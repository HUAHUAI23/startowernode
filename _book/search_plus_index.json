{"./":{"url":"./","title":"Introduction","keywords":"","body":"专题阅读 我从2016年开始系统学习编程之后，便一直零零散散的记录着各种各样的笔记。 其中收集过很多相关资料，但是一直没有汇集成册。 刚好最近比较有空闲，就将自己的学习笔记汇聚成册，希望能够给大家提供帮助。 整体笔风可能不是特别面向新手，但是也应该能够对你有所帮助。 涵盖3大编程语言：Python\\Golang\\JavaScript 涵盖4大数据库产品：MySQL\\Redis\\Elasticsearch\\MongoDB 关于系统着重使用MacOS 10.14.6以及CentOS 7.3，暂时不提供Windows的相关文章。 系统配置是Core i5 4核心4线程、16G RAM、256SSD，也算是比较老的配置了。 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-21 14:10:14 "},"杂谈专栏/summary.html":{"url":"杂谈专栏/summary.html","title":"杂谈专栏","keywords":"","body":"这一个专题更加的符合通用性，不拘泥于语言，或者说适用于大部分语言。 为什么命名为杂谈呢？因为实在是不好归类... Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-13 20:41:51 "},"杂谈专栏/编程语言区别.html":{"url":"杂谈专栏/编程语言区别.html","title":"编程语言区别","keywords":"","body":"低级语言 语言的高级和低级之分并不是说语言本身的层次高低，而是指的是与底层硬件的密切程度。 就如同机器语言与汇编语言就是直接与底层硬件打交道的语言，故也被称为低级语言。 机器语言 机器语言是不通过任何操作系统就可以直接与底层硬件打交道的语言，说白了就是计算机能读懂的二进制。 想要使用机器语言就得充分的了解计算机底层硬件的各个知识。 虽然这可能会花上你半生的时间，但是机器语言的执行效率却是无与伦比的高，计算机不需要通过任何编译就能直接运行。 与之相反的是机器语言的开发效率却是慢到令人发指，除了你需要去学习底层硬件相关的知识外还需要对每一条二进制指令烂熟于心，更加恐怖的是面对满屏的010101如果敲错一个字符就全部推倒重来，显然这已经超出了普通人所能承受的极限。 #指令部份的示例 0000 代表 加载（LOAD） 0001 代表 存储（STORE） ... ​ #暂存器部份的示例 0000 代表暂存器 A 0001 代表暂存器 B ... ​ #存储器部份的示例 000000000000 代表地址为 0 的存储器 000000000001 代表地址为 1 的存储器 000000010000 代表地址为 16 的存储器 100000000000 代表地址为 2^11 的存储器 ​ #集成示例 0000,0000,000000010000 代表 LOAD A, 16 0000,0001,000000000001 代表 LOAD B, 1 0001,0001,000000010000 代表 STORE B, 16 0001,0001,000000000001 代表 STORE B, 1[1] 名词 描述 执行效率 极高 开发效率 极低 跨平台性 极差（由于必须依赖具体的硬件，故移植性极差） 汇编语言 汇编语言仅仅是用一个英文标签代表一组二进制指令，毫无疑问，比起机器语言，汇编语言是一种进步，但汇编语言的本质仍然是直接操作硬件，因此汇编语言仍是比较低级/底层的语言、因为它十分的贴近计算机硬件。 汇编的中打印一句hello world，需要写十多行，如下： ; hello.asm section .data ; 数据段声明 msg db \"Hello, world!\", 0xA ; 要输出的字符串 len equ $ - msg ; 字串长度 section .text ; 代码段声明 global _start ; 指定入口函数 _start: ; 在屏幕上显示一个字符串 mov edx, len ; 参数三：字符串长度 mov ecx, msg ; 参数二：要显示的字符串 mov ebx, 1 ; 参数一：文件描述符(stdout) mov eax, 4 ; 系统调用号(sys_write) int 0x80 ; 调用内核功能 ; 退出程序 mov ebx, 0 ; 参数一：退出代码 mov eax, 1 ; 系统调用号(sys_exit) int 0x80 ; 调用内核功能 名词 描述 执行效率 极高 开发效率 低 跨平台性 极差（由于必须依赖具体的硬件，故移植性极差） 高级语言 高级语言并不关心底层硬件到底怎么样，因为高级语言是在和操作系统打交道。 而操作系统又是管控硬件的软件，所以高级语言相较于低级语言来说它的开发效率肯定是要快上不少，但是在执行效率上却有所损失。 对于语言的好坏一味的按照执行效率来区分并非是正确的，语言本身只是一种工具，使用语言的人才是真正的操纵者。 语言的对比只应场景适不适用，其本身并无强弱之分。 比如要对底层硬件进行开发，那么无疑汇编语言是最佳的选择，它能与本机硬件打交道所以能充分发挥自己执行效率高的特性，再比如要做一款网络爬虫相关的软件，由于网络具有延迟性会拖慢程序整体的运行速度，故使用汇编语言来编写爬虫便成了弱势（开发周期长，网络环境让汇编语言的高执行效率也体现不出来）。 高级语言中按照翻译方式的不同又大体可分为两类，分别是编译型语言与解释型语言。 编译型语言 如Golang，C语言等均为编译型语言。 编译型语言特点： 执行效率高：生成的目标文件可以脱离语言环境独立执行（因为都是存的二进制指令） 开发效率低：如果程序需要修改某一功能则必须修改源程序中的代码后再次生成目标程序，倘若只有目标程序而没有源程序的话则修改原本的功能是一件很困难的事情，这样做的好处是保证了代码的安全性，除开通过反编译技术手段否则看不见源代码 跨平台性差：大多数编译型语言的代码只针对某一个平台下进行编译，前平台下的编译结果（目标程序）无法拿到不同的平台上使用 其他：现在大多数的编程语言都是编译型的。编译程序（GCC）将源程序翻译成目标程序后保存在另一个文件中，该目标程序可脱离编译程序直接在计算机上多次运行。大多数软件产品都是以目标程序形式发行给用户的，不仅便于直接运行提升执行效率，同时又使他人难于盗用其中的技术 解释型语言 如Python，JavaScript均为解释型语言。 解释型语言特点： 执行效率低：在解释型语言的实现中，解释器并不产生目标机器代码，而是产生易于执行的中间代码。这种中间代码与机器代码是不同的，中间代码的解释是由软件支持的，不能直接使用硬件，软件解释器通常会导致执行效率偏低 开发效率高：用解释型语言编写的程序是由另一个可以理解中间代码的解释程序执行的，与编译程序不同的是，解释程序的任务是逐一将源程序的语句解释成可执行的机器指令，不需要将源程序翻译成目标代码再执行。解释程序的优点是当语句出现语法错误时，可以立即引起程序员的注意。让程序员在程序开发期间就能进行校正，故开发效率高于编译性语言 跨平台性强：代码运行是依赖于解释器，不同平台有对应版本的解释器，所以解释型语言的跨平台性更强 其他：对于解释型Basic语言，需要一个专门的解释器解释执行Basic程序，每条语句只有在执行时才被翻译，这种解释型语言每执行一次就翻译一次，因而效率低下。一般地，动态语言都是解释型的，例如：Tcl、Perl、Ruby、VBScript、JavaScript等 除此之外，还有一种混合型语言，如Java：Java语言首先会生成Java汇编，然后通过虚拟机进一步转换成计算机可以识别的二进制汇编语言。 动态与静态 动态类型：如果一门语言可以在运行时改变变量的类型，那我们称之为动态类型语言（如Python） 静态类型：相反，如果一门语言不可以在运行时改变变量的类型，则称之为静态类型语言（如Golang） 动态类型示例（Python演示）： >>> string = str(\"hello,world\") >>> type(string) >>> string = b\"\" >>> type(string) >>> 静态类型示例（Golang演示）： func main() { var str string str = \"hello,world\" fmt.Printf(\"%T\",str) str = 't' // 编译出现异常，不允许改变类型 } 强类型与弱类型 强类型：如果一门语言不倾向于对变量的类型做隐式转换，那我们将其称之为强类型语言（如Python） 弱类型：相反，如果一门语言倾向于对变量的类型做隐式转换，那我们则称之为弱类型语言（如JavaScript） 强类型示例（Python演示）： >>> 1 == \"1\" False 弱类型示例（JavaScript演示）： \"use strict\"; console.log(1 == \"1\"); // true Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-13 20:41:51 "},"杂谈专栏/详解字符编码.html":{"url":"杂谈专栏/详解字符编码.html","title":"详解字符编码","keywords":"","body":"字符编码 计算机使用计算机语言（2进制）表示数据，人类使用自然语言表示数据。 人类若想和计算机进行无障碍沟通，必须要通过一本记载着计算机语言与自然语言关系的词典。 而通过这本词典与计算机进行沟通交互的过程即可被称为字符的编码、解码的过程： 编码是指将自然语言转换为计算机语言的过程。 解码是指将计算机语言转换为自然语言的过程。 ASCII 计算机由西方世界发明，所以第一个字符编码表仅记录了一些英文与符号，该表也被称为ASCII码表。 它仅支持一些英文字符与特殊符号，不支持其他国家的语言字符。 实际上ASCII码表在设计之初，就预留了一些位置，最初的ASCII码表中每一个字符仅占用7bit的位置，也就最多表示128个字符。 最初的ASCII码表仅有128个字符，后来经过扩展，又新增了128个字符，此时的ASCII码表中，一个字符占用1Bytes（8bit）的位置。： GBK 随着计算机在世界范围内高速发展，ASCII码表已经不满足广大用户的需求了。 此时，各个国家开始推出自己的字符编码表，如： 日本的Shift-JIS表等 韩国的Euc-Kr表等 中国的gb2312、GBK表等 ... 这些表都有一个特点，即除了包含原本的ASCII码表之外还包含了本国的通用语言。 在GBK编码表中，一个英文字符占用1Bytes(8bit)，而一个中文字符则占用2Bytes(16bit)。 此时，出现了1个严重的问题，即跨国的通信问题，如下图所示： Unicode 为了解决这个问题，在1990年的时候推出了Unicode表，并且在1994年正式使用。 它详细的记录了所有自然语言与计算机语言的对应关系，在（usc2标准）中每一个字符不管是英文还是中文都占用2个Bytes（16bit），而在（usc4标准）中则统一占用4个Bytes（32bit），这样就解决了跨国通信的问题。 对比ASCII码表英文字符仅占用1个Bytes而言，如果直接使用Unicode编码进行文件存储则存储空间会直接翻倍，因此Unicode表仅存在于内存之中，而在网络传输以及文件存储上则采用了另外的编码格式。 换句话说，Unicode仅作为翻译词典存在于计算机内部，Unicode因为包含了所有自然语言与计算机语言的关系，因此作为翻译词典是最合适不过的。 UTF8 如下图，中文网站由GBK编码存储，国内的计算机中应该都有GBK编码，所以访问该网站非常轻松，而在日本计算机上若想访问该网站则必须要先下载GBK后方能以GBK的解码形式打开该网站，否则会产生乱码问题。 那么有没有一种编码，能够统一整个互联网，让所有计算机都用这种编码进行文件存储、网络传输呢？ 此时，出现了UTF8编码，全称为Unicode Transformation Format，即Unicode的转换格式，它是一种可变长的编码格式。 在UTF8编码格式中，英文字符统一占用1Bytes(8bit)的位置，而中文字符则占用3Bytes(24bit)或者4Bytes(32Bytes)的位置。 UTF8编码是未来的发展趋势，它与Unicode对比的唯一区别在于它不包含其他字符编码表。 在依然存在以GBK编码格式、Shift-JIS编码格式进行文件存储的环境下，使用UTF8作为翻译词典并不合适。 但是如果有一天所有人都统一使用UTF8进行文件存储网络传输的话，那么就不再需要包含其他字符编码表了，此时UTF8将会真正代替Unicode入驻内存中成为翻译词典，当然这是后话，目前还没有达到这样的理想情况。 UTF8的编解码 UTF8与Unicode的关系如下： 编码过程 如我们要将“云”字根据UTF8格式存储到磁盘中： 1.通过Python3中的hex()和ord()函数先得出该字符Unicode的16进制表现形式： >>> hex(ord(\"云\")) '0x4e91' 2.再将这个16进制的Unicode字符转换为2进制，那么这个2进制就是“云”字在内存中存储的样子： >>> bin(int(\"4e91\",base=16)) '0b100111010010001' 3.现在，计算机要把“云”字写入磁盘中，由于是使用的UTF8编码格式，所以先确定它的占用空间是3Bytes还是4Bytes，规则如下，套用表即可： 码位范围（Unicode十六进制） utf-8 0000 ~ 007F 用1个Bytes表示 0080 ~ 07FF 用2个Bytes表示 0800 ~ FFFF 用3个Bytes表示 4e91 在这里，第3分区 10000 ~ 10FFFF 用4个Bytes表示 4.确定了“云”字占用3Bytes，我们可以通过一个模板，将Unicode的2进制转换为UTF8的2进制： 码位范围（十六进制） 转换模板 0000 ~ 007F 0XXXXXXX 0080 ~ 07FF 110XXXXX 10XXXXXX 0800 ~ FFFF 1110XXXX 10XXXXXX 10XXXXXX 10000 ~ 10FFFF 11110XXX 10XXXXXX 10XXXXXX 10XXXXXX 5.根据分区信息，选用3Bytes的模板，进行转换，从右至左依次填充，不够的使用0进行填充： 1110XXXX 10XXXXXX 10XXXXXX 100 111010 010001 1110XXXX 10XXXXXX 10XXXXXX 0100 111010 010001 # 填充0 11100100 10111010 10010001 # 结果 所以最后得出的结果，“云”用UTF8格式保存至磁盘的话，2进制格式为11100100 10111010 10010001。 解码过程 如果要将“云”字UTF8的2进制格式转换为字符，则还是需要通过Unicode进行解码过程。 当计算机读取到这个文件是以UTF8格式进行存储后，内部已经做好了通过UTF8进行解码的准备。 开始读取后，计算机会将硬盘中存储的UTF8的2进制格式文字信息加载至内存中： 11100100 10111010 10010001 现在，Unicode会参照模板，通过UTF8分区信息提取出该文字Unicode的2进制格式： 码位范围（十六进制） 转换模板 0000 ~ 007F 0XXXXXXX 0080 ~ 07FF 110XXXXX 10XXXXXX 0800 ~ FFFF 1110XXXX 10XXXXXX 10XXXXXX 10000 ~ 10FFFF 11110XXX 10XXXXXX 10XXXXXX 10XXXXXX 11100100 10111010 10010001 “云”字的二进制信息格式刚好对应第3分区，那么我们按照第3分区的模板格式对UTF8的2进制表现形式进行掐头工作，将它转变为Unicode的2进制表现格式。 1110XXXX 10XXXXXX 10XXXXXX 11100100 10111010 10010001 0100 111010 010001 # 掐头 100111010010001 # 结果 得到了结果为100111010010001，现在可以通过一系列Python3函数将它转换为Unicode字符，转换过程如下所示： >>> int(\"100111010010001\",base=2) 20113 >>> hex(20113) '0x4e91' >>> \"\\u4e91\" '云' Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-13 20:41:51 "},"杂谈专栏/放一些常见题目.html":{"url":"杂谈专栏/放一些常见题目.html","title":"常见问题大全","keywords":"","body":"常见问题 Python 基础知识 %accordion%解释器版本升级%accordion% py2项目如何迁移成py3? 答案： six模块 使用py3自带的2to3.py工具将py2转换为py3 %/accordion% %accordion%值比较与引用比较%accordion% 聊聊is和==的区别？ 答案： is会判断2个对象是否来自同一引用 ==仅2个对象的判断表现形式是否相同 %/accordion% %accordion%内存管理%accordion% Python是如何进行内存管理的? Python的程序会内存泄漏吗?说说有没有什么方面阻止或检测内存泄漏 答案： python是使用私有堆进行内存管理的，我们无法访问，只能通过接口进行一些相关操作，python程序存在内存泄漏，主要是由于python是使用的引用计数的方式进行内存管理的，而如果重写__del__方法时声明了变量，因为计数还未变为0，所以会存在内存泄露。 阻止或检测的方法： 1. 程序员管理好每个python对象的引用，尽量在不需要使用对象的时候，断开所有引用 2. 尽量少通过循环引用组织数据，可以改用weakref做弱引用或者用id之类的句柄访问对象 3. 通过gc模块的接口可以检查出每次垃圾回收有哪些对象不能自动处理，再逐个逐个处理 %/accordion% %accordion%深浅拷贝%accordion% 简述Python深浅拷贝？ 答案： 不可变类型没有深浅拷贝，所有对不可变类型的深浅拷贝均是引用 所以深浅拷贝仅针对容器类型： 浅拷贝：仅拷贝容器的第一层，将不是不可变类型的对象都复制一份 深拷贝：递归的拷贝容器中所有层，将不是不可变类型的对象都复制一份 %/accordion% %accordion%循环打印乘法表%accordion% 用Python实现99乘法表(用两种不同的方法实现) 答案1： for i in range(1, 10): for j in range(1, 1 + i): print(\"{} * {} = {}\".format(i, j, i * j), end=\"\\t\") print(\"\") 答案2： i = 1 j = 1 while i %/accordion% %accordion%文件读取%accordion% 一个大小为100G的文件etl_log.txt, 要读取文件中的内容, 写出具体过程代码？ 答案： with open(\"fileName\", mode=\"rt\", encoding=\"utf8\") as f: for item in f: print(item) # file对象就是一个迭代器，具有惰性求值的功能 %/accordion% %accordion%计数器实现%accordion% 有一个数组[3, 4, 1, 2, 5, 6, 6, 5, 4, 3, 3] 请写一个函数, 找出该数组中没有重复的数的总和 ，例如上面数据的没有重复的总和为1+2=3。 答案： def add(seq): result = 0 saveTable = {} for item in seq: if item not in saveTable: saveTable[item] = 1 else: saveTable[item] += 1 for sumNumber in saveTable: if saveTable[sumNumber] == 1: result += sumNumber return result print(add([3, 4, 1, 2, 5, 6, 6, 5, 4, 3, 3])) %/accordion% 数据类型 %accordion%布尔类型判断%accordion% 下列哪种说法是错误的 除字典类型外, 所有标准对象均可用于布尔测试 空字符串的布尔值是False 空列表对象的布尔值是False 值为0的任何数字对象的布尔值是False 答案： 1 字典类型也能用于布尔测试 %/accordion% %accordion%字典的hash%accordion% 选择代码的运行结果： country_counter ={} def addone(country): if country in country_counter: country_counter[country ]+=1 else: country_counter[country ]= 1 addone(\"China\") addone(\"Japan\") addone(\"china\") print len(country_counter ) A:0 B:1 C:2 D:3 E:4 答案：D，China和china的hash值不同 %/accordion% %accordion%字典的key是否存在？%accordion% 如何判断一个字典中的key是否存在？方法越多越好 答案： dic = {chr(i):i for i in range(65, 65 + 26)} # 1 print(dic.get(\"A\")) # 2 print(\"A\" in dic) # 3 print(dic[\"A\"]) # 4 print(dic.pop(\"A\")) %/accordion% %accordion%列表推导式%accordion% 如何用一行代码生成[1, 4, 9, 16, 25, 36, 49, 64, 81, 100] ? 答案： print( [i ** 2 for i in range(1, 11)] ) %/accordion% %accordion%序列翻转%accordion% 翻转1个字符串，如”1234“翻转为”4321“： 答案： string = \"1234\" print(string[::-1]) print(str.join(\"\", list(reversed(string)))) %/accordion% %accordion%字典的setdefault()方法%accordion% 将列表内的元素,根据位数合并成字典，列表如下： lst = [1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 32769, 65536, 4294967296] 答案： lst = [1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 32769, 65536, 4294967296] dic = {} for i in lst: k = len(str(i)) # 如果不存在该键，这该键等同于一个空列表 dic.setdefault(k, []) dic[k].append(i) print(dic) %/accordion% 函数相关 %accordion%形参类型必须为不可变%accordion% 写出程序运行结果： def add_end(l=[]): l.append(\"end\") return l add_end() add_end() 答案： [\"end\"] [\"end\", \"end\"] %/accordion% %accordion%命名空间%accordion% 全局变量和局部变量的区别, 如何给function里面的一个全局变量赋值? 答案： 全局变量是指存放在global namespace中的变量，它允许在任何命名空间中访问 全局有效，全局存活 局部变量是指存放在local namespace中的变量，它仅允许在当前函数的运行时访问，同时，也允许该函数中嵌套定义的子函数在运行时访问 局部有效，局部存活。 function里面如果要对1个全局变量进行赋值，可使用global关键字，如： x = 1 def func(): global x x += 1 %/accordion% %accordion%标识符命名冲突问题%accordion% 请写出下面程序的运行结果： a = 1 def fun(a): a = 2 fun(a) print(a) a = [] def fun(a): a.append(1) fun(a) print(a) 答案： 1 [1] %/accordion% %accordion%lambda表达式？%accordion% 简述lambda表达式格式以及应用场景。 答案： 格式如下： lambda x, y : x + y 形参可以没有，不必显式return 常与内置函数搭配使用，如filter，map，sorted，max等 %/accordion% %accordion%多装饰器嵌套%accordion% 请给出下面代码片段的输出： def say_hi(func): def wrapper(*args, **kwargs): print(\"HI\") ret = func(*args, **kwargs) print(\"BYE\") return ret return wrapper def say_yo(func): def wrapper(*args, **kwargs): print(\"YO\") return func(*args, **kwargs) return wrapper @say_hi @say_yo def func(): print(\"ROCK & ROLL\") func() 答案： print(\"HI\") print(\"YO\") print(\"ROCK & ROLL\") print(\"BYE\") %/accordion% %accordion%生成器与普通函数的区别？%accordion% 解释生成器与函数的不同, 并实现和简单使用generator 答案： 当一个函数中具有yield关键字时，此函数即为生成器函数 区别如下： 普通函数加括号是立即调用函数，执行函数体内部代码 生成器函数加括号是返回一个生成器对象，必须通过for循环或者手动使用send(None)或者调用其下的next()方法进行启动 生成器函数比普通函数的运行栈帧会多一个保存当前函数挂起状态的C语言结构体，因为yield关键字之后会将函数状态进行挂起，而return直接会返回并将函数栈帧从系统调用栈中踢出来 生成器对象可以通过send()方法与生成器函数体中yield进行数据交互，而普通的函数则不行，一经return直接结束函数运行 值得一提的是低版本中，yield和return不能同时出现 def genFunc(): yield 1 yield 2 yield 3 genObject = genFunc() for item in genObject: print(item) %/accordion% %accordion%递归打印%accordion% 有一个多层嵌套的列表A=[1,2,[3,4,[\"434\",...]]], 请写一段代码遍历A中的每一个元素并打印出来 答案： def func(li): for item in li: if isinstance(item, list): func(item) else: print(item) func([1, 2, [3, 4, [\"434\"]]]) %/accordion% %accordion%sorted()函数中key参数的使用%accordion% 将以下字典按照value的大小进行排序： d = {\"a\": 26, \"g\": 20, \"e\": 20, \"c\": 24, \"d\": 23, \"f\": 21, \"b\": 25} 答案： d = {\"a\": 26, \"g\": 20, \"e\": 20, \"c\": 24, \"d\": 23, \"f\": 21, \"b\": 25} print(sorted(d, key=lambda k:d[k])) %/accordion% %accordion%zip的使用%accordion% 写代码 tupleA = (\"a\",\"b\",\"c\",\"d\",\"e\") tupleB = (1,2,3,4,5) RES = {\"a\":1,\"b\":2,\"c\":3,\"d\":4,\"e\":5} 写出由tupleA和tupleB得到res的及具体实现过程 答案： dict(zip(tupleA, tupleB)) %/accordion% %accordion%ord()和chr()使用%accordion% 写一个base62encode函数，实现62进制解码。 范围0-10，a-z，A-Z def base62encode(number): if number 61: raise ValueError(\"Must be between 0 - 61\") encodeTable = ( *[i for i in range(10)], *[chr(i) for i in range(97, 123)], *[chr(i) for i in range(65, 91)],) return encodeTable[number] print(base62encode(61)) # Z %/accordion% %accordion%生成器编写斐波拉契数列%accordion% 使用生成器编写fib函数，函数声明为fib(max)，输入一个参数max值，使得该函数可以这样调用： for i in range(0,100): print fib(1000) 并产生如下结果(斐波那契数列) 1, 1, 2, 3, 5, 8, 13, 21... 答案： def fib(max): count, currentValue, nextValue = 0, 0, 1 while count %/accordion% %accordion%IP地址转换%accordion% 请编写一个函数实现将IP地址转换成一个整数。 如 10.3.9.12 转换规则为： 10 00001010 3 00000011 9 00001001 12 00001100 再将以上二进制拼接起来计算十进制结果：00001010 00000011 00001001 00001100 = ？ 答案： def transformIpAddr(ip): bitIpList = list(map(lambda x: str(bin(int(x)))[ 2:].rjust(8, \"0\"), ip.strip().split(\".\"))) return int(\"\".join(bitIpList), base=2) print(transformIpAddr(\"10.3.9.12\")) %/accordion% %accordion%计时装饰器实现%accordion% 请实现一个装饰器, 限制该函数被调用的频率, 如10秒一次 答案： import datetime import time def warpper(s=10): def outer(func): nextRunTime = None def inner(*args, **kwargs): nonlocal nextRunTime nowTime = datetime.datetime.now() if nextRunTime is None or nowTime > nextRunTime: result = func(*args, **kwargs) nextRunTime = datetime.timedelta(seconds=s) + nowTime return result print(nextRunTime - nowTime) return inner return outer @warpper(10) def func(): print(\"run...\") for i in range(10): time.sleep(2) func() %/accordion% %accordion%可迭代对象%accordion% 下列数据结构中,哪一种是不可迭代的 A. dict B. object C. set D. str 答案： B %/accordion% 算法与数构 %accordion%哈希冲突回避算法有哪几种, 分别有什么特点？%accordion% 开放定址法： 所谓的开放定址法就是一旦发生了冲突，就去寻找下一个空的散列地址，只要散列表足够大，空的散列地址总能找到，并将记录存入 再哈希法： 再哈希法又叫双哈希法，有多个不同的Hash函数，当发生冲突时，使用第二个，第三个，….，等哈希函数 计算地址，直到无冲突。虽然不易发生聚集，但是增加了计算时间。 链地址法： 链地址法的基本思想是：每个哈希表节点都有一个next指针，多个哈希表节点可以用next指针构成一个单向链表，被分配到同一个索引上的多个节点可以用这个单向链表向后排列。 建立公共溢出区： 这种方法的基本思想是：将哈希表分为基本表和溢出表两部分，凡是和基本表发生冲突的元素，一律填入溢出表 %/accordion% 模块相关 %accordion%pip命令的使用%accordion% 如何安装第三方模块？ 答案： pip install module name %/accordion% %accordion%datetime模块%accordion% 输入某年某日, 判断这是这一年的第几天?(可以用Python的内置模块) 答案： import datetime def dayofyear(): year = input(\"请输入年份：\") month = input(\"请输入月份：\") day = input(\"请输入天：\") date1 = datetime.date(year=int(year),month=int(month),day=int(day)) date2 = datetime.date(year=int(year),month=1,day=1) return (date1 - date2).days + 1 print(dayofyear()) %/accordion% %accordion%random使用%accordion% 如何生成一个随机数？ 答案： random.random() 生成0-1之间的随机小数。 %/accordion% %accordion%sys与模块路径查找%accordion% sys.path.append(\"/root/mods\")的作用？ 答案： 添加/root/mods路径至硬盘模块查找中 %/accordion% %accordion%os模块应用%accordion% 如何用Python删除1个文件？ os.remove() %/accordion% %accordion%文件递归%accordion% 写代码实现查看一个目录下的所有文件。 答案： import os def pathRecursion(path): print(path) if os.path.isdir(path): for subPath in os.listdir(path): pathRecursion(os.path.join(path, subPath)) pathRecursion(os.path.abspath(os.getcwd())) %/accordion% %accordion%JSON转中文%accordion% json序列化时，默认遇到中文会转换成unicode，如果想要保留中文怎么办？ 答案： 序列化时添加参数： ensure_ascii=False %/accordion% %accordion%JSON扩展%accordion% json序列化时，可以处理的数据类型有哪些？如何定制支持datetime类型？ 答案: json序列化只能序列化Python基本数据类型。 如果要想序列化非Python基本数据类型，则可以使用参数cls进行定制，详情参见Python模块一章。 json.dumps(data, cls=自己写的类) %/accordion% %accordion%简述logging模块作用%accordion% logging模块的作用？以及应用场景？ 答案： 日志记录 %/accordion% %accordion%正则表达式贪婪匹配%accordion% 什么是正则的贪婪匹配？或 正则匹配中的贪婪模式与非贪婪模式的区别？ 答案： *+?{n, m}都是贪婪模式，即有多个的时候匹配多个。 通过?可取消贪婪模式，即及时有多个也取最少的 %/accordion% %accordion%正则表达式%accordion% 请写出以字母或下划线开始, 以数字结束的正则表达式 答案： import re result = re.search(pattern=r\"^[A-Za-z0-9_].*\\d$\", string=\"321\") print(result.group()) %/accordion% %accordion%re模块中search和match的区别？%accordion% 请问re模块中search()和match()有什么区别？ 答案： search和match都有1个共同点，即只会成功匹配1次 不同点在于match只会匹配开头，相当于search基础上加了^ %/accordion% %accordion%如何判断一个邮箱是否合法？%accordion% 如何判断一个邮箱是否合法？ 答案： ^[a-zA-Z0-9_-]+@[a-zA-Z0-9_-]+(\\.[a-zA-Z0-9_-]+)+$ %/accordion% %accordion%itertools模块%accordion% 写代码：用户输入一个字符串，打印该字符串的所有不重复排列组合。 答案： from itertools import permutations a = input() for i in permutations(a, len(a)): print(''.join(i)) %/accordion% 面向对象 %accordion%简述oop三大特性%accordion% 请简述oop三大特性。 答案： 封装：将代码封装起来，只留下接口，通过接口访问对象 继承：实现多复用，子类的公用方法和属性可以从父类继承，减少代码冗余 多态，面向对象最灵活的地方，可以动态绑定，一种事物，多种形态，也称鸭子类型 %/accordion% %accordion%类变量和实例变量的区别%accordion% 请简述类变量和实例变量的区别。 答案： 实例变量仅存在实例对象的内存空间，类是无法调用实例变量。 类变量 存在整个类对象的内存空间，所有该类实例化出来的对象都可以调用到这些变量 %/accordion% %accordion%类与实例作用域%accordion% 以下代码输出是什么? 请给出答案并解释： class Parent(object): x = 1 class Child1(Parent): pass class Child2(Parent): pass print Parent.x, Child1.x, Child2.x Child1.x = 2 print Parent.x, Child1.x, Child2.x Parent.x = 3 print Parent.x, Child1.x, Child2.x 答案： 1 1 1 1 2 1 3 2 3 详情参见类与对象一篇，类与实例命名空间和标识符查找顺序。 %/accordion% %accordion%类方法与静态方法%accordion% 请简单解释Python中的static method(静态方法)和class method(类方法),并将以下代码填写完整 class A(object): def foo(self,x) print 'executing foo(%s, %s)'%(self,x) @classmethod def class_foo(cls,x): print 'executing class_foo(%s, %s)'%(cls,x) @staticmethod def static_foo(x): print 'executing static_foo(%s)'%(x) a= A() # 调用foo函数,参数传入1 ____________________ # 调用class_foo函数,参数传入1 ____________________ # 调用static_foo函数,参数传入1 答案： @classmethod：类的绑定方法，只能由类调用 @staticmethod：类的静态方法，类和instance都能调用 a.foo(1) A.class_foo(1) A.static_foo(1) a.static_foo(1) %/accordion% %accordion%上下文管理机制%accordion% 有用过with statement（语句）吗？它的好处是什么？ 答案： 上下文管理，with完成后自动调用__exit__(). 故可以在__exit__()中关闭系统占用资源 %/accordion% %accordion%上下文管理器实现%accordion% 参考下面代码片段 class Context: pass with Content() as ctx: ctx.do_something() 请在Context类下添加代码完成该类的实现 答案： class Context: def __enter__(self): print(\"run .. enter\") return self def __exit__(self,exc_type,exc_val,exc_tb): print(\"run .. exit\") return self def do_something(self): print(\"run .. do something\") return self with Context() as ctx: ctx.do_something() %/accordion% %accordion%super()方法%accordion% super()的作用？ 答案： 根据mro属性查找顺序列表来依次访问父类、超类、基类。 达到方法借用的目的。 %/accordion% %accordion%单例模式%accordion% 实现一个Singleton单例类, 要求遵循基本语言编程规范（用尽量多的方式）。 方式1，元类实现： class MetaClass(type): def __call__(self, *args, **kwargs): \"\"\" self : class Singleton \"\"\" if not hasattr(self, \"ins\"): insObject = super(__class__, self).__call__(*args, **kwargs) setattr(self, \"ins\", insObject) return getattr(self, \"ins\") class Singleton(object, metaclass=MetaClass): pass if __name__ == \"__main__\": ins = Singleton() print(id(ins)) ins = Singleton() print(id(ins)) 方式2，继承实现： class ParentClass: def __new__(cls, *args, **kwargs) -> object: \"\"\" cls : class Singeton \"\"\" if not hasattr(cls, \"ins\"): insObject = super(__class__, cls).__new__(cls, *args, **kwargs) setattr(cls, \"ins\", insObject) return getattr(cls, \"ins\") class Singleton(ParentClass): pass if __name__ == \"__main__\": ins = Singleton() print(id(ins)) ins = Singleton() print(id(ins)) 方式3，装饰器实现： def warpper(clsObject): def inner(*args, **kwargs): if not hasattr(clsObject, \"ins\"): insObject = clsObject(*args, **kwargs) setattr(clsObject, \"ins\", insObject) return getattr(clsObject, \"ins\") return inner @warpper class Singleton: pass if __name__ == \"__main__\": ins = Singleton() print(id(ins)) ins = Singleton() print(id(ins)) 方式4，模块实现： - foo.py --> ins = Singleton() - bar.py --> from foo import ins 方式5，@classmethod实现单例模式： class Singleton: @classmethod def getSingletonInstanceObject(cls, *args, **kwargs): if not hasattr(cls, \"ins\"): insObject = cls(*args, **kwargs) setattr(cls, \"ins\", insObject) return getattr(cls, \"ins\") if __name__ == \"__main__\": ins = Singleton.getSingletonInstanceObject() print(id(ins)) ins = Singleton.getSingletonInstanceObject() print(id(ins)) %/accordion% %accordion%双下方法举例%accordion% 列举面向对象中带双下划线的特殊方法。 答案： __getitem__ __setitem__ __delitem__ __getattr__ __setattr__ __delattr__ __continar__ .. %/accordion% %accordion%isinstance和type%accordion% 简述isinstance()和type()的区别。 答案： isinstance判断一个对象是否来自于一个类的实例，返回布尔值 type用于返回指定实例的类型，返回类对象本身 %/accordion% %accordion%简述duke type%accordion% 什么是鸭子类型？ 答案： 如果它走起来像鸭子，而且叫起来像鸭子，那么它就是鸭子 也就是说，我们只关注对象行为而不关注对象本身 %/accordion% %accordion%单下划线和双下划线的区别？%accordion% 简述单下划线开头的变量名和双下滑先开的变量名有什么区别？ 答案： 单下划线开头的变量名逻辑上是私有变量，即不推荐外部进行访问，但是外部仍然可以访问到，并未对变量名本身做任何处理。 双下划线开头的变量名逻辑上是私有变量，即禁止外部进行访问，会将变量名重命名，规则为 _类名.__变量名 %/accordion% %accordion%简述mro%accordion% mro是什么？有什么作用？如何获取？ 答案： mro是属性查找顺序列表，由c3算法生成。 仅新式类具有该属性，经典类没有。 调用方式： className.mro() or className.__mro__ %/accordion% %accordion%可调用对象%accordion% python中如何判断一个对象是否可调用? 那些对象可以是可调用对象?如何定义一个类, 使其对象本身就是可调用对象? 答案： 使用callable(Object)判断一个对象是否可调用 函数，类都是可调用对象 如果想 className() ，则需要在其metaclass中定义 __call__() 方法， 如果想instanceName()， 则需要在其实现类中定义 __call__() 方法 %/accordion% 格式 %accordion%Some title here%accordion% Any content here %/accordion% Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-13 20:41:51 "},"Python/summary.html":{"url":"Python/summary.html","title":"Python专栏","keywords":"","body":" Python快速入门 Python基础知识 Python函数相关 Python模块与包 Python面向对象 Python数算基础 Python设计模式 Python网络编程 Python并发编程 Python驱动程序 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-07-07 19:43:36 "},"Python/Python快速入门/summary.html":{"url":"Python/Python快速入门/summary.html","title":"Python快速入门","keywords":"","body":" Python简介 Python安装 pip简单使用 Python虚拟环境 Python常用工具 PEP8规范说明 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-13 20:41:50 "},"Python/Python快速入门/Python简介.html":{"url":"Python/Python快速入门/Python简介.html","title":"Python简介","keywords":"","body":"Python简述 Python诞生于1989年圣诞节，由仁慈的独裁者（Benevolent Dictator For Life，缩写BDFL）吉多·范罗苏姆（Guido van Rossum）基于C语言开发。 Python的名字来源于龟叔（Guido van Rossum在Python界的爱称）十分喜欢的一部名为Monty Python's Flying的电视剧，一想到这个风靡全球的编程语言名字居然来的这么随意，不禁让人哑然失笑。 作为一门解释性的动态强类型语言，Python的开发效率奇高，因此在Python界流传着这样一句至理名言： 人生苦短，我用Python Python并不是毫无缺点的孩子，作为一门动态语言，它的执行效率是偏低的。 作为80年代的产物，它的并发性支持也可能不太好，但是这并不妨碍我们对它的热爱，相信只要拥入Python的怀抱你一定会爱上这一门优雅的语言。 Python解释器 由于是动态语言，Python在代码执行时必须先将代码转换为字节码，然后通过字节码再转换为机器可读的机器码。 而解释器就是负责这一切工作的小蜜蜂。 我们常说的Python是基于C语言开发而来的CPython，除此之外还有基于Java开发而来的Jython、以及基于C#开发而来的IronPython。 不论是Jython还是IronPython，我们在学习时都不会去考虑，而是统一选择CPython，因为它们相较于传统的CPython多了一个转换环节所以会导致执行效率的降低。 低效率的执行 动态语言是逐行翻译，我们可以将它理解为一种边跑边看的策略。 这样做的后果是方便代码排查，缺点是拉低执行效率。 常见的Python解释器（包括CPython）等都是采用这种策略，故Python的执行效率一直被人诟病。 PyPy解释器 熟悉Python的朋友都知道，有一款Python解释器打破了人们对于Python低执行效率的印象。 它就是PyPy解释器，PyPy是另一个Python解释器，它的目标是执行速度。 PyPy采用JIT技术，对Python代码进行动态编译（注意不是解释），所以可以显著提高Python代码的执行速度。 绝大部分Python代码都可以在PyPy下运行，但是PyPy和CPython有一些是不同的，这就导致相同的Python代码在两种解释器下执行可能会有不同的结果。 如果你的代码要放到PyPy下执行，就需要了解PyPy和CPython的不同点。 你可以简单的这么理解： 代码第一次运行时：进行动态编译，生成目标文件 代码第二次运行时：使用目标文件进行运行，没必要再进行逐行翻译，故执行效率提升 如果你需要较高的执行效率，可以选用该解释器，但是本专题中不会使用它。 因为PyPy终究不是正统，所以对很多第三方库的依赖性和兼容性不如CPython。 版本介绍 由于我们平常讲的Python实际上都为CPython，故我们接下来的学习也是围绕CPython（以下简称Python）展开的。 目前Python版本已经更迭到了3.9。 以下是Python的发展历程： 1989年，Guido开始写Python语言的解释器。 1991年，第一个Python解释器诞生，它是用C语言实现的，并能够调用C语言的库文件。 从一出生，Python已经具有了：类，函数，异常处理，包含表和词典在内的核心数据类型，以及模块为基础的拓展系统。 Granddaddy of Python web frameworks, Zope 1 was released in 1999 Python 1.0 - January 1994 增加了 lambda, map, filter and reduce. Python 2.0 - October 16, 2000，加入了内存回收机制，构成了现在Python语言框架的基础 Python 2.4 - November 30, 2004, 同年目前最流行的WEB框架Django诞生 Python 2.5 - September 19, 2006 Python 2.6 - October 1, 2008 Python 2.7 - July 3, 2010 In November 2014, it was announced that Python 2.7 would be supported until 2020, and reaffirmed that there would be no 2.8 release as users were expected to move to Python 3.4+ as soon as possible Python 3.0 - December 3, 2008 Python 3.1 - June 27, 2009 Python 3.2 - February 20, 2011 Python 3.3 - September 29, 2012 Python 3.4 - March 16, 2014 Python 3.5 - September 13, 2015 Python 3.6 - 2016-12 Python 3.7 - 2018 Python 3.8 - 2019 ... 细心的读者会发现，08年时就推出了3.0，2010年反而又推出了2.7？ 这是因为3.0不向下兼容2.0，而很多公司已经基于2.0版本开发出了大量程序，公司已然投入了大量的人财物力，这就导致大家都拒绝升级3.0，无奈官方只能推出2.7过渡版本，之后我们都应该采用3.0解释器开发程序，但为了方便读者维护2.0版本的软件，在遇到两种版本的差异时会专门指出来。 应用方向 Python的应用领域十分广泛，如：人工智能，数据处理，爬虫，金融量化，云计算，WEB开发，自动化运维/测试，游戏开发，网络服务，图像处理等众多领域。 并且国内外很多知名的企业也都在使用Python，如：Youtube、DropBox、BT、Quora（中国知乎）、豆瓣、知乎、Google、Yahoo、FaceBook、NASA、百度、腾讯、汽车之家、美团等等。 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-13 20:41:50 "},"Python/Python快速入门/Python安装.html":{"url":"Python/Python快速入门/Python安装.html","title":"Python安装","keywords":"","body":"本机示例 虽然目前的Python版本已经更迭到了3.9，但是在这里将会使用Python3.6.8来进行开发。 Python3.6系列应该是目前使用最为广泛的一个版本系列，相较于最新版的3.9来说它支持的库更多、兼容性更好。 需要注意的是在类Unix平台中，Python2版本已经自带，所以我们只需安装Python3.6即可。 MAC安装 MAC下有源码安装Source，和界面化.pkg安装，我们选择pkg安装。 第一步：打开Python官网，点我跳转： 第二步，下载对应版本的pkg安装程序： 第三步，一直点击下一步即可： 上述的安装方式会自动将Python安装至以下目录： /Library/Frameworks/Python.framework/Versions/3.6/ 安装完成之后系统会自动的将常用软件ln -s到/usr/local/bin中： $ ls /usr/local/bin/ | grep p.*3 pip3 pip3.6 pydoc3 pydoc3.6 python3 python3-config python3.6 python3.6-config python3.6m python3.6m-config pyvenv-3.6 Linux安装 Linux下有源码安装Source，和免编译安装Binary，我们选择免编译安装。 第一步，下载gcc工具： $ yum install gcc gcc-c++ -y 第二步，下载wget工具： $ yum install wget -y 第三步，下载Python3.6.8的Binary版本： $ cd ~ $ wget https://www.python.org/ftp/python/3.6.8/Python-3.6.8.tgz 第五步，将归档文件tgz解压至当前目录： $ > tar xvf Python-3.6.8.tgz -C ./ $ > ls anaconda-ks.cfg Python-3.6.8 Python-3.6.8.tgz 第六步，进入解压的目录中，进行编译安装（由于CPython基于C语言，而C语言又是编译性语言，故需要进行编译后安装）： $ > cd Python-3.6.8 $ > ./configure --prefix=/usr/local/Python36 $ > make $ > make install 第七步，添加环境变量： $ vim /etc/profile # 写入内容 export PATH=/usr/local/Python36/bin:$PATH $ source /etc/profile 交互测试 安装完成之后，分别在shell中输入python（自带的版本）以及python3，查看是否能进入交互式环境中。 如果能成功进入则按照成功，如果不能请谷歌排查原因。 若想退出交互式环境，输入exit()即可： $ python Python 2.7.10 (default, Feb 22 2019, 21:55:15) [GCC 4.2.1 Compatible Apple LLVM 10.0.1 (clang-1001.0.37.14)] on darwin Type \"help\", \"copyright\", \"credits\" or \"license\" for more information. >>> exit() $ python3 Python 3.6.8 (v3.6.8:3c6b436a57, Dec 24 2018, 02:04:31) [GCC 4.2.1 Compatible Apple LLVM 6.0 (clang-600.0.57)] on darwin Type \"help\", \"copyright\", \"credits\" or \"license\" for more information. >>> exit() Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-13 20:41:50 "},"Python/Python快速入门/pip简单使用.html":{"url":"Python/Python快速入门/pip简单使用.html","title":"pip简单使用","keywords":"","body":"pip工具 pip是Python的包管理工具，该工具提供了对Python第三方包的查找、下载、安装、卸载等功能。 Python 2.7.9+ 或 Python 3.4+ 以上版本都自带pip工具，在安装Python时会一并安装。 如果你安装了两个版本的Python，则对应的pip命令就是pip2或者pip3。 $ ls /usr/local/bin/pip* /usr/local/bin/pip /usr/local/bin/pip2 /usr/local/bin/pip2.7 /usr/local/bin/pip3 /usr/local/bin/pip3.6 Ps：类似于NodeJS的NPM 常用命令 在shell中可使用的pip常用命令如下： 命令 描述 pip --version 显示版本和路径 pip --help 获取帮助 pip install -U pip pip升级 pip install 包名 安装包 pip install --upgrade 包名 升级包 pip uninstall 包名 卸载包 pip search 包名 搜索包 pip list 查看所有已安装的包 pip list -o 查看所有可升级的包 pip升级 使用以下命令进行pip工具进行升级： Windows平台： $ python -m pip install -U pip # python2.x $ python -m pip3 install -U pip # python3.x Linux&Mac平台： $ pip install --upgrade pip # python2.x $ pip3 install --upgrade pip # python3.x 换源配置 pip下载的包默认是从国外源下载，速度较慢，因此可以为其设置为国内源（阿里云）。 下面介绍类Unix平台与Windows平台的换源方式。 Windows 直接在user目录中创建一个pip目录，如：C:\\Users\\username\\pip，新建文件pip.ini，然后填入以下内容： [global] index-url = https://mirrors.aliyun.com/pypi/simple Unix 类Unix平台需要依次运行如下命令： $ cd ~ # 进入用户家目录 $ mkdir .pip # 创建隐藏文件夹 $ vim .pip/pip.conf # 创建pip3的配置文件 然后在配置文件pip.conf中填入以下内容： [global] index-url = https://mirrors.aliyun.com/pypi/simple Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-13 20:41:50 "},"Python/Python快速入门/Python虚拟环境.html":{"url":"Python/Python快速入门/Python虚拟环境.html","title":"Python虚拟环境","keywords":"","body":"虚拟环境 虚拟环境是真实的Python解释器的一份拷贝。 由于真实的Python解释器可能在不断的添加各种第三方库，而我们的项目中又没有用到这些库所以就会造成一个环境的污染，可能会造成打包exe文件后体积过大等问题。 一个项目的环境干净是十分重要的，而虚拟环境就是为了净化项目环境而生的一种措施。 我们在这里使用virtualenv与virtualenvwrapper这两个第三方模块来更加方便的管理我们的虚拟环境。 Windows 需要使用两个第三方模块，在终端中使用pip3命令下载安装： $ pip3 install virtualenv $ pip3 install virtualenvwrapper-win 创建虚拟环境工作目录，新建一个文件夹，从此之后所有的虚拟环境都会存放至该文件夹下： $ D: mkdir .virtualenvs 然后需要配置虚拟环境工作目录： 打开环境变量，在用户变量中新建，变量名为WORKON_HOME，值为虚拟环境的配置路径，即.virtualenvs的路径 打开原本的Python3环境安装目录，找到Scripts文件夹，双击执行其下的virtualenvwrapper.bat Linux&Mac 需要使用两个第三方模块，在shell中使用pip3命令下载安装： $ pip3 install -i https://pypi.douban.com/simple virtualenv $ pip3 install -i https://pypi.douban.com/simple virtualenvwrapper 创建虚拟环境工作目录，新建一个文件夹，从此之后所有的虚拟环境都会存放至该文件夹下： $ mkdir ~/.virtualenvs 配置环境变量，编辑userHome/.bash_profile文件，如果是Mac用户且终端为zsh，则配置userHome/.zshrc文件，新增以下内容： # Setting virtual environment save path # 填入你的虚拟环境存放目录 export WORKON_HOME=\"~/.virtualenvs\" # Setting virtual environment copy python path # 填入你的真实Python3解释器路径，用于虚拟环境的拷贝 export VIRTUALENVWRAPPER_PYTHON=/Library/Frameworks/Python.framework/Versions/3.6/bin/python3.6 # Setting virtualenvwrapper.sh run path # 填入virtualenvwrapper.sh的脚本路径 source /Library/Frameworks/Python.framework/Versions/3.6/bin/virtualenvwrapper.sh 最后刷新一下该文件的配置： $ source ~/.bash_profile 命令概览 shell中可指定的命令如下： 命令 描述 workon 列出所有虚拟环境 mkvirtualenv -p python3 虚拟环境名字 创建新的虚拟环境 rmvirtualenv 虚拟环境名字 删除指定的虚拟环境 workon 虚拟环境名字 使用指定的虚拟环境 示例演示，创建一个LearnPython的虚拟环境： $ mkvirtualenv -p python3 LearnPython $ workon 现在你会发现，shell的提示符改变了： (LearnPython) YunYadeMacBook-Pro:~ yunya$ Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-13 20:41:50 "},"Python/Python快速入门/Python常用工具.html":{"url":"Python/Python快速入门/Python常用工具.html","title":"Python常用工具","keywords":"","body":"运行方式 REPL交互式 REPL名为交互式解释器（Read Eval Print Loop），提供了一个CLI(command-line interface:命令行界面)下读取值、求值、输出值、循环代码的环境。 这种交互式的方式会经常用到，适用于快速的进行一些功能测试，如函数传参、求值测试等。 现在让我们以REPL交互式来运行第一条Python代码，在shell中进行执行： $ python3 >>> print(\"hello world\") hello world >>> 如果要退出REPL环境，则使用exit()即可。 脚本调用式 外部调用 在一个文件中，书写好Python代码后进行调用的方式被称为脚本调用式。 也是非常常用的一种方式，通常文件后缀名以py结尾，标识这是一个Python脚本文件。 使用Python调用脚本时，其实并不关心文件后缀名是什么，后缀名更多的作用是给使用者看的，便于区分不同类型的文件 $ echo \"print('hello world')\" > helloWorld.py $ python3 helloWorld.py hello world 在此示例中我们使用Python3的解释器在外部对其进行调用，并执行了其中的代码打印了hello world。 内部调用 除开外部调用，我们也可以在脚本内部指定Python解释器，并通过./进行代码执行，对上述文件内容进行修改： #!/usr/bin/env python3 print('hello world') 修改完成并保存，再修改文件的执行权限： $ chmod 775 helloWorld.py 直接使用./进行代码执行： $ ./helloWorld.py hello world 使用内部调用需要注意：指定Python解释器的语句一定要放在文件头部，因此该代码也被称为头文件代码。 常见的头文件代码除开指定Python解释器以外，还有指定解释器解码格式、声明作者和日期等，如下所示： #!/usr/bin/env python3 # -*- coding:utf-8 -*- # author: YunYa # date: 2017-01-28 头文件代码调用说明：env是类Unix平台的环境变量别称，当我们在头文件代码中指定/usr/bin/env python3的时候，它内部会运行env | grep python3，找到python3解释器，并对文件进行执行，前提是该文件必须具有可执行权限。 $ env | grep python3 VIRTUALENVWRAPPER_PYTHON=/Library/Frameworks/Python.framework/Versions/3.6/bin/python3.6 执行过程 一个Python程序被解释器解释并执行，可粗略的分为三个步骤： 启动Python解释器 Python解释器发起系统调用，将脚本内容载入内存，此时并不会做任何处理 Python解释器开始识别Python语法，解释并执行内存中存储的脚本文件内容 IDE介绍 IDE简介 IDE的全称是Integrated Development Environment，即集成开发环境。 它是一种辅助程序开发人员开发软件的应用软件，在开发工具内部就可以辅助编写源代码文本、并编译打包成为可用的程序，有些甚至可以设计图形接口。 如果单纯的touch出一个文本，并在其内部书写代码是很容易出现问题的。 没有语法高亮，这意味着某个字符少打了、某个单词拼错了都不能被及时发现，并且这样学习对新手难度极大 没有debug功能，当业务逻辑越来越复杂时，程序不可避免的会出现一些bug，此时如果没有debug程序来检测出现问题的原因，整个排查的过程将变的异常艰难 而使用IDE开发则可以完全避免这些问题。 Python IDLE Python自带了一款类似的工具，名为Python IDLE，是Python的集成开发和学习环境。 官方文档：https://docs.python.org/3/library/idle.html 它自带了2种模式，一种是REPL交互模式，一种是脚本调用模式。 当你打开它后默认会进入REPL交互模式，此时只需要新建一个文件即可开始编写我们的代码。 CTRL+N：新建文件 CTRL+S：保存文件 F5：运行程序 可以发现，当我们想使用print()功能时，它会提示该功能需要哪些参数： 当编写完代码后，即可使用F5来进行文件的保存与运行，如下所示： IDLE适用于刚入门起步学习Python的同学，但对于大的项目构建来说还是十分的不方便。 推荐指数：⭐️⭐️⭐️ PyCharm PyCharm是由JetBrains公司开发，也是最受欢迎的Python IDE工具。 官方网站：https://www.jetbrains.com/pycharm/ 优点是功能强大，你能想到的不能想到的它都给你提供了。 缺点是收费，并且软件本身比较臃肿，但是比起它的优秀来说这些缺点可以忽略不计。 推荐指数：⭐️⭐️⭐️⭐️⭐️ VsCode VsCode是由Microsoft Corporation开发，是近年来最火的一款轻量级编辑器。 官方网站：https://code.visualstudio.com/ 优点是支持多语言，Golang、C、Python等手到擒来，此外它是完全免费的。 缺点是配置比较繁琐，对新手不太友好。 推荐指数：⭐️⭐️⭐️⭐️ 个人使用 我自己平常写一些小的脚本，会首选VsCode，若是要搭建一些比较大型的项目，则会选择PyCharm。 在这里并没有详细指出每种工具的安装，因为互联网上类似的教程太多了。 推荐在初次接触Python时，建议统一使用Python IDLE，因为PyCharm本身会对Python许多地方做出优化，而恰好这些优化对新手并不友好。 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-13 20:41:50 "},"Python/Python快速入门/PEP8规范说明.html":{"url":"Python/Python快速入门/PEP8规范说明.html","title":"PEP8规范说明","keywords":"","body":"PEP8规范 每种语言都有其一种特定的书写规范，而PEP8规范则是Python中的书写规范。 以下的内容对于初学者来说可能会显得有些超纲，但是我为什么要将它放在第一章呢？就是为了警示你书写规范其实很重要。 尽管现在你可能看不懂，但是没有关系，你看得懂的时候就一定要去学会遵守它。 Ps：其实我自己就是一个不太遵守规范的家伙... 缩进与续行 每一级缩进使用4个空格，而不是使用table def main(): print(\"hello,world\") # --- def main(): print(\"hello,world\") 续行应该与其包裹元素对齐，要么使用圆括号、方括号和花括号内的隐式行连接来垂直对齐，要么使用挂行缩进对齐 def main( param1, param2, param3, param4 ): print(\"hello,world\") # --- def main(param1, param2, param3, param4 ): print(\"hello,world\") 分割与宽度 每行最大的字符数不可超过79，文档字符或者注释每行不可超过72 def main(): # this is a test function ... # this is a test function ... # this is a test function ... print(\"hello,world\") # --- def main(): # this is a test function ... this is a test function ... this is a test function ... print(\"hello,world\") 顶层函数和类的定义，前后用两个空行隔开，类里的方法定义用一个空行隔开 模块的导入 导入不同模块，应当进行分行 导入模块的位置应当总是位于文件顶部，且在头文件代码之后 标准库导入放最前、相关第三方库导入放其次，而后是本地库导入 每一组导入语句之间加入空行分割，以区分是内置库、三方库、还是自建库 推荐使用绝对导入 import sys import os # --- import sys, os 注释 在更改代码之前，推荐先更改注释 释应该是完整的句子。如果一个注释是一个短语或句子，它的第一个单词应该大写，除非它是以小写字母开头的标识符(永远不要改变标识符的大小写！) 如果注释很短，结尾的句号可以省略。块注释一般由完整句子的一个或多个段落组成，并且每句话结束有个句号 在句尾结束的时候应该使用两个空格 当用英文书写时，遵循Strunk and White （译注：《Strunk and White, The Elements of Style》）的书写风格 在非英语国家的Python程序员，请使用英文写注释，除非你120%的确信你的代码不会被使用其他语言的人阅读 块注释通常适用于跟随它们的某些（或全部）代码，并缩进到与代码相同的级别。块注释的每一行开头使用一个#和一个空格（除非块注释内部缩进文本）。 块注释内部的段落通过只有一个#的空行分隔 有节制地使用行内注释 行内注释是与代码语句同行的注释。行内注释和代码至少要有两个空格分隔。注释由#和一个空格开始 文档字符串 要为所有的公共模块，函数，类以及方法编写文档说明 非公共的方法没有必要，但是应该有一个描述方法具体作用的注释。这个注释应该在def那一行之后 PEP 257描述了写出好的文档说明相关的约定。特别需要注意的是，多行文档说明使用的结尾三引号应该自成一行，例如： \"\"\"Return a foobang Optional plotz says to frobnicate the bizbaz first. \"\"\" 对于单行的文档说明，尾部的三引号应该和文档在同一行 命名规范 应该避免的名字 永远不要使用字母‘l’（小写的L），‘O’（大写的O），或者‘I’（大写的I）作为单字符变量名 在有些字体里，这些字符无法和数字0和1区分，如果想用‘l’，用‘L’代替 类名 类名一般使用首字母大写的约定 在接口被文档化并且主要被用于调用的情况下，可以使用函数的命名风格代替 注意，对于内置的变量命名有一个单独的约定：大部分内置变量是单个单词（或者两个单词连接在一起），首字母大写的命名法只用于异常名或者内部的常量 函数名 函数名应该小写，如果想提高可读性可以用下划线分隔 大小写混合仅在为了兼容原来主要以大小写混合风格的情况下使用（比如 threading.py），保持向后兼容性 函数和方法参数 始终要将 self 作为实例方法的的第一个参数 始终要将 cls 作为类静态方法的第一个参数 如果函数的参数名和已有的关键词冲突，在最后加单一下划线比缩写或随意拼写更好。因此 class_ 比 clss 更好（也许最好用同义词来避免这种冲突） 编程建议 代码应该用不损害其他Python实现的方式去编写（PyPy，Jython，IronPython，Cython，Psyco 等） 比如，不要依赖于在CPython中高效的内置字符连接语句 a += b 或者 a = a + b 这种优化甚至在CPython中都是脆弱的（它只适用于某些类型）并且没有出现在不使用引用计数的实现中。在性能要求比较高的库中，可以用“”.join() 代替 这可以确保字符关联在不同的实现中都可以以线性时间发生 和像None这样的单例对象进行比较的时候应该始终用 is 或者 is not，永远不要用等号运算符 另外，如果你在写 if x 的时候，请注意你是否表达的意思是 if x is not None。举个例子，当测试一个默认值为None的变量或者参数是否被设置为其他值的时候。这个其他值应该是在上下文中能成为bool类型false的值 使用 is not 运算符，而不是 not … is 虽然这两种表达式在功能上完全相同，但前者更易于阅读，所以优先考虑 推荐： if foo is not None 不推荐： if not foo is None: Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-13 20:41:50 "},"Python/Python基础知识/summary.html":{"url":"Python/Python基础知识/summary.html","title":"Python基础知识","keywords":"","body":" 代码与注释 变量与常量 整形与浮点型 列表类型 元组类型 字符串类型 字典类型 集合类型 布尔类型 单例None 内存管理 深浅拷贝 输入与输出 运算符相关 分支结构 流程控制 推导式 字符编码 文件操作 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-13 20:41:50 "},"Python/Python基础知识/代码与注释.html":{"url":"Python/Python基础知识/代码与注释.html","title":"代码与注释","keywords":"","body":"代码注释 学习任何一门语言首要的就是学习它的注释。注释就是说你的脚本程序在运行过程中不会被解释器解释与执行的一部分，它的功能主要是给人阅读方便代码的后期维护。 在Python中（Python2和Python3均可），主要有3种注释方式，其中单行注释1种，多行注释2种。 #号注释 单个#号注释是属于单行注释，如下示例： # This is a single line comment 要注意的是，我们一般会在#后面添加上一个空格，如果#号前面有代码，一般会间隔两个空格。 print(\"HELLO,WORLD\") # 它将打印HELLO,WORLD -- - 三单引号注释 ''' '''三个单引号可以进行跨行注释，如下示例： def func(): ''' 用于进行一个功能的描述与说明 ''' pass 三双引号注释 \"\"\" \"\"\"三个双引号的注释与三个单引号的注释语义相同，基本上在能够使用三个单引号的地方都可以使用三个双引号： def func(): \"\"\" 用于进行一个功能的描述与说明 \"\"\" pass Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-13 20:41:50 "},"Python/Python基础知识/变量与常量.html":{"url":"Python/Python基础知识/变量与常量.html","title":"变量与常量","keywords":"","body":"标识符与对象 在Python中有一个核心的概念，叫做一切皆对象。 我们定义的数据、资源等皆可称之为对象，对象均存放在内存中。 而如果要使用这个对象，则必须通过标识符与对象进行绑定，说的通俗一点就是，为对象取一个名字。 一般来讲，一次绑定分为三部分操作： 创建资源对象（值） 创建标识符（名字） 建立绑定关系（赋值符号） 如下所示： 整个绑定的过程，被称为常量\\变量赋值或者对象定义，用=号将标识符与对象进行链接。 如下所示，我们用多个对象表示一个人的信息： name = \"yunya\" age = 18 height = 1.92 print(\"name : %s\\nage : %s\\nheight : %s\\n\" % (name, age, height)) # name : yunya # age : 18 # height : 1.92 先定义后使用 对象必须先定义，后使用，如果未定义就使用则会抛出异常。 print(\"My name is :\", name) name = \"yunya\" # NameError: name 'name' is not defined 命名风格 下面介绍几种常用的标识符命名方式： Camel-Case之小驼峰式：个人比较喜欢的风格，但是Python中并不建议使用小驼峰。 单词开头的字母小写，而后每个单词的分割首字母采用大写形式： userAge = 18 Camel-Case之大驼峰式：大驼峰式在Python中比较常见，一般定义类名时使用，不要滥用大驼峰。 每个单词都首字母都大写 UserInfo = {} 匈牙利类型标记法：前面的小写字母为变量类型，如，i代表int类型、s代表str类型： iUserAge = 18 蛇形命名法：小写+下划线，是Python中更推荐使用的标识符命名方式： user_age = 18 命名规范 标识符的命名需要遵从以下规范： 标识符应当见名知意 标识符由数字，字母，下划线组成。并且开头不能为数字 标识符不能使用Python中的关键字 错误的示范： $name = 'yunya' # 具有特殊字符 1year = 365 # 数字开头 *_size = 1024 # 具有特殊字符 and = 123 # 使用了关键字 年级 = 3 # 强烈不建议使用中文（占用内存大） (color) = 'red' # 虽然这种命名方式可行但是也极为不推荐 正确的示范： name = 'yunya' __age = 18 # Python中双下划线开头的标识符一般有隐私的这种说法，因此一般不建议使用 page_1 = 'home page' 同时，个人十分不推荐在标识符中加上任何的数字，这样的做法显得很莽撞。如item1，item2等... 绑定映射 Python中所有的数据均被称之为对象（object），对象存放至堆（heap）区内存中。 在对象存入堆区内存时，会为对象开辟一块内存空间并保存。 而在栈（stack）区内存中，则存放对象的引用（reference），即对象在堆区内存中的地址。 当一个对象被赋值给一个标识符后，在栈区内存中会创建一种映射（mapping）关系，此时标识符和对象就建立了联系，并且标识符本身也会被存放至栈区内存中。 name = \"yunya\" age = 18 height = 1.92 盒子声明 在很多其他的编程语言中，声明一个数据的过程可以被称作盒子声明，当遇到赋值操作时，它会进行如下的流程： 创建一个具体的盒子（开辟内存，创建盒子，并且为盒子打上标识） 放入具体的数据（将对象放入盒子中） 而在Python中，则没有盒子声明这种说法，我更喜欢将它称作贴纸声明，当遇到赋值操作时，它会进行如下的流程： 先创建一个对象（自动的在遇到=符号时，开辟内存并创建对象，如果该对象已存在，则进行引用） 将=符号左侧的标识符与对象绑定（像贴纸一样） 两者对比一下： 其他编程语言中总是先进行标识符盒子的初始化，再之后将数据对象放入盒子中 Python中总是先创建对象，并且再将标识符与对象做绑定 如下图所示： 引用传递 Python中所有的标识符与对象的绑定均为引用，不论是函数传参，单纯赋值等，标识符都与对象的内存地址做绑定，而不和对象本身的值做绑定。 Python中一个对象可以被多个标识符所引用，而一个标识符仅能引用一个对象。 你可以理解为Python中所有数据类型均为引用类型，没有值类型。 如下所示，我们将声明2个不同的标识符，标识符都指向了同一个int对象： oldAge = 18 newAge = oldAge print(id(oldAge)) print(id(newAge)) # 4550527568 # 4550527568 如下图所示： 在Golang中，如果进行上面的操作，因为盒子声明的缘故新的标识符newAge会创建出一片新的内存空间，并且将oldAge的值进行一次拷贝后存放至新内存空间中： package main import \"fmt\" func main() { var oldAge int = 18 var newAge int = oldAge fmt.Println(oldAge, &oldAge) fmt.Println(newAge, &newAge) } // 18 0xc42008e168 // 18 0xc42008e190 如下图所示： 变量 变量指的是该标识符所绑定的对象允许在运行时刻发生变化，是用来记录事物变化状态的一种东西。 举个例子： 进入游戏：等级为0 一天之后：等级为10 一月之后：等级为100 标识符（等级）与表示等级的对象所绑定，并且该等级在不断的变化，那么这个标识符可以称为变量标识符，与变量标识符绑定的对象是可以随意改变的： # 进入游戏 level = 0 # 一天后 level = 10 # 一月后 level = 100 # 现在的等级 print(level) # 100 变量命名 变量标识符的命名一般以蛇形命名法和小驼峰命名法为准。 不可使用大驼峰式命名法，同时全大写命名法也不要进行使用。 匿名变量 如果一个变量标识符为_，则代表该变量为匿名变量。 匿名变量的作用是当做一个垃圾桶，对于一些不会用到的对象可以命名为_，仅做到一个占位的作用，这在解构赋值中经常会被使用到。 其实官方没有匿名变量的定义，这也是Python社区中一条不成文的规定，因为实在是懒得对一个不用的对象想名字，干脆就用_进行命名。 常量 常量指的是该标识符所绑定的对象不允许在运行时刻发生变化，表示一个恒定的数据。 举个例子： 圆周率PI是恒定的，不能因为程序的运行而改变 人的性别是恒定的，不能因为程序的运行而改变 很遗憾，在应用领域来说Python并未提供常量的定义，但是在Python社区中有一个不成文的规定。 如果一个标识符所有字母都是大写的话，则认为该标识符是常量标识符： PI = 3.1415926535897 SEX = \"男\" 常量池 上面说过，尽管在应用领域中Python并未提供常量的定义，但是在内部实现中处处可见常量的影子。 如小整数常量池就是一个很好的例子。 在其他的编程语言，类似Golang、JavaScript中，常量定义的关键词为const，很快你也会在Python中见到这个单词。 相关方法 id() 使用id()函数可拿到标识符所对应对象在堆区内存中的地址号。 name = \"yunya\" print(id(name)) # 2933298725640 type() 使用type()函数可获取到该标识符对应对象的数据类型，返回类本身。 name = \"yunya\" print(type(name)) # del 使用del跟上标识符名字，将对该标识符所关联的对象进行解绑操作，同时也会取消该标识符的定义，将其从栈区内存中抹去。 name = \"yunya\" del name print(name) # NameError: name 'name' is not defined Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-13 20:41:50 "},"Python/Python基础知识/整形与浮点型.html":{"url":"Python/Python基础知识/整形与浮点型.html","title":"整形与浮点型","keywords":"","body":"整形 整形概述 Python中对于整形的划分非常简单，仅仅只有一个int类型。 整形是不可变类型，即对象本身的属性不会根据外部变化而变化 整形属于原子类型，即不可被分割 基本声明 以下是使用类实例化的形式进行对象声明： age = int(12) print(\"value : %r\\ntype : %r\" % (age, type(age))) # value : 12 # type : 也可以选择使用更方便的字面量形式进行对象声明： age = 12 print(\"value : %r\\ntype : %r\" % (age, type(age))) # value : 12 # type : 类型转换 整形可以与布尔型，浮点型，字符串等做转换，使用对应的工厂函数即可： num = 1 strNum = str(num) boolNum = bool(num) floatNum = float(num) print(\"value : %r\\ntype : %r\" % (strNum, type(strNum))) print(\"value : %r\\ntype : %r\" % (boolNum, type(boolNum))) print(\"value : %r\\ntype : %r\" % (floatNum, type(floatNum))) # value : '1' # type : # value : True # type : # value : 1.0 # type : 进制转换 使用以下三个内置函数，可进行进制转换： 函数名 描述 bin() 十进制转二进制 oct() 十进制转八进制 hex() 十进制转十六进制 示例如下： num = 100 print(bin(num)) print(oct(num)) print(hex(num)) # 0b1100100 # 0o144 # 0x64 如果想二进制、八进制、十六进制转换十进制，则可通过指定int()的第二参数base实现，如下所示： print(int(\"0b1100100\", base=2)) print(int(\"0o144\", base=8)) print(int(\"0x64\", base=16)) # 100 # 100 # 100 Unicode转换 使用以下两个内置函数，可进行整形与Unicode互转： 函数名 描述 chr() 传入0-1114111之间的整形，将其转换为Unicode字符 ord() 传入单个Unicode字符，将其转换为Unicode字符十进制整形 示例如下： >>> chr(65) 'A' >>> ord(\"A\") 65 long类型 在Python2中，如果整形后面加上L则代表长整型，在Python3中取消了这种设定。 >>> num = 100L >>> type(num) 浮点型 浮点型概述 Python中对于浮点型的划分非常简单，仅仅只有一个float类型。 浮点形是不可变类型，即对象本身的属性不会根据外部变化而变化 浮点形属于原子类型，即不可被分割 基本声明 以下是使用类实例化的形式进行声明： f = float(3.15) print(\"value : %r\\ntype : %r\" % (f, type(f))) # value : 3.15 # type : 也可以选择使用更方便的字面量形式： f = 3.15 print(\"value : %r\\ntype : %r\" % (f, type(f))) # value : 3.15 # type : 类型转换 浮点形可以与布尔型、整型、字符串等做转换，使用对应的工厂函数即可： num = 1.9 strNum = str(num) boolNum = bool(num) intNum = int(num) print(\"value : %r\\ntype : %r\" % (strNum, type(strNum))) print(\"value : %r\\ntype : %r\" % (boolNum, type(boolNum))) print(\"value : %r\\ntype : %r\" % (intNum, type(intNum))) # value : '1.9' # type : # value : True # type : # value : 1 # type : 四则运算 整形与浮点型均支持四则运算。 但是需要注意的是当整形与浮点型进行运算后，所得到的结果必然是浮点型： print(100 * 1.0) # 100.0 同时，整形也可以与字符串进行乘法运算： print(\"hello\" * 3) # hellohellohello 他两都支持与布尔型进行运算，布尔型的本质就是1和0，这里不再例举。 _的形式 在Python3中提供了对数字的_分割表现形式。 旨在更加方便阅读大数字： >>> a = 100_00 >>> a 10000 >>> b = 100_00.1 >>> b 10000.1 强类型 由于Python是强类型语言，故不会出现隐式转换的问题（Python2中是允许字符串与数字做比较的，且数字永远小于字符串）。 如下，使用整形与字符串做对比，返回的结果永远是False。 print(\"100\" == 100) # False 但是整形可以和浮点型做比较，因为它们同属于数值类型： print(100.00 == 100) # True 他两都支持与布尔型进行比较，布尔型的本质就是1和0，这里不再例举。 小整数池 Python解释器觉得有一些整数会经常被使用（-5到255之间），故当脚本程序运行前就将这些数字写入堆区内存中。 当用户定义int对象且使用到其中的数值时会直接将该数值的内存地址引用到存在于栈内存的变量标识符上，这样做极大节省了内存空间。 如：一个程序中使用了100000次1这个数值，那么如果没有Python的这个机制则会开辟出100000个内存空间用来存放相同的数值。 这么做显然极大的浪费了内存。 故Python的这种机制是十分高效且合理的，并且它的名字叫做小整数常量池，或简称为小整数池（范围：-5,255）： int_1 = 1 int_2 = 1 print(id(int_1)) # 1558801440 print(id(int_2)) # 1558801440 # 超出小整数池范围 int_3 = -6 int_4 = -6 print(id(int_3)) # 2264143854288 print(id(int_4)) # 2264143854448 绝对引用 数值拥有绝对引用的特性，无论是深拷贝还是浅拷贝，都不会获得其副本，而是直接对源对象进行引用： >>> import copy >>> oldN = 1_0000 >>> id(oldN) 4373791728 >>> n1 = copy.copy(oldN) >>> id(n1) 4373791728 >>> n2 = copy.deepcopy(oldN) >>> id(n2) 4373791728 声明速率 时间对比 对于所有的Python内置数据模型来说，字面量形式的对象声明永远要比类实例化的形式对象声明速度要快。 时间差大约3倍或者更多，我们可以做一个小实验来观察，使用timeit模块检测2者时间差： $ python3 -m timeit -n 1000000 -r 5 -v \"int(1)\" raw times: 0.138 0.136 0.135 0.152 0.16 1000000 loops, best of 5: 0.135 usec per loop $ python3 -m timeit -n 1000000 -r 5 -v \"1\" raw times: 0.00974 0.00961 0.0107 0.0107 0.00991 1000000 loops, best of 5: 0.00961 usec per loop ❶ -n 语句执行多少次 ❷ -r 重复计时器的次数，默认为5 可以看类实例化声明1百万次int类型时长为0.135秒。 而字面量形式声明1百万次int类型时长为0.00961秒。 整个差距居然有14倍！当然，如果是一些复杂的类型声明，这个差距会变小。 底层探究 为什么会出现这样的情况，可以使用dis模块来探索，该模块会通过反汇编来查看到语句执行情况的字节码。 $ echo \"int(1)\" > demo.py $ python3 -m dis demo.py 1 0 LOAD_NAME 0 (int) 2 LOAD_CONST 0 (1) 4 CALL_FUNCTION 1 6 POP_TOP 8 LOAD_CONST 1 (None) 10 RETURN_VALUE $ echo \"1\" > demo.py $ python3 -m dis demo.py 1 0 LOAD_CONST 0 (None) 2 RETURN_VALUE 使用类实例化声明对象时，必定会调用到底层函数__init__()，而调用函数的过程会发起系统调用栈的进出栈操作，故更加耗时。 此外，我们也从上面的LOAD_CONST可以观察出，int类型小整数1确实会从小整数常量池中加载数据。 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-13 20:41:50 "},"Python/Python基础知识/列表类型.html":{"url":"Python/Python基础知识/列表类型.html","title":"列表类型","keywords":"","body":"列表 Python中的列表（list）是最常用的数据类型之一。 Python中的列表可以存储任意类型的数据，这与其他语言中的数组（array）不同。 被存入列表中的内容可称之为元素（element）或者数据项（data item）亦或是值（value）。 虽然Python列表支持存储任意类型的数据项，但不建议这么做，事实上这么做的概率也很低。 列表特性 列表特性如下： 列表属于线性容器序列 列表属于可变类型，即对象本身的属性会根据外部变化而变化，例如长度 列表底层由顺序存储组成，而顺序存储是线性结构的一种 基本声明 以下是使用类实例化的形式进行对象声明： lst = list((1, 2, 3, 4, 5)) print(\"value : %r\\ntype : %r\" % (lst, type(lst))) # value : [1, 2, 3, 4, 5] # type : 也可以选择使用更方便的字面量形式进行对象声明，利用[]对数据项进行包裹，并且使用逗号将数据项之间进行分割： lst = [1, 2, 3, 4, 5] print(\"value : %r\\ntype : %r\" % (lst, type(lst))) # value : [1, 2, 3, 4, 5] # type : 多维列表 当一个列表中嵌套另一个列表，该列表就可以称为多维列表。 如下，定义一个2维列表： lst = [1, 2, [\"三\",\"四\"]] print(\"value : %r\\ntype : %r\" % (lst, type(lst))) # value : [1, 2, ['三', '四']] # type : 续行操作 在Python中，列表中的数据项如果过多，可能会导致整个列表太长，太长的列表是不符合PEP8规范的。 每行最大的字符数不可超过79，文档字符或者注释每行不可超过72 Python虽然提供了续行符\\，但是在列表中可以忽略续行符，如下所示： lst = [ 1, 2, 3, 4, 5 ] print(\"value : %r\\ntype : %r\" % (lst, type(lst))) # value : [1, 2, 3, 4, 5] # type : 类型转换 列表支持与布尔型、字符串、元组、以及集合类型进行类型转换： lst = [1, 2, 3] bLi = bool(lst) strLi = str(lst) tupLi = tuple(lst) setLi = set(lst) print(\"value : %r\\ntype : %r\" % (bLi, type(bLi))) print(\"value : %r\\ntype : %r\" % (strLi, type(strLi))) print(\"value : %r\\ntype : %r\" % (tupLi, type(tupLi))) print(\"value : %r\\ntype : %r\" % (setLi, type(setLi))) # value : True # type : # value : '[1, 2, 3]' # type : # value : (1, 2, 3) # type : # value : {1, 2, 3} # type : 如果一个2维列表遵循一定的规律，那么也可以将其转换为字典类型： lst = [[\"k1\", \"v1\"], [\"k2\", \"v2\"], [\"k3\", \"v3\"]] dictList = dict(lst) print(\"value : %r\\ntype : %r\" % (dictList, type(dictList))) # value : {'k1': 'v1', 'k2': 'v2', 'k3': 'v3'} # type : 四则运算 列表支持与元组，列表进行加法运算： +：合并2个列表并生成新列表： lst1 = [1, 2, 3] lst2 = [4, 5, 6] newLi = lst1 + lst2 print(newLi) # [1, 2, 3, 4, 5, 6] +=：扩展已有列表，相当于extend()方法： oldLi = [1, 2, 3] newLi = [4, 5, 6] oldLi += newLi print(oldLi) # [1, 2, 3, 4, 5, 6] 列表支持与数字进行乘法运算： *：生成一个重复旧列表数据项的新列表： oldLi = [1, 2, 3] newLi = oldLi * 3 print(newLi) # [1, 2, 3, 1, 2, 3, 1, 2, 3] *=：扩展已有列表，将已有列表的数据项进行重复添加： oldLi = [1, 2, 3] oldLi *= 3 print(oldLi) # [1, 2, 3, 1, 2, 3, 1, 2, 3] 索引切片 索引的概念 列表底层是以一种连续的顺序结构存储数据项，故可以使用索引（index）对数据项进行获取、删除、截取、替换等操作。 ----------------------------| | A | B | C | D | E | F | G | ----------------------------| | 0 | 1 | 2 | 3 | 4 | 5 | 6 | |-7 |-6 |-5 |-4 |-3 |-2 |-1 | 正向索引都是从0开始，负向索引都是从-1开始。 enumerate() 我们以一个内置函数enumerate()来举例，该函数返回一个迭代器，将其转换为list()后可以查看数据项以及正向索引： lst = [\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\"] print(list(enumerate(lst))) # [(0, 'A'), (1, 'B'), (2, 'C'), (3, 'D'), (4, 'E'), (5, 'F'), (6, 'G')] 更多的关于enumerate()函数的妙用，将会放在循环章节中进行探讨。 slice() slice()函数有三个参数： start：索引开始的位置 stop：索引结束的位置 step：步长间距，默认为1 如果为正数代表正取，如果为负数代表倒取 如果为1代表连续取，如果为2代表隔一个取一个，以此类推 使用方法如下示例，先使用slice()确定截取数据项的范围，然后再使用列表的[]操作形式取出指定范围的数据项。 注意：所有的切片都是顾头不顾尾： lst = [\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\"] # 取出A # 释义：从0开始取，取1个，步长为0 s = slice(0, 1, None) print(lst[s]) # ['A'] [::]形式 使用slice()函数会比较繁琐，直接使用[::]形式进行切片会比较简单。 签名如下： [start:stop:step] 参数描述和slice()相同，当某一参数不设置时可省略前面的参数。 增删改截操作演示： >>> # 获取第2个数据项 >>> lst = [\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\"] >>> lst[1] 'B' >>> # 删除第3个数据项 >>> del lst[2] >>> lst ['A', 'B', 'D', 'E', 'F', 'G'] >>> # 从第1个数据项开始向后替换2个数据项，替换内容为123 >>> lst[0:3] = 1,2,3 >>> lst [1, 2, 3, 'E', 'F', 'G'] >>> # 从第1个数据项开始获取2个数据项 >>> lst[0:3] [1, 2, 3] >>> # 试图访问一个超出索引之外的数据项，将引发异常 >>> lst[100] IndexError: lstst index out of range 需要注意的是，如果使用[:]则会创建一个新的列表，再将原有列表中的数据项全部引用至新的列表中，类似于浅拷贝的概念。 如下所示： lst1 = [\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\"] lst2 = lst1[:] print(\"value : %r\\naddr : %r\" % (lst1, id(lst1))) print(\"value : %r\\naddr : %r\" % (lst2, id(lst2))) # value : ['A', 'B', 'C', 'D', 'E', 'F', 'G'] # addr : 4307969608 # value : ['A', 'B', 'C', 'D', 'E', 'F', 'G'] # addr : 4308270792 正向切片 正向切片即使用正向索引进行切片，索引从0处开始进行切片。 如下示例： >>> lst = [\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\"] >>> lst[0:3] ['A', 'B', 'C'] 反向切片 反向切片即使用反向索引进行切片，索引从-1处开始进行切片。 如下示例： >>> lst = [\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\"] >>> lst[-3:] ['E', 'F', 'G'] 多维切片 列表是支持多维切片的，如下示例，拿出2维列表中的数据项A： >>> lst = [1, 2, [\"A\", \"B\"]] >>> lst[-1][0] 'A' 高级切片 反向和正向切片可以混合使用，下面是一些高级切片的用法： >>> lst = [\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\"] >>> lst[:] ❶ ['A', 'B', 'C', 'D', 'E', 'F', 'G'] >>> lst[2:4] ❷ ['C', 'D'] >>> lst[::2] ❸ ['A', 'C', 'E', 'G'] >>> lst[::-2] ['G', 'E', 'C', 'A'] ❹ >>> lst[::-1] ❺ ['G', 'F', 'E', 'D', 'C', 'B', 'A'] >>> lst[:-5:-2] ❻ ['G', 'E'] >>> lst[0::-1] ❼ ['A'] >>> lst[5::-2] ❽ ['F', 'D', 'B'] 如何一眼读懂高级切片，通过以下步骤判定： 第一步先观察step，是负数还是正数，负数代表倒着取 第二步观察start，确定切片的开始位置 第三步观察stop，确定切片的结束位置 上述示例演示的说明，带*的是比较重要的方式。 ❶：列表的[:]操作是创建一个新的列表，再将原有列表中的数据项全部引用一次至新的列表* ❷：步长为空，代表正着取，从第2号索引位置的数据项开始，到第4号索引位置的数据项结束，根据顾头不顾尾原则，取2，3号索引的数据项* ❸：步长为2，代表正着取，隔一个取一个，即从0号索引位置的数据项开始，每次往后数到2的时候再取* ❹：步长为-2，代表倒着取，隔一个取一个，即从-1号索引位置的数据项开始，每次向前数到2的时候再取* ❺：步长为-1，代表倒着取，即从-1号索引位置的数据项开始，取到索引0号位置结束* ❻：步长为-2，代表倒着取，隔一个位置取一个，取到-5索引位置结束，根据顾头不顾尾原则，不取-5索引位置的数据项 ❼：步长为-1，代表倒着取，开始位置为0，结束位置未标记，则取1个 ❽：步长为-2，代表倒着取，隔一个取一个，开始位置为5号索引，则从第5号索引开始向前取 解构方法 *语法 使用*语法可对列表进行解构，将列表中的数据项全部提取出来： lst = [1, 2, 3] print(*lst) # 1 2 3 我们可以利用*语法的特性，来达到两个列表进行合并产生新列表的效果，类似于+： lst1 = [1, 2, 3] lst2 = [4, 5, 6] result = [*lst1, *lst2] print(result) # [1, 2, 3, 4, 5, 6] 解构赋值 如果一个列表中的数据项需要赋值到变量中，可使用解构赋值，需要注意的是变量接收位置与列表中的数据项位置需要一一对应： lst = [\"A\", \"B\"] item1, item2 = lst print(item1, item2) # A B 我们只想取出列表中前2个数据项时，可使用*语法将剩下的数据项全部打包到一个变量中： lst = [\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\"] item1, item2, *otherItems = lst print(item1, item2) print(otherItems) # A B # ['C', 'D', 'E', 'F', 'G'] 如果只想取第1个后和最后2个，中间的都不想要怎么办？也可以通过*语法： lst = [\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\"] itemFirst, *_, itemLast1, itemLast2 = lst # ❶ print(itemFirst, itemLast1, itemLast2) print(_) # A F G # ['B', 'C', 'D', 'E'] ❶：_为匿名变量，参见变量与常量一章节中的释义 常用方法 方法一览 常用的list方法一览表： 方法名 返回值 描述 append() None 将数据项添加至列表的末尾 extend() None 通过附加来自可迭代对象的数据项来扩展列表 insert() None 在索引之前插入对象 pop() item 删除并返回索引处的项目（默认为-1）。如果列表为空或索引超出范围，则引发IndexError copy() list 返回L的浅拷贝 remove() None 删除列表中第一次出现的数据项。如果不存在该数据项，则引发ValueError clear() None 从L移除所有项目 count() integer 返回数据项在L中出现的次数 index() integer 返回第一个数据项在L中出现位置的索引，若值不存在，则抛出ValueError sort() None 对列表进行原地排序，可指定参数reverse，若不指定该参数则默认升序排列，指定该参数则为降序排列 基础公用函数： 函数名 返回值 描述 len() integer 返回容器中的项目数 enumerate() iterator for index, value of iterable 返回一个可迭代对象，其中以小元组的形式包裹数据项与正向索引的对应关系 reversed() ... 详情参见函数章节 sorted() ... 详情参见函数章节 获取长度 使用len()方法来获取列表的长度。 返回int类型的值。 lst = [\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\"] print(len(lst)) # 7 Python在对内置的数据类型使用len()方法时，实际上是会直接的从PyVarObject结构体中获取ob_size属性，这是一种非常高效的策略。 PyVarObject是表示内存中长度可变的内置对象的C语言结构体。 直接读取这个值比调用一个方法要快很多。 追加元素 使用append()方法为当前列表追加一个数据项。 返回None： lst = [\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\"] lst.append(\"H\") print(lst) # ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H'] 你也可以使用+=进行操作，但个人并不推荐这样使用。 lst = [\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\"] lst += \"H\" print(lst) # ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H'] 列表合并 使用extend()方法来让当前列表与另一个可迭代对象进行合并。 返回None： lst1 = [\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\"] lst2 = [\"H\", \"J\", \"K\", \"L\"] lst1.extend(lst2) print(lst1) # ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'J', 'K', 'L'] 你也可以使用+=进行操作，但个人并不推荐这样使用。 lst1 = [\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\"] lst2 = [\"H\", \"J\", \"K\", \"L\"] lst1 += lst2 print(lst1) # ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'J', 'K', 'L'] 插入元素 使用insert()方法将数据项插入当前列表中的指定位置。 返回None： lst = [\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\"] lst.insert(0, \"a\") print(lst) # ['a', 'A', 'B', 'C', 'D', 'E', 'F', 'G'] 列表拷贝 使用copy()方法将当前列表进行浅拷贝。 返回当前列表的拷贝对象： oldLi = [\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\"] newLi = oldLi.copy() print(oldLi) print(newLi) print(id(oldLi)) print(id(newLi)) print(id(oldLi[0])) print(id(oldLi[0])) # ['A', 'B', 'C', 'D', 'E', 'F', 'G'] # ['A', 'B', 'C', 'D', 'E', 'F', 'G'] # 4329305992 # 4329607688 # 4328383520 # 4328383520 弹出元素 使用pop()方法弹出当前列表中在此索引位置的数据项，列表中该数据项将被删除，并返回被弹出的数据项。 若不指定位置，则默认弹出-1号索引位置的数据项： lst = [\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\"] popItem1 = lst.pop() popItem2 = lst.pop(2) print(lst) print(popItem1) print(popItem2) # ['A', 'B', 'D', 'E', 'F'] # G # C 删除元素 使用remove()方法删除当前列表中的数据项，根据数据项的名字进行删除。 如果具有多个同名的数据项，则只会删除第一个。 返回None： lst = [\"A\", \"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\"] lst.remove(\"A\") print(lst) # ['A', 'B', 'C', 'D', 'E', 'F', 'G'] 我们也可以使用del lst[index]进行数据项的删除： lst = [\"A\", \"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\"] del lst[0] print(lst) # ['A', 'B', 'C', 'D', 'E', 'F', 'G'] 这种方式还可以删除多个： lst = [\"A\", \"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\"] del lst[0:3] print(lst) # ['C', 'D', 'E', 'F', 'G'] 清空元素 使用clear()方法将当前列表进行清空，即删除所有数据项。 返回None： lst = [\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\"] lst.clear() print(lst) # [] 我们也可以使用del lst[:]进行列表的清空： lst = [\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\"] del lst[:] print(lst) # [] 统计次数 使用count()方法统计数据项在该列表中出现的次数。 返回int： lst = [\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\", \"A\"] aInLiCount = lst.count(\"A\") print(aInLiCount) # 2 查找位置 使用index()方法找到数据项在当前列表中首次出现的位置索引值，如数据项不存在则抛出异常。 返回int。 lst = [\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\", \"A\"] aInLiIndex = lst.index(\"A\") print(aInLiIndex) # 0 顺序排列 使用sort()方法将当前列表中的数据项按照ASCII码顺序进行排列，默认从小到大。 可指定参数resverse，用于是否翻转列表，如翻转列表则代表从大到小。 返回None： lst = [\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\", \"A\"] lst.sort(reverse=True) print(lst) # ['G', 'F', 'E', 'D', 'C', 'B', 'A', 'A'] sort()方法内部采用timsort算法，这是一种非常优秀的算法，速度快且稳定。 底层探究 容器序列 这里引出一个新的概念，线性容器序列： 线性是指该对象内部是由连续的内存空间组成 容器中能存放不同类型的数据项，如list就是标准的一个容器 序列是指具有长度的对象，且该对象能使用index进行内部数据项的操作 容器序列存放的是它们所包含的任意类型的对象的引用，如下定义了一个列表： x = [“A”, “B”, “C”] 它的内部存储结构如下图所示： 在CPython源码中，列表数据项的引用为PyObject **ob_item属性，即指针的指针。 元素调整 列表中，pop()和insert()方法都具有指定索引值的功能。 如果使用pop(0)，或者insert(0)则都会引起整个列表中数据项的调整。 pop(0)会将队首的数据项弹出并删除，后面的所有数据项都要向前挪一个位置。1变成0，2变成1，以此类推 insert(0)会将新的数据项插入至队首，后面的所有数据项都要向后挪一个位置。0变成1，1变成2，以此类推 而单纯的使用pop()或者append()则不会发生数据项调整，因为它们总是在队尾做操作。 总而言之，任何一个方法只要不是操作的队尾数据项，都会引起该列表中其他所有数据项的调整。 图示如下： 扩容机制 在对列表进行添加数据项时，如果列表内部的容量已满则会触发扩容机制。 我们要理解2个概念： 容量：容量指的是列表底层在开辟内存时，开辟了多大的内存空间，能够容纳多少数据项，可以理解为一共有多少个槽位 大小：大小指的是当前列表中，数据项已占据的容量，可以理解为已用了多少个槽位 在CPython源码中，列表容量的属性为Py_ssize_t allocated，而列表大小的属性为Py_ssize_t ob_size 在初始化列表时，容量和大小总是等于数据项的总个数，如： 一个空列表，容量和大小都为0 有8个槽位的列表，容量和大小都为8 如果对一个已有的列表进行增加数据项的操作时会有以下2条判断，判定当前列表是否需要扩容： 当前列表容量 > 已有数据项个数+1 and 已有数据项个数 >= 当前列表容量的一半 则直接添加数据项，不进行扩容 并且新增数据项个数 Py_ssize_t ob_size + 1 当前列表容量 则先进行扩容后再添加数据项 扩容是一种线性增长，增长规律为：0、4、8、16、24、32、40、52、64、76 …，总是为4的倍数 在扩容时不必担心发生内存溢出，因为内部已经设置了最大值 为：PY_SSIZE_T_MAX *（9/8）+ 6 缩容机制 缩容机制建立在列表有空余空间的情况下。 我们如果使用pop()方法删除了最后一个数据项，其实并不会将最后一个列表槽位所占用的内存空间给释放掉而是进行保留，内部仅进行一次Py_ssize_t ob_size - 1的操作。 这样做的好处是，后面再添加数据项时，其实就不用再次进行扩容了。 但是在添加数据项之前，会判断整个列表的容量是否过大，如果过大即代表还有很多空的位置，此时要进行缩容机制： 如果数据项个数 + 1 则进行缩容，删除空的列表槽位 如果是clear()清空列表中的数据项，则直接非常干脆的将容量以及大小都重置为0，并且将该列表所有槽位占据的内存空间进行释放。 迁徙机制 因为列表底层是顺序存储，必须占用一个连续的内存空间。 如果在进行扩容时，发现后面连续的内存空间被其他对象所占据，则会将整个列表进行一次拷贝。 然后迁徙到新的位置开辟内存，确保所有的列表槽位都是连续的。 列表缓存 当删除一个列表之后，会将该列表中槽位引用的数据项地址全部清空。 并且将该列表的引用存放至一个叫做free_list的缓存中，下次如果再需要创建列表，则直接从free_list缓存中获取。 free_list最多可以缓存80个列表 示例，旧列表被删除后将空列表的引用存放至free_list缓存中，当再次创建一个新列表时，会直接从free_list缓存中获取旧列表，并且填入数据项： lst1 = [1, 2, 3] print(id(lst1)) del lst1 lst2 = [4, 5, 6, 7] print(id(lst2)) # 4405732936 # 4405732936 listobject.c源码 官网参考：点我跳转 源码一览：点我跳转 以下是截取了一些关键性源代码，并且做上了中文注释，方便查阅。 每一个列表都有几个关键性的属性： Py_ssize_t ob_refcnt; // 引用计数器 PyObject **ob_item; // 列表内部槽位的数据项指针，即指针的指针 Py_ssize_t ob_size; // 列表大小 Py_ssize_t allocated; // 列表容量 创建列表 PyObject * PyList_New(Py_ssize_t size) { // 空列表 if (size numfree != -1); #endif // 判断是否有free_list中是否有缓存 if (state->numfree) { // 有缓存，free_list缓存的列表个数减1 state->numfree--; op = state->free_list[state->numfree]; // 建立新的引用关系 _Py_NewReference((PyObject *)op); } else { // 无缓存，创建新列表，先开辟内存 op = PyObject_GC_New(PyListObject, &PyList_Type); if (op == NULL) { return NULL; } } if (size ob_item = NULL; } else { // 如果列表不是空的，则将每个槽位的数据项地址进行引用 op->ob_item = (PyObject **) PyMem_Calloc(size, sizeof(PyObject *)); if (op->ob_item == NULL) { Py_DECREF(op); return PyErr_NoMemory(); } } // 设置列表中数据项占据的容量大小 Py_SET_SIZE(op, size); // 设置列表的整体容量 op->allocated = size; // 将列表放入双向链表中以进行内存管理 _PyObject_GC_TRACK(op); // 返回列表的结构体指针 return (PyObject *) op; } 添加元素 static int app1(PyListObject *self, PyObject *v) { // 获取列表的大小（已占用容量） Py_ssize_t n = PyList_GET_SIZE(self); assert (v != NULL); assert((size_t)n + 1 static int list_resize(PyListObject *self, Py_ssize_t newsize) { PyObject **items; size_t new_allocated, num_allocated_bytes; Py_ssize_t allocated = self->allocated; /* Bypass realloc() when a previous overallocation is large enough to accommodate the newsize. If the newsize falls lower than half the allocated size, then proceed with the realloc() to shrink the list. */ // 扩容、缩容机制调用realloc()函数 // allocated = 容量 // newsize代表已存在的数据项个数 + 1 // 当前列表容量 > 已有数据项个数+1 and 已有数据项个数 >= 当前列表容量的一半 if (allocated >= newsize && newsize >= (allocated >> 1)) { assert(self->ob_item != NULL || newsize == 0); // 则直接添加数据项，不进行扩容 // 并新增数据项个数 Py_ssize_t ob_size + 1 Py_SET_SIZE(self, newsize); return 0; } /* This over-allocates proportional to the list size, making room * for additional growth. The over-allocation is mild, but is * enough to give linear-time amortized behavior over a long * sequence of appends() in the presence of a poorly-performing * system realloc(). * Add padding to make the allocated size multiple of 4. * The growth pattern is: 0, 4, 8, 16, 24, 32, 40, 52, 64, 76, ... * Note: new_allocated won't overflow because the largest possible value * is PY_SSIZE_T_MAX * (9 / 8) + 6 which always fits in a size_t. */ new_allocated = ((size_t)newsize + (newsize >> 3) + 6) & ~(size_t)3; /* Do not overallocate if the new size is closer to overallocated size * than to the old size. */ // 如果数据项个数 + 1 (Py_ssize_t)(new_allocated - newsize)) new_allocated = ((size_t)newsize + 3) & ~(size_t)3; // 全是空的 if (newsize == 0) new_allocated = 0; num_allocated_bytes = new_allocated * sizeof(PyObject *); // 基于realloc()进行扩容或者缩容，内部会包含数据项的位置调整 items = (PyObject **)PyMem_Realloc(self->ob_item, num_allocated_bytes); if (items == NULL) { PyErr_NoMemory(); return -1; } // 重新设置列表的 ob_item、obsize、allocated self->ob_item = items; Py_SET_SIZE(self, newsize); self->allocated = new_allocated; return 0; } 插入元素 static int ins1(PyListObject *self, Py_ssize_t where, PyObject *v) { // 获取数据项个数 Py_ssize_t i, n = Py_SIZE(self); PyObject **items; // 插入数据项确保不是NULL if (v == NULL) { PyErr_BadInternalCall(); return -1; } assert((size_t)n + 1 n) where = n; // 拿到列表中所有数据项的引用 items = self->ob_item; // 让插入位置之后的所有数据项开始向后挪动1个位置，腾出位置来插入新的数据项 for (i = n; --i >= where; ) // i + 1指的是数据项指针地址，每次 - 1 items[i+1] = items[i]; // 新增数据项的引用计数 + 1 Py_INCREF(v); // 新的数据项索引位置和值做绑定 items[where] = v; return 0; } int PyList_Insert(PyObject *op, Py_ssize_t where, PyObject *newitem) { // 传入列表的引用， 插入的位置，还有新的数据项引用，并且验证列表和数据项 if (!PyList_Check(op)) { PyErr_BadInternalCall(); return -1; } // 进行插入 return ins1((PyListObject *)op, where, newitem); } 移除元素 static PyObject * list_pop_impl(PyListObject *self, Py_ssize_t index) // 传入列表的引用，列表的弹出数据项索引位置 { PyObject *v; int status; // 如果是一个空列表，则抛出异常 if (Py_SIZE(self) == 0) { /* Special-case most common failure cause */ PyErr_SetString(PyExc_IndexError, \"pop from empty list\"); return NULL; } if (index ob_item[index]; // 如果弹出的数据项是列表中的最后一个 if (index == Py_SIZE(self) - 1) { // list_resize()内部只会做size - 1，而不会回收内存进行缩容 status = list_resize(self, Py_SIZE(self) - 1); if (status >= 0) return v; /* and v now owns the reference the list had */ else return NULL; } // 增加一次引用计数器 Py_INCREF(v); // 如果弹出的数据项不是列表中的最后一个，则需要进行位置调整 status = list_ass_slice(self, index, index+1, (PyObject *)NULL); if (status 清空元素 static int _list_clear(PyListObject *a) { Py_ssize_t i; PyObject **item = a->ob_item; if (item != NULL) { /* Because XDECREF can recursively invoke operations on this list, we make it empty first. */ i = Py_SIZE(a); // 重新设置大小为0 Py_SET_SIZE(a, 0); // 将列表中插槽引用的对象全部设置为None a->ob_item = NULL; // 重新设置容量为0 a->allocated = 0; // 循环列表中的数据项，令所有数据项的引用计数-1 while (--i >= 0) { Py_XDECREF(item[i]); } PyMem_Free(item); } /* Never fails; the return value can be ignored. Note that there is no guarantee that the list is actually empty at this point, because XDECREF may have populated it again! */ return 0; } 删除列表 static void list_dealloc(PyListObject *op) { Py_ssize_t i; // 内部会判断这个列表是否还有其他标识符引用，如果为0则代表没有其他标识符引用 // 可以通过内部GC机制将该列表所占据的内存空间进行释放 PyObject_GC_UnTrack(op); Py_TRASHCAN_BEGIN(op, list_dealloc) if (op->ob_item != NULL) { /* Do it backwards, for Christian Tismer. There's a simple test case where somehow this reduces thrashing when a *very* large list is created and immediately deleted. */ // 获取列表中已有数据项的个数（即大小） i = Py_SIZE(op); // 循环列表中的数据项，令所有数据项的引用计数-1 while (--i >= 0) { Py_XDECREF(op->ob_item[i]); } PyMem_Free(op->ob_item); } struct _Py_list_state *state = get_list_state(); #ifdef Py_DEBUG // list_dealloc() must not be called after _PyList_Fini() assert(state->numfree != -1); #endif // 判断free_list中的已缓存列表个数是否大于80，这里是没满 // 在free_list中添加空列表的引用即可 if (state->numfree free_list[state->numfree++] = op; } else { // 如果free_list的大小已达到容量限制 // 则直接在内存中销毁列表的结构体对象 Py_TYPE(op)->tp_free((PyObject *)op); } Py_TRASHCAN_END } Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-13 20:41:50 "},"Python/Python基础知识/元组类型.html":{"url":"Python/Python基础知识/元组类型.html","title":"元组类型","keywords":"","body":"元组 Python中的元组容器序列（tuple）与列表容器序列（list）具有极大的相似之处，因此也常被称为不可变的列表。 但是两者之间也有很多的差距，元组侧重于数据的展示，而列表侧重于数据的存储与操作。 它们非常相似，虽然都可以存储任意类型的数据，但是一个元组定义好之后就不能够再进行修改。 元组特性 元组特性如下： 元组属于线性容器序列 元组属于不可变类型，即对象本身的属性不会根据外部变化而变化 元组底层由顺序存储组成，而顺序存储是线性结构的一种 基本声明 以下是使用类实例化的形式进行对象声明： tpl = tuple((1, 2, 3, 4, 5)) print(\"value : %r\\ntype : %r\" % (tpl, type(tpl))) # value : (1, 2, 3, 4, 5) # type : 也可以选择使用更方便的字面量形式进行对象声明，使用逗号对数据项之间进行分割： tpl = 1, 2, 3, 4, 5 print(\"value : %r\\ntype : %r\" % (tpl, type(tpl))) # value : (1, 2, 3, 4, 5) # type : 为了美观，我们一般会在两侧加上()，但是要确定一点，元组定义是用逗号来分隔数据项，而并非是用()包裹数据项： tpl = (1, 2, 3, 4, 5) print(\"value : %r\\ntype : %r\" % (tpl, type(tpl))) # value : (1, 2, 3, 4, 5) # type : 多维元组 当一个元组中嵌套另一个元组，该元组就可以称为多维元组。 如下，定义一个2维元组： tpl = (1, 2, (\"三\", \"四\")) print(\"value : %r\\ntype : %r\" % (tpl , type(tpl))) # value : (1, 2, ('三', '四')) # type : 续行操作 在Python中，元组中的数据项如果过多，可能会导致整个元组太长，太长的元组是不符合PEP8规范的。 每行最大的字符数不可超过79，文档字符或者注释每行不可超过72 Python虽然提供了续行符\\，但是在元组中可以忽略续行符，如下所示： tpl = ( 1, 2, 3, 4, 5 ) print(\"value : %r\\ntype : %r\" % (tpl, type(tpl))) # value : (1, 2, 3, 4, 5) # type : 类型转换 元组支持与布尔型、字符串、列表、以及集合类型进行类型转换： tpl = (1, 2, 3) bTpl = bool(tpl) strTpl = str(tpl) lstTpl = list(tpl) setTpl = set(tpl) print(\"value : %r\\ntype : %r\" % (bTpl, type(bTpl))) print(\"value : %r\\ntype : %r\" % (strTpl, type(strTpl))) print(\"value : %r\\ntype : %r\" % (lstTpl, type(lstTpl))) print(\"value : %r\\ntype : %r\" % (setTpl, type(setTpl))) # value : True # type : # value : '(1, 2, 3)' # type : # value : [1, 2, 3] # type : # value : {1, 2, 3} # type : 如果一个2维元组遵循一定的规律，那么也可以将其转换为字典类型： tpl = ((\"k1\", \"v1\"), (\"k2\", \"v2\"), (\"k3\", \"v3\")) dictTuple = dict(tpl) print(\"value : %r\\ntype : %r\" % (dictTuple, type(dictTuple))) # value : {'k1': 'v1', 'k2': 'v2', 'k3': 'v3'} # type : 索引操作 元组由于是线性结构，故支持索引和切片操作 但只针对获取，不能对其内部数据项进行修改。 使用方法参照列表的索引切片一节。 绝对引用 元组拥有绝对引用的特性，无论是深拷贝还是浅拷贝，都不会获得其副本，而是直接对源对象进行引用。 但是列表没有绝对引用的特性，代码验证如下： >>> import copy >>> # 列表的深浅拷贝均创建新列表... >>> oldLi = [1, 2, 3] >>> id(oldLi) 4542649096 >>> li1 = copy.copy(oldLi) >>> id(li1) 4542648840 >>> li2 = copy.deepcopy(oldLi) >>> id(li2) 4542651208 >>> # 元组的深浅拷贝始终引用老元组 >>> oldTup = (1, 2, 3) >>> id(oldTup) 4542652920 >>> tup1 = copy.copy(oldTup) >>> id(tup1) 4542652920 >>> tup2 = copy.deepcopy(oldTup) >>> id(tup2) 4542652920 Python为何要这样设计？其实仔细想想不难发现，元组不能对其进行操作，仅能获取数据项。 那么也就没有生成多个副本提供给开发人员操作的必要了，因为你修改不了元组，索性直接使用绝对引用策略。 值得注意的一点：[:]也是浅拷贝，故对元组来说属于绝对引用范畴。 元组的陷阱 Leonardo Rochael在2013年的Python巴西会议提出了一个非常具有思考意义的问题。 我们先来看一下： >>> t = (1, 2, [30, 40]) >>> t[-1] += [50, 60] Traceback (most recent call last): File \"\", line 1, in TypeError: 'tuple' object does not support item assignment 现在，t到底会发生下面4种情况中的哪一种？ t 变成 (1, 2, [30, 40, 50, 60])。 因为 tuple 不支持对它的数据项赋值，所以会抛出 TypeError 异常。 以上两个都不是。 a 和 b 都是对的。 正确答案是4，t确实会变成 (1, 2, [30, 40, 50, 60])，但同时元组是不可变类型故会引发TypeError异常的出现。 >>> t (1, 2, [30, 40, 50, 60]) 如果是使用extend()对t[-1]的列表进行数据项的增加，则答案会变成1。 我当初在看了这个问题后，暗自告诉自己了1件事情： tuple中不要存放可变类型的数据，如list、set、dict等.. 元组更多的作用是展示数据，而不是操作数据。 举个例子，当用户根据某个操作获取到了众多数据项之后，你可以将这些数据项做出元组并返回。 用户对被返回的原对象只能看，不能修改，若想修改则必须创建新其他类型对象。 解构方法 元组的解构方法与列表使用相同。 使用方法参照列表的解构方法一节。 常用方法 方法一览 常用的tuple方法一览表： 方法名 返回值 描述 count() integer 返回数据项在T中出现的次数 index() integer 返回第一个数据项在T中出现位置的索引，若值不存在，则抛出ValueError 基础公用函数： 函数名 返回值 描述 len() integer 返回容器中的项目数 enumerate() iterator for index, value of iterable 返回一个可迭代对象，其中以小元组的形式包裹数据项与正向索引的对应关系 reversed() ... 详情参见函数章节 sorted() ... 详情参见函数章节 获取长度 使用len()方法来获取元组的长度。 返回int类型的值。 tpl = (\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\") print(len(tpl)) # 7 Python在对内置的数据类型使用len()方法时，实际上是会直接的从PyVarObject结构体中获取ob_size属性，这是一种非常高效的策略。 PyVarObject是表示内存中长度可变的内置对象的C语言结构体。 直接读取这个值比调用一个方法要快很多。 统计次数 使用count()方法统计数据项在该元组中出现的次数。 返回int： tpl = (\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\", \"A\") aInTupCount = tpl.count(\"A\") print(aInTupCount) # 2 查找位置 使用index()方法找到数据项在当前元组中首次出现的位置索引值，如数据项不存在则抛出异常。 返回int。 tpl = (\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\", \"A\") aInTupIndex = tpl.index(\"A\") print(aInTupIndex) # 0 底层探究 内存开辟 Python内部实现中，列表和元组还是有一定的差别的。 元组在创建对象申请内存的时候，内存空间大小便进行了固定，后续不可更改（如果是传入了一个可迭代对象，例如tupe(range(100))，这种情况会进行扩容与缩容，下面的章节将进行详细研究）。 而列表在创建对象申请内存的时候，内存空间大小不是固定的，如果后续对其新增或删除数据项，列表会进行扩容或者缩容机制。 元组创建 空元组 若创建一个空元组，会直接进行创建，然后将这个空元组丢到缓存free_list中。 元组的free_list最多能缓存 20 * 2000 个元组，这个在下面会进行讲解。 如图所示： 元组转元组 下面的代码会进行元组转元组： tup = tuple((1, 2, 3)) 首先内部的参数本身就是一个元组（1， 2， 3），所以会直接将内部的这个元组拿出来并返回引用，并不会再次创建。 代码验证： >>> oldTpl = (1, 2, 3) >>> id(oldTpl) 4384908128 >>> newTpl = tuple(oldTpl) >>> id(newTpl) 4384908128 >>> 列表转元组 列表转元组会将列表中的每一个数据项都拿出来，然后放入至元组中： tpl = tuple([1, 2, 3]) 所以你会发现，列表和元组中的数据项引用都是相同的： >>> lst = [\"A\", \"B\", \"C\"] >>> tpl = tuple(lst) >>> print(id(lst[0])) 4383760656 >>> print(id(tpl[0])) 4383760656 >>> 可迭代对象转元组 可迭代对象是没有长度这一概念的，如果是可迭代对象转换为元组，会先对可迭代对象的长度做一个猜想。 并且根据这个猜想，为元组开辟一片内存空间，用于存放可迭代对象的数据项。 然后内部会获取可迭代对象的迭代器，对其进行遍历操作，拿出数据项后放至元组中。 如果猜想的长度太小，会导致元组内部的内存不够存放下所有的迭代器数据项，此时该元组会进行内部的扩容机制，直至可迭代对象中的数据项全部被添加至元组中。 rangeObject = range(1, 101) tpl = tuple(rangeObject) // 假如猜想的是9 // 第一步：+ 10 // 第二步：+ (原长度+10) * 0.25 // 其实，就是增加【原长度*0.25 + 2.5】 // 即第一次新增4个槽位 如果猜想的长度太大，而实际上迭代器中的数据量偏少，则需要对该元组进行缩容。 切片取值 对元组进行切片取值的时候，会开辟一个新元组用于存放切片后得到的数据项。 tpl = (1, 2, 3) newSliceTpl = tpl[0:2] 当然，如果是[:]的操作，则参照绝对引用，直接返回被切片的元组引用。 代码验证： >>> id(tpl) 4384908416 >>> newSliceTpl = tpl[0:2] >>> id(newSliceTpl) 4384904392 缓存机制 free_list缓存 元组的缓存机制和列表的缓存机制不同。 元组的free_list会缓存0 - 19长度的共20种元组，其中每一种长度的元组通过单向链表横向扩展缓存至2000个，如下图所示： 当每一次del操作有数据项的元组时，都会将该元组数据项清空并挂载至free_list单向链表的头部的位置。 del (1, 2, 3) --> (None, None, None) \\ del (4, 5, 6) --> (None, None, None) -> free_list 长度3的元组 ... del (7, 8, 9) --> (None, None, None) / 如下图所示： 当要创建一个元组时，会通过创建元组的长度，从free_list单向链表的头部取出一个元组，然后将数据项存放进去。 前提是free_list单向链表中缓存的有该长度的元组。 tup = (1, 2, 3) # 长度为3，从free_list的长度为3的元组中取 空元组与非空元组的缓存 空元组的缓存是一经创建就缓存到free_list单向链表中。 而非空元组的缓存必须是del操作后才缓存到free_list单向链表中。 空元组的创建 第一次创建空元组后，空元组会缓存至free_list单向链表中。 以后的每一次空元组创建，返回的其实都是同一个引用，也就是说空元组在free_list单向链表中即使被引用了也不会被销毁。 >>> t1 = () >>> id(t1) 4511088712 >>> t2 = () >>> id(t2) 4511088712 非空元组的创建 创建非空元组时，先检查free_list，当free_list单向链表中有相同长度的元组时，会进行引用并删除。 这个在上图中已经示例过了，就是这个： 代码示例： $ python3 Python 3.6.8 (v3.6.8:3c6b436a57, Dec 24 2018, 02:04:31) [GCC 4.2.1 Compatible Apple LLVM 6.0 (clang-600.0.57)] on darwin Type \"help\", \"copyright\", \"credits\" or \"license\" for more information. >>> v1 = (None, None, None) >>> id(v1) 4384907696 >>> v2 = (None, None, None) >>> id(v2) 4384908056 >>> del v1 >>> del v2 # ❶ >>> v3 = (None, None, None) >>> id(v3) # ❷ 4384908056 >>> v4 = (None, None, None) >>> id(v4) # ❸ 4384907696 >>> ❶：free_list num_free=3 单向链表结构：v2 —> v1 ❷：创建了v3，拿出v2的空元组，填入v3数据项，故v2和v3的id值相等，证明引用同一个元组，此时free_list num_free=3 单向链表结构为：—> v1 ❸：创建了v4，拿出v1的空元组，填入v4数据项，故v1和v4的id值相等，证明引用同一个元组 tupleobject.c源码 官网参考：点我跳转 源码一览：点我跳转 以下是截取了一些关键性源代码，并且做上了中文注释，方便查阅。 每一个元组都有几个关键性的属性： Py_ssize_t ob_refcnt; // 引用计数器 Py_ssize_t ob_size; // 数据项个数，即元组大小 PyObject *ob_item[1]; // 存储元组中的数据项 [指针, ] 关于缓存free_list的属性： PyTuple_MAXSAVESIZE // 相当于图中的 free_num ，最大20，即纵向扩展的缓存元组长度 PyTuple_MAXFREELIST // 图中 free_list 的横向扩展缓存列表个数，最大2000 创建元组 空元组 PyObject * PyTuple_New(Py_ssize_t size) { PyTupleObject *op; // 缓存相关 Py_ssize_t i; // 元组的大小不能小于0 if (size 0 // 创建空元组，优先从缓存中获取 // size = 0 表示这是一个空元组，从free_list[0]中获取空元组 if (size == 0 && free_list[0]) { // op就是空元组 op = free_list[0]; // 新增空元组引用计数器 + 1 Py_INCREF(op); #ifdef COUNT_ALLOCS tuple_zero_allocs++; #endif // 返回空元组的指针 return (PyObject *) op; } // 如果创建的不是空元组，且这个创建的元组数据项个数小于20，并且free_list[size]不等于空，表示有缓存 // 则从缓存中去获取，不再重新开辟内存 if (size ob_item[0]; // num_free减1 numfree[size]--; #ifdef COUNT_ALLOCS fast_tuple_allocs++; #endif /* Inline PyObject_InitVar */ // 初始化，定义这个元组的长度为数据项个数 #ifdef Py_TRACE_REFS Py_SIZE(op) = size; // 定义类型为 tuple Py_TYPE(op) = &PyTuple_Type; #endif // 增加一次新的引用 _Py_NewReference((PyObject *)op); } // 如果是空元组 else #endif { // 检查内存情况，是否充足 /* Check for overflow */ if ((size_t)size > ((size_t)PY_SSIZE_T_MAX - sizeof(PyTupleObject) - sizeof(PyObject *)) / sizeof(PyObject *)) { return PyErr_NoMemory(); } // 开辟内存，并获得一个元组：op op = PyObject_GC_NewVar(PyTupleObject, &PyTuple_Type, size); if (op == NULL) return NULL; } // 空元组的每一个槽位都是NULL for (i=0; i ob_item[i] = NULL; #if PyTuple_MAXSAVESIZE > 0 // 缓存空元组 if (size == 0) { free_list[0] = op; ++numfree[0]; Py_INCREF(op); /* extra INCREF so that this is never freed */ } #endif #ifdef SHOW_TRACK_COUNT count_tracked++; #endif // 将元组加入到GC机制中，用于内存管理 _PyObject_GC_TRACK(op); return (PyObject *) op; } 可迭代对象转元组 这个不在tupleobject.c源码中，而是在abstract.c源码中。 官网参考：点我跳转 源码一览：点我跳转 PyObject * PySequence_Tuple(PyObject *v) { PyObject *it; /* iter(v) */ Py_ssize_t n; /* guess for result tuple size */ PyObject *result = NULL; Py_ssize_t j; if (v == NULL) { return null_error(); } /* Special-case the common tuple and list cases, for efficiency. */ // 如果是元组转换元组，如 tup = (1, 2, 3) 或者 tup = ((1, 2, 3))直接返回内存地址 if (PyTuple_CheckExact(v)) { Py_INCREF(v); return v; } // 如果是列表转换元组，则执行PyList_AsTuple()，将列表转换为元组 // 如 tup = ([1, 2, 3]) if (PyList_CheckExact(v)) return PyList_AsTuple(v); /* Get iterator. */ // 获取迭代器， tup = (range(1, 4).__iter__()) it = PyObject_GetIter(v); if (it == NULL) return NULL; /* Guess result size and allocate space. */ // 猜想迭代器长度，也就是猜一下有多少个数据项 n = PyObject_LengthHint(v, 10); if (n == -1) goto Fail; // 根据猜想的迭代器长度，进行元组的内存开辟 result = PyTuple_New(n); if (result == NULL) goto Fail; /* Fill the tuple. */ // 将迭代器中每个数据项添加至元组中 for (j = 0; ; ++j) { PyObject *item = PyIter_Next(it); if (item == NULL) { if (PyErr_Occurred()) goto Fail; break; } //如果迭代器中数据项比猜想的多，则证明开辟内存不足需要需要进行扩容 if (j >= n) { size_t newn = (size_t)n; /* The over-allocation strategy can grow a bit faster than for lists because unlike lists the over-allocation isn't permanent -- we reclaim the excess before the end of this routine. So, grow by ten and then add 25%. */ // 假如猜想的是9 // 第一步：+ 10 // 第二步：+ (原长度+10) * 0.25 // 其实，就是增加【原长度*0.25 + 2.5】 newn += 10u; newn += newn >> 2; // 判断是否超过了元组的数据项个数限制（sys.maxsize） if (newn > PY_SSIZE_T_MAX) { /* Check for overflow */ PyErr_NoMemory(); Py_DECREF(item); goto Fail; } n = (Py_ssize_t)newn; // 扩容机制 if (_PyTuple_Resize(&result, n) != 0) { Py_DECREF(item); goto Fail; } } // 将数据项放入元组之中 PyTuple_SET_ITEM(result, j, item); } /* Cut tuple back if guess was too large. */ // 如果猜想的数据项太多，而实际上迭代器中的数据量偏少 // 则需要对该元组进行缩容 if (j 列表转元组 这个不在tupleobject.c源码中，而是在listobject.c源码中。 官网参考：点我跳转 源码一览：点我跳转 PyObject * PyList_AsTuple(PyObject *v) { PyObject *w; PyObject **p, **q; Py_ssize_t n; // 例如：tup = ([1, 2, 3]) // 进行列表的验证 if (v == NULL || !PyList_Check(v)) { PyErr_BadInternalCall(); return NULL; } // 获取大小，即数据项个数 n = Py_SIZE(v); // 开辟内存 w = PyTuple_New(n); // 如果是空元组 if (w == NULL) return NULL; // 执行迁徙操作 p = ((PyTupleObject *)w)->ob_item; q = ((PyListObject *)v)->ob_item; // 将列表中数据项的引用，也给元组进行引用 // 这样列表中数据项和元组中的数据项都引用同1个对象 while (--n >= 0) { // 数据项引用计数 + 1 Py_INCREF(*q); *p = *q; p++; q++; } // 返回元组 return w; } 切片取值 PyObject * PyTuple_GetSlice(PyObject *op, Py_ssize_t i, Py_ssize_t j) // 切片会触发该方法 { // 如果对空元组进行切片，则会抛出异常 if (op == NULL || !PyTuple_Check(op)) { PyErr_BadInternalCall(); return NULL; } // 内部的具体实现方法 return tupleslice((PyTupleObject *)op, i, j); } static PyObject * tupleslice(PyTupleObject *a, Py_ssize_t ilow, Py_ssize_t ihigh) { PyTupleObject *np; PyObject **src, **dest; Py_ssize_t i; Py_ssize_t len; // 计算索引位置 if (ilow Py_SIZE(a)) ihigh = Py_SIZE(a); if (ihigh ob_item + ilow; dest = np->ob_item; // 对源元组中的数据项的引用计数+1 for (i = 0; i 缓存相关 static void tupledealloc(PyTupleObject *op) { Py_ssize_t i; Py_ssize_t len = Py_SIZE(op); PyObject_GC_UnTrack(op); Py_TRASHCAN_SAFE_BEGIN(op) // 如果元组的长度大于0，则不是一个非空元组 if (len > 0) { i = len; // 将内部的数据项引用计数都 - 1 while (--i >= 0) Py_XDECREF(op->ob_item[i]); #if PyTuple_MAXSAVESIZE > 0 // 准备缓存，判断num_free是否小于20，并且单向链表中的已缓存元组个数小于2000 if (len ob_item[0] = (PyObject *) free_list[len]; // 将num_free + 1 numfree[len]++; free_list[len] = op; goto done; /* return */ } #endif } // 内存中进行销毁 Py_TYPE(op)->tp_free((PyObject *)op); done: Py_TRASHCAN_SAFE_END(op) } Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-13 20:41:50 "},"Python/Python基础知识/字符串类型.html":{"url":"Python/Python基础知识/字符串类型.html","title":"字符串类型","keywords":"","body":"字符串 字符串（str）一般是指Unicode字符串，见名知意，字符串是由多个字符所构成的一个串。 它是Python中最常用的数据类型之一，因此十分重要。 字符串有一个最显著的特征，即不可变，也就是说你无法使用索引来改变字符串中的字符，仅限于获取。 字符串特性 字符串特性如下： 字符串属于线性扁平序列 字符串是不可变的，即对象本身的属性不会根据外部变化而变化 字符串底层是一段连续的内存空间 基本声明 以下是使用类实例化的形式进行对象声明： string = str(\"ABCDEFG\") print(\"value : %r\\ntype : %r\" % (string, type(string))) # value : 'ABCDEFG' # type : 也可以选择使用更方便的字面量形式进行对象声明，使用英文状态下的单引号、双引号、三单引号、三双引号将数据项进行包裹即可： string = \"ABCDEFG\" print(\"value : %r\\ntype : %r\" % (string, type(string))) # value : 'ABCDEFG' # type : 个人并不推荐常规的使用三单引号或三双引号进行字符串定义，因为除了字符串定义外它们还具有文档注释的功能。 续行操作 在Python中，如果一个字符串过长，可能会导致不符合PEP8规范的情况出现。 每行最大的字符数不可超过79，文档字符或者注释每行不可超过72 如果要定义这样的长字符串，推荐使用三单引号或者三双引号进行定义，这样即可进行换行（但会保留特殊字符，如\\n）: string = \"\"\" 江雪 柳宗元 千山鸟飞绝 万径人踪灭 孤舟蓑笠翁 独钓寒江雪 \"\"\" print(\"value : %r\\ntype : %r\" % (string, type(string))) # value : '\\n 江雪\\n 柳宗元\\n千山鸟飞绝\\n万径人踪灭\\n孤舟蓑笠翁\\n独钓寒江雪\\n' # type : 类型转换 字符串支持与布尔型、整形、以及浮点型进行转换，这是最常用的操作： string = \"100\" iStr = int(string) bStr = bool(string) fStr = float(string) print(\"value : %r\\ntype : %r\" % (iStr, type(iStr))) print(\"value : %r\\ntype : %r\" % (bStr, type(bStr))) print(\"value : %r\\ntype : %r\" % (fStr, type(fStr))) # value : 100 # type : # value : True # type : # value : 100.0 # type : 需要注意的是，如果一个字符串不是纯数字，那么将其转换为整形或浮点型时将会出现异常： string = \"Non-digital string: 100\" iStr = int(string) fStr = float(string) print(\"value : %r\\ntype : %r\" % (iStr, type(iStr))) print(\"value : %r\\ntype : %r\" % (fStr, type(fStr))) # ValueError: invalid literal for int() with base 10: 'Non-digital string: 100' 此外，字符串也支持转换为列表以及集合： string = \"①〇②④\" setStr = set(string) listStr = list(string) print(\"value : %r\\ntype : %r\" % (setStr, type(setStr))) print(\"value : %r\\ntype : %r\" % (listStr, type(listStr))) # value : {'①', '〇', '②', '④'} # type : # value : ['①', '〇', '②', '④'] # type : 特殊的\\ 在普通的声明字符串中，\\后面一般都会跟上一个特殊字符。 该字符具有特殊的意义，如\\n代表换行，\\t代表制表符等，这种具有特殊意义的\\char组合被称为转义字符。 转义字符 意义 ASCII码值（十进制） \\a 响铃(BEL) 007 \\b 退格(BS) ，将当前位置移到前一列 008 \\f 换页(FF)，将当前位置移到下页开头 012 \\n 换行(LF) ，将当前位置移到下一行开头 010 \\r 回车(CR) ，将当前位置移到本行开头 013 \\t 水平制表(HT) （跳到下一个TAB位置） 009 \\v 垂直制表(VT) 011 \\ 代表一个反斜线字符''' 092 \\' 代表一个单引号（撇号）字符 039 \\\" 代表一个双引号字符 034 ? 代表一个问号 063 \\0 空字符(NUL) 000 \\ddd 1到3位八进制数所代表的任意字符 三位八进制 \\xhh 十六进制所代表的任意字符 十六进制 如果你还是不能理解，那么可看下面这个示例： 我想打印 hello”world，并且我的字符串字面量声明采用 “ 进行包裹。 我们必须进行“的转义，让它变为一个普通字符，而非Python中字符串字面量语法表示符： print(\"hello\\\"world\") # hello\"world r字符串 如果在声明字符串的前面加上字符r，则代表该字符串中不会存在转义字符，所有字符将按照普通的方式进行解读。 r字符串也被称为原始字符串： s1 = r\"\\n\\t\\b\" print(s1) # \\n\\t\\b 字节串 字节串（bytes）是字符串的另一种表现形式。 它记录内存中的原始数据，你可以将它理解为2进制数据。 字节串可用于网络传输、多媒体持久化存储中，它和字符串拥有相同的特性，即不可变。 字节串仅在Python3中出现，Python2中不存在该类型。 基本声明 以下是使用类实例化的形式进行对象声明，必须传入一个字符串及指定该字符串的编码格式，如不传入字符串，则默认生成空的bytes对象： bitStr = bytes(\"ABCDEFG\".encode(\"u8\")) print(\"value : %r\\ntype : %r\" % (bitStr, type(bitStr))) # value : b'ABCDEFG' # type : 也可以选择使用更方便的字面量形式进行对象声明，使用英文状态下的小写b加上单引号、双引号、三单引号、三双引号将数据项进行包裹即可，注意数据项必须位于ASCII码表之内： bitStr = b\"ABCDEFG\" print(\"value : %r\\ntype : %r\" % (bitStr, type(bitStr))) # value : b'ABCDEFG' # type : 个人并不推荐常规的使用三单引号或三双引号进行字节串定义，它们还具有文档注释的功能。 编码解码 一个非ASCII标准字符串要变为字节串，必须通过encode()方法来做指定编码格式。 而一个字节串要想变为非ASCII标准字符串，也必须通过decode()方式做指定解码格式。 s = \"你好，世界，hello，world!\" bitStr = bytes(s.encode(encoding=\"u8\")) print(bitStr) string = str(bitStr.decode(encoding=\"u8\")) print(string) # b'\\xe4\\xbd\\xa0\\xe5\\xa5\\xbd\\xef\\xbc\\x8c\\xe4\\xb8\\x96\\xe7\\x95\\x8c\\xef\\xbc\\x8chello\\xef\\xbc\\x8cworld!' # 你好，世界，hello，world! 如果直接使用str.encode()则自动将str转变为bytes类型。 反之，如果直接使用bytes.decode()时bytes也会自动转为str类型。 因此我们可以省略bytes()和str()在外部的包裹： s = \"你好，世界，hello，world!\" bitStr = s.encode(encoding=\"u8\") print(bitStr) string = bitStr.decode(encoding=\"u8\") print(string) # b'\\xe4\\xbd\\xa0\\xe5\\xa5\\xbd\\xef\\xbc\\x8c\\xe4\\xb8\\x96\\xe7\\x95\\x8c\\xef\\xbc\\x8chello\\xef\\xbc\\x8cworld!' # 你好，世界，hello，world! 四则运算 基本操作 字符串支持与字符串进行加法运算，做到拼接的效果，由于字符串是不可变的，所以会生成一个新的字符串： s1 = \"string1\" s2 = \"string2\" print(s1 + s2) # string1string2 字符串支持与整形进行乘法运算，做到重复打印的效果，由于字符串是不可变的，所以会生成一个新的字符串： s1 = \"*\" print(s1 * 3) # *** “可变”的字符串 str可以使用+=操作，来使原本的字符串与新的字符串进行拼接。 +=是一种常见的操作，所以CPython内部为其做了优化。 一个str在初始化内存的时候，程序会为它留出额外的可扩展空间，因此进行增量操作的时候，并不会涉及复制原有字符串到新位置这类操作，而是在原有字符串位置的后面添加上新的字符串。 基于这个点，我们看一个有趣的问题： >>> a 'hello world !' >>> id(a) 140521043795728 >>> a+=\"d\" >>> id(a) 140521043795728 >>> a+=\"d\" >>> id(a) 140521043795728 >>> a 'hello world !dd' 乍看之下其实会发现字符串的+=操作并不会开辟额外的内存空间，但是事实并非如此。 CPython的字符串在底层依旧是不可变的，当这个字符串被+=新的字符串时，会产生一个新的字符串，恰好该字符串会复用之前字符串的id()值。 这个问题在stackoverflow上已经有人问过了，这里贴出原贴： 点我跳转 字符间隙 看一个有趣的例子： s1 = \"HELLO\" boolRET = \"\" in s1 print(boolRET) # True 下一个例子，使用count()方法计算该字符串中空白字符的数量： s1 = \"HELLO\" print(s1.count(\"\")) # 6 小问号你是否充满了很多朋友？ 实际上，Python内部进行str存储的时候会为每个字符之间留一个空隙，如下所示： 所以才会造成上述情况的发生。 intern机制 intern机制是Python解释器为了节省内存而做出的一种策略。 当第一次创建一个短字符串的时候，都会用一个全局的字典将该字符串进行存储，而短字符串的定义如下： 长度不超过20 不含空格 当再次创建这个短字符串，会先查看全局字典中是否存在该短字符串，如果存在则不创建而是直接进行引用。 这种策略也被称之为短字符串驻留机制。 下面这个示例字符串是符合短字符串的，因此会进行驻留： >>> s1 = \"Python\" >>> s2 = \"Python\" >>> s1 is s2 True 由于字符串中含有空格，故该字符串不会触发驻留机制： >>> s1 = \"Pytho n\" >>> s2 = \"Pytho n\" >>> s1 is s2 False 字符串长度超过20，也不会触发驻留机制： >>> s1 = \"Python\" * 10 >>> s2 = \"Python\" * 10 >>> s1 is s2 False 如果是空字符串，也会有驻留机制： >>> s1 = \"\" >>> s2 = \"\" >>> id(s1) 4360137392 >>> id(s2) 4360137392 绝对引用 字符串拥有绝对引用的特性，则无论是深拷贝还是浅拷贝，都不会获得其副本，而是直接对源对象进行引用： >>> import copy >>> oldStr = \"0\" * 100 >>> id(oldStr) 4373971144 >>> s1 = copy.copy(oldStr) >>> id(s1) 4373971144 >>> s2 = copy.deepcopy(oldStr) >>> id(s2) 4373971144 索引切片 字符串由于是线性结构，故支持索引和切片操作。 由于字符串是不可变类型，所以索引操作也仅支持获取数据项，不支持删改数据项。 使用方法参照列表的索引切片一节。 常用方法 方法一览 常用的str方法一览： 方法名 返回值 描述 strip() str 移除字符串两侧指定的字符，如不进行指定，则默认移除\\n、\\t以及空格。 split() list 按照指定字符进行从左到右的分割，以列表形式返回。可指定maxslipt限制切分次数 rsplit() list 按照指定字符进行从右到左的分割，以列表形式返回。可指定maxslipt限制切分次数 join() str 将一个列表中的数据项以指定字符拼接成新的字符串 replace() str 将字符串中的指定子串替换成另一个子串 count() integer 统计子串在父串中出现的次数 title() str 令字符串中的每一个单词首字母大写 capitalize() Str 令字符串中的句首单词首字母变为大写 find() integer 查找子串首次出现在父串中的索引值，若存在则返回索引，若不存在则返回-1，从左至右查找 rfind() integer 同上，从右至左查找 upper() str 令字符串中所有的小写字母转换为大写 lower() str 令字符串中所有的大写字母转换为小写 startswith() bool 判断字符串是否以特定子串开头 endswith() bool 判断字符串是否以特定子串结束 isdigit() bool 判断该字符串是否是一个数字串 基础公用函数： 函数名 返回值 描述 len() integer 返回容器中的项目数 enumerate() iterator for index, value of iterable 返回一个可迭代对象，其中以小元组的形式包裹数据项与正向索引的对应关系 reversed() ... 详情参见函数章节 sorted() ... 详情参见函数章节 获取长度 使用len()方法来进行字符串长度的获取。 返回int类型的值。 s1 = \"abcdefg\" print(len(s1)) # 7 Python在对内置的数据类型使用len()方法时，实际上是会直接的从PyVarObject结构体中获取ob_size属性，这是一种非常高效的策略。 PyVarObject是表示内存中长度可变的内置对象的C语言结构体。 直接读取这个值比调用一个方法要快很多。 移除空白 使用strip()方法移除字符串两侧指定的字符，如不进行指定，则默认移除\\n、\\t以及空格。 返回str类型的值。 s1 = \" abcdefg $$$\" res = s1.strip(\" $\") print(res) # abcdefg 拆分列表 使用split()方法按照指定字符进行从左到右的分割，以列表形式返回。可指定maxslipt限制切分次数。 返回list类型的值。 s1 = \"ab,cd,ef,gh\" res = s1.split(\",\",maxsplit=1) print(res) # ['ab', 'cd,ef,gh'] 使用rsplit()方法按照指定字符进行从右到左的分割，以列表形式返回。可指定maxslipt限制切分次数。 返回list类型的值。 s1 = \"ab,cd,ef,gh\" res = s1.rsplit(\",\",maxsplit=1) print(res) # ['ab,cd,ef', 'gh'] 列表合并 使用join()方法将一个列表中的数据项以指定字符拼接成新的字符串。 返回str类型的值。 l1 = [\"a\",\"b\",\"c\"] res = \"-\".join(l1) print(res) # a-b-c 替换操作 使用replace()方法将字符串中的指定子串替换成另一个子串。 返回str类型的值。 s1 = \"ABCDEFG\" res = s1.replace(\"BCD\",\"bcd\") print(res) # AbcdEFG 次数统计 使用count()方法统计子串在父串中出现的次数。 返回int类型的值。 s1 = \"HELLO\" res = s1.count(\"L\") print(res) # 2 词首大写 使用title()方法令字符串中的每一个单词首字母大写。 返回str类型的值。 s1 = \"hello world\" res = s1.title() print(res) # Hello World 句首大写 使用capitalize()方法令字符串中的句首单词变为大写。 返回str类型的值。 s1 = \"hello world\" res = s1.capitalize() print(res) # Hello world 索引位置 使用find()方法查找子串首次出现在父串中的索引值，若存在则返回索引，若不存在则返回-1，这是从左至右查找，rfind()则是从右至左查找。 返回int类型的值。 s1 = \"hello world\" res = s1.find(\"w\") print(res) # 6 小写转大写 使用upper()方法令字符串中所有的小写字母转换为大写。 返回str类型的值。 s1 = \"hello world\" res = s1.upper() print(res) # HELLO WORLD 大写转小写 使用lower()方法令字符串中所有的大写字母转换为小写。 返回str类型的值。 s1 = \"HELLO WORLD\" res = s1.lower() print(res) # hello world 指定开头 使用startswith()方法判断字符串是否以特定子串开头。 返回bool类型的值。 s1 = \"HELLO WORLD\" res = s1.startswith(\"HE\") print(res) # True 指定结尾 使用endswith()方法判断字符串是否以特定子串结束。 返回bool类型的值。 s1 = \"HELLO WORLD\" res = s1.endswith(\"LD\") print(res) # False 数字串 使用isdigit()方法判断该字符串是否是一个数字串。 返回bool类型的值。 s1 = \"100\" res = s1.isdigit() print(res) # True 其他方法 以下是一些其他不太常用的方法： 方法名 返回值 描述 index() integer 同find()，唯一区别找不到抛出异常，find()是返回-1，从左至右查找 rindex() integer 同上，从右至左查找 swapcase() str 字符串中大小进行翻转。大写转小写，小写转大写。 expandtabs() str 指定字符串中的tab长度，\\t代表制表符，默认长度为8 center() str 指定宽度，指定字符。若字符串的长度不够则将字符串放在中间，两侧使用指定字符填充 ljust() str 指定宽度，指定字符。若字符串的长度不够则将字符串放在左边，右侧使用指定字符填充 rjust() str 指定宽度，指定字符。若字符串的长度不够则将字符串放在右边，左侧使用指定字符填充 zfill() str 同rjust()，但是不可指定填充字符。按0进行填充 isdecimal() bool 判断字符串是否由数字组成。只支持unicode并且没有bytes的使用 isnumeric() bool 判断字符串是否由数字组成。只支持unicode，中文数字，罗马数字并且没有bytes的使用 isalnum() bool 判断字符串是否仅由数字和字母构成 isalpha() bool 判断字符串是否仅由字母构成 isspace() bool 判断字符串是否仅由空格构成 islower() bool 判断字符串是否纯小写 isupper() bool 判断字符串是否纯大写 istitle() bool 判断字符串中的单词是否首字母大写 index()与rindex()方法： s1 = \"Python\" s1.index(\"a\") s1.rindex(\"a\") # ValueError: substring not found 字符串翻转swapcase()方法： s1 = \"Python\" print(s1.swapcase()) # pYTHON 指定制表符长度的expandtabs()方法，默认制表符的长度为8，下面指定为4： s1 = \"P\\ty\\tt\\th\\to\\tn\" print(s1) print(s1.expandtabs(4)) # P y t h o n # P y t h o n 字符填充系列： s2 = \"H\" print(s2.center(20, \"+\")) print(s2.ljust(20, '+')) print(s2.rjust(20, '+')) print(s2.zfill(20)) # 0 填充，不可指定填充字符 # 其实总体来说就是将一个字符必须按照指定字符扩展为指定长度 # 区别在于源字符串的位置在指定填充符的中间、左侧、还是右侧 # +++++++++H++++++++++ # H+++++++++++++++++++ # +++++++++++++++++++H # 0000000000000000000H 字符串判断系列之数字串检测： s1 = b\"4\" # 字节数字串 s2 = u\"4\" # unicode数字串，默认Python3的str就是unicode编码，可以不用加u s3 = \"四\" # 中文数字串 s4 = \"Ⅳ\" # 罗马数字串 # isdigt()检测是否为数字串，只支持bytes和unicode print(s1.isdigit()) # True print(s2.isdigit()) # True print(s3.isdigit()) # False print(s4.isdigit()) # False # isdecimal()检测是否为数字串，只支持unicode字符串，如果是bytes字节串则抛出异常 print(s2.isdecimal()) # True print(s3.isdecimal()) # False print(s4.isdecimal()) # False # isnumeric()检测是否为数字串，不支持bytes字节串，支持unicode字符串、中文数字串、罗马数字串 print(s2.isnumeric()) # True print(s3.isnumeric()) # True print(s4.isnumeric()) # True 字符串判断之成员检测： s1 = \"Python3.6.8\" # isalnum() 判断字符串是否仅由数字和字母构成 print(s1.isalnum()) # False # isalpha() 判断字符串是否仅由字母构成 print(s1.isalpha()) # False # isspace() 判断字符串是否仅由空格构成 print(s1.isspace()) # False 字符串判断之大小写检测： s1 = \"Python3.6.8\" # islower() 判断字符串是否纯小写 print(s1.islower()) # False # isupper() 判断字符串是否纯大写 print(s1.isupper()) # False # istitle() 判断字符串中的单词是否首字母大写 print(s1.istitle()) # True 版本区别 数字与字符串对比 在Python2中是支持字符串与数字进行比较的，字符串永远比数字大： >>> \"0\" > 1 True 但是在Python3中，这种比较会抛出异常： >>> \"0\" > 1 Traceback (most recent call last): File \"\", line 1, in TypeError: '>' not supported between instances of 'str' and 'int' 表现形式 Python2的字符串表现形式为原始字节序列，也就是说Python2的str其实实际上是Python3的字节串，故仅支持在ASCII码表之内的字符： >>> s1 = \"你好，世界\" >>> s1 '\\xe4\\xbd\\xa0\\xe5\\xa5\\xbd\\xef\\xbc\\x8c\\xe4\\xb8\\x96\\xe7\\x95\\x8c' 但是在Python3中的字符串表现形式不是这样的，Python3中的字符串统一都为Unicode字符串： >>> s1 = \"你好，世界\" >>> s1 '你好，世界' 底层探究 扁平序列 这里引出一个新的概念，线性扁平序列。 扁平序列其实更加紧凑，但是它里面只能存放诸如字符、字节和数值这种基础类型 扁平序列里存放的是值而不是引用 扁平序列不支持多维的说法，仅有一个维度 字符串为什么要设计成不可变类型？这是由于字符串内部是采用连续存储的方式。 因为字符串是连续的一块内存存放（在c语言体现中其实是一个数组，以\\0结尾），被看做为一个整体，修改其中某一个数据项那么必定会导致后面的内存发生变化，链式反应滚起雪球需要处理的数据量很庞大，于是Python干脆不支持修改字符串。 strobject.c源码 官网参考：点我跳转 源码一览：点我跳转 关于字符串的源码阅读，感兴趣的朋友可以看一下，这里不再进行延伸阅读。 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-13 20:41:50 "},"Python/Python基础知识/字典类型.html":{"url":"Python/Python基础知识/字典类型.html","title":"字典类型","keywords":"","body":"字典 Python中的字典（dict）也被称为映射（mapping）或者散列（hash），是支持Python底层实现的重要数据结构。 同时，它也是应用最为广泛的数据结构，内部采用hash存储，存储方式为键值对。 字典本身属于可变容器类型，但键（key）必须为不可变类型，而值（value）可以是任意类型。。 字典的优点是单点查找速度极快，但不能够支持范围查找，此外也比较占用内存。 字典特性 字典特性如下： 字典是一个可变的容器类型 字典内部由散列表组成 字典的单点读写速度很快，但是不支持范围查找 字典的key必须是不可变的，只有不可变对象才能被hash 字典在3.6之后变得有序了，这样做提升了遍历效率 基本声明 以下是使用类实例化的形式进行对象声明： userInfo = dict(name=\"YunYa\", age=18, hobby=[\"football, music\"]) print(\"value : %r\\ntype : %r\" % (userInfo, type(userInfo))) # value : {'name': 'YunYa', 'age': 18, 'hobby': ['football, music']} # type : 也可以选择使用更方便的字面量形式进行对象声明，使用{}对键值对进行包裹，键值对采用k:v的形式分割，多个键值对之间使用逗号进行分割： userInfo = {\"name\": \"YunYa\", \"age\": 18, \"hobby\": [\"football, music\"]} print(\"value : %r\\ntype : %r\" % (userInfo, type(userInfo))) # value : {'name': 'YunYa', 'age': 18, 'hobby': ['football, music']} # type : 声明字典时，千万注意key只能是不可变类型。 如字符串（str），整形（int），浮点型（float），布尔型（bool），元组类型（tuple）等等均可设置为字典的key，但使用可变类型作为key时则会抛出异常。 续行操作 在Python中，字典中的键值对如果过多，可能会导致整个字典太长，太长的字典是不符合PEP8规范的。 每行最大的字符数不可超过79，文档字符或者注释每行不可超过72 Python虽然提供了续行符\\，但是在字典中可以忽略续行符，如下所示： userInfo = { \"name\": \"YunYa\", \"age\": 18, \"hobby\": [\"football, music\"]} print(\"value : %r\\ntype : %r\" % (userInfo, type(userInfo))) # value : {'name': 'YunYa', 'age': 18, 'hobby': ['football, music']} # type : 多维嵌套 字典中可以进行多维嵌套，如字典套字典，字典套元组，字典套列表等： dic = { \"k1\": [1, 2, 3], \"k2\": (1, 2, 3), \"k3\": { \"k3-1\": 1, \"k3-2\": 2, }, } 类型转换 字典可以与布尔类型和字符串进行转换，这是最常用的： dic = {\"k1\": \"v1\", \"k2\": \"v2\"} boolDict = bool(dic) strDict = str(dic) print(\"value : %r\\ntype : %r\" % (boolDict, type(boolDict))) print(\"value : %r\\ntype : %r\" % (strDict, type(strDict))) # value : True # type : # value : \"{'k1': 'v1', 'k2': 'v2'}\" # type : 如果要将字典转换为列表、元组、集合类型，直接转换只会拿到键，并不会拿到值。 尤其注意这一点，但是其实这样用的场景十分少见，记住就行了： dic = {\"k1\": \"v1\", \"k2\": \"v2\"} listDict = list(dic) tupleDict = tuple(dic) setDict = set(dic) print(\"value : %r\\ntype : %r\" % (listDict, type(listDict))) print(\"value : %r\\ntype : %r\" % (tupleDict, type(tupleDict))) print(\"value : %r\\ntype : %r\" % (setDict, type(setDict))) # value : ['k1', 'k2'] # type : # value : ('k1', 'k2') # type : # value : {'k1', 'k2'} # type : 重复key 一个字典中的key必须是唯一的，若不是唯一的则value可能面临被覆盖的危险： dic = {\"name\": \"云崖\", \"age\": 18, \"name\": \"Yunya\"} print(dic) # {'name': 'Yunya', 'age': 18} 同理，True和1，False和0也会彼此进行覆盖： dic = {True: \"云崖\", \"age\": 18, 1: \"Yunya\"} print(dic) # {True: 'Yunya', 'age': 18} []操作字典 由于字典并非线性结构，故不支持索引操作。 但是字典也提供了[]操作语法，它是根据key来操作value的。 增删改查 以下示例展示了如何使用[]对字典中的value进行操纵： dic = {\"k1\": \"v1\", \"k2\": \"v2\"} # 增 dic[\"k3\"] = \"v3\" print(dic) # {'k1': 'v1', 'k2': 'v2', 'k3': 'v3'} # 删，如果没有该key，则抛出keyError del dic[\"k2\"] print(dic) # {'k1': 'v1', 'k3': 'v3'} # 改，如果没有该key，则抛出keyError dic[\"k3\"] = \"VV3\" print(dic) # {'k1': 'v1', 'k3': 'VV3'} # 查，如果没有该key，则抛出keyError result = dic[\"k1\"] print(result) # v1 多维操作 字典套列表的多维操作如下，首先需要拿到该列表： dic = {\"k1\": [1, 2, 3, 4]} # 取出3 result = dic[\"k1\"][2] print(result) # 3 # k1的列表，添加数据项 \"A\" dic[\"k1\"].append(\"A\") print(dic) # {'k1': [1, 2, 3, 4, 'A']} 字典套字典的多维操作如下，首先需要拿到被操纵的字典： dic = { \"k1\":{ \"k1-1\":{ \"k1-2\":{ \"k1-3\":\"HELLO,WORLD\", } } } } # 拿到 k1-3 对应的value result = dic[\"k1\"][\"k1-1\"][\"k1-2\"][\"k1-3\"] print(result) # HELLO,WORLD 解构语法 **语法 **语法用于将字典中的k:v全部提取出来。 我们可以利用该语法的特性来对字典进行合并，将两个旧字典合并成一个新字典： dic_1 = {\"d1k1\": \"A\", \"d1k2\": \"B\"} dic_2 = {\"d2k1\": \"C\", \"d2k2\": \"D\"} result = {**dic_1, **dic_2} print(result) # {'d1k1': 'A', 'd1k2': 'B', 'd2k1': 'C', 'd2k2': 'D'} 解构赋值 字典支持平行变量赋值操作吗？当然可以！但是这样只会拿到字典的key： dic = {\"k1\": \"v1\", \"k2\": \"v2\"} first, last = dic print(first) print(last) # k1 # k2 有办法拿到value么？借助字典的values()方法即可做到，它的本质是将value全部提取出来，组成一个可迭代对象： dic = {\"k1\": \"v1\", \"k2\": \"v2\"} first, last = dic.values() print(first) print(last) # v1 # v2 你可以理解为，将value全部提取出来组成一个列表，类似于[“v1”, “v2”]，在Python2中的确是这样，但是到了Python3中做法改变了，目前按下不表。 对于一些不想要的数据项，你也可以按照列表的解构赋值操作来进行，这里不再举例。 常用方法 方法一览 常用的dict方法一览： 方法名 返回值 描述 get() v or None 取字典key对应的value，如果key不存在返回None setdefault() v 获取字典key对应的value，如该字典中不存在被获取的key则会进行新增k:v，并返回v update() None 对原有的字典进行更新 pop() v 删除该字典中的键值对，如果不填入参数key或者key不存在则抛出异常 keys() Iterable 返回一个可迭代对象，该可迭代对象中只存有字典的所有key values() Iterable 返回一个可迭代对象，该可迭代对象中只存有字典的所有value items() Iterable 返回一个可迭代对象，该可迭代对象中存有字典中所有的key与value，类似于列表套元组 clear() None 清空当前字典 基础公用函数： 函数名 返回值 描述 len() integer 返回容器中的项目数 获取长度 使用len()方法来进行字典长度的获取。 返回int类型的值。 dic = {\"name\": \"云崖\", \"age\": 18} print(len(dic)) # 2 一组键值对被视为一个数据项，故2组键值对长度为2 Python在对内置的数据类型使用len()方法时，实际上是会直接的从PyVarObject结构体中获取ob_size属性，这是一种非常高效的策略。 PyVarObject是表示内存中长度可变的内置对象的C语言结构体。 直接读取这个值比调用一个方法要快很多。 get() 使用get()方法获取字典key对应的value，相比于[]操作更加的人性化，因为[]一旦获取不存在的key则会抛出异常，而该方法则是返回None。 dic = {\"name\": \"云崖\", \"age\": 18} username = dic.get(\"name\") userhobby = dic.get(\"hobby\") print(\"用户姓名:\",username) print(\"用户爱好:\",userhobby) # 用户姓名: 云崖 # 用户爱好: None setdefault() 使用setdefault()方法来获取字典key对应的value，如该字典中不存在被获取的key则会进行新增k:v，并返回v。 返回字典原有的value或者新设置的k:v。 dic = {\"name\": \"云崖\", \"age\": 18} # 字典有name，则取字典里的name username = dic.setdefault(\"name\",\"云崖先生\") # 字典没有hobby，则设置hobby的value为足球与篮球并返回 userhobby = dic.setdefault(\"hobby\",\"足球与篮球\") print(\"用户姓名:\",username) print(\"用户爱好:\",userhobby) # 用户姓名: 云崖 # 用户爱好: 足球与篮球 update() 使用update()方法对原有的字典进行更新。 返回None。 dic = {\"name\": \"云崖\", \"age\": 18} dic.update( {\"hobby\": [\"篮球\", \"足球\"]} ) print(dic) # {'name': '云崖', 'age': 18, 'hobby': ['篮球', '足球']} pop() 使用pop()方法删除该字典中的键值对，如果不填入参数key或者key不存在则抛出异常。 返回被删除的value。 dic = {\"name\": \"云崖\", \"age\": 18} result = dic.pop(\"age\") print(result) print(dic) # 18 # {'name': '云崖'} keys() 返回一个可迭代对象，该可迭代对象中只存有字典的所有key。 Python2中返回的是列表，Python3中返回的是可迭代对象。 dic = {\"name\": \"云崖\", \"age\": 18} key_iter = dic.keys() print(key_iter) # dict_keys(['name', 'age']) Python3中返回的对象被称为字典视图。它们提供了字典条目的一个动态视图，这意味着当字典改变时，视图也会相应改变。 values() 返回一个可迭代对象，该可迭代对象中只存有字典的所有value。 Python2中返回的是列表，Python3中返回的是可迭代对象。 dic = {\"name\": \"云崖\", \"age\": 18} value_iter = dic.values() print(value_iter) # dict_values(['云崖', 18]) Python3中返回的对象被称为字典视图。它们提供了字典条目的一个动态视图，这意味着当字典改变时，视图也会相应改变。 items() 返回一个可迭代对象，该可迭代对象中存有字典中所有的key与value，类似于列表套元组。 Python2中返回的是二维列表，Python3中返回的是可迭代对象。 dic = {\"name\": \"云崖\", \"age\": 18} items_iter = dic.items() print(items_iter) # dict_items([('name', '云崖'), ('age', 18)]) Python3中返回的对象被称为字典视图。它们提供了字典条目的一个动态视图，这意味着当字典改变时，视图也会相应改变。 clear() 清空当前字典。 返回None。 dic = {\"name\": \"云崖\", \"age\": 18} dic.clear() print(dic) # {} 其他方法 方法 返回值 描述 popitem() (k, v) 随机删除一组键值对,并将删除的键值放到元组内返回 fromkeys(iter,value) dict 第一个参数是可迭代对象，其中每一个数据项都为新生成字典的key，第二个参数为同一的value值 示例演示： dic1 = dict(k1=\"v1\", k2=\"v2\", k3=\"v3\", k4=\"v4\") print(dic1.popitem()) # ('k4', 'v4') dic2 = dict.fromkeys([1, 2, 3, 4], None) print(dic2) # {1: None, 2: None, 3: None, 4: None} 底层探究 高效查找 为什么要有字典这种数据结构？ 如果对一个无序的列表查找其中某一个value（前提是不能对列表进行排序），必须经过一个一个的遍历，速度会很慢。 [3, 2, 8, 9, 11, 13] # 如果要获取数据项11，必须经过5次查找 有没有一种办法，能够让速度加快？ 为了不违背不能排序的前提，我们只能在列表存入value的时候做文章。 我们可以为每个value都造一个独一无二的身份标识，根据这个身份标识符计算出value需要插入到列表的索引位置。 在取的时候同理，通过身份标识符直接就可以拿到value所在列表的索引值，无疑速度会快很多。 一个小总结： 有一个身份标识，身份标识必须是唯一的 提供一个根据身份标识计算出插入位置的算法 回到字典的本质，字典的key就是value的身份标识，而根据key计算出插入位置的算法被封装在了hash()函数中，这个算法也被称之为hash算法。 为什么key必须是唯一的，参照下面这个示例： [\"k1\", \"k2\", \"k3\", \"k4\", \"k5\", \"k6\"] ↓ ↓ ↓ ↓ ↓ ↓ [ 3, 2, 8, 9, 11, 13] 假如k5变成了k6，那么就有2个k6对应2个不同的value 这么做的后果就是，使用k6获取value的时候，根本不知道你需要的value是哪一个 所以，干脆Python规定，key必须是不可变类型！如果有重复则新的覆盖旧的。 或者说，只有不可变对象才能被hash。 hash过程 如何通过hash()函数，确定value的插入位置？ 实际上每个键值对在存入字典之前，都会通过hash()函数对key计算出一个hash值（也被称为散列值）： >>> hash(\"k1\") 7036545863130266253 而字典的底层结构是由一个2维数组嵌套组成的，也被称为散列表、hash表。 如下所示，每次创建字典的时候，字典都会初始化生成一个固定长度且内容全是空的2维数组，Python内部生成的散列表长度为8（可参见dictobject.c结构体源码）： [ ① ② ③ [空, 空, 空], index: 0 [空, 空, 空], index: 1 [空, 空, 空], index: 2 [空, 空, 空], index: 3 [空, 空, 空], index: 4 [空, 空, 空], index: 5 [空, 空, 空], index: 6 [空, 空, 空] index: 7 ] ❶：存放根据key计算出的hash值 ❷：存放key的引用 ❸：存放value的引用 现在，我们要存储name:yunya的键值对，对name计算hash值： >>> hash(\"name\") 3181345887314224636 用计算出的hash值与散列表长度进行求余运算： >>> 3181345887314224636 % 8 4 得到结果是4，就在散列表4的索引位置插入： [ ① ② ③ [空, 空, 空], index: 0 [空, 空, 空], index: 1 [空, 空, 空], index: 2 [空, 空, 空], index: 3 [3181345887314224636, \"name\"的引用, \"yunya\"], index: 4 [空, 空, 空], index: 5 [空, 空, 空], index: 6 [空, 空, 空] index: 7 ] 再次插入age:18，并用计算出的hash值与散列表长度进行求余运算: >>> hash(\"age\") 7064862892218627464 >>> 7064862892218627464 % 8 0 得到的结果是0，就在散列表0的索引位置插入： [ ① ② ③ [7064862892218627464, \"age\"的引用, 18], index: 0 [空, 空, 空], index: 1 [空, 空, 空], index: 2 [空, 空, 空], index: 3 [3181345887314224636, \"name\"的引用, \"yunya\"], index: 4 [空, 空, 空], index: 5 [空, 空, 空], index: 6 [空, 空, 空] index: 7 ] 可以看见，这个2维数组不是按照顺序进行插入的，总有一些空的位置存在，因此该数组也被称为稀松数组。 由于数组是稀松的，所以dict不支持范围获取（能获取到空值），但单点存取的速度很快。 读取的时候也同理，但是Python的hash函数底层实现是否真的利用hash值对稀松数组长度进行简单的求余运算，这个还有待商榷。 因为hash算法的实现有很多种，长度求余只是最为简单的一种而已，这里用作举例，如果想具体了解其算法可以查看Python源码，dictobject.c中的perturb。 散列冲突 现在，我们的这个散列表中0和4的索引位置都已经存在数据了。 如果现在存入一个teacher:wang，那么结果会是怎么样？ >>> hash(\"teacher\") 4789346189807557228 >>> 4789346189807557228 % 8 4 可以发现，teacher的hash值求余算结果也是4，这个时候就会发生散列冲突。 最常见的做法是，向后挪！因为索引5的位置是空的，我们可以将这个键值对插入到索引5的位置： [ ① ② ③ [7064862892218627464, \"age\"的引用, 18], index: 0 [空, 空, 空], index: 1 [空, 空, 空], index: 2 [空, 空, 空], index: 3 [3181345887314224636, \"name\"的引用, \"yunya\"], index: 4 [4789346189807557228, \"teacher\"的引用, \"wang\"], index: 5 [空, 空, 空], index: 6 [空, 空, 空] index: 7 ] 这种查找空位的方法叫做开放定址法（openaddressing），向后查找也被称为线性探测（linearprobing）。 如果此时又插入一个数据项，最后key的插入索引位置也是4，则继续向后查找空位，如果查找到7还是没有空位，又从0开始找。 上述方法是解决散列冲突的基础方案，当然也还有更多的其他解决方案，这里再说就过头了，放在后面数构一章中再进行介绍吧。 扩容机制 Python的dict会对散列表的容量做出判定。 当容量超过三分之二时，即进行扩容（resize）机制。 如果散列表大小为8，在即将插入第5个键值对时进行扩容，扩容策略为已有散列表键值对个数 * 2。 即散列表大小扩展为18 (5 * 2 + 8)。 如果整个散列表已有键值对个数达到了50000，则扩容策略为已有散列表键值对个数 * 4。 此外，dict只会进行扩容，不会进行缩容，如果删除了1个键值对，其内存空间占用的位置并不会释放。 不同key的优化 整形是其本身 整形的hash值是其本身： >>> hash(1) 1 >>> hash(2) 2 >>> hash(3) 3 >>> hash(10000) 10000 加盐策略 在Python3.3开始，str、bytes、datetime等对象在计算散列值的时候会进行加盐处理。 这个盐引用内部的一个常量，该常量在每次CPython启动时会生成不同的盐值。 所以你会发现每次重启Python3.3以后的解释器，对相同字符串进行hash()求散列值得出的结果总是不一样的： $ python3 Python 3.6.8 (v3.6.8:3c6b436a57, Dec 24 2018, 02:04:31) [GCC 4.2.1 Compatible Apple LLVM 6.0 (clang-600.0.57)] on darwin Type \"help\", \"copyright\", \"credits\" or \"license\" for more information. >>> hash(\"k1\") 8214688532022610754 >>> exit() $ python3 Python 3.6.8 (v3.6.8:3c6b436a57, Dec 24 2018, 02:04:31) [GCC 4.2.1 Compatible Apple LLVM 6.0 (clang-600.0.57)] on darwin Type \"help\", \"copyright\", \"credits\" or \"license\" for more information. >>> hash(\"k1\") -7444020267993088839 >>> exit() 再看Python2.7，由于没有加盐策略，所以每次重启Python解释器后相同key得到的hash结果是相同的： $ python Python 2.7.10 (default, Feb 22 2019, 21:55:15) [GCC 4.2.1 Compatible Apple LLVM 10.0.1 (clang-1001.0.37.14)] on darwin Type \"help\", \"copyright\", \"credits\" or \"license\" for more information. >>> hash(\"k1\") 13696082283123634 >>> exit() $ python Python 2.7.10 (default, Feb 22 2019, 21:55:15) [GCC 4.2.1 Compatible Apple LLVM 10.0.1 (clang-1001.0.37.14)] on darwin Type \"help\", \"copyright\", \"credits\" or \"license\" for more information. >>> hash(\"k1\") 13696082283123634 >>> exit() 有序字典 字典无序的观念似乎已经深入人心，但那已经都是过去式了。 在Python3.6之后，字典变的有序了。 2012年12月10日星期一的时候，R. David Murray向Python官方发送了一封邮件，提出建议让Python的字典变的有序。 这样的做法能够让Python字典的空间占用量更小，迭代速度更快，以下是邮件内容： https://mail.python.org/pipermail/python-dev/2012-December/123028.html 我们先看看2.7中的字典： >>> {chr(i) : i for i in range(10)} {'\\x01': 1, '\\x00': 0, '\\x03': 3, '\\x02': 2, '\\x05': 5, '\\x04': 4, '\\x07': 7, '\\x06': 6, '\\t': 9, '\\x08': 8} 再来看3.6中的字典： >>> {chr(i) : i for i in range(10)} {'\\x00': 0, '\\x01': 1, '\\x02': 2, '\\x03': 3, '\\x04': 4, '\\x05': 5, '\\x06': 6, '\\x07': 7, '\\x08': 8, '\\t': 9} 果然！它确实变的有序了，关于具体细节，可以参照这封邮件，已经表述的很清楚了，下面做一个简单的示例。 首先，以前的散列表就是一个单纯的稀松二维数组： [ [空, 空, 空], index: 0 [空, 空, 空], index: 1 [空, 空, 空], index: 2 ... ] 键值对的读取顺序来源与填加顺序。 索引靠前的会被先遍历拿到，索引靠后只能后被遍历出来。 如果这个散列表长度为8，前7个都没有数据项存入，仅有8才有，那么遍历完整个散列表需要8次： [ [空, 空, 空], index: 0 [空, 空, 空], index: 1 [空, 空, 空], index: 2 ... [hash值, key的引用, value的引用], index: 7 ] 而Python3.6之后，又新增了一个顺序数组，该数组与散列表的长度相等，初始均为8，并且会跟随散列表的扩容而进行扩容，如下示例初始状态： [None, None, None, ...] [ [空, 空, 空], index: 0 [空, 空, 空], index: 1 [空, 空, 空], index: 2 ... ] 如果说第1个键值对，被插入到散列表索引1的位置，那么在顺序数组中，则在索引0处记录下该键值对被插入在散列表中的位置(1)，如下图所示： [1, None, None, ...] [ [空, 空, 空], index: 0 [hash值, key的引用, value的引用], index: 1 [空, 空, 空], index: 2 ... ] 如果第2个键值对，被插入到散列表索引0的位置，那么在顺序数组中，则在索引1处记录下该键值对被插入在散列表中的位置(0)，如下图所示： [1, 0, None, ...] [ [hash值, key的引用, value的引用], index: 0 [hash值, key的引用, value的引用], index: 1 [空, 空, 空], index: 2 ... ] 再插入一个键值对，该键值对被插到了索引7的位置，那么在顺序数组中，则在索引2处记录下该键值对被插入在散列表中的位置(7)，如下图所示： [1, 0, 7, None, None, None, None, None] [ [hash值, key的引用, value的引用], index: 0 [hash值, key的引用, value的引用], index: 1 [空, 空, 空], index: 2 ... [hash值, key的引用, value的引用], index: 7 ] 在遍历的时候，会遍历这个顺序数组，然后通过索引值拿到散列表中对应位置的数据项，如果遍历到的值为None就结束遍历，而不用遍历完整个散列表： 类似于： hashTableOrderArray = [1, 0, 7, None, None, None, None, None] hashTable = [ [\"hash\", \"k2\", \"v2\"], [\"hash\", \"k1\", \"v1\"], [None, None, None], [None, None, None], [None, None, None], [None, None, None], [None, None, None], [\"hash\", \"k3\", \"v3\"], ] n = 0 while n 这样只需遍历3次即可，而如果没有这个顺序数组，则要完整遍历整个散列表，即8次才能拿出所有的键值对。 dictobject.c源码 官网参考：点我跳转 源码一览：点我跳转 关于字典的源码阅读，感兴趣的朋友可以看一下，这里不再进行延伸阅读。 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-15 14:08:42 "},"Python/Python基础知识/集合类型.html":{"url":"Python/Python基础知识/集合类型.html","title":"集合类型","keywords":"","body":"集合 Python中的集合（set）内部存储也采用hash存储，所以说它也可以归类为映射容器类型之中。 集合与字典有很多类似之处，你可以将集合理解为没有value的字典（仅有key）。 集合本身是可变的数据类型，但是其内部数据项必须是不可变的，能被hash()的对象，这与字典的key特性相同。 集合特性 集合特性如下： 集合是一个可变的容器类型 集合中的数据项必须是不可变类型 集合更多的是用来操纵数据，而不是存储数据 嗯，再说一个冷门知识点，集合的速度比字典的存读速度更快！因为它的数据项仅有1部分，而字典的数据项拥有2部分，即key与value。 基本声明 以下是使用类实例化的形式进行对象声明： s = set((1, 2, 3, 4, 5)) print(\"value : %r\\ntype : %r\" % (s, type(s))) # value : {1, 2, 3, 4, 5} # type : 也可以选择使用更方便的字面量形式进行对象声明，使用{}对数据项进行包裹，每个数据项间用逗号进行分割： s = {1, 2, 3, 4, 5} print(\"value : %r\\ntype : %r\" % (s, type(s))) # value : {1, 2, 3, 4, 5} # type : 注意一个集合声明的陷阱，如果要声明一个空集合必须使用类实例的形式进行声明。 如果用一个空的{}进行字面量声明会生成一个字典。 声明集合时，千万注意数据项只能是不可变类型。 如字符串（str），整形（int），浮点型（float），布尔型（bool），元组类型（tuple）等等，使用可变类型作为数据项加入至集合中会抛出TypeError异常。 续行操作 在Python中，集合中的数据项如果过多，可能会导致整个集合太长，太长的集合是不符合PEP8规范的。 每行最大的字符数不可超过79，文档字符或者注释每行不可超过72 Python虽然提供了续行符\\，但是在集合中可以忽略续行符，如下所示： s = { 1, 2, 3, 4, 5 } print(\"value : %r\\ntype : %r\" % (s, type(s))) # value : {1, 2, 3, 4, 5} # type : 类型转换 集合可以和布尔型、列表、元组、字符串类型进行转换： s = {1, 2, 3, 4, 5} boolSet = bool(s) strSet = str(s) listSet = list(s) tupleSet = tuple(s) print(\"value : %r\\ntype : %r\" % (boolSet, type(boolSet))) print(\"value : %r\\ntype : %r\" % (strSet, type(strSet))) print(\"value : %r\\ntype : %r\" % (listSet, type(listSet))) print(\"value : %r\\ntype : %r\" % (tupleSet, type(tupleSet))) # value : True # type : # value : '{1, 2, 3, 4, 5}' # type : # value : [1, 2, 3, 4, 5] # type : # value : (1, 2, 3, 4, 5) # type : 无序特性 Python本身并未对集合新增顺序数组，因此集合不论是Python3还是Python2中都是无序的。 Python2.7.10示例： >>> {chr(i) for i in range(10)} set(['\\x01', '\\x00', '\\x03', '\\x02', '\\x05', '\\x04', '\\x07', '\\x06', '\\t', '\\x08']) Python3.6.8示例： >>> {chr(i) for i in range(10)} {'\\x07', '\\x06', '\\t', '\\x02', '\\x00', '\\x05', '\\x04', '\\x03', '\\x01', '\\x08'} 去重特性 得益于内部hash存储方式，集合具有去处重复的特性，我们可以让其与列表结合，将列表中重复的数据项剔除： repeatList = [1, 1, 2, 2, 3, 4, 5, 1, 2] newList = list(set(repeatList)) print(newList) # [1, 2, 3, 4, 5] 集合中的数据项怎么拿出来 集合虽然是容器类型，但是更多的作用是操作数据项，存储非它所长（存了就不好取了）。 集合没有提供[]语法： 它没有key，无法像字典一样通过key来操作value 也没有index，因为它不是顺序存储的线性结构。 虽然set中没有提供单拿数据项的方法，但是我们可以将其转换为list后再通过index将某个数据项拿出来。 或者是通过遍历。 常用方法 常用的set方法一览，set有一部分方法可以进行符号操作： 方法名 符号表示 返回值 描述 add() 无 None 为集合中新增数据项 pop() 无 Data item 弹出随机数据项 remove() 无 None 删除指定数据项，若不存在则抛出异常 discard() 无 None 同上、但不存在不会抛出异常 clear() 无 None 清空集合 copy() 无 set 对集合进行浅拷贝 update() 无 None 原地更新集合 intersection() & set 求a集合与b集合的交集 difference() - set 求a集合与b集合的差集 union() set 求a集合与b集合的合集/并集 symmetric_difference() ^ set 求a集合与b集合的对称差集 issuperset() >或者>= bool 判定a集合是否为b集合的父级 issubset() bool 判断a集合是否为b集合的子集 isdisjoint() 无 bool 判断两个集合是否完全独立没有共同部分返回 intersection_update() 无 None 求出a集合与b集合的交集后并更新a集合 difference_update() 无 None 求出a集合与b集合的差集后并更新a集合 基础公用函数： 函数名 返回值 描述 len() integer 返回容器中的项目数 数据管理 示例演示： s1 = set() # 增加数据项 s1.add(1) print(s1) # {1} # 更新数据项 s1.update({2, 3, 4, 5}) print(s1) # {1, 2, 3, 4, 5} # 删除数据项， 不存在则抛出异常 s1.remove(2) print(s1) # {1, 3, 4, 5} # 删除数据项， 即使不存在也不会抛出异常 s1.discard(2) print(s1) # {1, 3, 4, 5} # 随机弹出数据项 print(s1.pop()) # 1 print(s1) # {3, 4, 5} # 浅拷贝 print(s1.copy()) # {3, 4, 5} # 清空数据项 s1.clear() print(s1) # set() 关系图解 集合关系图示： 关系获取 示例演示： s1 = {1, 2, 3, 4, 5} s2 = {4, 5, 6, 7, 8} # 交集 print(s1 & s2) print(set.intersection(s1, s2)) # {4, 5} # 差集 print(s1 - s2) print(set.difference(s1, s2)) # {1, 2, 3} # 合集、并集 print(s1 | s2) print(set.union(s1, s2)) # {1, 2, 3, 4, 5, 6, 7, 8} # 对称差集 print(s1 ^ s2) print(set.symmetric_difference(s1, s2)) # {1, 2, 3, 6, 7, 8} # 父子集 s3 = {1, 2, 3} s4 = {1,2} # 父级 print(s3 > s4) print(s3 >= s4) print(set.issuperset(s3, s4)) # True # 子集 print(s4 不可变的集合 frozenset()创建的集合拥有元组的特性，一旦集合创建完成后将不可以修改。 fs = frozenset((1, 2, 3)) print(fs) # frozenset({1, 2, 3}) 可以与普通的set集合进行关系获取，但是不能够进行数据项管理（可以copy，copy也是绝对引用）。 2.3以前怎么办 Python2.3的set和frozenset首次以模块的形式加入到Python中。 并且在Python2.6之后，提升为内置模块。 在Python2.3以前，我们常用字典来进行与集合相同的操作，因为字典的key也具有去重的特性嘛！ repeatList = [1, 1, 2, 2, 3, 4, 5, 1, 2] newList = list(dict.fromkeys(repeatList, None).keys()) print(newList) # [1, 2, 3, 4, 5] 如果是求交叉并集这种关系，则实现会更加复杂一点，这里不再举例。 dictobject.c源码 官网参考：点我跳转 源码一览：点我跳转 关于集合的源码阅读，感兴趣的朋友可以看一下，这里不再进行延伸阅读。 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-13 20:41:50 "},"Python/Python基础知识/布尔类型.html":{"url":"Python/Python基础知识/布尔类型.html","title":"布尔类型","keywords":"","body":"布尔类型 布尔类型的值被称为布尔值，常用于分支流程中，仅有2种表现形式： True：代表条件为真 False：代表条件为假 布尔属于不可变类型，同时也是基础的原子类型，即不可分割，不能容纳其他对象。 基本声明 以下是使用类实例化的形式进行对象声明： term = bool(True) print(\"value : %r\\ntype : %r\" % (term, type(term))) # value : True # type : 也可以选择使用更方便的字面量形式进行对象声明： term = True print(\"value : %r\\ntype : %r\" % (term, type(term))) # value : True # type : 类型转换 布尔值仅能转换为数字、字符串，使用对应的工厂函数即可： termTrue = True termFalse = False iTrue = int(termTrue) iFalse = int(termFalse) fTrue = float(termTrue) fFalse = float(termFalse) sTrue = str(termTrue) sFalse = str(termFalse) print(\"value : %r\\ntype : %r\" % (iTrue, type(iTrue))) print(\"value : %r\\ntype : %r\" % (iFalse, type(iFalse))) print(\"value : %r\\ntype : %r\" % (fTrue, type(fTrue))) print(\"value : %r\\ntype : %r\" % (fFalse, type(fFalse))) print(\"value : %r\\ntype : %r\" % (sTrue, type(sTrue))) print(\"value : %r\\ntype : %r\" % (sFalse, type(sFalse))) # value : 1 # type : # value : 0 # type : # value : 1.0 # type : # value : 0.0 # type : # value : 'True' # type : # value : 'False' # type : 除此之外，使用bool()将任意类型对象包裹均能获得其布尔值的表现形式。 以下举例Python内置数据类型在不同状态下的布尔值表示： 类型 True False int&float 不为0 为0 str&bytes 不为空串 为空串 list&tuple 不为空序列 为空序列 dict&set 不为空映射 为空映射 示例如下： >>> # --- int & float --- >>> bool(0) False >>> bool(1) True >>> bool(-1) True >>> bool(0.1) True >>> bool(-0.1) True >>> # --- str & bytes --- >>> bool(\"\") False >>> bool(b\"\") False >>> bool(\"string\") True >>> bool(b\"bytes\") True >>> # --- list & tuple --- >>> bool(list()) False >>> bool(tuple()) False >>> bool(list((1, 2, 3))) True >>> bool(tuple((1, 2, 3))) True >>> # --- dict & set --- >>> bool(dict()) False >>> bool(set()) False >>> bool(dict(k1=\"v1\", k2=\"v2\")) True >>> bool(set((\"ele1\", \"ele2\"))) True 布尔常量池 True和False是会被经常使用到的，因此在Python解释器启动时就会进行创建，我将他两归类为布尔常量池中（实际上并不存在）。 与小整数常量池中的数字类似，即使经历不同的实例化过程，但每次得到的True和False都来自同一引用： >>> id(True) 4495471488 >>> id(False) 4495471456 >>> id(bool(1)) 4495471488 >>> id(bool(0)) 4495471456 True&False与1&0 布尔值参与四则运算的时候，True等价于1，False等价于0： >>> True + 1 2 >>> False + 1 1 >>> True - False 1 实际上，True和False当采用运算时将会从小整数池中取出1和0，但是若使用id()方法查看True和1的地址号，会发现是不同的： >>> id(True) 4495471488 >>> id(1) 4495853616 为什么会出现这种情况？其实点开bool类型的源代码就可以发现，在Python3中bool类继承至int类： class bool(int): 当传入一个任意类型构建bool类的实例对象时，通过内部一系列判定都会返回True或者False这种形式。 若要将布尔类型直接参与运算（四则运算、hash运算），则会通过内部某种特殊的机制拿到1或者0。 id()方法返回的是对象的地址号，而bool的实例对象和int的实例对象必定在堆区内存中由不同的位置进行存储，故它们的结果不一样。 而运算时，布尔类型会去小整数池中拿到对应的整型值来参与运算，故True和1的hash运算的结果都是相同的。 如下图所示： 绝对引用 布尔类型拥有绝对引用的特性，则无论是深拷贝还是浅拷贝，都不会获得其副本，而是直接对源对象进行引用： >>> import copy >>> oldBool = True >>> id(oldBool) 4369122176 >>> b1 = copy.copy(oldBool) >>> id(b1) 4369122176 >>> b2 = copy.deepcopy(oldBool) >>> id(b2) 4369122176 boolobject.c源码 官网参考：点我跳转 源码一览：点我跳转 现有的名称 Py_False 和 Py_True 引用独一无二的布尔对象 False 和 True （之前，它们分别引用了值为 0 和 1 的静态整数对象，是众多整数之一）。 一个新的 API，即PyObject *PyBool_FromLong(long) ，会接收一个 C长整型参数，并返回对 Py_False （当参数为零时）或 Py_True （当非零时）的新引用。 要检查对象是否为布尔对象，可以使用宏PyBool_Check()。 布尔实例的类型是 PyBoolObject*。 布尔类型对象可作为PyBool_Type使用。 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-13 20:41:50 "},"Python/Python基础知识/单例None.html":{"url":"Python/Python基础知识/单例None.html","title":"单例None","keywords":"","body":"None None是Python中经常出现的一种类型，但其实关于它的描述并不是很多，因此None也经常被人忽略。 None是一种不可变类型，同时也是基础的原子类型，即不可分割，不能容纳其他对象。 它常用于初始化数据，并且是函数默认的返回值。 基本声明 None的声明方式仅有字面量声明： empty = None print(\"value : %r\\ntype : %r\" % (empty, type(empty))) # value : None # type : NoneType与单例 尽管可以看到None的实例化类为NoneType，但是你可能无法直接找到NoneType： print(NoneType) # NameError: name 'NoneType' is not defined NoneType实现了单例模式，我们虽然无法直接拿到NoneType这个类，但是可以通过 __class__属性拿到。 以下实例化多个None，查看id()是否相同： NoneType = None.__class__ none1 = NoneType() none2 = NoneType() print(id(none1)) print(id(none2)) # 4377856088 # 4377856088 绝对引用 None类型也是绝对引用，无论是深拷贝还是浅拷贝，都不会获得其副本，而是直接对源对象进行引用： >>> import copy >>> oldNone = None >>> id(oldNone) 4369221720 >>> no1 = copy.copy(oldNone) >>> id(no1) 4369221720 >>> no2 = copy.deepcopy(oldNone) >>> id(no2) 4369221720 None的使用 None一般用于对一个变量进行初始化，可能我们还没想好这个变量存什么内容时可以用None先代替进行存入。 这种变量可称之为临时变量，即只在一定的场景下进行使用，而并不会常驻使用： temp = None Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-13 20:41:50 "},"Python/Python基础知识/内存管理.html":{"url":"Python/Python基础知识/内存管理.html","title":"内存管理","keywords":"","body":"Gc简介 Gc（garbage collection）中文直译为垃圾回收，是一种回收内存空间避免内存泄漏的机制。 我们在程序的运行中会产生大量的对象用于保存数据，而有时候有些对象已经没有用了就需要被清理释放掉该对象所占据的内存空间。 在一些较为低级的语言中对于内存空间的释放是需要编程人员来手动进行的，这种与底层硬件直接打交道的操作是十分的危险与繁琐的，而基于C语言开发而来的Python为了解决掉这种顾虑则自带了一种垃圾回收机制，从而让开发人员不必过分担心内存的使用情况而可以全身心的投入到开发中去。 引用计数 最简单的Gc机制，引用计数。 首先将堆区内存中的对象与栈区内存中标识符的绑定数量做一个计数。 示例如下： >>> a = \"Python\" >>> b = \"Python\" >>> c = \"Python\" 我们的图示按照标识符的引用次数为准，并忽略临时引用，下图中Python这个str对象的引用计数目前为3： 每次标识符与对象取消绑定关系，则计数-1，当计数减到0的时候将自动清理该对象。 示例如下： >>> del a >>> del b >>> del c 标记清除 循环引用 引用计数能够解决百分之九十的问题，但是有一种特殊的情况是引用计数处理不了的，即循环引用（也被称为交叉引用）。 什么是循环引用，举一个简单的例子就是列表的互相嵌套，如下所示，l1和l2的引用计数都为2（标识符+1次引用，两个列表的[-1]索引处+1次引用）： >>> l1 = [1,2,3] >>> l2 = [1,2,3,l1] >>> l1.append(l2) >>> l1 [1, 2, 3, [1, 2, 3, [...]]] >>> l2 [1, 2, 3, [1, 2, 3, [...]]] 接着往下看，我们取消标识符与对象的绑定关系： >>> del l1 >>> del l2 现在，由于2个列表对象的计数都为1，故引用计数的策略显得不好使了。 因为2个列表对象的引用计数都未清0： 解决方案 为了解决循环引用带来的内存泄露问题，出现了标记清除法。 标记清除的意思在于当应用程序可用内存空间即将被耗尽时便开始遍历栈区所有的标识符，并且会顺着栈区标识符对其引用的在堆区中的对象做一个标记。 如果堆区内存中存在没有与栈区标识符进行绑定的对象，该对象则会认为是无用的对象，将会被清理。 分代回收 基于引用计数的垃圾回收机制每一次执行清理操作前都会将整个堆区对象的引用计数做一次遍历统计。 这样做是非常消耗时间的，所以Python垃圾回收机制为了效率的提升加入了分代回收的策略。 即： 当多次扫描后，若该对象的引用计数一直不为0，且也没有被标记清除法所清理掉，则证明 该对象会被经常使用，因此降低该对象的扫描频率，以提升效率。 优秀文章推荐 其实Python内部的内存管理机制远不如此。 所以这里推荐一个知乎博主写的系列文章，感兴趣的朋友可以跳转后继续深入阅读，该博主对Python底层内存机制剖析的极为透彻，是不可多得的好文章： 点我跳转 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-13 20:41:50 "},"Python/Python基础知识/深浅拷贝.html":{"url":"Python/Python基础知识/深浅拷贝.html","title":"深浅拷贝","keywords":"","body":"拷贝 copy即拷贝，意在将相同的数据进行复制，以便将复制出的副本应用于不同的操作上，而本体不会受到任何影响。 绝大多数语言中都有深浅拷贝的概念，故此篇文章也是属于通用性文章。 在Python中，除开手动导入copy模块并使用deepcopy()函数的拷贝是深拷贝，其他的所有的拷贝操作都是浅拷贝。 在开始之前，介绍几个基本概念： 不可变类型：int、float、str、bool、None、tuple、frozenset 可变类型：list、dict、set（均是容器） 绝对引用：所有的不可变类型，都具有绝对引用的特性，即深浅拷贝都不会获得其副本，而是直接对源对象进行引用 赋值 赋值就是引用，代码如下： #!/usr/bin/env python3 # -*- coding:utf-8 -*- oldLi = [\"A\", [1, ], (1,)] newLi = oldLi if id(oldLi) == id(newLi): print(\"外部大容器：可变类型：list来自同一个引用\") else: print(\"外部大容器：可变类型：list来自不同的引用\") if id(oldLi[0] == id(newLi[0])): print(\"内部第1个元素：不可变类型：str来自同一个引用\") else: print(\"内部第1个元素：不可变类型：str来自不同的引用\") if id(oldLi[1]) == id(newLi[1]): print(\"内部第1个大容器：可变类型：list来自同一个引用\") else: print(\"内部第1个大容器：可变类型：list来自不同的引用\") if id(oldLi[1][0]) == id(newLi[1][0]): print(\"内部第1个大容器的数据项：不可变类型：int ：%r来自同一个引用\" % oldLi[1][0]) else: print(\"内部第1个大容器的数据项：不可变类型：int ：%r来自不同的引用\" % oldLi[1][0]) if id(oldLi[2]) == id(newLi[2]): print(\"内部第2个大容器：不可变类型：tuple来自同一个引用\") else: print(\"内部第2个大容器：不可变类型：tuple来自不同的引用\") if id(oldLi[2][0]) == id(newLi[2][0]): print(\"内部第2个大容器的数据项：不可变类型：int ：%r来自同一个引用\" % oldLi[2][0]) else: print(\"内部第2个大容器的数据项：不可变类型：int ：%r来自不同的引用\" % oldLi[2][0]) # 外部大容器：可变类型：list来自同一个引用 # 内部第1个元素：不可变类型：str来自同一个引用 # 内部第1个大容器：可变类型：list来自同一个引用 # 内部第1个大容器的数据项：不可变类型：int ：1来自同一个引用 # 内部第2个大容器：不可变类型：tuple来自同一个引用 # 内部第2个大容器的数据项：不可变类型：int ：1来自同一个引用 如图所示： 所有引用都相同，这代表着oldLi中任意一个数据项改变后，newLi中的数据项也会跟着发生改变： oldLi[0] = \"B\" print(\"oldLi -> index0:type=str -> %r\" % oldLi[0]) print(\"newLi -> index0:type=str -> %r\" % newLi[0]) oldLi[1][0] = 10 print(\"oldLi -> index1:type=list --> index0:type=int -> %r\" % oldLi[1][0]) print(\"newLi -> index1:type=list --> index0:type=int -> %r\" % newLi[1][0]) # oldLi -> index0:type=str -> 'B' # newLi -> index0:type=str -> 'B' # oldLi -> index1:type=list --> index0:type=int -> 10 # newLi -> index1:type=list --> index0:type=int -> 10 图示如下： 浅拷贝 被浅拷贝的对象如果是可变类型，则创建副本，如果是不可变类型，则是引用，浅拷贝仅拷贝1层。 代码如下： #!/usr/bin/env python3 # -*- coding:utf-8 -*- import copy oldLi = [\"A\", [1, ], (1,)] newLi = copy.copy(oldLi) if id(oldLi) == id(newLi): print(\"外部大容器：可变类型：list来自同一个引用\") else: print(\"外部大容器：可变类型：list来自不同的引用\") if id(oldLi[0] == id(newLi[0])): print(\"内部第1个元素：不可变类型：str来自同一个引用\") else: print(\"内部第1个元素：不可变类型：str来自不同的引用\") if id(oldLi[1]) == id(newLi[1]): print(\"内部第1个大容器：可变类型：list来自同一个引用\") else: print(\"内部第1个大容器：可变类型：list来自不同的引用\") if id(oldLi[1][0]) == id(newLi[1][0]): print(\"内部第1个大容器的数据项：不可变类型：int ：%r来自同一个引用\" % oldLi[1][0]) else: print(\"内部第1个大容器的数据项：不可变类型：int ：%r来自不同的引用\" % oldLi[1][0]) if id(oldLi[2]) == id(newLi[2]): print(\"内部第2个大容器：不可变类型：tuple来自同一个引用\") else: print(\"内部第2个大容器：不可变类型：tuple来自不同的引用\") if id(oldLi[2][0]) == id(newLi[2][0]): print(\"内部第2个大容器的数据项：不可变类型：int ：%r来自同一个引用\" % oldLi[2][0]) else: print(\"内部第2个大容器的数据项：不可变类型：int ：%r来自不同的引用\" % oldLi[2][0]) # 外部大容器：可变类型：list来自不同的引用 # 内部第1个元素：不可变类型：str来自同一个引用 # 内部第1个大容器：可变类型：list来自同一个引用 # 内部第1个大容器的数据项：不可变类型：int ：1来自同一个引用 # 内部第2个大容器：不可变类型：tuple来自同一个引用 # 内部第2个大容器的数据项：不可变类型：int ：1来自同一个引用 如图所示，浅拷贝为什么浅，因为只拷贝了一层： 如果修改oldLi第1层的index指向，newLi并不会受到影响，而如果修改oldLi第2层的index指向，则newLi会受到影响，如下所示： oldLi[0] = \"B\" print(\"oldLi -> index0:type=str -> %r\" % oldLi[0]) print(\"newLi -> index0:type=str -> %r\" % newLi[0]) oldLi[1][0] = 10 print(\"oldLi -> index1:type=list --> index0:type=int -> %r\" % oldLi[1][0]) print(\"newLi -> index1:type=list --> index0:type=int -> %r\" % newLi[1][0]) # oldLi -> index0:type=str -> 'B' # newLi -> index0:type=str -> 'A' # oldLi -> index1:type=list --> index0:type=int -> 10 # newLi -> index1:type=list --> index0:type=int -> 10 图示如下： 深拷贝 深拷贝是递归的拷贝，即在浅拷贝的基础上也会递归的判定其子数据项是否能被拷贝。 如果是可变类型则拷贝，如果是不可变类型则不拷贝，代码如下： #!/usr/bin/env python3 # -*- coding:utf-8 -*- import copy oldLi = [\"A\", [1, ], (1,)] newLi = copy.deepcopy(oldLi) if id(oldLi) == id(newLi): print(\"外部大容器：可变类型：list来自同一个引用\") else: print(\"外部大容器：可变类型：list来自不同的引用\") if id(oldLi[0] == id(newLi[0])): print(\"内部第1个元素：不可变类型：str来自同一个引用\") else: print(\"内部第1个元素：不可变类型：str来自不同的引用\") if id(oldLi[1]) == id(newLi[1]): print(\"内部第1个大容器：可变类型：list来自同一个引用\") else: print(\"内部第1个大容器：可变类型：list来自不同的引用\") if id(oldLi[1][0]) == id(newLi[1][0]): print(\"内部第1个大容器的数据项：不可变类型：int ：%r来自同一个引用\" % oldLi[1][0]) else: print(\"内部第1个大容器的数据项：不可变类型：int ：%r来自不同的引用\" % oldLi[1][0]) if id(oldLi[2]) == id(newLi[2]): print(\"内部第2个大容器：不可变类型：tuple来自同一个引用\") else: print(\"内部第2个大容器：不可变类型：tuple来自不同的引用\") if id(oldLi[2][0]) == id(newLi[2][0]): print(\"内部第2个大容器的数据项：不可变类型：int ：%r来自同一个引用\" % oldLi[2][0]) else: print(\"内部第2个大容器的数据项：不可变类型：int ：%r来自不同的引用\" % oldLi[2][0]) # 外部大容器：可变类型：list来自不同的引用 # 内部第1个元素：不可变类型：str来自同一个引用 # 内部第1个大容器：可变类型：list来自不同的引用 # 内部第1个大容器的数据项：不可变类型：int ：1来自同一个引用 # 内部第2个大容器：不可变类型：tuple来自同一个引用 # 内部第2个大容器的数据项：不可变类型：int ：1来自同一个引用 如图所示，深拷贝把能拷贝的，不是绝对引用的都拷贝了： 无论怎么修改oldLi，newLi都不会受到影响： oldLi[0] = \"B\" print(\"oldLi -> index0:type=str -> %r\" % oldLi[0]) print(\"newLi -> index0:type=str -> %r\" % newLi[0]) oldLi[1][0] = 10 print(\"oldLi -> index1:type=list --> index0:type=int -> %r\" % oldLi[1][0]) print(\"newLi -> index1:type=list --> index0:type=int -> %r\" % newLi[1][0]) # oldLi -> index0:type=str -> 'B' # newLi -> index0:type=str -> 'A' # oldLi -> index1:type=list --> index0:type=int -> 10 # newLi -> index1:type=list --> index0:type=int -> 1 图示如下： Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-13 20:41:50 "},"Python/Python基础知识/输入与输出.html":{"url":"Python/Python基础知识/输入与输出.html","title":"输入与输出","keywords":"","body":"输入与输出 输入（output）让计算机能够听懂人类的指令，输入（input）能够告诉人类程序目前的状态。 标准输出 print() 在Python3中，print()函数默认会将对象的表现形式输出至屏幕上： print(\"hello world\") # hello world 而在Python2中，print后面不必加括号，直接加上对象即可： print \"hello world\" 除此之外，print()函数还可以接收3个参数，分别是：sep、end、file sep参数 该参数用来显示逗号间隔中的链接字符，默认为一个空格： # 不指定sep参数 print(\"hello\", \"world\") # hello world # 指定sep参数 print(\"hello\", \"world\", sep=\"☺\") # hello☺world end参数 该参数用于指定当print()完成后所在行尾指定的字符，默认为\\n即换行符。 print(\"hello\", end=\"\\t\") print(\"world\") # hello world file参数 该参数默认内部为标准输出，即输出至用户屏幕，我们可以通过该参数来指定print()的内容写入到某个指定的文件句柄中： with open(\"testFile.txt\", mode=\"wt\", encoding=\"utf8\") as f: print(\"this line written in file\", file=f) 格式化输出 如果我们想将一个字符串与一个对象的表现形式相结合，可使用格式化输出。 % %格式化的历史悠久，很多码龄较长的程序员都喜欢用它进行格式化输出。 我们来看一个例子： name = \"YunYaSir\" age = 19 s1 = \"name : %s\\nage : %d\" % (name, age) # ❶ print(s1) # name : YunYaSir # age : 19 ❶：字符串中的%s、%d等都是占位符，占位符要和对象匹配，在进行格式化时%char会被对象的表现形式所代替。 常见的占位符如下表所示： 占位符 描述 %s 接收任意类型的值，以字符串形式显示 %r 接收任意类型的值，以r字符串形式显示 %c 只接收单个字符 %b 接收int类型的值，二进制整数形式显示 %d 接收int类型的值，十进制整数形式显示 %i 接收int类型的值，十进制整数形式显示 %o 接收int类型的值，八进制整数形式显示 %x 接收int类型的值，十六进制整数形式显示 %e 接收float类型的值，指数形式显示 (基底写为e) %E 接收float类型的值，指数形式显示 (基底写为E) %f 接收float类型的值，浮点数形式显示 %F 接收float类型的值，浮点数形式显示 %g 接收float类型的值，指数(e)或浮点数 (根据显示长度) %G 接收float类型的值，指数(E)或浮点数 (根据显示长度) %% 即打印1个百分号 位置传参 一个占位符对应一个对象，当对象与占位符有多个时便需要将%后面的对象跟上括号做出一个元组，如若只有一个则不需要加上括号，%后元组中的对象数量必须与占位符的数量一致，且位置要一一对应： name = \"YunYaSir\" age = 19 s1 = \"name : %s\\nage : %d\" % (name, age) # ❶ print(s1) # name : YunYaSir # age : 19 如上所示：%s对应name、%d对应age。 优点：便于维护 缺点：对象与占位符必须一一对应，数量必须保持一致 关键字传参 使用关键字传参可以打破位置传参中占位符和标识符顺序以及数量必须统一的限制： name = \"YunYaSir\" age = 19 s1 = \"name : %(name)s\\nage : %(age)d\" % {\"age\": age, \"name\": name} # ❶ print(s1) # name : YunYaSir # age : 19 如上所示：%(name)s代表将dict中key为name的值转换为字符串形式显示，而%(age)d则代表将dict中key为age的值转换为字符串形式显示。 优点：使用灵活 缺点：如果被格式化的占位符过多，可能导致维护不便的情况发生 格式化百分号 如果想打印%占比，则可以使用下面的方式 %%代表一个% 。放在 %d后面的%则代表格式化出后的结果是3%: s1 = \"%d%%\"%3 print(s1) # 3% 格式化精度控制 如果要格式化一个小数，保留点后2位该怎么做？ 如下示例： PI = 3.1415926 print(\"pi = %.2f\" % PI) # pi = 3.14 format() %虽然能够满足基本需求。但在Python2.6中新增的format()方法，它更加强大且速度更快。 推荐今后使用format()的方法进行字符串格式化 。 注意:format()中的s只接受str类型的传值而不接受全部类型 如下所示，必须一个{}对应format()中的一个对象： name = \"YunYaSir\" age = 19 s1 = \"name : {}\\nage : {}\".format(name, age) # ❶ print(s1) # name : YunYaSir # age : 19 ❶：第1个{}对应format()中传入的第1个对象name，而第2个{}对应format()中传入的第2个对象age 或者也可以使用对象的方法调用形式： name = \"YunYaSir\" age = 19 s1 = str.format(\"name : {}\\nage : {}\", name, age) print(s1) # name : YunYaSir # age : 19 位置传参 基本使用，采用{}进行占位，需要注意的是format中的s不是接收全部类型的对象，只能接收str类型的对象： name = \"YunYaSir\" age = 19 s1 = \"name : {:s}\\nage : {:d}\".format(name, age) print(s1) # name : YunYaSir # age : 19 如果不指定类型，则{}中默认接收全部类型的对象： name = \"YunYaSir\" age = 19 s1 = \"name : {}\\nage : {}\".format(name, age) print(s1) # name : YunYaSir # age : 19 索引传参 索引传参是format()方法所独有的。 采用{}进行占位，并在其中传入format()中被格式化对象的位置信息，如下所示： name = \"YunYaSir\" age = 19 s1 = \"name : {0:s}\\nage : {1:d}\".format(name, age) print(s1) # name : YunYaSir # age : 19 需要注意，索引传参时必须为正向索引，不支持负向索引。 关键字传参 format()方法传参时使用键值对的方式进行传参： name = \"YunYaSir\" age = 19 s1 = \"name : {name:s}\\nage : {age:d}\".format(name=name, age=age) print(s1) # name : YunYaSir # age : 19 你也可以直接传入一个字典，通过**语法对字典解包： name = \"YunYaSir\" age = 19 s1 = \"name : {name:s}\\nage : {age:d}\".format(**{\"name\": name, \"age\": age}) print(s1) # name : YunYaSir # age : 19 字符填充功能 format()方法格式化时支持字符填充，如下表所示： 填充位置符号 描述 字符串居左、往右填充数据项 > 字符串居右、往左填充数据项 ^ 字符串居中、两侧填充数据项 示例如下： char = \"M\" # 右填充*，字符串长度为10时停止填充 rightFill = str.format(\"{0:*10}\", char) print(leftFill) # *********M # 两侧填充*，字符串长度为10时停止填充 midFill = str.format(\"{0:*^10}\", char) print(midFill) # ****M***** 格式化百分号 format()方法格式化百分号方法如下，它比%的格式化更加简单： s1 = str.format(\"{0}%\", 3) print(s1) # 3% 格式化{}大括号 如果使用format()方法，格式化时要输出“{char}“该怎么做？ 在外部套用2次大括号即可，如下所示： s1 = str.format(\"{{{0}}}\", \"☺\") print(s1) # {☺} 内部的{0}代表要格式化后面的☺，而外部的2个{}格式化完成后则表现为1个{}。 格式化精度控制 如果要使用format()方法格式化一个小数，保留点后2位该怎么做？ 如下示例： PI = 3.1415926 print(\"pi = {0:.2f}\".format(PI)) # pi = 3.14 其他的格式化 进制转换、如下所示： # 进制转换 sBit = str.format(\"{:b}\", 10) # 2进制 sOct = str.format(\"{:o}\", 10) # 8进制 sHex = str.format(\"{:x}\", 10) # 16进制 print(sBit) # 1010 print(sOct) # 12 print(sHex) # a 如果1代表百分之百，该怎么表示？如下所示： # .2%中的2代表保留2小数点后2位 s1 = str.format(\"{:.2%}\", 1) print(s1) s2 = str.format(\"{:.2%}\", 0.5) print(s2) # 100.00% # 50.00% 千分位表示，用逗号进行分割： s = str.format(\"{:,}\", 100000000) print(s) # 100,000,000 f 尽管format()已经非常方便了。但是如果传入的参数值太多依旧会看着十分混乱，于是Python3.6中新增了 f 格式字符串的操作。 这种方法的速度最快，但是却不推荐使用，因为程序还要考虑一个向下兼容性的问题。 name = \"YunYaSir\" age = 19 s1 = f\"name : {name}\\nage : {age}\" print(s1) # name : YunYaSir # age : 19 具体使用方法参照上面，与原始字符串r使用差不多，用f添加在字符串前面，并且使用{}进行占位，{}中放入对象即可。 关于其他的字符串填充、精度控制、格式化转换等功能均和format()使用相同，这里不再举例。 标准输入 input() Python2和Python3中均有input()函数来接收用户的输入。 需要注意的是，Python3中input()所得到的所有用户输入的数据，类型都是str，举个例子，用户输入小键盘数字1，程序得到的类型为str而不是int，所以我们可能需要额外的进行类型转换。 而在Python2中，则会自动转换类型为int，Python2会检测用户输入的内容是否符合Python语法，如不符合语法就会抛出异常，因此Python3中才摈弃了这种设定。 Python3中获得的所有输入结果类型均为str： username = input(\"Please type in your name:\") userage = input(\"Please enter age:\") print(\"value : %r\\ntype : %r\" % (username, type(username))) print(\"value : %r\\ntype : %r\" % (userage, type(userage))) # Please type in your name:YunYaSir # Please enter age:18 # value : 'YunYaSir' # type : # value : '18' # type : 用户年龄应当是int类型，所以我们需要对其做一次类型转换： username = input(\"Please type in your name:\") userage = int(input(\"Please enter age:\")) Python2中如果用户没有按照Python语法进行数据的录入，则会抛出异常： # coding:u8 username = input(\"Please type in your name:\") userage = input(\"Please enter age:\") print u\"value : %r\\ntype : %r\" % (username, type(username)) print u\"value : %r\\ntype : %r\" % (userage, type(userage)) # -- 输入了 yunya 会抛出 name 'yunya' is not defined # -- 而输入了 \"yunya\" 则会正常 raw_input() raw_input()是Python2中独有的，与Python3的input()效果相同。 这还是因为Python2中input()的缺点而导致raw_input()的诞生，用户必须熟知Python语法才能与程序进行交互，这是不现实的。 >>> name = input(\"Please type in your name:\") Please type in your name: yunya ❶ NameError: name 'yunya' is not defined >>> name = input(\"Please type in your name:\") Please type in your name: \"yunya\" ❷ >>> name 'yunya' ❶：这里没加引号，Python2的input()会认为这是一个变量，但该变量并未被定义，所以抛出 yunya 未定义的这么一个异常。 ❷：加了引号，表明这是一个字符串 更进一步了解输出 stdin&stdout&stderr 在Linux下，当一个用户进程被创建的时候，系统会自动为该进程创建三个数据流，分别是stdin、stdout、stderr。 stdin：标准输入、指向用户键盘 stdout：标准输出、指向用户屏幕 stderr：标准错误、指向用户屏幕 print()的指向 Python3的print()函数，内部则是引用了stdout，也就是说会默认的将数据显示在用户屏幕上。 我们可以从Python中print()函数签名中看到： def print(self, *args, sep=' ', end='\\n', file=None): # known special case of print \"\"\" print(value, ..., sep=' ', end='\\n', file=sys.stdout, flush=False) Prints the values to a stream, or to sys.stdout by default. Optional keyword arguments: file: a file-like object (stream); defaults to the current sys.stdout. sep: string inserted between values, default a space. end: string appended after the last value, default a newline. flush: whether to forcibly flush the stream. \"\"\" pass 而关于flush参数，则可以理解为刷新机制。 默认是False即代表是流式的输出，而改为True则会拥有类似于帧动画的特性，以下代码将进行验证，推荐使用Python IDLE查看效果： import time print(\"downloading\\t\", end=\"\") for i in range(100): time.sleep(0.1) if i == 99: print('#', flush=True, end=\"\\tdownload complate\\n\") break print('#', flush=True, end=\"\") Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-13 20:41:50 "},"Python/Python基础知识/运算符相关.html":{"url":"Python/Python基础知识/运算符相关.html","title":"运算符相关","keywords":"","body":"算数运算符 符号意义 以下是常用的算数运算符： 符号 意义 + 加法运算 - 减法运算 * 乘法运算 / 除法运算，精确除法（返回float） // 除法运算，地板除法（向下取整，生成int） ** 幂运算 % 求余运算 注意事项： float与int或者bool做运算，得到的结果均为float >>> 1 + 1.0 2.0 >>> 1 - 1.0 0.0 >>> 1 * 1.0 1.0 >>> 1 / 1.0 1.0 **幂运算仅支持int 、float、 bool 三种类型 >>> 2 ** 3 8 >>> 2.0 ** 3 8.0 >>> True ** 3 1 >>> %求余运算只支持 int 、float、 bool 三种类型，如果被求余数小于求余数，那么余数就为被求余数本身 >>> 6 % 8 6 示例演示 加法运算 print(1 + 1) print(1 + 1.1) print(1 + True) print([1, 2, 3] + [4, 5, 6]) print('OldStr ' + ' NewStr') # Change the reference value, generate new objects print((1, 2, 3) + (4, 5, 6)) # Change the reference value, generate new objects # 2 # 2.1 # 2 # OldStr NewStr # [1, 2, 3, 4, 5, 6] # (1, 2, 3, 4, 5, 6) 减法运算 print(1 - 1) print(1 - 1.1) print(1 - True) # 0 # -0.10000000000000009 # 0 乘法运算 s1 = '￥' l1 = [1, 2, 3] t1 = (1, 2, 3) print(1 * 2) print(1 * 2.0) print(1 * True) print(3 * l1) print(3 * s1) # Change the reference value to generate a new STR object print(3 * t1) # Change the reference value to generate a new Tuple object # 2 # 2.0 # 1 # [1, 2, 3, 1, 2, 3, 1, 2, 3] # ￥￥￥ # (1, 2, 3, 1, 2, 3, 1, 2, 3) 精确除法 print(10 / 2) print(10 / 2.0) print(10.1 / True) print(10.1 / True) print(10.1 / True) print(10.1 / True) print(False / 10) print(True / 2) print(True / 2.0) # 5.0 # 5.0 # 10.1 # 10.1 # 10.1 # 10.1 # 0.0 # 0.5 # 0.5 赋值运算符 符号意义 以下是常用的赋值运算符： 符号 意义 = 普通的赋值 += 增量加法赋值 -= 增量减法赋值 *= 增量乘法赋值 /= 增量精确除法赋值 //= 增量地板除法赋值 **= 增量幂运算赋值 %= 增量求余赋值 普通赋值 赋值运算符为=，切记一个=才是赋值： >>> x = 1 >>> x 1 增量赋值 在原本标识符所指向的对象基础上进行增量的运算后，再将运算结果赋值给原本的标识符。 增量赋值运算符就是将赋值符号和算术运算符结合起来达到简写的目的： 普通的先运算后赋值： >>> x = 1 >>> x = x + 10 >>> x 11 >>> x = x - 10 >>> x 1 >>> x = x * 10 >>> x 10 >>> x = x / 10 >>> x 1.0 >>> x = x // 10 >>> x 0.0 >>> x = x ** 10 >>> x 0.0 >>> x = x % 10 >>> x 0.0 简便的增量运算符： >>> x = 1 >>> x += 10 >>> x 11 >>> x -= 10 >>> x 1 >>> x *= 10 >>> x 10 >>> x /= 10 >>> x 1.0 >>> x //= 10 >>> x 0.0 >>> x **= 10 >>> x 0.0 >>> x %= 10 >>> x 0.0 平行赋值 平行赋值，一次为多个标识符进行赋值： >>> x, y, z = 1, 2, 3 >>> x 1 >>> y 2 >>> z 3 链式赋值 链式赋值，多个标识符引用同一个对象： >>> x = y = z = \"Object\" >>> x 'Object' >>> y 'Object' >>> z 'Object' 链式赋值也被称之为间接赋值。 交叉赋值 交叉赋值，将2个标识符所指向的对象进行互换： >>> x = \"Object001\" >>> y = \"Object002\" >>> x, y = y, x >>> x 'Object002' >>> y 'Object001' 解压赋值 解压赋值这里不再进行赘述了，前面在介绍内置数据类型的时候已经介绍过了。 比较运算符 符号意义 比较运算符的返回结果总是为True或者False，一般是用于比较2个相同类型的值的大小。 常用于条件分支结构中： 符号 意义 > 大于 小于 == 等于 != 不等于 >= 大于或者等于 小于或者等于 示例演示 比较运算符得到的结果必然是bool类型： >>> 1 >> 1 > 2 False >>> 1 == 1.0 True >>> 1 == True True 比较方式 字符串与字符串之间的比较会一位一位对照ASCII表来进行比对： >>> ord(\"y\") 121 >>> ord(\"k\") 107 >>> \"y\" > \"k\" True 如果是非ASCII字符，则会调用其他的比较机制，如调用locale模块下的strxfrm()函数对字符串进行本地化处理： print(\"中\" > \"美\") 如果是数字串，则会一位一位进行比较： >>> \"100\" > \"4\" False # 第一位比较：1 小于 4，后续不再比较 数字与数字之间的比较会之间比较整体： >>> 100 > 1000 False 元组、列表之间的比较会根据相同的索引值进行一位一位的比较： >>> (\"100\", ) > (\"45\", \"b\") False # 1比4小 逻辑运算符 逻辑词汇 不同于其他编程语言的&&和||，Python中使用单词代表与或非。 单词 意义 not 非，统一取反 and 与，一真一假取一假，两个为真才取真 or 或，一真一假取一真，两个为假才取假 优先级 优先级的意思是如下： not True and False or True # 第一个True是该给not还是and做运算呢？ 牢记：NOT>AND>OR 故上面的结果为： True 以下是推算流程： False and False or True False or True True 示例演示 使用not进行取反： >>> not 1 > 2 True 使用and进行多条件连接： >>> name = \"Yunya\" >>> age = 18 >>> name == \"Yunya\" and age == 18 True >>> 使用or进行或逻辑判断： >>> name = \"Yunya\" >>> age = 18 >>> name == \"Yunya\" or age == 100 True >>> 短路运算 如果一次逻辑运算中的逻辑运算符号全部为 and 或者 or 则会从左至右依次进行逻辑运算。 如果每一次都进行运算是很消耗时间的，所以这个时候出现了短路机制。 看图说话： 与或运算 如果不是对True或者False进行and or运算而是对数字进行and or运算呢？ 只需要牢记0是False非0是True即可： >>> 1 and 0 or 3 3 >>> 3 + 1 and 4 or 0 4 每次的结果，都取最后一个True值： >>> 1 and 2 2 >>> 2 and 1 1 >>> 1 or 0 1 >>> 0 or 1 1 成员运算符 in in用来判断容器类型的某一个数据项是否在其中，支持的类型有str、list、tuple、dict、set、frozenset，所有的判定严格区分大小写。 in：在其中 not in：不在其中 需要注意的是如果是对dict做in的成员判定，只会判定key是否在其中： >>> string = \"ABCDEFG\" >>> \"A\" in string True >>> \"a\" in string False >>> li1 = [1, 2, 3] >>> 1 in li1 True >>> 0 in li1 False >>> tup = (1, 2, 3) >>> 1 in tup True >>> 0 in tup False >>> dic = {\"k1\" : \"v1\", \"k2\" : \"v2\"} >>> \"k1\" in dic True >>> \"v1\" in dic False >>> s1 = {1, 2, 3} >>> 1 in s1 True >>> 0 in s1 False 身份运算符 is is判定对象是否来自同一引用，即是否是同一个对象，用来判断引用是否相等： >>> x = y = z = \"I love Python\" >>> x is y True >>> x is z True is&==的异同 ==仅判断对象的值是否相同，不关心是否引用自同一对象： >>> x = \"I love Python\" >>> y = \"I love Python\" >>> x == y True >>> x is y False 两者的区别在于使用is时相当于使用 id(obj) == id(obj)，即对象是否为同一引用： >>> x = \"I love Python\" >>> y = \"I love Python\" >>> id(x) 4305667952 >>> id(y) 4305668016 >>> id(x) == id(y) # is False 而==则不会判定id，仅判断2个对象的形式值是否相同： >>> x = \"I love Python\" >>> y = \"I love Python\" >>> id(x) 4305667952 >>> id(y) 4305668016 >>> x == y True 小结： is：引用判定，引用相等的对象则必然值相等 ==：值判定，值相等的对象引用不一定相等 is None 一般来说，我们对None做判断时都会使用is None而不是 == None，这是因为None本身就是一个单例对象。 所有的None对象其实内部都引用自同一对象，在PEP8规范中明确表示，对于None的判定应该使用is而不是==： r = None print(r is None) print(r == None) # True # True 虽然这么使用毫无问题，但是在PyCharm中会报出PEP8不规范的提示： 对象的增量与普通运算操作 记住一句话，增量是原地操作，不会开辟新的内存空间（字符串的+=除外）。 而普通的运算操作则会开辟新的内存空间，返回1个新对象。 我们以列表举例： >>> lst1 = [1, 2, 3] >>> lst2 = lst1 * 3 >>> lst1 is lst2 False >>> lst2 [1, 2, 3, 1, 2, 3, 1, 2, 3] >>> lst1 = [1, 2, 3] >>> id(li1) 4346207752 >>> lst1 *= 3 >>> id(li1) 4346207752 >>> lst1 [1, 2, 3, 1, 2, 3, 1, 2, 3] Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-07-22 17:08:52 "},"Python/Python基础知识/分支结构.html":{"url":"Python/Python基础知识/分支结构.html","title":"分支结构","keywords":"","body":"分支结构 分支结构能够让计算机像人一样进行思考，应对不同的场景做出不同的回应。 Python中不支持switch语法，目前仅支持if/else形式，但是在Python3.10的测试版本中，貌似支持了switch语法，这里不做例举。 if 多条if语句出现会逐行进行判断，条件为真则执行其下的代码块，条件为假则略过： if 条件判断： 逻辑代码... if 条件判断: 逻辑代码... if 条件判断: 逻辑代码... 示例演示： userAge = int(input(\"Please enter your age:\")) if userAge = 18 and userAge = 30 and userAge = 60 and userAge = 80: print(\"Can still meal\") if/else if代表如果怎样就怎样，else代表否则怎样就怎样。 一组if/else只会执行其中的一个。 以下是Python中if/else语法： if 条件判断： 逻辑代码... else： 逻辑代码... 示例演示： userinput = input(\"Enter any character, determine if it is a numeric string:\") if userinput.isdigit(): print(\"Is a digital string\") else: print(\"Not a digital string\") if/elif/else 多条if会按顺序依次执行，对每一条if语句都进行判定，而如果使用elif则只会从多条逻辑判定中取出最先为True的进行执行，后续的判定将不会被执行。 也就是说，if/elif/else三者只会执行一个。 语法使用如下： if 条件判断： 逻辑代码... elif 条件判断: 逻辑代码... elif 条件判断: 逻辑代码... else: 逻辑代码 示例演示： userAge = int(input(\"Please enter your age:\")) if userAge 三元表达式 三元表达式中有三个重要的元素： 条件是第一元素 　 条件成立返回的值是第二元素 　 条件不成立返回的值是第三元素 普通形式 如果只是一个简单if/else判定，我们可以将代码写在一行，语法如下： if else 示例演示： age = int(input(\"Please enter your age:\")) result = \"adult\" if age >= 18 else \"underage\" print(result) 其他形式 上面的三元表达式是最常见的一种，除此之外再介绍几种不常见的。 第二种，这种有一个BUG，不能区分0或者Fasle： and or 如下所示，如果1大于0就返回0，否则返回False，但是第二种的返回的结果永远是False： result = 1 > 0 and 0 or False print(result) # False 如果使用第一种，就不会有这样的问题： result = 0 if 1 > 0 else False print(result) # False 第三种，语法如下： (, )[condition] 示例如下： age = int(input(\"Please enter your age:\")) result = (\"underage\", \"adult\")[age >= 18] print(result) 第四种，语法如下： {True: , False: }[] 示例如下： age = int(input(\"Please enter your age:\")) result = {True: \"adult\", False: \"underage\"}[age >= 18] print(result) Python语法糖 链式比较 在Python中的判定支持一种链式比较，下面是常规的比较： age = 13 if age > 12 and age 通过链式比较进行简写： age = 13 if 12 12 and age 获得布尔值 判定用户输入的是否为数字串，如果为数字串result变量为True，否则为False。 很多情况下，初学者可能会写出下面这种代码： userInput = input(\"Please enter your age:\") result = None if userInput.isdigit(): result = True else: result = False print(result) 其实一行代码就可以搞定： userInput = input(\"Please enter your age:\") result = bool(userInput.isdigit()) print(result) 或者你也可以使用另一种方式： userInput = input(\"Please enter your age:\") result = userInput.isdigit() or False print(result) 实例练习 输入一个数字，判断该数字是奇数还是偶数： num = int(input(\"Enter a number: \")) if (num % 2) == 0: print(\"%s an even number\" % num) else: print(\"%s an odd number\" % num) 输入一个年份，判断该年份是否是闰年？ year = int(input(\"Enter a year: \")) if (year % 4) == 0: if (year % 100) == 0: if (year % 400) == 0: print(\"%s is a leap year\" % year) # 整百年能被400整除的是闰年 else: print(\"%s not is leap year\" % year) else: print(\"%s is a leap year\" % year) # 非整百年能被4整除的为闰年 else: print(\"%s not is leap year\" % year) 输入某年某月某日，判断这一天是这一年的第几天？ year = int(input('year:\\n')) month = int(input('month:\\n')) day = int(input('day:\\n')) sumInt = None months = (0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334) if 0 2): sum += 1 print('it is the %dth day.' % sum) Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-13 20:41:50 "},"Python/Python基础知识/流程控制.html":{"url":"Python/Python基础知识/流程控制.html","title":"流程控制","keywords":"","body":"流程控制 流程控制以循环为主，旨在让计算机重复的去做某一件事情。 在介绍流程控制一章节前，引入一个叫做遍历的概念： 遍历是指对一个可迭代对象类型（暂时理解为容器类型），进行数据项的依次访问行为 下面这个是遍历行为轨迹示意： # [1, 2, 3, 4, 5, 6] # ------------------> 重复的取值也在遍历范畴： # [1, 2, 3, 4, 5, 6] # -----> # # 条件循环 while while循环是基于条件的循环，while本身具有if判断的功能，当条件为真时开始重复执行子代码块中的内容直至条件为假后跳出循环。 tag = 10 while tag > 5: print(\"current tag value : %s\" % tag) tag -= 1 print(\"while cycle end tag of value : %s\" % tag) # current tag value : 10 # current tag value : 9 # current tag value : 8 # current tag value : 7 # current tag value : 6 # while cycle end tag of value : 5 条件退出 while只有在每一次的循环开始前才会检测条件是否为真，如果条件在子代码块内部发生改变则本次的循环并不会立即退出，如下所示： tag = 10 while tag != 5: print(\"current tag value : %s\" % tag) tag = 5 print(\"no stop continue to run\") print(\"while cycle end tag of value : %s\" % tag) # current tag value : 10 # no stop continue to run\" # while cycle end tag of value : 5 while/else while循环正常结束后，会执行else代码块中的代码： 正常结束的while循环是指不被强制break的while循环 tag = 3 while tag: print(tag) tag -= 1 else: print(\"else...\") # 3 # 2 # 1 # else... 死循环 当while的结果永远为真时，将引发死循环。 单纯的死循环不会引来性能损耗问题，但是如果做一些计算操作则必将会对CPU带来极大的性能压力，因为CPU没有一刻的休息时间。 tag = 1 while 1: tag += 10 取值循环 for for循环内部是基于while循环来完成的，for循环在对可迭代对象的取值上比while循环更加的方便，故也被称为取值循环。 for循环常用于遍历可迭代对象进行取值操作，以下是语法介绍： for 迭代变量 in 可迭代对象（暂时可理解为容器类型） 逻辑操作... 以下是使用while循环遍历可迭代对象进行取值，相当麻烦： lst = [1, 2, 3, 4, 5] index = 0 while 1: try: print(lst[index]) except IndexError: break index += 1 # 1 # 2 # 3 # 4 # 5 如果使用for循环，那么就变的简单许多： lst = [1, 2, 3, 4, 5] for i in lst: print(i) # 1 # 2 # 3 # 4 # 5 结束退出 for循环的正常退出是遍历完整个可迭代对象之后进行退出。 lst = [1, 2, 3, 4, 5] for i in lst: print(i) print(\"for cycle end\") # 1 # 2 # 3 # 4 # 5 # for cycle end for/else 当for循环正常退出结束后，会执行else下的代码块： 正常结束的for循环是指不被强制break的for循环 lst = [1, 2, 3, 4, 5] for i in lst: print(i) else: print(\"else..\") # 1 # 2 # 3 # 4 # 5 # else.. range() 我们有一个需求需要让计算机重复打印5次hello,world，你可能会这样做： count = 5 while count: print(\"hello,world\") count -= 1 也可以使用for循环来进行完成，但是这样会很麻烦，由于使用for循环必须遍历一个可迭代对象，所以要先创建一个可迭代对象： count = [0, 1, 2, 3, 4] for i in count: print(\"hello,world\") 如果你使用range()，这一切都会变得非常简单，range()会帮助你快速的创建一个可迭代对象，我们只需要指定它的次数即可： for i in range(5): print(\"hello,world\") 关于range()方法的其他讲解，会在下面进行。 容器遍历 字符串遍历 示例演示： string = \"hello world\" for i in string: print(\"index : %s, value : %s\"%(string.index(i), i)) # index : 0, value : h # index : 1, value : e # index : 2, value : l # index : 2, value : l # index : 4, value : o # index : 5, value : # index : 6, value : w # index : 4, value : o # index : 8, value : r # index : 2, value : l # index : 10, value : d 列表遍历 普通遍历： lst = [1, 2, 3, 4] for i in lst: print(i) 通过enumerate()函数来同时遍历2个相同长度的列表： lst1 = [\"A\", \"B\", \"C\", \"D\"] lst2 = [\"a\", \"b\", \"c\", \"d\"] for index, item in enumerate(lst1): lst1Message = str.format( \"lst1 index position {} is data item {}\", index, item) print(lst1Message) lst2Message = str.format( \"lst2 index position {} is data item {}\", index, lst2[index]) print(lst2Message) 通过[::-1]来反向遍历列表： lst = [\"A\", \"B\", \"C\", \"D\"] for i in lst[::-1]: print(i) 隔一个取一个的遍历列表： lst = [\"A\", \"B\", \"C\", \"D\"] for i in lst[::2]: print(i) 字典遍历 普通的遍历只会遍历出key，这样的操作等同于遍历dict.keys()： dic = { \"k1\": \"v1\", \"k2\": \"v2\", \"k3\": \"v3\", } for k in dic: print(k) # k1 # k2 # k3 如果你想取出value，则可以遍历dict.values()： dic = { \"k1\": \"v1\", \"k2\": \"v2\", \"k3\": \"v3\", } for v in dic.values(): print(v) # v1 # v2 # v3 如果你想同时取出key和value，则可以遍历dict.items(): dic = { \"k1\": \"v1\", \"k2\": \"v2\", \"k3\": \"v3\", } for k, v in dic.items(): print(k, v) # k1 v1 # k2 v2 # k3 v3 局部作用域 如果一个迭代变量的命名为i，那么这个迭代变量能在外部访问到吗？答案是能！ 其实在Python2和Python3中，普通的for循环语句是没有局部作用域这一个说法的，希望在未来版本能有所改进。 for i in range(10): pass print(i) # 9 循环控制 continue 在while/for中均可以使用continue跳过本次循环。 以下用for循环进行举例： for i in range(5): if i == 3: continue else: print(i) # 0 # 1 # 2 # 4 break 在while/for中均可以使用break结束本层循环。 以下用for循环进行举例： for i in range(5): if i == 3: break else: print(i) # 0 # 1 # 2 循环嵌套 while嵌套 while循环支持多层嵌套，在使用时注意下面的事项： 如果是使用基于条件退出那么所有的while循环都必须遵循同一个条件才能退出 break只针对当前的while循环体退出，对于非当前的while循环体不生效 continue只针对当前while循环体跳过，对于非当前的while循环体不生效。 如下示例： tag = True while tag: print(\"outer while cycle start, current tag value is : %s\" % tag) while tag: print(\"intermediate while cycle start, current tag value is : %s\" % tag) while tag: print(\"inner while cycle start, current tag value is : %s\" % tag) tag = False # outer while cycle start, current tag value is : True # intermediate while cycle start, current tag value is : True # inner while cycle start, current tag value is : True for嵌套 for循环同样支持嵌套。 外层执行1次，内层的for循环要全部循环完成才回到外层执行第2次。 for i in range(65, 68): print(\"outer for cycle, current cycle value is : %s\" % chr(i)) for j in range(97, 100): print(\"inner for cycle, current cycle value is : %s\" % chr(j)) print(\"\") # outer for cycle, current cycle value is : A # inner for cycle, current cycle value is : a # inner for cycle, current cycle value is : b # inner for cycle, current cycle value is : c # outer for cycle, current cycle value is : B # inner for cycle, current cycle value is : a # inner for cycle, current cycle value is : b # inner for cycle, current cycle value is : c # outer for cycle, current cycle value is : C # inner for cycle, current cycle value is : a # inner for cycle, current cycle value is : b # inner for cycle, current cycle value is : c 以下是使用for循环打印乘法表的例子： for i in range(1, 10): for j in range(1, i+1): print(\"%s * %s = %s\" % (i, j, i*j), end=\"\\t\") print(\"\") range()详解 range() range()方法在Python2中返回的是一个列表，而在Python3中返回的是一个可迭代对象（这种可迭代对象不会存值，而是惰性求值，类似于生成器）。 range()方法有三个参数，如下表所示： 参数介绍 描述 start 从几开始生成 stop 生成到几结束 step 步长间距 在使用range()进行生成时，需要注意顾头不顾尾。 如下所示： lst = list(range(1, 10, 2)) print(lst) # [1, 3, 5, 7, 9] xrange() Python2中的xrange()与Python3中的range()相同，均返回可迭代对象，而非列表。 关于为什么做，其实是为了节省内存空间。 列表中的具体值会存在内存中，而如果是一个通过计算可惰性求值的可迭代对象，则不会消耗太大的内存，以下是自定义range()的实现。 class Range: def __init__(self, stop, start=0, step=1): self.start = start self.stop = stop self.step = step self.current = None def __iter__(self): return Range_iterator(self.stop, self.start, self.step) class Range_iterator: def __init__(self, stop, start, step): self.start = start self.stop = stop self.step = step self.current = self.start def __next__(self): if self.current 实例练习 将列表内的元素,根据位数合并成字典，列表如下： lst = [1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 32769, 65536, 4294967296] 答案： lst = [1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 32769, 65536, 4294967296] dic = {} for i in lst: k = len(str(i)) # 如果不存在该键，这该键等同于一个空列表 dic.setdefault(k, []) dic[k].append(i) print(dic) 使用for循环打印三角形： for i in range(1, 6): for j in range(1, 6 - i): print(\" \", end=\"\") for k in range(1, i + 1): print(\"* \", end=\"\") print(\"\") # * # * * # * * * # * * * * # * * * * * 有四个数字：1、2、3、4，能组成多少个互不相同且无重复数字的三位数？各是多少？ count = 0 for i in range(5): for j in range(1, 5): for k in range(1, 5): if (i != k) and (i != j) and (j != k): count += 1 print(i, j, k) print(count) # 36 斐波拉契数列是这样的一个数列：0、1、1、2、3、5、8、13、21、34、…… 前2个值加起来的结果恰好等于第3个值，求一个长度为10的斐波拉契数列： n = 10 fibArray = [] a , b = 0, 1 for i in range(n): fibArray.append(a) a, b = b, a + b print(fibArray) # [0, 1, 1, 2, 3, 5, 8, 13, 21, 34] 输入2个数字，求2个数字的最小公倍数： x = int(input(\">>>\")) y = int(input(\">>>\")) minCommonMultiple = None if x > y: greater = y else: greater = x while 1: if ((greater % x == 0 ) and (greater % y == 0)): minCommonMultiple = greater break greater += 1 msg = str.format(\"{0}和{1}的最小公倍数为{2}\", x, y, minCommonMultiple) print(msg) 输入2个数字，求2个数字的最大公约数： x = int(input(\">>>\")) y = int(input(\">>>\")) maxCommonDivisor = None if x > y: smaller = y else: smaller = x for i in range(1, smaller + 1): if ((x % i == 0) and (y % i == 0)): maxCommonDivisor = i msg = str.format(\"{0}和{1}的最大公约数为{2}\", x, y, maxCommonDivisor) print(msg) Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-13 20:41:50 "},"Python/Python基础知识/推导式.html":{"url":"Python/Python基础知识/推导式.html","title":"推导式","keywords":"","body":"推导式 Python从Haskell语言中取得灵感，创建了一系列的Python推导式（comprehension）。 它可以在不丧失代码可读性的前提下创建一系列容器，是Python颇受好评的特性。 列表推导式 应用场景 有一个列表中存了一些人名和性别的元组数据项，我需要将性别为男性（male）的数据项提取至一个新的列表中。 如下所示，在没有学习列表推导式之前， 你可能会这样做： oldList = [ (\"Tom\", \"Male\"), (\"Jack\", \"Male\"), (\"Mary\", \"Female\"), (\"Laura\", \"Female\") ] newList = [] for tpl in oldList: if tpl[-1].lower() == \"male\": newList.append(tpl) print(newList) # [['Tom', 'Male'], ['Jack', 'Male']] 如果有列表推导式的帮助，它就会简单许多，语法如下： newList = [ 被添加/操作的数据项 for 迭代变量 in 可迭代对象 if 条件] 列表推导式操作如下所示： oldList = [ (\"Tom\", \"Male\"), (\"Jack\", \"Male\"), (\"Mary\", \"Female\"), (\"Laura\", \"Female\") ] newList = [tpl for tpl in oldList if tpl[-1].lower() == \"male\"] # ❶ print(newList) # [['Tom', 'Male'], ['Jack', 'Male']] ❶：当数据项的判断为True时将自动添加至newList中，不能指定else条件 快速创建列表 使用列表推导式可以快速的创建一个列表。 如下所示，推导出数据项从1-10的列表： newLi = [i for i in range(1, 11)] print(newLi) # [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] 下面的示例中，我们可以快速的使用双层循环推导出了一副扑克牌的列表： newLi = [ i + str(j) for i in [\"❤\", \"♧\", \"♤\", \"♢\"] for j in range(1, 14)] newLi.append(\"bigKing\") newLi.append(\"smallKing\") print(newLi) 结果如下： ['❤1', '❤2', '❤3', '❤4', '❤5', '❤6', '❤7', '❤8', '❤9', '❤10', '❤11', '❤12', '❤13', '♧1', '♧2', '♧3', '♧4', '♧5', '♧6', '♧7', '♧8', '♧9', '♧10', '♧11', '♧12', '♧13', '♤1', '♤2', '♤3', '♤4', '♤5', '♤6', '♤7', '♤8', '♤9', '♤10', '♤11', '♤12', '♤13', '♢1', '♢2', '♢3', '♢4', '♢5', '♢6', '♢7', '♢8', '♢9', '♢10', '♢11', '♢12', '♢13', 'bigKing', 'smallKing'] 元素的处理 数据项在添加至列表之前，可以为其进行一些操作。 比如在上面扑克牌的示例中，我们将int对象转换为了str对象，同理也可以做一些别的操作。 如下示例，我们将推导出一个含有26字母的列表： newLi = [chr(i) for i in range(65, 91)] print(newLi) # ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'] 迭代变量 需要注意的是，迭代变量与条件成立后添加的数据项没有任何关系，如下所示，一行代码创建10个A： newLi = [\"A\" for i in range(10)] print(newLi) # ['A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A'] 对于这个题目，有一种更简便的解法： newLi = [\"A\"] * 10 字典推导式 使用示例 字典推导式和列表推导式大体差不多，但是外部是用花括号包裹，并且要有:进行key和value的区分。 如下所示，快速的推导出标准ASCII码表的对照关系： asciiDict = {i: chr(i) for i in range(0, 128)} print(asciiDict) 结果如下： {0: '\\x00', 1: '\\x01', 2: '\\x02', 3: '\\x03', 4: '\\x04', 5: '\\x05', 6: '\\x06', 7: '\\x07', 8: '\\x08', 9: '\\t', 10: '\\n', 11: '\\x0b', 12: '\\x0c', 13: '\\r', 14: '\\x0e', 15: '\\x0f', 16: '\\x10', 17: '\\x11', 18: '\\x12', 19: '\\x13', 20: '\\x14', 21: '\\x15', 22: '\\x16', 23: '\\x17', 24: '\\x18', 25: '\\x19', 26: '\\x1a', 27: '\\x1b', 28: '\\x1c', 29: '\\x1d', 30: '\\x1e', 31: '\\x1f', 32: ' ', 33: '!', 34: '\"', 35: '#', 36: '$', 37: '%', 38: '&', 39: \"'\", 40: '(', 41: ')', 42: '*', 43: '+', 44: ',', 45: '-', 46: '.', 47: '/', 48: '0', 49: '1', 50: '2', 51: '3', 52: '4', 53: '5', 54: '6', 55: '7', 56: '8', 57: '9', 58: ':', 59: ';', 60: '', 63: '?', 64: '@', 65: 'A', 66: 'B', 67: 'C', 68: 'D', 69: 'E', 70: 'F', 71: 'G', 72: 'H', 73: 'I', 74: 'J', 75: 'K', 76: 'L', 77: 'M', 78: 'N', 79: 'O', 80: 'P', 81: 'Q', 82: 'R', 83: 'S', 84: 'T', 85: 'U', 86: 'V', 87: 'W', 88: 'X', 89: 'Y', 90: 'Z', 91: '[', 92: '\\\\', 93: ']', 94: '^', 95: '_', 96: '`', 97: 'a', 98: 'b', 99: 'c', 100: 'd', 101: 'e', 102: 'f', 103: 'g', 104: 'h', 105: 'i', 106: 'j', 107: 'k', 108: 'l', 109: 'm', 110: 'n', 111: 'o', 112: 'p', 113: 'q', 114: 'r', 115: 's', 116: 't', 117: 'u', 118: 'v', 119: 'w', 120: 'x', 121: 'y', 122: 'z', 123: '{', 124: '|', 125: '}', 126: '~', 127: '\\x7f'} 第2个例子，对于迭代一些特殊格式的容器，可以直接生成出一个字典： userMessage = [(\"name\", \"Yunya\"), (\"age\", 18), (\"gender\", \"male\")] newDict = {k: v for k, v in userMessage} print(newDict) # {'name': 'Yunya', 'age': 18, 'gender': 'male'} 集合推导式 使用示例 集合推导式只需要将列表推导式的[]改为{}即可。 以下是示例演示，很显然，由于是集合推导式，故下面的双层循环并不会产生重复元素： newSet = {j for i in range(10) for j in range(10)} print(newSet) # {0, 1, 2, 3, 4, 5, 6, 7, 8, 9} 局部作用域 之前聊过普通的for循环中是不存在局部作用域的，那么在推导式当中是否存在局部作用域呢？ 以列表举例： newList = [i for i in range(10)] print(i) # NameError: name 'i' is not defined 可以看见，在推导式中的局部作用域是存在的。 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-13 20:41:50 "},"Python/Python基础知识/字符编码.html":{"url":"Python/Python基础知识/字符编码.html","title":"字符编码","keywords":"","body":"存储编码 一般来说，我们用什么方式进行文件存储，就用什么编码方式对其进行打开，一般使用UTF8进行存储和打开文件即可。 执行编码 Python3中在执行代码时，解释器都会按照UTF8编码格式将脚本文件中的代码加载至内存中，所以一般不会出现问题。 但是在Python2里解释器则是使用ASCII的编码格式进行脚本文件内容的解码。 所以你可能会遇上下面的情况： SyntaxError:Non-ASCII character .... in file ... 解决这个办法，可以利用头文件代码，让Python解释器在解码脚本文件内容时，以UTF8格式进行解码： # --*-- coding:UTF8 --*-- # 开始书写你的代码 可以使用sys的getdefaultencoding()方法来查看Python解释器默认采用的执行编码格式： >>> # Python2 >>> import sys >>> sys.getdefaultencoding() 'ascii' >>> # Python3 >>> import sys >>> sys.getdefaultencoding() 'utf-8' Unicode字符串 Python2中的str类型，本质是Python3中的bytes，所以仅支持ASCII码表中的字符。 如果想将其转换为Unicode字符串，则必须在前面加上u： print u\"这是Unicode字符串\" Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-13 20:41:50 "},"Python/Python基础知识/文件操作.html":{"url":"Python/Python基础知识/文件操作.html","title":"文件操作","keywords":"","body":"open() Python中提供了open()方法用于对文件进行操作，该方法会返回一个文件对象。 由于被读取的文件内容本身全部属于str类型，故使用open()方法对其进行操作必然涉及字符编码的问题。 以下是open()方法的函数签名： def open(file: Union[str, bytes, int, _PathLike[Any]], mode: str = ..., buffering: int = ..., encoding: Optional[str] = ..., errors: Optional[str] = ..., newline: Optional[str] = ..., closefd: bool = ..., opener: Optional[Callable[[str, int], int]] = ...) -> IO[Any]: 下面是对常用参数的解释： 参数名 描述 file 必需，文件路径（相对或者绝对路径） mode 可选，文件内容读取与操作模式，*t模式以为文本内容读取模式打开文件。需要填入encoding，b模式为二进制模式读取文件内容，默认该参数为*t 。*代表操作模式 encoding 可选（Python2没有该参数），当mode为 *t 时指定编码或解码格式。一般设置为 utf-8。如不指定Windows平台默认为GBK，Mac和Linux平台为utf-8 buffering 设置缓冲 errors 报错级别 newline 是否区分换行符，默认为True closefd 传入的file参数类型 以下是在Python3中进行读取文件的简单示例： f = open(file=\"test.txt\", mode=\"rt\", encoding=\"utf-8\") print(f.read()) # ❶ f.close() # ❷ ❶：read()读取所有内容 ❷：关闭文件句柄 with语句 在open()后要切记关闭文件句柄，释放系统资源，这是一项非常重要但很容易被人忽视的细节点。 故推荐使用with语句进行文件操作，它将在with子代码块结束后自动关闭文件句柄。 with open(file=\"test.txt\", mode=\"rt\", encoding=\"utf-8\") as f: print(f.read()) 使用with语句还可以同时打开多个文件，示例如下，\\可进行换行： with open(file=\"test.txt\",mode=\"rt\",encoding=\"utf-8\") as f1,\\ open(file=\"test2.txt\",mode=\"rt\",encoding=\"utf-8\") as f2: data1 = f1.read() print (data1) data2 = f2.read() print (data2) 读写内容模式 t模式 当打开一个文件时，默认以*t模式打开。 t代表以文本方式读取文件内容，读取的都是字符。 with open(file=\"test.txt\", mode=\"rt\", encoding=\"utf-8\") as f: result = f.read(3) # ❶ print(result) ❶：指定读取的字符数量 b模式 如果以b模式打开文件，则读取到的都是字节。 若使用字节模式打开文件，则不存在字符编码的问题 with open(file=\"test.txt\", mode=\"rb\") as f: result = f.read(3) # ❶ print(result) # b'\\xe6\\xb5\\x8b' hans = result.decode(\"utf-8\") print(hans) # ❷ ❶：指定读取的字节数量 ❷：解码 读写操作模式 r模式 r代表只读，使用r模式打开文件时文件的指针将跑到最开始。 如果文件不存在将会抛出异常，并且只能使用读取相关的方法。 with open(file=\"test.txt\", mode=\"rb\") as f: print(f.readlines()) w模式 w模式代表只写，使用w模式打开文件时就相当于新建一个文件。 如果文件已存在将清空原本文件中所有的内容，如果文件不存在则创建新文件，并且只能使用写入相关的方法。 with open(file=\"test.txt\", mode=\"wb\") as f: data = \"你好世界\" f.write(data.encode(\"utf-8\")) a模式 a模式为追写模式，当文件不存在时创建新文件，只能执行写相关的操作。 当文件存在时则打开文件，文件指针放到最后，所以被称为追写模式。 强调 w 模式与 a模式的异同： 相同点：在打开的文件不关闭的情况下，连续的写入，新写的内容总会跟在前写的内容之后 不同点：以 a 模式重新打开文件，不会清空原文件内容，会将文件指针直接移动到文件末尾，新写的内容永远写在最后 with open(file=\"test.txt\", mode=\"ab\") as f: f.write(b'\\nnew line...') x模式 x模式与w模式都相同。 唯一不同的地方在于如果需要打开的文件已存在，x模式会抛出异常。 而w模式会新建一个同名文件并且删除掉旧文件。 with open(file=\"test.txt\", mode=\"xb\") as f: f.write(b'\\nnew line...') # FileExistsError: [Errno 17] File exists: 'test.txt' +模式 +这里是对 r w a 的一种扩展。 代表可读可写，但是打开文件后文件指针的位置还是依照 r w a 原本的位置，应该尽量少用+方法。 with open(file=\"test.txt\", mode=\"r+b\") as f: data = f.read() print(data) f.seek(0, 2) f.write(b\"A new line again\\n\") 文件指针 使用seek()函数可以对文件指针进行操作。 以下是seek()函数的签名： def seek(self, offset: int, whence: int = 0) -> int 注意，使用文件指针应该在*b模式下进行使用，它的移动将会按照字节进行移动。 如果是*t模式下，按照字符移动可能会出现某些错误。 参数 描述 offset 偏移量，负数代表向前移动指针，正数代表向后移动指针 whence 偏移位置，0代表起始位置，1代表当前位置，2代表结束位置 示例如下： with open(file=\"test.txt\", mode=\"rb\") as f: # ❶ print(f.tell()) # ❷ f.seek(2, 0) f.seek(10, 0) f.seek(20, 0) print(f.tell()) # ❸ f.seek(-2, 1) f.seek(-3, 1) f.seek(-4, 1) print(f.tell()) # ❹ # 0 # 20 # 11 ❶：注意，文件指针除了（0，0）和（0，2）外，其他都应该用b模式进行。 ❷：打印当前文件指针的位置 0 ❸：打印当前文件指针的位置 20 ❹：由于是相对定位，故可以累加。 20 - 9 ，文件指针在 11 循环读取 for循环 如果直接使用f.read()，当文件内容过于庞大时，这些内容全部会存放于Python程序的内存空间中。 会给内存带来极大的压力，故在文件较小时才使用f.read()，太大的话将使用其他解决方案，如下面的for循环进行读取： data = b\"\" with open(\"test.txt\", mode=\"rb\") as f: for line in f: # ❶ data += line print(data.decode(\"utf-8\")) ❶：直接读取f代表每次读一行，以\\n为单位 while循环 如果一个文件只有一行，如压缩版的前端代码。 在读取时则可使用while循环进行读取，示例如下： data = b\"\" with open(\"test.txt\", mode=\"rb\") as f: while 1: temp = f.read(512) data += temp if not len(temp): break print(data.decode(\"utf-8\")) 文件写入 内存写入 文本编辑器的原理是在打开一个文本文件时其中所有的内容都会加载并存放至内存中。 对该文本内容的修改实际上全部都是在修改内存中的数据，当修改完成后点击保存时才会将内存的数据重新写入至硬盘中。 你应该深有体会，打开一个特别大的文本文件时速度很慢，哪怕没做任何修改保存时速度也还是很慢，实际上就是这个原因导致的。 以下是模拟内存写入，打开文件后将“计算机”替换为“电脑”： data = \"\" # ❶ with open(file=\"BigFileTest.txt\", mode=\"rt\", encoding=\"utf-8\") as f: # ❷ while 1: temp = f.read(512) data += temp # ❸ print(data) # ❹ if not len(temp): # ❺ break print(\"读取完毕..\") data = data.replace(\"计算机\", \"电脑\") # ❻ with open(file=\"BigFileTest.txt\", mode=\"wt\", encoding=\"utf-8\") as f: # ❼ f.write(data) print(\"写入完毕..\") ❶：用于存放数据 ❷：r模式的指针默认放在0位置 ❸：代表每次读取512个字符 ❹：这里可以做其他操作 ❺：代表没有新的内容。 len(temp) == 0 ❻：模拟手动修改文件内容。将计算机修改为电脑，注意此时修改的是内存中的数据 ❼：读取后将Python应用程序中维护的data变量中的数据全部写入该文件。w模式会清空源文件的内容 硬盘时刷 文本编辑器的做法是在内部维护了一个变量，用于提供给用户修改内容。 这么做的好处就是用户可以在修改文件内容时能够查看到所有的文件内容，但是坏处是占用内存空间太大。 这里再介绍一种减少内存压力的方式。 注意：两种方式没有优劣之分，只有使用场景不同的区别，还是和上面一样的操作，将“计算机”替换为“电脑”。 import os with open(file=\"BigFileTest.txt\", mode=\"rt\", encoding=\"utf-8\") as f1, \\ open(file=\".BigFileTest.txt.swap\", mode=\"wt\", encoding=\"utf-8\") as f2: # ❶ for line in f1: line = line.replace(\"计算机\", \"电脑\") # ❷ f2.write(line) # ❸ print(\"操作完成..\") os.remove(\"BigFileTest.txt\") # ❹ os.rename(\".BigFileTest.txt.swap\", \"BigFileTest.txt\") # ❺ 这么做的坏处是没办法随时的修改内存中的变量数据，因为内存中根本没存文本文件内容。 只能按照设定好的程序走一遍，但是极大的节省了内存空间的占用。 ❶：以. 开头的文件代表隐藏文件。以swap结尾的文件代表交换文件（可以理解为临时文件） ❷：每次拿到和修改的只有line ❸：写入交换文件中 ❹：删除源文件 ❺：修改临时文件的名字。与源文件保持一致 操作方法 以下是文件操作中常用的方法： 方法 描述 read() 读取某个文件(全部内容)。也可指定大小，t模式的大小为字符单位，b模式为字节单位 readline() 读取一行文件内容 readlines() 读取所有文件内容并返回一个列表，以行割开 write() 写入一行数据，默认不会\\n需要手动换行 writelines() 写入一行数据，通过列表的方式写到文件里面 tell() 显示当前文件光标的位置 seek() 移动当前文件光标的位置(字节为单位，建议在b模式下使用) readable() 文件是否可读 writable() 文件是否可写 closed 文件是否关闭 encoding 如果文件打开模式是b,则没有该属性 flush() 立刻将文件内容从内存刷到硬盘（测试模式下使用） Python2-open() 由于Python2中不能使用encoding参数指定编解码的方式。所以我们看看在Python2中open()应该怎样使用： #!/usr/bin/env python2 # coding:utf-8 # import sys # reload(sys) # sys.setdefaultencoding('utf-8') # 设置默认的解码方式为 utf-8。如果这样操作就不用设置decode()了。 f = open(file=\"test.txt\",mode=\"rt\",) data = unicode(f.read().decode(\"utf-8\")) # unicode()将读取出的字符转为unicode字符存储于内存中。 print data f.close() Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-13 20:41:50 "},"Python/Python函数相关/summary.html":{"url":"Python/Python函数相关/summary.html","title":"Python函数相关","keywords":"","body":" 初识函数 使用函数 参数详解 命名空间 高阶函数 递归函数 匿名函数 内置函数 装饰器 迭代器 生成器 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-13 20:41:50 "},"Python/Python函数相关/初识函数.html":{"url":"Python/Python函数相关/初识函数.html","title":"初识函数","keywords":"","body":"函数 在编程语言中的函数不同于数学中的函数（function）。 不管是数学上的函数还是编程语言中的函数都是为了完成特定的某一功能而诞生的，他们的区别在于： 数学中的函数当输入的值是固定的情况下那么输出的值也一定是固定的。 它内部不允许原本输入的值状态发生改变。 编程语言中的函数则可以允许传入的值进行修改的。 如果按照数学函数的定义来做编程语言的函数，那么这种函数则被称为纯函数（pure function） 分类 在Python中，函数主要有两类： 内置函数（Built-in function） 自定义函数（Custom function） 如，id()、type()、print()等均属于内置函数，内置函数又被称为工厂函数。 内置函数的实现初衷是将一些经常使用的功能进行封装，并且同Python解释器一起提供给开发者，开发者开箱即用，不必关心底层的算法实现。 而自定义函数是指在内置函数无法完成需求的情况下，由开发人员去自己创作的为了满足特定的某一项功能的可重复使用的具体代码集合。 函数的特点 函数主要解决流式代码的2大问题： 代码冗余度高，程序的组织结构不清晰，可读性差 可维护性以及可扩展性差 函数的特点如下： 提供封装性，用户在外部不用关心内部如何实现 提供可重复调用，开发人员最大限度的减少了重复代码的实现 提升程序可读性，对特定的功能进行分类，使后期维护变的简单 举一个简单的例子，如果没有定义函数，要打印100次“hello world”则需要写一百行下面的代码： print(\"hello world\") print(\"hello world\") print(\"hello world\") print(\"hello world\") ... 而如果使用了函数，则只需调用100次函数即可： def func(): print(\"hello world\") func() func() func() ... 函数与方法 函数（function）与方法（method）都是一个具体功能的实现，它们本质都是一个东西。 区别在于函数允许大多数类型进行调用，而方法只允许特定类型进行调用。 如： id()：允许所有类型进行调用，因此被称为 “函数” format()：只允许str类型进行调用，因此被称为 “方法” 可调用性 函数和方法都是可调用的，如何判断一个对象是否可调用？ 可以使用内置函数callable()进行判断，如下所示，只需在callable()中传入函数名即可： >>> callable(print) True >>> callable(input) True Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-13 20:41:50 "},"Python/Python函数相关/使用函数.html":{"url":"Python/Python函数相关/使用函数.html","title":"使用函数","keywords":"","body":"函数使用 内置函数 内置函数是被内部定义好的一些函数，直接调用即可。 但是要严格传入函数所需要的参数，为此，你可以查看Python内置函数源代码，获得函数签名： def bin(*args, **kwargs): # real signature unknown; NOTE: unreliably restored from __doc__ \"\"\" Return the binary representation of an integer. >>> bin(2796202) '0b1010101010101010101010' \"\"\" pass 自定义函数 对于自定义函数来说，与对象声明相同，必须先定义后使用。 以下是语法格式： def 函数标识符(参数1, 参数2): # ❶ \"\"\"功能描述文档\"\"\" # ❷ 逻辑体代码块 # ❸ return 返回值 # ❹ ❶：def为关键字，用于定义一个函数。函数名即函数标识符，参照变量标识符的命名规则。参数是可选的，可以没有 ❷：功能描述文档可有可无，这是提供给用户的帮助信息，可以使用help()函数通过传入函数标识符获得该功能描述文档 ❸：函数的逻辑体代码块，用于具体实现某一功能 ❹：用于返回给用户需要的结果，如果不返回默认返回None 如何使用 函数标识符指向的是函数对象在内存空间的引用，也就是函数体代码块： >>> print 当加上括号后，将自动调用该函数，此时则根据函数签名需求传入对应参数即可： >>> print(\"hello world\") hello world 也就是说，函数标识符不加括号不会调用，只是拿到函数的引用，而加括号后才会执行函数内部的逻辑代码。 定义函数 无参函数 无参函数大多数情况下只是希望该函数单纯的做一点什么事情而并不需要该函数给返回一个结果。 常用于一段特定功能的重复调用，如我想在某种特定的情况下打印出WARNING信息，此时就可以定义一个无参函数： import sys import datetime def warning(): message = str.format( \"WARNING time: file:[{1}] - line:[{2}]\", datetime.datetime.now(), # ❶ sys._getframe().f_code.co_filename, # ❷ sys._getframe().f_back.f_lineno # ❸ ) print(message) warning() print(datetime.datetime.now()) # WARNING time: file:[/Users/Project/demo.py] - line:[13] ❶：获取当前时间 ❷：获取被调用函数所在模块文件名 ❸：获取被调用函数在被调用时所处代码行数 有参函数 函数的参数用于接收用户传入的对象，可以认为传入的对象是指“待加工原材料”。 当函数执行完成后，通过加工“原材料”将会返回一个加工后的“产品”。 以下示例中将计算2个值的相加结果： def add(x, y): res = x + y return res # ❶ result = add(1, 2) print(result) # 3 ❶：返回加工完成后的“产品”，该产品被外部使用result标识符进行接收 空函数 只定义函数名并未做具体实现的函数叫做空函数，空函数在逻辑构思中常被用到。 关键词：pass或者Ellipsis对象。 如下所示： def add(x, y): pass # ❶ def sub(x, y): ... # ❷ ❶：代表省略 ❷：Ellipsis对象，代表省略，仅在Python3中适用 函数调用 语句形式 在函数标识符后加上括号进行调用即可： >>> print(\"hello world\") hello world 表达式形式 表达式形式可以将函数返回的对象赋值给一个标识符，如下所示： def add(x, y): res = x + y return res result = add(1, 2) print(result) # 3 也可以直接对这个函数返回的对象进行操作，如下所示： def add(x, y): res = x + y return res result = add(1, 2) * 10 print(result) # 30 参数调用形式 函数可以作为参数传递给其他函数： def add(x, y): res = x + y return res result = add(add(1, 2), 3) # ❶ print(result) # 6 ❶：相当于add(3, 3) 函数返回值 默认返回值 Python中的函数一定具有返回值。 如果没有显式的使用return关键字指定返回值，则默认会返回None。 def add(x, y): ... result = add(1, 2) print(result) # None return返回值 return有2个作用： 返回函数的执行结果，可以返回1个，也可以返回多个，若返回多个则以元组形式返回 跳出所有的循环体（如果在多层的循环中使用return，将直接跳出所有循环，并且将结果进行返回） 如下示例， 获得指定范围区间的累加结果： def accumulate(start, stop): res = 0 for i in range(start, stop + 1): res += i return res result = accumulate(1, 100) print(result) # 5050 返回多个值时，将以元组形式进行返回，如下示例中输入一个ASCII码表的字符，返回其ASCII码表中对应的大小写编号（a - z具有2个编号，符号只有1个编号）： def getAscii(char): asciiTable = {chr(i) : i for i in range(0, 128)} lowerKey = char.lower() capitalKey = char.upper() return asciiTable[lowerKey], asciiTable[capitalKey] lowInt, capitalInt = getAscii(\"a\") print(lowInt, capitalInt) # 98 66 函数执行 函数必须先定义后使用，否则无法执行： func() def func(): print(\"run ...\") # NameError: name 'func' is not defined 嵌套调用 Python是解释性语言，解释一行执行一行。 当碰见def关键字开头的语句，内部会检测一下该代码块的语法，如果没有出现问题则代表该函数定义好了。 只有碰到函数名加括号的情况下才会去执行该函数。 所以，函数也可以进行嵌套调用，不过我个人不太喜欢这种调用方法，我更倾向于传参调用，在代码维护时更加的方便： def func1(): print(\"run ... func1\") def func2(): print(\"run ... func2\") func1() print(\"run stop\") func2() # run ... func2 # run ... func1 # run stop 内部逻辑 当定义一个函数时，会发生3件事情： 申请内存空间，保存函数体代码 将内存地址编号绑定给函数标识符（函数名） 定义函数并不会执行函数体内部代码，但是会检测函数体的语法 当调用一个函数时，也会发生3件事情： 通过函数标识符找到函数在内存中存在的位置 加上括号是一种语法格式，代表执行函数体内部的代码 调用系统调用栈，创建一个函数的栈帧片段并压入栈中 我们以函数嵌套的例子来分析它的定义和执行流程： def func1(): print(\"run ... func1\") def func2(): print(\"run ... func2\") func1() print(\"run stop\") func2() 定义函数 在Python解释器解释到到第1行、第3行的时候，会加载函数体代码，检查函数体语法，若无误则将其编译为字节码： 随后会加载函数标识符，func1与func2，并且会在内存中将函数体代码进行保存，让函数标识符与在内存中保存的函数体代码进行绑定： 如上图所示，现在还未开始执行函数，内存中已有func1，func2了。 执行函数 开始分析第9行的执行函数func2()，当Python解释器发现函数标识符加了一个括号后，知道这是要调用函数，会顺着函数名找到在内存中的函数体代码： 当开始真正执行func2()函数体代码后，系统调用栈会创建出一个独一无二的函数栈帧，函数栈帧会将函数的字节码、谁调用的它、以及函数内部定义的变量（如参数）等关键信息进行保存。 在第6行，发现又执行func1()，这个func1()是在func2()内部执行的所以Python解释器会在func2()栈帧的基础上运行func1()的代码，同理也会创建func1()函数的栈帧： 当func1()执行完毕后，发现没有返回值，则加载常量None并做为默认的返回结果，此时会一并弹出func1()的栈帧，常量None将返回给func1()的调用处： 然后func2()也执行完毕，发现没有返回值，加载常量None并做为默认的返回结果，此时会一并弹出func2()的栈帧，常量None将返回给func2()的调用处： Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-13 20:41:50 "},"Python/Python函数相关/参数详解.html":{"url":"Python/Python函数相关/参数详解.html","title":"参数详解","keywords":"","body":"形参与实参 什么是传参 将需要被处理的对象传递给函数的行为，被称为传参。 形参介绍 在定义函数时，函数需要使用1个或者多个标识符来接收到外部传递进的对象。 这个标识符就是形参： def func(x, y, z): \"\"\" :param x: 形参x :param y: 形参y :param z: 形参z :return: None \"\"\" ... 可以理解为形参是函数（工厂）的预留位置，你将“原材料”放在这些位置上才能被工厂所接收到。 实参介绍 在调用函数时，外部向函数传入的对象则被称为实参。 def func(x, y, z): \"\"\" :param x: 形参x :param y: 形参y :param z: 形参z :return: None \"\"\" ... # 传入实参1，2，3 func(1, 2, 3) 可以理解为实参是待加工的“原材料”， 需要将这些“原材料”放到指定的工厂预留位置上（形参）才能被工厂所接收。 两者关系 由于Python中一切皆引用，故实参传递给形参的也就是同一个对象，这种传参被称为引用传参。 2者总结关系有3点： 在函数调用时，实参将对象传递给形参后，对象的引用计数会+1 在函数内部，可以通过形参访问到该对象 形参与对象的绑定关系在函数调用结束后就会被取消掉 下面示例将验证形参和实参引用的都是同1个对象： x = 1 def func(x): print(id(x)) func(x) print(id(x)) # 4518684720 # 4518684720 形参定义 位置参数 函数定义时从左至右依次排列的没有特殊意义的形参被称为位置形参，位置形参必须被对象传入，多一个少一个都不行。 如果传入的不够、或者传入的过多，将会抛出异常： def func(x, y, z): ... 传少了： func(1) # TypeError: func() missing 2 required positional arguments: 'y' and 'z' 传多了： func(1, 2, 3, 4) # TypeError: func() takes 3 positional arguments but 4 were given 默认参数 默认形参是指可以不用被传递对象的形参，它拥有1个默认的对象。 如果调用函数时没有传入对象，则使用该默认的对象 如果调用函数时传入了1个对象，则使用接收到的对象 需要注意在定义默认形参时必须放在位置形参后面，否则会抛出异常。 def func(x, y, z=3): print(x, y, z) func(1, 2) func(\"A\", \"B\", \"C\") # 1 2 3 # A B C 传参方式 位置传参 如果是位置形参，则实参传入对象时必须严格按照形参的位置顺序、形参的总体数量进行传入。 如果传入的不够、或者传入的过多，将会抛出异常： def func(x, y, z): ... 传少了： func(1) # TypeError: func() missing 2 required positional arguments: 'y' and 'z' 传多了： func(1, 2, 3, 4) # TypeError: func() takes 3 positional arguments but 4 were given 关键字传参 使用位置传参时，我们要牢记形参的位置，这样比较麻烦。 可以直接通过 key = value 的形式进行传入，避免了需要记住形参位置的繁琐步骤，但是关键字传参必须放置在位置传参后面，也是个人比较推崇的一种传参方式： def func(x, y, z=3): print(x, y, z) func(y=2, x=1, z=3) func(1, z=3, y=2) # 1 2 3 # 1 2 3 *与**语法使用 *的形参接收 *语法用在形参上，代表该形参可以接收任意数量的位置传参对象。 该形参将会变成一个元组形式，接收所有的位置传参对象，这种形参必须定义在位置形参与默认形参的后面： def func(x, y=2, *args): print(x, y, args) func(1, 2, 3, 4, 5, 6, 7, 8, 9) # 1 2 (3, 4, 5, 6, 7, 8, 9) **的形参接收 **语法用在形参上，代表该形参可以接收任意数量的关键字传参对象。 该形参将会变成一个字典形式，接收所有的关键字传参对象，这种形参必须定义在位置形参与默认形参以及*形参的后面： def func(x, y=2, *args,**kwargs): print(x, y, args, kwargs) func(1, 2, 3, 4, 5, 6, 7, 8, 9, a=ord(\"a\"), b=ord(\"b\"), c=ord(\"c\")) # 1 2 (3, 4, 5, 6, 7, 8, 9) {'a': 97, 'b': 98, 'c': 99} *的实参传入 通过*语法，我们可以将1个容器序列根据位置传参的方式把其中的数据项对象传递给形参，如下所示： def func(x, y, z): print(x, y, z) func(*(1, 2, 3)) # 1 2 3 **的实参传入 通过**语法，我们也可以将1个字典根据关键字传参的方式把字典中的value对象传递给形参，如下所示： def func(x, y, z): print(x, y, z) func(**{\"x\": 1, \"y\": 2, \"z\": 3}) # 1 2 3 *args与**kwargs *形参通常命名为*args，这是一种约定的俗称。 同理，**形参则被命名为**kwargs。 指定传入方式 形参中，如果存在一个*名字的特殊标识，则该标识不用传递对象。 该标识是规定了哪些形参必须是接收位置传入的对象、哪些形参是必须接收关键字传入的对象，如下所示： def func(a, b=2, *, c=3, d): # ❶ print(a, b, c, d) func(1, d=4) ❶：在 *左边的都是位置传入，在*右边的都是关键字传入，在*右边的参数也被称为命名关键字参数 a：位置传入，不是默认参数，则必须通过位置传参的方式传入对象 b：位置传入，是默认参数，可以不用通过位置传参的方式传入对象 c：关键字传入，不是默认参数，则必须通过关键字传参的方式传入对象 d：关键字传入，是默认参数，可以不用通过关键字传参的方式传入对象 形参的定义顺序 形参的定义顺序如下所示： 位置形参 -> 默认形参 -> *args -> **kwargs 示例演示： def func(a, b, c=\"c\", *args, **kwargs): print(\"\"\" position params: {} {} default params: {} * params:{} ** params:{} \"\"\".format(a, b, c, args, kwargs)) func(\"A\", \"B\", \"C\", 1, 2, 3, 4, 5, k1=\"v1\", k2=\"v2\") # position params: A B # default params: C # * params:(1, 2, 3, 4, 5) # ** params:{'k1': 'v1', 'k2': 'v2'} 实参的传入顺序 实参的传入顺序牢记位置传参在前，关键字传参在后即可。 或者统一使用关键字传参，示例如下： def func(a, b, c, d, e, f): pass func(\"A\", *[\"B\", \"C\"], d=\"D\", **{\"e\": \"E\", \"f\": \"F\"}) # eq： # func(\"A\", \"B\", \"C\", d=\"D\", e=\"E\", f=\"F\") 嵌套调用中*与** 当函数2作为函数1的一层外包装，我们想调用函数2的时候实际上是调用的函数1，并且参数也要完整的传递过去，该怎么做呢？ Ps：这其实是装饰器的一个前瞻知识点 def func(x, y, z): print(x, y, z) def wrapper(*args, **kwargs): func(*args, **kwargs) # ❶ ❷ wrapper(1, y=\"v1\", z=\"v2\") # 1 v1 v2 ❶：实参用 * 和 ** 拆分开， * 是位置传参，**是关键字传参 ❷：args = (1)，kwargs = {\"y\":\"v1\",\"z\":\"v2”}，然后再通过解构进行传递给func函数，func相当于接收了 func(1, y=“v1”, z=“v2”) 函数标注 Python3.5之后新增了函数标注（function annotation），即类型提示功能如下所示，仅做提示，并不会限制传递参数时的类型： def add(x: int or float, y: int or float) -> int or float: # ❶ print(x) print(y) return x + y ❶：->代表返回值，返回int或者float类型 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-07-01 16:08:37 "},"Python/Python函数相关/命名空间.html":{"url":"Python/Python函数相关/命名空间.html","title":"命名空间","keywords":"","body":"Python之禅 传奇的Python核心开发者，Tim Peters为我们总结了Python核心思想点，收录在了内置模块this中： >>> import this The Zen of Python, by Tim Peters Beautiful is better than ugly. Explicit is better than implicit. Simple is better than complex. Complex is better than complicated. Flat is better than nested. Sparse is better than dense. Readability counts. Special cases aren't special enough to break the rules. Although practicality beats purity. Errors should never pass silently. Unless explicitly silenced. In the face of ambiguity, refuse the temptation to guess. There should be one-- and preferably only one --obvious way to do it. Although that way may not be obvious at first unless you're Dutch. Now is better than never. Although never is often better than *right* now. If the implementation is hard to explain, it's a bad idea. If the implementation is easy to explain, it may be a good idea. Namespaces are one honking great idea -- let's do more of those! Python之禅 by Tim Peters 优美胜于丑陋（Python 以编写优美的代码为目标） 明了胜于晦涩（优美的代码应当是明了的，命名规范，风格相似） 简洁胜于复杂（优美的代码应当是简洁的，不要有复杂的内部实现） 复杂胜于凌乱（如果复杂不可避免，那代码间也不能有难懂的关系，要保持接口简洁） 扁平胜于嵌套（优美的代码应当是扁平的，不能有太多的嵌套） 间隔胜于紧凑（优美的代码有适当的间隔，不要奢望一行代码解决问题） 可读性很重要（优美的代码是可读的） 即便假借特例的实用性之名，也不可违背这些规则（这些规则至高无上） 不要包容所有错误，除非你确定需要这样做（精准地捕获异常，不写 except:pass 风格的代码） 当存在多种可能，不要尝试去猜测 而是尽量找一种，最好是唯一一种明显的解决方案（如果不确定，就用穷举法） 虽然这并不容易，因为你不是 Python 之父（这里的 Dutch 是指 Guido ） 做也许好过不做，但不假思索就动手还不如不做（动手之前要细思量） 如果你无法向人描述你的方案，那肯定不是一个好方案；反之亦然（方案测评标准） 命名空间是一种绝妙的理念，我们应当多加利用（倡导与号召） 而今天我们主要探索的内容就是这最后一句，命名空间。 以下内容将围绕Python之禅最后一句话来进行逐一解惑。 Tim Peters是一位高产的Python开发者，在Python1.0版本之前就已经贡献出大量的代码，如li.sort()的排序算法TimSort就是Tim Peters所贡献，并且最终在Python2.x版本中进行使用 NameSpaces 命名空间即存储所有标识符（变量名、函数名、类名）的地方。 它本身是一种虚拟的概念，实际上并不存在。 命名空间分为3大类： 内置命名空间（Builtin NameSpaces） 全局命名空间（Global NameSpaces） 局部命名空间（Local NameSpaces） 不同的命名空间，存储的标识符范畴也不同，如下所示： 内置命名空间：存储Python解释器自带的标识符 全局命名空间：存储未在类、函数、方法中定义的标识符 局部命名空间：在调用类、函数、方法时产生的标识符 我们以一个代码和一幅图来举例： name = \"Jack\" age = 18 gender = \"male\" def add(x , y): res = x + y return res def sub(x, y): res = x - y return res Builtin NameSpaces 内置命名空间： 存放的标识符：Python解释器自带的函数标识符、变量标识符、类标识符等，如print、input、open等... 生命周期：Python解释器启动时产生，关闭时销毁 允许的数量：至多1个 示例演示： >>> print >>> input >>> open Global NameSpaces 全局命名空间： 存放的标识符：未在类、函数、方法中定义的标识符 生命周期：Python脚本文件执行时产生，执行完毕时销毁 允许的数量：至多1个 示例演示： name = \"Jack\" age = 18 gender = \"male\" def mathFunctionSet(method, x, y): def add(x, y): res = x + y return res def sub(x, y): res = x - y return res methodNameMapping = { \"add\":add, \"sub\":sub } return methodNameMapping[method](x,y) 上述示例中共有1个全局命名空间，存储的标识符有： name age gender # 变量标识符 mathFunctionSet # 函数标识符 Local NameSpaces 局部命名空间： 存放的标识符：在调用类、函数、方法时产生的标识符 生命周期：对于函数的局部命名空间来说，函数调用时存活，调用完毕则销毁 允许的数量：可以有多个局部命名空间，取决于内存大小 示例演示： name = \"Jack\" age = 18 gender = \"male\" def mathFunctionSet(method, x, y): def add(x, y): res = x + y return res def sub(x, y): res = x - y return res methodNameMapping = { \"add\":add, \"sub\":sub } return methodNameMapping[method](x,y) 上述示例中共有3个局部命名空间，如下所示： mathFunctionSet的局部命名空间存储的标识符： method x y add sub methodNameMapping add局部命名空间存储的标识符： x y res sub局部命名空间存储的标识符: x y res 顺序相关 加载和销毁顺序 加载顺序：内置命名空间 -> 全局命名空间 -> 局部命名空间 销毁顺序：局部命名空间 -> 全局命名空间 -> 内置命名空间 命名空间封闭性 在全局命名空间中无法访问局部命名空间定义的标识符，但是局部命名空间中可以访问全局命名空间的标识符，如下所示： globalName = \"global\" def function(): localName = \"function\" print(localName) function() print(localName) # function # NameError: name 'localName' is not defined 当然，内置命名空间是在哪里都可以进行访问。 标识符查找顺序 先在自己的命名空间中找，找不到就往定义自己的命名空间中找，最后查找内置命名空间。 如下代码示例： name = \"global\" def outer(): name = \"outer\" inner() # ❷ def inner(): print(name) # ❸ outer() # ❶ 首先我们是在全局命名空间中定义了outer()函数的标识符、inner()函数的标识符以及name变量标识符。 ❶：运行outer()函数 ❷：运行inner()函数 ❸：inner()中查找name，inner()的局部命名空间中没有name标识符，往定义自己的命名空间找，即到全局命名空间，最终找到name标识符 标识符的覆盖特性 如果全局/局部命名空间与内置命名空间中的标识符发生冲突，则最先查找到全局/局部命名空间中的标识符。 这也是为什么在第一章的时候就说到标识符的命名应该避免关键字，示例如下： print(callable(input)) # ❶ input = \"..\" print(callable(input)) # ❷ # True # False ❶：input此时引用的是内置命名空间的input()函数，所以可调用 ❷：全局命名空间中已经定义了input，此时的input引用的是全局命名空间中的字符串“..”，所以不可调用 预先检测的标识符 我们来看一个有趣的例子： x = 1 def function(x): print(x) x = 1 function(x) # 1 将这个代码稍微改动： x = 1 def function(): print(x) x = 1 function() # UnboundLocalError: local variable 'x' referenced before assignment 按理说，例子2中的x会引用全局命名空间中的x，那么为何会抛出异常呢？ 我们说过，在初始化函数时，会预先检测其中的语法是否出现错误： 例子1中的x最早出现在形参中，也就是说第3行的形参中定义了x，所以下面再使用x时是没有任何问题的 例子2中的x是定义在第5行，但是在第4行里就进行了使用，违反了对象必须先声明后使用的原则，故抛出异常 方法介绍 global引入 一个例子 先看一个简单的例子吧： x = 1 # ❶ def function(): x = 3 # ❸ print(x) # ❹ function() # ❷ print(x) # ❺ # 3 # 1 图示如下： ❶：全局命名空间定义了变量x，指向内存中的1 ❷：开始调用函数function() ❸：函数function()的局部命名空间中也声明了x，并且指向内存中的3 ❹：打印x，打印语句在函数内部，所以先从function()的局部命名空间中找x，这个x指向的3 ❺：打印x，打印语句在函数外部，所以在全局命名空间中找x，这个x指向的1 所以最后的结果是：3、1 方法使用 gloabl关键词可以在函数中使用，该关键词后面出现的标识符在函数内部也可以进行使用，但是该标识符的对象会指向全局命名空间中的对象。 我们对上面例子加上一句代码，结果就变的不同了： x = 1 # ❶ def function(): global x # ❷ x = 3 # ❸、❹ print(x) # ❺ function() print(x) # ❻ # 3 # 3 如下图所示： ❶：全局命名空间定义了变量x，指向内存中的1 ❷：在函数function()执行时，引入了外部的x，指向内存中的1 ❸、❹：将x重新指向3 ❺：打印x，打印语句在函数内部，所以先从function()的局部命名空间中找x，这个x就是外部的x，指向1 ❻：打印x，打印语句在函数外部，所以在全局命名空间中找x，这个x当然也指向的1 nonlocal引入 一个例子 先看一个简单的例子吧： x = 1 def outer(): x = 2 def inner(): x = 3 print(x) inner() print(x) outer() print(x) # 3 # 2 # 1 这个参照上面的global引入图示。 第1个print()是在inner()函数的局部命名空间中打印x，所以打印了3 第2个print()是在outer()函数的局部命名空间中打印x，所以打印了2 第3个print()是在全局命名空间中打印x，所以打印了3 方法使用 nonlocal关键字与global使用相同，不同的是gloabl引用的是全局命名空间中的标识符对象，而nonlocal则是引用上层局部命名空间中的标识符对象。 将代码稍微改动，于是你便发现结果又变了： x = 1 def outer(): x = 2 def inner(): nonlocal x print(x) inner() print(x) outer() print(x) # 2 # 2 # 1 第1个print()是在inner()函数的局部命名空间中打印x，该x指向的是上层局部命名空间中的x，所以打印了2 第2个print()是在outer()函数的局部命名空间中打印x，所以打印了2 第3个print()是在全局命名空间中打印x，所以打印了3 LEGB 我们在nonlocal例子中看见了一共有4个命名空间，分别如下： 内置命名空间 全局命名空间 函数outer的局部命名空间 函数inner的局部命名空间 这样划分会显得有些杂乱，所以可以将它用新的命名方式来表示，总计划分为4层： B-Builtin(Python)：Python解释器的内置命名空间，用B来表示 G-Global(module)；函数定义所在模块（文件）的命名空间，即全局命名空间，用G来表示 E-Enclosing function locals：外部嵌套函数的命名空间，即outer的局部命名空间，用E来表示，因为它是封闭的 L-Local(function)：被嵌套的函数命名空间，即inner的局部命名空间，用L来表示，即代码执行最里层的本地空间 作用域 在很多其他的教程中，可能会有作用域的划分，将3个命名空间分为了2个作用域： 全局作用域：包含内置命名空间与局部命名空间 局部作用域：即局部命名空间 这是一种比较粗暴直白的划分，并没有命名空间的划分来的详细，本质都是1个东西，这里不再举例。 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-13 20:41:50 "},"Python/Python函数相关/高阶函数.html":{"url":"Python/Python函数相关/高阶函数.html","title":"高阶函数","keywords":"","body":"高阶函数 在Python中函数是一等公民，它与普通的数据项对象并没有什么区别，唯一的区别可能在于函数是能被调用的吧。 这意味着，Python中的函数可以做下面的事情： 可以赋值 可以将一个函数对象传递给另一个函数对象的形参 一个函数中可以返回另一个函数 可以将函数当做容器类型中的一个数据项元素 赋值 函数标识符本来仅是一个贴纸，指向了函数体代码在内存中的位置。 那么我们可以再加上一个贴纸标识符，让它与函数标识符指向内存中相同的位置，如下所示： def function(): print(\"function ...\") func = function func() # function ... 传参 可以将一个函数对象传递给另一个函数对象的形参，如下所示： def outer(func): print(\"start\") func() print(\"stop\") def inner(): print(\"inner ..\") outer(inner) # start # inner .. # stop 返回值 一个函数中可以返回另一个函数，这样的做法常用于嵌套定义函数。 Ps：嵌套定义函数和嵌套调用函数还是有所不同的，嵌套定义的2个函数不在同一命名空间中进行声明，而是具有包含关系，而嵌套调用的函数大部分情况在同一命名空间中进行定义声明。 def outer(): def inner(): print(\"inner\") return inner func = outer() func() # inner 因为函数具有封装线，故外部无法访问内部，但是如果E层函数主动返回L层函数，那么外部就可以拿到L层的函数进行调用。 数据项 函数可以作为容器对象中的数据项： def f1(): print(\"f1\") def f2(): print(\"f2\") def f3(): print(\"f3\") li1 = [f1, f2, f3] for func in li1: func() # f1 # f2 # f3 应用实例 函数的嵌套调用 函数的嵌套调用会很常见。 如果有2个函数，我们可以将2个函数的功能进行分类： 函数1主要负责为外部使用者提供入口，而不负责逻辑关系的处理 函数2主要负责内部逻辑关系的处理，对于外部调用者而言它是隐藏的 如下所示，我们使用2个函数来实现从1个容器类型中拿出最大数据项的功能： def getMaxValue(*args): \"\"\"interface\"\"\" currentMaxItem = args[0] for item in args[1:]: currentMaxItem = computeMaxValue(item, currentMaxItem) return currentMaxItem def computeMaxValue(x, y): \"\"\"logic\"\"\" return x if x > y else y result = getMaxValue(*[8, 1, 2, 3, 5, 4]) print(result) # 8 基于函数的封装 我们只需要在函数内部定义函数，将1堆类似功能的函数封装在1个抽象函数中即可。 如下我们定义了1个数学工具类函数，它将包含了求长方形、长发体的面积： def mathFormula(select, length, width, height=None): \"\"\"长方形，求面积输入长宽，求体积输入长宽高\"\"\" def area(length, width): \"\"\"长方形面积\"\"\" return length * width def bulk(length, width, height): \"\"\"长方体体积\"\"\" return length * width * height if select == 1: return area(length, width) elif select == 2: return bulk(length, width, height) else: print(\"输入有误\") res = mathFormula(select=1, length=20, width=20) print(res) # 400 基于函数的字典 修改学生信息的一个小例子，如下所示： studentMessage = { \"1\": {\"name\": \"Tom\", \"gender\": \"male\", \"age\": 18, \"height\": 192, \"weight\": 140}, \"2\": {\"name\": \"Jack\", \"gender\": \"male\", \"age\": 17, \"height\": 172, \"weight\": 120}, \"3\": {\"name\": \"Kelly\", \"gender\": \"female\", \"age\": 20, \"height\": 168, \"weight\": 130}, } def check(): \"\"\"查\"\"\" for item in studentMessage: print(\"学生编号:{0}\".format(item)) for key, value in studentMessage[item].items(): print(\"{0: >10} | {1: Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-13 20:41:50 "},"Python/Python函数相关/递归函数.html":{"url":"Python/Python函数相关/递归函数.html","title":"递归函数","keywords":"","body":"递归函数 递归的特性 递归（recursion）是一种函数的调用方式，简而言之就是自己调用自己。 递归可以将一个大规模的问题分解成更小的相同问题，经过持续分解到最后问题规模小到可以用非常简单直接的方式来解决，或者将一个问题拆分成不同的各个部分，达到分而解决分而治之的目的。 一个递归函数必须要满足3要素： 必须有一个基本结束条件 必须能改变问题规模 必须调用自身 如下所示，这就是一个标准的递归函数： def function(count): if count: print(count) function(count=count - 1) return function(5) # 5 # 4 # 3 # 2 # 1 回溯与递推 函数递归必然经历2个阶段，一个是回溯阶段，一个是递推阶段： 回溯：函数不断递归调用自身时的阶段被称为回溯阶段 递推：当函数退出递归调用时的阶段被称为递推阶段 下面是一个问姓名的问题，可以非常直白的阐述回溯和递推的2个概念。 首先，你问A多少岁，A会回答你他比B大10岁，然后你又问B多少岁，B会回答你它比C大10岁... 这样直至E，E说他的年龄是18岁，最后问A多少岁？ 如上图所示，当你问A年龄的时候，回溯阶段开始。 而当你得知E的年龄后，递推阶段开始，根据E反推出A年龄的过程即递推的过程。 代码表现形式如下： def getAge(n): if n == 1: return 18 return getAge(n - 1) + 10 a = getAge(5) print(a) # 58 实例练习 数据项提取 有1个不知道维度的列表，现在要将它转换为1维列表，并且按照升序进行排序： oldList = [10, 1.2, [3, 345, 2.2, [15, [88.6, [78, [89.3, 99, [50]]]]]]] newList = [] def listSort(li): for i in li: if isinstance(i, list): listSort(i) else: newList.append(i) newList.sort() listSort(oldList) print(newList) # [1.2, 2.2, 3, 10, 15, 50, 78, 88.6, 89.3, 99, 345] 爬楼梯问题 有1个n阶的楼梯，每次可以爬1个台阶或者2个台阶，求解有多少种方法爬完整个楼梯。 def climbTheStairs(n): if n == 1: return 1 # ❶ if n == 2: return 2 # ❷ return climbTheStairs(n - 1) + climbTheStairs(n - 2) # ❸ print(climbTheStairs(3)) # 3 ❶：只有1个台阶，就只有1种走法，一次走1步 ❷：只有2个台阶，就只有2中走法，一次走1步或者一次走2步 ❸：将1次走1步的算出来，将1次走2步的算出来进行相加 递归与while 递归与while循环有一些类似之处，比如都要设置结束条件，但是两者不可一概而论。 如果一个问题规模不被确定，使用递归是最好的方案。 而如果一个问题的规模已被确定，则可以使用while循环进行解决。 但是递归要比while循环的效率更加的低下，因为递归的过程中会进行函数的调用，而函数调用则必定会对内存造成更大的压力，这来源于系统调用栈的栈帧会跟随每一次递归而不断的生成。 递归的深度 系统调用栈栈帧的生成不能毫无限制，所以Python对递归的深度进行了最大1000层的限定。 你可以随时修改这个层次，但是如果问题规模过大导致递归层次过多，则可能发生爆内存的情况，因为每一次的栈帧都会保存在内存中，以下是修改递归最大深度限制的方法： >>> import sys >>> sys.setrecursionlimit(100000) # ❶ >>> sys.getrecursionlimit() # ❷ 100000 ❶：修改最大默认递归层次为10000层 ❷：获取当前最大的递归层次 尾递归优化 递归函数中，每一次的栈帧生成都是相同的。 每一个递归函数的栈帧都拥有相同的调用方（自身）、拥有相同的字节码（相同的函数）、用于相同的命名空间（标识符）。 由于栈帧在系统调用栈中会占用大量的内存，对于某些语言如Java而言，会针对递归函数做一些优化，具体是指如果1个函数是进行递归调用，则只生成1个栈帧。 这种优化策略能够极大的减少内存空间的占用，也被称之为尾递归优化。 遗憾的是，Python并未实现尾递归优化。 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-13 20:41:50 "},"Python/Python函数相关/匿名函数.html":{"url":"Python/Python函数相关/匿名函数.html","title":"匿名函数","keywords":"","body":"匿名函数 匿名函数即没有名字的函数，最早出现在LISP语言中，Python对其进行了引用。 匿名函数的作用就是在不丧失代码可读性的前提下为精简代码提供的一种方式，以下是定义匿名函数的语法，通过lambda关键字进行定义。 注意！函数不管有名没名，都必须先定义后使用 语法如下： lambda 形参1, 形参2 ... : 返回值 # ❶ ❷ ❶：形参可以有多个，也可以没有 ❷：返回值不用跟return，直接写逻辑语句即可，将会自动的把逻辑语句的结果进行返回 定义和使用匿名函数的实际示例，求2个数的和： res = (lambda x, y : x + y)(1, 2) print(res) 匿名函数常用于定义一些非常简单的逻辑，不支持多行，因此要尽量写的简洁易懂。 使用方式 为匿名函数取名 匿名函数也可以通过一个标识符进行命名，但是一般都不会这样做： add = lambda x, y : x + y res = add(1, 2) print(res) # 3 自执行和自销毁 自执行函数即定义了匿名函数之后就立刻加括号调用，这种函数只会运行一次。 并且由于没有标识符的引用绑定关系，故使用完成后就会被GC机制所立即回收掉： res = (lambda x, y : x + y)(1, 2) # ❶ print(res) # 3 ❶：自执行的匿名函数必须在括号中进行定义 内置函数搭配使用 匿名函数常用于与内置函数进行搭配使用，如下将使用内置函数max()搭配匿名函数求得下列薪资最高的人员名字： salaries = { 'Ken': 3000, 'Tom': 7000, 'Jack': 2000 } name = max(salaries, key=lambda k: salaries[k]) # ❶ print(name) ❶：max()函数的key参数可指定1个函数，此时函数的返回结果就是本次求最大值的对比条件，这个例子就是指定薪资作为对比条件 常用搭配函数 lambda表达式与一些函数配合，才能发挥出最大的威力。 Python中出名的诸如map()、filter()、reduce()函数等均来自Lisp语言的设计，它们实在是太方便了，其实说到底一门优秀的语言必定大量借鉴了其他语言的优秀特性。 max()与min() max()函数用于从1个可迭代对象中返回最大的数据项，而min()是返回最小的，其他都一样。 max()函数签名如下： def max(*args, key=None): pass 参数详解： args：一个可迭代对象，拥有1个形参 key：传入1个可调用对象（通常是指函数），指定本次的大小对比方式，默认是根据数据项值本身对比 默认比对是比对的值本身，如果是字典则拿key的值进行比对，以下示例中，由于C的ASCII码比A大，所以返回了C： dic = {\"A\": 100, \"B\": 50, \"C\": 20} res = max(dic) print(res) # C 传入参数key，修改对比方式为字典的value，那么最后A的value最大，故返回A： dic = {\"A\": 100, \"B\": 50, \"C\": 20} res = max(dic, key=lambda k:dic[k]) print(res) # A 手动实现max()函数： from collections.abc import Iterable def customizeMax(*args, key=None): def default(args): \"\"\"默认对比规则\"\"\" it = iter(args) if not isinstance(args[0], Iterable) else iter(args[0]) currentMaxItem = next(it) for item in it: if currentMaxItem map() map()函数会从一个可迭代对象中依次取出1个数据项，并且会按照指定函数对数据项进行处理，处理完成后生成新的map可迭代对象并返回该map可迭代对象。 map()函数签名如下： def __init__(self, func, *iterables): pass 参数详解： func：一个可调用对象（通常是指函数），拥有1个形参，对iterables的数据项进行遍历并将返回值加入至新的map容器中，迭代完成后返回新的map容器 iterables：一个可迭代对象 其实map()能做的推导式都能做，如将整个可迭代对象中的数据项+100，并返回新的可迭代对象： newMapObject = map(lambda x:x+100, range(10)) print(list(newMapObject)) newList = [(lambda x:x+100)(i) for i in range(10)] print(newList) # [100, 101, 102, 103, 104, 105, 106, 107, 108, 109] # [100, 101, 102, 103, 104, 105, 106, 107, 108, 109] 手动实现map()函数： from collections.abc import Iterable def customizeMap(func, *iterables): it = iter(iterables) if not isinstance(iterables[0], Iterable) else iter(iterables[0]) for item in it: yield func(item) print(list(customizeMap(lambda x:x + 100, range(10)))) # [100, 101, 102, 103, 104, 105, 106, 107, 108, 109] filter() filter()函数会从一个可迭代对象中依次取出1个数据项，并且会按照指定函数对数据项进行筛选，符合条件的数据项加入新的filter对象中，不符合条件的数据项会直接丢弃，当遍历完整个可迭代对象后会返回新的filter对象。 filter()函数签名如下： def __init__(self, function_or_None, iterable): pass 参数详解： function_or_None：一个可调用对象（通常是指函数），拥有1个形参，指筛选条件，如果是None则筛选条件，此时会按照数据项本身的布尔值进行筛选 iterable：一个可迭代对象 其实filter()能做的推导式都能做，如遍历整个容器对象，将是偶数的数据项筛选出来： newFilterObject = filter(lambda x: x % 2 == 0, range(10)) print(list(newFilterObject)) newList = [i for i in range(10) if i % 2 == 0] print(newList) # [0, 2, 4, 6, 8] # [0, 2, 4, 6, 8] 手动实现filter()函数： def customizeFilter(function_or_None, iterable): it = iter(iterable) if function_or_None is None: for item in it: # 若没有指定筛选函数，则按照数据项本身的布尔值进行筛选 if item: yield item for item in it: res = function_or_None(item) if res: yield item print(list(customizeFilter(lambda x: x % 2 == 0, range(10)))) # [0, 2, 4, 6, 8] reduce() reduce()函数有1个初始值，你可以指定该初始值或者不指定。 每次对可迭代对象数据项进行迭代后，都会调用函数处理该数据项，并且将该数据项与初始值进行操作。 常用于累积运算，如累加，累乘等。 虽然该函数在Python3中已经被移除至内置函数的范畴，但是其强大的功能却很少被人熟练应用。 reduce()函数签名如下： def reduce(function, sequence, initial=None): pass 参数详解： function：一个可调用对象（通常是指函数），拥有2个形参，接收来自可迭代对象的2个数据项 sequence：一个可迭代对象 initial：一个初始值，它会随着可调用对象传入的参数进行运算而不断的改变，最终返回 简单的使用示例，求1 - 100的累加总和： from functools import reduce seqSum = reduce(lambda x,y:x+y, range(1, 101)) print(seqSum) # 5050 使用reduce()能够快速的完成寻求最大最小值的操作： from functools import reduce seqMax = reduce(lambda x, y: x if x > y else y, [1, 5, 10, 100, 399, 29]) print(seqMax) # 399 如果指定了初始值，那么则在初始值的基础上进行操作，如下所示初始值是English，每次的x，y进行相加后会再与初始值进行相加，最后会返回初始值： from functools import reduce seqSumStr = reduce(lambda x, y: x + y, [chr(i) for i in range(65, 65 + 26)], \"English:\") print(seqSumStr) # English:ABCDEFGHIJKLMNOPQRSTUVWXYZ 手动实现reduce()函数，了解底层实现原理： def customizeReduce(function, sequence, initial=None): it = iter(sequence) if initial: value = initial else: value = next(it) for item in it: value = function(value, item) return value seqSum = customizeReduce(lambda x, y: x + y, range(1, 101)) print(seqSum) seqMax = customizeReduce(lambda x, y: x if x > y else y, [1, 5, 10, 100, 399, 29]) print(seqMax) seqSumStr = customizeReduce(lambda x, y: x + y, [chr(i) for i in range(65, 65 + 26)], \"English:\") print(seqSumStr) # 5050 # 399 # English:ABCDEFGHIJKLMNOPQRSTUVWXYZ sorted() sorted()函数可以将一个可迭代对象传入，返回一个经过排序的列表，默认是升序排序。 第一参数：可迭代对象 第二参数，关键字key：一个可调用对象（通常是指函数），拥有1个形参，返回结果即为排序的对比规则，如不指定则按照Python默认排序对比规则进行排序对比 第三参数，关键字reverse：一个布尔值，当排序完成后是否对新列表进行翻转，默认是False即不翻转整个列表，如果是True则进行翻转，相当于对可迭代对象进行降序排序 sorted()函数与li.sort()方法的区别在于它会返回一个新的排好序的列表，而li.sort()则是原地排序。 此外sorted()函数支持对字典排序，这样做会返回1个包含字典key的列表，而li.sort()方法仅支持对列表排序。 使用如下，按照哈希值进行排序，并且翻转整个新的排序列表： newList = sorted([chr(i) for i in range(65, 65 + 26)], key=lambda item: hash(item), reverse=True) print(newList) # ['X', 'J', 'R', 'L', 'Q', 'C', 'U', 'T', 'M', 'O', 'I', 'Y', 'A', 'V', 'S', 'N', 'D', 'E', 'G', 'K', 'W', 'F', 'H', 'Z', 'B', 'P'] reversed() reversed()函数不可与lambda表达式进行搭配，放到这里的主要原因是因为它与sorted()的reverse参数、li.sort()的reverse参数作用相同，用于生成一个被翻转过后的新列表，如下所示，返回的结果是一个reversed可迭代对象，必须将它转换为list或者tuple后才能查看其中数据项： print( tuple(reversed([i for i in range(10)])) ) # (9, 8, 7, 6, 5, 4, 3, 2, 1, 0) 注意：该方法是生成新的对象，而不是原地翻转。 版本区别 Python2中的reduce()是内置模块，直接使用即可。 并且Python2中的map()、filter()的返回结果均为列表，而不是map对象和filter对象。 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-13 20:41:50 "},"Python/Python函数相关/内置函数.html":{"url":"Python/Python函数相关/内置函数.html","title":"内置函数","keywords":"","body":"查看方式 Python3中常用的内置函数可通过导入builtins模块查看： print(builtins.__dict__) 下面将挑选常用的且以前很少使用的内置函数进行示例。 基础 常用函数： 函数 返回值 描述 关注度 help() None 打印对象下的doc文档注释信息 5 hash() int 返回不可变对象的hash表现形式 5 id() int 返回对象在内存中的标识，即地址空间编号 5 print() None 向终端输入一则信息 5 input() str 获得用户在终端中输入的内容 5 open() fileObject 打开一个文件，获得文件句柄 5 exit() None 关闭并退出当前的Python解释器 3 quit() None 与exit()相同 3 help()获得帮助文档： >>> help(int) Help on class int in module builtins: class int(object) | int(x=0) -> integer | int(x, base=10) -> integer ... exit()和quit()都是退出解释器，结束脚本的继续执行。 类型转换 常用函数： 函数 返回值 描述 关注度 bool() bool 返回对象的布尔值 5 int() int 返回整形 5 float() float 返回浮点型 5 str() str 返回字符串 5 bytes() bytes 返回字节串 5 list() list 返回列表 5 tuple() tuple 返回元组 5 dict() dict 返回字典 5 set() set 返回集合 5 frozenset() frozenset 返回不可变集合 5 数学 常用函数： 函数 返回值 描述 关注度 hex() str 传入整形，返回其16进制表现形式 5 oct() str 传入整形，返回其8进制表现形式 5 bin() str 传入整形，返回其2进制表现形式 5 divmod() tuple 返回x与y的整除结果与求余结果 5 pow() int 返回x的y次乘阶 3 round() int 对数字的小数位数进行四舍五入 2 abs() int 返回参数的绝对值 2 divmod()返回x与y的整除结果与求余结果： >>> divmod(10, 3) (3, 1) 相当于10 // 3，10 % 3。 pow()返回x的y次乘阶，相当于x ** y： >>> pow(3, 3) 27 round()对数字的小数位数进行四舍五入： >>> round(3.4) 3 >>> round(3.5) 4 abs()返回参数的绝对值： >>> abs(-1) 1 字符串 常用函数： 函数 返回值 描述 关注度 chr() str 传入整形，将其转换为Unicode的16进制编码表现形式 5 ord() int 传入单个Unicode字符，将其转换为整形 5 ascii() str 返回对象的纯ASCII表示形式 1 format() str 获得对象内部双下format()方法的结果 1 repr() str 返回对象的规范字符串表示形式 2 eval() any 执行一个字符串形式的Python语句，并且返回执行结果 3 exec() any 执行一个字符串形式的Python语句，不会返回执行结果 3 repr()返回对象的规范字符串表示形式，相当于%r： >>> repr(1) '1' >>> 1 1 eval()执行一个字符串形式的Python语句，并且返回执行结果： >>> string = \"1 + 2\" >>> res = eval(string) >>> res 3 exec()执行一个字符串形式的Python语句，不会返回执行结果： >>> string = \"print('hello world')\" >>> exec(string) hello world 容器 常用函数： 函数 返回值 描述 关注度 len() int 返回容器中的项目数 5 slice() sliceObject 返回索引切片对象 2 iter() iterator 调用对象的双下iter()方法，获得专属迭代器 4 next() Item 从迭代器返回下一个数据项 4 range() rangeObject 返回range可迭代对象 5 enumerate() enumerateObject 返回可迭代对象的枚举类型 5 zip() zipObject 接收2个可迭代对象，将其合并为1个可迭代对象并返回，拉链函数 3 max() item 返回容器中最大的数据项 4 min() item 返回容器中最小的数据项 4 sum() int or float 迭代一个可迭代对象，并对其中数据项进行累加，返回求和结果 4 map() mapObject 对一个可迭代对象进行遍历，并对其中数据项挨个做操作，处理完成后返回map对象 5 filter() filterObject 对一个可迭代对象进行遍历，将符合条件的数据项返回至新的filter对象中 5 sorted() list 对一个容器进行排序，返回新的容器 5 reversed() reversedObject 对一个容器进行翻转，返回新的reversed对象 5 all() bool 如果容器中的数据项均为真，则返回True，否则返回False，若是空容器返回True 3 any() bool 如果容器中的数据项有1个为真，则返回True，否则返回False，若是空容器返回False 3 iter()和next()在迭代器一章节中会详细介绍。 zip()接收2个可迭代对象，将其合并为1个可迭代对象并返回，拉链函数： >>> li1 = [\"k1\", \"k2\", \"k3\"] >>> li2 = [\"v1\", \"v2\", \"v3\"] >>> list(zip(li1, li2)) [('k1', 'v1'), ('k2', 'v2'), ('k3', 'v3')] 可以用它快速将2个列表合成1个字典： >>> dict(zip(li1, li2)) {'k1': 'v1', 'k2': 'v2', 'k3': 'v3'} sum()迭代一个可迭代对象，并对其中数据项进行累加，返回求和结果： >>> sum(range(1, 101)) 5050 all()如果容器中的数据项均为真，则返回True，否则返回False，若是空容器返回True： >>> all([1,None,0]) False >>> all([(),{},[],None,0]) False >>> all([]) True any()如果容器中的数据项有1个为真，则返回True，否则返回False，若是空容器返回False： >>> any([1,None,0]) True >>> any([(),{},[],None,0]) False >>> any([]) False 面向对象 常用函数： 函数 返回值 描述 关注度 type() str 获得对象的类型 4 callable() bool 返回对象是否可调用 4 dir() list 返回对象的所有类实现方法，以及类属性 5 vars() dict 当不传入对象时相当于locals()方法，传入对象后相当于调用对象底层的双下字典 1 hasattr() bool 判断一个对象下某一个属性或者方法是否存在 5 getattr() attr 获取一个对象下某一个属性或者方法 5 setattr() None 新增或者设置一个对象的属性或者方法 5 delattr() None 删除一个对象下某一个属性或者方法 5 isinstance() bool 返回对象是类的实例还是子类的实例 5 issubclass() bool 判断一个类是否是另一个类的子类 5 super() method 调用父类的同名方法 5 type()函数已经见过了，其他函数将放在面向对象一栏中详细介绍。 作用域 常用函数： 函数 返回值 描述 关注度 globals() dict 返回全局命名空间的字典 2 locals() dict 返回当前代码执行的局部命名空间的字典 2 没什么用，完全可以不在意。 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-13 20:41:50 "},"Python/Python函数相关/装饰器.html":{"url":"Python/Python函数相关/装饰器.html","title":"装饰器","keywords":"","body":"装饰器 开闭原则 根据设计模式中的6大设计原则中的开闭原则来说，一个良好的项目应该具有以下2个特性： 对扩展开放：项目应当具有良好的扩展性 对修改关闭：当项目需要做功能变更时，不应该修改源代码，而应该增添新的功能，达到热插拔的效果 装饰器 装饰器（decorator）的功能就是在不违背开闭原则的前提下为一个原有功能增加上一些新的功能。 但是原有功能的调用、源代码都不会被修改，类似于一种在外部打补丁的方式。 装饰器有函数装饰器，类装饰器等分别，这里介绍函数装饰器，其实它们的运行原理都是相同的。 功能需求 我们有2个函数，upload()和download()，现在有1个需求，分别求出2个函数的运行时间。 同时还有3点限制： 不能修改源函数内部代码 不能改变源函数的调用方式 要以最精简的代码量完成需求 源代码如下： import time import random def download(fileName): time.sleep(random.randint(1, 3)) return \"下载文件{}完成\".format(fileName) def upload(fileName): time.sleep(random.randint(1, 3)) return \"下载文件{}完成\".format(fileName) downResult = download(\"testDownload.text\") upResult = upload(\"testUpload.text\") 解决过程 外部代码 最简单的方式是添加外部代码，来看一下效果： import time import random def download(fileName): time.sleep(random.randint(1, 3)) return \"下载文件{}完成\".format(fileName) def upload(fileName): time.sleep(random.randint(1, 3)) return \"下载文件{}完成\".format(fileName) downStartTime = time.time() downResult = download(\"testDownload.text\") downEndTime = time.time() downTotalTime = downEndTime - downStartTime print(\"函数:{} 运行共花费时长:{}\".format(download.__name__, downTotalTime)) upStartTime = time.time() upResult = upload(\"testUpload.text\") upEndTime = time.time() upTotalTime = upEndTime - upStartTime print(\"函数:{} 运行共花费时长:{}\".format(upload.__name__, downTotalTime)) # 函数:download 运行共花费时长:2.002652883529663 # 函数:upload 运行共花费时长:2.002652883529663 优点： 没有改变源函数的调用方式 没有修改源函数内部代码 缺点： 代码冗余量过大，每一次函数执行都至少要添加4行代码（开始时间，结束时间，总计时间，打印语句） 传参方式 对上述代码进行优化，再来看看效果： import time import random def showTotalRunTime(func, *args, **kwargs): startTime = time.time() res = func(*args, **kwargs) endTime = time.time() totalTime = endTime - startTime print(\"函数:{} 运行共花费时长:{}\".format(func.__name__, totalTime)) return res def download(fileName): time.sleep(random.randint(1, 3)) return \"下载文件{}完成\".format(fileName) def upload(fileName): time.sleep(random.randint(1, 3)) return \"下载文件{}完成\".format(fileName) downResult = showTotalRunTime(download, \"testDownload.text\") upResult = showTotalRunTime(upload, \"testUpload.text\") print(downResult) print(upResult) 优点： 极大的减少了代码冗余量 没有修改源函数内部代码 缺点： 改变了源函数的调用方式，若想在使用原本功能的前提下获得统计时长的功能，则必须运行showTotalRunTime()函数 闭包函数 闭包函数介绍 闭包函数是装饰器的核心知识点。 闭函数通常是指L层的函数，即被嵌套定义在另一个函数中的函数 包函数通常是指E层的函数，即该函数的内部嵌套定义了另一个函数 它的基本概念在于： 标识符的查找顺序以定义阶段为标准。当前命名空间没找到名字时则往定义自己的命名空间中查找标识符。 如下所示，这就是一个完整的闭包函数： def outer(): # ❶ def inner(): # ❷ pass return inner ❶：outer()函数是包函数 ❷：inner()函数是闭函数 闭包方案 在闭包函数中，E层的包函数命名空间里所有的标识符对象都不会被销毁（即使包函数已经进行了return），在L层的闭函数中，可以通过命名空间标识符向上查找的特性拿到E层包函数的命名空间标识符。 故我们可以使用闭包函数来进行问题的解决，下面的warpper()函数其实就是装饰器函数： import time import random def warpper(func): def inner(*args, **kwargs): startTime = time.time() res = func(*args, **kwargs) # ❹ endTime = time.time() totalTime = endTime - startTime print(\"函数:{} 运行共花费时长:{}\".format(func.__name__, totalTime)) return res return inner def download(fileName): time.sleep(random.randint(1, 3)) return \"下载文件{}完成\".format(fileName) def upload(fileName): time.sleep(random.randint(1, 3)) return \"下载文件{}完成\".format(fileName) download = warpper(download) # ❶ upload = warpper(upload) # ❷ downResult = download(\"testDownload.text\") # ❸ print(downResult) upResult = upload(\"testUpload.text\") print(upResult) ❶：调用warpper()函数，func形参存储的对象为download()函数，并返回inner()函数，此时外部的download标识符指向了inner()函数 ❷：调用warpper()函数，func形参存储的对象为upload()函数，并返回inner()函数，此时外部的upload标识符指向了inner()函数 ❸：调用download标识符所指向的inner()函数，并且传入了参数”testDownload.text”，开始执行inner()函数 ❹：在L层命名空间找func标识符，找不到，向上找到E层的命名空间，找到了func标识符形参，指向了download()函数，执行download()函数 ... 可以看到，通过闭包函数完美的完成了需求。 优点： 极大的减少了代码冗余量 没有修改源函数内部代码 在没有改变了源函数的调用方式前提下，新增了计时的功能 缺点： 我们必须对源函数做1个包装，将它的标识符由指向源函数改为指向为包函数的返回值，即闭函数，每一个需要增加统计时长功能的函数都要添加这样的一行代码，即❶，❷处。 整个过程图示，注意查看全局命名空间的标识符指向改变： @语法糖 无参装饰器 针对闭包方案的缺点，我们可以使用@语法糖的形式来进行进一步改进。 @语法糖内部会做2件事情： 自动加括号执行@后面的函数名，并且将@下面的被装饰函数当做第1个参数传入（注意，这个自动调用仅调用一次，当嵌套层数过多时则不会自动调用） 自动将@下面的被装饰函数的标识符重新指向内层返回的闭函数 如下所示： import time import random def warpper(func): def inner(*args, **kwargs): startTime = time.time() res = func(*args, **kwargs) endTime = time.time() totalTime = endTime - startTime print(\"函数:{} 运行共花费时长:{}\".format(func.__name__, totalTime)) return res return inner @warpper # ❶ def download(fileName): time.sleep(random.randint(1, 3)) return \"下载文件{}完成\".format(fileName) @warpper def upload(fileName): time.sleep(random.randint(1, 3)) return \"下载文件{}完成\".format(fileName) downResult = download(\"testDownload.text\") # ❷ print(downResult) upResult = upload(\"testUpload.text\") print(upResult) ❶：Python解释器检查语法，发现函数头上有个@装饰器函数，开始做2件事情: 自动调用warpper()函数，并且将@下面被装饰函数download()当做参数传递给func参数 自动将@下面的被装饰函数的标识符download重新指向内层返回的闭函数inner ❷：此时执行的download()函数其实是inner()函数，inner()函数执行时发现要找func，L层命名空间没有func，则往定义自己的warpper()函数的E层命名空间找func，找到了func指向的是download()函数，然后执行并返回 为了验证上面的例子，我们可以打印一下download的__name__属性进行查看： @warpper def download(fileName): time.sleep(random.randint(1, 3)) return \"下载文件{}完成\".format(fileName) print(download.__name__) # inner 如果不加装饰器呢？ def download(fileName): time.sleep(random.randint(1, 3)) return \"下载文件{}完成\".format(fileName) print(download.__name__) # download @手动传参 @如果手动加括号会怎么样？它会将执行结果对象返回给被装饰器函数的标识符。 如下示例，首先是打印了int类型的帮助信息，然后返回了一个None，func指向了None，如果func加上括号进行调用，则会抛出异常： @help(int) def func(): print(\"func...\") # Help on class int in module builtins: # # class int(object) # | int(x=0) -> integer # | int(x, base=10) -> integer func() # TypeError: 'NoneType' object is not callable 有参装饰器 一个新的需求： 下载或时候如果用户是普通用户，则享用10M带宽，如果是VIP用户，则享用100M带宽 如果用@语法糖来解决这个问题，则需要在外部再嵌套一层函数： import time import random def outer(genre): def warpper(func): def inner(*args, **kwargs): if genre == \"VIP\": print(\"欢迎您，尊贵的VIP用户，您的下载速度是100M/s\") else: print(\"欢迎您，亲爱的普通用户，您的下载速度是10M/s\") startTime = time.time() res = func(*args, **kwargs) endTime = time.time() totalTime = endTime - startTime print(\"函数:{} 运行共花费时长:{}\".format(func.__name__, totalTime)) return res return inner return warpper @outer(genre=\"VIP\" if random.randint(1, 2) == 1 else \"common\") def download(fileName): time.sleep(random.randint(1, 3)) return \"下载文件{}完成\".format(fileName) downResult = download(\"testDownload.text\") print(downResult) 执行流程如下： 手动调用一次outer()函数，并且为genre传入参数，返回了warpper()函数。 此时会变成这个样子，由于手动在装饰器函数后面加了括号，所以本次的返回值会依然当做装饰器添加在头上，并不会改变download()： @warpper def download(fileName): pass 自动调用一次（仅一次）warpper()函数，并且将@下面被装饰函数download()当做参数传递给func参数 自动将@下面的被装饰函数的标识符download重新指向内层的inner()函数 此时执行的download()函数其实是inner()函数，然后根据命名空间查找特性，找到genre形参变量标识符与func形参函数标识符 @自动执行 Python中的@语法糖对闭包函数只会自动的执行1次，如下所示： def warpper(x): print(\"执行第1次，返回f1\") def f1(x): print(\"执行第2次，返回f2\") def f2(x): print(\"执行第3次，返回None\") return f2 return f1 @warpper def func(): ... # 执行第1次，返回f1 而我们手动的对@后的函数进行调用，则在1层自动执行的基础上又加上了1次手动执行： def warpper(x): print(\"执行第1次，返回f1\") def f1(x): print(\"执行第2次，返回f2\") def f2(x): print(\"执行第3次，返回None\") return f2 return f1 @warpper(\"x\") def func(): ... # 执行第1次，返回f1 这是手动执行的1次 # 执行第2次，返回f2 这是自动执行的1次 也就是说Python的@语法最大仅能支持3层嵌套定义的闭包函数，如果太深则里面的就拿不到了，因为你不能手动调用2次，这样会抛出语法错误： @warpper(\"x\")(\"c\") def func(): ... # SyntaxError: invalid syntax 多个装饰器 多个装饰器叠放的场景你今后肯定会遇见，只需要记住一句话即可： 定义顺序自下而上，执行顺序自上而下 如下所示： def f1(func): print(\"定义f1装饰器\") def inner(*args, **kwargs): print(\"执行f1装饰器\") func() return inner def f2(func): print(\"定义f2装饰器\") def inner(*args, **kwargs): print(\"执行f2装饰器\") func() return inner @f1 @f2 def func(): ... func() # 定义f2装饰器 # 定义f1装饰器 # 执行f1装饰器 # 执行f2装饰器 流程分析： # Python解释器执行到 @f1 时，想自动运行一下，发现下面被装饰的不是一个函数，就不自动运行了 # Python解释器执行到 @f2 时，想自动运行一下，发现下面被装饰的是一个函数，于是开始自动运行 # print(\"定义f2装饰器\") # 然后返回了 inner 函数，现在 func -> inner 函数，变成了这个样子 # # @f1 # def func(): # ... # # 然后，Python解释器发现 @f1 下面是一个函数了，于是开始自动运行 # print(\"定义f1装饰器\") # 然后又返回 inner 函数，现在 func -> 新的 inner 函数 # # Python解释器继续向下走，发现 func() # 由于 func -> 新的 inner 函数 故开始运行 f1的 inner 函数： # print(\"执行f1装饰器\") # 打印完成后又要执行 func() # 那么这里的 func 是旧的 inner 函数，故开始运行f2的 inner 函数： # print(\"执行f2装饰器\") @wraps分析 @wraps其实是functiontools中自带的一款有参装饰器，它能够做到很好的隐藏功能。 如，普通装饰器的标识符被改变指向为L层函数后，通过查看__name__还是会看到原本L层函数的名字： def warpper(func): def inner(*args, **kwargs): result = func() return result return inner @warpper def func(): ... print(func.__name__) # inner 如果对内层L函数加上@wraps后，就会将内层函数的大部分属性变为原本标识符所指向的被装饰函数，如下所示： from functools import wraps def warpper(func): @wraps(func) def inner(*args, **kwargs): result = func() return result return inner @warpper def func(): ... print(func.__name__) # func 这个仅是换了1个属性，实际上内存地址还是inner的，通过以下示例进行验证： from functools import wraps def warpper(func): @wraps(func) def inner(*args, **kwargs): result = func() return result print(\"内部打印 inner() 函数的内存地址\", id(inner)) return inner @warpper def func(): ... print(\"内部打印 func 所指向函数的内存地址\", id(func)) # 内部打印 inner() 函数的内存地址 4451701896 # 内部打印 func 所指向函数的内存地址 4451701896 装饰器模板 无参装饰器 from functools import wraps def warpper(func): @wraps(func) def inner(*args, **kwargs): # 开始前的逻辑 result = func() # 结束后的逻辑 return result return inner @warpper def func(): ... func() 有参装饰器 from functools import wraps def warpper(*args, **kwargs): def outer(func): @wraps(func) def inner(*args, **kwargs): # 参数的使用 # 开始前的逻辑 result = func() # 结束后的逻辑 return result return inner return outer @warpper(k1=\"v1\") def func(): ... func() Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-13 20:41:50 "},"Python/Python函数相关/迭代器.html":{"url":"Python/Python函数相关/迭代器.html","title":"迭代器","keywords":"","body":"迭代器 迭代是什么 迭代指的是一个重复的过程，每次重复都必须基于上一次的结果而继续，单纯的重复并不是迭代，如Python中的for循环就是一个非常好的迭代例子。 for item in range(10): print(item) 迭代必须向前推进，不能后退，如下所示： # [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] # ------------------------------> 下面这种方式就不属于迭代： # [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] # --------> # 迭代器协议 在学习迭代器的整个知识点中，迭代器协议占据了非常重要的位置。 迭代器协议中包含了2个最基本的概念，分别是可迭代对象和迭代器对象。 可迭代对象（Iterable）：内部实现了__iter__()方法的对象则被称为可迭代对象 迭代器对象（Iterator）：内部实现了__iter__()以及_next\\_()方法的对象则被称之为迭代器对象 两者之间的关系： 在Python中，迭代器对象一定属于可迭代对象范畴，也就说迭代器对象必须具有__iter__()方法以及__next__()方法 在Python中，可迭代对象不一定属于迭代器对象范畴，也就是说可迭代对象只需要实现__iter__()方法即可 介绍2个函数： iter(Object)函数，它底层会执行Object.__iter__()方法 next(Object)函数，它底层会执行Object.__next__()方法 内置类型 通过collections.abc下的Iterable类和Iterator类进行判定，可快速的判定出所有内置类型是否是一个可迭代对象或者迭代器对象： >>> from collections.abc import Iterable >>> from collections.abc import Iterator >>> isinstance(list(), Iterable) True >>> isinstance(list(), Iterator) False 经过测试，所有的容器类型（list、tuple、str、dict、set、frozenset）均属于可迭代对象，但不属于迭代器对象 原子类型（bool、int、float、None）等均不属于可迭代对象，更不属于迭代器对象。 也可以通过另一种方式进行验证，通过hasattr()函数，检查类中是否定义了某一个方法： >>> hasattr(list,\"__iter__\") True >>> hasattr(list,\"__next__\") False 迭代原理 当可迭代对象被for循环进行调用后，底层执行流程如下所示： 将自动的执行iter()方法，该方法内部会查找可迭代对象的__iter__()方法，如果具有该方法，则返回一个该可迭代对象的专属迭代器对象，如果没有该方法，则抛出TypeError object is not iterable的异常。 Ps：每次的for循环都会返回一个全新的迭代器对象 不断的调用迭代器对象的__next__()方法，并且返回迭代器对象中下一个数据项，当遍历完成整个迭代器后，引发Stopiteration异常终止迭代 Ps：迭代器本身并不存储任何数据项，存储的只是一个指针，该指针指向可迭代对象中真正存储的数据项，它指向当前被遍历到的数据项索引位置，下一次遍历则向后推进这个位置 for循环自动的捕捉Stopiteration异常，并且停止迭代 Ps:for循环底层就是while循环实现的，只不过多加了3个步骤： 第一步：执行可迭代对象的__iter()__方法并保存返回的专属迭代器 第二步：不断的执行迭代器的__next()__方法 第三步：捕获Stopiteration异常 我们手动的实现一个for循环： li1 = list(range(10)) iteratorObject = iter(li1) # ❶ while 1: try: print(next(iteratorObject)) # ❷ except StopIteration as e: # ❸ break ❶：执行可迭代对象的__iter__()方法并保存返回的专属迭代器 ❷：不断的执行迭代器的__next__()方法 ❸：捕获Stopiteration异常 线性可迭代对象与迭代器的实现 如果是一个线性容器的可迭代对象，那么它一定具有索引值，我们可以让它的__iter__()方法返回一个专属的迭代器对象。 然后专属迭代器对象中记录本次迭代遍历的索引值，根据这个索引值返回可迭代对象中的数据项，当索引值达到可迭代对象中数据项总个数-1的时候，抛出异常，本次迭代结束： class LinearTypeContainer: def __init__(self, array): if isinstance(array, list) or isinstance(array, tuple): self.array = array else: raise TypeError(\"argument array must is linear container\") def __iter__(self): return LinearContainer_iterator(self.array) # ❶ class LinearContainer_iterator: def __init__(self, array): self.index = 0 self.array = array self.len = len(self.array) def __next__(self): if self.index ❶：Python中的一切传参均为引用传递 故LinearTypeContainer中的self.array和LinearContainer_iterator的self.array都是一个对象，并不会额外开辟内存空间 这也就是为什么可迭代对象创建的专属迭代器不会消耗太多的内存空间原因了。 ❷：迭代器对象一定属于可迭代对象范畴，所以在这里我们为迭代器对象LinearContaineriterator类也新增了\\_iter__()方法 这样做的好处在于如果单独的拎出了这个迭代器对象，则它也会支持for循环的遍历： def __iter__(self): return self containerIterator = LinearTypeContainer([i for i in range(10)]).__iter__() for item in containerIterator: print(item) # 0 # 1 # 2 # 3 # 4 # 5 # 6 # 7 # 8 # 9 如果取消了linearContaineriterator类的这个\\_iter__()方法，则不支持for循环的遍历： # def __iter__(self): # return self containerIterator = LinearTypeContainer([i for i in range(10)]).__iter__() for item in containerIterator: print(item) # TypeError: 'LinearContainer_iterator' object is not iterable 非线性可迭代对象与迭代器实现 如果是一个非线性容器的可迭代对象，可以先判断它的类型，如果传入的容器是一个字典，则将迭代的数据项集合转换为元组，里面存储的全部是字典的key即可。 如果传入的容器是一个集合，则将迭代的数据项集合转换为元组，再参照线性可迭代对象与迭代器的实现。 具体实现： class MappingTypeContainer: def __init__(self, mapping): self.mapping = mapping if not ( isinstance(self.mapping, dict) or isinstance(self.mapping, set) or isinstance(self.mapping, frozenset) ): raise TypeError(\"argument mapping must is mapping container\") def __getattr__(self, name: str): try: return dict.__getattribute__(self.mapping, name) except AttributeError: return set.__getattribute__(self.mapping, name) def __str__(self): return str(self.mapping) def __iter__(self): return MappingContainer_iterator(tuple(self.mapping)) class MappingContainer_iterator: def __init__(self, array): self.index = 0 self.array = array self.len = len(self.array) def __next__(self): if self.index 迭代器对象的特性 每一次for循环创建出的可迭代对象的专属迭代器都是一次性的，用完后就没用了： ... # ❶ containerIterator = LinearTypeContainer([i for i in range(3)]).__iter__() for item in containerIterator: print(item) # 0 # 1 # 2 for item in containerIterator: print(item) # ❷ print(\"?\") ❶：直接拿出一个迭代器对象 ❷：在第2次循环中，迭代器对象中存储的索引值已经最大了，每次调用iter()都会抛出异常返回出来再被for处理，所以print()函数根本不会运行 迭代器对象并不存储可迭代对象中的真正迭代数据，而是仅存储长度和索引，所以内存的占用并不多： class LinearContainer_iterator: def __init__(self, array): self.index = 0 # ❶ self.array = array # ❷ self.len = len(self.array) # ❸ ... ❶：占用额外的内存空间 ❷：引用对象，并不开辟内存 ❸：占用额外的内存空间 惰性求值与及早求值 迭代器对象中对于返回的数据项，是进行实时演算的，这种实时演算的特性求值方式被称为惰性求值，即你需要的时候我算出来后再给你： def __next__(self): if self.index 除开惰性求值，还有一种及早求值的方案，即使你要1个，我也把所有的都给你。 如Python2中的range()、map()、filter()、dict.items()、dict.keys()、dict.values()，它们均返回的是一个纯粹的列表，这样的设计是不合理的，参见要命的问题③。 因为返回的列表会占用很大的内存空间，而Python3中则统一优化为惰性求值方案，即返回一个可迭代对象。 要命的问题 一个非常有趣的问题： Python中的所有自带容器类型为何不自己设置成迭代器？ 而是在for循环时实例出一个专属的迭代器？ 直接在这些自带类型的底层实现__next__()方法不好吗？ 这样岂不是更加减少了内存的消耗，少定义了类和实例化了类吗？ 答：这真是一个要命的问题，这个问题我也想过很久，最后是在stackoverflow提问并且获得了满意的答案才记录下来的。 因为它确实是可以实现的，如下所示，只需要在加上❶处代码即可： class LinearTypeContainer: def __init__(self, array): if isinstance(array, list) or isinstance(array, tuple): self.array = array else: raise TypeError(\"argument array must is Linear container\") self.index = 0 self.len = len(self.array) def __iter__(self): return self def __next__(self): if self.index 但是这样做在某种特殊情况下会出现问题： container = LinearTypeContainer(list(range(5))) for item in container: print(item) if container.index == 3: break print(\"*\"*20) for item in container: print(item) # 0 # 1 # 2 # ******************** # 3 # 4 你会发现如果第一次for循环到了1半的时候退出，第二次for循环会接着根据第一次for循环进行继续。 能够解决一下吗？只需要加上一个标志位即可： class LinearTypeContainer: def __init__(self, array): if isinstance(array, list) or isinstance(array, tuple): self.array = array else: raise TypeError(\"argument array must is Linear container\") self.index = 0 self.len = len(self.array) self.iter = False # ❶ def __iter__(self): if self.iter: # ❷ self.index = 0 self.iter = True return self def __next__(self): if self.index ❶：判断是不是一次新的调用 ❷：如果是新的调用，则将index重新置为0即可 那么为何Python不这样设计呢？我们应该更多的考虑多线程的情况下，多个for循环使用同一个迭代器它是否是线程安全的，上面的示例中这个共享迭代器并不是线程安全的，此外它也不支持嵌套循环，如下所示，这样会造成无限循环： container = LinearTypeContainer(list(range(5))) for item in container: print(item) for j in container: print(j) 综上各个方面的考虑，Python将内置的数据类型，都设置了在for循环时返回专属迭代器的做法，这是非常好的设计，但是对于有些内置的对象，则是将它本身做成了迭代器，如文件对象。 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-07-07 16:36:18 "},"Python/Python函数相关/生成器.html":{"url":"Python/Python函数相关/生成器.html","title":"生成器","keywords":"","body":"生成器 生成器（generator）是迭代器的一种特殊实现方式，有2种方式可以创建，一种是通过生成器函数创建，另一种是生成器表达式进行创建。 生成器继承了迭代器的一切优点，简而言之是迭代器的一种升级版本。 在前面的迭代器一章节中介绍过，如果要想获取一个迭代器，必须要先创建一个可迭代对象，然后调用其下的__iter__()方法才能拿到一个迭代器，这样做会产生一些问题，如下所示： 我们只想要一个迭代器，并不需要可迭代对象的前提下该怎么办 可迭代对象中的数据项会占据大量内存空间，如果要想获取1个含有1000万个数据项的列表迭代器，则必须先创建1个列表对象，再获取其专属的迭代器，虽然迭代器不耗费内存，但是可迭代对象必然耗费内存 而生成器则是简化了这种操作，只需要创建生成器函数就可以拿到一个单纯的迭代器。 如果要判断一个对象是否属于生成器，推荐使用collections.abc下的Generator进行判定： >>> from collections.abc import Generator >>> isinstance(list,Generator) False 生成器函数 如果一个函数中出现yield关键字，则它就是一个生成器函数，当一个生成器函数加括号进行调用时，并不会立即运行逻辑体代码，而是返回一个生成器对象。 当对这个生成器对象调用next()方法时，将启动该生成器对象，生成器对象开始执行函数逻辑体代码。 而在执行函数逻辑体代码时如果碰见yield则会发生2件事情： 返回yield后面的值，类似于return函数 挂起当前生成器函数的运行状态，而不是结束生成器函数的运行，也就是说这个生成器对象不会被销毁 再次对生成器对象调用next()方法时恢复暂停状态，继续上述流程进行运行。 一个简单的例子： def generatorFunction(): n = 3 while n: yield n n-=1 # return None ❶ # ❷ generatorObject = generatorFunction() print(generatorObject) # ❸ print(next(generatorObject)) print(next(generatorObject)) print(next(generatorObject)) # ❹ print(next(generatorObject)) # # 3 # 2 # 1 # StopIteration ❶：默认的函数返回值即为None，在Python3之前的较低版本中，return关键字和yield关键字不可以同时出现在一个函数中，但是目前已经取消了这种设定 ❷：生成器函数加括号，返回生成器对象 ❸：生成器对象调用next()方法，开始执行函数体代码 ❹：由next()方法抛出的StopIteration异常，并不是生成器对象抛出的 斐波拉契数列 下面的示例中将使用生成器函数获取斐波拉契数列中指定位数之前所有的数据项。 仅获取数据项，并不产生存储，因此使用生成器函数极为方便： def getFibPositionValue(n): count, currentValue, nextValue = 0, 0, 1 while count 而如果是要对斐波拉契数列本身进行存储，使用普通函数则更好一点： def createFibArray(n): fibArray = [] count, currentValue, nextValue = 0, 0, 1 while count 生成器表达式 生成器表达式类（generator expression）似于列表推导式，用于快速的创建一个生成器对象，使用()对表达式进行包裹： genObject = (i for i in range(3)) print(genObject) # at 0x10bed0db0> 如果外部已经拥有一个括号，则可以忽略这大括号，如将生成器对象转换为元组的完整写法如下： tup = tuple((i for i in range(3))) print(tup) # (0, 1, 2) 忽略括号： tup = tuple(i for i in range(3)) print(tup) # (0, 1, 2) send() close() 生成器的特性不仅如此，它还能够实现一种双向的生成器外部调用代码与生成器内部逻辑代码的信息交互功能。 因为yield不仅可以返回值，还可以接收值。 如下示例，外部通过send()方法发送的信息将被yield所接收，当整个生成器对象迭代完毕后，可以调用close()方法关闭这个生成器对象： def generatorFunction(): print(\"generator object run ...\") firstRecvExternal = yield 1 # ① print(firstRecvExternal) # 打印A secondRecvExternal = yield 2 # ② print(secondRecvExternal) # 打印B lastRecvExternal = yield 3 # ③ print(lastRecvExternal) # 打印C genObject = generatorFunction() # ❶：启动生成器对象，执行函数，运行至①处返回 1，并暂停 genStartResult = genObject.send(None) print(genStartResult) # 打印1 # ❷：继续运行生成器对象，发送了字符串A，被生成器①处的firstRecvExternal所接收到，并进行了一次打印 A # 直至运行至②处，返回结果2 genSecondSend = genObject.send(\"A\") print(genSecondSend) # 打印2 # ❸：继续运行生成器对象，发送了字符串B，被生成器②处的secondRecvExternal所接收到，并且进行了一次打印 B # 直至运行至③处，返回了结果3 genThirdSend = genObject.send(\"B\") print(genThirdSend) # 打印3 try: # 继续运行生成器函数，发送了字符串C，被生成器③处的lastRecvExternal所接收到，并且进行了一次打印 C # 然后再往下运行发现 return None，于是 __next__()函数抛出了 StopIteration 的异常，但是被这里处理了 genLastSend = genObject.send(\"C\") # StopIteration except StopIteration: # 处理异常，关闭生成器对象 genObject.close() # generator object run ... # 1 # A # 2 # B # 3 # C yield form 生成器函数加括号不会执行函数体内部代码，而是返回生成器对象，生成器对象的启动必须通过next()或者send(None)。 for循环底层会调用生成器对象的__next__()方法进行启动和向下运行，因此通过for循环来操纵生成器是十分方便的： def genFunction(): count = 0 while 1: if count ❶：首先将生成器函数转换为生成器对象，然后通过for不断的进行调用 如果是2个嵌套调用的生成器函数，外部嵌套生成器函数需要时刻yield子调用生成器函数的值，似乎用for循环来完成这个需求是最好的选择： def outer(): yield \"run outer...\" for item in inner(): # ❶ yield item def inner(): yield \"run inner 1 ...\" yield \"run innner 2 ...\" yield \"run inner 3 ...\" for item in outer(): print(item) # run outer... # run inner 1 ... # run innner 2 ... # run inner 3 ... ❶：首先将生成器函数转换为生成器对象，然后通过for不断的进行调用 在Python3.3版本之后，你有了新的选择，使用yield from关键字，yield from关键字必须定义在一个生成器函数之中，它将会自动的在底层运行for循环进行调用另一个生成器函数，并将另一个生成器函数的结果进行返回： def outer(): yield \"run outer...\" yield from inner() # ❶ def inner(): yield \"run inner 1 ...\" yield \"run innner 2 ...\" yield \"run inner 3 ...\" for item in outer(): print(item) # run outer... # run inner 1 ... # run innner 2 ... # run inner 3 ... ❶：yield from关键字底层就是for循环，所以这里的代码会更加的精简 yield from关键字后面必须跟上一个可迭代对象，如迭代器、生成器： def outer(): yield \"run outer...\" yield from range(3) for item in outer(): print(item) # run outer... # 0 # 1 # 2 生成器函数栈帧 生成器函数为什么能够挂起当前状态？普通函数为什么不可以？其实根本原因还是在栈帧上。 普通的函数栈帧组成图： 生成器函数栈帧组成图： 函数栈帧结构体 一个函数其实完整的栈帧是由很多部分组成的，参见CPython源码，感兴趣的可以研究一下： typedef struct _frame { PyObject_VAR_HEAD struct _frame *f_back; /* previous frame, or NULL */ PyCodeObject *f_code; /* code segment */ PyObject *f_builtins; /* builtin symbol table (PyDictObject) */ PyObject *f_globals; /* global symbol table (PyDictObject) */ PyObject *f_locals; /* local symbol table (any mapping) */ PyObject **f_valuestack; /* points after the last local */ /* Next free slot in f_valuestack. Frame creation sets to f_valuestack. Frame evaluation usually NULLs it, but a frame that yields sets it to the current stack top. */ PyObject **f_stacktop; PyObject *f_trace; /* Trace function */ char f_trace_lines; /* Emit per-line trace events? */ char f_trace_opcodes; /* Emit per-opcode trace events? */ /* Borrowed reference to a generator, or NULL */ PyObject *f_gen; int f_lasti; /* Last instruction if called */ /* Call PyFrame_GetLineNumber() instead of reading this field directly. As of 2.3 f_lineno is only valid when tracing is active (i.e. when f_trace is set). At other times we use PyCode_Addr2Line to calculate the line from the current bytecode index. */ int f_lineno; /* Current line number */ int f_iblock; /* index in f_blockstack */ char f_executing; /* whether the frame is still executing */ PyTryBlock f_blockstack[CO_MAXBLOCKS]; /* for try and loop blocks */ PyObject *f_localsplus[1]; /* locals+stack, dynamically sized */ } PyFrameObject; 本章总结 这一章可以说及其重要，Python的协程编程中本章知识是绝对的核心基础，只有理解了生成器才用可能理解协程。 还是以问答形式进行记录吧： ①：生成器和迭代器有什么不同？ 答：生成器就是迭代器的另一种实现，普通的迭代器必须通过iter()函数进行创建，也就是说普通的迭代器必须依赖可迭代对象才能够创建出来，但是可迭代对象会占用大量内存，所以产生了生成器，即不通过可迭代对象就能拿到的迭代器。 ②：yield form的作用？ 答：yield form只能定义在一个生成器函数中，该生成器函数内部如果嵌套调用了另一个生成器函数时就可以使用yield form进行另一个生成器函数的调用，它底层会自动经过for循环对另一个生成器对象进行操纵，且将值返回给最外部。 ③：生成器函数和普通函数有什么不同？ 答：生成器函数加括号得到生成器对象，生成器对象调用其下__next__()方法才会执行函数体代码。而普通函数加括号直接执行函数体代码。 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-13 20:41:50 "},"Python/Python模块与包/summary.html":{"url":"Python/Python模块与包/summary.html","title":"Python模块与包","keywords":"","body":" 目录规范 Python模块 Python包 内置模块：time 内置模块：datetime 内置模块：random 内置模块：os 内置模块：sys 内置模块：json&pickle&shelve 内置模块：hashlib 内置模块：configparser 内置模块：subprocess 内置模块：logging 内置模块：re 内置模块：importlib 内置模块：collections 内置模块：itertools 内置模块：functools 模块包库框架的区别 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-13 20:41:50 "},"Python/Python模块与包/目录规范.html":{"url":"Python/Python模块与包/目录规范.html","title":"目录规范","keywords":"","body":"目录规范 为了提高程序的可读性与可维护性，我们应该为软件设计良好的目录结构，这与规范的编码风格同等重要。 软件的目录规范并无硬性标准，只要清晰可读即可。 但是有一些规范还是十分合理的，我们应当予以遵守： 目录层次不超过5层 目录尽量以复数形式命名，如imgs而不是img 目录命名尽量清晰易懂 目录说明 bin 目录级别：一级目录 目录作用：通常用于存放项目启动脚本 其他命名：暂无 注意事项：如果拥有此目录，则启动脚本需要考虑模块导入路径的问题 core 目录级别：一级目录 目录作用：存放主程序、业务逻辑源代码 其他命名：src 注意事项：可根据不同的子业务继续划分二级目录 api 目录级别：一级目录 目录作用：通常用于存放项目接口文件，使得项目能够在启动后和外部通信 其他命名：interface 注意事项：可根据不同的子业务需要继续划分二级目录 db 目录级别：一级目录 目录作用：存放操作数据库相关文件，主要用于与数据库交互 其他命名：暂无 注意事项：暂无 lib 目录级别：一级目录 目录作用：存放程序中常用的自定义模块 其他命名：暂无 注意事项：暂无 conf 目录级别：一级目录 目录作用：存放项目所需要的配置文件 其他命名：config 注意事项：暂无 logs 目录级别：一级目录 目录作用：存放项目运行时所产生的日志文件 其他命名：暂无 注意事项：暂无 docs 目录级别：一级目录 目录作用：存放项目的详细说明文档 其他命名：暂无 注意事项：暂无 plugins 目录级别：一级目录 目录作用：存放项目中所需要的第三方插件 其他命名：utils、tools、helpers 注意事项：暂无 common 目录级别：一级目录 目录作用：存放项目中大部分需求都能使用到的功能，相当于公共插件 其他命名：暂无 注意事项：暂无 test 目录级别：一级目录 目录作用：存放项目测试代码 其他命名：暂无 注意事项：暂无 static 目录级别：一级目录 目录作用：存放项目中所需要的静态文件 其他命名：暂无 注意事项：暂无 views 目录级别：一级目录 目录作用：存放项目中所需要的模板文件，MVC模型中的视图 其他命名：templates 注意事项：暂无 controller 目录级别：一级目录 目录作用：存放项目中的主流算法，MVC模型中的控制 其他命名：暂无 注意事项：暂无 models 目录级别：一级目录 目录作用：存放项目中与数据库打交道的脚本，MVC模型中的模型 其他命名：暂无 注意事项：暂无 文件说明 run.py 文件位置：项目根目录下，或者bin目录下 文件作用：项目的启动脚本 其他命名：start.py 注意事项：如果启动脚本是在bin目录下，则需要考虑sys.path setup.py 文件位置：项目根目录下 文件作用：安装、部署、打包的脚本，一键安装所需要的所有依赖环境 其他命名：暂无 注意事项：暂无 一般来说，用setup.py来管理代码的打包、安装、部署问题。业界标准的写法是用Python流行的打包工具setuptools来管理这些事情，这种方式普遍应用于开源项目中。 不过这里的核心思想不是用标准化的工具来解决这些问题，而是说，一个项目一定要有一个安装部署工具，能快速便捷的在一台新机器上将环境装好、代码部署好和将程序运行起来。 settings.py 文件位置：conf文件夹下 文件作用：项目配置文件 其他命名：有的是py脚本，后缀就是.py，而有的是.ini 、.conf、.yaml等 注意事项：暂无 requirements.txt 文件位置：项目根目录下 文件作用：存放所有项目第三方依赖库、模块的名字及版本 其他命名：暂无 注意事项：这个一般都是用第三方模块生成的 　requirements.txt文件的存在是为了方便开发者维护软件的依赖库。我们需要将开发过程中依赖库的信息添加进该文件中，避免在 setup.py安装依赖时漏掉软件包，同时也方便了使用者明确项目引用了哪些Python包。 README.md 文件位置：项目根目录下 文件作用：项目整体描述信息，设计思路，设计目标等 其他命名：暂无 注意事项：暂无 关于README.me的内容，这个应该是每个项目都应该有的一个文件，目的是能简要描述该项目的信息，让读者快速了解这个项目。它需要说明以下几个事项: 软件定位，软件的基本功能； 运行代码的方法: 安装环境、启动命令等； 简要的使用说明； 代码目录结构说明，更详细点可以说明软件的基本原理； 常见问题说明。 其他文件 CHANGELOG.md ：描述项目每个版本的更新信息，说明版本号、更新内容、修复了哪些问题等 humans.txt ：保存网站信息和网站建设者信息 ，格式规范参考官网http://humanstxt.org/ LICENSE.txt：项目基于的许可协议 robots.txt：规定爬虫程序能够获取本网站的那些信息 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-13 20:41:50 "},"Python/Python模块与包/Python模块.html":{"url":"Python/Python模块与包/Python模块.html","title":"Python模块","keywords":"","body":"Python模块 Python中的模块是一系列功能的集合体，总计可分为3大类： 内置模块：Python自带的一些内置库，开箱即用 第三方模块：通过pip命令下载到的模块，无需自己定义，Python拥有海量的第三方模块 自定义模块：一个.py文件就是一个模块，所以自己编写的.py文件也可以当做模块使用，例如文件名为m.py的文件就是一个名为m的自定义模块 自定义模块 自定义模块即自己写的模块，好处如下： 将相同功能的代码进行分类 降低代码耦合度，减少代码冗余 使整个程序组织结构更清晰，便于后期维护 结构分类 由于一个.py文件即为一个模块，故我们可以创建2个.py文件，一个当做程序入口文件，一个当做功能模块文件，以下是结构图： . ├── m1.py # 功能模块文件 └── run.py # 程序入口文件 首先在m1.py中写一个基本的函数： # m1.py print(\"this is module m1\") def add(x, y): return x + y 其次是在run.py中写上一个打印语句： # run.py print(\"run ..\") import简单使用 如果run.py中想要使用到m1.py中的add()函数，该怎么做？ 只需要在run.py中导入m1.py里定义的add()函数即可，注意在使用时也必须按m1开头才行： # run.py import m1 # ❶ print(\"run ..\") result = m1.add(1, 2) # ❷ print(result) # this is module m1 # run .. # 3 ❶：当解释器发现import m1时，会查找m1.py文件，并且会执行m1.py中的所有代码，所以下面会打印出 this is module m1的字样 ❷：使用了m1中的add()函数 针对❶，提出一个问题，如果导入多次这个m1文件，是否也会执行多次其中的代码呢？ 结果是否，也就是说只有第一次导入模块时，才会执行模块中的代码，多次导入只执行一次，其根本原因参照Python模块查找一节。 # run.py import m1 import m1 import m1 print(\"run ..\") result = m1.add(1, 2) print(result) # this is module m1 ❶ # run .. # 3 模块命名空间 现在我们有2个模块文件： . ├── m1.py ├── m2.py └── run.py 且2个模块文件中的代码都大部分相似： # m1.py print(\"this is module m1\") def add(x, y): return x + y # m2.py print(\"this is module m2\") def add(x, y): return x + y 在run中导入2个模块，且分别使用其下的add()函数时，内部发生了什么事情？ # run.py import m1 import m2 print(\"run ..\") resultM1 = m1.add(1, 2) resultM2 = m2.add(1, 2) print(resultM1) print(resultM2) # this is module m1 # this is module m2 # run .. # 3 # 3 run.py执行时，会按照import的顺序执行m1.py和m2.py文件中的代码 当m1，m2执行完成之后，会产生一个模块的命名空间 run.py的全局命名空间中将产生2个标识符，分别指向了m1.py和m2.py的模块命名空间 模块命名空间如下所示： 当要使用m1.add()时，则run.py通过全局命名空间中的标识符m1，去m1模块的命名空间中查找函数标识符add。 当要使用m2.add()时，则run.py通过全局命名空间中的标识符m2，去m2模块的命名空间中查找函数标识符add。 __name__与__main__ 当一个模块编写完成后，将要对其进行测试工作，确保代码无误才能投入使用。 如下，m1的测试代码写上： # m1.py print(\"this is module m1\") def add(x, y): return x + y # test print(add(1, 2)) 测试没问题后，run.py中对其进行功能引用： # run.py import m1 import m2 print(\"run ..\") resultM1 = m1.add(1, 2) resultM2 = m2.add(1, 2) print(resultM1) print(resultM2) # this is module m1 # 3 ❶ # this is module m2 # run .. # 3 当运行run.py后，会发现1处多打印了个3，这是因为在执行m1模块时，也将测试代码给执行了。 如何避免这种问题？我们可以在m1.py中加上一个判断语句： # m1.py print(\"this is module m1\") def add(x, y): return x + y # test if __name__ == \"__main__\": # ❶ print(add(1, 2)) ❶：__name__：如果该.py文件当做脚本被执行，则该变量为__main__，如果该.py文件当做模块导入被执行，则该变量为.py文件的名字，如m1.py就是m1 所以说，加入这条测试语句的目的在于，.py文件在不同的方式使用时可以执行不同的代码： 当做脚本被执行时，会运行测试代码 当做模块被导入时，不会运行测试代码 模块导入 import .. import语句的使用方式： import 模块名 导入的最小单元是模块 使用import导入模块的优缺点： 优点：不会和当前的全局命名空间标识符产生冲突 缺点：在使用模块功能时必须加上import右边的标识符前缀 如下所示，2个不同模块的相同标识符函数并不会产生冲突： import time import datetime print(time.time()) print(datetime.time()) # 1621665686.779634 # 00:00:00 也可以一行导入多个模块，使用逗号进行分割： import time, datetime from .. import .. from语句的使用方式： from 模块名 import 标识符 导入的最小单元是具体功能 使用from语句导入模块的优缺点： 优点：在使用模块功能时必须加上import右边的标识符前缀，如果直接导入了一个具体功能，则不用加前缀 缺点：容易和当前的全局命名空间标识符产生冲突 如下示例，由于datetime模块后导入，所以它的time函数标识符替代了time模块的time函数标识符： from time import time from datetime import time print(time()) print(time()) # 00:00:00 # 00:00:00 也可以在一行导入同一模块下的多个功能，以逗号进行分割： from time import time, sleep, ctime 别名的使用 使用as语句来为冲突的标识符取一个别名： from time import time as ttime from datetime import time as dtime print(ttime()) print(dtime()) # 1621665953.605452 # 00:00:00 *与__all__ 使用from 模块名 import *的方式，可以导入该模块下的所有标识符。 如果你是该模块的开发者，则可以通过__all__属性规定这种导入方式允许哪些标识符被导入。 在__all__中的标识符，可以被from 模块名 import *的方式进行导入 未在__all__中的标识符，不会被from 模块名 import *的方式进行导入 如果未定义__all__属性，则所有的标识符都会from 模块名 import *的方式进行导入 如下，在m1.py模块文件中，定义了1个getMax()的接口暴露函数，此外还有1个内部处理函数computeMax()以及模块说明变量desc： # m1.py def getMax(iterable): currentMax = None for index, item in enumerate(iterable): if index == 0: currentMax = computeMax(item, iterable[index + 1]) elif currentMax != item: currentMax = computeMax(currentMax, item) return currentMax def computeMax(x, y): return x if x > y else y desc = \"this is module m1\" __all__ = (\"getMax\", \"desc\") # ❶ ❶：__all__的格式必须是Tuple(str, str) 现在run.py中如果使用from m1 import *，则会将__all__中的所有标识符进行导入，下面示例中由于使用了未在__all__中定义的标识符，则抛出NameError的异常： # run.py from m1 import * print(getMax) print(desc) print(computeMax) # # this is module m1 # NameError: name 'computeMax' is not defined 循环导入问题 模块a中导入模块b，模块b中又导入了模块a，且导入语句都在首行，此时将引发循环导入的问题。 示例如下： # run.py import m1 print(m1.desc) # m1.py import m2 desc = \"this is module m1\" print(m2.desc) # m2.py import m1 desc = \"this is module m2\" print(m1.desc) 运行run.py，结果如下： AttributeError: module 'm2' has no attribute 'desc' 异常原因在于： run.py首行导入了m1，m1首行导入了m2，m2首行又导入了m1，导致m1.desc未能成功进行对象声明，故抛出异常。 执行步骤： run.py：import m1 (将m1加载至内存中) m1.py：import m2 (将m2加载至内存中) m2.py：import m1 (m1已经执行了，不重复执行了) m2.py：desc = \"this is module m2” m2.py：print(m1.desc)）(m1.desc没有进行对象声明，抛出异常) 解决办法： 将m1导入m2的语句放在行尾 将m1导入m2的语句放入函数中，并在行尾执行函数 办法1： # m1.py desc = \"this is module m1\" import m2 print(m2.desc) 办法2： desc = \"this is module m1\" def importFunction(): import m2 print(m2.desc) importFunction() 模块查找 查找优先级 无论是from .. import ..语句还是import语句，在导入模块时都会涉及到模块位置查找的问题。 模块查找优先级如下： 先查找内存 后查找硬盘 当一个模块被导入过一次后，就会加载至内存中，重复导入便可直接从内存中拿到该模块，而存在于内存中的模块代码是不会被执行的。 sys.modules sys.modules用于查看存在于内存中的模块，如果要导入的模块存在于这里面，就直接进行导入，而不执行其中的代码： >>> import sys >>> sys.modules ... 当一个存在于硬盘之上的模块被导入时，则会将该模块加载至内存中，只要是存在于内存中的模块，重复导入时就不会执行其中的代码了。 如下示例，第一次导入存在于硬盘之上的m1模块后，它被加载至了内存中： >>> tuple(sys.modules.items())[-1] ('rlcompleter', ) >>> import m1 >>> tuple(sys.modules.items())[-1] (('m1', )) Ps：其实当Python解释器启动时，会自动的运行一遍所有的内置模块并加载至内存中，因为这些内置模块也是存放在磁盘下的，你可以在Python解释器安装根目录的lib目录下找到它们。 sys.path 当内存中没有模块路径时，将按照sys.path的路径顺序依次在磁盘中查找。 如果在PyCharm下打印sys.path，它会做一些优化处理，比原生的REPL环境多出一些查找路径，下面使用#号进行标注： [ # '/Users/yunya/PycharmProjects/Project', # '/Users/yunya/PycharmProjects/Project', # '/Applications/PyCharm.app/Contents/plugins/python/helpers/pycharm_display', '/Library/Frameworks/Python.framework/Versions/3.6/lib/python36.zip', '/Library/Frameworks/Python.framework/Versions/3.6/lib/python3.6', '/Library/Frameworks/Python.framework/Versions/3.6/lib/python3.6/lib-dynload', '/Users/yunya/Library/Python/3.6/lib/python/site-packages', '/Library/Frameworks/Python.framework/Versions/3.6/lib/python3.6/site-packages', # '/Applications/PyCharm.app/Contents/plugins/python/helpers/pycharm_matplotlib_backend' ] 原生的REPL环境打印： >>> import sys >>> sys.path [ '', '/Library/Frameworks/Python.framework/Versions/3.6/lib/python36.zip', '/Library/Frameworks/Python.framework/Versions/3.6/lib/python3.6', '/Library/Frameworks/Python.framework/Versions/3.6/lib/python3.6/lib-dynload', '/Users/yunya/Library/Python/3.6/lib/python/site-packages', '/Library/Frameworks/Python.framework/Versions/3.6/lib/python3.6/site-packages' ] >>> 模块导入规范 导入模块时要遵循的一些规范： 导入顺序：内置模块在最上面，第三方模块在中间，自定义模块在下面 自定义模块名风格：蛇形式命名 Ps：Python2中有些模块是驼峰式命名，但是在Python3中都更改为蛇形式命名了，如PyMySQL，更名为pymysql 此外，模块也是一等公民，运行被赋值、传参等等。 模块编写规范 如果要编写自定义模块，也需要遵循一些规范： 首行添加模块文档描述，让别人知道你的模块是干嘛的 减少全局变量的使用，这样在第一次导入模块时会加快导入速度 模块中的类、函数等都需要写好注释 使用 if __name__ == “__main__”:的语句写好测试案例 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-13 20:41:50 "},"Python/Python模块与包/Python包.html":{"url":"Python/Python模块与包/Python包.html","title":"Python包","keywords":"","body":"Python包 包是一个含有__init__.py的文件夹（Python2中必须拥有，Python3中可以省略）。 包的基础单元是模块，当然一个包中也可以包含其他的包，是一组模块的集合。 包的导入 当导入一个包时，将会先执行包下__init__.py文件，于此同时会产生一个包的命名空间。 而在__init__中定义的标识符都会丢入到这个命名空间中。 现在，我们定义了一个包： ├── package # 顶级包 │ ├── __init__.py │ ├── sub1 # 子级包 │ │ ├── __init__.py │ │ └── m1.py # 含有add()函数 │ └── sub2 # 子级包 │ ├── __init__.py │ └── m2.py # 含有multiplication()函数 └── run.py # 启动文件 产生2个问题： 作为包的使用者而言，run.py如何调用到包中的某一个功能呢？ 作为包的开发者而言，包中任意一个模块，如何调用到另一个模块中的功能？ 外部导入 外部导入时，只能通过绝对路径来进行导入，如： # run.py from package.sub1.m1 import add 但如果package的__init__文件中，定义了add的路径，如： # package/__init__.py from package.sub1.m1 import add 则在外部可以省略绝对导入，直接通过package拿到add()函数： # run.py from package import add 这是因为顶级包package的命名空间中，已经有了add()函数的具体指向，所以外部的导入可以简写。 内部导入 内部导入分为绝对导入和相对导入两种。 绝对导入，必须以顶级包作为起始，如我想在m2.py文件中调用m1.py文件中的功能： # package/sub2/m2.py from package.sub1.m1 import add 相对导入是通过1个点和2个点来进行区分，1个点代指当前目录，2个点代指上层目录，如果在m2.py用相对导入调用m1.py文件中的功能，则代码如下所示： # package/sub2/m2.py from ..sub1.m1 import add 导入的约束 外部导入时，如果顶级包__init__.py文件中没有定义某一个功能的具体指向，你只能通过绝对导入的方式。 内部导入时，可以使用绝对导入和相对导入2种方式，个人更喜欢相对导入。 其次，在导包时一定要注意，不论是import还是from语法，.点的左边只能是一个包或者子模块（相对导入除外，.点的左边可以为空），如下所示： # run.py from package.sub1.m1 import add 顶级包 子级包 子模块 使用时没有这种限制，只需要记住使用时必须带上import语句后所有的标识符即可： # 导入时 from package import sub1 # 使用时 sub1.m1.add(1, 2) # 导入时 from package.sub1 import m1 # 使用时 m1.add(1, 2) 包的开发者 做为一名包的开发者，你需要尽可能的方便包的使用者。 多在__init__.py文件中写入子模块、功能的指向。 写好注释，测试用例。 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-13 20:41:50 "},"Python/Python模块与包/time.html":{"url":"Python/Python模块与包/time.html","title":"内置模块：time","keywords":"","body":"time简介 time模块是Python自带的模块，提供了时间的访问和转换功能。 官方文档 time模块中，对时间的表示包含3个概念： 时间戳形式：从1970.1.1 08:00:00（Unix纪元）开始到现在所经历的毫秒数，它int类型 结构化形式：以元组包裹的形式进行时间的展示，它tuple类型 字符串形式：以字符串的形式进行时间的展示，它是str类型 3种表示时间的方式之间可以互相转换，如下图所示： 时间获取 获取时间的方法： 方法 描述 表现形式 time.time() 获取时间戳形式的时间 时间戳 time.localtime() 获取结构化的本地时间 结构化 time.gmtime() 获取结构化的世界时间 结构化 time.asctime() 获取字符串形式的本地时间 字符串 time.ctime() 获取字符串形式的世界时间 字符串 time.strftime() 获取自定义格式的本地时间 字符串 Ps：本地时间在中国以东八区，上海时间时间为准，和世界时间（UTC）差了8小时 示例演示： >>> import time >>> time.time() 1621693706.0193129 >>> time.localtime() time.struct_time(tm_year=2021, tm_mon=5, tm_mday=22, tm_hour=22, tm_min=28, tm_sec=43, tm_wday=5, tm_yday=142, tm_isdst=0) >>> time.gmtime() time.struct_time(tm_year=2021, tm_mon=5, tm_mday=22, tm_hour=14, tm_min=29, tm_sec=0, tm_wday=5, tm_yday=142, tm_isdst=0) >>> time.asctime() 'Sat May 22 22:29:05 2021' >>> time.ctime() 'Sat May 22 22:29:09 2021' >>> time.strftime(\"%Y-%m-%d %H:%M:%S\") '2021-05-22 22:29:45' 结构化时间说明 在time.localtime()和time.gmtime()中，可以看到元组中有很多看不懂的数据项属性组成，它们的释义如下： 属性 描述 tm_year 年 tm_mon 月 tm_mday 日 tm_ hour 时 tm_min 分 tm_sec 秒 tm_wday 星期几，从0开始计算，一周就是0-6 tm_yday 该年份的第几天 tm_isdst 夏令营时间 这些属性都可以单独的提取出来，如获取这一年的年、月、日： >>> time.localtime().tm_year 2021 >>> time.localtime().tm_mon 5 >>> time.localtime().tm_mday 22 time.strftime() 放入一段字符串，将时间格式化出来，如下所示： >>> time.strftime(\"%Y-%m-%d %H:%M:%S\") '2021-05-22 22:29:45' %Y-%m%d这些都代表格式化时间的占位符，分别代表年月日等信息。 如下表所示： 符号 描述 %Y 格式化年份 %m 格式化月份 %d 格式化天数 %H 格式化小时 %M 格式化分钟 %S 格式化秒数 %X 等同于 “%H:%M:%S” 如想了解更多，参照官网示例截图： %accordion%点我查看%accordion% %/accordion% 时间转换 转换方法 以下是时间表现形式互相转换的方法： 方法 描述 time.mktime() 放入结构化时间，转换为时间戳时间 time.strftime() 放入结构化时间，转换为字符串时间 time.strptime() 放入字符串时间，转换为结构化时间 time.localtime() 放入时间戳时间，转换为结构化的本地时间 time.gmtime() 放入时间戳时间，转换为结构化的世界时间 示例演示： >>> time.mktime(time.localtime()) 1621694964.0 >>> time.strftime(\"%Y-%m-%d %X\", time.gmtime()) '2021-05-22 14:50:01' >>> time.strptime(time.ctime()) time.struct_time(tm_year=2021, tm_mon=5, tm_mday=22, tm_hour=22, tm_min=50, tm_sec=15, tm_wday=5, tm_yday=142, tm_isdst=-1) >>> time.localtime(time.time()) time.struct_time(tm_year=2021, tm_mon=5, tm_mday=22, tm_hour=22, tm_min=50, tm_sec=33, tm_wday=5, tm_yday=142, tm_isdst=0) >>> time.gmtime(time.time()) time.struct_time(tm_year=2021, tm_mon=5, tm_mday=22, tm_hour=14, tm_min=51, tm_sec=4, tm_wday=5, tm_yday=142, tm_isdst=0) 常用操作 将时间戳转换为固定的UTC时间字符串格式： >>> time.ctime(00) 'Thu Jan 1 08:00:00 1970' 将时间戳转换为本地时间的字符串表现形式： >>> t = 1293495903 # 有一个时间戳 >>> stuct = time.localtime(t) # 先将其转为本地的结构化时间 >>> stringTime = time.strftime(\"%Y-%m-%d %X\", stuct) # 再将其转换为字符串时间 >>> stringTime '2010-12-28 08:25:03' 将时间戳转换为世界时间的字符串表现形式： >>> t = 1293495903 # 有一个时间戳 >>> stuct = time.gmtime(t) # 先将其转为世界的结构化时间 >>> stringTime = time.strftime(\"%Y-%m-%d %X\", stuct) # 再将其转换为字符串时间 >>> stringTime '2010-12-28 00:25:03' 将一个字符串时间转换为时间戳： >>> stringTime = \"1998-01-26 00:00:10\" # 有一个字符串时间 >>> stuct = time.strptime(stringTime, \"%Y-%m-%d %X\") # 先将其转换为结构化时间 >>> stamp = time.mktime(stuct) # 再将其转换为时间戳 >>> stamp 885744010.0 线程睡眠 通过time.sleep()方法，可指定主线程睡眠多少秒，如下所示，第2个print()将在2秒后运行： import time print(\"start\") time.sleep(2) print(\"end\") 其他操作 日期判断 根据时间戳，获取7天后的时间： >>> currentTime = time.time() >>> sum7dayTime = currentTime + 7 * 86400 >>> time.strftime(\"%Y-%m-%d\", time.localtime(sum7dayTime)) '2021-05-29' 根据时间戳，获取3天前的时间： >>> currentTime = time.time() >>> sub3dayTime = currentTime - 3 * 86400 >>> time.strftime(\"%Y-%m-%d\", time.localtime(sub3dayTime)) '2021-05-19' 如果是时间戳操作，谨记1天是86400秒即可。 定时任务 脚本启动后，每隔一分钟，向屏幕打印一次hello world： import time currentSec = time.localtime().tm_sec while 1: if time.localtime().tm_sec == currentSec: print(\"hello world\") time.sleep(1) 延时任务 脚本启动后的一分钟时，打印一次hello world： import time currentTime = time.time() runTime = currentTime + 60 while 1: if time.time() == runTime: print(\"hello world\") break print(\"任务执行完毕\") Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-13 20:41:50 "},"Python/Python模块与包/datetime.html":{"url":"Python/Python模块与包/datetime.html","title":"内置模块：datetime","keywords":"","body":"datetime简介 datetime模块是Python内置模块，相比于time模块能够更加方便的操纵时间。 官方文档 以下举例部分常用方法： 方法 描述 datetime.datetime() 实例化返回一个datetime的对象 datetime.datetime.now() 获取本地时间，返回一个datetime的对象 datetime.datetime.utcnow() 获取世界时间，返回一个datetime的对象 datetime.datetime.fromtimestamp() 放入时间戳时间，直接转换为本地的datetime对象时间 datetime.datetime.utcfromtimestamp() 放入时间戳时间，直接转换为世界的的datetime对象时间 datetime.timedelta() 在一个datetime对象时间的基础上进行加减，返回一个新的datetime的对象 datetime.datetime.weekday() 放入一个datetime对象，获取该对象是那一周的第几天，从0开始计算，一周就是0-6 对象获取 datetime.datetime.now()和datetime.datetime.utcnow()都可以获取一个表示当前时间的datetime对象。 >>> import datetime >>> datetime.datetime.now() datetime.datetime(2021, 5, 22, 23, 31, 43, 468077) >>> datetime.datetime.utcnow() datetime.datetime(2021, 5, 22, 15, 31, 52, 841214) 为datetime.datetime.fromtimestamp()放入一个时间戳可直接获取到表示本地时间的datetime的对象： >>> datetime.datetime.fromtimestamp(11111) datetime.date(1970, 1, 1) >>> datetime.datetime.utcfromtimestamp(11111) datetime.datetime(1970, 1, 1, 3, 5, 11) datetime对象是str类型的更高一级封装，你可以将datetime对象转换为str类型： >>> str(datetime.datetime.now()) '2021-05-23 00:06:03.271989' 对象属性 一个datetime对象拥有很多时间属性，如下表所示： 属性 描述 year 年份（int） month 月份（int） day 天数（int） hour 时数（int） minute 分数（int） second 秒数（int） microsecond 毫秒数（int） 你可以快速的获取它们： >>> currentTime = datetime.datetime.now() >>> currentTime.year 2021 >>> currentTime.month 5 >>> currentTime.day 22 >>> currentTime.hour 23 >>> currentTime.minute 48 >>> currentTime.second 52 >>> currentTime.microsecond 527012 对象方法 一个datetime对象拥有很多方法，如下表所示： 方法 描述 datetimeObject.timestamp() 返回一个时间戳，不同于time模块的时间戳，该方法返回的是一个float类型 datetimeObject.timetuple() 返回与time.localtime()兼容的本地时间元组 datetimeObject.utctimetuple() 返回与time.gmtime()兼容的UTC时间元组 datetimeObject.ctime() 返回ctime()样式字符串 datetimeObject.isoformat() 根据ISO格式返回时间字符串 datetimeObject.strptime() 类似于time.strptime() datetimeObject.tzname() 返回时区名字 datetimeObject.replace() 替换一个字符串格式的时间中某部分，返回一个新的datetime的对象 由于这些方法使用的时候并不多，所以只举例一个时间替换。 将当前时间的年份替换为1998年： >>> currentTime = datetime.datetime.now() >>> currentTime.replace(year=1998) datetime.datetime(1998, 5, 23, 0, 22, 24, 698922) 时间加减 datetime对象允许通过和datetime.timedelta()进行加减，以便进行时间的计算。 时间加减中不支持年份的计算，可以用365天代替 当前时间加3天： >>> sum3dayTime = datetime.timedelta(+3) + currentTime >>> sum3dayTime datetime.datetime(2021, 5, 26, 0, 15, 15, 405378) 当前时间-3天： >>> sub3dayTime = datetime.timedelta(-3) + currentTime >>> sub3dayTime datetime.datetime(2021, 5, 20, 0, 15, 15, 405378) 当前时间加3小时： >>> sum3hours = datetime.timedelta(hours=+3) + currentTime >>> sum3hours datetime.datetime(2021, 5, 23, 3, 15, 15, 405378) 当前时间减3小时： >>> sub3hours = datetime.timedelta(hours=-3) + currentTime >>> sub3hours datetime.datetime(2021, 5, 22, 21, 15, 15, 405378) Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-13 20:41:50 "},"Python/Python模块与包/random.html":{"url":"Python/Python模块与包/random.html","title":"内置模块：random","keywords":"","body":"random简介 random模块是Python自带的模块，该模块实现了各种分布的伪随机数生成器。 官方文档 以下举例部分常用方法： 方法 描述 random.randint(1, 3) 从1-3之间随机生成一个整数 random.randrange(1, 3) 从1-2之间随机生成一个整数 random.random() 生成大于0且小于1的浮点数 random.uniform(1, 3) 生成大于1且小于3的浮点数 random.choice(seq) 从序列中随机取出1个数据项 random.sample(seq, 2) 从序列中随机取出指定个数据项，这里是2，以列表形式返回 random.shuffle(seq) 将传入的拥有索引的序列进行打乱，原地打乱，不返回新序列 整数生成 random.randint()是顾头顾尾的生成随机整数： >>> import random >>> random.randint(1, 3) 1 >>> random.randint(1, 3) 2 >>> random.randint(1, 3) 3 random.randrange()是顾头不顾尾的生成随机整数： >>> random.randrange(1, 3) 1 >>> random.randrange(1, 3) 2 浮点数生成 random.random()生成浮点数的范围总是介于0和1之间： >>> random.random() 0.818462343335113 random.uniform()可指定生成浮点数的范围： >>> random.uniform(1, 3) 2.810443694822667 数据项抽取 random.choice()可以从一个序列中随机抽取出一个数据项： >>> random.choice(range(10)) 1 random.sample()可以从一个序列中随机抽取出多个数据项： >>> random.sample(range(10), 2) [1, 0] 它们貌似均不支持字典的随机抽取。 生成乱序列 random.shuffle()可以传入一个线性结构的序列，并将其中的数据项进行随机的打乱： >>> li1 = [i for i in range(10)] >>> random.shuffle(li1) >>> li1 [1, 5, 6, 3, 7, 2, 9, 8, 4, 0] >>> random.shuffle(li1) >>> li1 [1, 5, 4, 3, 7, 0, 9, 6, 8, 2 生成验证码 验证码总是随机的，因此可以通过random模块进行实现生成： import random def getVerificationCode(bitNumber): code = \"\" for i in range(bitNumber): code += random.choice( [ str(random.randint(1, 9)), chr(random.randint(65, 91)) # ❶ ] ) return code code = getVerificationCode(6) print(code) ❶：65-90是大写的A-Z的ASCII码表示范围 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-13 20:41:50 "},"Python/Python模块与包/os.html":{"url":"Python/Python模块与包/os.html","title":"内置模块：os","keywords":"","body":"os简介 os模块是Python内置模块，提供了各种使用Python对操作系统提供操纵的接口。 官方文档 以下举例部分常用方法和属性： 方法/属性 描述 os.curdir 总是返回一个字符串，“.”，代指当前目录 os.pardir 总是返回一个字符串，“..”，代指当前父级目录 os.sep 返回当前平台下的路径分隔符，Windows下为“\\”，Unix下为“/” os.linesep 返回当前平台下的行终止符，Windows下为“\\r\\n”，Unix下为“\\n” os.pathsep 返回当前平台下的用于分割文件的分隔符，Windows下为“;”，Unix下为“:” os.name 返回当前平台的信息，Windows下为“nt”，Unix下为“posix” os.environ 获取系统环境变量 os.system(“command”) 运行shell命令 os.listdir(“dirName”) 获取指定目录下的所有项目，相当于ls命令，以列表方式返回结果 os.getcwd() 获取当前脚本的工作目录，相当于pwd命令 os.chdir(“dirName”) 改变当前脚本的工作目录，相当于cd命令 os.makedir(“dirName”) 生成单级的空目录，相当于mkdir命令 os.makedirs(“dirName1/dirName2”) 生成多层递归目录，相当于mkdir -p命令 os.rmdir(“dirName”) 删除单级的空目录 os.removedirs(“dirName”) 删除多层递归目录，前提是该目录必须为空 os.remove(“fileName”) 删除一个文件 os.rename(“oldName”, “newName”) 重命名文件/目录 os.path.abspath(“path”) 返回当前path的绝对路径 os.path.split(“path”) 将path分为2部分，返回元组，索引0是路径，索引1是文件 os.path.dirname(“path”) 返回path的路径部分，相当于上面方法的索引0 os.path.basename(“path”) 返回path的路径部分，相当于上面方法的索引1，如果path是以“/”或者“\\”结尾，则返回None os.path.join(“path1”, “path2”) 将多个path进行组合，相当于os.path.split()的反操作 os.path.exists(“path”) 判断path是否存在，返回布尔值 os.path.isabs(“path”) 判断path是否是绝对路径，返回布尔值 os.path.isfile(“path”) 判断path是否是一个文件路径，返回布尔值 os.path.isdir(“path”) 判断path是否是一个目录路径，返回布尔值 os.stat(“path”) 获取path所指文件/目录的相关信息 os.path.getatime(“path”) 获取path所指文件/目录的最后存取时间 os.path.getmtime(“path”) 获取path所指文件/目录的最后修改时间 os.path.getsize(“path”) 获取path所指文件/目录的大小 平台信息 根据以下一些属性，可获取平台信息： 属性 描述 os.curdir 总是返回一个字符串，“.”，代指当前目录 os.pardir 总是返回一个字符串，“..”，代指当前父级目录 os.sep 返回当前平台下的路径分隔符，Windows下为“\\”，Unix下为“/” os.linesep 返回当前平台下的行终止符，Windows下为“\\t\\n”，Unix下为“\\n” os.pathsep 返回当前平台下的用于分割文件的分隔符，Windows下为“;”，Unix下为“:” os.name 返回当前平台的信息，Windows下为“nt”，Unix下为“posix” os.environ 获取系统环境变量 os.environ是一个全局字典，你可以将它当做普通字典进行操作。 >>> os.environ ... >>> os.environ[\"k1\"] = \"v1\" >>> os.environ.get(\"k1\") 'v1' 此外，它是全局的，这意味着同一个项目之中任何地方都能随时获取到它，因此可以用它来存储一些较为私密的信息，如数据库链接IP+PORT+USER+PASSWORLD。 使用该字典时需要注意key必须是str类型，若是其他类型则会抛出异常。 目录操作 使用以下一些方法，可对目录做出操作： 方法 描述 os.system(“command”) 运行shell命令 os.listdir(“dirName”) 获取指定目录下的所有项目，相当于ls命令，以列表方式返回结果 os.getcwd() 获取当前脚本的工作目录，相当于pwd命令 os.chdir(“dirName”) 改变当前脚本的工作目录，相当于cd命令 os.makedir(“dirName”) 生成单级的空目录，相当于mkdir命令 os.makedirs(“dirName1/dirName2”) 生成多层递归目录，相当于mkdir -p命令 os.rmdir(“dirName”) 删除单级的空目录 os.removedirs(“dirName”) 删除多层递归目录，前提是该目录必须为空 os.remove(“fileName”) 删除一个文件 os.rename(“oldName”, “newName”) 重命名文件/目录 os.system()应该是一个比较常用的方法，它可以运行任何的shell命令： >>> os.system(\"tree .\") >>> os.system(\"ifconfig\") 但是os.system()如果在Windows环境下的PyCharm中进行使用，则会抛出异常。 因为Windows平台执行命令的返回结果是采用GBK编码，而PyCharm中使用UTF8对结果进行解码就会产生乱码问题。 路径操作 路径操作应该是os模块中比较常用的： 方法 描述 os.path.abspath(“path”) 返回当前path的绝对路径 os.path.split(“path”) 将path分为2部分，返回元组，索引0是路径，索引1是文件 os.path.dirname(“path”) 返回path的路径部分，相当于上面方法的索引0 os.path.basename(“path”) 返回path的路径部分，相当于上面方法的索引1，如果path是以“/”或者“\\”结尾，则返回None os.path.join(“path1”, “path2”) 将多个path进行组合，相当于os.path.split()的反操作 os.path.exists(“path”) 判断path是否存在，返回布尔值 os.path.isabs(“path”) 判断path是否是绝对路径，返回布尔值 os.path.isfile(“path”) 判断path是否是一个文件路径，返回布尔值 os.path.isdir(“path”) 判断path是否是一个目录路径，返回布尔值 示例演示os.path.join()和os.path.split()： >>> dirName, fileName = os.path.split(\"/Users/yunya/document/os模块.md\") >>> dirName '/Users/yunya/document' >>> fileName 'os模块.md' >>> newPath = os.path.join(\"/\", \"Users\", \"yunya\", \"document\", \"os模块.md\") >>> newPath '/Users/yunya/document/os模块.md' >>> 信息获取 信息获取也有时候会用到： 方法 描述 os.stat(“path”) 获取path所指文件/目录的相关信息 os.path.getatime(“path”) 获取path所指文件/目录的最后存取时间 os.path.getmtime(“path”) 获取path所指文件/目录的最后修改时间 os.path.getsize(“path”) 获取path所指文件/目录的大小 项目模块查找 项目启动不了? 在之前介绍Python模块一章节中说到PyCharm和原生解释器在查找模块时的sys.path会有所不同。 PyCharm会自动的新增几行模块查找路径，而原生解释器则不会进行新增。 这样会产生一个问题，即项目上线后通过原生解释器进行启动项目时会发现找不到模块。 如，我们有一个下面结构的项目： Project │ ├── bin │ └── run.py # 入口文件 └── view ├── __init__.py └── views.py # 视图层 定义了main()函数 当run.py进行执行后，Python工作目录就被定义在了Project/bin/run.py一层。 from view.views import main if __name__ == '__main__': main() 如果在PyCharm中执行run.py，则不会抛出异常，它能顺利的找到view模块，这是因为PyCharm将工作目录的上层、上上层也加入到了sys.path即模块查找路径中： [ '/Users/yunya/PycharmProjects/Project/bin', '/Users/yunya/PycharmProjects/Project', '...' ] 这样查找模块范围就会大很多： Project # 上上层能找到 │ ├── bin # 上层找不到 │ └── run.py # 本层找不到 └── view ├── __init__.py └── views.py 但是如果在Python原生解释器环境下，调用执行run.py脚本，则会提示找不到view模块，因为view模块仅能在上上层被找到： Project # 这里才能找到 │ ├── bin │ └── run.py # 找不到 └── view ├── __init__.py └── views.py 如何解决这个问题？只需要在run.py脚本中将上上层路径加入至sys.path即可： import sys import os sys.path.append(os.path.abspath(os.path.dirname(os.path.dirname(__file__)))) from view.views import main if __name__ == '__main__': main() 这样再次使用Python原生解释器通过run.py脚本启动项目，就不会发生任何问题了。 OpenStack对路径的处理 在OpenStack中，对这种项目模块查找路径的处理采用了截然不同的方式： import os import os, sys print(os.path.abspath(__file__)) possible_topdir = os.path.normpath(os.path.join( # ❶ __file__, os.pardir, # 上一级，相当于手动输入\"..\" os.pardir, )) print(possible_topdir) ❶：os.path.normpath()可以将一个不规范的路径变为规范路径 这样也能够达到相同的效果。 Django3.x对路径的处理 Django3以前，对项目模块查找路径的处理采用了和我们相同的方式： BASE_DIR = os.path.dirname(os.path.dirname(__file__)) print(BASE_DIR) 在Django3之后，则使用pathlib模块代替了os模块，其实本质都是一样的： from pathlib import Path root = Path(__file__) res = root.parent.parent # ❶ print(res) ❶：取上层的上层 补充一点pathlib的知识，对于pathlib的路径拼接直接使用 / 符号即可，符号左边为Path对象，右边为str类型。 与os.path.join()拥有相同的效果。 print(Path(\"User/YunYa\") / r\"a/b/c\") # User\\YunYa\\a\\b\\c 无论是os.path.join()还是pathlib的/进行路径拼接，都会选择出适合当前平台的路径分隔符。 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-13 20:41:50 "},"Python/Python模块与包/sys.html":{"url":"Python/Python模块与包/sys.html","title":"内置模块：sys","keywords":"","body":"sys简介 sys模块是Python内置模块，提供了各种系统相关的参数和函数。 官方文档 以下举例部分常用方法和属性： 方法/属性 描述 sys.platform 返回操作系统平台名称 sys.version 获取Python解释程序的版本信息 sys.builtin_module_names 获取内置的所有模块名，元组形式返回 sys.modules 返回以加载至内存之中的模块及路径 sys.path 返回模块在硬盘中的搜索路径 sys.stdin Python标准输入通道，input()函数的底层实现 sys.stdout Python标准输出通道，print()函数的底层实现 sys.stderr Python标准输入错误通道 sys.getrecursionlimit() 获取当前Python中最大递归层级 sys.setrecursionlimit() 设置当前Python中最大递归层级 sys._getframe(0).f_code.co_name 获取被调用函数的名称 sys._getframe(1).f_code.co_name 获取被调用函数是被哪一个函数所嵌套调用的，若不是被嵌套调用则返回module sys._getframe().f_back.f_lineno 获取被调用函数在被调用时所处代码行数 sys._getframe().f_code.co_filename 获取被调用函数所在模块文件名 sys.getrefcount() 获取对象的引用计数 sys.argv 获取通过脚本调用式传递的数据 修改递归层级 修改递归层级已经介绍过一次了，默认Python的最大递归层级是1000层，我们可以对其进行修改： >>> sys >>> sys.getrecursionlimit() 1000 >>> sys.setrecursionlimit(10000) >>> sys.getrecursionlimit() 10000 函数栈帧信息 sys._getframe()能够获取到函数的栈帧对象，我们知道函数的栈帧对象中封存了一些函数运行时的信息。 那么通过下面这些属性就能拿到函数里栈帧的某些数据： sys._getframe(0).f_code.co_name：获取被调用函数的名称 sys._getframe(1).f_code.co_name：获取被调用函数是被哪一个函数所嵌套调用的，若不是被嵌套调用则返回module sys._getframe().f_back.f_lineno：获取被调用函数在被调用时所处代码行数 sys._getframe().f_code.co_filename：获取被调用函数所在模块文件名 import sys def func(): print(sys._getframe(0).f_code.co_name) print(sys._getframe(1).f_code.co_name) print(sys._getframe().f_back.f_lineno) print(sys._getframe().f_code.co_filename) func() 脚本传入参数 我们都知道Python解释器可以通过以下方式进行.py文件的调用： $ python3 demo.py 但是你可能不知道通过sys.argv属性可以获取通过脚本调用式传递的数据，如下启动.py脚本时传入了1、2、3： $ python3 demo.py 1 2 3 那么现在sys.argv就会接受到这3个数据，变成下面的格式： sys.argv = [\"scriptPath\", \"1\", \"2\", \"3\"] 基于这个特性，我们来做一个下载模拟器： import random import sys import time def download(): scale = 40 print(\"开始下载文件:{0}\".format(sys.argv[2]).center(scale + 10, '-')) totalSize = random.randint(1000, 2000) currentSize = totalSize / scale for i in range(scale + 1): a = '█' * i b = '_' * (scale - i) c = (i / scale) * 100 print('''\\r{0:^3.2f}% | {1}{2} | {3:.2f}/{4:.2f}(MB)'''.format(c, a, b, currentSize * i, totalSize), end=\"\") time.sleep(0.1) print(\"\\n\" + \"执行结束\".center(scale + 10, '-')) def main(): try: runFunc = eval(sys.argv[1]) except Exception: print(\"输入有误！\", file=sys.stderr) exit() else: runFunc() if __name__ == '__main__': main() 启动时输入参数： python3 ./bin/run.py download test.text Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-13 20:41:50 "},"Python/Python模块与包/json&pickle&shelve.html":{"url":"Python/Python模块与包/json&pickle&shelve.html","title":"内置模块：json&pickle&shelve","keywords":"","body":"序列化 序列化是指将在内存中的数据变成为可存储或者可传输的数据。 Python中称序列化为pickling，而其他编程语言中则称之为serialization、marshalling、flattening等等，都是一个意思。 序列化最重要的目的是数据持久化保存，以及数据跨平台传输： 持久化保存：数据无法在内存中长期驻留，因此可以将其转变为某种格式并写入到磁盘之中 跨平台传输：不同的编程语言中对于数据的表示都是不同的，如Python中的set在很多语言中就不具备，故可以将数据进行序列化，变为一种大家都认识的格式 json JSON格式最早来源于JavaScript语言，现在已经成为跨平台语言传输的通用格式。 它的操纵及其简单，以下是JSON与Python中数据类型的对应关系： Python数据类型 JSON格式表示 dict {} list [] str string int or float int or float True or False true or false None Null JSON优点是操纵简单、跨语言传输十分方便，因为它采用字符串进行存储。 JSON缺点是仅支持Python基本数据类型，像函数、类这种都不被支持。 Python中进行JSON格式化，可以选择内置的json模块： 官方文档 常用方法一览： 方法 描述 json.dumps() 将Python中的基本数据类型序列化为JSON格式的字符串 json.loads() 将JSON格式字符串反序列化为Python中的基本数据类型 json.dump() 同json.dumps()，不过写入文件更方便 json.load() 同json.loads()，不过读取文件更方便 序列化 使用json.dumps()可以将Python中的基本数据类型序列化为JSON格式的字符串： >>> import json >>> userMessage = {\"name\" : \"yunya\", \"age\" : \"18\", \"gender\" : True, \"hobby\" : [\"read\", \"playGame\"]} >>> json.dumps(userMessage) '{\"name\": \"yunya\", \"age\": \"18\", \"gender\": true, \"hobby\": [\"read\", \"playGame\"]}' 如果想将序列化的结果进行持久化保存，可以使用json.dump()方法，它可以指定输出对象为文件句柄，如下示例： >>> import json >>> userMessage = {\"name\" : \"yunya\", \"age\" : \"18\", \"gender\" : True, \"hobby\" : [\"read\", \"playGame\"]} >>> with open(file=\"test.json\", mode=\"wt\", encoding=\"utf8\") as f: json.dump(userMessage,fp=f) 反序列化 使用json.loads()可以将JSON格式字符串反序列化为Python中的基本数据类型： >>> userJsonStr = '{\"name\": \"yunya\", \"age\": \"18\", \"gender\": true, \"hobby\": [\"read\", \"playGame\"]}' >>> json.loads(userJsonStr) {'name': 'yunya', 'age': '18', 'gender': True, 'hobby': ['read', 'playGame']} 如果想从文件中读取JSON字符串并进行反序列化，可以使用json.load()方法，它可以指定读取对象为文件句柄，如下所示： >>> import json >>> with open(file=\"test.json\", mode=\"rt\", encoding=\"utf8\") as f: userMessage = json.load(fp=f) >>> userMessage {'name': 'yunya', 'age': '18', 'gender': True, 'hobby': ['read', 'playGame']} 序列化的过程 Python的基本数据类型转换为JSON字符串时，经历了什么？ 总计可分为2步： 修改str的单引号为双引号 根据JSON与Python中数据类型的对应关系，将数据进行包装转换为JSON表现形式 示例、修改str的单引号为双引号： >>> pyStr = 'string' >>> jsonStr = json.dumps(pyStr) >>> jsonStr '\"string\" 示例、根据JSON与Python中数据类型的对应关系，将数据进行包装转换为JSON表现形式： >>> pyType = None >>> jsonType = json.dumps(pyType) >>> jsonType 'null' 中文显示 如果JSON序列化的字符串中带有中文，则将其转变为Unicode的16进制表现形式： >>> pyStr = \"云崖先生\" >>> json.dumps(pyStr) '\"\\\\u4e91\\\\u5d16\\\\u5148\\\\u751f\"' 你可以指定序json.dumps()中的关键字参数ensure_ascii为False，此时不会对中文字符进行转换： >>> json.dumps(pyStr, ensure_ascii=False) '\"云崖先生\"' 猴子补丁介绍 Monkey Patch是指用一个补丁偷偷的将一个原本的功能进行替换，使用者并不知道目前使用的功能是已经替换后的功能。 第三方模块ujson相比于json来说性能更加的高效，你可以将它作为猴子补丁偷偷的替换掉json，只需要在项目运行时的入口加入并运行一个替换函数： import json import ujson def monkeyPatchJson(): json.__name__ = \"ujson\" json.dumps = ujson.dumps json.loads = ujson.loads monkeyPatchJson() 修改完毕后，重启项目，后面的代码甚至不需要任何修改，就能使用性能更高的ujson了。 采用猴子补丁之后，如果发现ujson不符合预期，那也可以快速撤掉补丁，删除掉函数的执行语句即可。 序列化非基本数据类型 datetime类型并非是Python基本的数据类型，所以JSON不支持对它的序列化。 import datetime import json now = datetime.datetime.now() strNow = json.dumps(now, ensure_ascii=False) print(strNow) # TypeError: Object of type 'datetime' is not JSON serializable 此时我们可以手动的扩展json.dumps()的功能，让其支持datetime的序列化。 具体思路是将非Python基本数据类型转换为基本数据类型后再使用json.dumps()对其进行序列化，实现步骤如下所示： import datetime import json from json.encoder import JSONEncoder class JsonRealize(JSONEncoder): \"\"\" 该类是自定义序列化非Python基本数据类型的逻辑实现类 主要作用是继承并覆写父类JSONEncoder的default() \"\"\" def default(self, serializeObject): # 发现序列化对象是datetime类型的话，就将其转换为str类型 if isinstance(serializeObject, datetime.datetime): return str(serializeObject) # 如果是其他类型，则交由JSONEncoder的default()进行处理 return JSONEncoder.default(self, serializeObject) if __name__ == '__main__': now = datetime.datetime.now() strNow = json.dumps(now, cls=JsonRealize, ensure_ascii=False) print(strNow) # \"2021-05-23 20:40:49.446823\" json模块使用注意事项 Python3.6以及Python2.7之前均不支持反序列化bytes类型。 也就是说json.loads()一个bytes类型会抛出异常。 pickle 　pickle模块是Python自带的模块，它和json模块的方法全部一致，区别在于pickle序列化后的类型是bytes类型，而json序列化后的类型是字符串类型。 由于要考虑到多语言的兼容性问题，json模块并不支持Python除基本数据类型之外的类型。如：函数类型，类等等。 但是pickle由于只支持Python使用，所以有了更强的对Python序列化对象的支持。 pickle可以序列化函数，类等等，但是并不推荐这么做，因为保存的只有一个内存地址。 另外，由于pickle的局限性太强所以更推荐使用JSON进行序列化操作。 由于很少使用，以及与json模块的方法一致，这里不再进行演示了。 官方文档 shelve shelves是Python自带的模块，它能够更加方便的将Python数据进行持久化保存。 官方文档 它将整个文件看做一个大的字典，将字典中的key看做Python中的标识符，将value看做存储的对象，因此操作起来十分方便。 只需要记住2个方法即可： shelve.open()：打开一个文件，这个文件是可读可写的 shelve.close()：关闭文件 示例演示： >>> import shelve >>> with shelve.open(\"test.txt\") as f: f[\"name\"] = \"Yunya\" f[\"age\"] = 18 f[\"hobby\"] = [\"readBook\", \"playGame\"] >>> with shelve.open(\"test.txt\") as f: name = f.get(\"name\") >>> name 'Yunya' Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-28 21:05:24 "},"Python/Python模块与包/hashlib.html":{"url":"Python/Python模块与包/hashlib.html","title":"内置模块：hashlib","keywords":"","body":"hashlib简介 密码学是一个庞大的领域，总体来说可将该领域中的加密方式分为2大类： 对称加密：可通过加密值反解出内容 非对称加密：不可通过加密值反解出内容 而今天介绍的hashlib模块是Python3中所独有的，提供了一系列的非对称加密算法：hash算法。 在Python2中hashlib模块被拆分成了md5模块和sha模块，它们提供的功能和Python3的hashlib模块相同。 官方文档 以下是该模块提供的部分常用方法及属性： 属性/方法 描述 hashlib.algorithms_guaranteed 以集合方式，列出所有平台所支持的hash算法 hashlib.algorithms_available 以集合方式，列出当前所运行的Python解释器所支持的hash算法 hash.digest_size 以字节表示结果hash对象的大小 hash.block_size 以字节表示的hash算法的内部块大小 hash.name 返回hash对象的规范名称 hash.copy() 返回hash对象的拷贝副本 hash.update() 在已有基础上对hash对象的内容进行更新 hash.hexdigest() 返回16进制的字符串hash值 hash.digest() 返回2进制的字节串hash值 hash特性 Python的字典在键值对数据存储和读取时，就用到了hash算法。 比如：\"k1\" : \"v1\"的键值对在存储过程中，\"k1\"会通过hash()函数得出1个hash值，该hash值与v1一一对应，后续通过dict.get()方法通过\"k1\"找\"v1\"时，内部也是利用的这个hash值来进行查找。 通过字典的种种特性，我们可以顺势推导出hash的一些特性： 相同的内容求hash值，得到的hash结果也必然相同 不能通过hash值反解出内容（或者说反解的代价大到不可能实现，但也不是绝对的） 如果采用相同的hash算法，无论需要校验的内容由多大，得到的hash值长度总是固定的 我们使用内置的hash()函数来验证这3点结论： 1）相同的内容求hash值，得到的hash结果也必然相同： >>> hash(\"hello world\") -484803057 >>> hash(\"HELLO WORLD\") 264022494 >>> hash(\"hello world\") -484803057 2）不能通过hash值反解出内容： >>> hash(\"k1\") -714364401 >>> hash(\"-714364401\") 1936952577 3）如果采用相同的hash算法，无论需要校验的内容有多大，得到的hash值长度总是固定的： >>> hash(\"hello\") 313408759 >>> hash(\"hello, Python3\") -1705693388 算法区别 由于hash算法的特性，它常被用于一致性校验、密码存储等领域。 其中最著名的hash算法就是MD5，它被称为永不可破的hash算法，但随着技术的发展MD5已经不那么可靠了，它可以用撞库的方式对其进行反解。 而SHA256作为MD5的加强版，是目前的主流方案。 关于MD5和SHA家族的区别在于使用的加密算法不一样，以及它们生成的hash值长度不同： MD5较SHA家族的hash值要短一些，因此生成速度更快一点 对暴力破解来说，SHA家族的hash值比MD5的hash值更安全，更值得信赖 MD5：128位 SHA1：160位 SHA256：256位 如果你的项目安全等级较高，可采用SHA256作为加密方式，其他情况下使用MD5即可。 模块使用 hashlib模块的使用非常简单，总体来说先要生成一个hash对象，然后再填入字节串即可。 首先是普通的使用，以MD5举例： >>> import hashlib >>> m = hashlib.md5(\"hello world\".encode(\"u8\")) >>> m.digest() b'^\\xb6;\\xbb\\xe0\\x1e\\xee\\xd0\\x93\\xcb\"\\xbb\\x8fZ\\xcd\\xc3' 如果对一个大字符串生成hash值，可使用update()方法在原有hash对象基础上进行内容更新： >>> m = hashlib.md5() >>> m.update(\"line1\".encode(\"u8\")) >>> m.update(\"line2\".encode(\"u8\")) >>> m.update(\"line3\".encode(\"u8\")) >>> m.digest() b'\\xcc\\x0c\\x81\\xcdsha256的加密方式与md5的加密使用相同，如下所示： >>> m = hashlib.sha256(\"hello world\".encode(\"u8\")) >>> m.digest() b\"\\xb9M'\\xb9\\x93M>\\x08\\xa5.R\\xd7\\xda}\\xab\\xfa\\xc4\\x84\\xef\\xe3zS\\x80\\xee\\x90\\x88\\xf7\\xac\\xe2\\xef\\xcd\\xe9\" 基本使用就介绍完毕了，是不是非常简单呢？ 撞库介绍 在密码破解领域，有一个百试不爽的方法就是撞库破解。 撞库是指通过一个庞大的数据库来记录未加密字符串与加密后的值的一种映射关系，理论上来说只要这个数据库无限大，那么生成的hash值都能在这里找到其对应的生成字符串。 举个例子： 我现在有1个字符串，I LOVE YOU。 对他进行hash加密得到的结果假设为3242。 现在将这个对应关系放到数据库中，及3242这个hash值对应的字符串为I LOVE YOU。 如果有人要对3242进行反解，通过查询数据库即可知道结果。 这个思路非常的简单粗暴，但个人是不可能进行数据库的完善和搭建。 在Google上如果搜索MD5反解，应该能找到一些撞库网站，但大多数都是付费的，如果感兴趣可以试一试。 加盐验证 为了防止你的加密内容被撞库反解，我们可以使用加盐的策略来对已加密的内容进行二次加密。 整体思路如下，我们以一个普通的用户登陆作为案例： Server端有一个固定的字符串，被称之为盐 用户第一次注册后，要将用户名和密码写入到数据库中，此时数据库中的密码应当密文存储，且不可被反解，做到仅有用户知道自己的密码，连开发人员都不得而知的状态是最完美的 存储密码的时候，对明文密码进行hash加密，并在其中掺盐，得到密文hash密码进行存储 用户登陆的时候，将用户登陆时发送的明文密码也进行hash加密和掺盐，并且通过登陆的用户名获取到存储在数据库中的密文hash密码，两者进行比对，若一致则登陆成功，若不一致则登陆失败 当数据库被黑客攻破后，只要保证盐不泄露，那么他就没有任何办法破解出用户的密码 理论很复杂，实操很简单。如下所示： >>> salt = \"slat\".encode(\"u8\") >>> userPwd = \"123456\".encode(\"u8\") >>> hashObject = hashlib.md5(salt) # ❶ >>> hashObject.update(userPwd) # ❷ >>> savePwd = hashObject.digest() # ❶ >>> savePwd b'ELr\\x05\\x14$z=\\x1d\\x19(^4L>n' >>> >>> >>> reLoginPwd = \"123456\".encode(\"u8\") >>> hashObject = hashlib.md5(salt) # ❶ >>> hashObject.update(reLoginPwd)　 # ❷ >>> getPwd = hashObject.digest() # ❸ >>> getPwd == savePwd # ❹ True ❶：加盐 ❷：加入用户内容 ❸：获得存储密码 ❹：对比用户重登陆的密码hash值是否和以存储的密码hash值一致 文件校验 在Server端对Client端发送文件的过程中，该文件可能被黑客截取做出一些篡改，如下所示： server端 ---------> client端 | | 可能被黑客窃取，修改下载文件 此时就需要使用文件校验来确保安全性了： 在发送文件的时候要让用户知道我们文件本身的hash校验值 用户下载完成后将得出的结果与我们的hash校验值做对比 如果一致则文件没有被篡改过 如果不一致则文件已被篡改过 我们有2种方式，来进行文件校验的实现。 下面将采用模拟Server端生成文件校验hash值的整个过程。 首先是方式1，将文件所有内容hash校验一遍，安全系数最高，速度最慢。 res = \"\" m = hashlib.sha256() f = open(file=\"test.txt\",mode=\"rb\") while 1: temp = f.read(1024) # ❶ m.update(temp) # ❷ if not len(temp): f.close() hash_res = m.hexdigest() # ❸ break print(hash_res) # 48dd13d8629b4a15f791dec773cab271895187a11683a3d19d4877a8c256cb70 ❶：更新hash值 ❷：由于打开文件的模式是rb，故temp本身就是bytes类型，所以不用encode() ❸：当所有内容读取完毕后，生成文件的校验hash值 其次是方式2，文件指定指针点来更新hash值，安全系数小幅度降低，但速度大幅度提升。 迅雷等下载软件均采用此种方式，前提是要让用户知道我们seek()的文件指针点在哪里: m = hashlib.sha256() f = open(file=\"1.txt\",mode=\"rb\") # ❶ f.seek(20,0) temp = f.read(10) m.update(temp) # ❷ f.seek(20,1) temp = f.read(10) m.update(temp) # ❸ f.seek(-20,2) temp = f.read(10) m.update(temp) # ❹ hash_res = m.hexdigest() print(hash_res) # daffa21b2be95802d2beeb1f66ce5feb61195e31074120a605421563f775e360 ❶：在文件的开始位置，读取10个bytes，用作生成hash值的源内容部分 ❷：在文件的中间位置，读取10个bytes，用作生成hash值的源内容部分 ❸：在文件的末尾位置，读取10个bytes，用作生成hash值的源内容部分 ❹：生成文件校验的hash值，该hash值共由30个bytes组成，分别来自文件的开始、中间、末尾位置。Ps：指针点越多，安全性越高，但是速度越慢 hmac模块 hmac模块的使用与hashlib大同小异。但是在某些方面会比hashlib更优秀： 它也是一个内置模块，以下是简单的使用： >>> import hmac >>> hmacObject = hmac.new(\"hello world\".encode(\"u8\"), digestmod=\"md5\") >>> hmacObject.update(\"salt\".encode(\"u8\")) >>> hashValue = hmacObject.digest() >>> hashValue b'\\xf3Q\\xff\\xb2V{\\x88\\xfe\\x0e\\x9aX\\x19\\xbf\\x12\\xf3>> 另外，还有一个compare_digest()方法，放入2个bytes类型，用于判断他们的值是否一致。 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-28 21:51:23 "},"Python/Python模块与包/configparser.html":{"url":"Python/Python模块与包/configparser.html","title":"内置模块：configparser","keywords":"","body":"configparser简介 configparser模块是Python的内置模块，提供了配置文件创建、解析、修改等功能。 官方文档 值得注意的是，在Python2中，它的命名是驼峰式的，为ConfigParser。 认识配置文件 配置文件常以.ini或者.cfg作为后缀，注释方式有2种。 #注释与;注释，一个配置项是以键值对方式进行存储，通过:或者=分割。 [regulator] user_name : Yunya age = 21 sex = male is_admin = true salary = 20 [path] RUN_LOG_FILE = log/run.log $true ERROR_LOG_FILE = log/error.log $true 如果某一个配置项后面加上了$true，则$true在解析的时候将被替换为BASE_DIR，也就说该$true会被替换为完整的路径。 我个人喜欢将一个配置文件分成3部分，尽管下面的叫法并不是非常的正确： 配置项分类（classify）：以[]包裹的数据项，或者称为block 配置项的键（key）：:或者=左边的数据项 配置项的值（value）：:或者=右边的数据项 字典一样操作 configparser模块能够让配置文件像字典一样进行操作。 下面介绍3个该模块提供的基本方法： 方法 描述 ConfigParser() 创建文档对象 documentObject.read(filenames, encoding=None) 读取配置文件 documentObject.write(fp) 将文档对象写入磁盘 如下示例，对配置文件进行读取： import configparser # 创建文档对象，并且读取配置文件 documentObject = configparser.ConfigParser() documentObject.read(filenames=\"./config.ini\", encoding=\"u8\") # 获取所有classify classifyAllTuple = tuple(documentObject.items()) # 获取所有的key和value for classify in documentObject.values(): print(dict(classify.items())) # 获取指定classify下的指定key的value # 需要自己做类型转换 userAge = documentObject[\"regulator\"][\"age\"] print(int(userAge)) 新增一个配置文件，先创建一个空的文档对象，然后加入一些子字典，将他看做嵌套字典，最后进行写入磁盘即可： import configparser # 先创建一些classify以及kev-value配置项 defaultClassify = { \"ip\": \"0.0.0.0\", \"port\": 65535, } serverClassify = { \"ip\": \"192.168.0.120\", \"port\": 65536, } loginClassify = { \"user\": \"root\", \"password\": \"123456\", \"db\": 1, \"verify\": False, } # 创建一个空文档对象 noneDocumentObject = configparser.ConfigParser() # 为这个空文档对象，添加classify，将它看成字典操作即可 noneDocumentObject[\"DEFAULT\"] = defaultClassify noneDocumentObject[\"SERVER\"] = serverClassify noneDocumentObject[\"LOGIN\"] = loginClassify # 将文档对象写入到磁盘 with open(file=\"./newConfig.ini\", mode=\"wt\", encoding=\"utf8\") as f: noneDocumentObject.write(fp=f) 修改一个配置项，对字典中的value进行更新。最后将文档对象写入到磁盘： import configparser # 创建文档对象，并且读取配置文件 documentObject = configparser.ConfigParser() documentObject.read(filenames=\"./config.ini\", encoding=\"u8\") # 修改regulator下的age为30岁，注意这里必须为str类型 documentObject[\"regulator\"][\"age\"] = \"30\" # 写入磁盘 with open(\"./config.ini\", mode=\"wt\", encoding=\"utf8\") as f: documentObject.write(fp=f) 读取配置文件 configparser模块此外也为文档对象提供了一些专用的方法，来操作配置文件。 如下所示： 方法 描述 sections(self) 拿到所有的classify options(self, section) 指定一个classify，拿到其下所有的key items(self, section=_UNSET, raw=False, vars=None) 指定一个classify，拿到其下所有的key和value get(self, section, option) 指定classify和key，拿到具体的value，并将其转换为Python中的str类型 getint(self, section, option) 指定classify和key，拿到具体的value，并将其转换为Python中的int类型 getfloat(self, section, option) 指定classify和key，拿到具体的value，并将其转换为Python中的float类型，保留1位小数 getboolean(self, section, option) 指定classify和key，拿到具体的value，并将其转换为Python中的bool类型 示例演示： import configparser # 初始化文档对象，并且读取配置文件 documentObject = configparser.ConfigParser() documentObject.read(filenames=\"./config.ini\", encoding=\"utf8\") # 获取配置文件中所有的classify allClassify = documentObject.sections() print(allClassify) # ['regulator', 'path'] # 获取classify（regulator）下所有的key regulatorKeys = documentObject.options(section=allClassify[0]) print(regulatorKeys) # ['user_name', 'age', 'sex', 'is_admin', 'salary'] # 获取classify(regulator)下所有的键值对 regulatorItems = documentObject.items(section=allClassify[0]) print(regulatorItems) #　[('user_name', 'Yunya'), ('age', '21'), ('sex', 'male'), ('is_admin', 'true'),('salary', '20')] # 获取classify(regulator)下的key(user_name)对应的value # get()会自动将value转换为str类型 name = documentObject.get(section=allClassify[0], option=\"user_name\") print(name) # Yunya # 获取classify(regulator)下的key(age)对应的value # getint()会自动将value转换为int类型 age = documentObject.getint(section=allClassify[0], option=\"age\") print(age) # 21 # 获取classify(regulator)下的key(is_admin)对应的value # getboolean()会自动将value转换为bool类型 isAdimin = documentObject.getboolean(section=allClassify[0], option=\"is_admin\") print(isAdimin) # True # 获取classify(regulator)下的key(salary)对应的value # getfloat()会自动将value转换为float类型，并保留一位小数 salary = documentObject.getfloat(section=allClassify[0], option=\"salary\") print(salary) # 20.0 修改配置文件 configparser模块也提供了一些修改配置文件的方法。 如下表所示，但我很少会使用到，所以不再进行案例书写了： 方法 描述 add_section(self, section) 向文档对象中增加一个classify set(self, section, option, value=None) 设置或添加文档对象的键值对 remove_section(self, section) 删除文档对象中的的一个classify remove_options(self, section, option) 删除文档对象中的一组键值对 has_section(self, section) 判断文档对象中的一个classify是否存在 has_options(self, section, option) 判断文档对象中的一个key是否存在 个人更加倾向于通过字典的方式操纵文档对象。 特殊的DEFAULT 配置文件中有1个名为DEFAULT的classify，它提供了一些默认设置。 如果你的配置文件中没有显式的配置DEFAULT这个classify，则通过字典操作任然会获取到到它。但是若通过方法进行操作，该classify则不会出现。 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-13 20:41:50 "},"Python/Python模块与包/subprocess.html":{"url":"Python/Python模块与包/subprocess.html","title":"内置模块：subprocess","keywords":"","body":"subprocess简介 subprocess模块最早在Python2.4中引入，它会生成一个子进程，该子进程可以执行shell命令，并且会监听系统的标准输入管道、标准输出管道、标准错误管道，在命令执行完毕后，将结果进行返回到对应的管道中。 官方文档 如下图所示： 它的功能虽然看上去十分单一，但是应用是非常广泛的。 试想，你是一名运维人员，编写了1个脚本，每天定时定点的在100台机器上获得它们的状态信息，就可以用到该模块。 让脚本在宿主机上通过该模块执行命令，并且拿到命令的返回结果，再通过网络返回结果并对其进行分析，依此判定各个宿主机的工作状态。 简单的使用 对于简单的使用，记住这4个方法即可，如下表所示： 方法 描述 subprocess.Popen(...) 执行系统命令，并将执行结果放入对应的管道中，返回一个Popen对象 PopenObject.stdout.read() 从标准输出管道中获取执行结果 PopenObject.stderr.read() 从标准错误管道中获取执行结果 PopenObject.stdin.write() 通过标准输入管道与系统进行交互 subprocess.Popen()的可指定参数比较多，下面是它的签名： def __init__(self, args, bufsize=-1, executable=None, stdin=None, stdout=None, stderr=None, preexec_fn=None, close_fds=_PLATFORM_DEFAULT_CLOSE_FDS, shell=False, cwd=None, env=None, universal_newlines=False, startupinfo=None, creationflags=0, restore_signals=True, start_new_session=False, pass_fds=(), *, encoding=None, errors=None): 常用参数的释义如下： args：将要执行的命令，可以是str类型或者list、tuple类型 bufsize：指定缓冲大小，0是没有，1是默认 executable：要执行的替换程序 stdin/stdout/stderr：标准输入、输出、错误管道的句柄 preexec_fn：仅在Unix平台下有效。指定一个可调用对象，通常是指函数，它将在fork出的子程序运行之前调用 close_sds：在Windows平台下，如果该参数指定为True，则fork出的子程序将不会继承父程序的标准输入、输出、错误管道中传输的内容，一般设置默认即可 shell：如果为True，则通过shell执行命令 cwd：设置子进程执行时的工作目录 env：用于指定子进程的环境变量，如果为None，子进程将继承父进程的环境变了 Universal_newlines：如果为True，则不区分平台，统一将换行符定义为\\n 简单的执行命令并获取返回结果： import subprocess popenObject = subprocess.Popen( args=\"ping www.baidu.com\", shell=True, stdin=subprocess.PIPE, stderr=subprocess.PIPE, stdout=subprocess.PIPE, ) successMessage, errorMessage = popenObject.stdout.read(), popenObject.stderr.read() print(successMessage.decode(\"gbk\")) print(errorMessage.decode(\"gbk\")) popenObject.stdout.close() popenObject.stderr.close() 注意事项： 如果你的测试环境是Windows，则对执行结果的解码方式需要使用GBK，因为Windows的终端字符编码方式就是GBK。而如果是Unix平台只需要使用UTF8即可。 通过stdin与与宿主机进行交互： import subprocess # 执行的语句 stdInCommand = \"\"\"print (\\\"Hello, world\\\")\"\"\" # 通过subprocess在测试机上启动1个新的Python REPT交互式环境 popenObject = subprocess.Popen( args=\"python\", shell=True, stdin=subprocess.PIPE, stderr=subprocess.PIPE, stdout=subprocess.PIPE, ) # 写入内容，进行交互，注意每次交互完毕后都要立即关闭管道 popenObject.stdin.write(stdInCommand.encode(\"utf8\")) popenObject.stdin.close() # 获取并打印结果 successMessage, errorMessage = popenObject.stdout.read(), popenObject.stderr.read() print(successMessage.decode(\"gbk\")) print(errorMessage.decode(\"gbk\")) popenObject.stdout.close() popenObject.stderr.close() 更多的操作 以下方法了解即可，其实用的并不多： 方法 描述 subprocess.run() 执行命令，不返回结果，拥有timeout参数，可设定超时时间 subprocess.call() 执行命令，并且返回执行状态（bool类型，0成功，1失败） subprocess.check_call() 执行命令，并且返回执行结果和执行状态，如果命令执行失败则抛出异常， subprocess.getstatusoutput() 执行命令，返回1个tuple，[0]是执行状态，[1]是执行结果 subprocess.getoutput() 执行命令，返回执行结果（str类型） subprocess.check_output() 执行命令，返回执行结果（bytes类型） 这里就不再进行演示了，感兴趣的可以参见官方文档。 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-13 20:41:50 "},"Python/Python模块与包/logging.html":{"url":"Python/Python模块与包/logging.html","title":"内置模块：logging","keywords":"","body":"logging简介 Python内置模块logging提供了日志记录相关功能，是一款非常强大且常用的模块。 官方文档 它的使用如果刨根问底可能比较复杂，所以里仅介绍1种最方便的使用方式，其他的使用方式日常开发中基本不会用到，故不进行介绍。 简单了解 logging模块中规定日志拥有6个级别，每个级别都有单词、数字2种表现形式，如下表所示： level number 描述 logging.critical 50 致命错误 logging.error 40 常规错误 logging.warning 30 警告信息 logging.info 20 普通信息 logging.debug 10 调试信息 logging.NOSET 0 ... logging.NOSET一般不会进行使用，所以你也可以认为logging的日志级别只有5个。 等级越低，越能看到更多的日志信息，它会根据等级依次向上推进，如下图所示： 默认的等级是30，也就是warning级别，仅能看到critical、error、warning这个级别的日志，而info和debug则看不见。 如下所示： import logging logging.debug(\"debug\") logging.info(\"info..\") logging.warning(\"warning..\") logging.error(\"error..\") logging.critical(\"critical..\") # ❶ ❷ # WARNING:root:warning.. # ERROR:root:error.. # CRITICAL:root:critical.. ❶：root指的是记录日志的用户，默认就是root ❷：默认的日志输出位置是向屏幕，也可以将日志输出至文件 配置文件 如果想快速的使用logging模块进行日志记录。 可以使用配置文件的形式，一般来说该配置文件会存放至settings.py中： import os # 定义2种日志记录格式 # 标准的：standard_format # 简单的：simple_format standard_format = \"[%(asctime)s][%(threadName)s:%(thread)d][username:%(name)s][%(filename)s:%(lineno)d]\" \\ \"[%(levelname)s][%(message)s]\" simple_format = \"[%(levelname)s][%(asctime)s][%(filename)s:%(lineno)d]%(message)s\" # 定义日志存放路径 LOG_DIR = os.path.dirname(os.path.abspath(__file__)) if not os.path.isdir(os.path.join(LOG_DIR, \"log\")): os.mkdir(os.path.join(LOG_DIR, \"log\")) LOG_PATH = os.path.join(LOG_DIR, \"log\", \"run.log\") # LOGGING的应用配置字典，无需太大改动，开箱即用 LOGGING_SETTING = { \"version\": 1, \"disable_existing_loggers\": False, # 添加2种日志记录格式 \"formatters\": { \"standard\": { \"format\": standard_format }, \"simple\": { \"format\": simple_format }, }, # 控制流相关配置 \"handlers\": { # 输出到终端(logging.StreamHandler)，采用简单的日志记录格式 \"screen\": { \"level\": \"DEBUG\", \"class\": \"logging.StreamHandler\", \"formatter\": \"simple\" }, # 输出到文件(logging.handlers.RotatingFileHandler)，采用标准的日志记录格式 \"file\": { \"level\": \"DEBUG\", \"class\": \"logging.handlers.RotatingFileHandler\", \"formatter\": \"standard\", # 日志文件位置及名称，若不指定则默认在当前目录下 \"filename\": LOG_PATH, # 每个日志文件最大5M，当存在5个日志文件后开启日志轮转 \"maxBytes\": 1024*1024*5, \"backupCount\": 5, \"encoding\": \"utf-8\", }, }, # 定义不同用户采用的控制流 \"loggers\": { # 如果不指定用户，或指定用户未在loggers字典中，则采用该配置 \"\": { \"handlers\": [\"screen\", \"file\"], # 以控制流相关配置中过滤级别为准，这里是1次过滤，控制流中是2次过滤 \"level\": \"DEBUG\", # 关闭日志冒泡，切勿手动更改 \"propagate\": False, }, # 若指定用户为testUser，则采用该配置 \"testUser\": { \"handlers\": [\"screen\"], \"level\": \"DEBUG\", \"propagate\": False, } } } 项目应用 如何使用该配置文件？我们假设项目目录如下： Project/ |-- bin/ | |-- run.py # 启动脚本 | |-- view/ | |-- main.py # 主程序 | |-- common.py # 公用模块 |-- settings.py # logging配置文件 首先是启动脚本： # bin/run.py import os import sys sys.path.append( os.path.dirname(os.path.dirname(__file__)) ) from view.main import main if __name__ == \"__main__\": main() 其次是主程序： # view/main.py from common import logger def main(): logger.debug(\"debug\") logger.info(\"info..\") logger.warning(\"warning..\") logger.error(\"error..\") logger.critical(\"critical..\") 最后是公用模块： # common.py from logging import config from logging import getLogger from settings import LOGGING_SETTING config.dictConfig(LOGGING_SETTING) logger = getLogger(\"adminstartion\") 可以看到在公用模块中导入了配置字典，并且将它应用进了logging模块。 然后获取了一个日志对象logger，在以后使用时都使用这个logger进行日志记录即可，这里getLogger()的用户名是adminstartion，未定义在LOGGIN_SETTING的loggers中，故会采用第一个配置，也就是下面这个： \"loggers\": { # 如果不指定用户，或指定用户未在loggers字典中，则采用该配置 \"\": { \"handlers\": [\"screen\", \"file\"], \"level\": \"DEBUG\", \"propagate\": False, }, ... } Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-13 20:41:50 "},"Python/Python模块与包/re.html":{"url":"Python/Python模块与包/re.html","title":"内置模块：re","keywords":"","body":"re简介 正则表达式其本身就是一种小型的，高度专业化的编程语言。 在Python中，它被内嵌在了re模块里面，正则表达式模式被编译成一系列的字节码，然后由用C编写的匹配引擎执行。 官方文档 本文仅针对可能用到的方法进行描述，对不常用的方法等进行了筛选。 方法一览 符号大全 以下是正则表达式的符号大全： 符号 中文名称 释义 . 通配符 匹配除\\n之外的任意字符，如果想匹配\\n可更换匹配模式为re.S或re.DOTALL ^ 开始符 匹配以特定字符开始的字符串，在检测时只会检测开头第一个字符并立即返回结果 $ 结束符 匹配以特定字符结尾的字符串，在检测时只会检测结尾最后一个字符并立即返回结果 * 可有重复符 代表可以取0-∞位*号前面的字符（默认贪婪取值，可通过?取消贪婪模式） + 必有重复符 代表可以取1-∞位+号前面的字符（默认贪婪取值，可通过?取消贪婪模式） ? 单一重复符 代表可以取1-∞位?号前面的字符（默认贪婪取值，可通过?取消贪婪模式） {n,m} 范围重复符 代表可以取到n-m位{n,m}前面的字符（默认贪婪取值，可通过?取消贪婪模式） {n} 精确重复符 代表可以精确取到n位{n}前面的字符 [] 字符集 在[]中多个字符仅能匹配到1个，并且字符集中所有符号失去特殊意义，仅有- ^ \\ 这3个符号在字符集中具有特殊意义 [-] 区间符 字符集中的-号代表可以取从多少到多少区间的值，按照ASCII码排序，比如[a-z0-9A-Z]代表这1位取全部的英文字母和数字 排除符 字符集中的^号代表非的作用，比如[^0-9]代表这1位并非是数字 [\\] 转义符 转义符如果在字符集中使用，可以为特定的字符赋予特殊的意义 \\ 转义符 转义符如果在字符集外使用，可以为特定的字符赋予特殊的意义，并且还可以让特定的字符失去特殊的意义，但是如果未用r原始字符串进行正则匹配，则可能会导致令人意外的情况发生 \\d ... 匹配任何十进制数，它相当于在字符集中使用[0-9] \\D ... 匹配任何非十进制数，它相当于在字符集中使用[^0-9] \\s ... 匹配任何空白字符，它相当于在字符集中使用[\\t\\n\\r\\f\\v] \\S ... 匹配任何非空白字符，它相当于在字符集中使用[^\\t\\n\\r\\f\\v] \\w ... 匹配任何字母数字下划线字符,它相当于在字符集中使用[a-z A-Z 0-9] \\W ... 匹配任何非字母数字下划线字符,它相当于在字符集中使用[a-z A-Z 0-9] \\b ... 匹配一个特殊字符边界，比如空格,&.#等(不常用) 管道符 相当于或，注意与字符集里的区别，管道符将前后分为2段，左右看做1个整体，而字符集中的或仅仅代表从众多选项中拿出1个 () 分组符 将多个元素字符看做一个整体，也就是将它们当做一个元素字符进行匹配，若整个匹配规则中无子分组，则默认的匹配结果为一组 (?=exp) 零宽先行断言 匹配后面为exp的内容 (? 零宽后行断言 匹配前面为exp的内容 (?!exp) 零宽负向先行断言 匹配后面不能是exp的内容 (? 零宽负向后行断言 匹配前面不能是exp的内容 匹配方法 以下是re模块提供的正则匹配方法： 方法 描述 findall() 将所有的匹配结果返回至1个列表中 finditer() 将所有的匹配结果返回至1个迭代器中 search() 将首次匹配的结果返回至search对象中，可通过group()进行取值 match() 在search()基础上添加了^，使之只能在开头匹配 group() 通过该方法对search对象进行取值操作，返回一个或者多个匹配的子组 groups() 通过该方法对search对象进行取值操作，返回一个元组，包含所有匹配的子组 groupdict() 通过该方法对search对象进行取值操作，返回一个字典，包含了所有的具名子组 split() 对字符串进行分割，其算法可能导致令人意外的情况发生 sub() 对字符串进行替换，最少需要3个参数，返回一个新的字符串 subn() 对字符串进行替换，最少需要3个参数，返回一个元祖，其中包含了替换成功了几次 complie() 可以将一个标示符赋予指定的规则，达到简化重复操作的目的 匹配模式 以下是re模块提供的正则匹配模式： 模式简写 模式全写 描述 re.I re.IGNORECASE 不分大小写字母的匹配模式 re.M re.MULTILINE 视为多行的匹配模式，以\\n作为行分割符 re.S re.DOTALL 视为单行的匹配模式，即通配符可以匹配\\n re.U re.UNICODE 宽字符匹配模式，即支持匹配占4个字符的UTF-16匹配模式 创建正则 re.findall() 在测试阶段，我们大部分示例都会使用re.findall()方法进行测试。 它的函数签名如下： def findall(pattern, string, flags=0): 参数释义： pattern：匹配规则 string：被匹配字符串 flags：匹配模式 一次简单的使用，匹配以hello开头且以exp结尾的子串，采用多行匹配模式： import re string = \"hello world\\nhello regexp\\nhello python\\n\" resultList = re.findall( pattern=r\"^hello.*exp$\", string=string, flags=re.M ) print(resultList) # ['hello regexp'] 基础符号 . 通配符 .通配符会匹配除\\n之外的任意字符，如果想匹配\\n可更换匹配模式为re.S或re.DOTALL。 如下示例，匹配11个除开\\n之外的任意字符组成的子串： import re rule = \".\" * 11 string = \"hello world\\n123456abcdeABCDE\" resultList = re.findall(pattern=rule, string=string) print(resultList) # ['hello world', '123456abcde'] ^ 开始符 ^开始符会匹配以特定字符开始的字符串，在检测时只会检测开头第一个字符并立即返回结果。 如下示例，匹配以P开头且后面必须是ython加上7个除开\\n的任意字符的子串： import re rule = \"^Python.......\" string = \"Python regexp module\" resultList = re.findall(pattern=rule, string=string) print(resultList) # ['Python regexp'] $ 结束符 $结束符会匹配以特定字符结尾的字符串，在检测时只会检测结尾最后一个字符并立即返回结果。 如下所示，匹配以p结束，且前面2个字符必须是E与x的子串，区分大小写： import re rule = \"Exp$\" string = \"Python regexp regExp RegExp\" resultList = re.findall(pattern=rule, string=string) print(resultList) # ['Exp'] 重复符 * 可有重复 *代表可以取0-∞位*号前面的字符（默认贪婪取值，可通过?取消贪婪模式） 如下示例，匹配必须是以h开头，后面可以有0个也可以有多个除了\\n外的任意字符，紧接着\\n后继续匹配0个或者n个除了\\n外的任意字符，最后必须以p进行结尾的子串： import re rule = \"^h.*\\n.*p$\" string = \"hello Python\\nregexp\" resultList = re.findall(pattern=rule, string=string) print(resultList) # ['hello Python\\nregexp'] 上面这个示例，有3个条件是必须的。 h开头 中间必须有\\n p结束 所以下面这个字符串也会被匹配到： string = \"h\\np\" + 必有重复 +代表可以取1-∞位+号前面的字符（默认贪婪取值，可通过?取消贪婪模式） 如下示例，匹配必须是以h开头，后面可以有1个也可以有多个除了\\n外的任意字符，紧接着\\n后继续匹配1个或者n个除了\\n外的任意字符，最后必须以p进行结尾的子串： import re rule = \"^h.+\\n.+p$\" string = \"hello Python\\nregexp\" resultList = re.findall(pattern=rule, string=string) print(resultList) # ['hello Python\\nregexp'] 上面这个示例，有5个条件是必须的： h开头 h后面必须至少有1个任意字符 中间必须有\\n \\n后面必须至少有1个任意字符 p结束 所以下面这个字符串不会被匹配到： string = \"h\\np\" ? 单一重复 ?代表可以取1-∞位?号前面的字符（默认贪婪取值，可通过?取消贪婪模式） 如下示例，匹配可以是1开头，也可以不是1开头且后面是2345678且以9结尾的字符串： import re rule = \"^1?23456789$\" string = \"123456789\" resultList = re.findall(pattern=rule, string=string) print(resultList) # ['123456789'] 上面这个示例，有2个条件是必须的： 字符串的开头如果不是1，则必须是2 后面必须跟上345678，且以9结尾 所以下面这个字符串也会被匹配到： string = \"23456789\" {n,m} 区间重复 {n,m}代表可以取到n-m位{n,m}前面的字符，（默认贪婪取值，可通过?取消贪婪模式） 如下示例，匹配包含4个或者3个连续是1的子串： import re rule = \"1{3,4}\" string = \"1111111\" resultList = re.findall(pattern=rule, string=string) print(resultList) # ['1111', '111'] {n} 精确重复 {n}代表可以精确取到n位{n}前面的字符。 如下示例，匹配包含3个连续的1的子串： import re rule = \"1{3}\" string = \"1111111\" resultList = re.findall(pattern=rule, string=string) print(resultList) # ['111', '111'] 取消贪婪匹配 默认的*，+，?，{n,m}都是贪婪取值。 即有多个就取多个，没有多个才少取。 在它们后面加上?即可取消贪婪匹配，如下示例： import re ruleList = [ # 取0个或者多个a，取消贪婪后取0个 \"a*?\", # 取1个或者多个a，取消贪婪后取1个 \"a+?\", # 取0个或者1个a，取消贪婪后取0个 \"a??\", # 取3个或者4个a，取消贪婪后取3个 \"a{3,4}\" ] string = \"a\" * 7 for rule in ruleList: resultList = re.findall(pattern=rule, string=string) print(resultList) # ['', '', '', '', '', '', '', ''] # ['a', 'a', 'a', 'a', 'a', 'a', 'a'] # ['', '', '', '', '', '', '', ''] # ['aaaa', 'aaa'] 字符集 [] 字符集 在[]中多个字符仅能匹配到1个，并且字符集中所有符号失去特殊意义，仅有- ^ \\ 这3个符号在字符集中具有特殊意义。 如下示例，匹配包含1a或者2a或者3a的子串： import re rule = \"[123]a\" string = \"1a2a3a1b2b3b\" resultList = re.findall(pattern=rule, string=string) print(resultList) # ['1a', '2a', '3a'] [-]区间符 字符集中的-号代表可以取从多少到多少区间的值，按照ASCII码排序，比如[a-z0-9A-Z]代表这1位取全部的英文字母和数字。 如下示例，匹配所有由连续的字母或者数字组成的子串： import re rule = \"[0-9A-Za-z]+\" string = \"1b23c4d\\n2342bbc\" resultList = re.findall(pattern=rule, string=string) print(resultList) # ['1b23c4d', '2342bbc'] [^] 排除符 字符集中的^号代表非的作用，比如[^0-9]代表这1位并非是数字。 如下所示，匹配结尾不为数字的子串，匹配模式为多行匹配： import re rule = \".+[^0-9]$\" string = \"abc\\n12x\\n345\" resultList = re.findall(pattern=rule, string=string, flags=re.M) print(resultList) # ['abc', '12x'] [\\]转义符 转义符如果在字符集中使用，可以为特定的字符赋予特殊的意义。 如下所示，\\w是具有特殊意义的字符，作用是匹配字母数字下划线字符。 它可以在字符集中使用： import re rule = \"[\\w]+\" string = \"abc\\n12x\\n345\" resultList = re.findall(pattern=rule, string=string, flags=re.M) print(resultList) # ['abc', '12x', '345'] 转义字符 \\ 转义符 转义符如果在字符集外使用，可以为特定的字符赋予特殊的意义，并且还可以让特定的字符失去特殊的意义，但是如果未用r原始字符串进行正则匹配，则可能会导致令人意外的情况发生。 如，失去特殊意义： .本来是通配符，如果是\\.就是普通的.，再也没有任何意义了。 如下示例，匹配一个url： import re rule = \"w{3}\\.\\w+\\.com\" string = \"www.google.com www.biying.com\" resultList = re.findall(pattern=rule, string=string) print(resultList) # ['www.google.com', 'www.biying.com'] 以下是常用加上\\后就拥有特殊意义的字符： 符号 中文名称 释义 \\d ... 匹配任何十进制数，它相当于在字符集中使用[0-9] \\D ... 匹配任何非十进制数，它相当于在字符集中使用[^0-9] \\s ... 匹配任何空白字符，它相当于在字符集中使用[\\t\\n\\r\\f\\v] \\S ... 匹配任何非空白字符，它相当于在字符集中使用[^\\t\\n\\r\\f\\v] \\w ... 匹配任何字母数字下划线字符,它相当于在字符集中使用[a-z A-Z 0-9] \\W ... 匹配任何非字母数字下划线字符,它相当于在字符集中使用[a-z A-Z 0-9] \\b ... 匹配一个特殊字符边界，比如空格,&.#等(不常用) \\d和\\D \\d可以匹配任何十进制数，它相当于在字符集中使用[0-9]： import re rule = \"\\d+\" string = \"123 abc 1a2b3c\" resultList = re.findall(pattern=rule, string=string) print(resultList) # ['123', '1', '2', '3'] \\D可以匹配任何非十进制数，它相当于在字符集中使用[^0-9]： import re rule = \"\\D+\" string = \"123 abc 1a2b3c\" resultList = re.findall(pattern=rule, string=string) print(resultList) # [' abc ', 'a', 'b', 'c'] \\s和\\S \\s可以匹配任何空白字符，它相当于在字符集中使用[\\t\\n\\r\\f\\v]： import re rule = \"\\s\" string = \"123 abc 1a2b3c\" resultList = re.findall(pattern=rule, string=string) print(resultList) # [' ', ' '] \\S匹配任何非空白字符，它相当于在字符集中使用[^\\t\\n\\r\\f\\v]： import re rule = \"\\S\" string = \"123 abc 1a2b3c\" resultList = re.findall(pattern=rule, string=string) print(resultList) # ['1', '2', '3', 'a', 'b', 'c', '1', 'a', '2', 'b', '3', 'c'] \\w和\\W \\w可以匹配任何字母数字下划线字符,它相当于在字符集中使用[a-z A-Z 0-9]： import re rule = \"\\w+\" string = \"user_name123 \\t\\n\\f\" resultList = re.findall(pattern=rule, string=string) print(resultList) # ['user_name123'] \\W可以匹配任何非字母数字下划线字符,它相当于在字符集中使用[a-z A-Z 0-9]： import re rule = \"\\W+\" string = \"user_name123 \\t\\n\\f\" resultList = re.findall(pattern=rule, string=string) print(resultList) # [' \\t\\n\\x0c'] 原始字符串 下面这种情况，可能导致re匹配的结果和预料的结果不符。 我想匹配1个\\或者\\d： import re rule = \"[\\\\d]\" string = \"123\\\\456\\\\\" resultList = re.findall(pattern=rule, string=string) print(resultList) # ['1', '2', '3', '4', '5', '6'] 是什么原因导致了这样的情况？由于re模块建立在Python解释器之上，所以\\\\d会被分解成\\d，故会出现这样的情况。如下图所示： 如何解决这个问题呢？你可能想使用这个匹配规则： rule = \"[\\\\\\\\d]\" 但是这样的匹配结果是： ['\\\\', '\\\\'] d被当成了单独的普通匹配字符了。 其实最有效的办法是对rule采用原始字符串处理： import re rule = r\"[\\\\\\d]\" string = \"123\\\\456\\\\\" resultList = re.findall(pattern=rule, string=string) print(resultList) # ['1', '2', '3', '\\\\', '4', '5', '6', '\\\\'] 所以无论今后在什么场合下，对于rule都使用原始字符串定义就ok了。 管道 | 管道符 |管道符相当于或，注意与字符集里的区别，管道符将前后分为2段，左右看做1个整体，而字符集中的或仅仅代表从众多选项中拿出1个。 如下所示，匹配abc123或者456xyz的子串： import re rule = r\"abc123|456xyz\" string = \"abcdefgabc123xyzqud456xyz\" resultList = re.findall(pattern=rule, string=string) print(resultList) # ['abc123', '456xyz'] 分组 推荐在分组时，使用re.search()或者re.match()进行操作。 () 分组符 ()分组符将多个元素字符看做一个整体，也就是将它们当做一个元素字符进行匹配。若整个匹配规则中无子分组，则默认的匹配结果为一组： 如下，没有定义子分组，则默认的匹配结果为1组。 因此可通过group(0)方法获取整组内容： import re rule = r\".*\" string = \"hello world\" searchObject = re.search(pattern=rule, string=string) print(searchObject.group(0)) # hello world 匿名分组 匿名分组即没有名字的分组，单纯的用括号包裹即可。 如果定义了子分组，则可以通过groups()方法来查看所有的子分组。 如下所示，定义了3个匿名分组，分别是拿到标签名字，标签内容，标签结束 import re rule = r\"(.*)\" string = \"hello world\" searchObject = re.search(pattern=rule, string=string) print(searchObject.groups()) # ('div', 'hello world', 'div') 具名分组 具名分组的意思是为每一个子分组取一个别名。 语法是(?P\\regexp)，对于具名分组来说，可以使用方法groupdict()来查看分组的名字和分组匹配到的内容。 如下所示，定义了3个具名分组，分别是拿到标签名字，标签内容，标签结束： import re rule = r\"\\w+)>(?P.*)\\1)>\" string = \"hello world\" searchObject = re.search(pattern=rule, string=string) print(searchObject.groupdict()) # {'tagName': 'div', 'tagContext': 'hello world', 'tagEnd': 'div'} 分组引用 没有定义子分组时，整个匹配结果就是1个分组，编号为0. 而定义了子分组后，子分组的编号从1开始，向后排列，如下图所示： 我们可以利用这个索引编号在后面引用前面分组匹配的内容作为后面的匹配规则，语法格式如下： \\编号 示例如下所示： import re rule = r\"(.*)\" string = \"hello world\" searchObject = re.search(pattern=rule, string=string) print(searchObject.groups()) # ('div', 'hello world', 'div') 分组1匹配到什么，后面的\\1的匹配规则就是什么。 如果字符串变成了这个样子就会抛出异常，匹配不到。 因为分组1匹配到的内容是div，所以\\1也只能匹配div： string = \"hello world\" 如果前面分组是1个具名分组，后面也可以通过名字进行引用，语法格式如下： (?P=分组名) 示例如下所示： import re rule = r\"\\w+)>(?P.*)(?P=tagName))>\" string = \"hello world\" searchObject = re.search(pattern=rule, string=string) print(searchObject.groupdict()) # {'tagName': 'div', 'tagContext': 'hello world', 'tagEnd': 'div'} 取消记录 每一个子分组都具有编号，如果想取消某个子分组的编号，则可以使用(?:)来进行分组，若这样做则该子分组不可被后面引用，也不可被获取到，如下示例： import re rule = r\"(.*)\" string = \"hello world\" searchObject = re.search(pattern=rule, string=string) print(searchObject.groups()) # ('hello world',) 可以看见，只有1个子分组。 断言匹配 断言匹配虽然都有1个括号，但它们并不是子分组。 故括号中的内容也不会当做结果进行保持，可以将它们理解为匹配时的条件。 (?=exp) 零宽先行断言匹配后面为exp的内容。 如下示例，匹配后面是world的内容： import re rule = r\".+(?=world)\" string = \"hello world\" searchObject = re.search(pattern=rule, string=string) print(searchObject.group(0)) # hello (? 零宽后行断言，匹配前面为exp的内容。 如下示例，匹配前面是hello的内容： import re rule = r\"(?(?!exp) 零宽负向先行断言，匹配后面不能是exp的内容。 如下示例，匹配hello后面不能是Java的内容： import re rule = r\"hello (?!Java).*\" string = \"hello Java hello Golang hello Python\" searchObject = re.search(pattern=rule, string=string) print(searchObject.group(0)) # hello Golang hello Python (? (? 如下示例，匹配hello前面不能是Golang的内容： import re rule = r\"(?re方法 findall() 将所有的匹配结果返回至1个列表中。 其实说实话这种方法在日常开发中也很少用到，由于直接返回的是1个列表，所以比较占用内存。 import re rule = r\"\\d+\" string = \"123A567\" resultList = re.findall(pattern=rule, string=string) print(resultList) # ['123', '567'] finditer() 将所有的匹配结果返回至1个迭代器中。 finditer()比findall()更节省内存，因此推荐使用。 import re rule = r\"\\d+\" string = \"123A567\" resultIter = re.finditer(pattern=rule, string=string) print(resultIter) # search() 将首次匹配的结果返回至search对象中，可通过group()进行取值。 这个方法是最常用的方法，推荐使用，但是只能返回首次的匹配结果： import re rule = r\"\\d+\" string = \"123A567\" searchObject = re.search(pattern=rule, string=string) print(searchObject) # match() 在search()基础上添加了^，使之只能在开头匹配。 这个方法用到的场景也不多吧，简单介绍一下： import re rule = r\"\\d+\" string = \"123A567\" searchObject = re.match(pattern=rule, string=string) print(searchObject) # group() 通过该方法对search对象进行取值操作，返回一个或者多个匹配的子组。 可以取值的情况： 当没有分组时默认取大组，直接使用group()方法或指定编号0 能对匿名的子组进行取值，输入子组编号即可，子组编号从1开始 能对具名的子组进行取值，输入子组别名即可 我们上面介绍过，默认最大的组就是所有匹配结果，编号为0. 子组编号从1开始向后排列，通过该方法可以取出任意一个分组。 如，没有子组，可以使用group(0)或者直接使用group()取出最大的默认组： import re rule = r\".+\" string = \"123A567\" searchObject = re.search(pattern=rule, string=string) print(searchObject.group()) # 123A567 如果有多分组，则可以指定1个或者多个子组的编号，将它们取出来： import re rule = r\"(\\d+)([A-Z])(\\d+)\" string = \"123A567\" searchObject = re.search(pattern=rule, string=string) print(searchObject.group(0, 1, 2, 3)) # ('123A567', '123', 'A', '567') 如果有具名分组，则可以指定分组名将它们取出来： import re rule = r\"(?P\\d+)(?P[A-Z])(?P\\d+)\" string = \"123A567\" searchObject = re.search(pattern=rule, string=string) print(searchObject.group(0, \"first\", \"second\", \"last\")) # ('123A567', '123', 'A', '567') groups() 通过该方法对search对象进行取值操作，返回一个元组，包含所有匹配的子组。 注意事项： 它不能返回最大组，仅能以元组的方式返回所有的子组 能返回匿名子组、具名子组 示例如下，groups()不能像group()那样指定组的编号进行取值，它直接返回的就是1个元组： import re rule = r\"(?P\\d+)(?P[A-Z])(?P\\d+)\" string = \"123A567\" searchObject = re.search(pattern=rule, string=string) print(searchObject.groups()) # ('123A567', '123', 'A', '567') groupdict() 通过该方法对search对象进行取值操作，返回一个字典，包含了所有的具名子组 注意事项： 它不能返回最大组，仅能以字典的方式返回所有的具名子组 不能返回匿名子组 示例如下： import re rule = r\"(?P\\d+)(?P[A-Z])(?P\\d+)\" string = \"123A567\" searchObject = re.search(pattern=rule, string=string) print(searchObject.groupdict()) # {'first': '123', 'second': 'A', 'last': '567'} split() 对字符串进行分割，其算法可能导致令人意外的情况发生。 函数签名如下： def split(pattern, string, maxsplit=0, flags=0): 参数释义： pattern：匹配规则 string：被切分的字符串 maxsplit：最大切分的次数 flags：匹配模式 普通的3个小示例： import re # 按空格切分 print(re.split(r\" \", \"hello abc def\")) # ['hello', 'abc', 'def'] # 按空格或 | 分 print(re.split(r\" |\\|\",\"hello abc|def\")) # ['hello', 'abc', 'def'] # 按空格或 | 分 print(re.split(r\"[ |]\",\"hello abc|def\")) # ['hello', 'abc', 'def'] 意外的情况示例： import re # 先按照a切分，后按照b切分 print(re.split(r\"[ab]\",\"asdabcd\")) # 第一次按a来分：['', 'sd', 'bcd'] # 第二次按b来分: ['', 'sd', '', 'cd'] # 按b的分法由于是空。故前进一位 # 结果 # ['', 'sd', '', 'cd'] sub() 对字符串进行替换，最少需要3个参数，返回一个新的字符串。 函数签名如下： def sub(pattern, repl, string, count=0, flags=0): 参数释义： pattern：匹配规则 repl：新的字符 string：被替换的字符串 count：替换次数 flags：匹配模式 示例如下： import re print(re.sub(r\"a|b\", \"N\", \"123a456b\")) # 123N456N subn() 对字符串进行替换，最少需要3个参数，返回一个元祖，其中包含了替换成功了几次。 函数签名如下： def subn(pattern, repl, string, count=0, flags=0): 参数释义： pattern：匹配规则 repl：新的字符 string：被替换的字符串 count：替换次数 flags：匹配模式 示例如下： import re print(re.subn(r\"a|b\", \"N\", \"123a456b\")) # ('123N456N', 2) complie() complie()可以将一个标示符赋予指定的规则，达到简化重复操作的目的。 函数签名如下： def compile(pattern, flags=0): 参数释义： pattern：匹配规则 flags：匹配模式 示例演示，我有一个HTML文档。现在，我要匹配每个a标签的链接、a标签的内容： import re #　step01：指定匹配规则 rule = re.compile(r\"(.*)\", flags=re.I) # step02: 书写HTML文档 htmlDocument = \"\"\" 百度搜索 谷歌搜索 必应搜索 \"\"\" # step03:开始匹配 resultList = rule.findall(htmlDocument) print(resultList) # [('www.baidu.com', '百度搜索'), ('www.google.com', '谷歌搜索'), ('www.biying.com', '必应搜索')] re模式 re.I I模式下不区分大小写，此模式下[a-z]等同于[a-zA-Z]： import re rule = \"[a-z]+\" string = \"ABC1abc\" resultList = re.findall(pattern=rule, string=string, flags=re.I) print(resultList) # ['ABC', 'abc'] re.M M模式下会将每一行单独匹配，主要是对^和$的修饰。 如下示例，匹配必须以j开头且为p结尾的子串： import re rule = \"^J.+t$\" string = \"Python\\nJavaScript\\nGolang\" resultList = re.findall(pattern=rule, string=string, flags=re.M) print(resultList) # ['JavaScript'] re.S S模式下会将多行视为单行，这意味着.通配符可以匹配\\n了。 import re rule = \".+\" string = \"\\n\\n\\n\\n\\n\" resultList = re.findall(pattern=rule, string=string, flags=re.S) print(resultList) # ['\\n\\n\\n\\n\\n'] re.U U模式使用的不多，主要针对占4个Bytes的字符进行匹配支持，尽在Python2中适用，因为Python3里的字符都是Unicode字符了。 import re rule = \"𝒳𝒴\" string = \"𝒳𝒴𝒳𝒴𝒳𝒴\" resultList = re.findall(pattern=rule, string=string, flags=re.U) print(resultList) # ['𝒳𝒴', '𝒳𝒴', '𝒳𝒴'] 通用正则表达式大全 原文转载至：Java后端 原文地址：点我跳转 数字校验 数字：^[0-9]*$ n位的数字：^\\d{n}$ 至少n位的数字：^\\d{n,}$ m-n位的数字：^\\d{m,n}$ 零和非零开头的数字：^(0|[1-9][0-9]*)$ 非零开头的最多带两位小数的数字：^([1-9][0-9]*)+(.[0-9]{1,2})?$ 带1-2位小数的正数或负数：^(\\-)?\\d+(\\.\\d{1,2})?$ 正数、负数、和小数：^(\\-|\\+)?\\d+(\\.\\d+)?$ 有两位小数的正实数：^[0-9]+(.[0-9]{2})?$ 有1~3位小数的正实数：^[0-9]+(.[0-9]{1,3})?$ 非零的正整数：^[1-9]\\d*$ 或 ^([1-9][0-9]*){1,3}$ 或 ^\\+?[1-9][0-9]*$ 非零的负整数：^\\-[1-9][]0-9\"*$ 或 ^-[1-9]\\d*$ 非负整数：^\\d+$ 或 ^[1-9]\\d*|0$ 非正整数：^-[1-9]\\d*|0$ 或 ^((-\\d+)|(0+))$ 非负浮点数：^\\d+(\\.\\d+)?$ 或 ^[1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*|0?\\.0+|0$ 非正浮点数：^((-\\d+(\\.\\d+)?)|(0+(\\.0+)?))$ 或 ^(-([1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*))|0?\\.0+|0$ 正浮点数：^[1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*$ 或 ^(([0-9]+\\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\\.[0-9]+)|([0-9]*[1-9][0-9]*))$ 负浮点数：^-([1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*)$ 或 ^(-(([0-9]+\\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\\.[0-9]+)|([0-9]*[1-9][0-9]*)))$ 浮点数：^(-?\\d+)(\\.\\d+)?$ 或 ^-?([1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*|0?\\.0+|0)$ 字符校验 汉字：^[\\u4e00-\\u9fa5]{0,}$ 英文和数字：^[A-Za-z0-9]+$ 或 ^[A-Za-z0-9]{4,40}$ 长度为3-20的所有字符：^.{3,20}$ 由26个英文字母组成的字符串：^[A-Za-z]+$ 由26个大写英文字母组成的字符串：^[A-Z]+$ 由26个小写英文字母组成的字符串：^[a-z]+$ 由数字和26个英文字母组成的字符串：^[A-Za-z0-9]+$ 由数字、26个英文字母或者下划线组成的字符串：^\\w+$ 或 ^\\w{3,20} 中文、英文、数字包括下划线：^[\\u4E00-\\u9FA5A-Za-z0-9_]+$ 中文、英文、数字但不包括下划线等符号：^[\\u4E00-\\u9FA5A-Za-z0-9]+$ 或 ^[\\u4E00-\\u9FA5A-Za-z0-9]{2,20}$ 可以输入含有^%&',;=?$\\\"等字符：[^%&',;=?$\\x22]+ 禁止输入含有~的字符[^~\\x22]+ 其他校验 .*匹配除 \\n 以外的任何字符。 /[\\u4E00-\\u9FA5]/ 汉字 /[\\uFF00-\\uFFFF]/ 全角符号 /[\\u0000-\\u00FF]/ 半角符号 钱币校验 1.有四种钱的表示形式我们可以接受:\"10000.00\" 和 \"10,000.00\", 和没有 \"分\" 的 \"10000\" 和 \"10,000\"：^[1-9][0-9]*$ 2.这表示任意一个不以0开头的数字,但是,这也意味着一个字符\"0\"不通过,所以我们采用下面的形式：^(0|[1-9][0-9]*)$ 3.一个0或者一个不以0开头的数字.我们还可以允许开头有一个负号：^(0|-?[1-9][0-9]*)$ 4.这表示一个0或者一个可能为负的开头不为0的数字.让用户以0开头好了.把负号的也去掉,因为钱总不能是负的吧.下面我们要加的是说明可能的小数部分：^[0-9]+(.[0-9]+)?$ 5.必须说明的是,小数点后面至少应该有1位数,所以\"10.\"是不通过的,但是 \"10\" 和 \"10.2\" 是通过的：^[0-9]+(.[0-9]{2})?$ 6.这样我们规定小数点后面必须有两位,如果你认为太苛刻了,可以这样：^[0-9]+(.[0-9]{1,2})?$ 7.这样就允许用户只写一位小数.下面我们该考虑数字中的逗号了,我们可以这样：^[0-9]{1,3}(,[0-9]{3})*(.[0-9]{1,2})?$ 8.1到3个数字,后面跟着任意个 逗号+3个数字,逗号成为可选,而不是必须：^([0-9]+|[0-9]{1,3}(,[0-9]{3})*)(.[0-9]{1,2})?$ 生活需求 Email地址：^\\w+([-+.]\\w+)*@\\w+([-.]\\w+)*\\.\\w+([-.]\\w+)*$ 域名：[a-zA-Z0-9][-a-zA-Z0-9]{0,62}(/.[a-zA-Z0-9][-a-zA-Z0-9]{0,62})+/.? InternetURL：[a-zA-z]+://[^\\s]* 或 ^http://([\\w-]+\\.)+[\\w-]+(/[\\w-./?%&=]*)?$ 手机号码：^(13[0-9]|14[5|7]|15[0|1|2|3|5|6|7|8|9]|18[0|1|2|3|5|6|7|8|9])\\d{8}$ 电话号码(\"XXX-XXXXXXX\"、\"XXXX-XXXXXXXX\"、\"XXX-XXXXXXX\"、\"XXX-XXXXXXXX\"、\"XXXXXXX\"和\"XXXXXXXX)：^(\\(\\d{3,4}-)|\\d{3.4}-)?\\d{7,8}$ 国内电话号码(0511-4405222、021-87888822)：\\d{3}-\\d{8}|\\d{4}-\\d{7} 身份证号(15位、18位数字)：^\\d{15}|\\d{18}$ 短身份证号码(数字、字母x结尾)：^([0-9]){7,18}(x|X)?$ 或 ^\\d{8,18}|[0-9x]{8,18}|[0-9X]{8,18}?$ 帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：^[a-zA-Z][a-zA-Z0-9_]{4,15}$ 密码(以字母开头，长度在6~18之间，只能包含字母、数字和下划线)：^[a-zA-Z]\\w{5,17}$ 强密码(必须包含大小写字母和数字的组合，不能使用特殊字符，长度在8-10之间)：^(?=.*\\d)(?=.*[a-z])(?=.*[A-Z]).{8,10}$ 日期格式：^\\d{4}-\\d{1,2}-\\d{1,2} 一年的12个月(01～09和1～12)：^(0?[1-9]|1[0-2])$ 一个月的31天(01～09和1～31)：^((0?[1-9])|((1|2)[0-9])|30|31)$ xml文件：^([a-zA-Z]+-?)+[a-zA-Z0-9]+\\\\.[x|X][m|M][l|L]$ 中文字符的正则表达式：[\\u4e00-\\u9fa5] 双字节字符：[^\\x00-\\xff] (包括汉字在内，可以用来计算字符串的长度(一个双字节字符长度计2，ASCII字符计1)) 空白行的正则表达式：\\n\\s*\\r (可以用来删除空白行) HTML标记的正则表达式：]*>.*?| (网上流传的版本太糟糕，上面这个也仅仅能部分，对于复杂的嵌套标记依旧无能为力) 首尾空白字符的正则表达式：^\\s*|\\s*$或(^\\s*)|(\\s*$) (可以用来删除行首行尾的空白字符(包括空格、制表符、换页符等等)，非常有用的表达式) 腾讯QQ号：[1-9][0-9]{4,} (腾讯QQ号从10000开始) 中国邮政编码：[1-9]\\d{5}(?!\\d) (中国邮政编码为6位数字) IP地址：\\d+\\.\\d+\\.\\d+\\.\\d+ (提取IP地址时有用) IP地址：((?:(?:25[0-5]|2[0-4]\\\\d|[01]?\\\\d?\\\\d)\\\\.){3}(?:25[0-5]|2[0-4]\\\\d|[01]?\\\\d?\\\\d)) IP-v4地址：\\\\b(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\\\b (提取IP地址时有用) 校验IP-v6地址:(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])) 子网掩码：((?:(?:25[0-5]|2[0-4]\\\\d|[01]?\\\\d?\\\\d)\\\\.){3}(?:25[0-5]|2[0-4]\\\\d|[01]?\\\\d?\\\\d)) 校验日期:^(?:(?!0000)[0-9]{4}-(?:(?:0[1-9]|1[0-2])-(?:0[1-9]|1[0-9]|2[0-8])|(?:0[13-9]|1[0-2])-(?:29|30)|(?:0[13578]|1[02])-31)|(?:[0-9]{2}(?:0[48]|[2468][048]|[13579][26])|(?:0[48]|[2468][048]|[13579][26])00)-02-29)$(“yyyy-mm-dd“ 格式的日期校验，已考虑平闰年。) 抽取注释： 查找CSS属性:^\\\\s*[a-zA-Z\\\\-]+\\\\s*[:]{1}\\\\s[a-zA-Z0-9\\\\s.#]+[;]{1} 提取页面超链接:(]*)(href=\"https?:\\\\/\\\\/)((?!(?:(?:www\\\\.)?'.implode('|(?:www\\\\.)?', $follow_list).'))[^\" rel=\"external nofollow\" ]+)\"((?!.*\\\\brel=)[^>]*)(?:[^>]*)> 提取网页图片:\\\\]*[src] *= *[\\\\\"\\\\']{0,1}([^\\\\\"\\\\'\\\\ >]*) 提取网页颜色代码:^#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$ 文件扩展名效验:^([a-zA-Z]\\\\:|\\\\\\\\)\\\\\\\\([^\\\\\\\\]+\\\\\\\\)*[^\\\\/:*?\"<>|]+\\\\.txt(l)?$ 判断IE版本：^.*MSIE [5-8](?:\\\\.[0-9]+)?(?!.*Trident\\\\/[5-9]\\\\.0).*$ Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-07-31 13:48:13 "},"Python/Python模块与包/importlib.html":{"url":"Python/Python模块与包/importlib.html","title":"内置模块：importlib","keywords":"","body":"importlib简介 importlib模块作为Python内置模块，提供了更多导入模块的方式。 官方文档 常用方法： importlib.import_module(str)：根据字符串导入1个模块，该字符串以.为路径分割，如\"package.module\" 项目示例 假设我的项目之中包含了多个中间件，并且这些中间件会在项目正式启动之前先行启动。 我该如何集中式的管理这些中间件，让它们在需要的时候能够快速加上，不需要的时候能够快速去除呢？ 使用importlib模块是最明智的选择，整个项目目录如下： PYTHONPROJECT │ ├─bin │ | run.py │ ├─middleware │ │ first_middle.py │ │ init.py │ │ second_middle.py │ │ __init__.py │ ├─view │ │ main.py │ │ settings.py 首先先查看一下run.py，它主要处理项目模块路径、中间件初始化以及主程序的运行： #　run.py import os import sys BASE_DIR = os.path.dirname(os.path.dirname(__file__)) sys.path.append(BASE_DIR) from middleware.init import init from view.main import main if __name__ == \"__main__\": # init middleware init() # run main main() 再来看一下中间件的启动，它会从配置文件中拿到被集中化管理的需要启动的中间件，然后利用importlib模块对其进行导入后执行其下的某一个方法： # middleware/init.py import importlib import settings def init(): for stringPath in settings.LOAD_MIDDLEWARE: modulePath, funcName = stringPath.rsplit(\".\", maxsplit=1) # 利用importlib模块根据字符串路径导入模块 module = importlib.import_module(modulePath) # 模块也是对象，所以利用反射拿到函数对象并执行 funcObject = getattr(module, funcName) funcObject() 被集中管理的需要加载的中间件被定义在了settings.py的1个列表中。 其中每条数据项代表1个需要被加载的中间件，以BASE_DIR为准，用.进行分割，确定了中间件的导入路径与运行函数： # settings.py LOAD_MIDDLEWARE = [ \"middleware.first_middle.m1\", \"middleware.second_middle.m2\" ] 当后续需要新增中间件，只需要在middleware包中添加好.py文件并且在settings.py中按照格式把路径和运行函数填入即可。 如果要取消某个中间件的加载，直接在列表中对它进行注释即可。 总结2点： 如何规定模块导入的格式，参见LOAD_MIDDLEWARE列表 如何使用importlib快速导入模块且执行模块下的某一个函数，参见init.py文件 把其他代码也补上吧，中间件的启动函数： # middleware/first_middle.py def m1(): print(\"middleware 1 run..\") # middleware/second_middle.py def m2(): print(\"middleware 2 run..\") 主程序函数： # view/main.py def main(): print(\"view main run...\") 运行结果： middleware 1 run.. middleware 2 run.. view main run... Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-13 20:41:50 "},"Python/Python模块与包/collections.html":{"url":"Python/Python模块与包/collections.html","title":"内置模块：collections","keywords":"","body":"collections简介 collections模块提供了许多容器的数据类型，是Python内置数据类型的一种升级。 官方文档 collections模块所提供的内置容器或者基类如下所示： 容器/基类 描述 namedtuple() 创建命名元组子类的工厂函数 deque 类似列表(list)的容器，实现了在两端快速添加(append)和弹出(pop) ChainMap 类似字典(dict)的容器类，将多个映射集合到一个视图里面 Counter 字典的子类，提供了可哈希对象的计数功能 OrderedDict 字典的子类，保存了他们被添加的顺序 defaultdict 字典的子类，提供了一个工厂函数，为字典查询提供一个默认值 UserDict 封装了字典对象，简化了字典子类化 UserList 封装了列表对象，简化了列表子类化 UserString 封装了列表对象，简化了字符串子类化 ChainMap ChainMap能够让多个字典链接起来，返回类似于字典视图的功能，可以直接将多个互相分离的字典当做1个大的整体字典来用，ChainMap支持所有字典方法，如get()，pop()等。 可能有的朋友会想，那为什么不新创建1个字典然后update()旧的字典呢？ 这是因为ChainMap和字典视图很相似，所以oldDict的数据如果发生更新，则ChainMap也会同步进行更新。 但使用dict.update()创建的newDict就没有这种特性了，它不会随着oldDict的数据改变而发生改变。 如下图所示： 快速使用 如下示例，将链接2个字典，组成英文字母大小写对照ASCII码表： from collections import ChainMap uppercaseAlphabet = {chr(i): i for i in range(65, 91)} lowercaseAlphabet = {chr(i): i for i in range(97, 123)} letterTable = ChainMap(uppercaseAlphabet, lowercaseAlphabet) print(letterTable) 生成的对象如下所示： ChainMap({'A': 65, 'B': 66, 'C': 67, 'D': 68, 'E': 69, 'F': 70, 'G': 71, 'H': 72, 'I': 73, 'J': 74, 'K': 75, 'L': 76, 'M': 77, 'N': 78, 'O': 79, 'P': 80, 'Q': 81, 'R': 82, 'S': 83, 'T': 84, 'U': 85, 'V': 86, 'W': 87, 'X': 88, 'Y': 89, 'Z': 90}, {'a': 97, 'b': 98, 'c': 99, 'd': 100, 'e': 101, 'f': 102, 'g': 103, 'h': 104, 'i': 105, 'j': 106, 'k': 107, 'l': 108, 'm': 109, 'n': 110, 'o': 111, 'p': 112, 'q': 113, 'r': 114, 's': 115, 't': 116, 'u': 117, 'v': 118, 'w': 119, 'x': 120, 'y': 121, 'z': 122}) maps ChainMap的底层其实是用了1个列表，来存放了oldDict的引用。 格式如下： [ {oldDict1..}, {oldDict2..}, ... ] 在查询时，如果oldDict1和oldDict2具有重复的key，则会查出oldDict1，因为它是挨个字典的向后进行查找，其他的操作也是同理： 如下示例，oldDict1和oldDict2都有为a的key，那么操纵ChainMap的a时必定先拿到oldDict1的a： from collections import ChainMap oldDict1 = {\"a\": 1, \"b\": 2, \"c\": 3} oldDict2 = {\"a\": 10, \"b\": 20, \"c\": 30} newMap = ChainMap(oldDict1, oldDict2) print(newMap.get(\"a\")) # 1 如果直接想操作oldDict2的a，则可以通过ChainMap.maps拿到存储字典映射的列表，指定索引值来操作第2个字典也就是oldDict2，示例如下： from collections import ChainMap oldDict1 = {\"a\": 1, \"b\": 2, \"c\": 3} oldDict2 = {\"a\": 10, \"b\": 20, \"c\": 30} newMap = ChainMap(oldDict1, oldDict2) print(newMap.maps[1].get(\"a\")) # 10 new_child(m=None) 该方法会在旧的ChainMap上生成1个新的ChainMap，并且新增1个空字典在最前面。 如下图所示： 代码示例： from collections import ChainMap oldDict1 = {\"a\": 1, \"b\": 2, \"c\": 3} oldDict2 = {\"a\": 10, \"b\": 20, \"c\": 30} oldMap = ChainMap(oldDict1, oldDict2) newMap = oldMap.new_child() print(newMap) # ChainMap({}, {'a': 1, 'b': 2, 'c': 3}, {'a': 10, 'b': 20, 'c': 30}) 你也可以选择，在使用该方法的时候传入1个新的字典，让它填补第1个位置： ... newMap = oldMap.new_child({\"new\": None}) print(newMap) # ChainMap({'new': None}, {'a': 1, 'b': 2, 'c': 3}, {'a': 10, 'b': 20, 'c': 30}) parents 返回ChainMap的父ChainMap，相较于子ChainMap来说，父ChainMap永远没有子ChainMap的第1个oldDict。 如下图所示： 示例如下： from collections import ChainMap oldDict1 = {\"a\": 1, \"b\": 2, \"c\": 3} oldDict2 = {\"a\": 10, \"b\": 20, \"c\": 30} oldMap = ChainMap(oldDict1, oldDict2) print(oldMap.parents) # ChainMap({'a': 10, 'b': 20, 'c': 30}) 使用场景 在官方文档中举例了一个非常好的使用场景。 有1个简单的脚本，它拥有一些默认的参数变量。 当启动该脚本时，会有以下3种情况发生： 如果在命令行启动脚本时，指定了参数，则使用命令行指定的参数 如果没有在命令行启动脚本时指定参数，则会查找os的环境变量试图获取该参数 如果os的环境变量中也没有该参数，则使用默认的参数 这里它就是用了ChainMap来实现的，具体代码如下，避免了大量的if和else，非常方便： import os import argparse from collections import ChainMap defaults = {'color': 'red', 'user': 'guest'} parser = argparse.ArgumentParser() parser.add_argument('-u', '--user') parser.add_argument('-c', '--color') namespace = parser.parse_args() command_line_args = {k: v for k, v in vars(namespace).items() if v} combined = ChainMap(command_line_args, os.environ, defaults) print(combined['color']) print(combined['user']) 测试1，命令行传入了参数： python3 demo.py -c Black -u Yunya Black Yunya 测试2，命令行和os的环境变量中都没有参数，则用默认的参数： python3 demo.py red guest Counter Counter能够快速的获取一个可迭代对象中每一个数据项所出现的次数。 因此可以用来做词频统计，排行榜等一类的工具。 Counter是Dict的派生类，故支持大部分的字典方法，如get()，pop()等。 序列记数 直接为Counter()传入1个可迭代对象，返回一个dict，包含数据项和出现次数，按照降序排列，如下所示： from collections import Counter seq = [\"A\", \"A\", \"B\", \"C\", \"C\", \"D\"] c = Counter(seq) print(c) # Counter({'A': 2, 'C': 2, 'B': 1, 'D': 1}) 计数获取 如果你想获取1个数据项的出现次数，可通过[]的操作或者get()方法来完成，像操纵字典一样操纵Counter即可。 值得一提的是，当Counter通过[item]来获取数据项出现次数的话，如果这个数据项不存在则会返回0，而不是抛出KeyError。 from collections import Counter seq = [\"A\", \"A\", \"B\", \"C\", \"C\", \"D\"] c = Counter(seq) print(c.get(\"A\")) print(c.get(\"Z\")) print(c[\"Z\"]) # 2 # None # 0 排行获取 Counter.most_common()会返回1一个列表，按照Counter的排列顺序从大到小进行返回，如下所示，返回出现次数最多的3个数据项： from collections import Counter seq = [\"A\", \"A\", \"B\", \"C\", \"C\", \"D\"] c = Counter(seq) print(sorted(c.most_common(3))) # [('A', 2), ('C', 2), ('B', 1)] 如果想返回出现次数最少的3个数据项该怎么办呢？ 如下所示： from collections import Counter seq = [\"A\", \"A\", \"B\", \"C\", \"C\", \"D\"] c = Counter(seq) print(sorted(c.items(), key=lambda li:li[1])[:3]) # [('B', 1), ('D', 1), ('A', 2)] 词频统计 打开一个文件，做词频统计： from collections import Counter result = Counter() with open(\"./data/input.txt\",\"r\") as f: while True: lines = f.read(1024).splitlines() if lines==[]: break lines = [lines[i].split(\" \") for i in range(len(lines))] words = [] for line in lines: words.extend(line) tmp = Counter(words) result+=tmp print (result.most_common(10)) deque deque是collections模块提供的一大杀器，名为双端队列。 虽然普通的list也能够在队列2端进行数据项操作，但诸如insert(0, item)， pop(0)等方法都会引起数据项在内存中的挪动，从而使这2个方法的时间复杂度降低到O(n)。 而deque针对insert(0, item)和pop(0)做出了优化，让它们的时间复杂度都降到了O(1)。 如果仅在队首、队尾做操作，那么使用双端队列是最合适的。 如果要在队列中部做操作，还是推荐使用list。 方法一览 下面是deque所提供的方法和属性： 方法/属性 描述 deque(iterable, maxlen) 返回新的双端队列，可指定该队列的最大容量，如果不指定最大容量，则内部会根据数据项个数进行自动扩容 append(item) 添加数据项至队尾 appendleft(item) 添加数据项至队首 clear() 清空队列中的数据项 copy() 创建一份浅拷贝 count(item) 返回item在队列中出现的次数 extend(iterable) 通过附加来自可迭代对象的数据项来扩展队列，数据项添加至队尾 extendleft(iterable) 通过附加来自可迭代对象的数据项来扩展队列，数据项添加至队首 index(item, start, stop) 返回第一个数据项在队列中出现位置的索引，若值不存在，则抛出ValueError，可指定start和stop的索引区间 insert(index, item) 在索引之前插入数据项 pop() 删除并弹出队尾的数据项，若队列为空则抛出IndexError popleft() 删除并弹出队首的数据项，若队列为空则抛出IndexError remove(item) 删除队列中第一次出现的数据项。如果不存在该数据项，则引发ValueError reverse() 翻转整个队列，返回None，即原地翻转 rotate(n=1) 如果为正数，将队尾n个数据项移动至队首，如果是负数，将队首n个数据项移至队尾 maxlen 返回队列的最大容量 除了以上方法和属性之外，deque还支持迭代，枚举，len(d), reversed(d), copy.copy(d), copy.deepcopy(d), 成员测试 in 操作符，和下标引用 d[-1]，但是不支持切片[::] 。 注意！len()和maxlen是不同的： len()取的是队列中以有多少个数据项 maxlen取的是队列中最多可容纳多少数据项 如下所示： from collections import deque q = deque(range(3), maxlen=10) print(q.maxlen) print(len(q)) # 10 # 3 此外，rotate()方法可以在队列中进行数据项的位置迁移，如下所示。 n为正数，将队尾n个数据项移动至队首： from collections import deque q = deque(range(5), maxlen=10) print(q) q.rotate(2) print(q) # deque([0, 1, 2, 3, 4], maxlen=10) # deque([3, 4, 0, 1, 2], maxlen=10) n为负数，将队首n个数据项移至队尾： from collections import deque q = deque(range(5), maxlen=10) print(q) q.rotate(-2) print(q) # deque([0, 1, 2, 3, 4], maxlen=10) # deque([2, 3, 4, 0, 1], maxlen=10) defaultdict defaultdict本身是一个字典，继承了dict类并覆写了__missing__()方法。 在实例化defaultdict对象时我们可以为字典设置1个默认值，当使用[key]获取value时，若[key]不存在将会返回默认值而不是直接抛出keyError。 快速使用 如下所示，在使用了defaultdict后，用[key]操作获取value时若key不存在则会返回设定的默认值： from collections import defaultdict dic = defaultdict(lambda : None) #　❶ dic[\"k1\"] = \"v1\" print(dic[\"k1\"]) print(dic[\"k2\"]) # v1 # None ❶：设定默认值，必须是1个可调用对象，将其返回值作为defaultdict的默认值 计数统计 统计数据项在列表中出现的次数，如果是普通的dict你可能需要这么做： li1 = [\"A\", \"A\", \"B\", \"C\", \"C\", \"D\"] dic = {} for item in li1: dic.setdefault(item, 0) dic[item] += 1 print(dic) # {'A': 2, 'B': 1, 'C': 2, 'D': 1} 如果是defaultdict，则可以让代码更精简一点： from collections import defaultdict li1 = [\"A\", \"A\", \"B\", \"C\", \"C\", \"D\"] dic = defaultdict(lambda: 0) for item in li1: dic[item] += 1 print(dic) # defaultdict( at 0x0127B6A8>, {'A': 2, 'B': 1, 'C': 2, 'D': 1}) namedtuple namedtuple翻译过来就是具名元组，因为元组的主要功能是数据的展示，如果能够将1个元组中每个数据项的意思也表达出来就更好了。 如下所示，一个普通的元组： (\"Jack\", 18, \"male\", \"123456\") 乍一看前3个你可能都能看懂是什么意思，那么最后1个呢？是不是一脸懵逼？ 而通过具名元组，你就能知道最后1个的意思了，如下所示： (name='Jack', age=18, gender='male', password='123456') 可能这里有的同学会说，那我为什么不用dict？而偏要这么麻烦的用collections中的namedtuple？ 别搞忘了，dict是可变类型，namedtuple则是继承了tuple的特性，是不可变的，数据仅作展示时使用具名元组是最好的选择。 此外，具名元组是元组的子类，所以可以使用所有元组的方法，除此之外它还新增了一些方法和属性。 对象创建 使用namedtuple()方法来初始化一个类。 函数签名如下： def namedtuple(typename, field_names, *, verbose=False, rename=False, module=None): pass 参数释义： typename：将要实例化出的类的名称 field_names：具名元组中每个字段的名称 ... 示例演示： from collections import namedtuple UserMessage = namedtuple(\"userMessage\", [\"name\", \"age\" ,\"gender\", \"password\"]) u = UserMessage(\"Jack\", 18, \"male\", \"123456\") print(u) # userMessage(name='Jack', age=18, gender='male', password='123456') _make() 若1个序列的数据项个数与具名元组类的字段个数相同，通过该方法可直接将这个序列传入并生成新的具名元组对象。 如下所示，u的数据项个数与具名元组类的字段个数相同，直接根据u创建1个具名元组对象： from collections import namedtuple UserMessage = namedtuple(\"userMessage\", [\"name\", \"age\" ,\"gender\", \"password\"]) u = (\"Jack\", 18, \"male\", \"123456\") print(UserMessage._make(u)) # userMessage(name='Jack', age=18, gender='male', password='123456') _asdict() 将具名元组对象转换为有序字典（注：不是dict，而是Orderdict）： from collections import namedtuple UserMessage = namedtuple(\"userMessage\", [\"name\", \"age\" ,\"gender\", \"password\"]) u = UserMessage(\"Jack\", 18, \"male\", \"123456\") print(u._asdict()) # OrderedDict([('name', 'Jack'), ('age', 18), ('gender', 'male'), ('password', '123456')]) _replace() 由于具名元组不可改变，所以通过该方法会生成1个新的具名元组，用于替换旧的具名元组中的某一个数据项值： from collections import namedtuple UserMessage = namedtuple(\"userMessage\", [\"name\", \"age\" ,\"gender\", \"password\"]) oldUser = UserMessage(\"Jack\", 18, \"male\", \"123456\") newUser = oldUser._replace(name=\"Tom\", password=\"abcdef\") print(newUser) # userMessage(name='Tom', age=18, gender='male', password='abcdef') _fields 返回具名元组的字段列表： from collections import namedtuple UserMessage = namedtuple(\"userMessage\", [\"name\", \"age\" ,\"gender\", \"password\"]) u = UserMessage(\"Jack\", 18, \"male\", \"123456\") print(u._fields) # ('name', 'age', 'gender', 'password') 字典转换 若想将具名元组转换为普通字典，可通过如下方法： from collections import namedtuple UserMessage = namedtuple(\"userMessage\", [\"name\", \"age\" ,\"gender\", \"password\"]) u = UserMessage(\"Jack\", 18, \"male\", \"123456\") print( dict(zip(u._fields, u[:])) ) # {'name': 'Jack', 'age': 18, 'gender': 'male', 'password': '123456'} 若想将普通字典转换为具名元组，可通过如下方法： from collections import namedtuple userDict = {'name': 'Jack', 'age': 18, 'gender': 'male', 'password': '123456'} UserMessage = namedtuple(\"userMessage\", [\"name\", \"age\" ,\"gender\", \"password\"]) print(UserMessage(**userDict)) # userMessage(name='Jack', age=18, gender='male', password='123456') OrderDict OrderDict见字生意，即有序字典。 但是Python3.6之后字典已经变的有序了，所以这里不再举例它的用法。 感兴趣可以参照collections的官方文档进行查阅。 继承基类 collections中提供了3个基类，分别是UserList，UserDict，UserString。 它们并没有什么实质性的功能，只是针对list、dict、string的C语言实现用Python重写了一遍。 如果你对这些数据类型的实现比较感兴趣，可翻阅一下它们的源码。 此外，如果在自定义序列时，也建议继承这3个类，而不是继承内置的3个类。 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-13 20:41:50 "},"Python/Python模块与包/itertools.html":{"url":"Python/Python模块与包/itertools.html","title":"内置模块：itertools","keywords":"","body":"itertools简介 itertools是Python内置模块，提供了大量为高效循环而创建的迭代器函数，当你有以下一些特殊需求时就可以使用它们，而不必再自己动手造轮子。 官方文档 由于提供的迭代器众多，故不可能每个都记得，这里放上摘自官网的迭代器一览表。 首先是无穷迭代器如下表所示，即能够无限被迭代的迭代器： 迭代器 实参 结果 示例 count() start, [step] start, start+step, start+2*step, … count(10) --> 10 11 12 13 14 ... cycle() p p0, p1, … plast, p0, p1, … cycle('ABCD') --> A B C D A B C D ... repeat() elem [,n] elem, elem, elem, … 重复无限次或n次 repeat(10, 3) --> 10 10 10 其次是可停止的迭代器： 迭代器 实参 结果 示例 accumulate() p [,func] p0, p0+p1, p0+p1+p2, … accumulate([1,2,3,4,5]) --> 1 3 6 10 15 chain() p, q, … p0, p1, … plast, q0, q1, … chain('ABC', 'DEF') --> A B C D E F chain.from_iterable() iterable – 可迭代对象 p0, p1, … plast, q0, q1, … chain.from_iterable(['ABC', 'DEF']) --> A B C D E F compress() data, selectors (d[0] if s[0]), (d[1] if s[1]), … compress('ABCDEF', [1,0,1,0,1,1]) --> A C E F dropwhile() pred, seq seq[n], seq[n+1], … 从pred首次真值测试失败开始 dropwhile(lambda x: x 6 4 1 filterfalse() pred, seq seq中pred(x)为假值的元素，x是seq中的元素。 filterfalse(lambda x: x%2, range(10)) --> 0 2 4 6 8 groupby() iterable[, key] 根据key(v)值分组的迭代器 islice() seq, [start,] stop [, step] seq[start:stop:step]中的元素 islice('ABCDEFG', 2, None) --> C D E F G starmap() func, seq func(seq[0]), func(seq[1]), … starmap(pow, [(2,5), (3,2), (10,3)]) --> 32 9 1000 takewhile() pred, seq seq[0], seq[1], …, 直到pred真值测试失败 takewhile(lambda x: x 1 4 tee() it, n it1, it2, … itn 将一个迭代器拆分为n个迭代器 zip_longest() p, q, … (p[0], q[0]), (p[1], q[1]), … zip_longest('ABCD', 'xy', fillvalue='-') --> Ax By C- D- 然后是排列组合迭代器： 迭代器 实参 结果 product() p, q, … [repeat=1] 笛卡尔积，相当于嵌套的for循环 permutations() p[, r] 长度r元组，所有可能的排列，无重复元素 combinations() p, r 长度r元组，有序，无重复元素 combinations_with_replacement() p, r 长度r元组，有序，元素可重复 product('ABCD', repeat=2) AA AB AC AD BA BB BC BD CA CB CC CD DA DB DC DD permutations('ABCD', 2) AB AC AD BA BC BD CA CB CD DA DB DC combinations('ABCD', 2) AB AC AD BC BD CD combinations_with_replacement('ABCD', 2) AA AB AC AD BB BC BD CC CD DD 自认为比较重要的方法有：chain()，zip_longset()，permutations()。 除此之外的方法局限性太强，不适合所有场景。 无穷迭代器 count() 创建1个迭代器，初始值是start，步长是step，结束是无限。 函数签名如下： itertools.count(start=0, step=1) 官方文档的实现： def count(start=0, step=1): # count(10) --> 10 11 12 13 14 ... # count(2.5, 0.5) -> 2.5 3.0 3.5 ... n = start while True: yield n n += step 注意，可以生成浮点数，这是range所不支持的。 cycle() 创建1个迭代器，对传入的可迭代对象元素进行无限复制。 函数签名如下： itertools.cycle(iterable) 官方文档的实现： def cycle(iterable): # cycle('ABCD') --> A B C D A B C D A B C D ... saved = [] for element in iterable: yield element saved.append(element) while saved: for element in saved: yield element repeat() 创建1个迭代器，对传入的可迭代对象进行无限复制，或通过times参数指定复制的次数： 函数签名如下： itertools.repeat(object[, times]) 官方文档的实现： def repeat(object, times=None): # repeat(10, 3) --> 10 10 10 if times is None: while True: yield object else: for i in range(times): yield object 可停止的迭代器 accumulate() 该函数可接收2个参数，1个可迭代对象和1个具有2参数的可调用对象，返回1个迭代器。 该迭代器的值生成基于可调用对象对传入数据项的处理。 函数签名如下： itertools.accumulate(iterable[, func]) 官方文档实现： def accumulate(iterable, func=operator.add): 'Return running totals' # accumulate([1,2,3,4,5]) --> 1 3 6 10 15 # accumulate([1,2,3,4,5], operator.mul) --> 1 2 6 24 120 it = iter(iterable) try: total = next(it) except StopIteration: return yield total for element in it: total = func(total, element) yield total 示例演示： import itertools print(list(itertools.accumulate(range(5), lambda x,y:x+y))) # [0, 1, 3, 6, 10] 过程解析： # range(5) lambda x,y : x+y # [0, 1, 2, 3, 4] # 第一次：返回0 -> [0] # 第二次：0 + 1 = 1 -> [0, 1] # 第三次：1 + 2 = 3 -> [0, 1, 3] # 第四次：3 + 3 = 6 -> [0, 1, 3, 6] # 第五次：4 + 6 = 10 -> [0, 1, 3, 6, 10] # 结果： # [0, 1, 3, 6, 10] chain() 该函数可接收无限多的可迭代对象，并将它们进行合并成1个迭代器进行返回。 函数签名如下： itertools.chain(*iterables) 官方文档实现： def chain(*iterables): # chain('ABC', 'DEF') --> A B C D E F for it in iterables: for element in it: yield element from_iterable() 该函数可接收一个多维度的可迭代对象，并将多维展开合并成1个平面迭代器进行返回。 函数签名如下： itertools.chain.from_iterable(iterable) 官方文档实现： def from_iterable(iterables): # chain.from_iterable(['ABC', 'DEF']) --> A B C D E F for it in iterables: for element in it: yield element compress 创建一个迭代器，它返回data中经selectors真值测试为True的元素。迭代器在两者较短的长度处停止。 函数签名如下： itertools.compress(data, selectors) 官方文档实现： def compress(data, selectors): # compress('ABCDEF', [1,0,1,0,1,1]) --> A C E F return (d for d, s in zip(data, selectors) if s) dropwhile() 创建一个迭代器，如果predicate为true，迭代器丢弃这些元素，然后返回其他元素。 注意，迭代器在predicate首次为false之前不会产生任何输出，所以可能需要一定长度的启动时间。 函数签名如下： itertools.dropwhile(predicate, iterable) 官方文档实现： def dropwhile(predicate, iterable): # dropwhile(lambda x: x 6 4 1 iterable = iter(iterable) for x in iterable: if not predicate(x): yield x break for x in iterable: yield x filterfalse() 创建一个迭代器，只返回iterable中predicate为False 的元素。如果predicate是None，返回真值测试为false的元素。 其实说白了就相当于filter()的反函数。 函数签名如下： itertools.filterfalse(predicate, iterable) 官方文档实现： def filterfalse(predicate, iterable): # filterfalse(lambda x: x%2, range(10)) --> 0 2 4 6 8 if predicate is None: predicate = bool for x in iterable: if not predicate(x): yield x islice() 创建一个迭代器，该函数接收3个参数，总体效果和切片取子序列类似，能指定开始位置、结束位置、步长等。 函数签名如下： itertools.islice(iterable, start, stop[, step] 官方文档实现： def islice(iterable, *args): # islice('ABCDEFG', 2) --> A B # islice('ABCDEFG', 2, 4) --> C D # islice('ABCDEFG', 2, None) --> C D E F G # islice('ABCDEFG', 0, None, 2) --> A C E G s = slice(*args) start, stop, step = s.start or 0, s.stop or sys.maxsize, s.step or 1 it = iter(range(start, stop, step)) try: nexti = next(it) except StopIteration: # Consume *iterable* up to the *start* position. for i, element in zip(range(start), iterable): pass return try: for i, element in enumerate(iterable): if i == nexti: yield element nexti = next(it) except StopIteration: # Consume to *stop*. for i, element in zip(range(i + 1, stop), iterable): pass starmap() 创建一个迭代器，使用从可迭代对象中获取的参数来计算该函数。当参数对应的形参已从一个单独可迭代对象组合为元组时（数据已被“预组对”）可用此函数代替 map()。map()与starmap()之间的区别可以类比 function(a,b)与function(*c)的区别。 函数签名如下： itertools.starmap(function, iterable) 官方文档实现： def starmap(function, iterable): # starmap(pow, [(2,5), (3,2), (10,3)]) --> 32 9 1000 for args in iterable: yield function(*args) 注意，function必须接收2个参数，而传入的Iterable也必须符合上述格式。 takewhile() 相当于filter()，创建一个迭代器，只要predicate为真就从可迭代对象中返回元素。 函数签名如下： itertools.takewhile(predicate, iterable) 官方文档实现： def takewhile(predicate, iterable): # takewhile(lambda x: x 1 4 for x in iterable: if predicate(x): yield x else: break zip_longset() 创建一个迭代器，从每个可迭代对象中收集元素。如果可迭代对象的长度未对齐，将根据fillvalue填充缺失值。迭代持续到耗光最长的可迭代对象。 函数签名如下： itertools.zip_longest(*iterables, fillvalue=None) 官方文档实现： class ZipExhausted(Exception): pass def zip_longest(*args, **kwds): # zip_longest('ABCD', 'xy', fillvalue='-') --> Ax By C- D- fillvalue = kwds.get('fillvalue') counter = len(args) - 1 def sentinel(): nonlocal counter if not counter: raise ZipExhausted counter -= 1 yield fillvalue fillers = repeat(fillvalue) iterators = [chain(it, sentinel(), fillers) for it in args] try: while iterators: yield tuple(map(next, iterators)) except ZipExhausted: pass 其他的迭代器 这里省略了2个迭代器，tee()和groupby()，因为我实在想不通在怎样的场景下会去使用它们.. 排序组合迭代器 product() 返回可迭代对象输入的笛卡儿积，存在重复元素。 函数签名如下： itertools.product(*iterables, repeat=1) 官方文档实现： def product(*args, repeat=1): # product('ABCD', 'xy') --> Ax Ay Bx By Cx Cy Dx Dy # product(range(2), repeat=3) --> 000 001 010 011 100 101 110 111 pools = [tuple(pool) for pool in args] * repeat result = [[]] for pool in pools: result = [x+[y] for x in result for y in pool] for prod in result: yield tuple(prod) permutations() 连续返回由iterable元素生成长度为r的排列。 如果r未指定或为None ，r默认设置为iterable的长度，这种情况下，生成所有全长排列。 排列依字典序发出。因此，如果iterable是已排序的，排列元组将有序地产出。 即使元素的值相同，不同位置的元素也被认为是不同的。如果元素值都不同，每个排列中的元素值不会重复。 函数签名如下： itertools.permutations(iterable, r=None 官方文档实现： def permutations(iterable, r=None): # permutations('ABCD', 2) --> AB AC AD BA BC BD CA CB CD DA DB DC # permutations(range(3)) --> 012 021 102 120 201 210 pool = tuple(iterable) n = len(pool) r = n if r is None else r if r > n: return indices = list(range(n)) cycles = list(range(n, n-r, -1)) yield tuple(pool[i] for i in indices[:r]) while n: for i in reversed(range(r)): cycles[i] -= 1 if cycles[i] == 0: indices[i:] = indices[i+1:] + indices[i:i+1] cycles[i] = n - i else: j = cycles[i] indices[i], indices[-j] = indices[-j], indices[i] yield tuple(pool[i] for i in indices[:r]) break else: return combinations() 返回由输入iterable中元素组成长度为 r 的子序列。 组合按照字典序返回。所以如果输入iterable是有序的，生成的组合元组也是有序的。 即使元素的值相同，不同位置的元素也被认为是不同的。如果元素各自不同，那么每个组合中没有重复元素。 函数签名如下： itertools.combinations(iterable, r) 官方文档实现： def combinations(iterable, r): # combinations('ABCD', 2) --> AB AC AD BC BD CD # combinations(range(4), 3) --> 012 013 023 123 pool = tuple(iterable) n = len(pool) if r > n: return indices = list(range(r)) yield tuple(pool[i] for i in indices) while True: for i in reversed(range(r)): if indices[i] != i + n - r: break else: return indices[i] += 1 for j in range(i+1, r): indices[j] = indices[j-1] + 1 yield tuple(pool[i] for i in indices) combinations_with_replacement() 返回由输入iterable中元素组成的长度为r的子序列，允许每个元素可重复出现。 组合按照字典序返回。所以如果输入iterable是有序的，生成的组合元组也是有序的。 不同位置的元素是不同的，即使它们的值相同。因此如果输入中的元素都是不同的话，返回的组合中元素也都会不同。 函数签名如下： itertools.combinations_with_replacement(iterable, r) 官方文档实现： def combinations_with_replacement(iterable, r): # combinations_with_replacement('ABC', 2) --> AA AB AC BB BC CC pool = tuple(iterable) n = len(pool) if not n and r: return indices = [0] * r yield tuple(pool[i] for i in indices) while True: for i in reversed(range(r)): if indices[i] != n - 1: break else: return indices[i:] = [indices[i] + 1] * (r - i) yield tuple(pool[i] for i in indices) Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-13 20:41:50 "},"Python/Python模块与包/functools.html":{"url":"Python/Python模块与包/functools.html","title":"内置模块：functools","keywords":"","body":"functools简介 functools是非常强大的内置模块，它提供了许多装饰器与函数，适用于对所有可调用对象的应用。 官方文档 这里主要着重介绍2种常用的函数与装饰器，它们适用于绝大部分的场景。 函数/装饰器 描述 partial() 冻结可调用对象的某些参数，因此该函数也被称为偏函数 @lru_cache 为函数提供缓存功能，当某一函数的两次调用参数均一致，则直接返回前一次调用的结果 在该模块中，我们之前也已经接触过它所提供的redue()与@warps装饰器，所以这里不再进行举例。 partial() 传入1个可调用对象和它的某一个或多个调用参数，返回1个新的可调用对象，并且该对象中的某些参数是被固定的。 函数签名如下： functools.partial(func, *args, **keywords) 官方文档实现： def partial(func, *args, **keywords): def newfunc(*fargs, **fkeywords): newkeywords = keywords.copy() newkeywords.update(fkeywords) return func(*args, *fargs, **newkeywords) newfunc.func = func newfunc.args = args newfunc.keywords = keywords return newfunc 示例演示： import functools def add(x, y): return x + y # newFunc = add(1, 2) newFunc = functools.partial(add, 1, 2) print(newFunc()) # 3 再来一个2进制转10进制的函数： import functools binToDecimal = functools.partial(int, base=2) print(binToDecimal(\"110\")) # 6 @lru_cache 一个为函数提供缓存功能的装饰器，缓存maxsize组传入参数，在下次以相同参数调用时直接返回上一次的结果。用以节约高开销或I/O函数的调用时间。 由于使用了字典存储缓存，所以被装饰的函数固定参数和关键字参数必须是可哈希的。 函数签名如下： @functools.lru_cache(maxsize=128, typed=False) 参数释义： 如果maxsize设置为None，LRU功能将被禁用且缓存数量无上限。maxsize设置为2的幂时可获得最佳性能。 如果typed设置为true，不同类型的函数参数将被分别缓存。例如，f(3)和f(3.0)将被视为不同而分别缓存。 一个简单的例子： 第一次运行函数，传入参数1和2，计算结果为3，缓存这2个参数和结果 第二次运行函数，传入参数1和2，查询缓存，缓存有就直接获得结果，根本不运行函数，所以没有看到print()的打印效果 第三次运行函数，传入参数1.0和2，查询缓存，由于typed为True，故严格区分浮点型和整形，再次运行函数，结果计算为3.0 如下示例： import functools @functools.lru_cache(maxsize=128, typed=True) def add(x, y): print(\"add run...\") return x+y print(add(1, 2)) print(add(1, 2)) print(add(1.0, 2)) # add run... # 3 # 3 # add run... # 3.0 乍一看之下好像没什么作用，不就是缓存了一下嘛，实际上，在对递归函数上加上该装饰器，性能将会得到质的提升。 如下示例了加上该装饰器函数求解上楼梯问题和不加该装饰器函数求解上楼梯问题的总计运行时间。 对35阶梯楼梯的计算，加了该装饰器的运行几乎是瞬间完成，而不加该装饰器大概需要耗费十秒左右： import functools import time @functools.lru_cache(maxsize=256, typed=False) def haveCache(n): if n == 1: return 1 if n == 2: return 2 return haveCache(n - 1) + haveCache(n - 2) def dontHaveCache(n): if n == 1: return 1 if n == 2: return 2 return dontHaveCache(n - 1) + dontHaveCache(n - 2) s = time.time() haveCache(35) print(\"HaveCache - >\", time.time() - s) s = time.time() dontHaveCache(35) print(\"dontHaveCache - >\", time.time() - s) # HaveCache - > 0.0 # dontHaveCache - > 11.06638216972351 如果最大缓存设为2，则运行时间会慢一点，但是32阶的上楼梯问题也是在短短0.2秒之内得到解决了： @functools.lru_cache(maxsize=2, typed=False) ... # HaveCache - > 0.23421168327331543 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-28 21:52:41 "},"Python/Python模块与包/模块包库框架的区别.html":{"url":"Python/Python模块与包/模块包库框架的区别.html","title":"模块包库框架的区别","keywords":"","body":"模块 Python中1个.py文件就是一个模块。 模块是指为了解决某一单独功能而专门诞生的。 如用户登录注册功能中包含验证码发送，针对这一个小功能可以单独拎出来做一个模块。 verification_code.py 包 包其实就是一个包含有__init__.py的文件夹。 一个包中可以包含另一个包，包的基础单元是由模块构成。 包将一些近似功能的模块组合到一起，如登录注册这2个大功能可以形成一个顶级包，可分为登录包、注册包、功能包3个子包： login_register/ # 顶级包：登录组成 ├── __init__.py │ ├── features # 子级包：功能类 │ └── verification_code.py # 发送验证码 │ │ ├── login # 子级包：登录类 │ ├── __init__.py │ ├── email.py # 邮箱登录 │ ├── phone.py # 手机登录 │ ├── qq.py # QQ登录 │ └── weichat.py # 微信登录 │ │ └── register # 子级包：注册类 ├── __init__.py ├── other.py # 其他注册 ├── email.py # 邮箱注册 └── phone.py # 手机注册 库 库更像是针对某个功能的解决工具包，一般来说由一个或多个包组成。 如想获取时间相关功能的操作，有内置库time进行提供。 如想获取日志相关功能的操作，有内置库logging进行提供。 再比如想获取网络功能的操作，有第三方库requests进行提供。 在Python中，很多人通常将一些内置库称为内置模块，严格意义上来说并不准确，应该叫做Python内置库更好一点。 框架 框架是一套通用的解决方案，通常由多个库组成。 使用框架能够提供一整套的服务，它将所有可能用到的资源进行了整合。 如想搭建一个网站，有Django框架可以快速完成需求。 如想进行数据分析，有Numpy框架可以助你锦上添花。 再比如想开始网络爬虫，有Scrapy框架可以让你进行花式爬取。 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-13 20:41:50 "},"Python/Python面向对象/summary.html":{"url":"Python/Python面向对象/summary.html","title":"Python面向对象","keywords":"","body":" 编程范式 类与对象 类的方法 属性代理 封装 继承 多态 抽象基类 自省反射 双下大全 描述符类 元类编程 异常处理 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-13 20:41:50 "},"Python/Python面向对象/编程范式.html":{"url":"Python/Python面向对象/编程范式.html","title":"编程范式","keywords":"","body":"编程范式 编程范式只是一种程序设计思维，本身并无优劣之分。 与任何语言都无关，不要觉得面向对象就一定比面向过程好，实际上恰恰相反。 面向过程才是所有代码在内存中最终的状态。 面向过程 面向过程（OPP）编程思想的重点是将注意力放在事物本身上，更多的是关心下一步操作该怎么做，以正在发生为目的。 将1个大的问题逐步拆解成多个小问题，一旦问题解决后代码上线将很少有改动的场景。 特性：模块化、流程化 优点：代码可读性高，并且性能高 缺点：不利于维护与扩展 著名的以面向过程思想为指导的设计产品有Linux内核，git等软件。 可以说如果一个项目是按照面向过程思维进行开发，它应该是从小的细节一步一步实现，最终变为一个整体。 面向对象 面向对象（OOP）编程思想是目前主流的编程思想，它在对业务的分析上更加侧重于应当由谁来完成这份工作，将注意力放在了人的上面，而并非事物本身。 特性：抽象、封装、继承、多态 优点：易于维护、易于扩展 缺点：继承使得代码耦合度提高，并且性能较于面向过程来说略有损失 面向对象的本质就是整合，将具有某一共同特性的不同功能整合到一起进行分类。 如果一个项目是按照面向对象思维进行开发，它应该是先构建整体大局观，然后进行细节的丰富，而细节的丰富又最终回到了面向过程的思维上，因此面向对象和面向过程是不可分离的。 面向切面 面向切面（AOP）编程思想是面向对象的一种衍生。它旨在与将主逻辑业务和副逻辑业务进行切分，让彼此之间最大限度的降低耦合度。 此外，面向切面也能够在不损失已有功能的前提下，植入一个新的功能。 如Python装饰器函数，就是面向切面编程思想的最好体现。 特性：分离，低耦合，高内聚 优点：对扩展及其友好，因为各部都是分离的所以新功能添加上不会有太多的问题产生 缺点：如果设计过于混乱，则会让代码可读性降低，如一味使用装饰器来进行缝补，还不如重构整个项目 面向接口 面向接口（PO）编程思想是近些年来逐渐火热起来的一种编程思想，它将抽象与实现互相抽离，先定义接口规范，后进行逻辑实现。 面向接口与面向对象相结合，能够让项目更加健壮，并且可读性扩展性都会得到一定程度的提升。 特性：现实与抽象分离，抽象定义规范，现实指定逻辑 优点：具有良好的扩展性，增强代码可读性，便与后期维护 缺点：大幅度增加代码量 函数式编程 函数式编程是与数学函数高度结合的编程方式，纯粹的函数式编程语言没有变量只有常量，代码重复率较低，且功能一旦完善就不会出错。 在函数中没有for循环，所有的for循环用递归实现，函数式编程的一个特点就是允许把函数本身作为参数传入另一个参数，还允许返回一个函数。 此外，Python中的lambda以及filter，map，reduce等等都是从一些函数式编程语言如haskell中提取出来的一些优秀且符合Python核心思想的好案例。 特性：无变量，无for循环 优点：代码重复率低 缺点：程序易读性差 Python特性 Python本身是一门纯粹的面向对象语言，除此之外它也支持： 面向切面：装饰器就是最好的面向切面实现 面向接口：严格意义上来说Python并未提供真正完全的面向接口语法，但仍然可以实现 函数式编程：lambda、filter、map等都是Python中拥有的函数式编程实现 一门优秀的语言总是融百家之长，Python当然也不例外。 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-13 20:41:50 "},"Python/Python面向对象/类与对象.html":{"url":"Python/Python面向对象/类与对象.html","title":"类与对象","keywords":"","body":"类和对象 类是一个抽象的概念，而对象是一个实体的存在。 对象由类创造而出，每个对象之间互相独立互不影响，一个对象只能由一个类创建，但是一个类可以创建出多个对象，而实例化就是指通过某个类创建出对象的过程。 类与对象的关系类似于模具与产品，必须先有模具，然后才能根据这个模具制作出各式各样的产品。 基础介绍 定义类 Python中定义类，使用class关键字，具体语法如下: class 类标示符(继承类): # ❶ \"\"\" 类的描述文档 # ❷ \"\"\" 标示符 = 对象 # ❸ def __init__(self): # ❹ self.标示符 = 对象 def 实例方法(self): # ❺ pass ❶：类标识符以大驼峰命名 ❷：类的描述文档，用于介绍该类的作用 ❸：类属性，用于存放所有实例对象都可能用到的变量 ❹：初始化方法，用于初始化实例对象独有属性变量 ❺：实例化方法，用于提供给实例对象调用的函数 当一个类被定义时，将会发生以下的事情： 申请内存空间，保存类体代码 将内存空间的地址绑定给类的标示符 创建类的局部命名空间（注意与函数命名空间区分，函数是加括号调用执行后才创建） 执行类体代码（注意与函数的执行时机区分，函数是加括号调用后才会执行函数体代码） 下面将定义一个人类： class Person: \"\"\" Person：人类 class attr：眼耳口鼻 每个人都具有共同特性，可定义为类属性 instance attr: 姓名性别年龄 每个人不同的特征，可定义为实例属性 instance method: 吃饭 每个人都具有共同行为，可定义为实例方法 \"\"\" eye = 2 ear = 2 mouth = 2 nose = 1 def __init__(self, name, age, gender) -> None: self.name = name self.age = age self.gender = gender def eat(self, food): return \"%s eating %s\"%(self.name, food) def getInfo(self): return \"name : %s\\nage : %s\\ngender : %s\\n\"%(self.name, self.age, self.gender) 实例化 如何通过类创建出一个具体的对象？只需要在类标示符后加上括号即可，如下所示： if __name__ == \"__main__\": jack = Person(name=\"Jack\", age=18, gender=\"male\") print(jack.eat(\"fish\")) print(jack.getInfo()) # Jack eating fish # name : Jack # age : 18 # gender : male 类实例化的过程中会做很多事情，大概可分为下面3个步骤： 调用类下的__new__()方法构建一个空的实例对象 调用类下的__init__()方法对空实例对象进行初始化 于此同时，创建实例的专属命名空间 如何验证这一过程呢？我们可通过自定义__new__()方法进行证明： class A: def __new__(cls, *args, **kwargs) -> object: print(\"Run ... new\") instanceObject = super(A, cls).__new__(cls) return instanceObject def __init__(self, attr): print(\"Run ... init\") self.instanceAttr = attr if __name__ == \"__main__\": instanceA = A(\"a\") # Run ... new # Run ... init self、__new()__、__init__() __new__()方法是类实例化过程中运行的方法，作用是构建空的实例化对象，因此该方法也被称之为构造方法。 __init__()方法也是类实例化过程中运行的方法，作用是为空的实例化对象增添实例属性，因此该方法也被称之为对象的初始化方法，注意该方法必须返回None。 self其实就是指实例化对象本身，在实例化操作开始后实例化对象会由__new__()方法经过__init__()方法进行创建并返回。 所以你会看见下面3个标示符都是指向同1个对象： class A: def __new__(cls, *args, **kwargs) -> object: print(\"Run ... new\") instanceObject = super(A, cls).__new__(cls) print(id(instanceObject)) return instanceObject def __init__(self) -> None: print(\"Run ... init\") print(id(self)) def getInstanceId(self): print(\"Run ... instance method\") print(id(self)) if __name__ == \"__main__\": print(\"instance start\") instanceA = A() print(\"instance end\") print(id(instanceA)) instanceA.getInstanceId() # instance start # Run ... new # 29435600 # Run ... init # 29435600 # instance end # 29435600 # Run ... instance method # 29435600 __dict__ 类和实例对象都有一个__dict__，它是一个字典，包含类和对象的一些特征属性。 对于类的__dict__来说，它包含类属性、类方法、实例方法等一系列东西。 而对实例的__dict__来说，它仅包含实例属性。 如下所示： class A: name = \"class\" def __init__(self) -> None: self.name = \"instance\" def instanceMethod(self): pass if __name__ == \"__main__\": instanceA = A() print(A.__dict__) print(instanceA.__dict__) 结果展示，类的__dict__，包含的东西非常多： {'__module__': '__main__', 'name': 'class', '__init__': , 'instanceMethod': , '__dict__': , '__weakref__': , '__doc__': None} 而实例对象的__dict__只包含自身的实例属性，甚至连实例方法都在类的__dict__中： {'name': 'instance'} 属性与方法 类属性 如果要在类的外部获取类属性，可通过下面两种方式： 类.属性 类.__dict__[\"属性\"] 更加推荐第一种方式，它更加的直白，让人一眼就能看到这是在获取属性，而不是操纵字典： class A: name = \"class\" def __init__(self) -> None: self.name = \"instance\" def instanceMethod(self): pass if __name__ == \"__main__\": print(A.name) print(A.__dict__[\"name\"]) print(A.__dict__.get(\"name\")) # class # class # class 其他的类属性增删改查，也都是通过这两种方式进行操作，这里不再举例。 实例属性 外部获取实例属性与类属性一样，都是通过下面2种方式： 实例.属性 实例.__dict__[\"属性\"] 如下所示： class A: name = \"class\" def __init__(self) -> None: self.name = \"instance\" def instanceMethod(self): pass if __name__ == \"__main__\": instanceA = A() print(instanceA.name) print(instanceA.__dict__[\"name\"]) print(instanceA.__dict__.get(\"name\")) # instance # instance # instance 其他的操作诸如增删改等，都比较少用到，故不再进行举例。 实例方法 实例方法其实就是函数，我们可以看一下下面这个方法： class A: name = \"class\" def __init__(self) -> None: self.name = \"instance\" def instanceMethod(self, params): print(params) 如何调用它呢？ 方式1，通过实例对象调用它，会自动的将对象本身传递给self： if __name__ == \"__main__\": instanceA = A() instanceA.instanceMethod(\"hello world\") # hello world 方式2，通过类来调用它，但是需要你手动的为self传递参数： class A: name = \"class\" def __init__(self) -> None: self.name = \"instance\" def instanceMethod(self, params): print(params) if __name__ == \"__main__\": instanceA = A() A.instanceMethod(instanceA, \"hello world\") 方式2可能比较少见，但我们之前已经用过了，比如str.format()。 def format(self, *args: object, **kwargs: object) -> str 相同的结果，不同的调用方式，如下所示，self就是字符串\"hello {}\"： classRunFormatMethod = str.format(\"hello {}\", \"world\") instanceRunFormatMethod = \"hello {}\".format(\"world\") print(classRunFormatMethod) print(instanceRunFormatMethod) # hello world # hello world 内部获取 类属性可以在实例方法中进行获取，获取方式有2种： 类.属性 self.属性 # 前提是self.__dict__中没有同名属性 推荐使用第一种，指名道姓的说我要获取类属性： class A: name = \"class\" def __init__(self) -> None: self.name = \"instance\" def instanceMethod(self): print(A.name) print(self.name) if __name__ == \"__main__\": instanceA = A() A.instanceMethod(instanceA) # class # instance 实例属性在实例方法中获取直接通过下面的方式即可： self.属性 如下所示： class A: name = \"class\" def __init__(self) -> None: self.name = \"instance\" def instanceMethod(self): print(self.name) if __name__ == \"__main__\": instanceA = A() A.instanceMethod(instanceA) # instance 实例方法中可以嵌套调用另一个方法，也可以调用外部的函数，如下所示： class A: name = \"class\" def __init__(self) -> None: self.name = \"instance\" def func1(self): print(\"func1\") self.func2() globalFunc() def func2(self): print(\"func2\") def globalFunc(): print(\"globalFunc\") if __name__ == \"__main__\": instanceA = A() instanceA.func1() # func1 # func2 # globalFunc 命名空间 类和实例的命名空间 类和实例的命名空间说白了就是__dict__字典。 一个类拥有多个实例，一个实例仅来自于一个类。 因此我们可以画出下面这幅图： 首先，类的命名空间是无法访问实例的命名空间的。 但是实例命名空间可以访问类的命名空间，类似于函数嵌套LEGB的关系。 标示符查找顺序 如果一个实例要查找某一个属性，自身存在就获取自身的，若自身不存在则取拿类的。 查看实例自身的__dict__，若没有 则查看类的__dict__，若没有 则抛出异常 我们来看一下下面这个例子： class A: name = \"ClassAttr:A\" if __name__ == \"__main__\": instanceOne = A() instanceTwo = A() instanceThree = A() print(instanceOne.name) print(instanceTwo.name) print(instanceThree.name) A.name = \"ClassAttr:B\" print(instanceOne.name) print(instanceTwo.name) print(instanceThree.name) instanceOne.name = \"InstanceAttr:a\" print(instanceOne.name) print(instanceTwo.name) print(instanceThree.name) # ClassAttr:A # ClassAttr:A # ClassAttr:A # ClassAttr:B # ClassAttr:B # ClassAttr:B # InstanceAttr:a # ClassAttr:B # ClassAttr:B 采用图解的方式来进行代码注释。 第一种情况，三个实例的__dict__中都没有name，所以会去类的__dict__中查找： 第二种情况，类__dict__中的name被修改，三个实例再次访问name，自身的__dict__没有故到类的__dict__中找，会获取到修改后的name： 第三种情况，第一个实例对象One的__dict__中具有实例属性name，故它会拿到自己的，其他2个实例对象都没有，依然会去拿类的： Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-13 20:41:50 "},"Python/Python面向对象/类的方法.html":{"url":"Python/Python面向对象/类的方法.html","title":"类的方法","keywords":"","body":"实例方法 实例方法是存储在类的__dict__字典中，实例方法都有一个固定的参数名为self，位于第一个位置。 实例方法通常会通过实例对象调用，当实例对象调用实例方法时，会自动的将自身传递给self。 如下所示： class Student: def __init__(self, name): self.name = name def show(self): return \"my name is %s\"%self.name if __name__ == \"__main__\": instanceOne = Student(\"Jack\") instanceTwo = Student(\"Tom\") print(instanceOne.show()) # self = instanceOne print(instanceTwo.show()) # self = instanceTwo # my name is Jack # my name is Tom 它的底层是怎么做的呢？ 其实还是要从属性查找顺序开始剖析，如下所示： 第一步：查找实例自身的__dict__试图获取实例方法，但实例方法都存于与类的__dict__中，故找不到 第二步：查找类的__dict__成功获取实例方法 第三步：根据类的__dict__中所定义的实例方法，自动的为self参数传递进调用者，生成一个新的方法 所以你会看见下面这样的场景，3个方法，3个存储空间： class Student: def __init__(self, name): self.name = name def show(self): return \"my name is %s\"%self.name if __name__ == \"__main__\": instanceOne = Student(\"Jack\") instanceTwo = Student(\"Tom\") print(instanceOne.show) print(instanceTwo.show) print(Student.show) # > # > # 类的方法 类方法是指头部带有@classmethod装饰器的方法，类方法都有一个固定的参数名为cls，位于第一个位置。 类方法通常由类进行调用，同时会自动的将类传递进方法cls参数中，如下所示： class Student: def __init__(self, name): self.name = name def show(self): return \"my name is %s\"%self.name @classmethod def learn(cls): print(cls.__name__) return \"students must learn\" if __name__ == \"__main__\": print(Student.learn()) # cls = Student # Student # students must learn 当然也可以通过实例对象调用类方法，cls接收的对象不是实例本身而是类，但是不建议这么做： class Student: def __init__(self, name): self.name = name def show(self): return \"my name is %s\"%self.name @classmethod def learn(cls): print(cls.__name__) return \"students must learn\" if __name__ == \"__main__\": instanceObject = Student(\"Jack\") print(instanceObject.learn()) # cls = Student # Student # students must learn 静态方法 静态方法是指头部带有@staticmethod装饰器的方法。 常作为类的工具箱出现，类和实例都可以随意的对其调用，没有自动传入的参数self或者cls，就是一个类中的普通函数： class MathTools: @staticmethod def getMax(x, y): return x if x > y else y if __name__ == \"__main__\": print(MathTools.getMax(1, 2)) instanceObject = MathTools() print(instanceObject.getMax(1, 2)) # 2 # 2 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-13 20:41:50 "},"Python/Python面向对象/属性代理.html":{"url":"Python/Python面向对象/属性代理.html","title":"属性代理","keywords":"","body":"属性代理 属性代理是指通过@property描述符装饰器来规定用户对类或者实例中某一属性的操作做出行为限制的方式。 类似于JavaScript中的代理器，Vue中的计算属性等，Python中则称之为描述符。 计算获取 　BMI指数是用来衡量一个人的体重与身高对健康影响的一个指标，计算公式为： BMI指数计算公式: BMI = 体重(kg) / (身高m**2) BMI正常值在20至25之间，超过25为超重，30以上则属肥胖 身高或体重是不断变化的，因而每次想查看BMI值都需要通过计算才能得到，但很明显BMI听起来更像是一个特征而非功能。 为此Python专门提供了一个装饰器@property，可以将类中的方法伪装成属性，对象在访问该特殊属性时会触发功能的执行，然后将返回值作为本次访问的结果，例如： class Person: def __init__(self, name, height, weight): self.name = name self.height = height self.weight = weight @property def bmi(self): v = self.weight / (self.height ** 2) if 20 25: return \"overweight\" return \"obesity\" if __name__ == \"__main__\": instanceObject = Person(\"ken\", height=1.76, weight=77) # autoRun instanceObjectMethod => bmi(self=instanceObject) print(instanceObject.bmi) #　normal 行为控制 你也可以使用其他的形式，来控制属性的删改查等行为，如下所示： class Person: def __init__(self): self.__attr = None @property def name(self): \"\"\"获取name时自动触发该方法，只有当__attr不为None才能被获取到\"\"\" if not self.__attr is None: return self.__attr else: raise AttributeError(\"name is not set\") @name.setter def name(self, params): \"\"\"设置name时自动触发该方法，只有当params为 'Jack' 时才能成功为__attr赋值\"\"\" if params != \"Jack\": raise AttributeError(\"name must setting is string 'Jack', but you set is %s\"%params) else: self.__attr = params @name.deleter def name(self): \"\"\"删除name时自动触发该方法，不允许删除name\"\"\" raise AttributeError(\"name not should delete\") if __name__ == \"__main__\": instanceObject = Person() instanceObject.name = \"Jack\" print(instanceObject.name) del instanceObject.name # Jack # AttributeError: name not should delete 行为控制 行为控制还有另外一种形式，它是固定的用法，如下所示，效果和上面一样： class Person: def __init__(self): self.__attr = None def nameGet(self): \"\"\"获取name时自动触发该方法，只有当__attr不为None才能被获取到\"\"\" if not self.__attr is None: return self.__attr else: raise AttributeError(\"name is not set\") def nameSet(self, params): \"\"\"设置name时自动触发该方法，只有当params为 'Jack' 时才能成功为__attr赋值\"\"\" if params != \"Jack\": raise AttributeError(\"name must setting is string 'Jack', but you set is %s\"%params) else: self.__attr = params def nameDelete(self): \"\"\"删除name时自动触发该方法，不允许删除name\"\"\" raise AttributeError(\"name not should delete\") name = property(fget=nameGet, fset=nameSet, fdel=nameDelete) if __name__ == \"__main__\": instanceObject = Person() instanceObject.name = \"Jack\" print(instanceObject.name) del instanceObject.name # Jack # AttributeError: name not should delete Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-13 20:41:50 "},"Python/Python面向对象/封装.html":{"url":"Python/Python面向对象/封装.html","title":"封装","keywords":"","body":"oop封装 封装是oop思想中最重要的一个，也是所有面向对象程序设计中始终绕不开的话题，说白了就是将数据和功能整合到一起。 类本身就属于封装，如定义一个类，该类中的属性以及方法只有该类或者其实例化对象才能调用，这就是类封装的体现。 除此之外，oop封装中还有2个十分重要的名词，即： 私有属性 公有属性 私有属性 类的私有属性是指在类中以_下划线开头，或者以__下划线开头命名的标示符。 它们都是指将该标示符属性隐藏，仅用于类的内部调用，不希望甚至不支持在类的外部访问这些属性。 单下封装 单下封装是指在类中以_下划线开头的标示符，它意味着使用者不应该在类的外部访问该属性，但实际上外部仍然可以访问。 如下示例，对于女孩子来说，年龄是一项比较私密的属性，因此可以使用单下命名法将该属性隐藏。 即告诉别人，我不想要你知道我的年龄，但是你要强求也是可以得到的： class Person: def __init__(self, name, age, gender) -> None: self.name = name self.gender = gender if self.gender == \"male\": self.age = age elif self.gender == \"female\": self._age = age def getInfo(self): message = \"name : %s\\ngender : %s\\n\"%(self.name, self.gender) if self.gender == \"male\": message += \"age : %d\"%self.age elif self.gender == \"female\": if 18 > self._age: # ❶ message += \"age : underage\" elif 18 ❶：对于单下命名的属性，应当在类的内部进行调用 ❷：虽然能够在外部获取到Mary的年龄，但是不建议这样使用，正确的做法应该是调用getInfo()方法获取信息 双下封装 双下封装是指在类中以__下划线开头的标示符，它意味着使用者应当禁止在类的外部访问该属性，但通过特殊的手段也是能访问到的。 如下示例，对于女孩子来说，体重是一项绝对私密的属性，因此可以使用双下命名法将该属性隐藏。 即告诉别人，你不可以通过常规手段获得我的体重： class Person: def __init__(self, name, gender, weight) -> None: self.name = name self.gender = gender if self.gender == \"male\": self.weight = weight elif self.gender == \"female\": self.__weight = weight def getInfo(self): message = \"name : %s\\ngender : %s\\n\" % (self.name, self.gender) if self.gender == \"male\": message += \"weight : %s(kg)\" % self.weight elif self.gender == \"female\": if 45 > self.__weight: # ❶ message += \"weight : thin\" elif 45 55: message += \"weight : normal\" else: message += \"weight : fat\" return message if __name__ == \"__main__\": jack = Person(name=\"Jack\", gender=\"male\", weight=60) print(jack.getInfo()) print(jack.weight) mary = Person(name=\"Mary\", gender=\"female\", weight=50) print(mary.getInfo()) print(mary.__weight) # ❷ # name : Jack # gender : male # weight : 60(kg) # 60 # name : Mary # gender : female # weight : fat # AttributeError: 'Person' object has no attribute '__weight' ❶：对于双下命名的属性，应当在类的内部进行调用 ❷：外部调用该属性直接抛出异常，找不到，所以应当使用getInfo()方法获取信息 双下重命名 其实双下封装法只是将属性重命名了，通过实例对象的__dict__可以查看到： if __name__ == \"__main__\": mary = Person(name=\"Mary\", gender=\"female\", weight=50) print(mary.__dict__) # {'name': 'Mary', 'gender': 'female', '_Person__weight': 50} 命名规则是： _类名__属性 所以，双下封装的属性其实在外部也能获取到，但是不推荐这么做，有悖于规范，如下所示： if __name__ == \"__main__\": mary = Person(name=\"Mary\", gender=\"female\", weight=50) print(mary._Person__weight) # 50 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-13 20:41:50 "},"Python/Python面向对象/继承.html":{"url":"Python/Python面向对象/继承.html","title":"继承","keywords":"","body":"oop继承 继承介绍 继承作为oop三大特性之一，可以说是最难的一章知识点，但是用的非常多。 继承是指创建类的一种方式，极大程度上规避了类与类之间代码的重复问题。 在Python中，是支持多继承的，即一个类可以继承多个类，这是其他大多数语言中所不支持的。 被继承的类可以称为父类，超类或者基类 继承的类可以称为子类或者派生类 派生类可以使用父类所有的属性及方法，但是父类是不能使用派生类的属性或方法的。 以下是语法格式： class 类标示符(父类1, 父类2): ... 举一个简单的例子，下面定义了一个狼（Wolf）类和狗（Dog）类，它们都具有相同的方法咬人（bite）、跑步（run）等，由于继承的存在故不用将该方法书写两次，直接使用狗类继承狼类即可： class Wolf: def __init__(self, name) -> None: self.name = name def bite(self, personName): return \"%s biting %s\" % (self.name, personName) def run(self): return \"%s runing...\" % self.name class Dog(Wolf): pass if __name__ == \"__main__\": wolfInstance = Wolf(\"King Kong\") print(wolfInstance.bite(\"Tom\")) print(wolfInstance.run()) print(\"=\" * 10) dogInstance = Dog(\"Small Black\") print(dogInstance.bite(\"Jack\")) print(dogInstance.run()) # King Kong biting Tom # King Kong runing... # ========== # Small Black biting Jack # Small Black runing... 方法覆写 如果派生类中拥有和父类同名的方法或者属性，则派生类或者其实例对象在查找这些属性或方法时只会拿自己的。 如下所示，在Dog类中重写了bite，让它不再咬人： class Wolf: def __init__(self, name) -> None: self.name = name def bite(self, personName): return \"%s biting %s\" % (self.name, personName) def run(self): return \"%s runing...\" % self.name class Dog(Wolf): def bite(self, personName): return \"%s not biting, %s escaped \" % (self.name, personName) if __name__ == \"__main__\": wolfInstance = Wolf(\"King Kong\") print(wolfInstance.bite(\"Tom\")) print(wolfInstance.run()) print(\"=\" * 10) dogInstance = Dog(\"Small Black\") print(dogInstance.bite(\"Jack\")) print(dogInstance.run()) # King Kong biting Tom # King Kong runing... # ========== # Small Black not biting, Jack escaped # Small Black runing... Python3 新式类 Python3中默认的所有类都继承了object类，这样的类被称为新式类： class A: # eq class A(object) pass if __name__ == \"__main__\": print(A.__bases__) # (,) 单继承 新式类单继承查找公有属性、方法时，每轮按照一条线的向上查找次序，如下图所示： 代码示例： class A: def show(self): print(\"--- A.show run ---\") self.info() def info(self): print(\"--- A.info run ---\") def __getattribute__(self, name: str): print(\"find A.%s\" % name) return super().__getattribute__(name) class B(A): def info(self): print(\"--- B.info run ---\") def __getattribute__(self, name: str): print(\"find B.%s\" % name) return super().__getattribute__(name) class C(B): def info(self): print(\"--- C.info run---\") def __getattribute__(self, name: str): print(\"find C.%s\" % name) return super().__getattribute__(name) if __name__ == \"__main__\": instanceC = C() instanceC.show() # find C.show # find B.show # find A.show # --- A.show run --- # find C.info # find B.info # find A.info # --- C.info run--- 而新式类如果是单继承查找私有属性、方法则结果又不一样，如下图所示： 代码示例： class A: def show(self): print(\"--- A.show run ---\") self.__info() def __info(self): print(\"--- A.__info run ---\") def __getattribute__(self, name: str): print(\"find A.%s\" % name) return super().__getattribute__(name) class B(A): def __info(self): print(\"--- B.__info run ---\") def __getattribute__(self, name: str): print(\"find B.%s\" % name) return super().__getattribute__(name) class C(B): def __info(self): print(\"--- C.__info run---\") def __getattribute__(self, name: str): print(\"find C.%s\" % name) return super().__getattribute__(name) if __name__ == \"__main__\": instanceC = C() instanceC.show() # find C.show # find B.show # find A.show # --- A.show run --- # find C._A__info # find B._A__info # find A._A__info # --- A.__info run --- 普通多继承 Python3中的新式类普通多继承，会按照深度优先的查找策略查找整个继承树。 深度优先：从左至右查找，每条分支查到最顶部，最后查找object类 如下图所示： 代码示例： class A: def __getattribute__(self, name: str): print(\"find A.%s\" % name) return super().__getattribute__(name) class B(A): def __getattribute__(self, name: str): print(\"find B.%s\" % name) return super().__getattribute__(name) class C(B): def show(self): print(\"--- C.show run ---\") def __getattribute__(self, name: str): print(\"find C.%s\" % name) return super().__getattribute__(name) class D: def __getattribute__(self, name: str): print(\"find D.%s\" % name) return super().__getattribute__(name) class E(D): def __getattribute__(self, name: str): print(\"find E.%s\" % name) return super().__getattribute__(name) class F: def __getattribute__(self, name: str): print(\"find F.%s\" % name) return super().__getattribute__(name) class G(C, E, F): def __getattribute__(self, name: str): print(\"find G.%s\" % name) return super().__getattribute__(name) if __name__ == \"__main__\": instanceG = G() instanceG.show() # find G.show # find C.show # find B.show # find A.show # find E.show # find D.show # find F.show # --- C.show run --- 钻石多继承 钻石多继承也被称为死亡菱形继承，继承关系如下所示： Python3中的新式类钻石多继承，会按照广度优先的查找策略查找整个继承树。 广度优先：从左至右查找，每条分支查到顶部第二个类超类，也就是不查钻石基类，如果都没有才查找钻石基类，最后查找object类 如下图所示： 代码示例： class A: def show(self): print(\"--- A.show run ---\") def __getattribute__(self, name: str): print(\"find A.%s\" % name) return super().__getattribute__(name) class B(A): def __getattribute__(self, name: str): print(\"find B.%s\" % name) return super().__getattribute__(name) class C(A): def __getattribute__(self, name: str): print(\"find C.%s\" % name) return super().__getattribute__(name) class D(A): def __getattribute__(self, name: str): print(\"find D.%s\" % name) return super().__getattribute__(name) class E(B): def __getattribute__(self, name: str): print(\"find E.%s\" % name) return super().__getattribute__(name) class F(C): def __getattribute__(self, name: str): print(\"find F.%s\" % name) return super().__getattribute__(name) class G(D): def __getattribute__(self, name: str): print(\"find G.%s\" % name) return super().__getattribute__(name) class H(E): def __getattribute__(self, name: str): print(\"find H.%s\" % name) return super().__getattribute__(name) class I(H, F, G): def __getattribute__(self, name: str): print(\"find I.%s\" % name) return super().__getattribute__(name) if __name__ == \"__main__\": instanceI = I() instanceI.show() # find I.show # find H.show # find E.show # find B.show # find F.show # find C.show # find G.show # find D.show # find A.show # --- A.show run --- Python2 经典类 Python2中如果一个类没有继承object类，这种类被称为经典类。 反之，如果继承了object类，则被称为新式类。 如下所示： # Python2中的经典类，也就是Python3中的新式类 class A: pass # Python2中的新式类 class A(object): pass 换而言之，Python2的类有新式类和经典类2种，Python3中仅有新式类，取消了经典类的设定。 不论是Python2的新式类还是Python3的新式类，它们的查找过程都是相同的，故下面只会例举经典类的查找顺序。 单继承 经典类在单继承的情况下，和新式类的查找顺序一致。 普通多继承 不管是新式类还是经典类，在普通多继承的查找下都是深度优先策略： 深度优先：从左至右查找，每条分支查到最顶部 由于不能使用__getattribute__()方法来查看整个查找过程，故这里就不再进行代码示例了。 感兴趣的朋友可以自行测试一下。 钻石多继承 钻石多继承中，经典类采用的是深度优先策略，而新式类则采用的广度优先策略。 深度优先：从左至右查找，每条分支查到最顶部，也就是说钻石基类在第一轮就会被查到 图示如下： 由于不能使用__getattribute__()方法来查看整个查找过程，故这里就不再进行代码示例了。 感兴趣的朋友可以自行测试一下。 双下属性 __class__ instanceObject.__class__属性可以查看实例对象所属的类： class A: pass if __name__ == \"__main__\": instanceObject = A() print(instanceObject.__class__) # __main__.A __base__ className.__base__属性可查看到类的父类，仅Python3有效，返回类对象： class A: pass class B(A): pass class C(B): pass if __name__ == \"__main__\": print(C.__base__) # __bases__ className.__bases__属性可查看到类的父类，仅Python3有效，返回元组，索引0处是其父类： class A: pass class B(A): pass class C(B): pass if __name__ == \"__main__\": print(C.__bases__) # (,) __mro__ 类的属性查找顺序在类定义时底层会根据C3算法生成，使用className.__mro__可调用出该查找顺序。 返回一个列表，列表中嵌套各种父类、超类，也就是说这是一个属性查找顺序列表。 注意，仅在Python3中生效。 下面是新式类普通多继承属性查找顺序，和上面测试的结果一致： class A: pass class B(A): pass class C(B): pass class D: pass class E(D): pass class F: pass class G(C, E, F): pass if __name__ == \"__main__\": print(G.__mro__) # (, , , , , , , ) 下面是新式类钻石多继承属性查找顺序，和上面测试的结果一致： class A: pass class B(A): pass class C(A): pass class D(A): pass class E(B): pass class F(C): pass class G(D): pass class H(E): pass class I(H, F, G): pass if __name__ == \"__main__\": print(I.__mro__) # (, , , , , , , , , ) 方法借用 class.attr 如果一个类和另一个类没有任何关系，但是要借用运行其下方法时，可以选择指名道姓的通过类来调用其下方法。 必须手动传入所有参数，如下所示： class A: def func(self): print(\"run A instance method\") class B: def func(self): print(\"run B instance method\") A.func(self=self) if __name__ == \"__main__\": B().func() # run B instance method # run A instance method super() 如果一个类和另一个类有继承关系，则可以通过super()方法自动向后查找其父类中需要借用的方法并执行。 它本质上会做两件事： 调用__mro__，拿到属性查找顺序列表 确定当前类在列表中的位置，并且拿到其父类，再自动使用class.attr的方式指名道姓的运行父类方法 所以，使用super()方法进行方法借用时，也需要手动传入所有参数，但是传入的参数与class.attr的方式有所不同。 具体的函数签名如下： super(__class__, ) 使用案例： class A: def func(self): print(\"run A instance method\") class B(A): def func(self): print(\"run B instance method\") super(__class__, self).func() # ❶ ❷ if __name__ == \"__main__\": B().func() # run B instance method # run A instance method ❶：传入__class__，用于确认该类在__mro__所返回的属性查找顺序列表中的位置，以便确定后面的父类查找 ❷：传入self，它将自动把self传递给A.func()的第一个参数 注意事项： Python3的super()方法中参数可以不传递，它会自动进行补充 Python2的经典类如果想使用super()方法，则必须在文件顶部添加一句代码 ： __metaclass__ = type，否则无法使用 Python2的super()方法中参数必须传递，不可进行省略 Mixins机制 Python由于支持多继承的关系，故在某些情况下可能导致代码逻辑不通顺的问题出现，如下所示： 为了能让基类的作用更加强大，符合一切交通工具的特性，你可能会在交通工具基类里面定义下面的方法： 飞行方法 抛锚方法 刹车方法 那么这个时候就已经产生了逻辑问题： 轮船不会飞，也不会刹车，但作为交通工具基类的派生类，它也能调用这些方法 汽车不会飞，也不会抛锚，但作为交通工具基类的派生类，它也能调用这些方法 飞机不会刹车，也不会抛锚，但作为交通工具基类的派生类，它也能调用这些方法 代码示例： class Transportation: def __init__(self, name) -> None: self.name = name def fly(self): \"\"\" 飞 \"\"\" print(\"%s flying\" % self.name) def brake(self): \"\"\" 刹车 \"\"\" print(\"%s braking\" % self.name) def anchor(self): \"\"\" 抛锚 \"\"\" print(\"%s anchor\" % self.name) class Aircraft(Transportation): pass class Car(Transportation): pass class Ship(Transportation): pass if __name__ == \"__main__\": aircraft = Aircraft(\"Boeing 747\") car = Car(\"BMW\") ship = Ship(\"Titanic\") # Serious Problem aircraft.brake() aircraft.anchor() car.fly() car.anchor() ship.fly() ship.brake() # Boeing 747 braking # Boeing 747 anchor # BMW flying # BMW anchor # Titanic flying # Titanic braking 如何解决这个问题呢？我们可以使用Mixins机制，将刹车、抛锚、飞行这3个不同的功能单独的封装到下面3个类中： 汽车功能类：刹车 飞机功能类：飞行 轮船功能类：抛锚 子类只需要继承交通工具基类和对应的功能类即可，如下图所示： 代码示例如下： class Transportation: def __init__(self, name) -> None: self.name = name class AircraftMixin: def fly(self): \"\"\" 飞 \"\"\" print(\"%s flying\" % self.name) class CarMixin: def brake(self): \"\"\" 刹车 \"\"\" print(\"%s braking\" % self.name) class ShipMixin: def anchor(self): \"\"\" 抛锚 \"\"\" print(\"%s anchor\" % self.name) class Aircraft(Transportation, AircraftMixin): pass class Car(Transportation, CarMixin): pass class Ship(Transportation, ShipMixin): pass if __name__ == \"__main__\": aircraft = Aircraft(\"Boeing 747\") car = Car(\"BMW\") ship = Ship(\"Titanic\") aircraft.fly() car.brake() ship.anchor() # Boeing 747 flying # BMW braking # Titanic anchor Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-13 20:41:50 "},"Python/Python面向对象/多态.html":{"url":"Python/Python面向对象/多态.html","title":"多态","keywords":"","body":"oop多态 多态更多的是指的一种思想，而非具体技术。 因为继承的存在，从而引发了多态，举个例子，所有的生物都是由一个单细胞生物不断演化而来，迄今为止它们的差异越来越大，这就是多态的体现。 多态的定义其实更准确的说法是：在不同类中实例化得到的不同对象调用一个相同方法时，它们的实现过程并不一样。 Python本身就实现了多态，其中len()方法就是最好的多态体现，2个不同类的实例化对象调用相同方法，该方法内部的处理是完全不同的： lst = [i for i in range(10)] tpl = tuple(i for i in range(10)) print(len(lst)) print(len(tpl)) # 10 # 10 多态实现 为了能够更好的理解多态，我们可以用下面这段代码来阐述。 首先，有一个犬科（Canine）的类，实现了吼叫（howl）的方法。 然后，狼（Wolf）和狗（Dog）类均继承自该类，它们都有一个吼叫的方法，但是由于狼和狗还是有很大差距的，所以该方法的内部实现过程并不一样，这就是多态的体现。 即：犬科具有吼叫方法，但同属犬科的狼和狗的吼叫是不同的。 class Canine: def howl(self): pass class Wolf(Canine): def howl(self): return \"wolf howling : ao~ ao~ ao~\" class Dog(Canine): def howl(self): return \"dog howling : wang~ wang~ wang~\" if __name__ == \"__main__\": wolfInstance = Wolf() dogInstance = Dog() print(wolfInstance.howl()) print(\"=\" * 10) print(dogInstance.howl()) # wolf howling : ao~ ao~ ao~ # ========== # dog howling : wang~ wang~ wang~ duke type 鸭子类型（duke type）是一个很有趣的词汇。 它指的是我不管你是不是鸭子，只要你具备了某些鸭子的特性，如会嘎嘎嘎，走路会摇摇晃晃等我就认为你是鸭子。 那它到底有什么好处呢？其实这样做是为了方便使用者进行方法调用。 如tuple和list，它们何其相似，如果你知道list.index()这个方法，你肯定也会尝试tuple.index()方法，结果发现居然还真的有。 鸭子类型与继承毫无关系，它强调的也是一种抽象的分类，如list和tuple同属线性结构，应该都能使用index()方法，也应当都能使用len()方法。 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-13 20:41:50 "},"Python/Python面向对象/抽象基类.html":{"url":"Python/Python面向对象/抽象基类.html","title":"抽象基类","keywords":"","body":"抽象基类 接口（interface）和抽象基类（abstract base class）是非常相似的，Python中并未提供真正意义上的接口，但是提供了抽象基类的使用。 它们的作用在于： 约束子类实现，子类必须实现抽象基类中的某一个方法才能被实例化，否则将不可被实例化 举个例子，羊（Sheep）和狼（Wolf）都属于哺乳类（Breastfeeding），那么它们都至少具有1个方法名为哺乳（feeding），如果没有该方法，则该类不能被实例化。 其实说白了，抽象基类的作用就是规范子类实现，所以： 抽象基类仅用于被继承，不必对其进行实例化 抽象基类内部方法不必实现 abc Python中用abc模块定义抽象基类，只需要将抽象基类的metaclass=abc.ABCMeta即可。 除此之外，它还提供了3个装饰器： abc.abstractclassmethod：抽象类方法 abc.abstractstaticmethod：抽象静态方法 abc.abstractmethod：抽象实例方法 代码示例如下： import abc class Breastfeeding(metaclass=abc.ABCMeta): @abc.abstractmethod def feeding(self): pass class Sheep(Breastfeeding): def feeding(self): return \"sheep feeding\" class Wolf(Breastfeeding): pass if __name__ == \"__main__\": sheepInstance = Sheep() print(\"sheep class instance success!\") wolfInstance = Wolf() # sheep class instance success! # TypeError: Can't instantiate abstract class Wolf with abstract methods feeding 这个例子中，羊实现了哺乳的方法，所以实例化成功了，而狼则没有实现哺乳方法，故实例化失败了。 如果有1个狗（Dog）类继承了狼类，那么狗类能否受到抽象基类的影响呢？ 答案是不能，抽象基类只能影响其下一代继承类的实现，不能影响其孙系类。 如下所示： import abc class Breastfeeding(metaclass=abc.ABCMeta): @abc.abstractmethod def feeding(self): pass class Sheep(Breastfeeding): def feeding(self): return \"sheep feeding\" class Wolf(Breastfeeding): def feeding(self): return \"wolf fedding\" class Dog(Wolf): pass if __name__ == \"__main__\": sheepInstance = Sheep() print(\"sheep class instance success!\") wolfInstance = Wolf() print(\"wolf class instance success!\") dogInstance = Dog() print(\"dog class instance success!\") # sheep class instance success! # wolf class instance success! # dog class instance success! 继承约束 通过继承，也能进行子类的行为约束，但是常规手段不能禁止其实例化。 如下所示，狼类没有实现哺乳方法，依然实例化成功了，但是不能调用哺乳方法： class Breastfeeding: def feeding(self): raise AssertionError(\"%s must implement method feeding\" % (self.__class__.__name__)) class Sheep(Breastfeeding): def feeding(self): return \"sheep feeding\" class Wolf(Breastfeeding): pass if __name__ == \"__main__\": sheepInstance = Sheep() print(\"sheep class instance success!\") print(sheepInstance.feeding()) wolfInstance = Wolf() print(\"wolf class instance success!\") print(wolfInstance.feeding()) # sheep class instance success! # sheep feeding # wolf class instance success! # AssertionError: Wolf must implement method feeding 上面这种方式在很多框架中也被经常使用到，但如果你想实现和ABCMeta同样的效果，可以覆写基类的__new__()方法，如下所示： class Breastfeeding: def __new__(cls) -> object: for attr in Breastfeeding.__dict__: if attr.startswith(\"__\"): continue if attr not in cls.__dict__: raise TypeError(\"Can't instantiate abstract class %s with abstract methods %s\" % (cls.__name__, attr)) return super(Breastfeeding, cls).__new__(cls) def feeding(self): pass class Sheep(Breastfeeding): def feeding(self): return \"sheep feeding\" class Wolf(Breastfeeding): pass if __name__ == \"__main__\": sheepInstance = Sheep() print(\"sheep class instance success!\") print(sheepInstance.feeding()) wolfInstance = Wolf() print(\"wolf class instance success!\") print(wolfInstance.feeding()) # sheep class instance success! # sheep feeding # TypeError: Can't instantiate abstract class Wolf with abstract methods feeding Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-13 20:41:50 "},"Python/Python面向对象/自省反射.html":{"url":"Python/Python面向对象/自省反射.html","title":"自省反射","keywords":"","body":"自省反射 自省和反射是两个比较专业化的术语，释义如下： 自省是指获取对象的能力 反射是指操纵对象的能力 由于Python是一门强类型的动态解释型语言，所以它的自省和反射使用非常简单。 我们在某些时候并不知道对象中具有的属性与方法，尤其是接手别人的项目时这种情况更加明显。 在这种情况下，我们不能直接通过Object.__dict__来获取其对象的属性与方法（因为这样获取不到继承的属性），而应当先使用自省来获取对象信息后，再使用反射来操纵对象，故自省和反射的学习显得尤为重要。 以下举例常见自省与反射的函数： 函数 返回值 描述 help(object) None 获取对象文档帮助信息 dir(object) list 获取对象下所有能被.操纵的属性与方法 hasattr(object, str) bool 返回对象是否具有给定名称的属性或方法 getattr(object, str, default) attr 获取对象中指定的属性或方法，若该属性或方法不存在，则抛出AttributeError异常，若设置默认值，则在属性或方法不存在时返回默认值 setattr(object, str, any) None 设置对象中某一属性或方法的值 delattr(object, str) None 删除对象中某一指定属性或方法 issubclass(subClass, parentClass) bool 判定一个类是否是另一个类的子类 isinstance(instance, class) bool 判定一个对象是否是另一个类的实例 callable(object) bool 判定该对象是否可调用 示例演示 help(object)能够获取对象文档帮助信息。 返回None： >>> help(int) Help on class int in module builtins: class int(object) | int(x=0) -> integer | int(x, base=10) -> integer | | Convert a number or string to an integer, or return 0 if no arguments | are given. If x is a number, return x.__int__(). For floating point | numbers, this truncates towards zero. | | If x is not a number or if base is given, then x must be a string, | bytes, or bytearray instance representing an integer literal in the | given base. The literal can be preceded by '+' or '-' and be surrounded ... dir(object)能够获取对象下所有能被.操纵的属性与方法。 返回list： >>> dir(list) ['__add__', '__class__', '__contains__', '__delattr__', '__delitem__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__getitem__', '__gt__', '__hash__', '__iadd__', '__imul__', '__init__', '__init_subclass__', '__iter__', '__le__', '__len__', '__lt__', '__mul__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__reversed__', '__rmul__', '__setattr__', '__setitem__', '__sizeof__', '__str__', '__subclasshook__', 'append', 'clear', 'copy', 'count', 'extend', 'index', 'insert', 'pop', 'remove', 'reverse', 'sort'] hasattr(object, str)能够返回对象是否具有给定名称的属性或方法。 返回bool： >>> hasattr(list, \"index\") True >>> hasattr(list, \"items\") False getattr(object, str, default)能够获取对象中指定的属性或方法，若该属性或方法不存在，则抛出AttributeError异常，若设置默认值，则在属性或方法不存在时返回默认值： >>> method = getattr(list, \"index\") >>> method >>> method([1, 2, 3], 2) 1 setattr(object, str, any)能够设置对象中某一属性或方法的值。 返回None： >>> class A: ... pass ... >>> A.__doc__ None >>> setattr(A, \"__doc__\", \"help message\") >>> A.__doc__ help message delattr(object, str)能够删除对象中某一指定属性或方法。 返回None： >>> class A: ... classAttr = \"attr\" ... >>> A.classAttr 'attr' >>> delattr(A, \"classAttr\") >>> A.classAttr AttributeError: type object 'A' has no attribute 'classAttr' issubclass(subClass, parentClass)可以判定一个类是否是另一个类的子类。 返回bool： >>> issubclass(bool, int) True isinstance(instance, class)可以判定一个对象是否是另一个类的实例。 返回bool： >>> isinstance(1, bool) False >>> isinstance(True, bool) True 常用操作 当不确定对象中是否具有某一属性或方法时，可以使用hasattr()，getattr()以及callable()进行组合使用。 如下所示： import sys class YunPan: \"\"\" this is YunPan. You can specify start-up parameters on the command line. If the specified parameter is attribute, this property will be displayed. If the specified parameter is called, the method is performed The parameters you can specify now are: Help: Get help information The method you can specify is: Download: Test Download Features, Parameters -> Str UPLOAD: Test Upload Energy, Parameters -> Str Raises: TypeError: If there is no such method or attribute in the class, it will throw an exception. \"\"\" help = __doc__ def __init__(self) -> None: self.attrOrMethod = sys.argv[1] self.fileName = sys.argv[2] if len(sys.argv) > 2 else None self.choices() def download(self): print(\"downloading file : %s\"%self.fileName) def upload(self): print(\"uploading file : %s\"%self.fileName) def choices(self): if not hasattr(self, self.attrOrMethod): raise TypeError(\"%s not implement method or attributes:%s\"%(self.__class__.__name__, self.attrOrMethod)) attrOrMethod = getattr(self, self.attrOrMethod) if callable(attrOrMethod): return attrOrMethod() print(attrOrMethod) if __name__ == \"__main__\": YunPan() 测试结果： $ python3 .\\demo.py help this is YunPan. You can specify start-up parameters on the command line. If the specified parameter is attribute, this property will be displayed. If the specified parameter is called, the method is performed The parameters you can specify now are: Help: Get help information The method you can specify is: Download: Test Download Features, Parameters -> Str UPLOAD: Test Upload Energy, Parameters -> Str Raises: TypeError: If there is no such method or attribute in the class, it will throw an exception. $ python3 .\\demo.py download TestFile downloading file : TestFile $ python3 .\\demo.py upload TestFile uploading file : TestFile $ python3 .\\demo.py func .. TypeError: YunPan not implement method or attributes:func Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-13 20:41:50 "},"Python/Python面向对象/双下大全.html":{"url":"Python/Python面向对象/双下大全.html","title":"双下大全","keywords":"","body":"特殊的双下 在Python中有很多特殊的方法函数，如__init__()、__new__()等。 除此之外，也有很多特殊的属性变量，如__base__，__class__等。 这些属性变量或者方法函数经常被人称其为“魔法方法”，个人并不是很喜欢这种叫法。 我更喜欢称呼他们为双下方法或者双下属性，因为“魔法”一词总是带有玄幻的色彩，但在计算机领域中如果你觉得一个知识点过于玄幻，说明你并未真正的理解它。 言归正传，那么它们具体有什么作用呢？如下所示： 双下方法：在满足某一特定的条件下进行自动调用 双下属性：本身就含有一定的意义 本章节我们将先探讨双下方法，而后探讨双下属性。 双下方法 对象相关 __new__() 对象的构造方法，用于构建实例对象。 在类加括号时自动调用，创建并返回一个空的实例对象。 参数释义： cls：被实例化的类本身 args： 实例化类时传入的位置参数 kwargs： 实例化类时传入的关键字参数 返回值： object：实例化对象 应用场景： 实现单例模式，函数二次封装等 如下所示： class Category: def __new__(cls, *args, **kwargs) -> object: print(cls) print(args) print(kwargs) instanceObject = super(__class__, cls).__new__(cls) return instanceObject if __name__== \"__main__\": instance = Category(\"positionParams\", k=\"keyWordParams\") # # ('positionParams',) # {'k': 'keyWordParams'} __init__() 对象的初始化方法，用于构建实例对象，可以理解为为实例对象的__dict__填充内容。 在类加括号时自动调用，返回None： 参数释义： self：实例本身，也就是由__new__()创建出的空对象 返回值： None：该方法必须返回None 应用场景： 基本上适用于所有定义类的场景 如下所示： class Category: def __init__(self, params) -> None: self.k = params if __name__== \"__main__\": instance = Category(\"v\") print(instance.__dict__) # {'k': 'v'} __call__() 对象的调用方法，当对象后面加上括号时自动触发。 参数释义： self：实例本身，也就是由__new__()创建出的空对象 返回值： Any：任意值 应用场景： 它是内置函数callable()的判断依据，当callable(object)时，会判断object内部是否实现了该方法从而返回True或者False 如下所示，经过该方法实现，现在普通实例对象加括号会打印出其属性查找顺序： class Category: x = 1 def __call__(self): findList = list(self.__class__.__mro__) findList.insert(0, self) return tuple(findList) if __name__== \"__main__\": instance = Category() print(instance()) # (, , ) __del__() 对象的析构方法，当手动 del object 删除对象，或者在程序运行结束后自动触发。 参数释义： self：实例本身，也就是由__new__()创建出的空对象 返回值： None 应用场景： 用于关闭一些占据系统资源的操作，如文件资源，网络资源 如下所示： class Category: x = 1 def __del__(self): print(\"run ... __del__()\") if __name__== \"__main__\": instance = Category() del instance # run ... __del__() 示例，自定义文件操作类，可用于自动关闭文件： class OpenFile: def __init__(self, *args, **kwargs) -> None: self.__file = open(*args, **kwargs) def __getattr__(self, name:str): return getattr(self.__file, name) def __del__(self): print(\"auto file close\") self.__file.close() if __name__== \"__main__\": fileObject = OpenFile(file=\"./test.txt\", mode=\"rt\", encoding=\"utf8\") print(fileObject.read(32)) 属性操作 __getattribute__() 当要查找某一个属性或者方法时，都会触发该方法。 如要查找的属性或者方法存在，则返回该属性或方法。 否则抛出AttributeError的异常。 参数释义： self：实例本身，也就是 . 前面的对象 name：要查找的属性或方法 返回值： Any：要查找的方法或者属性 应用场景：自定义容器的方法查找，内置函数getattr()的底层其实就是该方法 如下所示： from typing import Any class Category: def __getattribute__(self, name: str) -> Any: print(\"run ..\") try: return super(__class__, self).__getattribute__(name) except AttributeError as e: return \"don't have attribute %s\" % name if __name__== \"__main__\": instance = Category() print(instance.x) # run .. # don't have attribute x __getattr__() 在对对象进行 . 操作试图获取对象下的某一属性或方法时而恰好该属性或方法不存在时自动触发。 若__getattribute__()与__getattr__()同时出现，则只会调用__getattribute__()。 参数释义： self：实例本身，也就是 . 前面的对象 name：要查找的属性或方法 返回值： Any：任意给定的值 应用场景：自定义类的方法借用，或者代理类 示例1，只定义了__getattr__()，它会在获取对象下的某一属性或方法不存在时触发： from typing import Any class Category: x = 1 def __getattr__(self, name: str) -> Any: print(\"run ..\") return \"%s not existing\" % name if __name__== \"__main__\": instance = Category() print(\"Find the existing properties and not call __getattr__()\") print(instance.x) print(\"Find the property that does not exist will call __getattr__()\") print(instance.y) # Find the existing properties and not call __getattr__() # 1 # Find the property that does not exist will call __getattr__() # run .. # y not existing 示例2，如果同时定义了__getattr__()和__getattribute__()则无论什么情况都不会触发__getattr__()： from typing import Any class Category: x = 1 def __getattribute__(self, name: str) -> Any: print(\"run __getattribute__()\") try: return super(Category, self).__getattribute__(name) except AttributeError as e: return \"don't have attribute %s\" % name def __getattr__(self, name: str) -> Any: print(\"run __getattr__()\") return \"%s not existing\" % name if __name__== \"__main__\": instance = Category() print(instance.x) print(instance.y) # run __getattribute__() # 1 # run __getattribute__() # don't have attribute y __setattr__() 在对对象进行 . 操作试图修改对象下的某一属性或方法时自动触发。 参数释义： self：实例本身，也就是 . 前面的对象 name：要设置的属性或方法 value：要为属性和方法设置的新值 返回值： None 应用场景：自定义代理类，内置函数setattr()的底层其实就是该方法 如下所示： from typing import Any class Category: x = 1 def __setattr__(self, name: str, value: Any) -> None: print(\"run .. __setattr__()\") self.__dict__[name] = value if __name__== \"__main__\": instance = Category() instance.y = \"newAttribute\" # run .. __setattr__() 一个容易被人忽视的地方，如果__setattr__()中设置成这样，则会引发无限递归，无数次调用自身： def __setattr__(self, name: str, value: Any) -> None: self.name = value __delattr__() 在对对象进行 . 操作试图删除对象下的某一属性或方法时自动触发。 参数释义： self：实例本身，也就是 . 前面的对象 name：要删除的属性或方法 返回值： None 应用场景：自定义不可变容器，内置函数delattr()的底层其实就是该方法 如下所示： class Category: x = 1 def __delattr__(self, name: str) -> None: print(\"run .. __delattr__()\") del self.__dict__[name] if __name__== \"__main__\": instance = Category() instance.attr = \"newAttr\" del instance.attr # run .. __delattr__() __getitem__() 在对对象进行 [] 操作试图获取对象下的某一对象属性或方法时自动触发。 除此之外，它也能代替__iter__()方法创建专属迭代器。 参数释义： self：实例本身，也就是 [] 前面的对象 name：要获取的属性或方法 返回值： None 应用场景：自定义映射容器，实现类似字典的操作 dict[k] 如下所示： from typing import Any class Category: x = 1 def __getitem__(self, name: str) -> Any: print(\"run .. __getitem__()\") return self.__dict__[name] if __name__== \"__main__\": instance = Category() instance.attr = \"newAttr\" print(instance[\"attr\"]) # run .. __getitem__() # newAttr 此外，如果类中实现了该方法，则该类的实例化对象就是可迭代对象： from typing import Any class Category: x = 1 def __getitem__(self, name: str) -> Any: print(\"run .. __getitem__()\") return self.__dict__[name] if __name__== \"__main__\": instance = Category() print(iter(instance)) # ❶ # ❶：即使该类没实现__iter__()，但是仍然可以创建专属迭代器 __setitem__() 在对对象进行 [] 操作试图修改对象下的某一对象属性或方法时自动触发。 参数释义： self：实例本身，也就是 [] 前面的对象 name：要设置的属性或方法 value：要为属性和方法设置的新值 返回值： None 应用场景：自定义映射容器，实现类似字典的操作 dict[k] = v 如下所示： from typing import Any class Category: x = 1 def __setitem__(self, name: str, value: Any) -> None: print(\"run .. __setitem__()\") self.__dict__[name] = value if __name__== \"__main__\": instance = Category() instance[\"y\"] = \"newAttr\" # run .. __setitem__() __delitem__() 在对对象进行 [] 操作试图删除对象下的某一对象属性或方法时自动触发。 参数释义： self：实例本身，也就是 [] 前面的对象 name：要删除的属性或方法 返回值： None 应用场景：自定义映射容器，实现类似字典的操作 del dict[k] 如下所示： class Category: x = 1 def __delitem__(self, name: str) -> None: print(\"run .. __delitem__()\") del self.__dict__[name] if __name__== \"__main__\": instance = Category() instance.attr = \"newAttr\" del instance[\"attr\"] # run .. __delitem__() 输出相关 __str__() print(object)时自动触发该方法。 参数释义： self：实例本身，也就是 . 前面的对象 返回值： 必须是str类型 应用场景：非常常用，如Django框架admin，models类中都会定义该方法进行数据项展示 如下所示： class Category: x = 1 def __str__(self) -> str: return \"it is class %s instance object\" % self.__class__.__name__ if __name__== \"__main__\": instance = Category() print(instance) # it is class Category instance object __repr__() 交互式环境下输入对象标识符，print(object)时自动触发该方法。 参数释义： self：实例本身，也就是 . 前面的对象 返回值： 必须是str类型 应用场景：与__str__()应用场景相当，但是比它要强大一点。 如果没有实现__str__()方法，则会在print(object)时使用该方法。 如下所示： class Category: x = 1 def __repr__(self) -> str: return \"it is class %s instance object\" % self.__class__.__name__ if __name__== \"__main__\": instance = Category() print(instance) # it is class Category instance object __format__() format(object)时自动触发该方法。 参数释义： self：实例本身，也就是 . 前面的对象 format_spec：模板{:}中:后面的值 返回值： 必须是str类型 应用场景：自定义时间类，格式化打印相关 如下所示： class Date: formatStyle = { \"ymd\": \"{0.year}:{0.month}:{0.day}\", \"dmy\": \"{0.day}/{0.month}/{0.year}\", \"mdy\": \"{0.month}-{0.day}-{0.year}\", } def __init__(self, year, month, day) -> None: self.year = year self.month = month self.day = day def __format__(self, format_spec: str) -> str: if format_spec is None or format_spec not in __class__.formatStyle: format_spec = \"ymd\" return __class__.formatStyle[format_spec].format(self) if __name__== \"__main__\": instance = Date(2011, 1, 23) print(format(instance)) print(\"{:mdy}\".format(instance)) # 2011:1:23 # 1-23-2011 组合套餐 __enter__()与__exit__() __enter__()与__exit__()方法可实现上下文管理协议。 使用with语句将自动触发__enter__()方法的执行。 with语句代码块执行完毕后或者with语句代码块执行过程中抛出异常都会自动触发__exit__()方法的执行。 上下文管理作用如下： 使用with语句的目的就是把代码块放入with中执行，with结束后，自动完成清理工作，无须手动干预 在需要管理一些资源比如文件，网络连接和锁的编程环境中，可以在__exit__()中定制自动释放资源的机制，你无须再去关心这个问题，这将大有用处 函数签名如下： def __enter__(self) -> object: pass def __exit__(self, exc_type, exc_val, exc_tab) -> bool: pass __enter__()方法说明： 参数释义： self：实例本身，也就是 . 前面的对象 返回值： 返回的对象会被as语句当做句柄接收 __exit__()方法说明： 参数释义： self：实例本身，也就是 . 前面的对象 exc_type：异常类型 exc_val：异常值 exc_tab：异常回溯信息 返回值： 如果返回False则代表立即抛出异常，如果返回True则代表捕获本次异常 示例演示，通过__new__()方法和上下文管理协议，实现文件类封装： class OpenFile: fileObject = None __doc__= open.__doc__ def __new__(cls, *args, **kwargs) -> object: cls.fileObject = open(*args, **kwargs) return cls.fileObject def __enter__(self): return __class__.fileObject def __exit__(exc_type, exc_val, exc_tab): __class__.fileObject.close() return False def __del__(self): __class__.fileObject.close() def __getattr__(self, name: str): return getattr(__class__.fileObject, name) if __name__== \"__main__\": with OpenFile(\"./test.txt\", mode=\"rt\", encoding=\"utf8\") as f: print(f.read()) print(help(OpenFile)) __iter__()与__next__() __iter__()与__next__()可实现迭代器协议。 具体参照迭代器一章节，这里不再具体演示。 容器相关 __len__() 当使用len(object)时将会自动执行该方法。 该方法应当返回int类型。 示例如下： class Category: x = 1 def __len__(self): return 100 if __name__== \"__main__\": instance = Category() print(len(instance)) # 100 __contains__() 当使用 item in object 时将会自动执行该方法。 该方法应当返回bool类型。 示例如下： class Category: x = 1 def __contains__(self, item): return True if __name__== \"__main__\": instance = Category() print(\"a\" in instance) # True 双下方法一览表 以上介绍的均是常见的双下方法，足以应付大部分使用场景。 下面是双下方法大全表： __new__(cls[, …]) ： 是在一个对象实例化的时候所调用的第一个方法，它的第一个参数是这个类，其他的参数是用来直接传递给 __init__方法。决定是否要使用该 __init__方法，因为 __new__可以调用其他类的构造方法或者直接返回别的实例对象来作为本类的实例，如果 __new__没有返回实例对象，则 __init__不会被调用。 __new__主要是用于继承一个不可变的类型比如一个 tuple 或者 string。 __init__(self[, …])： 构造器，当一个实例被创建的时候调用的初始化方法 __del__(self)： 析构器，当一个实例被销毁的时候调用的方法 __call__(self[, args…])： 允许一个类的实例像函数一样被调用：x(a, b) 调用 x.__call__(a, b) __len__(self)： 定义当被 len() 调用时的行为 __repr__(self)： 定义当被 repr() 调用时的行为 __str__(self)： 定义当被 str() 调用时的行为 __bytes__(self)： 定义当被 bytes() 调用时的行为 __hash__(self)： 定义当被 hash() 调用时的行为 __bool__(self)： 定义当被 bool() 调用时的行为，应该返回 True 或 False __format__(self, format_spec)： 定义当被 format() 调用时的行为 有关属性 __getattr__(self, name)： 定义当用户试图获取一个不存在的属性时的行为 __getattribute__(self, name)： 定义当该类的属性被访问时的行为 __setattr__(self, name, value)： 定义当一个属性被设置时的行为 __delattr__(self, name)： 定义当一个属性被删除时的行为 __dir__(self)： 定义当 dir() 被调用时的行为 __get__(self, instance, owner)： 定义当描述符的值被取得时的行为 __set__(self, instance, value)： 定义当描述符的值被改变时的行为 __delete__(self, instance)： 定义当描述符的值被删除时的行为 比较操作符 __lt__(self, other)： 定义小于号的行为：x y 调用 x.gt(y) __ge__(self, other) ： 定义大于等于号的行为：x >= y 调用 x.ge(y) 算数运算符 __add__(self, other)： 定义加法的行为：+ __sub__(self, other)： 定义减法的行为：- __mul__(self, other)： 定义乘法的行为：* __truediv__(self, other)： 定义真除法的行为：/ __floordiv__(self, other)： 定义整数除法的行为：// __mod__(self, other)： 定义取模算法的行为：% __divmod__(self, other)： 定义当被 divmod() 调用时的行为 __pow__(self, other[, modulo])： 定义当被 power() 调用或 ** 运算时的行为 __lshift__(self, other)： 定义按位左移位的行为：> __and__(self, other)： 定义按位与操作的行为：& __xor__(self, other)： 定义按位异或操作的行为：^ __or__(self, other)： 定义按位或操作的行为：| 反运算 __radd__(self, other)： （与上方相同，当左操作数不支持相应的操作时被调用） __rsub__(self, other) ： （与上方相同，当左操作数不支持相应的操作时被调用） __rmul__(self, other) ： （与上方相同，当左操作数不支持相应的操作时被调用） __rtruediv__(self, other)： （与上方相同，当左操作数不支持相应的操作时被调用） __rfloordiv__(self, other)： （与上方相同，当左操作数不支加粗样式持相应的操作时被调用） __rmod__(self, other)： （与上方相同，当左操作数不支持相应的操作时被调用） __rdivmod__(self, other)： （与上方相同，当左操作数不支持相应的操作时被调用） __rpow__(self, other)： （与上方相同，当左操作数不支持相应的操作时被调用） __rlshift__(self, other)： （与上方相同，当左操作数不支持相应的操作时被调用） __rrshift__(self, other)： （与上方相同，当左操作数不支持相应的操作时被调用） __rand__(self, other)： （与上方相同，当左操作数不支持相应的操作时被调用） __rxor__(self, other)： （与上方相同，当左操作数不支持相应的操作时被调用） __ror__(self, other)： （与上方相同，当左操作数不支持相应的操作时被调用） 增量赋值运算 __iadd__(self, other)： 定义赋值加法的行为：+= __isub__(self, other)： 定义赋值减法的行为：-= __imul__(self, other)： 定义赋值乘法的行为：*= __itruediv__(self, other)： 定义赋值真除法的行为：/= __ifloordiv__(self, other)： 定义赋值整数除法的行为：//= __imod__(self, other)： 定义赋值取模算法的行为：%= __ipow__(self, other[, modulo])： 定义赋值幂运算的行为：**= __ilshift__(self, other)： 定义赋值按位左移位的行为：>= __iand__(self, other)： 定义赋值按位与操作的行为：&= __ixor__(self, other)： 定义赋值按位异或操作的行为：^= __ior__(self, other)： 定义赋值按位或操作的行为：|= 一元操作符 __pos__(self)： 定义正号的行为：+x __neg__(self)： 定义负号的行为：-x __abs__(self)： 定义当被 abs() 调用时的行为 __invert__(self)： 定义按位求反的行为：~x 类型转换 __complex__(self)： 定义当被 complex() 调用时的行为（需要返回恰当的值） __int__(self)： 定义当被 int() 调用时的行为（需要返回恰当的值） __float__(self)： 定义当被 float() 调用时的行为（需要返回恰当的值） __round__(self[, n])： 定义当被 round() 调用时的行为（需要返回恰当的值） __index__(self)： 当对象是被应用在切片表达式中时，实现整形强制转换，若定义了一个可能在切片时用到的定制的数值型,应该定义 __index__，若 __index__被定义，则 __int__也需要被定义，且返回相同的值 上下文管理（with 语句） __enter__(self)： 定义当使用 with 语句时的初始化行为，返回值被 with 语句的目标或者 as 后的名字绑定 __exit__(self, exc_type, exc_value, traceback)： 定义当一个代码块被执行或者终止后上下文管理器应该做什么，一般被用来处理异常，清除工作或者做一些代码块执行完毕之后的日常工作 容器类型 __len__(self)： 定义当被 len() 调用时的行为（返回容器中元素的个数） __getitem__(self, key)： 定义获取容器中指定元素的行为，相当于 self[key] __setitem__(self, key, value)： 定义设置容器中指定元素的行为，相当于 self[key] = value __delitem__(self, key)： 定义删除容器中指定元素的行为，相当于 del self[key] __iter__(self)： 定义当迭代容器中的元素的行为 __reversed__(self)： 定义当被 reversed() 调用时的行为 __contains__(self, item)： 定义当使用成员测试运算符（in 或 not in）时的行为 双下属性 类的属性 __doc__ 类的帮助信息，使用help(class or instanceObject)时，将获得该信息。 class Category: __doc__ = \"hello magic attribute\" if __name__== \"__main__\": help(Category) # class Category(builtins.object) # | hello magic attribute # | # | Data descriptors defined here: # ... __dict__ 类或者实例对象的底层字典。 详情参见类与对象一章。 __slots__ __slots__可以代替__dict__作为类或者实例的属性存储容器。 它还能限制实例对象属性的增加，如下只允许实例对象具有name和age属性，当添加gender属性时抛出异常： class Category: __slots__ = (\"name\", \"age\") if __name__== \"__main__\": instance = Category() instance.name = \"Jack\" print(instance.name) instance.age = 18 print(instance.age) instance.gender = \"male\" # Jack # 18 # AttributeError: 'Category' object has no attribute 'gender' __class__ 在类中调用__class__获得类本身。 通过self.__class__获得实例化出self的类。 推荐使用它来获取类属性，在类中使用__class__.attr而不是className.attr，这样更加灵活。 __base__ 通过className.__base__可获得类的父类，返回父类对象。 详情参见继承一章。 __bases__ 通过className.__bases__可获得类的父类，返回父类对象元组。 详情参见继承一章。 __mro__ 通过className.__mro__可获得该类的属性查找顺序列表。 详情参见继承一章。 全局属性 __file__ 获取当前脚本文件路径： print( __file__ ) # /Users/yunya/PythonProject/demo.py __name__ 如果使用__class__.name，则获取当前类的名称，而不是返回类对象： print( None.__class__ ) print( None.__class__.__name__ ) # # NoneType 如果在全局使用__name__则会判断执行方式是脚本“main”还是模块“module”。 详情参见模块一章。 __all__ 定义模块中允许被import *导入的标识符。 详情参见模块一章。 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-13 20:41:50 "},"Python/Python面向对象/描述符类.html":{"url":"Python/Python面向对象/描述符类.html","title":"描述符类","keywords":"","body":"描述符类 我们在之前接触了代理属性@property装饰器，它其实就是一个描述符，本质上而言是一个新式类。 如果想自定义一个描述符类，则必须实现以下三种双下方法的任意一个或多个： __get__()：获取描述符类实例时，触发该方法 __set__()：设置描述符类实例时，触发该方法 __delete__()：删除描述符类实例时，触发该方法 于此同时还需要注意在定义描述符类时的2点细节： 描述符类本身应该定义成新式类，被代理的类也应该是新式类 必须把描述符实例定义成这个类的类属性，不能定义到__init__()中成为实例属性 简单的属性代理示例，如下所示： 当访问Category.name时，会触发Proxy.__get__()方法 当设置Category.name时，会触发Proxy.__set__()方法 当删除Category.name时，会触发Proxy.__delete__()方法： class Proxy: proxyName = None def __get__(self, instance, owner): # ❶ print(\"run ... Proxy.__get__()\") return __class__.proxyName def __set__(self, instance, value): # ❷ print(\"run ... Proxy.__set__()\") __class__.proxyName = value def __delete__(self, instance): # ❸ print(\"run ... Proxy.__delete__()\") del __class__.proxyName class Category: name = Proxy() if __name__== \"__main__\": ins = Category() ins.name = \"King Kong\" print(ins.name) del ins.name # run ... Proxy.__set__() # run ... Proxy.__get__() # King Kong # run ... Proxy.__delete__() ❶：instance即实例对象本身，就是外部的ins标识符指向的对象，owner即实例对象拥有者，就是Category类 ❷：instance即实例对象本身，就是外部的ins标识符指向的对象，value是新设置的值，即23行的King Kong ❸：instance即实例对象本身，就是外部的ins标识符指向的对象 描述符类的种类 描述符类可分为数据描述符类和非数据描述符类，如下所示： 数据描述符类：至少实现了__get__()和__set__()方法的类 非数据描述符类：只实现了__get__()方法的类 数据描述符类和非数据描述符类对实例对象属性查找极其重要，所以这里特别指出。 如下，定义一个数据描述符类： class Proxy: def __get__(self, instance, owner): print(\"run ... Proxy.__get__()\") return __class__.proxyName def __set__(self, instance, value): print(\"run ... Proxy.__set__()\") __class__.proxyName = value 如下，定义一个非数据描述符类： class Proxy: def __get__(self, instance, owner): print(\"run ... Proxy.__get__()\") return __class__.proxyName 代理属性设置优先级 现在有1个类（Category），它的类属性（name）被代理了，并且代理类（Proxy）中设置了__set__()方法，于此同时被代理类（Category）中也设置了__setattr__()方法。 当对Category的实例对象进行. 操作试图修改name时，会执行哪一个方法？ Category.__setattr__()的优先级是高于Proxy.__set__()的，故会执行Category.__setattr__()方法。 如下所示： class Proxy: proxyName = None def __get__(self, instance, owner): print(\"run ... Proxy.__get__()\") return __class__.proxyName def __set__(self, instance, value): print(\"run ... Proxy.__set__()\") __class__.proxyName = value def __delete__(self, instance): print(\"run ... Proxy.__delete__()\") del __class__.proxyName class Category: name = Proxy() def __setattr__(self, name, value): print(\"run ... Category.__setattr__()\") self.__dict__[name] = value if __name__ == \"__main__\": ins = Category() ins.name = \"King Kong\" # run ... Category.__setattr__() 如果被代理类（Category）没有实现__setattr__()方法，则修改被代理属性name时，会触发Proxy.__set__()方法的执行： class Proxy: proxyName = None def __get__(self, instance, owner): print(\"run ... Proxy.__get__()\") return __class__.proxyName def __set__(self, instance, value): print(\"run ... Proxy.__set__()\") __class__.proxyName = value def __delete__(self, instance): print(\"run ... Proxy.__delete__()\") del __class__.proxyName class Category: name = Proxy() if __name__ == \"__main__\": ins = Category() ins.name = \"King Kong\" # run ... Proxy.__set__() 代理属性查找优先级 当具有描述符类存在时，属性查找顺序不再是一味的从实例开始查找到类及其超类。 而是按照以下流程： object.__getattribute__() 数据描述符 实例对象__dict__ 非数据描述符 类即超类__dict__ 类即超类__getattr__() 整个流程如图下所示： 1）数据描述符的查找优先于实例属性 class Proxy: proxyName = None def __get__(self, instance, owner): print(\"run ... Proxy.__get__()\") return __class__.proxyName def __set__(self, instance, value): print(\"run ... Proxy.__set__()\") __class__.proxyName = value def __delete__(self, instance): print(\"run ... Proxy.__delete__()\") del __class__.proxyName class Category: name = Proxy() def __init__(self) -> None: self.name = \"Proxy.proxyName\" if __name__ == \"__main__\": ins = Category() print(ins.__dict__) print(ins.name) # run ... Proxy.__set__() # {} # run ... Proxy.__get__() # Proxy.proxyName ❶：self.name的时候，由于name本身是一个被数据描述符类代理的属性，且Category未实现__setattr__()故会执行Proxy.__set__()方法，现在Proxy.proxyName = “Proxy.proxyName” ❷：由于self.name操作触发了Proxy代理类的__set__()方法执行，故instance.__dict__中并未拥有任何实例属性 ❷：28行print()操作试图获取这个被数据描述符类代理的属性，故会执行Proxy.__get__()方法获取并返回Proxy.proxyName 2）实例属性的查找优先于非数据描述符 class Proxy: proxyName = None def __get__(self, instance, owner): print(\"run ... Proxy.__get__()\") return __class__.proxyName class Category: name = Proxy() def __init__(self) -> None: self.name = \"instance name\" # ❶ if __name__ == \"__main__\": ins = Category() print(ins.__dict__) print(ins.name) # {'name': 'instance name'} # instance name ❶：self.name的时候，由于name不是一个被数据描述符类代理的属性，故底层会执行object.__setattr__()方法，将name变更为实例属性存储至instance.__dict__中 3）实例属性的查找优先于类属性 class Category: name = \"class name\" def __init__(self) -> None: self.name = \"instance name\" if __name__ == \"__main__\": ins = Category() print(ins.__dict__) print(ins.name) # {'name': 'instance name'} # instance name 描述符类简单应用 众所周知，Python是动态语言，即参数的赋值没有类型限制，下面我们通过描述符机制来实现类型限制功能。 注意点：如果对传入值进行参数设置，其被描述符代理属性的类千万不要设置 __setattr__()，因为__setattr__()方法的优先级高于描述符的__get__()方法。 class Proxy: def __init__(self, key, expectedType) -> None: self.key = key self.expectedType = expectedType def __get__(self, instance, owner): if instance is None: # ❶ return self return instance.__dict__[self.key] def __set__(self, instance, value): if not isinstance(value, self.expectedType): raise TypeError(\"parameter type error, expected %s type %s, but you give type is %s\" % ( self.key, self.expectedType, type(value))) instance.__dict__[self.key] = value def __delete__(self, instance): del instance.__dict__[self.key] class Category: name = Proxy(\"name\", str) age = Proxy(\"age\", int) def __init__(self, name: str, age: int) -> None: self.name = name self.age = age if __name__ == \"__main__\": ins = Category(\"Jack\", 18) print(ins.name, type(ins.name)) print(ins.age, type(ins.age)) # Jack # 18 ❶：这个判断条件是针对使用Category.被代理属性，如果是这样直接返回Proxy实例即可 类装饰器 装饰器可以给类装饰 装饰器的本质就是将@decorator下面的可调用对象当做参数自动传入到装饰器中，类本身是可调用的，因此我们也可以给类的上面套一个装饰器。 类的无参装饰器： def warpper(object): object.attr = \"newAttr\" return object @warpper class Category: pass if __name__ == \"__main__\": print(Category.attr) # newAttr 类的有参装饰器： def warpper(**kwargs): def inner(object): for k, v in kwargs.items(): setattr(object, k, v) return object return inner @warpper(name=\"Category\", type=\"class\") class Category: pass if __name__ == \"__main__\": for k,v in Category.__dict__.items(): if not k.startswith(\"__\"): print(k, v) # name Category # type class 类也可以作为装饰器 一定要理解，装饰器的本质只是将@decorator下对象的引用传入至形参中，所以我们也可以将类作为装饰器： class Warpper: def __new__(cls, instanceClass) -> object: instanceClassObject = instanceClass(\"Jack\", 18, \"male\") return instanceClassObject @Warpper class Category: def __init__(self, name, age, gender) -> None: self.name = name self.age = age self.gender = gender if __name__ == \"__main__\": print(Category) print(Category.name) print(Category.age) print(Category.gender) # # Jack # 18 # male 在这个例子中，Category其实是Category的instance对象。 描述符与类装饰器应用 属性类型限制 我们在学习了类的装饰器后，已经可以将其与描述符类相结合，完成以下功能了。 1）通过给类添加有参装饰器实现动态添加类属性： def addClassAttribute(**kwargs): def inner(cls): for k, v in kwargs.items(): setattr(cls, k, v) return cls return inner @addClassAttribute(name=\"Jack\", age=18, gender=\"male\") class Person: pass if __name__ == \"__main__\": for k, v in Person.__dict__.items(): if not k.startswith(\"__\"): print(k, v) # name Jack # age 18 # gender male 2）通过给类添加有参装饰器以及配合数据描述符实现实例属性类型检测： class Proxy: def __init__(self, key, expectedType) -> None: self.key = key self.expectedType = expectedType def __get__(self, instance, owner): if instance is None: # ❶ return self return instance.__dict__[self.key] def __set__(self, instance, value): if not isinstance(value, self.expectedType): raise TypeError(\"parameter type error, expected %s type %s, but you give type is %s\" % ( self.key, self.expectedType, type(value))) instance.__dict__[self.key] = value def __delete__(self, instance): del instance.__dict__[self.key] def addClassAttribute(**kwargs): def inner(cls): for k, v in kwargs.items(): setattr(cls, k, Proxy(key=k, expectedType=v)) return cls return inner @addClassAttribute(name=str, age=int, gender=str) class Person: def __init__(self, name: str, age: int, gender: str) -> None: self.name = name self.age = age self.gender = gender if __name__ == \"__main__\": for k, v in Person.__dict__.items(): if not k.startswith(\"__\"): print(k, v) ins = Person(name=\"Jack\", age=\"19\", gender=1) # name # age # gender # TypeError: parameter type error, expected type , but you give type is ❶：这个判断条件是针对使用Person.被代理属性，如果是这样直接返回Proxy实例即可 自定义property @property本身是通过描述符类实现的，因此我们也可以自己实现: class Property: def __init__(self, method) -> None: self.method = method def __get__(self, instance, owner): if instance is None: # ❶ return self else: v = self.method(instance) # ❷ # instance.__dict__[self.method.__name__] = v # ❸ return v class Person: def __init__(self, name, height, weight): self.name = name self.height = height self.weight = weight @Property def bmi(self): v = self.weight / (self.height ** 2) if 20 25: return \"overweight\" return \"obesity\" if __name__ == \"__main__\": instanceObject = Person(\"ken\", height=1.76, weight=77) print(instanceObject.bmi) #　normal ❶：这个判断条件是针对使用Person.被代理属性的操作，如果是这样直接返回Proxy实例即可 ❷：手动的为self传递参数为instance ❸：这里是做一个缓存功能，将第一次求值结果存放至实例字典中。 如果要做缓存功能，则需要注意自定义的这个描述符种类必须是非数据描述符，因为数据描述符属性的查找顺序是在实例之前。 此外，如果添加上缓存功能，后续该实例的身高体重一旦发生改变，则会导致二次求值结果不准确，因此一般不做这个缓存 自定义classmethod @classmethod本身是通过描述符类实现的，因此我们也可以自己实现: class ClassMethod: def __init__(self, method) -> None: self.clsMethod = method def __get__(self, instance, owner): def inner(*args, **kwargs): return self.clsMethod(owner, *args, **kwargs) return inner class Person: desc = \"This is person class\" @ClassMethod def show(cls, x, y, z): print(x, y, z) print(cls.desc) if __name__ == \"__main__\": Person.show(1, 2, 3) # 1 2 3 # This is person class 自定义staticmethod @staticmethod本身是通过描述符类实现的，因此我们也可以自己实现： class StaticMethod: def __init__(self, method) -> None: self.staticMethod = method def __get__(self, instance, owner): def inner(*args, **kwargs): return self.staticMethod(*args, **kwargs) return inner class Person: @StaticMethod def show(x, y, z): print(x, y, z) if __name__ == \"__main__\": Person.show(1, 2, 3) # 1 2 3 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-07-06 11:47:50 "},"Python/Python面向对象/元类编程.html":{"url":"Python/Python面向对象/元类编程.html","title":"元类编程","keywords":"","body":"一切皆对象 函数是对象 Python中一切皆对象，故函数也是一个实例对象。 通过function.__class__，可以拿到创建出函数这个实例对象的类： >>> func = lambda : 1 >>> print(func.__class__) 我们还可以为函数实例对象增添实例属性，虽然没人会这样做： >>> func.attr = \"intance attribute\" >>> func.attr 'intance attribute' 类也是对象 由于一切皆对象的缘故，故类也是一个实例对象。 而创建出类这个实例对象的类，被称为元类（metaclass），Python中只有1个内置元类，为type。 如下示例，使用class.__class__即可拿到元类type： >>> int.__class__ >>> list.__class__ >>> class Category: pass >>> Category.__class__ 什么是元类 经过上面的例子，我们可以看见所有类都是由元类type类进行实例化而得到的。 故元类即为创造类的类，它的作用主要有2个： 用于生产出类对象 用于生产出类对象的实例对象 class定义内部机制 当我们使用class关键字定义一个类之后，底层的创建步骤大体可分为4步： 拿到类标识符 拿到类的基类 执行类体代码，创建类的命名空间 调用元类，默认为type类，得到实例化出的类对象 创建类不一定非要使用class关键字，也可以有其他形式，下面这个示例将重现上面4大步骤： # first step : get class name className = \"Person\" # second step : get class parent class and super class and bases classes classBasesClass = (object, ) # third step 1 : definition class __dict__ ， Now this is empty classDict = {} # third step 2 : get class body code , It is interpreted by Python is a string classBody = \"\"\" def __init__(self, name, age, gender): self.name = name self.age = age self.gender = gender def show(self): return \"name : %s age : %s gender : %s\"%(self.name, self.age, self.gender) \"\"\" # first param : class body code # second param : global name space # last param : class __dict__ , is class local name space exec(classBody, {}, classDict) # Now, class __dict__ have content, class initing end print(classDict) # last step # class name give global identifier Person Person = type(className, classBasesClass, classDict) if __name__ == \"__main__\": ins = Person(name=\"Jack\", age=18, gender=\"male\") print(ins.show()) 自定义元类 如何自定义元类 如果一个类继承了type类，那么他就是一个元类： class MetaClass(type): pass print(type(MetaClass)) # 元类如何生产出类对象 元类如何生成出一个类呢？实际上class ClassName后执行脚本时这一系列过程都是自动的。 在元类中会经历2大步骤： 调用元类自己的__new__()方法，构建出1个空的类对象 调用元类自己的__init__()方法，为空的类对象增添属性 详细的整体过程如图所示： 如下示例，我们如果要指定1个类的元类，则必须在其继承括号中添加上 metaclass = className 的字样： class MetaClass(type): def __new__(cls, *args, **kwargs) -> object: \"\"\" cls : meta class args : (class name, (class bases, ), { class __dict__ }) kwargs : empty dict Returns: object: meta class instance object \"\"\" # must transfer all params return super(__class__, cls).__new__(cls, *args, **kwargs) def __init__(self, *args, **kwargs) -> None: \"\"\" self : meta class instance object args : (class name, (class bases, ), { class __dict__ }) kwargs : empty dict Returns: None \"\"\" super(__class__, self).__init__(*args, **kwargs) class Person(object, metaclass=MetaClass): pass if __name__ == \"__main__\": pass 当解释器执行到25行时，会自动调用元类__new__()方法开始构造类对象。 元类如何生产出类的实例对象 一个普通的类如果创建实例对象，必定会使用className()的形式。 那么他底层会做什么事情呢？如下所示： 当className()时， 类自动调用元类下的_call\\_()方法 元类下的__call__()方法会自动调用类的__new__()方法，创建出一个空的实例化对象 元类下的__call__()方法会自动调用类的__init__()方法，为这个空实例化对象增添实例属性 元类下的__call__()方法将返回造好的这个实例化对象 如下所示： class MetaClass(type): # create cls object method : __new__() 、 __init__() def __new__(cls, *args, **kwargs) -> object: return super(__class__, cls).__new__(cls, *args, **kwargs) def __init__(self, *args, **kwargs) -> None: super(__class__, self).__init__(*args, **kwargs) # create cls instance obj method : __call__() def __call__(cls, *args, **kwargs) -> object: \"\"\" cls : meta class instance object args : cls instance position params kwargs : cls instance keyword params Returns : cls instance object \"\"\" clsInstanceObject = cls.__new__(cls, *args, **kwargs) cls.__init__(clsInstanceObject, *args, **kwargs) return clsInstanceObject class Person(object, metaclass=MetaClass): def __new__(cls, *args, **kwargs) -> object: return super(__class__, cls).__new__(cls) def __init__(self, name, age, gender) -> None: self.name = name self.age = age self.gender = gender if __name__ == \"__main__\": ins = Person(name=\"Jack\", age=18, gender=\"male\") 过程图示如下： 实例对象与类对象的属性查找 查找的区别 我们如果对ins加上括号，会不会调用元类的__call()__方法呢？ 答案是不会，实例对象和类对象的属性查找是不一样的，验证如下所示： class MetaClass(type): # create cls object method : __new__() 、 __init__() def __new__(cls, *args, **kwargs) -> object: return super(__class__, cls).__new__(cls, *args, **kwargs) def __init__(self, *args, **kwargs) -> None: super(__class__, self).__init__(*args, **kwargs) # create cls instance obj method : __call__() def __call__(cls, *args, **kwargs) -> object: clsInstanceObject = cls.__new__(cls, *args, **kwargs) cls.__init__(clsInstanceObject, *args, **kwargs) return clsInstanceObject class Person(object, metaclass=MetaClass): def __new__(cls, *args, **kwargs) -> object: return super(__class__, cls).__new__(cls) def __init__(self, name, age, gender) -> None: self.name = name self.age = age self.gender = gender if __name__ == \"__main__\": ins = Person(name=\"Jack\", age=18, gender=\"male\") ins() # TypeError: 'Person' object is not callable 类对象的属性查找顺序 类对象如果要进行属性查找，它会去父类、超类、object基类以及type元类中查找。 如图所示： 示例如下： class MetaClass(type): findAttr = \"MetaClass.attr\" class A: # findAttr = \"A.attr\" pass class B(A): # findAttr = \"B.attr\" pass class C(B, metaclass=MetaClass): # findAttr = \"C.attr\" pass if __name__ == \"__main__\": print(C.findAttr) 实例对象的属性查找顺序 类的实例对象如果要进行属性查找，它会去父类、超类、object基类中查找，不会去元类层。 如图所示： 示例如下： class MetaClass(type): findAttr = \"MetaClass.attr\" class A: findAttr = \"A.attr\" pass class B(A): # findAttr = \"B.attr\" pass class C(B, metaclass=MetaClass): # findAttr = \"C.attr\" pass if __name__ == \"__main__\": ins = C() print(ins.findAttr) 实例练习 类的命名规则检测 有了自定义元类，我们可以将自定义类的命名规定为必须大驼峰，否则抛出异常： class MetaClass(type): def __new__(cls, *args, **kwargs): if not args[0].istitle(): raise NameError(\"class %s name must upper\" % args[0]) super(__class__, cls).__new__(cls, *args, **kwargs) class category(metaclass=MetaClass): pass # NameError: class name must upper 类的文档信息检测 有了自定义元类，我们可以规定类必须书写文档信息，即__doc__，否则抛出异常： class MetaClass(type): def __new__(cls, *args, **kwargs): if \"__doc__\" not in args[-1] : raise SyntaxError(\"class %s must have help doc\" % args[0]) super(__class__, cls).__new__(cls, *args, **kwargs) class Category(metaclass=MetaClass): pass # SyntaxError: class Category must have help doc Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-13 20:41:50 "},"Python/Python面向对象/异常处理.html":{"url":"Python/Python面向对象/异常处理.html","title":"异常处理","keywords":"","body":"异常介绍 异常分类 　　程序中难免出现错误，总共可分为两种。 　　1.逻辑错误 　　2.语法错误 　　对于刚接触编程的人来说，这两个错误都会经常去犯，但是随着经验慢慢的积累，语法错误的情况会越来越少反而逻辑错误的情况会越来越多（因为工程量巨大）。 不论多么老道的程序员都不可避免出现这两种错误。 异常信息 　异常其实就是程序运行时发生错误的信号，我们写代码的过程中不可避免也最害怕的就是出现异常，然而当程序抛出异常时实际上会分为三部分，即三大信息。 常见异常 在Python中一切皆对象，异常本身也是由一个类生成的，NameError其实本身就是一个异常类，其他诸如此类的异常类还有很多，如下表所示。 异常类 描述 AttributeError 属性错误，被查找属性不存在 IOError IO错误，文件无法打开 ImportError 导包错误，导入模块或包时给定了错误的路径或导入了没有的功能 IndentaionError 缩进错误，代码没有正确对齐 KeyError 键错误，获取字典中不存在的键 NameError 标识符错误，试图使用一个未被赋值的标识符 SyntaxError 语法错误，代码写错了 TypeError 类型错误，传入对象的类型和预期不符 ValueError 值错误，传入一个调用者不期望的值，即使值的类型是正确的 AssertionError 断言异常 异常处理 我们可以来用某些方法进行异常捕捉，当出现异常时我们希望代码以另一种逻辑运行，使得我们的程序更加健壮，这个就叫做异常处理。 异常处理是非常重要的，本身也并不复杂，千万不可马虎大意，但是切记不可滥用异常处理，这会使得你的代码可读性变差。 if else处理异常 if和else本身就具有处理异常的功能，他们更多的是在我们能预测到可能出现异常的范围内进行规避异常，对于我们不能预测的异常来说就显得不是那么的好用。 如下所示，我们仅期待用户输入数字，如果是输入其他内容则会被其他逻辑所处理： while 1: choice = input(\"Please enter a digital string:\") if choice.isdigit(): print(\"success!!\") break else: print(\"You input not is a digital string!!\") try/except try和except是最常用的一种异常处理方式。 try：代表要检测可能出现异常的代码块 except：当特定异常出现后的处理情况 执行流程如下： try中检测的代码块 如果有异常 执行except代码块 执行正常逻辑 执行完毕 try中检测的代码块 如果无异常 执行完try中代码快 执行正常逻辑 执行完毕 如图所示： 示例如下，try中未抛出异常： lst = [i for i in range(3)] try: print(\"run try\") print(lst[2]) except IndexError as e: print(\"run except\") print(\"normal code\") # run try # 2 # normal code 示例如下，try中抛出异常： lst = [i for i in range(3)] try: print(\"run try\") print(lst[3]) except IndexError as e: print(\"run except\") print(\"normal code\") # run try # run except # normal code 多段except捕捉多异常 使用1个try和多个except来捕捉多种可能出现的异常： lst = [i for i in range(3)] dic = dict.fromkeys((chr(i) for i in range(65, 68)), None) try: print(lst[2]) print(dic[\"D\"]) except IndexError as e: print(\"index error %s \" % e) except KeyError as e: print(\"key error %s\" % e) print(\"normal code\") # 2 # key error 'D' # normal code 元组捕获多异常 使用多段except处理多异常会显得麻烦，可以使用except (error1, error2)来处理多个异常。 但是多个异常只有1个处理结果，故处理逻辑可能会写的比较麻烦： lst = [i for i in range(3)] dic = dict.fromkeys((chr(i) for i in range(65, 68)), None) try: print(lst[2]) print(dic[\"D\"]) except (IndexError, KeyError) as e: if isinstance(e, IndexError): print(\"index error %s\" % e) elif isinstance(e, KeyError): print(\"key error %s\" % e) print(\"normal code\") # 2 # key error 'D' # normal code except捕获万能异常 使用except Exception来捕捉所有可能出现的异常，Exception是所有异常的基类。 Exception类的父类则是BaseException类，而BaseException的父类则是object类 lst = [i for i in range(3)] dic = dict.fromkeys((chr(i) for i in range(65, 68)), None) try: print(lst[2]) print(dic[\"D\"]) except Exception as e: if isinstance(e, IndexError): print(\"index error %s\" % e) elif isinstance(e, KeyError): print(\"key error %s\" % e) print(\"normal code\") # 2 # key error 'D' # normal code try/except/esle else代表没有异常发生的情况下执行的代码，如下图所示： 如下示例： lst = [i for i in range(3)] dic = dict.fromkeys((chr(i) for i in range(65, 68)), None) try: print(lst[2]) print(dic[\"A\"]) except Exception as e: if isinstance(e, IndexError): print(\"index error %s\" % e) elif isinstance(e, KeyError): print(\"key error %s\" % e) else: print(\"don't have throw an exception\") print(\"normal code\") # 2 # None # don't have throw an exception # normal code try/except/else/finally finally代表不论抛异常与否都会执行，因此常被用作关闭系统资源的操作。 如下图所示： 如下示例： lst = [i for i in range(3)] dic = dict.fromkeys((chr(i) for i in range(65, 68)), None) try: print(lst[2]) print(dic[\"A\"]) except Exception as e: if isinstance(e, IndexError): print(\"index error %s\" % e) elif isinstance(e, KeyError): print(\"key error %s\" % e) else: print(\"don't have throw an exception\") finally: print(\"last run this\") print(\"normal code\") # 2 # None # don't have throw an exception # last run this # normal code 主动抛出异常 在某些时候我们可能需要主动的去阻止程序的运行，主动的抛出一个异常。 以防止逻辑越错越远。 raise raise可以主动的抛出一个异常，如下所示： lst = [i for i in range(3)] l = input(\"please input %s length >>>\" % lst) if not l.isdigit(): raise TypeError(\"you must input number\") if int(l) != len(lst): raise ValueError(\"your length input error, he length is not %s\" % l) if int(l) == len(lst): print(\"success!!\") assert 断言内部会进行if判断，如果判断结果为False则抛出AssertionError异常，如果为True就不抛出AssertionError异常。 如下所示： lst = [i for i in range(3)] l = input(\"please input %s length >>>\" % lst) assert l.isdigit(), \"you must input number\" assert int(l) == len(lst), \"your length input error, he length is not %s\" % l print(\"success!!\") 自定义异常 前面已经说过一切皆对象，异常也来自一个对象，所以我们可以自定义一个异常，只需要继承BaseException类即可。 如下示例，内置异常没有InputTypeError，我们来自己定义一个： class InputTypeError(BaseException): pass lst = [i for i in range(3)] l = input(\"please input %s length >>>\" % lst) if not l.isdigit(): raise InputTypeError(\"you must input number\") if int(l) != len(lst): raise ValueError(\"your length input error, he length is not %s\" % l) if int(l) == len(lst): print(\"success!!\") Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-13 20:41:50 "},"Python/Python数算基础/summary.html":{"url":"Python/Python数算基础/summary.html","title":"Python数算基础","keywords":"","body":" 算法与数构 list和dict性能 数构之线构篇 数构之哈希篇 数构之链表篇 算法之递归篇 算法之搜索篇 算法之排序篇 数构之树相关 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-22 16:35:16 "},"Python/Python数算基础/算法与数构.html":{"url":"Python/Python数算基础/算法与数构.html","title":"算法与数构","keywords":"","body":"为什么要学习数算 随着应用程序变的越来越复杂，我们最常思考的问题无非下面2个： 如何存储海量数据？ 如何从海量数据中操纵所需要的数据？ 为了解决上述问题，我们需要有合理的机制来规划如何存储数据，那么如何存储数据即为数据的结构。 同时，我们还需要制定一系列方案，来思考如何从海量数据中进行增、删、改、查，这一方案的实现即程序的算法。 尼克劳斯·埃米尔·维尔特（n.writh）说过一句很著名的话： 程序 = 算法 + 数据结构 因此，一个良好的健硕的程序，必然根据其业务场景采用了合适的数据存储方案，并且指定了一系列相关的数据操纵方案。 什么是算法 算法的定义 算法（Algorithm）是指解题方案的准确而完整的描述，是一系列解决问题的清晰指令，算法代表着用系统的方法描述解决问题的策略机制。 也就是说，能够对一定规范的输入，在有限时间内获得所要求的输出。 如果一个算法有缺陷，或不适合于某个问题，执行这个算法将不会解决这个问题。 不同的算法可能用不同的时间、空间或效率来完成同样的任务。 一个算法的优劣可以用空间复杂度与时间复杂度来衡量。 算法与语言本身无关，仅是一种解决思路，用于解决一些实际的问题 通过知名算法的学习，可以提高编程思维，优化程序代码。 算法的特征 一个算法应该具有以下五个重要的特征： 有穷性（Finiteness） 算法的有穷性是指算法必须能在执行有限个步骤之后终止； 确切（Definiteness） 算法的每一步骤必须有确切的定义； 输入项（Input） 一个算法有0个或多个输入，以刻画运算对象的初始情况，所谓0个输入是指算法本身定出了初始条件； 输出项（Output） 一个算法有一个或多个输出，以反映对输入数据加工后的结果。没有输出的算法是毫无意义的； 可行性（Effectiveness） 算法中执行的任何计算步骤都是可以被分解为基本的可执行的操作步骤，即每个计算步骤都可以在有限时间内完成（也称之为有效性）。 算法的评定 同一问题可用不同算法解决，而一个算法的质量优劣将影响到算法乃至程序的效率。 算法分析的目的在于选择合适算法和改进算法。 一个算法的评价主要从时间复杂度和空间复杂度来考虑。 除此之外，评定规则还有以下3个： 正确性 算法的正确性是评价一个算法优劣的最重要的标准 可读性 算法的可读性是指一个算法可供人们阅读的容易程度 鲁棒性 鲁棒性是指一个算法对不合理数据输入的反应能力和处理能力，也称为容错性 时间复杂度 时间复杂度是指算法的大概运行时间，是判定算法优劣的重要评定规则，使用大O进行表示。 对一个算法的时间复杂度而言，对其影响最大因素就是需要解决的问题规模。 问题规模越大，解决时间也就越久，如下图所示： 时间复杂度更多是表示一个模糊的大概时间，而并非一个具体的准确的数字。 如： 抽一支烟，这个行为大概会占用几分钟的时间 睡一觉，这个行为大概会占用几个小时的时间 当然，这只是大概，并不用进行精确的求值，因为个体差异，客观环境因素等原因都会导致这个时间度不同，没有人敢确切的说自己在任何情况下抽一支烟只花费3分钟，也没有人敢确切的说自己在任何情况下睡一觉只花费8个小时。 时间复杂度可依照基础语句对其进行判断，基础语句操作的时间复杂度记为1 除此之外还有循环次数n，和循环嵌套层数n²或者n³、至于四层循环就很少了，不再举例。 当有多种判定时，取最大的即可： 1）仅一次基础操作，时间复杂度就直接等于1： x = 1 # O(1) # 取O(1) 2）根据问题规模而变化，单次循环，时间复杂度等于循环次数n： for i in range(n): # O(n) x = i # O(1) # 取O(n) 3）一个更加复杂的问题规模，双层循环，时间复杂度等于循环次数n加上循环嵌套层数： for i in range(n): # O(n²) for j in range(n): x = i + j # O(1) # 取O(n²) 4）目前来说相当复杂的问题规模，三层循环，时间复杂度等于循环次数n加上循环嵌套层数： for i in range(n): # O(n³) for j in range(n): for k in range(n): x = i + j + k # O(1) # 取 O(n³) 当然，不要陷入逻辑误区，像下面这条语句的时间复杂度也是O(1)，因为1次基础操作和3次基础操作的速度没有本质区别，它没有一个可以改变问题规模的n，所以归类为O(1)而不是O(3)。 一定记住一句话，时间复杂度是一个模糊的估算值，并不是确切值： x = 1 x = 2 x = 3 继续判断，将下面代码看为4部分，依照取最大的原则： a = 5 # O(1) b = 6 c = 10 for i in range(n): # O(n²) for j in range(n): x = i * i y = j * j z = i * j for k in range(n): # O(n) w = a * k + 45 v = b * b d = 33 # O(1) # 取O(n²) 同时，如果双层循环中，内层循环有多个，时间复杂度也记为O(n²)，因为循环只嵌套了2层，如下所示： for i in range(n): for j in range(n): pass for k in range(n): pass # 层数是2，所以取O(n²) 还有一个常见的时间复杂度，O(logn)。 如下所示，每一次运行，问题规模减少一半，其实全部表示法是O(log2n)，简写为了O(logn)，这种时间复杂度在递归中很容易看到。 n = 64 # O(1) while n > 1: # O(log2n) print(n) # O(1) n = n // 2 以下方法可快速判断算法的时间复杂度： 确定问题规模O(n) 有没有循环减半的过程O(logn) 有几层循环O(nn) 空间复杂度 空间复杂度是用来评估算法内存占用大小的式子。 空间复杂度和时间复杂度是一种相对应的关系，一句很流行的话叫做空间换时间，也是现在的主流，如分布式等架构就是典型的空间换时间。 表示方式与时间复杂度完全一样，都采用大O表示法： 算法使用了几个变量：O(1) 算法使用了长度为n的一维列表：O(n) 算法使用了n行n列的二维列表：O(nn) 一般来说，时间复杂度的判定比空间复杂度的判定更为重要。 什么是数据结构 数据结构的定义 数据结构是计算机存储、组织数据的方式。 数据结构是指相互之间存在一种或多种特定关系的数据元素的集合。 通常情况下，精心选择的数据结构可以带来更高的运行或者存储效率。 数据结构往往同高效的检索算法和索引技术有关。 常见数据结构 线性结构：数据结构中的元素存在一对一的相互关系 树形结构：数据结构中的元素存在一对多的相互关系 图形结构：数据结构中的元素存在多对多的相互关系 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-13 21:41:58 "},"Python/Python数算基础/list和dict性能.html":{"url":"Python/Python数算基础/list和dict性能.html","title":"list和dict性能","keywords":"","body":"2种常用类型 在Python中，最常用的2种数据类型为list和dict。 你是否了解过它们的各种方法，时间复杂度到底如何？在那种策略下用那种方法更省时？ 两种数据类型都拥有很多方法，常用的亦或是不常用的，因此在Python设计之初定下了一个原则： 让最常用的操作性能最好，牺牲不太常用的操作 在实际使用中，80%的功能其使用率往往只有20%，因此将剩下的20%的功能时间复杂度降低，而将不常用的80%功能时间复杂度增加，做到一种均衡的策略。 其实在Python官网上，已经贴出了每种数据类型方法的时间复杂度，点我跳转 dict 官方展示 The Average Case assumes parameters generated uniformly at random. Internally, a list is represented as an array; the largest costs come from growing beyond the current allocation size (because everything must move), or from inserting or deleting somewhere near the beginning (because everything after that must move). If you need to add/remove at both ends, consider using a collections.deque instead. Operation Average Case Amortized Worst Case Copy O(n) O(n) Append[1] O(1) O(1) Pop last O(1) O(1) Pop intermediate[2] O(n) O(n) Insert O(n) O(n) Get Item O(1) O(1) Set Item O(1) O(1) Delete Item O(n) O(n) Iteration O(n) O(n) Get Slice O(k) O(k) Del Slice O(n) O(n) Set Slice O(k+n) O(k+n) Extend[1] O(k) O(k) Sort O(n log n) O(n log n) Multiply O(nk) O(nk) x in s O(n) min(s), max(s) O(n) Get Length O(1) O(1) pop()和inster() pop()和inster()通常来说有2种情况： 如果都是操纵list[-1]，也就是最后一个数据项，它们的时间复杂度均为O(1) 如果操纵的是其他数据项，则时间复杂度均为O(n) 由于list底层是顺序存储，故任何一个非index-1的数据项的添加或删除都会引起整个列表的调整。 例如，从中部移除数据项的话，要把被移除数据项后面的全部数据项向前挪一个槽位。 虽然看起来有点笨拙，但这种实现方法能够保证列表按索引取值和赋值的操作很快，能够达到O(1)的良好情况。 这也算是一种对常用和不常用操作的折衷方案吧。 dict 官方展示 The Average Case times listed for dict objects assume that the hash function for the objects is sufficiently robust to make collisions uncommon. The Average Case assumes the keys used in parameters are selected uniformly at random from the set of all keys. Note that there is a fast-path for dicts that (in practice) only deal with str keys; this doesn't affect the algorithmic complexity, but it can significantly affect the constant factors: how quickly a typical program finishes. Operation Average Case Amortized Worst Case k in d O(1) O(n) Copy[3] O(n) O(n) Get Item O(1) O(n) Set Item[1] O(1) O(n) Delete Item O(1) O(n) Iteration[3] O(n) O(n) 为什么字典这么快 dict内部采用hash存储，所以单点查找非常迅速，但不能使用范围查找。 这也是所有hash存储的特性，是属于一种典型的空间换时间的方案。 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-14 17:04:26 "},"Python/Python数算基础/数构之线构篇.html":{"url":"Python/Python数算基础/数构之线构篇.html","title":"数构之线构篇","keywords":"","body":"Linear Structure 认识线性结构 线性结构是一种有序的数据项集合结构，线性结构中除开第一个后最后一个数据项，其他每一个数据项都有前驱和后继，如图所示： 当新的数据项加入到数据集中时，只会加入到原有某个数据项之前或之后。 具有这种性质的数据集，就称为线性结构。 如Python中的list、tuple等数据类型都属于线性结构。 特点介绍 线性结构总有2端，在不同情况下，2端的称呼也不同。 如称呼为：(前端、后端)，（左端、右端）、（首端、尾端）： 还有称呼为：（上端、下端）、（顶端、底端）： 两端的称呼并不是关键，不同线性结构的关键区别在于数据项增减的方式。 有的线性结构只允许数据项从一端添加或删除，而有的线性结构则允许数据项从两端添加或删除，或者从任意位置添加或删除： 栈（Stack） 栈的特点 栈是一种数据项进出有序的线性结构，在栈中，所有数据项的加入和移除都只能发生在栈顶（stack top），而栈底（stack base）则不能有其他操作。 栈中的数据项总是按照后进先出（LIFO）的特性进行出入栈，如下图所示： 栈有一个特性，即进栈和出栈的次序正好相反。 这种访问次序反转的特性，我们在某些计算机操作上也经常碰到过，如浏览器的“后退back”按钮，最先back的是最近访问的网页，再比如Word的“Undo”按钮，最先撤销的是最近操作。 ADT Stack 如果要使用Python来定义栈这种数据结构，则应当提供以下方法： 方法名 描述 ADTStack() 一个类，用于构建一个空栈 push() 将值加入到栈顶，无返回值 pop() 将栈顶数据项移除，并返回被移除的数据项，栈会被修改 peek() “窥视”栈顶数据项，返回栈顶的数据项但不移除，栈不被修改 isEmpty() 返回栈是否为空栈 size() 返回栈中有多少个数据项 接下来我们基于Python内置的数据类型list，来实现一个栈。 其实实现非常简单，唯一需要考虑的就是栈顶是index-1处还是index0处。 推荐将index-1处作为栈顶，这样在进行出栈操作时list.pop()和list.append()方法时间复杂度为O(1)，而如果将index0处作为栈顶，则list.pop(0)和list.insert(0, item)方法的时间复杂度为O(n)： 以下是代码实现： #!/usr/bin/env python3 # -*- coding:utf-8 -*- class ADTStack: def __init__(self) -> None: self.stack = [] def push(self, item): self.stack.append(item) def pop(self): return self.stack.pop() def peek(self): return self.stack[-1] def isEmpty(self): return not bool(self.stack) def size(self): return len(self.stack) 符号匹配 我们可以利用栈的特性实现一个符号匹配，一组括号必须成对出现，如下所示： { { ( [ ] [ ] ) } ( ) } [ [ { { ( ( ) ) } } ] ] [ ] [ ] [ ] ( ) { } 如果不是成对出现的，像下面这样，就匹配失败： ( [ ) ] ( ( ( ) ] ) ) [ { ( ) ] 代码如下： from linear_structure import ADTStack def SymbolMatch(symbolString): s = ADTStack() leftSymbolString = \"([{\" rightSymbolString = \")]}\" for char in symbolString: # 如果被循环的字符是左符号 if char in leftSymbolString: s.push(char) # 如果被循环的字符不是左符号，也不是右符号，则抛出异常 elif not char in rightSymbolString: raise ValueError(\"character:% s does not support matching\" % char) # 开始循环右符号 else: # 1. 如果是空栈，代表左右符号个数不一，直接返回False # 2. 如果不是空栈，则判定左右符号是否匹配，如果不匹配直接返回False if s.isEmpty() or leftSymbolString.index(s.pop()) != rightSymbolString.index(char): return False # 循环完毕，判定所有左符号是否匹配完毕 return True if s.isEmpty() else False if __name__ == \"__main__\": print(SymbolMatch(\"{{([][])}()}\")) print(SymbolMatch(\"[{()]\")) 进制转换 使用栈的特性，我们可以快速实现2、8、16进制转换为10进制的函数。 思路图示，10进制转换2、8、16进制都可采用求余法，下图以2进制举例： 代码如下： from linear_structure import ADTStack def baseConversion(decimalNumber, base): s = ADTStack() digits = \"0123456789ABCDEF\" while decimalNumber > 0: quotient, residue = divmod(decimalNumber, base) decimalNumber = quotient s.push(residue) newString = \"\" while not s.isEmpty(): newString += digits[s.pop()] return newString if __name__ == \"__main__\": print(baseConversion(101, 2)) print(baseConversion(101, 8)) print(baseConversion(101, 16)) # 1100101 # 145 # 65 队列（Queue） 队列的特点 队列是一种数据项进出有序的线性结构，在队列中，数据项的添加总发生在其中一端（通常称为尾“tail”端），而数据项的移除总发生在另一端（通常称为首“head”端） 队列中的数据项总是按照先进后出（FILO）的特性进行出入栈，如下图所示： 队列仅有一个入口和一个出口，不允许数据项直接插入队中，也不允许从中间移除数据项。 队列其实在生活中随处可见，如排队、必须等到前一个人出队后，后一个人才能接着出队，当然新来的成员也不能进行插队，要想入队只能从队尾开始排列。 ADT Queue 如果要使用Python来定义一个队列这种数据类型，则应当提供以下方法： 方法名 描述 ADTQueue() 一个类，用于构建一个空队列 enqueue() 将值加入到队尾，无返回值 dequeue() 将队首数据项移除，并返回被移除的数据项，队列会被修改 isEmpty() 返回队列是否为空 size() 返回队列中有多少个数据项 接下来我们基于Python内置的数据类型list，来实现一个队列。 如果将list的index0处作为队列尾端，list的index-1处作为队列首端，则enqueue()复杂度为O(n)，而dequeue()复杂度为O(1) 如果将list的index0处作为队列首端，list的index-1处作为队列尾端，则enqueue()复杂度为O(1)，而dequeue()复杂度为O(n) 以下是代码实现，采用第2种方案，将list的index0处作为队列首端： #!/usr/bin/env python3 # -*- coding:utf-8 -*- class ADTQueue: def __init__(self) -> None: self.queue = [] def enqueue(self, item): self.queue.append(item) def dequeue(self): return self.queue.pop(0) def isEmpty(self): return not bool(self.queue) def size(self): return len(self.queue) 约瑟夫环 传说犹太人反叛罗马人，落到困境，约瑟夫和40人决定殉难，坐成一圈儿，报数1～7，报到7的人由旁边杀死，结果约瑟夫给自己安排了个位置，最后活了下来...... 现在，使用队列模拟解决约瑟夫环问题，队首始终是要被杀死的人，因此从第一轮开始由队首的人开始出队，每数到7，在队首的人就不必再入队了，依次循环往复： from linear_structure import ADTQueue def Joseph(nameList, num): q = ADTQueue() # 所有人加入游戏 for name in nameList: q.enqueue(name) # 只要剩下的人数大于1，游戏就继续 while q.size() > 1: # 前6个都没事 for i in range(num - 1): q.enqueue(q.dequeue()) # 第7个死掉 q.dequeue() return q.dequeue() if __name__ == \"__main__\": nameList = (\"position:%s\" % i for i in range(1, 42)) survivor = Joseph(nameList, 7) print(survivor) 双端队列（Deque） 双端队列的特点 双端队列是一种数据项进出有序的线性结构，跟队列相似，其两端可以称作“首”“尾”端或者“左”“右”端，但双端队列中数据项既可以从队首加入，也可以从队尾加入，数据项也可以从两端移除。 某种意义上说，双端队列集成了栈和队列的能力： 双端队列并不具有内在的LIFO或者FIFO特性，如果用双端队列来模拟栈或队列需要由使用者自行维护操作的一致性。 ADT Deque 如果要使用Python来定义一个双端队列这种数据类型，则应当提供以下方法： 方法名 描述 ADTDeque() 一个类，用于构建一个空的双端队列 appendLeft() 将值加入到队首，无返回值 appendRight() 将值加入到队尾，无返回值 popLeft() 将队首数据项移除，并返回被移除的数据项，队列会被修改 popRight() 将队尾数据项移除，并返回被移除的数据项，队列会被修改 isEmpty() 返回队列是否为空 size() 返回队列中有多少个数据项 接下来我们基于Python内置的数据类型list，来实现一个双端队列。 如果将list的index0处作为双端队列尾端，list的index-1处作为双端队列首端，则appendLeft()和popLeft()时间复杂度为O(1)，而appendRight()和popRight()时间复杂度为O(n) 如果将list的index0处作为双端队列首端，list的index-1处作为双端队列尾端，则appendLeft()和popLeft()时间复杂度为O(n)，而appendRight()和popRight()时间复杂度为O(1) 以下是代码实现，采用第2种方案，将list的index0处作为队列首端： #!/usr/bin/env python3 # -*- coding:utf-8 -*- class ADTDeque: def __init__(self) -> None: self.dequeue = [] def appendLeft(self, item): self.dequeue.insert(0, item) def appendRight(self, item): self.dequeue.append(item) def popLeft(self): return self.dequeue.pop(0) def popRight(self): return self.dequeue.pop() def isEmpty(self): return not bool(self.dequeue) def size(self): return len(self.dequeue) 回文词判定 我们可以利用双端队列的特性，进行回文词判定，如radar、madam、toot。 再比如中文短句“上海自来水来自海上”“山东落花生花落东山”等。 实现思路也非常简单，先将需要判定的词从队尾加入deque再从两端同时移除字符判定是否相同，直到deque中剩下0个或1个字符，代码如下： from linear_structure import ADTDeque def termJudgment(string): dq = ADTDeque() for ch in string: dq.appendLeft(ch) while dq.size() > 1: first = dq.popLeft() last = dq.popRight() if first != last: return False return True if __name__ == \"__main__\": print(termJudgment(\"radar\")) print(termJudgment(\"radarr\")) Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-18 13:30:26 "},"Python/Python数算基础/数构之哈希篇.html":{"url":"Python/Python数算基础/数构之哈希篇.html","title":"数构之哈希篇","keywords":"","body":"Hash Table 散列表（hash table）也被称为哈希表，它是一种根据键（key）来存储值（value）的特殊线性结构。 常用于迅速的无序单点查找，其查找速度可达到常数级别的O(1)。 散列表数据存储的具体思路如下： 每个value在放入数组存储之前会先对key进行计算 根据key计算出一个重复率极低的指纹 根据这个指纹将value放入到数组的相应槽位中 同时查找的时候也将经历同样的步骤，以便能快速的通过key查出想要的value。 这一存储、查找的过程也被称为hash存储、hash查找。 如图所示： 我们注意观察，其实散列表中的每一个槽位不一定都会被占据，它是一种稀疏的数组结构，即有许多的空位，并不像list那种顺序存放的结构一样必须密不可分，这就导致了散列表无法通过index来进行value的操作。 散列表在Python中应用非常广泛，如dict底层就是散列表实现，而dict也是经历了上述步骤才将key-value进行存入的，后面会进行介绍。 名词释义 在学习Hash篇之前，介绍几个基本的相关名词： 散列表（hash table）：本身是一个普通的数组，初始状态全是空的 槽位（slot、bucket）：散列表中value的存储位置，用来保存被存入value的地方，每一个槽位都有唯一的编号 哈希函数（hash function）：如图所示，它会根据key计算应当将被存入的value放入那一个槽位 哈希值（hash value）：哈希函数的返回值，也就是对数据项存放位置的结算结果 还有2个比较专业性的词汇： 散列冲突：打个比方，k1经过hash函数的计算，将v1存在了1号槽位上，而k22也经过了hash函数的计算，发现v2也应该存在1号槽位上。 现在这种情况就发生了散列冲突，v2会顶替v1的位置进行存放，原本1号槽位的存放数据项会变为v2。 负载因子：说白了就说这个散列表存放了多少数据项，如11个槽位的一个散列表，存放了6个数据项，那么该散列表的负载因子就是6/11 哈希函数 如何通过key计算出value所需要插入的槽位这就是哈希函数所需要思考的问题。 求余哈希法 如果我们的key是一串电话号码，或者身份证号，如436-555-4601： 取出数字，并将它们分成2位数（43，65，55，46，01） 对它们进行相加，得到结果为210 假设散列表共有11个槽位，现在使用210对11求余数，结果为1 那么这个key所对应的value就应当插入散列表中的1号槽位 平方取中法 平方取中法如下，现在我们的key是96： 先计算它的平方值：96^2 平方值为9216 取出中间的数字：21 假设散列表共有11个槽位，现在使用21对11求余数，结果为10 那么这个key所对应的value就应当插入散列表中的10号槽位 字符串求值 上面举例的key都是int类型，如果是str类型该怎么做？ 我们可以遍历这个str类型的key，并且通过内置函数ord()来将它字符转换为int类型： >>> k = \"hello\" >>> i = 0 >>> for char in k: i += ord(char) >>> i 532 然后再将其对散列表长度求余，假设散列表共有11个槽位，现在使用532对11求余数，结果为4 那么这个key所对应的value就应当插入散列表中的4号槽位。 字符串问题 如果单纯的按照上面的方式去做，那么一个字符完全相同但字符位置不同的key计算的hash结果将和上面key的hash结果一致，如下所示： >>> k = \"ollhe\" >>> i = 0 >>> for char in k: i += ord(char) >>> i 532 如何解决这个问题呢？我们可以使用字符的位置作为权重进行解决： 代码设计如下： def getHash(string): idx = 0 hashValue = 0 while idx 完美散列函数 为了应对散列冲突现象的发生，我们必须严格定制hash函数根据key生产hash值的这一过程，尽量做到每一个不同key产生的hash值都是不重复的，能做到这一点的hash函数被称为完美散列函数。 如何设计完美散列函数？主要看该散列函数产生的散列值是否有以下特性： 压缩性：任意长度的数据，得到的“指纹”长度是固定的 易计算性：从原数据计算“指纹”很容易 抗修改性：对原数据的微小变动，都会引起“指纹”的大改变 抗冲突性：已知原数据和“指纹”，要找到相同指纹的数据（伪造）是非常困难的 介绍2种产生散列函数的方案，MD5和SHA系列函数。 MD5（MessageDigest）将任何长度的数据变换为固定长为128位（16字节 ）的“摘要” SHA（SecureHashAlgorithm）是另一组散列函数 SHA-0/SHA-1输出散列值160位（20字节） SHA-256/SHA-224分别输出256位、224位 SHA-512/SHA-384分别输出512位和384位 128位二进制已经是一个极为巨大的数字空间：据说是地球沙粒的数量，MD5能达到这种效果。 160位二进制相当于10的48次方，地球上水分子数量估计是47次方，SHA-0能达到这种效果。 256位二进制相当于10的77方， 已知宇宙所有基本粒子大约是72～87次方，SHA-256能达到这种效果。 所以一般来说，MD5函数作为散列函数是非常合适的，而在Python中使用它们也非常简单： #! /usr/local/bin/python3 # -*- coding:utf-8 -*- import hashlib m = hashlib.md5(\"salt\".encode(\"utf8\")) m.update(\"HELLO\".encode(\"utf8\")) print(m.hexdigest()) # ad24f795146b59b78c145fbd6b7f4d1f 像这种方案，通常还被应用到一致性校验中，如文件下载、网盘分享等。 只要改变任意一个字节，都会导致散列值发生巨大的变化。 散列冲突 如果两个不同的key被散列映射到同一个槽位，则需要一个系统化的方法在散列表中保存第2个value。 这个过程称为“解决冲突”，除了可以使用完美散列函数进行解决之外，以下也会介绍一些常见的解决办法。 开放定址法 所谓的开放定址法就是一旦发生了冲突，就去寻找下一个空的散列地址，只要散列表足够大，空的散列地址总能找到，并将记录存入。 从冲突的槽开始往后扫描，直到碰到一个空槽如果到散列表尾部还未找到，则从首部接着扫描： 这种寻找空槽的技术称为“开放定址openaddressing” 逐个向后寻找空槽的方法则是开放定址技术中的“线性探测linearprobing” 如下图所示： 它有一个缺点，就是会造成数据项扎堆形成聚集（clustering）的趋势，这会影响到其他数据项的插入。 比如上图中4号和5号槽位都被占据了，下次的v3本来是要插入到5号槽位的，但是5号槽位被v1占据了，它就只能再次向后查找： 针对这个缺点，可以做一个优化措施，即线性探测的范围从1变为3，每次向后查找3个槽位。 或者让线性探测的范围不固定，而是按照线性的趋势进行增长，如第一次跳3个，第二次跳5个，第三次跳7个等等，也是较好的解决方案。 如果采用跳跃式探测方案，则需要注意： 跳跃步数的取值不能被散列表大小整除，否则会产生周期性跳跃，从而造成很多空槽永远无法被探测到 这里提供一个技巧，把散列表的大小设为素数，如11个槽位大小的散列表就永远不会产生跳跃式探测方案的插槽浪费。 再哈希法 再哈希法又叫双哈希法，有多个不同的hash函数，当发生冲突时，使用第二个，第三个，等哈希函数计算槽位，直到出现空槽位后再插入value。 虽然不易发生聚集，但是增加了计算时间。 链地址法 每个哈希表节点都有一个next指针，多个哈希表节点可以用next指针构成一个单向链表，被分配到同一个索引上的多个节点可以用这个单向链表向后排列。 如下图所示： 公共溢出区 将哈希表分为基本表和溢出表两部分，凡是和基本表发生冲突的元素，一律填入溢出表。 当要根据key查找value时，先查找基本表，再查找溢出表。 ADT Map 思路解析 Python的dict是以一种key-value的键值对形式进行保存，也被称之为映射。 我们如何使用Python的list来实现一个类似的数据结构呢？参照dict，有2大因素： key必须具有唯一性，不可变 通过key可以唯一的确定一个value 在做ADT Map之前，思考一下它应该具有哪些方法： 方法 描述 ADTMap() 创建一个空的映射，返回空映射对象 set() 将key-val加入映射中，如果key已存在，将val替换旧关联值 get() 给定key，返回关联的数据值，如不存在，则返回None pop() 给定key，删除键值对，返回value，如果key不存在，则抛出KeyError，不进行缩容进制 len() 返回映射中key-val关联的数目 keys() 返回map的视图，类似于dict.keys() values() 返回map的视图，类似于dict.values() items() 返回map的视图，类似于dict.items() clear() 清空所有的key-val，触发缩容机制 in 通过key in map的语句形式，返回key是否存在于关联中，布尔值 [] 支持[]操作，与内置dict一致 for 支持for循环，与内置dict一致 我们都知道，Python3.6之后的dict是有序的，所以ADT Map也应该实现有序，减少遍历次数。 Ps：详情参见Python基础dict一章 另外还需要思考： 散列表应该是什么结构？ 采用怎样的哈希函数？ 如何解决可能出现的hash冲突？ 如何做到动态扩容？ 首先第一个问题，我们的散列表采用二维数组方式进行存储，具体结果如下，初始散列表长度为8，内容全为None，与Python内置的dict初始容量保持一致： [ [hash值, key, value], [hash值, key, value], [hash值, key, value], ... ] 第二个问题，这里采用字符串求值的哈希函数，也就是说key支持str类型 第三个问题，解决hash冲突采用开放定址+定性的线性探测 第四个问题，动态扩容也按照Python底层实现，即当容量超过三分之二时，进行扩容，扩容策略为已有散列表键值对个数 * 2，而在pop()时不进行缩容，但是在clear()会进行缩容，将散列表恢复初始状态。 map实现 下面是按照Python的dict底层实现的动态扩容map： #!/usr/bin/env python3 # -*- coding:utf-8 -*- class ADTMap: def __init__(self) -> None: # 初始容量为8 self.cap = 8 # 已有键值对个数为0 self.size = 0 # 初始map self.map = [[None] * 3] * self.cap # map顺序表 self.order = [None] * self.cap def set(self, key, value): # 求hash值 hashValue = self.__getHash(key) # 求插入或者更新槽位 slotIdx = self.__getSlot(hashValue) # 检查是否需要扩容, 当容量超过三分之二时，即进行扩容（resize）机制 if (self.size + 1 > round(self.cap * (2 / 3))): self.__resize() # 添加键值对 self.map[slotIdx] = [hashValue, key, value] self.size += 1 # 添加顺序表，如果是更新value，则不用添加 for i in range(len(self.order)): if self.order[i] is None or slotIdx == self.order[i]: self.order[i] = slotIdx break def get(self, key): # 求hash值 hashValue = self.__getHash(key) # 求key所在槽位 slotIdx = self.__getSlot(hashValue) return self.map[slotIdx][2] def pop(self, key): # 求hash值 hashValue = self.__getHash(key) # 求key所在槽位 slotIdx = self.__getSlot(hashValue) if self.map[slotIdx][2] == None: raise KeyError(\"%s\" % key) # 移除key self.size -= 1 retValue = self.map[slotIdx][2] self.map[slotIdx] = [None] * 3 for idx in range(len(self.order)): if self.order[idx] == slotIdx: # 删除 del self.order[idx] # 在最后添加空的，确保前面都是有序的不会出现None self.order.append([None] * 3) break return retValue def keys(self): for idx in self.order: if idx is not None: yield self.map[idx][1] else: break def values(self): for idx in self.order: if idx is not None: yield self.map[idx][2] else: break def items(self): for idx in self.order: if idx is not None: yield self.map[idx][1], self.map[idx][2] else: break def clear(self): self.cap = 8 self.size = 0 self.map = [[None] * 3] * self.cap self.order = [None] * self.cap def __setitem__(self, name, value): self.set(key=name, value=value) def __getitem__(self, name): return self.get(key=name) def __delitem__(self, name): # del map[\"k1\"] 无返回值 self.pop(key=name) def __contains__(self, item): keyList = self.keys() for key in keyList: if key == item: return True return False def __iter__(self): # 直接迭代map则返回keys列表 return self.keys() def __getHash(self, key): # int类型的keyhash值是其本身 if isinstance(key, int): return key # str类型需要使用ord()进行转换，并添加位权 if isinstance(key, str): idx = 0 v = 0 while idx str: retStr = \"\" for idx in self.order: if idx is not None: retStr += \" \" % (self.map[idx][1], self.map[idx][2]) else: break retStr = \"[\" + retStr + \"]\" return retStr Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-15 17:04:24 "},"Python/Python数算基础/数构之链表篇.html":{"url":"Python/Python数算基础/数构之链表篇.html","title":"数构之链表篇","keywords":"","body":"线性表(linear list) 顺序表(order list) Python中list和tuple的实现都是基于一种叫顺序表的东西。 顾名思义，所有的数据项都是有序的并且在一片连续的内存空间中存放，在使用顺序表进行存储时，需预先申请一整块足够大的存储空间，然后将数据按照次序逐一存储，数据项之间紧密贴合，不留一丝空隙： 当pop()掉任意一个非尾部数据项时，会导致pop()后的所有数据项前推，如下图所示： 同理，当insert()一个数据项时，如果insert()的数据项未在顺序表尾部，也会导致所有insert()后的数据项后移，如下图所示： 顺序表的优秀在于其查找性能，由于是顺序存储，故可以通过index直接获取到数据项本身，时间复杂度为O(1)，但缺点也很明显，诸如pop()、insert()、remove()等操作都会造成数据项前推或后移，时间复杂度是O(n)。 链表(linked list) 链表（Linked list），也是一种线性结构的数据类型，存储方式与顺序表截然相反，什么时候存储数据，什么时候才申请存储空间，数据之间的逻辑关系依靠每个数据项携带的指针维持： 链表的优秀在于其扩展性上，链表中数据项元素之间的逻辑关系靠的是节点之间的指针维持。 当需要在链表中某处插入或删除节点时，只需改变相应节点的指针指向即可，无需大量移动数据项，时间复杂度为O(1)。 而缺点在于其查找性能上，在链表中访问数据项，需要从链首依次遍历，直到找到指定节点，花费的时间复杂度为 O(n)。 下表中对顺序表和链表进行总结： 插入、删除、移动 查询 内存申请 链表 O(1) 需要从链首开始查找，所以是O(n) 按需申请 顺序表 由操作数据项的位置决定，最差情况是O(n) 顺序表中可直接使用index进行查询，所以是O(1) 一次申请 单向链表 认识单向链表 单向链表（Unidirectional Linked List）顾名思义，每个链表节点之间只有next指针，没有prev指针。 如下图所示： 如果需要让你来实现一个抽象的单向链表，你会如何设计呢？ 1）需要有一个LinkedListNode类，作为链表中的各个节点，主要包含以下属性和方法： self.nextNode：下一个节点指向，tail节点该属性总是为None self.dataItem：当前节点数据项 getData(self)：获取当前节点数据项 setData(self, item)：设置当前节点数据项 getNext(self)：获取当前节点的下一个节点 setNext(self, node)：设置当前节点的下一个节点 __str__(self) -> str：返回当前节点对象的显示 2）还需要有一个LinkedList类，来进行管理其中的各个节点，它主要包含以下属性和方法： self.head：当前链表中第一个节点 self.tail：当前链表中最后一个节点 self.size：当前链表的节点数量 add(self, item)：为当前链表增加一个新节点 search(self, item)：搜索并返回当前链表中某一个节点，若链表为空或被搜索节点不存在，使用该方法则抛出异常 remove(self, item)：删除并返回当前链表中某一个节点，若链表为空或被删除节点不存在，使用该方法则抛出异常 __str__(self) -> str：返回当前链表对象的显示 __len__(self) -> int：返回当前链表的长度 增加节点 增加节点的add()方法应当考虑将newNode插入到哪里性能最高？这个时候又分2种情况： 你的链表是无序链表 你的链表是有序链表 如果是无序链表，则可以直接插入在self.head节点前，或者也可以选择直接插入在self.tail节点后，它们的时间复杂度均为O(1)，这里需要注意2个点： 直接插入在self.head节点之前，列表总是以 直接插入在self.tail节点之后，列表总是以 -> 的方向新增节点 如下图所示： 如果是有序链表，则在插入前需要进行节点搜索并判断节点数据项的大小，由于此时的插入受到插入节点数据项大小与整体链表长度的因素影响，故插入性能是O(n)，如下图所示： 除了插入位置的考虑外，我们还需要考虑怎么添加新节点，单向链表比较简单，总体来说分为2步： 将newNode链接到currentSearchNextNode上 将currentSearchNode链接到newNode上 我们以单向有序链表举例，如下图所示： 这个顺序十分重要，如果将步骤互换，则会导致链表断开，currentSearchNextNode就找不到了： 当然也有解其他决方案，你可以用一个临时变量来存储currentSearchNextNode，但是并不推荐这样做。 搜索节点 如果是无序单向链表的查找，则需要从链首查到链尾，对比所有节点值与被查找的数据项是否一致，返回被查找的节点或者None，时间复杂度为O(n)。 如果是有序单向链表的查找，则只需要从链首查到大于被查找数据项的节点即可，也是返回被查找的节点或者None，时间复杂度为O(n)。 删除节点 节点的删除和节点查询的方法相差无几，唯一需要注意的是如果找到被删除的节点，则需要记录该节点的前一个节点，以便于删除currentSearchNode后让currentSearchPrevNode和currentSearchNextNode进行链接。 那么整体的顺序也是让currentSearchPrevNode指向currentSearchNextNode后，再将currentSearchNode的next指向清除。 如下图所示： 单向无序链表实现 下面是单向无序链表的实现代码： #!/usr/bin/env python3 # -*- coding:utf-8 -*- class UnidirectionalDisorderLinkedListNode: def __init__(self, dataItem) -> None: self.nextNode = None self.dataItem = dataItem def getData(self): return self.dataItem def setData(self, item): self.dataItem = item def getNext(self): return self.nextNode def setNext(self, node): self.nextNode = node def __str__(self) -> str: return str(\"\" % self.dataItem) class ADTUnidirectionalDisorderLinkedList: def __init__(self) -> None: self.head = None self.tail = None self.size = 0 def add(self, item): newNode = UnidirectionalDisorderLinkedListNode(dataItem=item) # 第一次插入 if self.head is None: self.head = newNode self.tail = newNode # 其他的插入 else: self.tail.setNext(newNode) self.tail = newNode self.size += 1 def search(self, item): if not self.size: raise ValueError(\"empty linked list not support search\") # 开始查找数据项 currentSearchNode = self.head # 遍历整个链表 while currentSearchNode is not None: if currentSearchNode.getData() == item: return currentSearchNode else: currentSearchNode = currentSearchNode.getNext() # 没找到，抛出异常 raise ValueError(\"%s does not exist\" % item) def remove(self, item): if not self.size: raise ValueError(\"empty linked list not support remove\") # 开始查找数据项 currentSearchNode = self.head currentSearchPrevNode = None # 遍历整个链表 while currentSearchNode is not None: # 符合条件 if currentSearchNode.getData() == item: # 被删除节点是链首 if currentSearchNode is self.head: self.head = currentSearchNode.getNext() # 被删除节点是链尾 elif currentSearchNode is self.tail: self.tail = currentSearchPrevNode self.tail.setNext(None) else: currentSearchPrevNode.setNext(currentSearchNode.getNext()) self.size -= 1 return currentSearchNode # 不符合条件，继续向下找 else: currentSearchPrevNode = currentSearchNode currentSearchNode = currentSearchNode.getNext() # 没找到，抛出异常 raise ValueError(\"%s does not exist\" % item) def __str__(self) -> str: if not self.size: return \"{}\" currentSearchNode = self.head retStr = \"{ \" while currentSearchNode.getNext() is not None: retStr += \"[%r] -> \" % currentSearchNode.getData() currentSearchNode = currentSearchNode.getNext() retStr += \"[%r] node-size:%r }\" % ( currentSearchNode.getData(), self.size) return retStr def __len__(self) -> int: return self.size 单向有序链表实现 下面是单向有序链表的实现代码： #!/usr/bin/env python3 # -*- coding:utf-8 -*- class UnidirectionalOrderLinkedListNode: def __init__(self, dataItem) -> None: self.nextNode = None self.dataItem = dataItem def getData(self): return self.dataItem def setData(self, item): self.dataItem = item def getNext(self): return self.nextNode def setNext(self, node): self.nextNode = node def __str__(self) -> str: return str(\"\" % self.dataItem) class ADTUnidirectionalOrderLinkedList: def __init__(self) -> None: self.head = None self.tail = None self.size = 0 def add(self, item): newNode = UnidirectionalOrderLinkedListNode(dataItem=item) # 第一次插入 if self.head is None: self.head = newNode self.tail = newNode # 其他的插入 else: currentSearchNode = self.head currentSearchPrevNode = None # 寻找插入位置 while currentSearchNode is not None and currentSearchNode.getData() str: if not self.size: return \"{}\" currentSearchNode = self.head retStr = \"{ \" while currentSearchNode.getNext() is not None: retStr += \"[%r] -> \" % currentSearchNode.getData() currentSearchNode = currentSearchNode.getNext() retStr += \"[%r] node-size:%r }\" % ( currentSearchNode.getData(), self.size) return retStr def __len__(self) -> int: return self.size 其他链表 双向链表 双向链表（double linked list）即每个节点除了拥有next指针外还有一个prev指针，如下图所示： 单向循环链表 单向循环链表是指tail节点会将next指针指向head节点，如下图所示： 双向循环链表 双向循环链表是指head节点的prev指针会指向tali节点，而tail节点的next指针会指向head节点，如下图所示： 跳跃表 普通的有序链表查找速度均为O(n)，总是按照一条线向后进行查找。 我们可以为链表中关键节点建立层级索引，如下图所示，这样就构成了跳跃表： 当要查询时，则从层级索引开始往下找，查找速度为O(logn)，但是空间复杂度会增加为O(n)，是典型的空间换时间的查询方式： Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-17 17:16:57 "},"Python/Python数算基础/算法之递归篇.html":{"url":"Python/Python数算基础/算法之递归篇.html","title":"算法之递归篇","keywords":"","body":"递归前言 递归（Recursion）相信各位都非常了解了，所以这里就不再详细阐述，具体可参照Python函数章节中的递归函数。 递归三大定律如下： 递归算法必须有一个基本结束条件 递归算法必须能改变问题规模 递归算法必须调用自身 分治策略 分治策略是指将一个大规模的问题分解成更小的相同问题，经过持续分解到最后问题规模小到可以用非常简单直接的方式来解决，或者将一个问题拆分成不同的各个部分，分而解决分而治之。 分治策略一般会经历三个步骤： 划分：此步骤涉及将问题分解为更小的子问题。子问题应该代表原始问题的一部分。这一步通常采用递归方法来划分问题，直到没有子问题可以进一步划分。在这个阶段，子问题本质上变成了原子，但仍然代表了实际问题的一部分 解决：这一步需要解决很多较小的子问题。通常，在此级别上，问题被视为自行“解决”。 合并：当较小的子问题得到解决时，这个阶段会开始递归地组合它们，直到它们合并成出原始问题的解决方案。 进制转换 前面的线性结构（栈）我们实现了一次10进制转换2、8、16进制，如果利用递归函数则整个实现过程又会变的非常简单。 如下所示： def baseConversion(n, base): digits = \"0123456789ABCDEF\" if n 汉诺塔 汉诺塔问题是由法国数学家爱德华·卢卡斯在 1883 年提出的。 他的灵感来自一个传说，有一个印度教寺庙，将谜题交给年轻的牧师，在开始的时候，牧师被给予三根杆和一堆 64 个金碟，每个盘比它下面一个小一点。 牧师的任务是将所有 64 个盘子从三个杆中一个转移到另一个。 有两个重要的约束： 一次只能移动一个盘子 不能在较小的盘子顶部上放置更大的盘子。 牧师日夜不停每秒钟移动一块盘子，传说，当他完成工作时，寺庙会变成灰尘，世界将消失。 游戏规则如下图所示： 如何用递归法求解呢？我们先对汉诺塔本身的游戏规则进行分析。 在上图中可以看到，s和m型号的圆盘，必须通过C号杆子再坐落到B号杆子上，我们可以将任意数量的非最大号的圆盘看为一整组，而最大号圆盘单独分为一组，总共将圆盘分为2组，并且在移动时按照组来进行划分： 算法如下，如此只要分三步即可： 把n-1个圆盘从柱子A经过C移动到B，但是省略掉到C的步骤，直接到B即可 把第n圆盘（最大的圆盘）从A移动到C 把n-1个圆盘从B经过A移动到C，但是省略掉到A的步骤，直接到C即可 代码如下，先按照3个圆盘求解： def hanoi(n, a, b, c): if n: # 从a经过c到b hanoi(n - 1, a, c, b) # 从a到c print(\"moving from %s to %s\" % (a, c)) # 从b经过a到c hanoi(n - 1, b, a, c) if __name__ == \"__main__\": hanoi(3, \"A\", \"B\", \"C\") # moving from A to C # moving from A to B # moving from C to B # moving from A to C # moving from B to A # moving from B to C # moving from A to C 贪心策略 贪心算法（又称贪婪算法）是指，在对问题求解时，总是做出在当前看来是最好的选择。 也就是说，不从整体最优上加以考虑，算法得到的是在某种意义上的局部最优解 。 贪心算法不是对所有问题都能得到整体最优解，关键是贪心策略的选择 。 找硬币问题 假设你为一家自动售货机厂家编程序，自动售货机要每次找给顾客最少数量硬币； 假设某次顾客投进$1(美元)纸币，买了ȼ37(美分)的东西，要找ȼ63，那么最少数量就是：2个quarter（ȼ25）、1个dime（ȼ10）和3个penny（ȼ1），一共6个。 人们会采用各种策略来解决这些问题，例如最直观的“贪心策略”，一般我们这么做： 从最大面值的硬币开始找起，用尽量少的硬币找尽量多的余额，直至最大的找不开 再到下一个最大面值的硬币，直至到penny（ȼ1）为止。 因为我们每次都试图解决问题的最大部分，对应到兑换硬币问题上就是每次以最多数量的最大面值硬币来迅速减少找零面值，这就是贪心策略，代码如下，你可以尝试将它改写成递归实现的： def findCoins(coinValueList, change): \"\"\" :param coinValueList: 传入硬币体系 :param change: 传入需要找回的硬币 :return: 返回的信息，找回多少 \"\"\" minCoins = \"\" for coin in coinValueList[::-1]: # 如果需要找的钱大于最大的面值，则算法开始 if change >= coin: # 最多找几枚最大面值的硬币? n = int(change // coin) # 最多能找多少钱? amount = n * coin # 还差多少钱没找？准备开始下一轮 change -= amount # 本次找了多少枚硬币，硬币是多少元 minCoins += \"%s枚%s元硬币\\n\" % (n, coin) return minCoins if __name__ == '__main__': print(findCoins([1, 5, 10, 25], 63)) # 2枚25元硬币 # 1枚10元硬币 # 3枚1元硬币 递归实现如下： def findCoins(coinValueList, change): minCoins = \"\" coin = coinValueList[-1] if change >= coin: n = int(change // coin) amount = n * coin change -= amount minCoins += \"%s枚%s元硬币\\n\" % (n, coin) if change == 0: return minCoins return findCoins(coinValueList[:-1], change=change) + minCoins if __name__ == '__main__': print(findCoins([1, 5, 10, 25], 63)) # 3枚1元硬币 # 1枚10元硬币 # 2枚25元硬币 动态规划 动态规划方法类似于分治法，将问题分解为更小的可能的子问题，但与分而治之不同的是，这些子问题不是独立解决的，相反，这些较小子问题的结果会被记住并用于相似或重叠的子问题。 在我们遇到问题的地方使用动态规划，可以将这些问题划分为类似的子问题，以便可以重复使用它们的结果。 大多数情况下，该算法往往用于优化。在解决现有子问题之前，动态算法将尝试检查先前解决的子问题的结果。将子问题的解决方案组合起来以获得最佳解决方案。 所以我们可以说： 问题应该能够分成更小的重叠子问题 最优解可以通过使用较小子问题的最优解来实现 动态算法使用记忆化 Elbonia奇怪的硬币体系 ”贪心策略”解决找零兑换问题，在美元或其他货币的硬币体系下表现尚好，但如果你的老板决定把自动售货机出口到Elbonia，事情就会有点复杂。 Elbonia是系列漫画Dilbert里杜撰的国家 这个古怪的国家除了上面3种面值之外，还有一种【ȼ21】的硬币！ 按照“贪心策略”，在Elbonia，ȼ63还是原来的6个硬币： ȼ63 =ȼ25*2+ȼ10*1+ȼ1*3 但实际上最优解是3个面值ȼ21的硬币！ ȼ63 =ȼ21*3 所以...贪心策略失效了。 常规解决 我们来找一种肯定能找到最优解的方法，放弃掉贪心策略的方案。 因为，贪心策略是否有效依赖于具体的硬币体系，如在Elbonia的货币体系中贪心策略就失效了。 首先是确定基本结束条件，兑换硬币这个问题最简单直接的情况就是，需要兑换的找零，其面值正好等于某种硬币，如找零25分，答案就是1个硬币！ 其次是减小问题的规模，我们要对每种硬币尝试1次，例如美元硬币体系： 找零减去1分(penny)后，求兑换硬币最少数量（递归调用自身） 找零减去5分(nikel)后，求兑换硬币最少数量 找零减去10分(dime)后，求兑换硬币最少数量 找零减去25分(quarter)后，求兑换硬币最少数量 上述4项中选择最小的一个 代码实现如下： #! /usr/local/bin/python3 # -*- coding:utf-8 -*- def recMC(coinValueList, change): minCoins = change if change in coinValueList: return 1 else: for i in [c for c in coinValueList if c 对63分的兑换硬币问题，需要进行67,716,925次递归调用。 这个实现方案我足足跑了40多秒，因为其中存在大量的子递归重复计算。 例如找零15分的，出现了3次！而它最终解决还要52次递归调用，下图中只是递归一角： 优化方案 对这个递归解法进行改进的关键就在于消除重复计算，我们可以用一个表将计算过的中间结果保存起来，在计算之前查表看看是否已经计算过，如果计算过就不运行函数，故也不会生成函数栈帧，极大减少了运行时长，这就是动态规划。 虽然这个做法会增大空间复杂度，但是会极大的减少时间复杂度，即让每个子问题只求解一次。 在递归调用之前，先查找表中是否已有部分找零的最优解如果有，直接返回最优解而不进行递归调用如果没有，才进行递归调用。 代码实现如下： #! /usr/local/bin/python3 # -*- coding:utf-8 -*- def recDC(coinValueList,change,knownResults): \"\"\" :param coinValueList: :param change: :param knownResults: 存表的结果（对应设计模式中，备忘录模式），因为我们要对63找零，所以这里设置为宽度为64的列表即可 \"\"\" minCoins = change # 递归结束基本条件 if change in coinValueList: # 记录最优解 knownResults[change] = 1 return 1 elif knownResults[change] > 0: # 查表成功，直接使用最优解 return knownResults[change] else: for i in [c for c in coinValueList if c 现在再次调用，则仅需要零点几秒就可以获得结果了。 Python内置库functools的@lrc_chace也实现了这种缓存功能，但该装饰器使用了字典存储缓存，所以被装饰函数的固定参数和关键字参数必须是可哈希的。 如下所示，不用自己写动态规划，直接调用该装饰器，只需要将货币体系传入由列表改为元组即可： #! /usr/local/bin/python3 # -*- coding:utf-8 -*- import functools @functools.lru_cache(maxsize=63) def recMC(coinValueList, change): minCoins = change if change in coinValueList: return 1 else: for i in [c for c in coinValueList if c 递归可视化 turtle module 这是一个Python内置的模块，随时可以进行调用，以LOGO语言的创意为基础模拟一只海龟在沙滩上爬行而留下的足迹。 以下是一些基本方法： 方法 描述 turtle.Turtle() 实例化对象 hideturtle() 使乌龟本身不可见，仅留下足迹 forward() 乌龟向前移动（头朝东） backward() 乌龟向后移动（头朝西） left() 乌龟向左边转向 right() 乌龟向右边转向 penup() 抬起画笔 pendown() 放下画笔 pensize() 笔的宽度 pencolor() 笔的颜色 turtle.done() 画完后不关闭 画一个三角形： import turtle import time def triangle(): t = turtle.Turtle() t.forward(200) t.right(60) t.backward(200) t.left(120) t.backward(200) if __name__ == '__main__': triangle() time.sleep(5) 自相似递归图形 分形Fractal，是1975年由Mandelbrot开创的新学科。 它的概念是：“一个粗糙或零碎的几何形状，可以分成数个部分，且每一部分都（至少近似地）是整体缩小后的形状”，即具有自相似的性质。 在大自然中的自相似递归图形有很多，比如雪花、树枝等等： 分形树 我们可以使用递归来画一颗二叉分形树，将树分解为3个部分：：树干、左边的小树、右边的小树。 分解后，正好符合递归的定义：对自身的调用。 代码如下： import turtle def tree(branch_len: int, t: turtle.Turtle) -> None: # 递归结束条件，树干不能太短 if branch_len > 5: # 画树干 t.forward(branch_len) # 右倾斜20度 t.right(20) # 递归，画右边小数，树干 - 15 tree(branch_len - 15, t) # 左倾斜40度，即回正后向左倾斜20度 t.left(40) # 递归，画左边小数，树干 - 15 tree(branch_len - 15, t) # 右倾斜20度，即回正 t.right(20) # 海龟退回原来的位置 t.backward(branch_len) if __name__ == '__main__': t = turtle.Turtle() # 转头，向正北 t.left(90) # 抬笔 t.penup() # 向上抬100个px t.backward(100) # 落笔 t.pendown() # 笔宽：2，颜色：绿色 t.pencolor(\"green\") t.pensize(2) # 开始画长度为75的树干 tree(75, t) # 使乌龟不可见 t.hideturtle() # 退出时不关闭 turtle.done() 效果演示： 谢尔宾斯三角形 谢尔宾斯三角形Sierpinski是一种分型构造。 创建一个三角形，然后每次都将这个三角形分成三份，无限制的挖下去最终这个三角形的面积会变为0，而周长变为无穷，是介于一维和二维之间的分数维（约1.585维）构造。 据自相似特性，谢尔宾斯基三角形是由3个尺寸减半的谢尔宾斯基三角形按照品字形拼叠而成。 由于我们无法真正做出谢尔宾斯基三角形（degree->∞），只能做degree有限的近似图形。 在degree有限的情况下，degree=n的三角形 ，是由3个degree=n-1的三角形按照品字形拼叠而成同时，这3个degree=n-1的三角形边长均为degree=n的三角形的一半（规模减小）。 当degree=0，则就是一个等边三角形，这是递归基本结束条件。 代码如下，感兴趣的可以仔细研究一下： import turtle def drawTriangle(points, color, myTurtle): myTurtle.fillcolor(color) myTurtle.up() myTurtle.goto(points[0][0], points[0][1]) myTurtle.down() myTurtle.begin_fill() myTurtle.goto(points[1][0], points[1][1]) myTurtle.goto(points[2][0], points[2][1]) myTurtle.goto(points[0][0], points[0][1]) myTurtle.end_fill() def getMid(p1, p2): return ((p1[0] + p2[0]) / 2, (p1[1] + p2[1]) / 2) def sierpinski(points, degree, myTurtle): colormap = ['blue', 'red', 'green', 'white', 'yellow', 'violet', 'orange'] drawTriangle(points, colormap[degree], myTurtle) if degree > 0: sierpinski([points[0], getMid(points[0], points[1]), getMid(points[0], points[2])], degree - 1, myTurtle) sierpinski([points[1], getMid(points[0], points[1]), getMid(points[1], points[2])], degree - 1, myTurtle) sierpinski([points[2], getMid(points[2], points[1]), getMid(points[0], points[2])], degree - 1, myTurtle) def main(): myTurtle = turtle.Turtle() myWin = turtle.Screen() myPoints = [[-100, -50], [0, 100], [100, -50]] sierpinski(myPoints, 3, myTurtle) myWin.exitonclick() if __name__ == '__main__': main() 效果演示： 绘制步骤： Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-18 15:20:58 "},"Python/Python数算基础/算法之搜索篇.html":{"url":"Python/Python数算基础/算法之搜索篇.html","title":"算法之搜索篇","keywords":"","body":"线性搜索 顺序查找也被称之为线性查找，因在Python中list的底层为顺序表存储，故我们可以使用index来循环遍历整个列表获得所需要查找的数据项。 它的时间复杂度为O(n)，如果刚好被搜索的数据项排列在最后一个，那么整个查找是非常耗费时间的： 如下所示，如果查找数据项50，将会查找11次： def seqLinerSearch(seq, findItem): idx = 0 count = 0 seqLenght = len(seq) while idx 有序的必要性 现在，让我们观察上面的代码是否有什么可以优化的地方。 我们的查找在数据项不存在的情况下总是会遍历完整个列表，导致这个问题的主要原因还是因为传入的列表是无序的。 如上述代码，我们查找数据项53，它总是一遍一遍的进行对比，直至对比完成整个列表发现都没有符合条件的数据项后才会返回，时间复杂度总是为O(n)，所以要针对这个情况进行简单的优化。 如果我们将列表排为有序的状态，当查找到71后，也就发现了没有必要往后查找，故至此直接返回即可。 优化策略： 列表要有序 如果正在遍历的数据项大于被查找的数据项，则代表此列表中没有该数据项 代码实现如下，虽然整体的时间复杂度还是O(n)，但是已经做了很大的优化了： def seqLinerSearch(seq, findItem): idx = 0 count = 0 seqLenght = len(seq) while idx 注意：排序本身就花费时间，复杂度为O(n log n) 二分搜索 通过上面的2个例子，可以得出一个结论： 对查找来说，保持数据项的有序是十分必要的 那么现在基于这个先决条件，介绍一种查找效率更高的算法，二分查找法。 二分查找的实现理念：每次只查找列表中间元素的值，判定这个中间元素与被查找元素的关系，通过关系将列表进行折半后，继续查找，时间复杂度是O(logn)，如下所示二分查找法与顺序查找的对比图： 实现二分查找，查找数据项50仅需要3次： #! /usr/local/bin/python3 # -*- coding:utf-8 -*- def binarySearch(seq, findItem): count = 0 l_idx = 0 r_idx = len(seq) - 1 while l_idx seq[m_idx]: l_idx = m_idx + 1 # 如果查找的元素小于当前列表中部索引的元素，则重新定义右侧索引 else: r_idx = m_idx - 1 else: return None, count if __name__ == '__main__': result, count = binarySearch([2, 8, 18, 22, 34, 37, 50, 71, 82, 91, 92], 50) print(result, count) # 50 3 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-18 16:17:44 "},"Python/Python数算基础/算法之排序篇.html":{"url":"Python/Python数算基础/算法之排序篇.html","title":"算法之排序篇","keywords":"","body":"排序简介 常见的十大排序算法如下所示，本章节会例举6种常见且易于掌握的排序算法： 算法名称 平均时间复杂度 最好情况 最坏情况 空间复杂度 排序方式 稳定性 冒泡排序 O(n²) O(n) O(n²) O(1) in-place 稳定 选择排序 O(n²) O(n²) O(n²) O(1) in-place 不稳定 插入排序 O(n²) O(n) O(n²) O(1) in-place 稳定 希尔排序 O(n log n) O(n log n) O(n log² n) O(1) in-plcae 不稳定 归并排序 O(n log n) O(n log n) O(n log n) O(n) out-place 稳定 快速排序 O(n log n) O(n log n) O(n²) O(log n) in-plcae 不稳定 堆排序 O(n log n) O(n log n) O(n log n) O(1) in-plcae 不稳定 计数排序 O(n + k) O(n + k) O(n + k) O(k) out-place 稳定 桶排序 O(n + k) O(n + k) O(n²) O(n + k) out-place 稳定 基数排序 O(n + k) O(n + k) O(n + k) O(n + k) out-place 稳定 关于排序算法的3大基础知识： 稳定性：示例，排序前红色3在蓝色3前面，如果排序完成后位置没有发生改变则该排序算法是稳定的： 稳定：1，2，3，3，5 不稳定：1，2，3，3，5 有序区和无序区：在排序算法中，会将一个序列分为2大区，如下所示： [1, 2, 3, | 28, 11, 43] ---------- ---------- 有序区 无序区 原地排序：原地排序是指在原序列中进行数据项排列，不用开辟额外内存空间 非原地排序则需要生成新的序列，来存储排列好的数据项，空间复杂度会增加 冒泡排序 冒泡排序（Bubble Sort）是一种简单的排序算法。 这种排序算法是基于比较的算法，每次比较2个相邻数据项并进行交换。 该算法不适合大型数据集，因为其平均和最坏情况复杂度为 Ο(n²)，其中n是项目数。 代码及注释如下： def bubbleSort(seq): # ❶ for i in range(len(seq) - 1): # ❷ tag = False # ❸ for j in range(len(seq) - (i + 1)): if seq[j] > seq[j + 1]: seq[j], seq[j + 1] = seq[j + 1], seq[j] tag = True if not tag: break if __name__ == \"__main__\": lst = [2, 1, 3, 4, 5, 6, 7, 8, 9] bubbleSort(lst) print(lst) ❶：我们认为最后1个数据项不用排序，故循环次数是 len(seq) - 1，每一次外层循环都会令有序区数据项 + 1 ❷：一个标志位，用于判定是否还需要继续进行排序 ❸：内层循环只会遍历无序区数据项，i 是外层循环次数， + 1代指seq最后1个数据项，即不用排序的数据项 如果不加该标志位，则会产生许多重复的且无用的排序，因此该标志位算是一种优化手段。 选择排序 选择排序（Selection Sort）会将序列分为2部分，有序区和无序区。 它的工作原理：首先在无序区中找到最小（大）数据项，存放到有序区的起始位置，然后，再从剩余无序区中继续寻找最小（大）数据项，然后放到有序区的末尾。 以此类推，直到所有数据项均排序完毕。 该算法不适合大型数据集，因为其平均和最坏情况复杂度为 Ο(n²)，其中n是项目数。 代码及注释如下： def selectionSort(seq): # ❶ for i in range(len(seq) - 1): # ❷ minIndex = i # ❸ for j in range(i + 1, len(seq)): # ❹ if seq[minIndex] > seq[j]: minIndex = j # ❺ if minIndex != i: seq[i], seq[minIndex] = seq[minIndex], seq[i] if __name__ == '__main__': lst = [4, 1, 0, 2, 3] selectionSort(lst) print(lst) ❶：我们认为最后1个数据项不用排序，故循环次数是 len(seq) - 1，每一次外层循环都会令有序区数据项 + 1 ❷：将当前被外层循环遍历的数据项当做最小值，并记录其索引位置 ❸：循环所有无序区数据项 ❹：判断当前被遍历的无序区数据项是否小于以设定的最小值数据项，如果是则更新 ❺：交换最小值数据项与外层循环被遍历数据项的位置 插入排序 插入排序（Inster Sort）类似于打扑克牌，先会构建出一个有序区，再遍历无序区数据项并将其插入到有序区中合适的位置。 该算法不适合大型数据集，因为其平均和最坏情况复杂度为 Ο(n²)，其中n是项目数。 代码及注释如下： def insertSort(seq): # ❶ for i in range(1, len(seq)): # ❷ currentItem = seq[i] # ❸ prevItemIndex = i - 1 # ❹ while prevItemIndex >= 0 and seq[prevItemIndex] > currentItem: # ❺ seq[prevItemIndex + 1] = seq[prevItemIndex] prevItemIndex -= 1 seq[prevItemIndex + 1] = currentItem if __name__ == \"__main__\": lst = [1, 4, 2, 3, 0] insertSort(lst) print(lst) ❶：外层循环从索引1处开始向后遍历，即我们认为有序区默认有1个数据项 ❷：拿到当前的数据项，即有序区最后一个数据项 ❸：拿到有序区前一个数据项的索引，这里就是插入位置，当无序区被遍历数据项小于有序区最后一个数据项，就插入到这里 ❹：条件1：如序列为[1, 2, 3 | 0, 9, 8, 10]，0如果想要插入1前面，索引就变成了-1，而-1位置是序列中最后位置，这样就会插入失败，故该条件确保不会出现负向索引 条件2：规定什么时候进行插入，当然是被遍历的无序区数据项小于有序区最后一个数据项时才进行插入 ❺：寻找插入位置 希尔排序 希尔排序（Shell Sort）是插入排序的一种，它是针对直接插入排序算法的改进。 希尔排序又称缩小增量排序，因 DL.Shell 于 1959 年提出而得名。 它通过比较相距一定间隔的数据项来进行，各趟比较所用的距离随着算法的进行而减小，直到只比较相邻数据项的最后一趟排序为止，是首次突破O(n²)的排序算法。 该算法对于中等规模的数据集非常有效，因为该算法的平均和最坏情况复杂度取决于间隙序列，最著名的是 Ο(n)，其中 n 是项目的数量。最坏情况下的空间复杂度是 O(n)。 首先，我们有一个长度为8的序列，我们需要对其 // 2，得到一个值是4，这个值叫做gap值。 现在，我们将整个序列分为4组，如下图所示，35和14为一组，中间的间隔是4，33和19是一组，中间的间隔也是4，依次类推： 然后我们对这4组中的元素进行插入排序，非常简单，下图是排序完成后的样子： 上次得到的gap值是4，我们再将它 // 2，得到新的gap值，为2。 老规矩，将整个序列分为2组，如下图所示： 然后，再将这2组中的元素进行插入排序，下图是排序完成之后的样子： 上次的gap值是2，我们再将它 // 2，得到结果是1，继续对这1组进行插入排序，如下图所示： 代码及注释如下： def shellSort(seq): # ❶ currentGap = len(seq) // 2 # ❷ while currentGap >= 1: # ❸ for startPosition in range(currentGap): gapInsertSort(seq, startPosition, currentGap) print(\"after increments of size %s, the sequence is %s\" % (currentGap, seq)) # ❹ currentGap //= 2 def gapInsertSort(seq, start, gap): # ❺ for i in range(start + gap, len(seq), gap): currentItem = seq[i] position = i while position >= gap and seq[position - gap] > currentItem: seq[position] = seq[position - gap] position = position - gap seq[position] = currentItem if __name__ == \"__main__\": lst = [35, 33, 42, 10, 14, 19, 27, 44] shellSort(lst) print(lst) ❶：获取gap值，后续会根据gap值进行分组 ❷：死循环，直至所有组都排序完毕 ❸：循环，开始进行插入排序 ❹：插入排序完毕后，重新进行分组，更新gap值 ❺：start + gap是当前需要插排的分组，len(seq)是整体序列长度， gap是跳过的步数，也就是不同的分组，至此开始每一轮的插入排序 归并排序 归并排序（Merge Sort）是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。 归并排序会不断的将序列 // 2，直至每个序列仅包含1个数据项，然后再将小序列排序并合并成大序列。 归并排序是一种基于分治技术的排序技术，最坏情况的时间复杂度为 Ο(n log n)，它是最受尊敬的算法之一。 首先，下面是一个未经历排序的长度为8的序列： 我们不断的将它拆分，直至每个序列中仅有1个数据项： 然后开始进行子序列合并，通过不断的对比每个子序列中的数据项，最终将它们合并成1个大的序列： 代码及注释如下： def mergeSort(seq): # ❶ if len(seq) > 1: mid = len(seq) // 2 leftSeq, rightSeq = seq[:mid], seq[mid:] mergeSort(leftSeq) mergeSort(rightSeq) # ❷ i = j = k = 0 while i ❶：不断的对序列进行拆分，直至每个序列中仅有1个数据项 ❷：开始进行排序、对比、合并，i 是左侧序列索引值，j是右侧序列索引值，k是整个大序列索引值 ❸：如果左序列被遍历数据项小于右序列被遍历数据项，则整体大序列中左序列数据项排列在前面 如：leftSeq = [0]， rightSeq = [1]， 则大的seq = [0 , 1] ❹：如果右序列被遍历数据项小于左序列被遍历数据项，则整体大序列中右序列数据项排列在前面 如：leftSeq = [1]， rightSeq = [0]， 则大的seq = [0 , 0] ❺：针对❹的情况，要将大seq的[0, 0]变为[0, 1]，因为❹的时候 i 没有 + 1，总之最后要保证：i = 1, j = 1, k = 2 ❻：针对❸的情况，因为❸的时候 j 没有 + 1，总之最后要保证：i = 1, j = 1, k = 2 快速排序 快速排序（Quick Sort）最大的特点就是快，使用分治法进行实现。 它的算法步骤是在一个序列中选定任意一个值，作为基准（pivot），然后使用2个指针，从序列的左侧与右侧一起进行数据项检测，每检测1步2个指针距离更进一步。 左侧指针用于将比基准值小的数据项排在左侧 右侧指针用于将比基准值大的数据项排在右侧 当2个指针重合时代表一趟排序完成，如此排列一轮整个序列就分为了2组，左侧比基准小（左侧各个序列数据项之间也大概率无序），右侧比基准大（右侧各个序列数据项之间也大概率无序）。 再次重复以上的步骤，对左侧或者右侧的列表重新定义基准值，再次进行挑选，直至最后划分为无数个长度为1的小序列时，排序完成。 该算法对于大型数据集非常有效，因为其平均复杂度和最坏情况复杂度分别为O(n log n) 和 O(n² )。 可能动图演示太快了，我们使用图解的形式： 第一趟的基准值是6（随机的）： 接下来继续第2倘，重新定义基准值为3（随机的），重复上面的步骤。 代码及注释如下： def quickSort(seq): def innerQuickSort(seq, left, right): if left left and seq[right] >= pivot: right -= 1 seq[left] = seq[right] # ❸ while left ❶：定义基准值，pivot ❷：右侧指针与左侧指针没有重合，且右侧指针数据项大于基准值则右侧指针左移一位 ❸：左侧指针与右侧指针没有重合，且左侧指针数据项小于基准值则左侧指针右移一位 ❹：重新定义基准值，本倘遍历完成 此时还可能会出现一个最坏情况： 由于pivot我们总是选择在了首位，如果出现传入一个已经有序（升序）的列表，就会发生最坏情况。 反之，如果pivot总是选择在末位，如果出现传入一个已经有序（降序）的列表，也会发生最坏的情况。 最坏情况下，时间复杂度将退化O(n²)，加上递归的开销可能比冒泡排序还要慢一点，解决方案是将pivot选择为一个随机位置，如中间。 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-20 19:37:28 "},"Python/Python数算基础/数构之树相关.html":{"url":"Python/Python数算基础/数构之树相关.html","title":"数构之树相关","keywords":"","body":"树的知识 什么是树 树是一种基本的非线性数据结构，在操作系统、图形学、数据库系统、计算机网络等领域被广泛使用。 跟自然界中的树一样，数据结构树也分为：根、枝、叶三个部分，一般数据结构的图示会把根放在上方，叶放在下方，就像一颗倒置的树，如下示例： 相关术语 节点(node) 节点是组成树的基本部分，每个节点具有不同的名称或“键值”属性。 除此之外，节点还可以保存额外数据项，数据项根据不同的应用而变化。 边(edge) 边是组成树的另一个基本部分，每条边恰好连接两个节点，表示节点之间具有关联。 除此之外，边还具有出入方向： 每个节点（除根节点）恰好有一条来自另一节点的入边。 每个节点可以有多条连到其它节点的出边。 根(root) 根是树中唯一一个没有入边的节点，即最顶端的节点。 路径(path) 路径是由边依次连接在一起的节点组成的有序列表，如：HTML->BODY->UL->LI就是一条路径。 子节点(children) 入边均来自于同一个节点的若干节点，称为这个节点的子节点。 父节点(parent) 一个节点是其所有出边所连接节点的父节点。 兄弟节点(sibling) 具有同一个父节点的节点之间称为兄弟节点. 子树(subtree) 子树是一个节点和其所有子孙节点，以及相关边的集合。 一个树中有多个子树，每个子树是独立的一颗树。 叶子节点(leaf) 没有子节点的节点称为叶节点。 层级(level) 根节点开始到达一个节点的路径，所包含的边的数量，称为这个节点的层级。 Root从0开始计数，也可以从1开始计数： 高度(height) 树中所有节点的最大层级称为树的高度。 如下图树的高度为2： 度(degree) 一个枝的度代表它有几条出边，而一颗树的度则取决于树中节点的最大度。 如，一颗树中最大的度为2，这可树可被称为二叉树，除此之外还有三叉、四叉树等结构。 如下图，这是一颗三叉树： 认识二叉树 普通二叉树 普通的二叉树没什么要求，树的最大度为2即可。 完全二叉树 在完全二叉树中，枝节点必须全部是满的，叶子节点可以不满。 但是新的节点添加时必须从左至右依次添加，不能先添加右边后添加左边。 平衡二叉树 树的左右子树高度差不超过1的树被称为平衡二叉树，空树也是平衡二叉树的一种。 满二叉树 满二叉树的意思就是无论是枝节点还是叶子节点，必须全部都是满的。 二叉树表示 列表表示法 在Python中，我们可以使用多维的列表来表示一颗不确定度的多叉树。 这样的做法有一个好处，每一个列表都是一颗子树，索引值1是左子树，索引值2是右子树。 同时，如果要增加某个节点的度，则向其添加一个空列表即可。 如上述这幅图的二叉树，则可以向下面这样进行表示： 第1个元素为根节点的值 第2个元素是左子树（所以也是一个列表） 第3个元素是右子树（所以也是一个列表） [root, [left], [right]] ----------------------- 0 1 2 如下所示： myTree = \\ [ \"a\", [\"b\", [\"d\", [], []], [\"e\", [], []] ], [\"c\", [\"f\"] ] ] 拿到第二层的叶子节点f： print(myTree[2][1]) 节点表示法 使用节点表示法，能够更加清晰的管理树，这比列表表示法通常更加省力。 如下图所示： 以下是代码实现上图中二叉树的表现： class BinaryTree: def __init__(self, root): self.key = root self.leftChild = None self.rightChild = None self.height = 0 def insertLeft(self, newNode): tree = BinaryTree(newNode) if not self.leftChild: self.leftChild = tree else: # 如果插入位置已有节点，则整体向下挪 # 新的子节点与旧的子节点链接，旧的父节点与新的子节点链接 tree.leftChild = self.leftChild self.leftChild = tree self.height += 1 def insertRight(self, newNode): tree = BinaryTree(newNode) if not self.rightChild: self.rightChild = tree else: tree.rightChild = self.rightChild self.rightChild = tree self.height += 1 def getRightChild(self): return self.rightChild def getLeftChild(self): return self.leftChild def setRootVal(self, obj): self.key = obj def getRootVal(self): return self.key if __name__ == '__main__': binaryTree = BinaryTree(\"a\") binaryTree.insertLeft(\"b\") binaryTree.insertRight(\"c\") binaryTree.leftChild.insertLeft(\"d\") binaryTree.leftChild.insertRight(\"e\") binaryTree.rightChild.insertLeft(\"f\") 二叉树遍历 将一颗二叉树依次排开，如下所示： 根节点在中间 左节点在左边 右节点在右边 那么就会有不同的4种遍历规则。 前序遍历（preorder） 中序遍历（inorder） 后序遍历（postorder） 层级遍历（levelorder） 我们可以在BinaryTree中新增几个实例方法，用来书写不同的遍历代码： class BinaryTree: ... def preOrder(self): pass def inOrder(self): pass def postOrder(self): pass def levelOrder(self): pass 前序遍历(pre order) 前序遍历规则如下： 首先访问根节点 前序访问左子树 前序访问右子树 一句话总结：中左右 遍历顺序： 代码实现： def preOrder(self): def inner(tree): if tree: print(tree.getRootVal()) inner(tree.getLeftChild()) inner(tree.getRightChild()) inner(self) 中序遍历(in order) 中序遍历规则如下： 中序访问左子树 然后访问根节点 中序访问右子树 一句话总结：左中右 遍历顺序： 代码实现： def inOrder(self): def inner(tree): if tree: inner(tree.getLeftChild()) print(tree.getRootVal()) inner(tree.getRightChild()) inner(self) 后序遍历(post order) 后序遍历规则如下： 后序访问左子树 后序访问右子树 最后访问根节点 一句话总结：左右中 遍历顺序： 代码实现： def postOrder(self): def inner(tree): if tree: inner(tree.getLeftChild()) inner(tree.getRightChild()) print(tree.getRootVal()) inner(self) 层级遍历(level order) 层级遍历没什么好说的，按层访问： 第0层、根 第1层、左、右 …第n层、左、右 遍历顺序： 代码实现，需要借助一个双端队列或者列表： def levelOrder(self): def inner(tree): treeLst = [] treeLst.append(tree) while len(treeLst) > 0: node = treeLst.pop(0) print(node.getRootVal()) if node.leftChild: treeLst.append(node.getLeftChild()) if node.rightChild: treeLst.append(node.getRightChild()) inner(self) 根据遍历画出树 如果给出你2个遍历结果，并且指明这棵树是二叉树，如何画出这棵树的结构？ 前序遍历顺序是 A B C D E F G 中序遍历顺序是 C B D A F E G 首先，前序遍历是中左右，中序遍历是左中右，按照下面的结构开始进行结构划分： 前序： [A] [B C D] [E F G] 中序： [C B D] [A] [F E G] 划分完成之后就可以出图了： 二叉堆 什么是二叉堆 二叉堆是二叉树的一种特殊结构，二叉堆必须是完全二叉树或者近似完全二叉树，可分为大根堆和小根堆。 小根堆（小顶堆）：任意一个节点都比其孩子节点小 大根堆（大顶堆）：任意一个节点都比其孩子节点大 图示如下： 二叉堆的表示 使用列表来表示二叉堆的时候，不需要利用多维列表，单纯的一维列表足以。 因为二叉堆必须是完全二叉树或者近似完全二叉树，所以整个树是平衡的，可以用列表来进行表示。 [1, 2, 3, 4, 5, 6, 7] 如果要查找任意节点的左子节点与右子节点，可以使用 2p 与 2p+1 来查找，如果想查找其父节点，可以使用 n // 2 的方式。 如上述列表表示了一个小根堆，我们要寻找3的左子节点与右子节点及父节点，流程如下： Node 3 Position: 3 # 不要按照索引计算，正确计算是索引值+1 Left Child Node Position: 3 * 2 = 6 Right Child Node Position: 3 * 2 + 1 = 7 Parent Node Position: 3 // 2 = 1 堆排序(Heap Sort) 由于堆只有大根堆和小根堆，为了满足其中的特性，我们必须将一些节点进行值的比对然后上浮或者下沉。 如下图所示，展示了一个大根堆的排序过程： 时间复杂度为O(n log n)，空间复杂度为O(1)。 实现思路： 构造初始堆，将给定无序序列构造成一个大根堆（排序时一般大根堆为升序，小根堆为降序） 将堆顶元素与末尾元素进行交换，使末尾元素最大。然后继续调整堆，再将堆顶元素与末尾元素交换，得到第二大元素； 重新调整结构，使其满足堆定义，然后继续交换堆顶元素与当前末尾元素； 如此反复进行交换、重建、交换，直到整个序列有序。 代码实现如下，这是一个大根堆： def build(seq, root, end): while True: # 左子节点的位置 child = 2 * root + 1 # 若左子节点超过了最后一个节点，则终止循环 if child > end: break # 若右子节点在最后一个节点之前，并且右子节点比左子节点大，则我们的孩子指针移到右子节点上 if (child + 1 seq[child]): child += 1 # 若最大的孩子节点大于根节点，则交换两者顺序，并且将根节点指针，移到这个孩子节点上 if seq[child] > seq[root]: seq[child], seq[root] = seq[root], seq[child] root = child else: break def heapSort(seq): n = len(seq) # 确认最深最后的那个根节点的位置 first_root = n // 2 - 1 # 由后向前遍历所有的根节点，建堆并进行调整 for root in range(first_root, -1, -1): build(seq, root, n - 1) # 调整完成后，将堆顶的根节点与堆内最后一个元素调换位置，此时为数组中最大的元素，然后重新调整堆，将最大的元素冒到堆顶。依次重复上述操作 for end in range(n - 1, 0, -1): seq[0], seq[end] = seq[end], seq[0] build(seq, 0, end - 1) if __name__ == '__main__': lst = [7, 3, 2, 4, 1, 5] heapSort(lst) print(lst) ADT BinHeap 如果要使用Python来进行二叉堆实现，同时应当提供以下方法。 这样做的好处是所有的入堆出堆操作时间复杂度均为O(n log n)，我们可以用二叉堆来模拟实现类似优先级队列的数据结构。 方法名 描述 BinaryHeap() 一个类，用于构建一个空的二叉堆对象 insert() 将新key加入到堆中 findMin() 返回堆中的最小项，最小项仍保留在堆中，堆本身不会改变 delMin() 返回堆中的最小项，同时从堆中删除，堆本身会改变 isEmpty() 返回堆是否为空 size() 返回堆中key的个数 buildHeap() 从一个key列表创建新堆 现在准备实现一个小根堆，用一个列表来保存堆数据，其中列首下标为0的项无用，但是节点的左右子节点查找是根据 2p 与 2p+1 来计算的，因此我们可以用这个0来做一个占位，使索引与p相同，而不是从0开始计数，所以选择保留它： class BinHeap: def __init__(self): self.heapList = [0] self.currentSize = 0 insert()方法的实现，一定要满足完全二叉树的性质，因此我们可以将新的key添加到列表末尾，同时使用堆排序来将该key上浮或者到合适的位置，实现有序的特性。 def percUp(self, i): # 判断父节点是否存在，由于现在新添加的元素 # 索引+1了，直接进行整除即可 while i // 2 > 0: # 如果新元素小于父节点，则上浮，交换位置 if self.heapList[i] delMin()方法的实现要移走整个堆中最小的key，由于我们实现的是小根堆，所以最小的元素都在堆顶。 如果直接简单粗暴的移走堆顶root，用那个元素来顶替好呢？ 实际上，我们可以采用将堆底，即列表最后一个元素放到堆顶再向下沉的策略来进行该方法的构建。 def percDown(self, i): # 如果没有左子节点，则代表整个列表就1个元素，不是一个堆 # 就不向下执行 while (i * 2) self.heapList[mc]: # 临时保留root节点的元素信息 temp = self.heapList[i] self.heapList[i] = self.heapList[mc] self.heapList[mc] = temp i = mc def minChild(self, i): # 先判断右子节点，是否大于当前的堆顶元素 if i * 2 + 1 > self.currentSize: return i * 2 # 不大于 else: # 判断左子节点，是否小于右子节点 if self.heapList[i * 2] 其他方法的实现： def buildHeap(self, li): # 一颗树的总长度+1整除2，会得到该树的root节点+枝节点 # 忽略掉了叶子节点 i = len(li) // 2 # 重新定义长度 self.currentSize = len(li) # 重新赋值 self.heapList = [0] + li # 从最后一个元素开始，进行排序 while i > 0: self.percDown(i) i -= 1 def findMin(self): return self.heapList[1] def isEmpty(self): return not self.heapList def size(self): return self.__len__() def __len__(self): return len(self.heapList) - 1 def __str__(self): return str(self.heapList[1:]) def __contains__(self, item): return item in self.heapList 完整代码： class BinHeap: def __init__(self): self.heapList = [0] self.currentSize = 0 def percUp(self, i): # 判断父节点是否存在，由于现在新添加的元素 # 索引+1了，直接进行整除即可 while i // 2 > 0: # 如果新元素小于父节点，则上浮，交换位置 if self.heapList[i] self.heapList[mc]: # 临时保留root节点的元素信息 temp = self.heapList[i] self.heapList[i] = self.heapList[mc] self.heapList[mc] = temp i = mc def minChild(self, i): # 先判断右子节点，是否大于当前的堆顶元素 if i * 2 + 1 > self.currentSize: return i * 2 # 不大于 else: # 判断左子节点，是否小于右子节点 if self.heapList[i * 2] 0: self.percDown(i) i -= 1 def findMin(self): return self.heapList[1] def isEmpty(self): return not self.heapList def size(self): return self.__len__() def __len__(self): return len(self.heapList) - 1 def __str__(self): return str(self.heapList[1:]) def __contains__(self, item): return item in self.heapList if __name__ == '__main__': bHeap = BinHeap() for i in range(5, 12): bHeap.insert(i) bHeap.insert(4) print(bHeap) bHeap.delMin() print(bHeap) print(bHeap.isEmpty()) print(bHeap.size()) 二叉查找树 在前面的章节中，我们已经介绍了基于线性数据结构+二分查找法的查找方式，以及使用HashMap做定点查找的方式。 现在，将介绍一种基于二叉树的查找方式，名为二叉查找树或二叉搜索树Binary Search Tree。 BinarySearchTree有一个性质，即比父节点小的key都出现在左子树，比父节点大的key都出现在右子树。 在插入时，也一样会经过上浮下沉的步骤，如果按照70,31,93,94,14,23,73的顺序插入： 首先插入的70成为树根 31比70小，放到左子节点 93比70大，放到右子节点 94比93大，放到右子节点 14比31小，放到左子节点 23比14大，放到右子节点 73比93小，放到左子节点 若插入顺序如果不同，则生成的BinarySearchTree也会不同。 Python实现BinarySearch树 如果要使用Python来进行二叉查找树的实现，同时应当提供以下方法： 方法名 描述 BinarySearchTree() 一个类，用于构建一个空的二叉查找树对象 put() 将key-val关联对加入至BinarySearchTree中，如果key已存在，则将val进行更新 get() 指定key，返回val，如val不存在，则返回None del 通过 del BinarySearchTree[key]的语句形式删除一组键值对 len() 返回BinarySearchTree中键值对的数量 in 支持成员运算符的应用 为了实现二叉查找树，我们可以用2个类，BinarySearchTree以及TreeNode。 一个用来构建树的结构，一个用来生成树的节点。 BinarySearchTree类的root成员引用根节点的TreeNode，以下是基本方法： class BinarySearchTree: def __init__(self): self.root = None self.size = 0 def length(self): return self.size def __len__(self): return self.size 下面是节点类的基本方法： class TreeNode: def __init__(self, key, val, left=None, right=None, parent=None): self.key = key self.payload = val self.leftChild = left self.rightChild = right self.parent = parent def getLeftChild(self): \"\"\"返回左子节点\"\"\" return self.leftChild def getRightChild(self): \"\"\"返回右子节点\"\"\" return self.rightChild def isLeftChild(self): \"\"\"判断当前节点是否是左节点\"\"\" return self.parent and \\ self.parent.leftChild == self def isRightChild(self): \"\"\"判断当前节点是否是右节点\"\"\" return self.parent and \\ self.parent.rightChild == self def isRoot(self): \"\"\"判断当前节点是否是根节点，根节点无父节点\"\"\" return not self.parent def isLeaf(self): \"\"\"判断当前节点是否是叶子节点\"\"\" return not (self.rightChild or self.leftChild) def hasAnyChildren(self): \"\"\"判断当前节点是否含有任意的子节点\"\"\" return self.rightChild or self.leftChild def hasBothChildren(self): \"\"\"判断当前节点是否含有左子节点和右子节点\"\"\" return self.rightChild and self.leftChild def replaceNodeDate(self, key, value, lc, rc): \"\"\"替换当前节点\"\"\" self.key = key self.payload = value self.leftChild = lc self.rightChild = rc if self.getLeftChild(): self.leftChild.parent = self if self.getRightChild(): self.rightChild.parent = self 当所有的基本方法都齐全后，开始构建put()方法。 put() put()方法是BinarySearchTree的一个实例方法，该方法将检测树是否已有根，若没有根那么put()方法将创建一个新的TreeNode实例并将其作为BinarySearchTree的根，如果根节点已就位，则put()方法将调用私有的递归辅助函数_put()方法，它将根据以下算法进行树的搜索： 从树的根开始，搜索二叉树，将新键与当前节点中的键进行比较。如果新键小于当前节点，则搜索左子树。如果新键大于当前节点，则搜索右子树。 当没有左（或右）孩子要搜索时，我们在树中找到应该建立新节点的位置。 以下是代码实现： def put(self, key, val): # 如果存在root节点，则下沉开始寻找插入位置 if self.root: self._put(key, val, self.root) else: self.root = TreeNode(key, val) self.size += 1 def _put(self, key, val, currentNode): # 如果新key小于root，则准备在左子树中寻找插入位置 if key 顺带将索引赋值也做上： def __setitem__(self, key, value): self.put(key,value) get() put()方法构建完毕后，让我们接着构建get()方法。 gut()方法是BinarySearchTree的一个实例方法，它与put()方法类似，同样也有一个私有的递归辅助函数_get()方法来进行递归检测，大体流程如下： 首先判断该树有没有根，若没有根则直接返回None 如果有根，则判断要查找的key是否等于root，如果相等直接返回，如果小于则往左子树递归查找，反之则往右子树递归查找，若都找不到则返回None 以下是代码实现： def get(self, key): if self.root: res = self._get(key, self.root) if res: return res.payload else: return None else: return None def _get(self, key, currentNode): # 查找到叶子节点都没找到，返回None if not currentNode: return None # 判断是否等于当前Node的key elif currentNode.key == key: return currentNode # 如果小于，递归遍历左子树 elif key 顺带着，由于实现了get()方法，我们也可以将BinarySearchTree的掌管成员运算符in的\\_contains__()一起实现，代码如下： def __contains__(self, key): if self._get(key, self.root): return True else: return False __iter__() 当get()方法构建完毕后，下一步要构建迭代器了，只需要实现__iter__()方法即可。 将BinarySearchTree中的__iter__()调用至TreeNode中的__iter__()方法即可： # BinarySearchTree def __iter__(self): return self.root.__iter__() # TreeNode def __iter__(self): \"\"\"采用中序遍历\"\"\" if self: if self.getLeftChild(): for ele in self.leftChild: yield ele yield self.key if self.getRightChild(): for ele in self.rightChild: yield ele delete() 现在简单的方法都构建完毕了，最难的就属delete()方法，它包含2层，1层是找节点、2层是删节点。 为了使程序更加解耦，我们用delete()作为2个方法的代理，负责调度_get()方法来找节点与remove()方法来删节点，当然remove()方法暂时还没有实现。 在delete()方法中，大体思路如下： 如果这个树的长度大于1，则说明有节点，调用_get()方法开始从root节点向后查找，找得到就将其设置为None，找不得则抛出异常 如果这个树的长度为1，则说明只有一个root节点，此时判定root节点是否是我们需要找的节点，找得到就将root节点设为None，找不得就删除 代码实现如下： def delete(self,key): if self.size > 1: nodeToRemove = self._get(key,self.root) if nodeToRemove: self.remove(nodeToRemove) self.size -= 1 else: raise KeyError(\"Error, key not in tree\") elif self.size == 1 and self.root.key == key: self.root = None self.size -= 1 else: raise KeyError(\"Error, key not in tree\") def __delitem__(self, key): self.delete(key) 如果找到了节点，就需要执行remove()方法对其进行删除，但是remove()方法还未实现，我们需要提前对其做一些规划。为了保持整颗二叉查找树的性质，删节点时要对以下3种情形做出分别不同的处理： 将要被删除的节点是一个叶子节点（没有任何子节点） 将要被删除的节点有1个子节点 将要被删除的节点有2个子节点 没有子节点的第1种情况最好办，直接删除即可： def remove(self, currentNode): # 第一种情况：如果被删除节点是叶子节点 if currentNode.isLeaf(): # 判断是左叶子还是右叶子，将其置为None if currentNode == currentNode.parent.leftChild: currentNode.parent.leftChild = None else: currentNode.parent.rightChild = None 第2种情况稍微复杂，被删节点有1个子节点，我们需要将这个唯一的子节点上移，替换掉被删节点的位置。 但是在替换操作的时候，又要区分几种情况，如下所示： 被删节点的子节点是左？还是右子节点？ 被删节点本身是其父节点的左？还是右子节点？ 被删节点本身就是根节点？ 解决策略如下： 如果当前被删节点是左子节点，则我们只需要更新左子节点的父引用以指向当前节点的父节点，然后更新父节点的左子节点引用以指向当前节点的左子节点 如果当前被删节点是右子节点，则我们只需要更新左子节点的父引用以指向当前节点的父节点，然后更新父节点的右子节点引用以指向当前节点的左子节点 如果当前被删节点没有父级，则它是根。在这种情况下，我们将通过在根上调用replaceNodeData() 方法来替换 key，payload，leftChild和rightChild的数据。 说了这么多，还不如看代码实际，先写个else，来处理第二种情况，因为我们无法保证该节点只有1个子节点，所以将这个情况放在第三种情形下面即可，（将要被删除的节点有2个子节点）： def remove(self, currentNode): # 第一种情况：如果被删除节点是叶子节点 if currentNode.isLeaf(): # 判断是左叶子还是右叶子，将其置为None if currentNode == currentNode.parent.leftChild: currentNode.parent.leftChild = None else: currentNode.parent.rightChild = None # 第三种情况：如果被删除节点有2个子节点 elif currentNode.hasBothChildren(): pass # 第二种情况：如果被删除的节点有1个子节点 else: # 如果被删除的节点的1个子节点是左子节点 if currentNode.getLeftChild(): # 如果被删除的节点本身是左节点 if currentNode.isLeftChild(): # 爸爸死了，让左儿子的爷爷做左儿子的监护人 currentNode.leftChild.parent = currentNode.parent # 爷爷的左儿子死了，爷爷让左孙子顶替左儿子的位置 currentNode.parent.leftChild = currentNode.leftChild # 如果被删除的节点本身是右节点 elif currentNode.isRightChild(): # 爸爸死了，让左儿子的爷爷做左儿子的监护人 currentNode.leftChild.parent = currentNode.parent # 爷爷的右儿子死了，爷爷让左孙子顶替右儿子的位置 currentNode.parent.rightChild = currentNode.leftChild # 如果被删除的节点本身是根节点 else: # 爸爸死了儿子顶上 currentNode.replaceNodeData(currentNode.leftChild.key, currentNode.leftChild.payload, currentNode.leftChild.leftChild, currentNode.leftChild.rightChild) # 如果被删除的节点的1个子节点是右子节点 else: # 如果被删除的节点本身是左节点 if currentNode.isLeftChild(): # 爸爸死了，让右儿子的爷爷做右儿子的监护人 currentNode.rightChild.parent = currentNode.parent # 爷爷的左儿子死了，爷爷让右孙子顶替左儿子的位置 currentNode.parent.leftChild = currentNode.rightChild # 如果被删除的节点本身是右节点 elif currentNode.isRightChild(): # 爸爸死了，让右儿子的爷爷做右儿子的监护人 currentNode.rightChild.parent = currentNode.parent # 爷爷的右儿子死了，爷爷让右孙子顶替右儿子的位置 currentNode.parent.rightChild = currentNode.rightChild # 如果被删除的节点本身是根节点 else: # 爸爸死了儿子顶上 currentNode.replaceNodeData(currentNode.rightChild.key, currentNode.rightChild.payload, currentNode.rightChild.leftChild, currentNode.rightChild.rightChild) 第3种情形最复杂，即被删节点有2个子节点。 这时无法简单地将某个子节点上移替换被删节点但可以找到另一个合适的节点来替换被删节点，这个合适节点就是被删节点的下一个key值节点，即被删节点右子树中最小的那个，称为后继。 可以肯定这个后继节点最多只有1个子节点（本身是叶节点，或仅有右子树）将这个后继节点摘出来，替换掉被删节点。 继续补全remove()中第二个条件的代码，我们可以发现下面有一个寻找后继的函数findSuccessor()与进行切分的函数spliceOut()。 # 第三种情况：如果被删除节点有2个子节点 elif currentNode.hasBothChildren(): succ = currentNode.findSuccessor() succ.spliceOut() # 使用后继节点替换掉当前节点信息 currentNode.key = succ.key currentNode.payload = succ.payload 这三个方法要书写到TreeNode类中： def findSuccessor(self): \"\"\" 寻找后继 self:将要被删除的节点 \"\"\" succ = None if self.getRightChild(): succ = self.rightChild.findMin() else: if self.parent: if self.isLeftChild(): succ = self.parent else: self.parent.rightChild = None succ = self.parent.findSuccessor() self.parent.rightChild = self return succ def spliceOut(self): if self.isLeaf(): if self.isLeftChild(): self.parent.leftChild = None else: self.parent.rightChild = None elif self.hasAnyChildren(): if self.getLeftChild(): if self.isLeftChild(): self.parent.leftChild = self.leftChild else: self.parent.rightChild = self.leftChild self.leftChild.parent = self.parent else: if self.isLeftChild(): self.parent.leftChild = self.rightChild else: self.parent.rightChild = self.rightChild self.rightChild.parent = self.parent def findMin(self): \"\"\"寻找最小值，self是当前将要被删除节点的右子节点\"\"\" current = self # 判断当前节点是否有左子节点，有就一直往下找 while current.getLeftChild(): current = current.leftChild # 直到找到将要被删除节点的右子节点下的最左侧节点 return current 完整代码 完整及测试代码如下： #! /usr/local/bin/python3 # -*- coding:utf-8 -*- class BinarySearchTree: def __init__(self): self.root = None self.size = 0 def length(self): return self.size def __len__(self): return self.size def __iter__(self): return self.root.__iter__() def put(self, key, val): if self.root: self._put(key, val, self.root) else: self.root = TreeNode(key, val) self.size += 1 def _put(self, key, val, currentNode): # 如果新key小于root，则准备在左子树中寻找插入位置 if key 1: nodeToRemove = self._get(key, self.root) if nodeToRemove: self.remove(nodeToRemove) self.size -= 1 else: raise KeyError(\"Error, key not in tree\") elif self.size == 1 and self.root.key == key: self.root = None self.size -= 1 else: raise KeyError(\"Error, key not in tree\") def __delitem__(self, key): self.delete(key) def remove(self, currentNode): # 第一种情况：如果被删除节点是叶子节点 if currentNode.isLeaf(): # 判断是左叶子还是右叶子，将其置为None if currentNode == currentNode.parent.leftChild: currentNode.parent.leftChild = None else: currentNode.parent.rightChild = None # 第三种情况：如果被删除节点有2个子节点 elif currentNode.hasBothChildren(): succ = currentNode.findSuccessor() succ.spliceOut() # 使用后继节点替换掉当前节点信息 currentNode.key = succ.key currentNode.payload = succ.payload # 第二种情况：如果被删除的节点有1个子节点 else: # 如果被删除的节点的1个子节点是左子节点 if currentNode.getLeftChild(): # 如果被删除的节点本身是左节点 if currentNode.isLeftChild(): # 爸爸死了，让左儿子的爷爷做左儿子的监护人 currentNode.leftChild.parent = currentNode.parent # 爷爷的左儿子死了，爷爷让左孙子顶替左儿子的位置 currentNode.parent.leftChild = currentNode.leftChild # 如果被删除的节点本身是右节点 elif currentNode.isRightChild(): # 爸爸死了，让左儿子的爷爷做左儿子的监护人 currentNode.leftChild.parent = currentNode.parent # 爷爷的右儿子死了，爷爷让左孙子顶替右儿子的位置 currentNode.parent.rightChild = currentNode.leftChild # 如果被删除的节点本身是根节点 else: # 爸爸死了儿子顶上 currentNode.replaceNodeData(currentNode.leftChild.key, currentNode.leftChild.payload, currentNode.leftChild.leftChild, currentNode.leftChild.rightChild) # 如果被删除的节点的1个子节点是右子节点 else: # 如果被删除的节点本身是左节点 if currentNode.isLeftChild(): # 爸爸死了，让右儿子的爷爷做右儿子的监护人 currentNode.rightChild.parent = currentNode.parent # 爷爷的左儿子死了，爷爷让右孙子顶替左儿子的位置 currentNode.parent.leftChild = currentNode.rightChild # 如果被删除的节点本身是右节点 elif currentNode.isRightChild(): # 爸爸死了，让右儿子的爷爷做右儿子的监护人 currentNode.rightChild.parent = currentNode.parent # 爷爷的右儿子死了，爷爷让右孙子顶替右儿子的位置 currentNode.parent.rightChild = currentNode.rightChild # 如果被删除的节点本身是根节点 else: # 爸爸死了儿子顶上 currentNode.replaceNodeData(currentNode.rightChild.key, currentNode.rightChild.payload, currentNode.rightChild.leftChild, currentNode.rightChild.rightChild) class TreeNode: def __init__(self, key, val, left=None, right=None, parent=None): self.key = key self.payload = val self.leftChild = left self.rightChild = right self.parent = parent def getLeftChild(self): \"\"\"返回左子节点\"\"\" return self.leftChild def getRightChild(self): \"\"\"返回右子节点\"\"\" return self.rightChild def isLeftChild(self): \"\"\"判断当前节点是否是左节点\"\"\" return self.parent and \\ self.parent.leftChild == self def isRightChild(self): \"\"\"判断当前节点是否是右节点\"\"\" return self.parent and \\ self.parent.rightChild == self def isRoot(self): \"\"\"判断当前节点是否是根节点，根节点无父节点\"\"\" return not self.parent def isLeaf(self): \"\"\"判断当前节点是否是叶子节点\"\"\" return not (self.rightChild or self.leftChild) def hasAnyChildren(self): \"\"\"判断当前节点是否含有任意的子节点\"\"\" return self.rightChild or self.leftChild def hasBothChildren(self): \"\"\"判断当前节点是否含有左子节点和右子节点\"\"\" return self.rightChild and self.leftChild def replaceNodeDate(self, key, value, lc, rc): \"\"\"替换当前节点\"\"\" self.key = key self.payload = value self.leftChild = lc self.rightChild = rc if self.getLeftChild(): self.leftChild.parent = self if self.getRightChild(): self.rightChild.parent = self def __iter__(self): \"\"\"采用中序遍历\"\"\" if self: if self.getLeftChild(): for ele in self.leftChild: yield ele yield self.key if self.getRightChild(): for ele in self.rightChild: yield ele def findSuccessor(self): \"\"\" 寻找后继 self:将要被删除的节点 \"\"\" succ = None if self.getRightChild(): succ = self.rightChild.findMin() else: if self.parent: if self.isLeftChild(): succ = self.parent else: self.parent.rightChild = None succ = self.parent.findSuccessor() self.parent.rightChild = self return succ def spliceOut(self): if self.isLeaf(): if self.isLeftChild(): self.parent.leftChild = None else: self.parent.rightChild = None elif self.hasAnyChildren(): if self.getLeftChild(): if self.isLeftChild(): self.parent.leftChild = self.leftChild else: self.parent.rightChild = self.leftChild self.leftChild.parent = self.parent else: if self.isLeftChild(): self.parent.leftChild = self.rightChild else: self.parent.rightChild = self.rightChild self.rightChild.parent = self.parent def findMin(self): \"\"\"寻找最小值，self是当前将要被删除节点的右子节点\"\"\" current = self # 判断当前节点是否有左子节点，有就一直往下找 while current.getLeftChild(): current = current.leftChild # 直到找到将要被删除节点的右子节点下的最左侧节点 return current if __name__ == '__main__': mytree = BinarySearchTree() mytree[3] = \"red\" mytree[4] = \"blue\" mytree[6] = \"yellow\" mytree[2] = \"at\" del mytree[2] for i in mytree: print(i) 性能分析 上述的二叉搜索树，性能影响最大的是其高度，而其高度又受数据项key插入顺序的影响。 如果key的列表是随机分布的话，那么大于和小于根节点key的键值大致相等。 这样的树就是平衡树，put()方法最差性能为O(log2n)。 如果key的插入的顺序十分极端，如下图所示，那么put()方法的性能就变为了O(n)，其他方法也类似： 如何改进二叉搜索树，让其不受到key插入顺序的影响呢？ 这就涉及到下面要介绍的平衡二叉查找树的知识了。 平衡二叉查找树 AVL树即为平衡二叉树，它能够保证性能不受到key插入顺序的影响。 AVL是发明者的名字缩写：G.M. Adelson-Velskii and E.M. Landis AVL树的实现与基础的BinarySearcTree的实现基本相同，唯一不同之处在于二叉树的生成与维护过程。 平衡因子 AVL树的实现中，需要对每个节点跟踪“平衡因子balancefactor”参数，平衡因子是根据节点的左右子树的高度来定义的，确切地说，是左右子树高度差。 balanceFactor = height(leftSubTree) − height(rightSubTree) 如果平衡因子大于0，称为“左重left-heavy”，小于零称为“右重right-heavy”平衡因子等于0，则称作平衡。 如果一个二叉查找树中每个节点的平衡因子都在-1，0，1之间，则把这个二叉搜索树称为平衡树。 在平衡树操作过程中，有节点的平衡因子超出此范围，则需要一个重新平衡的过程。 也就是说，左子树和右子树的高度差不能超过1，在AVL树实现中只要确保该点即可。 树的自旋 我们只需要在上面的BinarySearchTree中做改进便可完成实现，首先，如果向AVL树插入一个新key，如何才能保持AVL树的平衡性质。 作为BinarySearchTree，新key必定以叶节点形式插入到AVL树中，叶节点的平衡因子是0，其本身无需重新平衡。 但这样做会影响其父节点的平衡因子： 作为左子节点插入，则父节点平衡因子会增加1 作为右子节点插入，则父节点平衡因子会减少1 这种影响可能随着其父节点到根节点的路径一直传递上去，直到传递到根节点为止。 或者某个父节点平衡因子被调整到0，不再影响上层节点的平衡因子为止。 无论从-1或者1调整到0，都不会改变子树高度，如下图所示，左侧的父节点本身平衡因子是1，但是因为加入了新的节点，父节点的平衡因子变为了0，此时不会再往上传递。 AVL树中如何将不平衡因子转为平衡？最主要的手段就是通过旋转，左旋、右旋、先左旋后右旋、先右旋后左旋4种策略。 根据当前树是左重，还是右重来进行不同方向的旋转，同时还需要更新相关父节点的引用，更新旋转后被影响节点的平衡因子。 左旋(LL) 示例1，新插入了C在B的右侧： 叶子节点C的平衡因子为0 从B的角度看这课树，平衡因子是-1，符合AVL树的性质 从A的角度看这课树，平衡因子是-2，已经不符合AVL树的性质，需要进行左旋调整 右旋(RL) 示例2，新插入了A在B的左侧： 叶子节点A的平衡因子为0 从B的角度看这棵树，平衡因子是1，符合AVL树的性质 从A的角度看这棵树，平衡因子是2，已经不符合AVL树的性质，需要进行右旋调整 两次旋转是已经解释过的旋转形式的稍微复杂的版本。为了更好地理解它们，我们应注意旋转时执行的每个动作。让我们首先检查如何执行左右旋转。左右旋转是左旋转与右旋转的组合。 先左后右旋(LR) 一个节点已插入到左子树的右子树中。这使C成为不平衡节点。这种情况下使AVL树执行左右旋转： 我们首先在C的左子树上执行左旋转。这使A成为B的左子树： 节点C仍然不平衡： 现在，我们将树右旋转，使B成为该子树的新根节点。C现在成为其自己的左子树的右子树。 目前，树已平衡： 先右旋后左旋(RL) 一个节点已插入到右子树的左子树中。这使C成为不平衡节点。这种情况下使AVL树执行右左旋转： 首先，我们沿C节点执行右旋转，使C成为其自己的左子树B的右子树。现在，B成为A的右子树。 节点A仍然由于其右子树的右子树而处于不平衡状态，并且需要向左旋转。 通过使B成为子树的新根节点，可以执行向左旋转。A成为其右子树B的左子树。 目前，树已平衡： 代码实现 只需要在BinarySearchTree的代码中做如下修改即可，如下添加了左旋代码，右旋和双向旋转没有添加，感兴趣的朋友可以自行实现： # __init__中新增节点的平衡因子属性： rotRoot.balanceFactor = rotRoot.balanceFactor + 1 - min(0,newRoot.balanceFactor) def _put(self, key, val, currentNode): # 如果新key小于root，则准备在左子树中寻找插入位置 if key 1 or node.balanceFactor 0: self.rotateRight(node.rightChild) self.rotateLeft(node) else: self.rotateLeft(node) elif node.balanceFactor > 0: if node.leftChild.balanceFactor Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-22 12:19:11 "},"Python/Python设计模式/summary.html":{"url":"Python/Python设计模式/summary.html","title":"Python设计模式","keywords":"","body":" 设计模式 普通工厂模式 抽象工厂模式 建造者模式 单例模式 原型模式 适配器模式 桥接模式 组合模式 外观模式 代理模式 装饰器模式 享元模式 责任链模式 解释器模式 迭代器模式 观察者模式 中介者模式 访问者模式 备忘录模式 命令模式 状态模式 策略模式 模板模式 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-25 18:00:37 "},"Python/Python设计模式/设计模式.html":{"url":"Python/Python设计模式/设计模式.html","title":"设计模式","keywords":"","body":"设计模式 设计模式与语言无关，是一种通用的解决思路。 是早期的先辈们在实践中总结出的精华，是考虑了封装性、复用性、效率性、可修改性、可一致性等各种因素的高度总结思想。 一个良好的设计模式对整个系统的影响极其重要，能大幅度提升可读性，利于团队项目的继承和扩展。 反之，如果设计的不好，不光是维护麻烦，项目交接等工作也变的难以展开。 GOF 1994 年，由 Erich Gamma、Richard Helm、Ralph Johnson 和 John Vlissides 四人合著出版了一本名为 Design Patterns - Elements of Reusable Object-Oriented Software（中文译名：设计模式 - 可复用的面向对象软件元素）的书，该书首次提到了软件开发中设计模式的概念。 四位作者合称 GOF（四人帮，全拼 Gang of Four）。 他们所提出的设计模式主要是基于以下的面向对象设计原则。 对接口编程而不是对实现编程 优先使用对象组合而不是继承 六大原则 开闭原则(Open Close Principle) 开闭原则的意思是：对扩展开放，对修改关闭。 在程序需要进行拓展的时候，不能去修改原有的代码，必须实现一个热插拔的效果。 简而言之，它是为了使程序的扩展性更好，更易于维护和升级而提出的一种原则。 想要达到这样的效果，我们需要使用接口和抽象基类对实现类进行约束。 一句话表示：不要修改源代码进行扩展，而是在设计之初就做好扩展的打算 里氏代换原则(Liskov Substitution Principle) 里氏代换原则是面向对象设计的基本原则之一。 里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。 LSP 是继承复用的基石，只有当派生类可以替换掉基类，且软件单位的功能不受到影响时，基类才算真正被复用，而派生类也能够在基类的基础上增加新的行为。 里氏代换原则是对开闭原则的补充。实现开闭原则的关键步骤就是抽象化，而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。 一句话表示：一个功能被父类能调用，则子类也必定能被调用，如动物类能够调用吃东西这个功能，则其子类狼、狗、猫等都能够调用吃东西这个功能 依赖倒转原则(Dependence Inversion Principle) 这个原则是开闭原则的基础，具体内容：针对接口编程，依赖于抽象而不依赖于具体。 一句话表示：多使用接口、抽象基类等规范子类行为，使整个项目逻辑仅看接口便能知道它是如何运作的。 接口隔离原则(Interface Segregation Principle) 这个原则的意思是：使用多个隔离的接口，比使用单个接口要好。 它还有另外一个意思是：降低类之间的耦合度。 由此可见，其实设计模式就是从大型软件架构出发、便于升级和维护的软件设计思想，它强调降低依赖，降低耦合。 一句话表示：将各个不同功能之间的接口耦合度降低，尽可能防止链式崩塌，即一个接口出了问题其他接口跟着完蛋 迪米特法则(Demeter Principle) 又称最少知道原则，它是指：一个实体应当尽量少地与其他实体之间发生相互作用，使得系统功能模块相对独立。 一句话表示：一个对象尽量只负责自己的一些行为，而不要涉及其他对象的行为 合成复用原则(Composite Reuse Principle) 合成复用原则是指：尽量使用合成/聚合/组合的方式书写代码，而不是使用继承。 一句话表示：继承是增加耦合性、减少代码量的一种方式，不要随意滥用。 相关分类 常说的设计模式有23种，可分为3大类，其类别分别是： 创建型模式5种 结构型模式7种 行为性模式11种 来源于Design Patterns - Elements of Reusable Object-Oriented Software一书。 而另外有8种设计模式，被分为J2EE模式，更加注重表示层，由Sun Java Center进行鉴定，这里不再进行演示。 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-25 17:31:30 "},"Python/Python设计模式/普通工厂模式.html":{"url":"Python/Python设计模式/普通工厂模式.html","title":"普通工厂模式","keywords":"","body":"普通工厂模式 工厂模式（Factory Pattern）是非常常用的一种模式，主要分为2大部分： 简单工厂模式 工厂方法模式 两者同属普通工厂模式，只是在理念上有一些细微的差异。 该模式属于创建型模式。 简单工厂模式 基本介绍 用户只需关注自身需要一个什么样的产品，而不用将注意力放在如何构建这个产品上。 只要用户构思好了，直接从工厂类的一个指定接口中去拿产品即可。、 特点：对外隐藏，只暴露一个接口，但这个接口可以创建出非常多的用户所需要的产品 案例图示 假如一个用户要买手机，他只需要考虑手机的品牌，型号，颜色等信息，而并不需要关心去那里买的问题，因为在手机城里各式各样的手机都应有尽有。 优缺点 优点： 隐藏对象创建的细节 客户端不需要修改代码 缺点： 违反单一职责原则，将创建逻辑集中到了一个工厂类里 当添加新的产品时，需要修改工厂类的代码，违反了开闭原则 代码实现 用Python实现简单工厂模式： # 定义手机厂商 class BasePhone: def __init__(self, model, color) -> None: self.model = model self.color = color def getInfo(self): return \"A %s mobile phone, the brand is %s, the model is %s\" % (self.color, self.brand, self.model) class SamSung(BasePhone): def __init__(self, model, color) -> None: self.brand = __class__.__name__ super(__class__, self).__init__(model, color) class Apple(BasePhone): def __init__(self, model, color) -> None: self.brand = __class__.__name__ super(__class__, self).__init__(model, color) class HuaWei(BasePhone): def __init__(self, model, color) -> None: self.brand = __class__.__name__ super(__class__, self).__init__(model, color) # 定义工厂 class MobleCity: def shopPhone(self, brand, model, color): brandDict = { \"SamSung\": SamSung, \"Apple\": Apple, \"HuaWei\": HuaWei } cls = brandDict.get(brand) if cls: instance = cls(model, color) return instance raise TypeError(\"no brand : %s\" % brand) if __name__ == \"__main__\": store = MobleCity() iphone_x = store.shopPhone(brand=\"Apple\", model=\"X\", color=\"black\") sumsung_note7 = store.shopPhone( brand=\"SamSung\", model=\"Note 7\", color=\"blue\") huawei_p10 = store.shopPhone(brand=\"HuaWei\", model=\"P10\", color=\"white\") print(iphone_x.getInfo()) print(sumsung_note7.getInfo()) print(huawei_p10.getInfo()) # A black mobile phone, the brand is Apple, the model is X # A blue mobile phone, the brand is SamSung, the model is Note 7 # A white mobile phone, the brand is HuaWei, the model is P10 工厂方法模式 基本介绍 简单工厂模式是将所有产品都放在1个工厂中，而工厂方法模式是每个不同种类的产品都放在一个单独的工厂中。 相较于简单工厂模式来说，设计更加简单一些。 特点：对外隐藏，每个工厂指定暴露一个接口，用于让用户取出该工厂的产品 案例图示 假如一个用户要买手机，他只需要考虑手机的品牌，型号，颜色等信息，并不需要关心手机是怎么造出来的，充分对外隐藏内部实现细节。 只要用户构思好了，就直接到每个手机品牌专卖店去买即可： 乍一看和简单工厂很相似，但是这个是每个手机品牌都有一个自己的专卖店，也就是说代码耦合度降低了。 优缺点 优点： 每个具体产品都对应一个具体的工厂类，当新增产品时不需要修改工厂类代码 隐藏了对象创建的细节 缺点： 每增加一个具体产品类，就必须增加一个相应的具体工厂类 代码实现 用Python实现工厂方法模式： # 定义手机厂商 class BasePhone: def __init__(self, model, color) -> None: self.model = model self.color = color def getInfo(self): return \"A %s mobile phone, the brand is %s, the model is %s\" % (self.color, self.brand, self.model) class SamSung(BasePhone): def __init__(self, model, color) -> None: self.brand = __class__.__name__ super(__class__, self).__init__(model, color) class Apple(BasePhone): def __init__(self, model, color) -> None: self.brand = __class__.__name__ super(__class__, self).__init__(model, color) class HuaWei(BasePhone): def __init__(self, model, color) -> None: self.brand = __class__.__name__ super(__class__, self).__init__(model, color) # 定义工厂 class SamSungStore: def shopPhone(self, model, color): return SamSung(model, color) class AppleStore: def shopPhone(self, model, color): return Apple(model, color) class HuaWeiStore: def shopPhone(self, model, color): return HuaWei(model, color) if __name__ == \"__main__\": samsungStore = SamSungStore() appleStore = AppleStore() huaweiStore = HuaWeiStore() iphone_x = appleStore.shopPhone(model=\"X\", color=\"black\") sumsung_note7 = samsungStore.shopPhone(model=\"Note 7\", color=\"blue\") huawei_p10 = huaweiStore.shopPhone(model=\"P10\", color=\"white\") print(iphone_x.getInfo()) print(sumsung_note7.getInfo()) print(huawei_p10.getInfo()) # A black mobile phone, the brand is Apple, the model is X # A blue mobile phone, the brand is SamSung, the model is Note 7 # A white mobile phone, the brand is HuaWei, the model is P10 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-24 19:35:11 "},"Python/Python设计模式/抽象工厂模式.html":{"url":"Python/Python设计模式/抽象工厂模式.html","title":"抽象工厂模式","keywords":"","body":"基本介绍 抽象工厂模式（Abstract Factory Pattern）在其他普通工厂模式的2个分支基础上，能够控制产品的类型。 该设计模式主要围绕一个超级工厂创建其他工厂。 该超级工厂又称为其他工厂的工厂。 特定：对外隐藏，可搭配普通工厂模式或者工厂方法模式来指定接口，但在此基础上管控了生成产品的零部件来源 该模式属于创建型模式。 案例图示 在普通工厂模式中，造一辆车时如果不对其零部件来源加以控制，可能发现装上了一个不属于该车范畴的配件。 但是在抽象工厂模式下，购车造车时专卖店必须负责车辆配件的来源，如发生假冒伪劣产品必须承担责任，如下图所示： 优缺点 优点： 将客户端与类的具体实现相分离 每个工厂创建了一个完整的产品系列，使得易于交换产品系列 有利于产品的一致性 缺点： 难以支持新种类的抽象产品，扩展困难 代码实现 用Python实现抽象工厂模式： # 零部件厂商 # 生产奔驰轮胎的厂商 class BenzTiresManufacturer: def getInfo(self): return \"Benz make\" # 生产奔驰底盘的厂商 class BenzChassisManufacturer: def getInfo(self): return \"Benz make\" # 生产奔驰其他零部件的厂商 class BenzOtherManufacturer: def getInfo(self): return \"Benz make\" # 品牌厂商 class Benz: def __init__(self, color): self.brandMsg = self.__class__.__name__ self.colorMsg = color self.tiresMsg = None self.chassisMsg = None self.otherMsg = None def build_car(self, tiresManufacturer, chassisManufacturer, otherManufacturer): # 由厂家内部根据指定零件厂商，开始制造零件 self.makeTires(tiresManufacturer) self.makeChassis(chassisManufacturer) self.makeOther(otherManufacturer) def getCar(self): return self def makeTires(self, tiresManufacturer): tires = tiresManufacturer() self.tiresMsg = tires.getInfo() def makeChassis(self, chassisManufacturer): chassis = chassisManufacturer() self.chassisMsg = chassis.getInfo() def makeOther(self, otherManufacturer): other = otherManufacturer() self.otherMsg = other.getInfo() def getInfo(self): return \"brand:%s\\ncolor:%s\\ntires:%s\\nchassis:%s\\nother:%s\\n\" % (self.brandMsg, self.colorMsg, self.tiresMsg, self.chassisMsg, self.otherMsg) # 品牌厂商专卖店 class BenzStore: def buyCar(self, color): # step03：告诉奔驰厂家该车的颜色 self.brand = Benz(color=color) # step04：通知厂家开始造车，专卖店必须要对零部件负责，故此在这里指定 # 轮胎、底盘、其他零件均为奔驰制造 self.brand.build_car( tiresManufacturer=BenzTiresManufacturer, chassisManufacturer=BenzChassisManufacturer, otherManufacturer=BenzChassisManufacturer ) # step05：获取造出来的汽车并返回给用户 return self.brand.getCar() if __name__ == \"__main__\": # step01：实例化出奔驰专卖店 benzStore = BenzStore() # step02：去专卖店买车 benzCar = benzStore.buyCar(\"black\") print(benzCar.getInfo()) # brand:Benz # color:black # tires:Benz make # chassis:Benz make # other:Benz make Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-24 19:34:21 "},"Python/Python设计模式/建造者模式.html":{"url":"Python/Python设计模式/建造者模式.html","title":"建造者模式","keywords":"","body":"基本介绍 建造者模式（Builder Pattern）使用多个简单的对象一步一步构建成一个复杂的对象。 具体内容是将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。 特点：灵活，耦合度低，可自由组合，提供暴露接口使用户不必关心底层的实现，直接调用即可 建造者模式与抽象工厂模式相似，也用来创建复杂的对象。 主要的区别是建造者模式着重一步步构造一个复杂且灵活的对象，而抽象工厂模式着重于同时提供多个系列的产品对象。 该模式属于创建型模式。 案例图示 去肯德基，汉堡、可乐、薯条、炸鸡翅等是不变的，而其组合是经常变化的，生成出所谓的”套餐\"： 优缺点 优点： 隐藏了一个产品的内部结构和装配过程 将构造代码与表示代码分开 可以对构造过程进行更加精细的控制 缺点： 产品必须有共同点，范围有限制 如果内部变化复杂，会有很多的建造类 代码实现 用Python实现建造者模式： # 最终产品 class Product: def __init__(self) -> None: self.hamburger = None self.coke = None def __str__(self) -> str: return \"Product\".center(20, \"=\") + \\ \"\\n\" + (\"hamburger : %s\" % self.hamburger).center(20, \" \") + \\ \"\\n\" + (\"coke : %s\" % self.coke).center(20, \" \") + \\ \"\\n\" + \"=\" * 20 # 套餐组合 # 套餐1（肥牛组合）：牛肉汉堡、可口可乐 class BeefPackage: def __init__(self) -> None: self.product = Product() def buildHamburger(self): self.product.hamburger = \"Beaf Hamburger\" def buildCoke(self): self.product.coke = \"Coca Cola\" # 套餐2(炸鸡套餐) ： 鸡肉汉堡、百事可乐 class ChickenPackage: def __init__(self) -> None: self.product = Product() def buildHamburger(self): self.product.hamburger = \"Chicken Hamburger\" def buildCoke(self): self.product.coke = \"Pepsi Cola\" # 建造者类 class KfcStore: def getProduct(self): package = None choice = input( \"Please Choice Your Package\\na.Beef Package\\nb.Chicken Package\\n>>> \") if choice == \"a\": package = BeefPackage() elif choice == \"b\": package = ChickenPackage() else: raise ValueError(\"don't have package choice %r\" % choice) # 根据选择套餐方案开始建造产品 package.buildHamburger() package.buildCoke() return package.product if __name__ == \"__main__\": kfc = KfcStore() product = kfc.getProduct() print(product) # Please Choice Your Package # a.Beef Package # b.Chicken Package # >>> b # ======Product======= # hamburger : Chicken Hamburger # coke : Pepsi Cola # ==================== Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-24 19:35:05 "},"Python/Python设计模式/单例模式.html":{"url":"Python/Python设计模式/单例模式.html","title":"单例模式","keywords":"","body":"基本介绍 单例模式（Singleton Pattern）即一个类只能拥有一个实例对象，实例化多次的结果都会指向同一个对象。 特点：全局唯一，允许更改 该模式属于创建型模式，同时也是创建型模式中应用最为广泛的一种。 案例图示 从配置文件中读取配置来进行实例化，在配置相同的情况下，就没必要重复产生对象浪费内存了，只有在配置不同的情况下才会生成新的实例。 文件内容如下： # settings.py文件内容如下 HOST = \"localhost\" PORT = 3306 案例图示： 优缺点 优点： 避免对资源的多重占用，如写入文件操作 节省内存 防止命名空间被污染 缺点： 没有接口，不能继承，与单一职责原则冲突，一个类应该只关心内部逻辑，而不关心外面怎么样来实例化 代码实现 Python实现单例模式手段较多，这里例举5种比较常见的。 继承实现 基础代码如下： class Singleton: def __new__(cls, *args, **kwargs) -> object: \"\"\" cls : class Category \"\"\" if not hasattr(cls, \"ins\"): singletonInsObject = super(__class__, cls).__new__(cls, *args, **kwargs) setattr(cls, \"ins\", singletonInsObject) return getattr(cls, \"ins\") class Category(Singleton): pass if __name__ == \"__main__\": ins = Category() print(id(ins)) ins = Category() print(id(ins)) 元类实现 基础代码如下： class MetaClass(type): def __call__(self, *args, **kwargs): \"\"\" self : class Category \"\"\" if not hasattr(self, \"ins\"): singletonInsObject = super(__class__, self).__call__(*args, **kwargs) setattr(self, \"ins\", singletonInsObject) return getattr(self, \"ins\") class Category(object, metaclass=MetaClass): pass if __name__ == \"__main__\": ins = Category() print(id(ins)) ins = Category() print(id(ins)) 装饰器实现 基础代码如下： def warpper(clsObject): def inner(*args, **kwargs): if not hasattr(clsObject, \"ins\"): singletonInsObject = clsObject(*args, **kwargs) setattr(clsObject, \"ins\", singletonInsObject) return getattr(clsObject, \"ins\") return inner @warpper class Category: pass if __name__ == \"__main__\": ins = Category() print(id(ins)) ins = Category() print(id(ins)) 模块实现 基础代码如下： - foo.py --> ins = Category() - bar.py --> from foo import ins @classmethod实现 基础代码如下： class Category: @classmethod def getSingletonInstanceObject(cls, *args, **kwargs): if not hasattr(cls, \"ins\"): singletonInsObject = cls(*args, **kwargs) setattr(cls, \"ins\", singletonInsObject) return getattr(cls, \"ins\") if __name__ == \"__main__\": ins = Category.getSingletonInstanceObject() print(id(ins)) ins = Category.getSingletonInstanceObject() print(id(ins)) 案例实现 案例实现采用元类实现、装饰器实现以及@classmethod实现. 1）元类实现： import settings class MetaClass(type): \"\"\" self : class MySQL \"\"\" def __call__(self, *args, **kwargs): # 常规实例化 if args or kwargs: insObject = object.__new__(self) self.__init__(insObject, *args, **kwargs) return insObject # 采用默认配置实例化，生成单例对象 if not hasattr(self, \"ins\"): singletonInsObject = object.__new__(self) self.__init__(singletonInsObject, settings.HOST, settings.PORT) setattr(self, \"ins\", singletonInsObject) return getattr(self, \"ins\") class MySQL(object, metaclass=MetaClass): def __init__(self, host, port) -> None: self.host = host self.port = port if __name__ == \"__main__\": ins1 = MySQL(\"192.168.0.1\", 3306) ins2 = MySQL(\"192.168.0.1\", 3307) print(ins1 is ins2) ins3 = MySQL() ins4 = MySQL() print(ins3 is ins4) # False # True 2）装饰器实现： import settings def warpper(cls): singletonInsObject = cls(settings.HOST, settings.PORT) def inner(*args, **kwargs): # 常规实例化 if args or kwargs: insObject = cls(*args, **kwargs) return insObject # 采用默认配置实例化，生成单例对象 return singletonInsObject return inner @warpper class MySQL: def __init__(self, host, port) -> None: self.host = host self.port = port if __name__ == \"__main__\": ins1 = MySQL(\"192.168.0.1\", 3306) ins2 = MySQL(\"192.168.0.1\", 3307) print(ins1 is ins2) ins3 = MySQL() ins4 = MySQL() print(ins3 is ins4) # False # True 3）@classmethod实现： import settings class MySQL: singletonInsObject = None # 常规实例化 def __init__(self, host, port) -> None: self.host = host self.port = port # 采用默认配置实例化，生成单例对象 @classmethod def getSingletonInstanceObject(cls): if not cls.singletonInsObject: cls.singletonInsObject = cls(settings.HOST, settings.PORT) return cls.singletonInsObject if __name__ == \"__main__\": ins1 = MySQL(\"192.168.0.1\", 3306) ins2 = MySQL(\"192.168.0.1\", 3307) print(ins1 is ins2) ins3 = MySQL.getSingletonInstanceObject() ins4 = MySQL.getSingletonInstanceObject() print(ins3 is ins4) # False # True Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-24 19:34:41 "},"Python/Python设计模式/原型模式.html":{"url":"Python/Python设计模式/原型模式.html","title":"原型模式","keywords":"","body":"基本介绍 原型模式（Prototype Pattern）是用于创建重复的对象，同时又能保证性能。 这种模式是实现了一个原型接口，该接口用于创建当前对象的克隆。 当直接创建对象的代价比较大时，则采用这种模式。 特点：仅存在一份，后面如果要用类似的就进行克隆拷贝，拷贝方式分2种，深拷和浅拷，原型允许个体中的属性存在差异 原型模式更适用于创建一个通用的模板，后续要使用时在此模板的基础上对实例属性进行一定范围内的变更。 该模式属于创建型模式。 案例图示 每台计算机的构成都是类似的，如果要同时组装多台计算机，可采用原型模式进行设计。 只实例化一次，减少实例化的消耗，后续个体都通过拷贝原型并修改其中属性实现差异化： 优缺点 优点： 性能提高，减少实例化时的内存消耗 节省内存 简化对象创建，同时避免了构造函数的约束，不受构造函数的限制直接复制对象，是优点，也有隐患，这一点还是需要多留意一些 缺点： 深拷贝和浅拷贝的使用需要事先考虑周到 某些编程语言中，拷贝会影响到静态变量和静态函数的使用 代码实现 用Python实现原型模式： import copy # 计算机原型 class ComputerPrototype: def __init__(self) -> None: self.cpu = None self.gpu = None self.ram = None def getInfo(self): return \"cpu : %s\\ngpu : %s\\nram : %s\" % (self.cpu, self.gpu, self.ram) # 原型建造类 class Prototype: def __init__(self) -> None: self.prototype = ComputerPrototype() def getComputer(self, cpu, gpu, ram): computer = copy.deepcopy(self.prototype) computer.__dict__.update({\"cpu\": cpu, \"gpu\": gpu, \"ram\": ram}) return computer if __name__ == \"__main__\": pro = Prototype() computerOne = pro.getComputer(cpu=\"Intel\", gpu=\"Nvidia\", ram=\"Samsung\") computerSecond = pro.getComputer(cpu=\"AMD\", gpu=\"AMD\", ram=\"Kingston\") print(computerOne.getInfo()) print(computerOne.getInfo()) # cpu : Intel # gpu : Nvidia # ram : Samsung # cpu : Intel # gpu : Nvidia # ram : Samsung Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-24 19:35:51 "},"Python/Python设计模式/适配器模式.html":{"url":"Python/Python设计模式/适配器模式.html","title":"适配器模式","keywords":"","body":"基本介绍 适配器模式（Adapter Pattern）是作为两个不兼容的接口之间的桥梁。 这种模式涉及到一个单一的类，该类负责加入独立的或不兼容的接口功能。 特点：兼容不同功能接口的2个类，让这2个类都能用相同的方式进行功能调用 该模式属于结构型模式。 案例图示 现在有2种支付方案，AliPay和WechatPay，它们调用支付的方法都不相同： AliPay调用的是aliPayAPI()进行支付 WechatPay调用的是wechatPayAPI()进行支付 现在我想实现的是不管是AliPay还是WechatPay都调用payAPI来进行支付，不再有各种区分。 并且如果后期加入了AppalePay支付的话，也是调用payAPI进行支付。 有这种需求的话就可以使用适配器模式来对接口进行适配，进行统一管理，如下图所示： 优缺点 优点： 可以让任何两个没有关联的类一起运行 提高了类的复用 增加了类的透明度 灵活性好 缺点： 过多地使用适配器，会让系统非常零乱，不易整体进行把握。比如，明明看到调用的是 A 接口，其实内部被适配成了 B 接口的实现 代码实现 用Python实现适配器模式，有2种实现方案，1是多继承，2是组合，下面是使用组合的方式实现： # 被适配类和接口 class AliPay: def aliPayAPI(self, sum): print(\"ali pay $%s\" % sum) class WeichatPay: def weichatPayAPI(self, sum): print(\"weichat pay $%s\" % sum) # 适配器类 class PayAdapter: def __init__(self, payMode, payMethod) -> None: self.payMode = payMode() self.payMethod = payMethod self.checkPay() def checkPay(self): if not hasattr(self.payMode, self.payMethod): raise AttributeError( \"Unsupported payment method：%s\" % self.payMethod) def payAPI(self, sum): method = getattr(self.payMode, self.payMethod) return method(sum) if __name__ == \"__main__\": # 对支付方案套上适配器 aliPayInstance = PayAdapter(AliPay, \"aliPayAPI\") weichatPayInstance = PayAdapter(WeichatPay, \"weichatPayAPI\") # 使用适配器接口付款 aliPayInstance.payAPI(100) weichatPayInstance.payAPI(100) # ali pay $100 # weichat pay $100 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-24 19:35:20 "},"Python/Python设计模式/桥接模式.html":{"url":"Python/Python设计模式/桥接模式.html","title":"桥接模式","keywords":"","body":"基本介绍 桥接模式（Bridge）将一个事物一分为二，把抽象的部分和实现的部分进行抽离，达到解耦的作用。 同时，被拆分的2个部分也都可以进行独立的变化。 特点：一分为二、独立扩展 桥接模式属于结构型模式。 案例图示 拿一支笔来举例，它拥有钢笔、毛笔等类型（实体）。 同时，不同的实体类型有不同的作用，如钢笔就写硬笔字（抽象），毛笔就写软笔字（抽象）。 优缺点 优点： 实现抽象和现实分离，便于维护 桥接模式拥有优秀的可扩展能力 实现细节对用户透明 缺点： 增加理解和设计难度 代码实现 用Python实现桥接模式： # 实现 class Pen: def __init__(self, use) -> None: self.name = \"pen\" self.use = use def getUse(self): return \"%s can write %s\" % (self.name, self.use.desc) class Brush: def __init__(self, use) -> None: self.name = \"brush\" self.use = use def getUse(self): return \"%s can write %s\" % (self.name, self.use.desc) # 抽象 class HardPenWords: @property def desc(self): return \"hard pen words\" class SoftPenWords: @property def desc(self): return \"soft pen words\" if __name__ == \"__main__\": pen = Pen(use=HardPenWords()) brush = Brush(use=SoftPenWords()) print(pen.getUse()) print(brush.getUse()) # pen can write hard pen words # brush can write soft pen words Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-24 11:55:09 "},"Python/Python设计模式/组合模式.html":{"url":"Python/Python设计模式/组合模式.html","title":"组合模式","keywords":"","body":"基本介绍 组合模式（Composite Pattern），又叫部分整体模式，是用于把一组相似的对象当作一个单一的对象。 组合模式依据树形结构来组合对象，用来表示部分以及整体层次。 特点：多个小的构成一个大的，根据不同粒度可以无限制的进行组合 该模式属于结构型模式，它创建了对象组的树形结构。 案例图示 一台计算机由粗看之下由以下配件组成： 机箱（chassis） 显示器（monitor） 核心处理器（CPU） 显卡（GPU） 内存（memory） 硬盘（disk） 电源（mains） 主板（motherboard） 我们可以使用组合模式将这些配件组装到一起，得到一台计算机。 优缺点 优点： 高层模块调用简单 节点自由增加 缺点： 在使用组合模式时，其叶子和树枝的声明都是实现类，而不是接口，违反了依赖倒置原则 代码实现 用Python实现组合模式，需要注意硬盘内存和显示器可能有多个，因此内部需要用列表来进行维护： # 机箱 class Chassis: def __init__(self, brand, model) -> None: self.brand = brand self.model = model # 主板 class Motherboard: def __init__(self, brand, model) -> None: self.brand = brand self.model = model # CPU class CPU: def __init__(self, brand, model) -> None: self.brand = brand self.model = model # GPU class GPU: def __init__(self, brand, model) -> None: self.brand = brand self.model = model # 内存 class Memory: def __init__(self, brand, size) -> None: self.brand = brand self.size = size # 硬盘 class Disk: def __init__(self, brand, size, type) -> None: self.brand = brand self.size = size self.type = type # 电源 class Mains: def __init__(self, brand, power) -> None: self.brand = brand self.power = power # 显示器 class Monitor: def __init__(self, brand, size, resolution) -> None: self.brand = brand self.size = size self.resolution = resolution # 电脑 class Computer: def __init__(self) -> None: self.chassis = None self.monitor = [] self.cpu = None self.gpu = None self.memory = [] self.disk = [] self.mains = None self.motherboard = None def add(self, name, obj): if hasattr(self, name): oldObject = getattr(self, name) if isinstance(oldObject, list): oldObject.append(obj) else: setattr(self, name, obj) else: raise TypeError(\"invalid accessories\") def remove(self, name): if hasattr(self, name): oldObject = getattr(self, name) if isinstance(oldObject, list): oldObject.pop() else: setattr(self, name, None) def getInfo(self): compileMessage = f\"\"\" ---- compile message ---- Chassis : {self.chassis.brand} {self.chassis.model} Monitor : {list(map(lambda obj:obj.brand + \" \" + obj.size + \" \" + obj.resolution, self.monitor))} * {len(self.monitor)} CPU : {self.cpu.brand} {self.cpu.model} GPU : {self.gpu.brand} {self.gpu.model} Memory : {list(map(lambda obj:obj.brand + \" \" + obj.size, self.memory))} * {len(self.memory)} Disk : {list(map(lambda obj:obj.brand + \" \" + obj.size, self.disk))} * {len(self.disk)} Mains: {self.mains.brand} {self.mains.power} Motherboard : {self.motherboard.brand} {self.motherboard.model} \"\"\" return compileMessage if __name__ == \"__main__\": chassis = Chassis(brand=\"ROG\", model=\"MINI-ITX\") monitor = Monitor(brand=\"SamSung\", size=\"72\", resolution=\"244hz\") cpu = CPU(brand=\"Intel\", model=\"core i9-10980XE\") gpu = GPU(brand=\"Nvidia\", model=\"RTX3090\") memory = Memory(brand=\"SamSung\", size=\"32GB\") disk = Disk(brand=\"SamSung\", size=\"2TB\", type=\"SSD\") mains = Mains(brand=\"Huntkey\", power=\"700W\") motherboard = Motherboard(brand=\"ROG\", model=\"Strix X299-E Gaming II\") compile = Computer() compile.add(\"chassis\", chassis) compile.add(\"monitor\", monitor) compile.add(\"cpu\", cpu) compile.add(\"gpu\", gpu) compile.add(\"memory\", memory) compile.add(\"memory\", memory) compile.add(\"disk\", disk) compile.add(\"mains\", mains) compile.add(\"motherboard\", motherboard) print(compile.getInfo()) # ---- compile message ---- # Chassis : ROG MINI-ITX # Monitor : ['SamSung 72 244hz'] * 1 # CPU : Intel core i9-10980XE # GPU : Nvidia RTX3090 # Memory : ['SamSung 32GB', 'SamSung 32GB'] * 2 # Disk : ['SamSung 2TB'] * 1 # Mains: Huntkey 700W # Motherboard : ROG Strix X299-E Gaming II Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-24 19:35:59 "},"Python/Python设计模式/外观模式.html":{"url":"Python/Python设计模式/外观模式.html","title":"外观模式","keywords":"","body":"基本介绍 外观模式（Facade Pattern）隐藏系统的复杂性，并向客户端提供了一个客户端可以访问系统的接口。 这种模式涉及到一个单一的类，该类提供了客户端请求的简化方法和对现有系统类方法的委托调用。 特点：为子系统中的一组接口提供一个一致的界面，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用 该模式属于结构型模式，它向现有的系统添加一个接口，来隐藏系统的复杂性。 案例图示 去医院看病，可能要去挂号、门诊、划价、取药，让患者或患者家属觉得很复杂，如果有提供接待人员，只让接待人员来处理，就很方便，当然现实中这是不可能存在的： 优缺点 优点： 减少系统相互依赖 提高灵活性 提高了安全性 缺点： 不符合开闭原则，如果要改东西很麻烦，继承重写都不合适 代码实现 用Python实现外观模式： # 行为类 class Hospital: def registered(self, name): print(\"patient : %s go to registered\" % name) def diagnosis(self, name): print(\"patient : %s go to diagnosis\" % name) def price(self, name): print(\"patient : %s go to calculating price\" % name) def getMedicine(self, name): print(\"patient : %s go to get medicine\" % name) # 外观类 class Admit: def __init__(self, name) -> None: self.name = name self.hospital = Hospital() def see_a_doctors(self): print(\"receptionist ..\") # 挂号 self.hospital.registered(self.name) # 诊断 self.hospital.diagnosis(self.name) # 计算价格 self.hospital.price(self.name) # 取药 self.hospital.getMedicine(self.name) if __name__ == \"__main__\": man = \"Ken\" hospital = Admit(man) hospital.see_a_doctors() # receptionist .. # patient : Ken go to registered # patient : Ken go to diagnosis # patient : Ken go to calculating price # patient : Ken go to get medicine Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-24 19:35:28 "},"Python/Python设计模式/代理模式.html":{"url":"Python/Python设计模式/代理模式.html","title":"代理模式","keywords":"","body":"基本介绍 在代理模式（Proxy Pattern）中，一个类代表另一个类的功能。 和适配器模式的区别：适配器模式主要改变所考虑对象的接口，而代理模式不能改变所代理类的接口。 和装饰器模式的区别：装饰器模式为了增强功能，而代理模式是为了加以控制。 特点：为其他对象提供一种代理以控制对这个对象的访问 代理模式属于结构型模式。 案例图示 买火车票不一定要去火车站买，也可以在网上买，省去了排队的环节： 优缺点 优点： 职责清晰 高扩展性 智能化 缺点： 由于在客户端和真实主题之间增加了代理对象，因此有些类型的代理模式可能会造成请求的处理速度变慢 实现代理模式需要额外的工作，有些代理模式的实现非常复杂 代码实现 用Python实现代理模式： class TrainStation: def buy_tickets(self): return \"Train ticket\" def line_up(self): print(\"Users are waiting in line ...\") class Proxy: def __init__(self): # 与火车站建立联系 self.train_station = TrainStation() def buy_tickets(self): self.__request() return self.train_station.buy_tickets() def __request(self): print(\"I am launching a ticket request to the train station ...\") if __name__ == '__main__': get_tickets = Proxy() tickets = get_tickets.buy_tickets() print(tickets) # I am launching a ticket request to the train station ... # Train ticket Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-24 12:22:52 "},"Python/Python设计模式/装饰器模式.html":{"url":"Python/Python设计模式/装饰器模式.html","title":"装饰器模式","keywords":"","body":"基本介绍 装饰器模式（Decorator Pattern）允许向一个现有的对象添加新的功能，同时又不改变其结构。 这种模式创建了一个装饰类，用来包装原有的类，并在保持类方法签名完整性的前提下，提供了额外的功能。 常用于扩展一个类的功能，同时这个新增的功能与原本的类没有任何关联，可以动态的进行撤销。 特点：动态地给一个对象添加一些额外的职责 装饰器模式属于结构型模式。 案例图示 在蜘蛛侠被蜘蛛咬之前，他只是一个普通人，但是被蜘蛛咬了之后，他具有了一些超能力。 同时，如果超能力在未来某一天没有了，他依然还是一个普通人： 优缺点 优点： 装饰类和被装饰类可以独立发展，不会相互耦合，装饰模式是继承的一个替代模式，装饰模式可以动态扩展一个实现类的功能 缺点： 多层装饰比较复杂 代码实现 用Python实现装饰器模式： # 超人（装饰类） class Superman: def __init__(self, person) -> None: self.person = person def fly(self): print(\"%s are flying\" % self.person.name) # 普通人（被装饰类） class Person: def __init__(self, name): self.name = name def eat(self): print(\"%s are eating\" % self.name) # 装饰器类 class Decorator: def __init__(self, person, superman) -> None: self.person = person self.superman = superman(self.person) def __getattr__(self,attr): try: return getattr(self.person, attr) except AttributeError: return getattr(self.superman, attr) if __name__ == \"__main__\": ken = Person(\"ken\") ken.eat() # ken.fly() parker = Decorator(Person(\"Parker\"), Superman) parker.eat() parker.fly() # ken are eating # Parker are eating # Parker are flying Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-24 13:05:34 "},"Python/Python设计模式/享元模式.html":{"url":"Python/Python设计模式/享元模式.html","title":"享元模式","keywords":"","body":"基本介绍 享元模式（Flyweight Pattern）主要用于减少创建对象的数量，以减少内存占用和提高性能。 享元模式尝试重用现有的同类对象，如果未找到匹配的对象，则创建新对象。 特点：运用共享技术有效地支持大量细粒度的对象，用HashMap存储这些对象 该模式属于结构型模式，它提供了减少对象数量从而改善应用所需的对象结构的方式。 案例图示 当大多数请求都是同一个结果，为每个请求生成一个实例的代价太高。 故只要请求的是同一个结果，我们就将已存在的实例进行返回。 举个例子，我们有一个报表系统，当第一次请求2016年度报表时会生成并存储该报表，以后再次请求2016年度报表时都不会重复生成该报表而是通过查询直接返回。 优缺点 优点： 大大减少对象的创建 降低系统的内存 缺点： 提高了系统的复杂度，需要分离出外部状态和内部状态，而且外部状态具有固有化的性质，不应该随着内部状态的变化而变化，否则会造成系统的混乱 代码实现 用Python实现享元模式： # 报表系统 class Report: def __init__(self, year) -> None: self.year = year self.desc = \"%s report\" % year # 请求报表（享元） class RequestReport: def __init__(self) -> None: self.savaMap = {} def getReport(self, year): if not self.savaMap.get(year): print(\"generated report\") newReport = Report(year) self.savaMap[year] = newReport return self.savaMap[year] if __name__ == \"__main__\": client = RequestReport() report = client.getReport(2016) print(report.desc) # 仅生成一次 report = client.getReport(2016) print(report.desc) # generated report # 2016 report # 2016 report Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-24 19:35:38 "},"Python/Python设计模式/责任链模式.html":{"url":"Python/Python设计模式/责任链模式.html","title":"责任链模式","keywords":"","body":"基本介绍 责任链模式（Chain of Responsibility Pattern）为请求创建了一个接收者对象的链。 在这种模式中，通常每个接收者都包含对另一个接收者的引用。如果一个对象不能处理该请求，那么它会把相同的请求传给下一个接收者，依此类推（亦可反之，一个处理了给下一个，直到处理完毕或其中一个不再进行处理）。 特点：避免请求发送者与接收者耦合在一起，让多个对象都有可能接收请求，将这些对象连接成一条链，并且沿着这条链传递请求，直到有对象处理它为止 该模式属于行为型模式。 案例图示 这里有3种等级的日志，info、warning、error。 它们的优先级是：info info日志只处理info级别的，如果碰见warning或者error级别日志则向上传递，如果碰见info级别的则直接处理并返回，不再向上传递。 整个记录过程是一个链式的顺序，如图所示： 优缺点 优点： 降低耦合度，一个请求将被分为接收者和发送者 简化了对象，使得对象不需要知道链的结构 增强给对象指派职责的灵活性。通过改变链内的成员或者调动它们的次序，允许动态地新增或者删除责任 增加新的请求处理类很方便 缺点： 不能保证请求一定被接收 系统性能将受到一定影响，而且在进行代码调试时不太方便，可能会造成循环调用 可能不容易观察运行时的特征，有碍于除错 代码实现 用Python实现责任链模式： import datetime class LevelBase: def write(self, logName, message): print(\"%s:[%s]:[%s] -- %s\" % (logName, datetime.datetime.now(), self.__class__.__name__.upper(), message)) class Error(LevelBase): pass class Warning(LevelBase): pass class Info(LevelBase): pass class Logger: # 建立等级关系 logLevel = (Info(), Warning(), Error()) def __init__(self, logName) -> None: self.logName = logName def write(self, level, message): for ins in __class__.logLevel: if level.upper() == ins.__class__.__name__.upper(): ins.write(self.logName, message) break else: raise ValueError(\"don't have level %s\" % level) if __name__ == \"__main__\": log = Logger(\"Yunya\") log.write(\"error\", \"this is error message\") log.write(\"info\", \"this is info message\") # Yunya:[2021-06-24 19:59:52.958078]:[ERROR] -- this is error message # Yunya:[2021-06-24 19:59:52.958136]:[INFO] -- this is info message Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-24 20:01:17 "},"Python/Python设计模式/解释器模式.html":{"url":"Python/Python设计模式/解释器模式.html","title":"解释器模式","keywords":"","body":"基本介绍 解释器模式（Interpreter Pattern）提供了评估语言的语法或表达式的方式。 这种模式实现了一个表达式接口，该接口解释一个特定的上下文，常被用在 SQL 解析、符号处理引擎等。 特点：给定一个语言，定义它的文法表示，并定义一个解释器，这个解释器使用对应文法来解释语言中的语句 该模式属于行为型模式。 案例图示 使用解释器模式，创建一门新的语言，例如 A是B，B是C，C是D… 可用于加密的工程上： 优缺点 优点： 可扩展性比较好，灵活 增加了新的解释表达式的方式 易于实现简单文法 缺点： 可利用场景比较少 对于复杂的文法比较难维护 代码实现 用Python实现解释器模式： # 密文 class Code: def __init__(self, content) -> None: self.content = content # 解释器 class Interpreter: # 定义文法 grammar = { \"a\" : \"b\", \"b\" : \"c\", \"c\" : \"d\" } def run(self, document): content = document.content result = \"\" for ch in content: result += __class__.grammar[ch] return result if __name__ == \"__main__\": document = Code(\"abc\") result = Interpreter().run(document) print(result) # bcd Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-24 20:13:36 "},"Python/Python设计模式/迭代器模式.html":{"url":"Python/Python设计模式/迭代器模式.html","title":"迭代器模式","keywords":"","body":"基本介绍 迭代器模式（Iterator Pattern）是 Java 和 .Net 编程环境中非常常用的设计模式。 这种模式用于顺序访问集合对象的元素，而不需要知道集合对象的底层表示。 特点：提供一种方法顺序访问一个聚合对象中各个元素，而又无须暴露该对象的内部表示 迭代器模式属于行为型模式。 案例图示 一个对象内部的数据存储结构并不能被直接获取到，而是通过迭代器进行获取。 Python本身已经实现了迭代器模式，只需要重写对象中的__iter__()方法和__next__()方法即可。 优缺点 优点： 支持以不同的方式遍历一个聚合对象 迭代器简化了聚合类 在同一个聚合上可以有多个遍历 缺点： 由于迭代器模式将存储数据和遍历数据的职责分离，增加新的聚合类需要对应增加新的迭代器类，类的个数成对增加，这在一定程度上增加了系统的复杂性 代码实现 用Python实现迭代器模式，迭代一个二叉树对象： # 可迭代对象 class BinaryTree: def __init__(self, root): self.key = root self.leftChild = None self.rightChild = None self.height = 0 def insertLeft(self, newNode): tree = BinaryTree(newNode) if not self.leftChild: self.leftChild = tree else: # 如果插入位置已有节点，则整体向下挪 # 新的子节点与旧的子节点链接，旧的父节点与新的子节点链接 tree.leftChild = self.leftChild self.leftChild = tree self.height += 1 def insertRight(self, newNode): tree = BinaryTree(newNode) if not self.rightChild: self.rightChild = tree else: tree.rightChild = self.rightChild self.rightChild = tree self.height += 1 def getRightChild(self): return self.rightChild def getLeftChild(self): return self.leftChild def setRootVal(self, obj): self.key = obj def getRootVal(self): return self.key def __iter__(self): return TreeIterator(tree=self) def __str__(self): return \"\"%self.getRootVal() # 迭代器 class TreeIterator: def __init__(self, tree) -> None: self.tree = tree self.treeLst = [self.tree] def __iter__(self): return self def __next__(self): # 采用层级遍历 while len(self.treeLst) > 0: node = self.treeLst.pop(0) if node.leftChild: self.treeLst.append(node.getLeftChild()) if node.rightChild: self.treeLst.append(node.getRightChild()) return node raise StopIteration(\"Tree iter end\") if __name__ == '__main__': binaryTree = BinaryTree(\"a\") binaryTree.insertLeft(\"b\") binaryTree.insertRight(\"c\") binaryTree.leftChild.insertLeft(\"d\") binaryTree.leftChild.insertRight(\"e\") binaryTree.rightChild.insertLeft(\"f\") for node in binaryTree: print(node) # # # # # # Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-25 14:12:43 "},"Python/Python设计模式/观察者模式.html":{"url":"Python/Python设计模式/观察者模式.html","title":"观察者模式","keywords":"","body":"基本介绍 观察者模式（Observer Pattern）常用于一对多关系依赖中，当某个对象发生改变后，其他对象也会做出相应的调整策略。 特点：定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新 观察者模式也被称为发布订阅模式，属于行为型模式的一种。 案例图示 当客户减少到阀值时，销售通知工厂减少生产、人力资源开始裁人，反之则增加： 优缺点 优点： 观察者和被观察者是抽象耦合的 建立一套触发机制 缺点： 如果一个被观察者对象有很多的直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间 如果在观察者和观察目标之间有循环依赖的话，观察目标会触发它们之间进行循环调用，可能导致系统崩溃 观察者模式没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的，而仅仅只是知道观察目标发生了变化 代码实现 用Python实现观察者模式： # 观察者：销售部门 # 被观察者：客户资源（SalesInstanceObject._customer） # 通知对象：工厂、人事部门 class Sales: \"\"\"销售部门\"\"\" def __init__(self): # 被观察对象 self._customer = None self._department = [] @property def customer(self): return self._customer @customer.setter def customer(self, value): self._customer = value print('当前客户数量:{}'.format(self._customer)) for obj in self._department: obj.change(value) print('------------------') def notice(self, department): \"\"\"相关部门\"\"\" self._department.append(department) class Hr: \"\"\"人事部门\"\"\" def change(self, value): if value 20: print(\"人事变动：扩员\") else: print(\"人事不受影响\") class Factory: \"\"\"工厂类\"\"\" def change(self, value): if value 25: print(\"生产计划变动：增产\") else: print(\"生产计划保持不变\") if __name__ == '__main__': sales = Sales() hr = Hr() factory = Factory() # 部门关联 sales.notice(hr) sales.notice(factory) # 客户变动 sales.customer = 10 sales.customer = 15 sales.customer = 20 sales.customer = 25 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-25 14:26:07 "},"Python/Python设计模式/中介者模式.html":{"url":"Python/Python设计模式/中介者模式.html","title":"中介者模式","keywords":"","body":"基本介绍 中介者模式（Mediator Pattern）是用来降低多个对象和类之间的通信复杂性。 这种模式提供了一个中介类，中介类来处理不同类之间的通信，并支持松耦合，使代码易于维护。 也就是说，消费者和生产者不直接接触，而是通过中介者来建立联系。 比如MVC 框架中C（控制器）就是 M（模型）和 V（视图）的中介者。 特点：用一个中介对象来封装一系列的对象交互，中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互 中介者模式属于行为型模式。 案例图示 生产者生成各类产品，中介者购买生产者的产品再转卖给消费者，生产者和消费者不直接进行接触： 优缺点 优点： 降低了类的复杂度，将一对多转化成了一对一 各个类之间的解耦 符合迪米特原则 缺点： 中介者会随着业务不断增长而变的庞大，这样的后果是中介者代码复杂且难以维护 代码实现 用Python实现中介者模式： class Consumer: \"\"\"消费者类\"\"\" def __init__(self, product, price): self.name = \"消费者\" self.product = product self.price = price def shopping(self, name): \"\"\"买东西\"\"\" print(\"向{} 购买 {}价格内的 {}产品\".format(name, self.price, self.product)) class Producer: \"\"\"生产者类\"\"\" def __init__(self, product, price): self.name = \"生产者\" self.product = product self.price = price def sale(self, name): \"\"\"卖东西\"\"\" print(\"向{} 销售 {}价格的 {}产品\".format(name, self.price, self.product)) class Mediator: \"\"\"中介者类\"\"\" def __init__(self): self.name = \"中介者\" self.consumer = None self.producer = None def sale(self): \"\"\"进货\"\"\" self.consumer.shopping(self.producer.name) def shopping(self): \"\"\"出货\"\"\" self.producer.sale(self.consumer.name) def profit(self): \"\"\"利润\"\"\" print('中介净赚：{}'.format((self.consumer.price - self.producer.price))) def complete(self): self.sale() self.shopping() self.profit() if __name__ == '__main__': consumer = Consumer('手机', 3000) producer = Producer(\"手机\", 2500) mediator = Mediator() mediator.consumer = consumer mediator.producer = producer mediator.complete() # 向生产者 购买 3000价格内的 手机产品 # 向消费者 销售 2500价格的 手机产品 # 中介净赚：500 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-25 14:33:04 "},"Python/Python设计模式/访问者模式.html":{"url":"Python/Python设计模式/访问者模式.html","title":"访问者模式","keywords":"","body":"基本介绍 访问者模式（Visitor Pattern）可以让多个处理对象对同一个数据对象做出不同的反应，但并不会改变被访问的数据对象。 特点：主要将数据结构与数据操作分离 访问者模式应该是所有模式中最抽象、最难以理解的一个。 该模式属于行为型模式。 案例图示 上市公司的原始财务数据，对于会计来说需要制作各种报表，对于财务总监来说需要分析公司业绩，对于战略顾问来说需要分析行业变化。 它们总是对同一份数据进行访问，但是获得的结果都是不同的： 优缺点 优点： 符合单一职责原则 优秀的扩展性 灵活性 缺点： 具体元素对访问者公布细节，违反了迪米特原则 具体元素变更比较困难 违反了依赖倒置原则，依赖了具体类，没有依赖抽象 代码实现 用Python实现访问者模式： class Finance: \"\"\"财务数据结构类\"\"\" def __init__(self): # 销售额 self.salesvolume = None # 成本 self.cost = None # 历史销售额 self.history_salesvolume = None # 历史成本 self.history_cost = None def set_salesvolume(self, value): self.salesvolume = value def set_cost(self, value): self.cost = value def set_history_salesvolume(self, value): self.history_salesvolume = value def set_history_cost(self, value): self.history_cost = value def accept(self, visitor): pass class Finance_year(Finance): \"\"\"2018年财务数据类\"\"\" def __init__(self, year): Finance.__init__(self) self.work = [] # 安排工作人员列表 self.year = year def add_work(self, work): self.work.append(work) def accept(self): for obj in self.work: obj.visit(self) class Accounting: \"\"\"会计类\"\"\" def __init__(self): self.ID = \"会计\" self.Duty = \"计算报表\" def visit(self, table): print('会计年度： {}'.format(table.year)) print(\"我的身份是： {} 职责： {}\".format(self.ID, self.Duty)) print('本年度纯利润： {}'.format(table.salesvolume - table.cost)) print('------------------') class Audit: \"\"\"财务总监类\"\"\" def __init__(self): self.ID = \"财务总监\" self.Duty = \"分析业绩\" def visit(self, table): print('会计总监年度： {}'.format(table.year)) print(\"我的身份是： {} 职责： {}\".format(self.ID, self.Duty)) if table.salesvolume - table.cost > table.history_salesvolume - table.history_cost: msg = \"较同期上涨\" else: msg = \"较同期下跌\" print('本年度公司业绩： {}'.format(msg)) print('------------------') class Adviser: \"\"\"战略顾问\"\"\" def __init__(self): self.ID = \"战略顾问\" self.Duty = \"制定明年战略\" def visit(self, table): print('战略顾问年度： {}'.format(table.year)) print(\"我的身份是： {} 职责： {}\".format(self.ID, self.Duty)) if table.salesvolume > table.history_salesvolume: msg = \"行业上行，扩大生产规模\" else: msg = \"行业下行，减小生产规模\" print('本年度公司业绩： {}'.format(msg)) print('------------------') class Work: \"\"\"工作类\"\"\" def __init__(self): self.works = [] # 需要处理的年度数据列表 def add_work(self, obj): self.works.append(obj) def remove_work(self, obj): self.works.remove(obj) def visit(self): for obj in self.works: obj.accept() if __name__ == '__main__': work = Work() # 计划安排财务、总监、顾问对2018年数据处理 # 实例化2018年数据结构 finance_2018 = Finance_year(2018) finance_2018.set_salesvolume(200) finance_2018.set_cost(100) finance_2018.set_history_salesvolume(180) finance_2018.set_history_cost(90) # 实例化会计 accounting = Accounting() # 实例化总监 audit = Audit() # 实例化总监 adviser = Adviser() # 会计安排到2018分析日程中 finance_2018.add_work(accounting) finance_2018.add_work(audit) # 顾问安排到2018分析日程中 finance_2018.add_work(adviser) # 添加2018年财务工作安排 work.add_work(finance_2018) work.visit() # 会计年度： 2018 # 我的身份是： 会计 职责： 计算报表 # 本年度纯利润： 100 # ------------------ # 会计总监年度： 2018 # 我的身份是： 财务总监 职责： 分析业绩 # 本年度公司业绩： 较同期上涨 # ------------------ # 战略顾问年度： 2018 # 我的身份是： 战略顾问 职责： 制定明年战略 # 本年度公司业绩： 行业上行，扩大生产规模 # ------------------ Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-25 16:40:22 "},"Python/Python设计模式/备忘录模式.html":{"url":"Python/Python设计模式/备忘录模式.html","title":"备忘录模式","keywords":"","body":"基本介绍 备忘录模式（Memento Pattern）用于保存一个对象的某个状态，以便在适当的时候恢复对象。 特点：不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态 备忘录模式属于行为型模式。 案例图示 游戏有存档和删档的功能，当我们进行到某一关时便可对游戏进行存档，下次进入游戏后按照上次的存档位置继续游戏： 优缺点 优点： 给用户提供了一种可以恢复状态的机制，可以使用户能够比较方便地回到某个历史的状态 实现了信息的封装，使得用户不需要关心状态的保存细节 缺点： 消耗资源。如果类的成员变量过多，势必会占用比较大的资源，而且每一次保存都会消耗一定的内存 代码实现 用Python实现备忘录模式： import copy class AddNumber: def __init__(self): self.start = 0 def add(self, number): self.start = number class Memento: \"\"\"备忘录\"\"\" def backups(self, obj=None): \"\"\" 设置备份方法 :param obj: :return: \"\"\" self.obj_dict = copy.deepcopy(obj.__dict__) print(\"备份数据:{}\".format(self.obj_dict)) def recovery(self, obj): \"\"\" 恢复备份方法 :param obj: :return: \"\"\" obj.__dict__.clear() obj.__dict__.update(self.obj_dict) print(\"恢复数据:{}\".format(self.obj_dict)) return obj if __name__ == '__main__': test = AddNumber() memento = Memento() for i in [1, 2, 3, 4, 5]: if i == 2: memento.backups(test) test.add(i) print(\"当前数据:{}\".format(test.start)) memento.recovery(test) print(test.start) # 备份数据:{'start': 1} # 当前数据:5 # 恢复数据:{'start': 1} # 1 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-25 16:52:34 "},"Python/Python设计模式/命令模式.html":{"url":"Python/Python设计模式/命令模式.html","title":"命令模式","keywords":"","body":"基本介绍 命令模式（Command Pattern）是一种数据驱动的设计模式，它将请求以命令的形式包裹在对象中，并传给调用对象。 调用对象寻找可以处理该命令的合适的对象，并把该命令传给相应的对象，该对象执行命令。 特点：将一个请求封装成一个对象，从而使您可以用不同的请求对客户进行参数化 该模式属于行为型模式。 案例图示 命令模式应该有一下几个角色： 1）Command： 定义命令的接口，声明执行的方法，可以理解为一个基类。 2）ConcreteCommand： 命令接口实现对象，通常会持有接收者，并调用接收者的功能来完成命令要执行的操作。 3）Receiver： 接收者，真正执行命令的对象。任何类都可能成为一个接收者，只要它能够实现命令要求实现的相应功能。 4）Invoker： 要求命令对象执行请求，通常会持有命令对象，可以持有很多的命令对象，相当于使用命令对象的入口。 5）Client： 创建具体的命令对象，组装命令对象和接收者，或许，把这个Client称为装配者会更好理解，因为真正使用命令的客户端是从Invoker来触发执行。 优缺点 优点： 降低了系统耦合度 新的命令可以很容易添加到系统中去 缺点： 使用命令模式可能会导致某些系统有过多的具体命令类 代码实现 用Python实现命令模式： class Command: \"\"\"声明命令模式接口\"\"\" def __init__(self, obj): self.obj = obj def execute(self): pass class ConcreteCommand(Command): \"\"\"实现命令模式接口\"\"\" def execute(self): self.obj.run() class Invoker: \"\"\"接受命令并执行命令的接口\"\"\" def __init__(self): self._commands = [] def add_command(self, cmd): self._commands.append(cmd) def remove_command(self, cmd): self._commands.remove(cmd) def run_command(self): for cmd in self._commands: cmd.execute() class Receiver: \"\"\"具体动作\"\"\" def __init__(self, word): self.word = word def run(self): print(self.word) def client(): \"\"\"装配者\"\"\" test = Invoker() cmd1 = ConcreteCommand(Receiver('命令一')) test.add_command(cmd1) cmd2 = ConcreteCommand(Receiver('命令二')) test.add_command(cmd2) cmd3 = ConcreteCommand(Receiver('命令三')) test.add_command(cmd3) test.run_command() if __name__ == '__main__': client() # 命令一 # 命令二 # 命令三 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-25 16:55:48 "},"Python/Python设计模式/状态模式.html":{"url":"Python/Python设计模式/状态模式.html","title":"状态模式","keywords":"","body":"基本介绍 状态模式（State Pattern）是指当对象的内部状态改变的时候，允许对象执行不同的流程，这样看起来就像改写了一个对象。 核心的方法是把复杂状态变化情况下的流程抽象出来，简化复杂情况状态的判断。 特点：允许对象在内部状态发生改变时改变它的行为，对象看起来好像修改了它的类 案例图示 定义一个运维脚本，用于监控CPU使用率状态，在不同状态下的自动化运维脚本执行不同的操作： 优缺点 优点： 封装了转换规则 枚举可能的状态，在枚举状态之前需要确定状态种类 将所有与某个状态有关的行为放到一个类中，并且可以方便地增加新的状态，只需要改变对象状态即可改变对象的行为 允许状态转换逻辑与状态对象合成一体，而不是某一个巨大的条件语句块 可以让多个环境对象共享一个状态对象，从而减少系统中对象的个数 缺点： 状态模式的使用必然会增加系统类和对象的个数 状态模式的结构与实现都较为复杂，如果使用不当将导致程序结构和代码的混乱 状态模式对\"开闭原则\"的支持并不太好，对于可以切换状态的状态模式，增加新的状态类需要修改那些负责状态转换的源代码，否则无法切换到新增状态，而且修改某个状态类的行为也需修改对应类的源代码 代码实现 用Python实现状态模式： class Base: def executor(self, value): self.run(value) class Low(Base): def __init__(self): self.name = \"较低占用率状态\" def run(self, value): print(\"当前：{} 值:{}\".format(self.name, value)) print(\"无应急情况执行\") class Large(Base): def __init__(self): self.name = \"较高占用率状态\" def run(self, value): print(\"当前：{} 值：{}\".format(self.name, value)) print(\"发送警报邮件\") class Status: def __init__(self): self.value = 0.1 self.low = Low() self.large = Large() self.status = None def monitor(self): if self.value Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-25 17:00:58 "},"Python/Python设计模式/策略模式.html":{"url":"Python/Python设计模式/策略模式.html","title":"策略模式","keywords":"","body":"基本介绍 策略模式（Strategy Pattern）中，一个类的行为或其算法可以在运行时更改。 也就是说该类在不同的环境下，能够调用不同的策略算法。 特点：定义一系列的算法，把它们一个个封装起来, 并且使它们可相互替换 该模式属于行为型模式。 案例图示 如一个人旅游时，当他身在不同的国家中便要说不同的语言： 优缺点 优点： 算法可以自由切换 避免使用多重条件判断 扩展性良好 缺点： 策略类会增多 所有策略类都需要对外暴露 代码实现 用Python实现策略模式： # 人 class People(object): def __init__(self): self.strategy = {} def get_strategy(self, location): strategy = self.strategy.get(location) if strategy: return strategy() else: raise AttributeError(\"不会这个位置的语言\") def register_strategy(self, location, strategy): self.strategy[location] = strategy # 策略类 class Strategy(object): @staticmethod def speak_english(): return \"说英文\" @staticmethod def speak_chinese(): return \"说中文\" # 位置 class Location(object): def __init__(self, location): self.location = location if __name__ == '__main__': person = People() location = Location(\"美国\") # 注册地理位置的策略 person.register_strategy(location.location, Strategy.speak_english) # 获取在美国的策略 print(person.get_strategy(\"美国\")) location = Location(\"中国\") # 注册地理位置的策略 person.register_strategy(location.location, Strategy.speak_chinese) # 获取在中国的策略 print(person.get_strategy(\"中国\")) # 说英文 # 说中文 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-25 17:07:47 "},"Python/Python设计模式/模板模式.html":{"url":"Python/Python设计模式/模板模式.html","title":"模板模式","keywords":"","body":"基本介绍 在模板模式（Template Pattern）中，一个抽象类公开定义了执行它方法的模板。 它的子类可以按需要重写方法实现，但调用将以抽象类中定义的方式进行。 特点：在有一些通用方法都需要使用时，可将其定义为模板 该模式属于行为型模式。 案例图示 如图所示，为同一个模板传入不同的参数会得到不同的结果： 优缺点 优点： 封装不变部分，扩展可变部分 提取公共代码，便于维护 行为由父类控制，子类实现 缺点： 每一个不同的实现都需要一个子类来实现，导致类的个数增加，使得系统更加庞大 代码实现 用Python实现模板模式，实现一个客户点单后的处理流程流程： class User: def __init__(self, name, shop, times, number): self.name = name self.shop = shop self.times = times self.number = number class Handle: def __init__(self, user=None): self.user = user def Invoicen(self): \"\"\"打印小票\"\"\" string = \"打印小票\\n\" \\ \"客户：{} \" \\ \"商品：{} \" \\ \"数量：{} \" \\ \"时间：{} \".format(self.user.name, self.user.shop, self.user.number, self.user.times) print(string) def Make(self): \"\"\"开始制作\"\"\" print(\"制作完成：{} 数量：{}\".format(self.user.shop, self.user.number)) def run(self): self.Invoicen() self.Make() if __name__ == '__main__': test = Handle() xiaoming = User(\"小明\", \"汉堡\", \"17:50\", \"5\") test.user = xiaoming test.run() # 打印小票 # 客户：小明 商品：汉堡 数量：5 时间：17:50 # 制作完成：汉堡 数量：5 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-25 17:16:10 "},"Python/Python网络编程/summary.html":{"url":"Python/Python网络编程/summary.html","title":"Python网络编程","keywords":"","body":" socket编程 TCP粘包 socketserver使用 socketserver源码 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-29 20:56:50 "},"Python/Python网络编程/socket编程.html":{"url":"Python/Python网络编程/socket编程.html","title":"socket编程","keywords":"","body":"前瞻知识 C/S架构 C/S架构是一种由服务端（Server）和客户端（Client）组成的双层架构。 互联网中处处充满了C/S架构（Client/Server），比如我们需要玩英雄联盟，就必须连接至英雄联盟的服务器上，那么对于我们玩家来说它的英雄联盟服务器就是Server端，而我们必须要下载一个英雄联盟Client端才能够去和英雄联盟Server端进行数据交互。 五层协议 互联网的协议实际上就是为了让计算机之间互相进行通信而产生的，本身并没有层级之分。 为了便于理解，我们可以按照功能将它们划分成5层或者7层，如下表所示： 层级 功能 相关协议 应用层 用于规定应用数据的格式，提供给各个应用程序以便于彼此之间进行通信 HTTP、FTP 传输层 用于区分该系统上的唯一一个网络应用程序 TCP、UDP 网络层 用于区分广播域，防止网络风暴的发生 IP 数据链路层 用于划分电信号以及提供IP地址和MAC地址相互转换的功能 以太网协议、ARP协议 物理层 用于传输电信号，它是网络传输数据的基石 socket抽象层 计算机网络的核心就是一堆协议，想开发基于网络通信的软件就必须遵守这些协议。 但是由于学习协议的代价巨大，故我们需要一种高度抽象的中间层来承上启下便于我们进行快速开发。 此时，socket产生了，socket位于应用层和传输层之间，它向下封装了各种协议，用户只需要通过socket提供的接口就能快速的开发出基于网络通信的软件，而并不需要深入的去研究某些底层协议，如TCP、UDP等。 为什么要学习socket呢？因为它是各种与网络沾边的应用框架的底层实现，如Django、requests等只要与网络有关系的框架或模块都离不开socket。 TCP协议简述 流式传输 TCP协议是一种基于字节流的形式，什么叫流呢？因为数据的传输就像是水龙头一样打开哗啦啦的没有确切的边界，如下图所示： 三次握手 Client端和Server端若想正常进行数据交互，必须先经历一次三次握手的过程，用于确定二者关系并建立双向链接通道： 状态释义，可通过netstat命令查看： SYN_SENT：Client端发送一次建立链接请求后会立刻进入该状态，并且在没有收到Server端的回应之前都会保持该状态，通常来说该状态持续时间非常短，几乎不可测 ESTABLISHED：当某一方进入该状态后，则代表可以向另一方发送数据了 LISTEN：Server端在等待Client端建立三次握手时的状态，即监听Client端的请求 SYN_RCVD：Server端进入该状态代表已收到Client端的三次握手链接请求 信息释义： SYN：用于建立链接的标志位 ACK：确认请求的标志位 seq：可以理解为一段暗号，用于确认该信息未被修改 补充，SYN泛洪攻击： 当Server端长期进入SYN_RCVD状态时就要当心是否遭受了SYN洪水攻击。 因为TCP三次握手对于Server端来讲会无限的回复Client端发来的SYN请求，收到一条就回一条。 如果有黑客模拟成千上万台Client端对Server端发起SYN请求，在发送第一次握手后就溜溜球了那么服务器还傻乎乎的等待第三次的握手回信，这么做会让Server端的压力很大。所以TCP协议也被称为好人协议... 补充，半链接池backlog： Server端如果不能一时之间全部处理完成所有的请求时会将后到的请求放入半链接池中进行排队 防止SYN 洪水攻击的有效策略其中一点就是：增大backlog链接池的最大数量，但是一般不会采用该策略 另一个策略是缩小Server端对每个请求的返回次数（如果Server端发现Client端没理自己，就会不断的回应上次的信息。初始值为5s，过5s发一次，然后变成3s，再过3s发一次，变成1s，再发一次...直到不想发了就不会理睬这个请求了） 平常打开一个网页打不开的时候，有一种可能性就是人家的backlog满了，你就只能排在外边儿等 双向链接通道 当Client端和Server端三次握手完成后，TCP协议会创建一个双向链接通道，用于Client端和Server端之间的数据交互，如图所示： 可靠传输 TCP协议也被称为可靠传输协议，即发送方向接收方发送了数据后，接收方必须回应发送方一个收到了的信息的ACK确认，若发送方没收到该ACK确认，则会重新发送一次数据，如下图所示。 注意：三次握手时的数据交互并不是走双向链接通道，而对于下图的数据传输来说则是走的双向链接通道了 四次挥手 当Client端要断开与Server端的链接时，必须要经历一个四次挥手的过程。 为什么创建链接仅需要三次，而断开链接则需要四次呢？ 可以看到，三次握手之前是没有数据传输的，并且其中第二次是一次性发送了一个请求和一个确认。所以减少了一次操作。 而四次挥手涉及到数据的传输，所以不可能简化成三次挥手。 此外，四次挥手也是不同于三次握手，四次挥手也是建立在双向链接通道的基础之上的，而三次握手的时候该双向通道还未建立成功： 状态释义： FIN_WAIT_1：代表主动发起断开链接请求 FIN_WAIT_2：代表此时的Client端不会再主动向Server端发送数据 TIME_WAIT：代表Client端还要回复最后一条确认消息，回复完毕后双向链接正式关闭 CLOSE_WAIT：代表关闭等待 LAST_ACK：代表持续的确认（即只要Client端没有回复第4条信息，Server端就不断尝试发送断开链接的FIN请求） 另外，在实际生活场景中，服务端主动断开链接的情况比较多，因为它涉及到了和很多客户端的通信，还有的客户端还在排队，所以不可能对一个客户端浪费太多时间。 这句话你可以理解为： 服务器是个渣男 ，很多女孩子（Client端）都喜欢他，都给他写情书，他回复完了一个女孩子的情书后立马会拆开下一封情书，并不会只留恋于一封。 UDP协议简述 数据报传输 UDP协议是一种基于数据报的格式（也被称为基于消息的传输），不同于TCP的字节流格式。UDP的数据报格式是有头有尾的，这一点很重要。 如图所示： 不可靠传输 UDP协议在数据传输时并不需要建立双向链接通道。 且UDP发消息与TCP不太一样，发送发只管发送消息，不管接收方有没有收到消息都不会再发，所以这也是UDP协议被称为不可靠传输协议的由来。 因为UDP协议没有这种ACK确认的机制，虽然对于数据可靠性来说下降了不少但是对于数据传输性上则有了明显的提示。 故DHCP服务以及DNS域名解析服务都是使用UDP协议，因为它速度更快，此外早起的QQ也是使用的UDP协议进行通信。 套接字发展史 套接字起源 套接字起源于20世纪70年代加利福尼亚大学伯克利分校版本的Unix，它最初的设计是为了让同一台主机上的多个应用程序之间进行通信，也就是进程通信或者被称为IPC，套接字有两种： 基于文件的套接字 基于网络的套接字 同机的不同进程之间本身是不允许通信的，但是可以通过套接字来进行数据交互。 此外，套接字也允许应用程序将I/O（input / output）插入到网络中，并与网络中的其他应用程序进行通信，基于网络的套接字就是IP地址加端口的组合。 故socket也被称为：IP+PORT。 基于文件的套接字家族 名称：AF_UNIX 作用：Unix一切皆文件，基于文件的套接字调用的就是底层的文件系统来存取数据，两个套接字进程运行在同一台机器上，可以通过访问同一个文件系统间接完成通信。 基于网络的套接字家族 名称：AF_INET 作用：IPV4协议套接字，有了IP + PORT我们可以与互联网上的任何应用程序进行通信。 除此之外还有一个叫AF_INET6的套接字，也就是基于IPV6的套接字。 套接字工作流程 基于TCP协议的套接字工作流程 由于TCP协议本身比较复杂，故使用基于TCP协议的套接字编写程序整体流程也较为复杂： 基于UDP协议的套接字工作流程 基于UDP协议的套接字工作流程相比于基于TCP协议的套接字工作流程来说简单一些，因为不用建立双向链接通道： TCP/Socket简单通信 基础实现 由于TCP协议需要建立双向链接通道，故必须先开启Server端后再开启Client端，否则会发生异常。 Server端代码如下： from socket import * # 1. 实例化socket对象，并添加端口复用 # AF_INET：IPV4 # SOCK_STREAM：TCP协议 server = socket(family=AF_INET, type=SOCK_STREAM) server.setsockopt(SOL_SOCKET, SO_REUSEADDR, 1) # 2.绑定IP地址与端口号 # localhost：仅允许本机使用 # 127.0.0.1：仅允许本机使用 # 0.0.0.0：允许任意client链接 server.bind((\"localhost\", 8888)) # 3.设置半链接池大小 server.listen(5) # 4.阻塞等待三次握手请求 # conn：双向链接通道 # clientAddr：客户端链接信息 conn, clientAddr = server.accept() # 5.接收client发送的信息，单位：字节 data = conn.recv(1024) # 6.给client发送信息 conn.send(data.upper()) # 7.关闭双向链接通道，释放底层端口占用的系统资源 conn.close() # 8.关闭服务器，释放Python应用程序所占据的内存资源 server.close() Client端代码如下： from socket import * # 1. 实例化socket对象 # AF_INET：IPV4 # SOCK_STREAM：TCP协议 client = socket(family=AF_INET, type=SOCK_STREAM) # 2.向服务端发送请求 # 开始进行三次握手并创建双向链接通道 client.connect((\"localhost\", 8888)) # 3.通信开始，发送消息 client.send(\"hello world\".encode(\"u8\")) # 4.接收server端的消息 msg = client.recv(1024) print(msg.decode(\"u8\")) # 5.关闭客户端 client.close() 双层循环 上面的例子中，Server端会接受Client端的信息，并将其进行upper()后返回。 也就是说Server端和Client端的交互仅有一次，这显然不符合常理。 所以我们需要为Server端的代码做一些小小的改动，让其能够不断的处理Client端的请求，而非只处理一次。 具体逻辑是： 增加链接循环，接收不同Client端的三次握手请求 增加通信循环，让Client端和Server端能够长时间通信 Server端代码如下所示： from socket import * server = socket(family=AF_INET, type=SOCK_STREAM) server.setsockopt(SOL_SOCKET, SO_REUSEADDR, 1) server.bind((\"localhost\", 8888)) server.listen(5) while 1: # 不断接受新请求， 即服务端永不停止运（链接循环） conn, clientAddr = server.accept() print(\"%s connect server\" % clientAddr[0]) # 服务端能一直保持和客户端的通信，当客户端输入exit后将停止对当前客户端的服务（通信循环） while 1: data = conn.recv(1024) if data.decode(\"u8\") == \"exit\": break conn.send(data.upper()) print(\"%s close connect\" % clientAddr[0]) conn.close() Client端代码如下所示： from socket import * client = socket(family=AF_INET, type=SOCK_STREAM) client.connect((\"localhost\", 8888)) # 不断的与服务器进行交互 while 1: sendMsg = input(\">>>\") client.send(sendMsg.encode(\"u8\")) # 如果发送的是exit，则断开链接 if sendMsg == \"exit\": break recvMsg = client.recv(1024) print(recvMsg.decode(\"u8\")) print(\"client close\") client.close() Client端发送空信息导致的异常 现在Server端已经全部做好了，但是Client端还有一个问题。 当Client端出现 >>> 时直接敲击回车后会Server端会卡住，只有重启Server端才能解决该问题。 若进行代码调试，可观察到此时Client端处于recv()状态，而Server端也处于recv()状态，这代表Client端发送的回车“空消息”根本没有被Server端所接收到。 为什么会出现这样的情况？还需要从底层原理说起。 其实不管是send()还是recv()都是socket应用程序对操作系统发出的一次系统调用，再此期间CPU工作状态会从用户态转变至内核态。 而用户态的内存数据是不能直接与内核态的内存数据发生交互的，所以只能靠一种映射关系（可以理解为拷贝，但是并不准确）来映射出需要发送的内容。 如果Client端输入一个回车，且发送给了Server端后，Server端是接收不到该信息的，因为recv()的映射是读取不到“空消息”的： Client端将自己的回车“空消息”进行发送 Server端的recv()由于读取不到“空消息”，故会直接卡住 如下图所示： 如果要解决这个问题，我们只需对Client端发送的消息做出限制，让其不为空即可： from socket import * client = socket(family=AF_INET, type=SOCK_STREAM) client.connect((\"localhost\", 8888)) # 不断的与服务器进行交互 while 1: sendMsg = input(\">>>\") # 不让客户端发送空消息 if not sendMsg: continue client.send(sendMsg.encode(\"u8\")) recvMsg = client.recv(1024) print(recvMsg.decode(\"u8\")) # 如果发送的是exit，则断开链接 if sendMsg == \"exit\": break print(\"client close\") client.close() 强行关闭Client端导致的异常 当Server端正在与Client端链接时，如果此时强行关闭Client端，将会导致Server端出现异常。 Windows平台下Server端会直接抛出ConnectionResetError异常 Unix平台下Server端的recv()会无限制收到空信息 如下所示： ConnectionResetError: [WinError 10054] 远程主机强迫关闭了一个现有的连接。 为什么会出现这种原因呢？因为Server端和Client端的链接是双向的，一旦一方关闭链接通道后这个链接通道就会崩塌，从而导致Server端发生此异常。 如何解决该异常？需要用到try和except以及if判断，如下所示： from socket import * server = socket(family=AF_INET, type=SOCK_STREAM) server.setsockopt(SOL_SOCKET, SO_REUSEADDR, 1) server.bind((\"localhost\", 8888)) server.listen(5) while 1: conn, clientAddr = server.accept() print(\"%s connect server\" % clientAddr[0]) while 1: # try： 针对Windows环境 try: data = conn.recv(1024) # if：针对Unix环境 if not data: break conn.send(data.upper()) except ConnectionResetError as e: break print(\"%s close connect\" % clientAddr[0]) conn.close() 最终代码 最终代码如下。 Server端： from socket import * server = socket(family=AF_INET, type=SOCK_STREAM) server.setsockopt(SOL_SOCKET, SO_REUSEADDR, 1) server.bind((\"localhost\", 8888)) server.listen(5) while 1: conn, clientAddr = server.accept() print(\"%s connect server\" % clientAddr[0]) while 1: # try： 针对Windows环境 try: data = conn.recv(1024) # if：针对Unix环境 if not data: break conn.send(data.upper()) except ConnectionResetError as e: break print(\"%s close connect\" % clientAddr[0]) conn.close() Client端： from socket import * client = socket(family=AF_INET, type=SOCK_STREAM) client.connect((\"localhost\", 8888)) # 不断的与服务器进行交互 while 1: sendMsg = input(\">>>\") # 不让客户端发送空消息 if not sendMsg: continue # 如果发送的是exit，则断开链接 if sendMsg == \"exit\": break client.send(sendMsg.encode(\"u8\")) recvMsg = client.recv(1024) print(recvMsg.decode(\"u8\")) print(\"client close\") client.close() UDP/Socket简单通信 基础实现 下面是基于UDP协议的socket通信。由于UDP协议是没有双向链接通道的，故首先启动任意一端都不会报错。 Server端代码如下： from socket import * # 1. 实例化socket对象，并添加端口复用 # AF_INET：IPV4 # SOCK_DGRAM：UDP协议 server = socket(family=AF_INET, type=SOCK_DGRAM) server.setsockopt(SOL_SOCKET, SO_REUSEADDR, 1) # 2.绑定IP地址与端口号 # localhost：仅允许本机使用 # 127.0.0.1：仅允许本机使用 # 0.0.0.0：允许任意client链接 server.bind((\"localhost\", 8888)) # 3.接收client端的数据 data, clientAddr = server.recvfrom(1024) # 4.回复client的信息 server.sendto(data.upper(), clientAddr) # 5.关闭服务器，释放Python应用程序所占据的内存资源 server.close() Client端代码如下： from socket import * # 1. 实例化socket对象 # AF_INET：IPV4 # SOCK_DGRAM：UDP协议 client = socket(family=AF_INET, type=SOCK_DGRAM) # 2.向服务端发送数据 client.sendto(\"hello world\".encode(\"u8\"), (\"localhost\", 8888)) # 3.接收服务端的数据 msg, serverAddr = client.recvfrom(1024) print(msg.decode(\"u8\")) # 4.关闭客户端 client.close() 增加单层循环 由于基于UDP协议通信不会建立双向链接通道，所以我们只需要增加一个“通信循环”即可。 Server端改进代码如下所示： from socket import * server = socket(family=AF_INET, type=SOCK_DGRAM) server.setsockopt(SOL_SOCKET, SO_REUSEADDR, 1) server.bind((\"localhost\", 8888)) while 1: data, clientAddr = server.recvfrom(1024) server.sendto(data.upper(), clientAddr) Client端改进代码如下所示： from socket import * client = socket(family=AF_INET, type=SOCK_DGRAM) while 1: sendMsg = input(\">>>\") if sendMsg == \"exit\": break client.sendto(sendMsg.encode(\"u8\"), (\"localhost\", 8888)) msg, serverAddr = client.recvfrom(1024) print(msg.decode(\"u8\")) client.close() Bug测试 我们对该两段代码进行BUG测试均未发现异常。 1）强制停止Client端是否会导致Server端异常崩溃？ 没有导致，原因是因为UDP协议的通信不基于双向链接通道 2）客户端发送回车或者任意空消息是否会导致recvfrom()卡住？ 没有导致，这个还是要从UDP的数据格式说起，因为UDP是数据报格式的发送，所以即便消息体是空，也还有一个消息头在里面 所以UDP的整段数据是不可能为空的，也就不会导致内核缓冲区读不到数据而卡住 解决端口占用问题 在进行socket编程中肯定会遇到端口被占用的情况，实际上就是服务器再向客户端发送最后一条ACK回应，也就是四次挥手中的第四步。 此时服务器的状态应该处于：TIME_WAIT（等待一段时间确保双向链接通道中的信息全部读取完毕）。这是属于正常情况，请勿惊慌。 解决方式如下： 1）加入一条socket配置，重用ip和端口： # 这条代码放在bind的前面 server = socket(family=AF_INET, type=SOCK_STREAM) server.setsockopt(SOL_SOCKET, SO_REUSEADDR, 1) # * server.bind((\"localhost\", 8888)) 2）针对Linux平台： 发现系统存在大量TIME_WAIT状态的连接，通过调整linux内核参数解决， vi / etc / sysctl.conf 编辑文件，加入以下内容： net.ipv4.tcp_syncookies = 1 net.ipv4.tcp_tw_reuse = 1 net.ipv4.tcp_tw_recycle = 1 net.ipv4.tcp_fin_timeout = 30 然后执行 / sbin / sysctl - p 让参数生效。 net.ipv4.tcp_syncookies = 1 表示开启SYN Cookies。当出现SYN等待队列溢出时，启用cookies来处理，可防范少量SYN攻击，默认为0，表示关闭； net.ipv4.tcp_tw_reuse = 1 表示开启重用。允许将TIME - WAIT sockets重新用于新的TCP连接，默认为0，表示关闭； net.ipv4.tcp_tw_recycle = 1 表示开启TCP连接中TIME - WAIT sockets的快速回收，默认为0，表示关闭。 net.ipv4.tcp_fin_timeout 修改系統默认的 TIMEOUT 时间 验证链接合法性 在很多时候，我们的TCP服务端为了防止网络泛洪可以设置一个客户端链接的验证机制。 这个验证机制的实现其实也是非常简单，思路在于进入通信循环之前，客户端和服务端先走一次链接认证，只有通过认证的客户端才能够继续和服务端进行链接，核心点在于Server端和Client端都必须具有1个相同的验证对比盐值。 实现如图所示： Server端代码如下： from socket import * import json import os import hmac class TcpServer: def __init__(self, ip_port=(\"localhost\", 8888), backlog=5, bufsize=1024) -> None: self.salt = b\"SOCKET SERVER\" self.verificationString = None self.bufsize = bufsize self.backlog = backlog self.ip_port = ip_port self.socket = None self.conn = None self.clientAddr = None def run(self): self.initialization() while 1: self.requestHandler() if not self.verification(): print(\"verification fail\") continue while 1: try: self.communicateHandler() except ConnectionResetError as e: self.conn.close() break def initialization(self): \"\"\"初始化数据\"\"\" self.socket = socket(family=AF_INET, type=SOCK_STREAM) self.socket.setsockopt(SOL_SOCKET, SO_REUSEADDR, 1) self.socket.bind(self.ip_port) self.socket.listen(5) self.socket.listen(self.backlog) def requestHandler(self): \"\"\"处理链接请求\"\"\" self.conn, self.clientAddr = self.socket.accept() def verification(self): \"\"\"验证链接合法性\"\"\" # 生成32位bytes类型的随机值 self.verificationString = os.urandom(32) # 将随机值发送给client端 self.conn.send(self.verificationString) # 接收client端的信息 recvMsg = self.conn.recv(self.bufsize) # 将随机值和盐进行hash加密，与recvMsg进行对比，如果一样则验证通过 # 否则认证失败，关闭双向通道 h = hmac.new(self.salt, self.verificationString) digest = h.digest() print(digest, \"\\n\", recvMsg) return hmac.compare_digest(digest, recvMsg) def communicateHandler(self): \"\"\"处理通信请求\"\"\" data = self.conn.recv(self.bufsize) if not data: raise ConnectionResetError( \"client %s close\" % str(self.clientAddr)) data = json.loads(data.decode(\"u8\")) self.conn.send( json.dumps(data).encode(\"u8\") ) if __name__ == \"__main__\": server = TcpServer() server.run() Client端代码如下： import json import hmac from socket import * class TcpClient: def __init__(self, server_ip_port=(\"localhost\", 8888), backlog=5, bufsize=1024) -> None: self.salt = b\"SOCKET SERVER\" self.bufsize = bufsize self.backlog = backlog self.server_ip_port = server_ip_port self.socket = None def run(self): \"\"\"初始化数据\"\"\" self.socket = socket() self.socket.connect(self.server_ip_port) self.verification() self.communicateHandler() def verification(self): \"\"\"验证链接合法性\"\"\" # 获取server端发送的验证字符串 recvVerificationString = self.socket.recv(self.bufsize) # 将验证字符串与本地的盐进行混合，得到新的结果 h = hmac.new(self.salt, recvVerificationString) digest = h.digest() # 将新结果发送给server端做比对 self.socket.send(digest) def communicateHandler(self): \"\"\"处理通信请求\"\"\" while 1: sendMsg = input(\">>>\") # 不让客户端发送空消息 if not sendMsg: continue # 如果发送的是exit，则断开链接 if sendMsg == \"exit\": break self.socket.send( json.dumps(sendMsg).encode(\"u8\") ) recvMsg = json.loads( self.socket.recv(1024).decode(\"u8\") ) print(recvMsg) self.socket.close() if __name__ == \"__main__\": client = TcpClient() client.run() socket模块方法大全 以下是socket模块所提供的方法： 方法 描述 s.bind() 绑定地址（host, port）到套接字， 在AF_INET下,以元组（host, port）的形式表示地址 s.listen() 开始TCP监听。backlog指定在拒绝连接之前，操作系统可以挂起的最大连接数量。该值至少为1，大部分应用程序设为5就可以了 s.accept() 被动接受TCP客户端连接，(阻塞式)等待连接的到来 s.connect() 主动初始化TCP服务器连接。一般address的格式为元组（hostname, port），如果链接出错会抛出socket.error异常 s.connect_ex() connect()函数的扩展版本，出错时返回出错码，而不是抛出异常 s.recv() 接收TCP数据，数据以字符串形式返回，bufsize指定要接收的最大数据量。flag提供有关消息的其他信息，通常可以忽略 s.send() 发送TCP数据，将string中的数据发送到连接的套接字。返回值是要发送的字节数量，该数量可能小于string的字节大小 s.sendall() 完整发送TCP数据，将string中的数据发送到连接的套接字，但在返回之前会尝试发送所有数据。成功返回None，失败则抛出异常 s.recvfrom() 接收UDP数据，与recv()类似，但返回值是（data, address）。其中data是包含接收数据的字符串，address是发送数据的套接字地址 s.sendto() 发送UDP数据，将数据发送到套接字，address是形式为（ipaddr，port）的元组，指定接收方的ip地址和端口号。返回值是发送的字节数 s.close() 关闭套接字 s.getpeername() 返回连接套接字的远程地址。返回值通常是元组（ipaddr, port） s.getsockname() 返回套接字自己的地址。通常是一个元组(ipaddr, port) s.setsockopt(level,optname,value) 设置给定套接字选项的值 s.getsockopt(level,optname[.buflen]) 返回套接字选项的值 s.settimeout(timeout) 设置链接超时时间，默认为None，即永不超时 s.gettimeout() 返回当前超时期的值，单位是秒，如果没有设置超时期，则返回None s.fileno() 返回套接字的文件描述符 s.setblocking(flag) 如果flag为0，则将套接字设为非阻塞模式，否则将套接字设为阻塞模式（默认值）。非阻塞模式下，如果调用recv()没有发现任何数据，或send()调用无法立即发送数据，那么将引起socket.error异常 s.makefile() 创建一个与该套接字相关连的文件 更多方法，参考官方文档：点我跳转 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-28 22:31:16 "},"Python/Python网络编程/TCP粘包.html":{"url":"Python/Python网络编程/TCP粘包.html","title":"TCP粘包","keywords":"","body":"TCP/Socket与subprocess 我们准备做一个可以在Client端远程执行Server端的shell命令并拿到其执行结果的程序，而涉及到网络通信就必然会使用到socket模块，此外还需要subprocess模块拿到命令执行结果。 关于传输层协议的选择我们采用TCP协议，因为它是可靠传输协议且一次传输的数据量要比UDP协议更大。 以下是Server端的代码实现： import subprocess from socket import * # 默认直接实例化socket是IPV4 + TCP协议 server = socket() server.setsockopt(SOL_SOCKET, SO_REUSEADDR, 1) server.bind((\"localhost\", 8888)) server.listen(5) while 1: conn, clientAddr = server.accept() print(\"%s connect server\" % clientAddr[0]) while 1: try: command = conn.recv(1024) if not command: break result = subprocess.Popen( args=command.decode(\"u8\"), shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE ) # get success result successOut = result.stdout.read() # get error result errorOut = result.stderr.read() # type == bytes dataBody = successOut or errorOut conn.send(dataBody) except ConnectionResetError as e: break print(\"%s close connect\" % clientAddr[0]) conn.close() 以下是Client端代码的实现： from socket import * client = socket() client.connect((\"localhost\", 8888)) while 1: command = input(\">>>\").strip() if not command: continue if command == \"exit\": break client.send(command.encode(\"u8\")) dataBody = client.recv(1024) # windows server : decode(\"gbk\") # unix server : decode(\"u8\") print(dataBody.decode(\"u8\")) print(\"client close\") client.close() 使用测试，Client端输入命令： >>>ls __pycache__ socketClient.py socketServer.py >>>pwd /Users/yunya/PythonProject >>>cal 六月 2021 日 一 二 三 四 五 六 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 >>> 粘包现象 上面的测试看起来一切都非常完美，但如果Client端输入一条结果很长的命令时会出现一次性读取不完的Bug，如下所示： >>>info vim File: *manpages*, Node: vim, Up: (dir) VIM(1) VIM(1) NAME vim - Vi IMproved, a programmer's text editor SYNOPSIS vim [options] [file ..] vim [options] - vim [options] -t tag vim [options] -q [errorfile] ex view gvim gview evim eview rvim rview rgvim rgview DESCRIPTION Vim is a text editor that is upwards compatible to Vi. It can be used to edit all kinds of plain text. It is especially useful for editing programs. There are a lot of enhancements above Vi: multi level undo, multi win- dows and buffers, syntax highlighting, command line editing, filename completion, on-line help, visual selection, etc.. See \":help vi_diff.txt\" for a summary of the differences between Vim and Vi. While running Vim a lot of help can be obtained from the on-line help system, with the \":help\" command. See the ON- >>>ls LINE HELP section below. Most often Vim is started to edit a single file with the command vim file More generally Vim is started with: vim [options] [filelist] If the filelist is missing, the editor will start with an empty buffer. Otherwise exactly one out of the following four may be used to choose one or more files to be edited. file .. A list of filenames. The first one will be the current file and read into the buffer. The cursor will be posi- tioned on the first line of the buffer. You can get to the other files with the \":next\" command. To edit a file that starts with a dash, precede the filelist with \"--\". - The file to edit is read from stdin. Commands are read from stderr, which should be a tty. -t {tag} The file to edit and the initial cursor position depends on a >>> 可以看到，第一次命令是info vim，第二次命令是ls，但是ls显示的依旧是info vim命令的执行结果。 这种现象就被称之为粘包现象。 产生原因 为什么会产生粘包现象呢？其实这与TCP底层传输有关，我们知道TCP是流式传输协议，故消息没有确切的边界。 上述代码中每次的recv()仅读取1024个字节，当消息超过1024字节后就会发生一次性读取不完整个内核缓冲区的情况，此时第二次recv()的读取会接着上次读取的位置继续进行读取，如下图所示： 由于我们的recv()只是按照固定的1024去读取数据，那么一旦整体内核缓冲区中所存储的数据量大于1024个字节，就会产生粘包现象。 产生粘包现象的原因主要还是因为接收方不知道消息之间的界限，不知道一次性读取多少字节的数据所造成的。 Nagle算法 基于TCP协议的socket通信有一个特点： 即一方的send()与另一方的recv()可以没有任何关系 比如一方send()三次，另一方recv()一次就可以将数据全部取出来。 TCP协议的发送方有一个特征，他会采用了Nagle算法来对数据进行组包，如果一次发送的数据量很小，比如第一次发送10个字节，第二次发送2个字节，第三次发送3个字节，他可能会将这15个字节的数据凑到一块发送出去。 这么做有一个弊端就是接收方想要将这个大的数据包按照发送方的发送次数精确无误的接收拆分成10 2 3必须要有发送方提供的拆包机制才行。 Server端代码如下所示： from socket import * ip_port = (\"localhost\", 8000) back_log = 5 server = socket(AF_INET, SOCK_STREAM) server.setsockopt(SOL_SOCKET, SO_REUSEADDR, 1) server.bind(ip_port) server.listen(back_log) conn, addr = server.accept() conn.send(\"ABCDEFGHJK\".encode(\"utf-8\")) # 第一次发送是10Bytes的数据 conn.send(\"LM\".encode(\"utf-8\")) # 第二次也是2Bytes的数据 conn.send(\"NOP\".encode(\"utf-8\")) # 第三次是3Bytes的数据 Client端代码如下所示： from socket import * ip_port = (\"localhost\", 8000) buffer_size = 1024 client = socket(AF_INET, SOCK_STREAM) client.connect(ip_port) data_1 = client.recv(buffer_size) print(\"first send of data:\", data_1.decode(\"utf-8\")) data_2 = client.recv(buffer_size) print(\"second send of data:\", data_2.decode(\"utf-8\")) data_3 = client.recv(buffer_size) print(\"last send of data:\", data_3.decode(\"utf-8\")) 最终接受结果： first send of data: ABCDEFGHJK second send of data: LMNOP last send of data: 可以看见发送方Server分三次发送了15bytes的数据，而接收方Client仅用两个recv()就接收完毕了所有的数据。 由Nagle算法产生的组包，会有极大可能导致粘包现象的发生，故我们需要思考如何让接收方知道发送方每一次发送的数据大小并准确进行拆分。 手动拆分 如果我们手动拆分接收方的recv()读取大小呢？是否还会发生粘包现象？ 改进的Client端代码如下所示： from socket import * ip_port = (\"localhost\", 8000) buffer_size = 1024 client = socket(AF_INET, SOCK_STREAM) client.connect(ip_port) # 由于预先知道对面第一次发送的数据包大小为10bytes，故这里也用10bytes进行读取 data_1 = client.recv(10) print(\"first send of data:\", data_1.decode(\"utf-8\")) # 由于预先知道对面第一次发送的数据包大小为2bytes，故这里也用2bytes进行读取 data_2 = client.recv(2) print(\"second send of data:\", data_2.decode(\"utf-8\")) # 由于预先知道对面第一次发送的数据包大小为3bytes，故这里也用3bytes进行读取 data_3 = client.recv(3) print(\"last send of data:\", data_3.decode(\"utf-8\")) 最终接收结果： first send of data: ABCDEFGHJK second send of data: LM last send of data: NOP 粘包被我们手动的计算字节数来精确的分割数据接受量的大小给解决了，但是这样做是不现实的，我们不可能知道对方发送的数据到底是怎么样的，更不用说手动计算。 所以有没有更好的解决方案呢？ 预先发送消息长度 好了，其实上面关于解决粘包的思路已经出来了。 我们需要做的就是让接收方知道本次需要接收内容的大小才能够精确的将所有数据全部提取出来不产生遗漏。 实现方式很简单，可以尝试以下思路： 发送方发送一个此次数据固定的长度 接收方接收到该数据长度并且回应 发送方收到回应并且发送真正的数据 接收方不断的用默认的buffer_size值接收新的数据并存储起来直到超出整个数据的长度，代表此次数据全部接收完毕 实现代码如下，Server端： import subprocess from socket import * # 默认直接实例化socket是IPV4 + TCP协议 server = socket() server.setsockopt(SOL_SOCKET, SO_REUSEADDR, 1) server.bind((\"localhost\", 8888)) server.listen(5) while 1: conn, clientAddr = server.accept() print(\"%s connect server\" % clientAddr[0]) while 1: try: command = conn.recv(1024) if not command: break result = subprocess.Popen( args=command.decode(\"u8\"), shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE ) # get success result successOut = result.stdout.read() # get error result errorOut = result.stderr.read() # type == bytes dataBody = successOut or errorOut # this is message head # tell client next receive of buffsize how many dataHead = len(dataBody) conn.send(str(dataHead).encode(\"u8\")) # server receive result is ready # representative client it is already possible to receive real data body if conn.recv(1024) == b\"ready\": conn.send(dataBody) except ConnectionResetError as e: break print(\"%s close connect\" % clientAddr[0]) conn.close() Client端： from socket import * client = socket() client.connect((\"localhost\", 8888)) while 1: command = input(\">>>\").strip() if not command: continue if command == \"exit\": break client.send(command.encode(\"u8\")) dataHead = client.recv(1024) dataBodyLength = int(dataHead.decode(\"u8\")) currentRecvDataBodyLength = 0 dataBody = b\"\" # Can receive data body client.send(b\"ready\") while currentRecvDataBodyLength 经过实测后发现输入任何命令都不会发生粘包了。 json+struct增加消息头 上面的解决方案还是有一些弊端，因为Server端是发送了2次send()，第1次发送数据整体长度，第2次发送数据内容主体，这样是不太好的（Server端可能同时处理多个链接，所以send()次数越少越好）。 而且如果Server端传的是一个文件的话那么局限性就太强了。因为我们只能将整体的消息长度发送过去而诸如文件名，文件大小之内的信息就发送不过去。 所以我们需要一个更加完美的解决方案，即Server端发送一次send()就将本次的数据整体长度发送过去（还可以包括文件姓名，文件大小等信息）。 那么这里就要使用到一个内置模块，struct。 struct模块可以将其某一种数据格式序列化为固定长度的bytes类型，其中最重要的两个方法就是pack()、unpack()。 pcak(fmt, *args)：根据格式将数据转换为固定长度的bytes类型 unpack(fmt, string)：根据格式将bytes类型转换为原本的数据 以下是常用fmt格式类型： 格式 C语言类型 Python类型 字节数大小 x 填充字节 没有值 c char 字节长度为1 1 b signed char 整数 1 B unsigned char 整数 1 ? _Bool bool 1 h short 整数 2 H unsigned short 整数 2 i int 整数 4 I unsigned int 整数 4 l long 整数 4 L unsigned long 整数 4 q long long 整数 8 Q unsigned long long 整数 8 n ssize_t 整数 N size_t 整数 f float 浮点数 4 d double 浮点数 8 s char[] 字节 p char[] 字节 P void * 整数 简单的使用示例，将数值转换为固定长度的bytes： >>> import struct >>> binInt = struct.pack(\"i\", len(\"this is message\")) >>> binInt b'\\x0f\\x00\\x00\\x00' >>> struct.unpack(\"i\", binInt) (15,) >>> 现在利用该struct模块 + json模块，我们就可以完美的解决粘包现象。 Server端代码如下： import subprocess import json import struct from socket import * # 默认直接实例化socket是IPV4 + TCP协议 server = socket() server.setsockopt(SOL_SOCKET, SO_REUSEADDR, 1) server.bind((\"localhost\", 8888)) server.listen(5) while 1: conn, clientAddr = server.accept() print(\"%s connect server\" % clientAddr[0]) while 1: try: command = conn.recv(1024) if not command: break result = subprocess.Popen( args=command.decode(\"u8\"), shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE ) # get success result successOut = result.stdout.read() # get error result errorOut = result.stderr.read() # type == bytes dataBody = successOut or errorOut # 如果请求的是文件，还可以添加诸如 fileName fileSize # 等属性 dataHeadDict = { \"dataBodyLength\": len(dataBody), \"dataBodyType\": str(type(dataBody)), } # 将字典序列化为字节 dataHead = json.dumps(dataHeadDict).encode(\"u8\") dataHeadLength = struct.pack(\"i\", len(dataHead)) # 发送数据头长度（固定为4字节）， 数据头字典，数据体信息 conn.send( dataHeadLength + \\ dataHead + \\ dataBody ) except ConnectionResetError as e: break print(\"%s close connect\" % clientAddr[0]) conn.close() Client端代码如下： import json import struct from socket import * client = socket() client.connect((\"localhost\", 8888)) while 1: command = input(\">>>\").strip() if not command: continue if command == \"exit\": break client.send(command.encode(\"u8\")) # step01：接收数据头长度，也就是数据头字典的bufsize dataHeadLength = struct.unpack(\"i\", client.recv(4))[0] # step02：提取数据头字典 dataHeadDict = json.loads(client.recv(dataHeadLength)) # step03：提取数据体长度和数据体类型 dataBodyLength, dataBodyType = dataHeadDict.values() # step04：提取数据体 dataBody = b\"\" currentRecvDataBodyLength = 0 while currentRecvDataBodyLength Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-28 17:49:56 "},"Python/Python网络编程/socketserver使用.html":{"url":"Python/Python网络编程/socketserver使用.html","title":"socketserver使用","keywords":"","body":"socketserver简介 在之前我们使用socket模块来构建服务器，但是使用该模块所编写的服务器处理请求都是串行的，即来一个处理一个，无疑这样的处理效率是十分低下的。 那么本篇文章将介绍socketserver模块的使用，它是对socket模块的更高级别封装，内部支持I/O多路复用机制，能够在最短的时间内处理更多的请求。 官方文档：点我跳转 TCP/socketserver 下面是使用socketserver模块构建TCP服务器的基本格式： import socketserver class Server(socketserver.BaseRequestHandler): def handle(self) -> None: # self.request == conn ❶ # self.client_address = clientAddr ❷ print(\"%s connect server\" % self.client_address[0]) while 1: try: data = self.request.recv(1024) if not data: break print(\"receive client data : %s\" % data.decode(\"u8\")) self.request.send(data.upper()) except ConnectionResetError as e: break print(\"%s close connect\" % self.client_address[0]) self.request.close() if __name__ == \"__main__\": server = socketserver.ThreadingTCPServer( server_address=(\"localhost\", 8888), RequestHandlerClass=Server ) # run server server.serve_forever() ❶：self.request等同于双向链接通道conn ❷：self.client_address就是Client端的地址和端口信息 建立TCP/socketserver的步骤如下： 导入socketserver模块 创建一个新的类，并继承socketserver.BaseRequestHandler，重写其handle()方法，用于处理TCP请求 写入交互逻辑 防止客户端发送空信息以致双方卡死（针对Unix平台Client端异常关闭） 防止客户端突然断开服务端抛出的ConnectionResetError异常（针对Windows平台Client端异常关闭） 实例化socketserver.ThreadingTCPServer类，并传入自定义处理TCP请求的类和绑定ip+port 调用socketserver.ThreadingTCPServer实例对象下的serve_forever()方法，启动服务 注意：socketserver模块实现的TCP服务器并不会提供粘包优化，所以需要自己手动实现。 可以看见，使用socketserver模块来构建TCP/socket服务器会简单很多，同时使用它创建的服务器还支持并发服务，而不再是串行服务。 UDP/socketserver 下面是使用socketserver模块构建UDP服务器的基本格式： import socketserver class Server(socketserver.BaseRequestHandler): def handle(self) -> None: # self.request == (message, server) ❶ # self.client_address = clientAddr ❷ data = self.request[0] server = self.request[1] print(\"receive client data : %s\" % data.decode(\"u8\")) server.sendto(data.upper(), self.client_address) if __name__ == \"__main__\": server = socketserver.ThreadingUDPServer( server_address=(\"localhost\", 8888), RequestHandlerClass=Server ) # run server server.serve_forever() ❶：self.request和TCP的self.request不同，它不是双向链接通道conn，而是包含了信息与服务端本身 ❷：self.client_address就是Client端的地址和端口信息 TCP/socketserver解决粘包 使用socketserver模块来构建能够解决粘包的TCP服务器，以远程输入命令为例。 Server端代码如下： import json import struct import socketserver import subprocess class Server(socketserver.BaseRequestHandler): def handle(self) -> None: \"\"\" 处理通信 \"\"\" print(\"%s connect server\" % self.client_address[0]) while 1: try: command = self.request.recv(1024) if not command: break self.main(command) except ConnectionResetError as e: break print(\"%s close connect\" % self.client_address[0]) self.request.close() def main(self, command): \"\"\" 通信处理的主体逻辑 \"\"\" dataBody = self.runCommand(command) sendData = self.encapsulate(dataBody) self.request.send(sendData) def runCommand(self, command): \"\"\" 运行命令，并返回结果 Args: command string: 远程传入的命令 Returns: string: 命令执行结果 \"\"\" result = subprocess.Popen( args=command.decode(\"u8\"), shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE ) successOut = result.stdout.read() errorOut = result.stderr.read() return successOut or errorOut def encapsulate(self, dataBody): \"\"\" 对命令执行结果进行封装，自定义协议解决粘包问题 Args: dataBody: 命令执行结果 Returns: string: 封装完成的结果，格式是 '消息头长度 [消息头 {消息体长度} ] 消息体' \"\"\" dataHeadDict = { \"dataBodyLength\": len(dataBody), } dataHead = json.dumps(dataHeadDict).encode(\"u8\") dataHeadLength = struct.pack(\"i\", len(dataHead)) sendData = dataHeadLength + dataHead + dataBody return sendData if __name__ == \"__main__\": server = socketserver.ThreadingTCPServer( server_address=(\"localhost\", 8888), RequestHandlerClass=Server ) # run server server.serve_forever() Client端代码如下： import json import struct from socket import * client = socket() client.connect((\"localhost\", 8888)) while 1: command = input(\">>>\").strip() if not command: continue if command == \"exit\": break client.send(command.encode(\"u8\")) # step01：接收数据头长度，也就是数据头字典的bufsize dataHeadLength = struct.unpack(\"i\", client.recv(4))[0] # step02：提取数据头字典 dataHeadDict = json.loads(client.recv(dataHeadLength)) # step03：提取数据体长度和数据体类型 dataBodyLength= dataHeadDict.get(\"dataBodyLength\") # step04：提取数据体 dataBody = b\"\" currentRecvDataBodyLength = 0 while currentRecvDataBodyLength Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-28 18:43:45 "},"Python/Python网络编程/socketserver源码.html":{"url":"Python/Python网络编程/socketserver源码.html","title":"socketserver源码","keywords":"","body":"基础源码 包含信息 socketserver源代码中基本上所有的类都会分成两部分。 server类：处理链接相关 request类：处理通信相关 我们可以看一下socketserver中使用到了哪些比较基础的模块（socketserver.py line 126 - 136）： import socket # socket基础模块 import selectors # I/O多路复用模块 import os # 操作系统接口模块 import errno # 定义符号错误码的模块 import sys # 系统相关模块 try: import threading # 多线程模块，如果平台支持 except ImportError: import dummy_threading as threading # 多线程模块的另一个版本，当平台不支持时导入该模块 from io import BufferedIOBase # 读取相关模块 from time import monotonic as time # 单调时钟模块，避免时间波动的发生 下面是定义了允许导入该模块的内容，这里就基本上是socketserver模块最常用的一些类（socketserver.py line 138 - 141）： __all__ = [\"BaseServer\", \"TCPServer\", \"UDPServer\", \"ThreadingUDPServer\", \"ThreadingTCPServer\", \"BaseRequestHandler\", \"StreamRequestHandler\", \"DatagramRequestHandler\", \"ThreadingMixIn\"] 平台扩展 接下来socketserver模块的执行，会根据不同的平台做出一些不同的区分了。 如（socketserver.py line 142 - 147）： if hasattr(os, \"fork\"): __all__.extend([\"ForkingUDPServer\",\"ForkingTCPServer\", \"ForkingMixIn\"]) if hasattr(socket, \"AF_UNIX\"): __all__.extend([\"UnixStreamServer\",\"UnixDatagramServer\", \"ThreadingUnixStreamServer\", \"ThreadingUnixDatagramServer\"]) 这里主要的意思是动态的为__all__属性增加一些可用于导入的类，但是这些类可以说很少用到，因此不必太在意。 上面为__all__属性增加的类还未进行实现，在何时进行实现呢？你可以在（socketserver.py line 681 - 698）找到这些类的实现，代码如下： if hasattr(os, \"fork\"): class ForkingUDPServer(ForkingMixIn, UDPServer): pass class ForkingTCPServer(ForkingMixIn, TCPServer): pass class ThreadingUDPServer(ThreadingMixIn, UDPServer): pass class ThreadingTCPServer(ThreadingMixIn, TCPServer): pass if hasattr(socket, 'AF_UNIX'): class UnixStreamServer(TCPServer): address_family = socket.AF_UNIX class UnixDatagramServer(UDPServer): address_family = socket.AF_UNIX class ThreadingUnixStreamServer(ThreadingMixIn, UnixStreamServer): pass class ThreadingUnixDatagramServer(ThreadingMixIn, UnixDatagramServer): pass 下面这两行比较重要（socketserver.py line 151 - 154），它会根据平台选择不同的I/O多路复用机制，如果是Unix平台，会采用epoll，而Windows平台则只能采用性能较低的select机制。 if hasattr(selectors, 'PollSelector'): _ServerSelector = selectors.PollSelector else: _ServerSelector = selectors.SelectSelector 其实针对不同平台实例化或添加不同的应用类在各大框架中都比较常见，socketserver模块也不仅仅只有上面一些地方会根据平台进行区分，这里只是例举几个比较重要的。 类的介绍 当socketserver源码执行至此，基本上所有常用的类都被初始化了。 那么这些类的作用到底是什么？前面已经说过，socketserver模块中主要分为两大类，我们就依照这个来进行划分。 1）处理链接相关的类： 类名 描述 父类 BaseServer 基础链接类 object TCPServer TCP协议类 BaseServer UDPServer UDP协议类 TCPServer UnixStreamServer 文件形式字节流类 TCPServer UnixDatagramServer 文件形式数据报类 UDPServer 2）处理通信相关的类： 类名 描述 父类 BaseRequestHandler 基础请求处理类 object StreamRequestHandler 字节流请求处理类 BaseRequestHandler DatagramRequestHandler 数据报请求处理类 BaseRequestHandler 除此之外，还有一些多线程以及多进程相关的类，如下所示。 1）多线程相关的类： 类名 描述 父类 ThreadingMixIn 线程工具包类 object ThreadingUDPServer 多线程UDP协议服务类 ThreadingMixIn, UDPServer ThreadingTCPServer 多线程TCP协议服务类 ThreadingMixIn, TCPServer 2）多进程相关的类： 类名 描述 父类 ForkingMixIn 进程工具包类 object ForkingUDPServer 多进程UDP协议服务类 ForkingMixIn, UDPServer ForkingTCPServer 多进程TCP协议服务类 ForkingMixIn, TCPServer 继承图示 上面所举例的类的继承关系如下所示。 1）处理链接相关的类： 2）处理通信相关的类： 3）多线程相关的类： 4）多进程相关的类： 5）总继承关系一览图： TCP/socketserver分析 实例化过程分析 有了继承关系后，我们可以看TCP服务的实例化过程，首先它的启动如下： ins = socketserver.ThreadingTCPServer((\"ip\", port), RequestHandler) # RequestHandler即我们自己写的类，需要覆写handle()方法 所以我们首先是需要找到ThreadingTCPServer类的__init__()方法，在其父类TCPServer类中能找该方法（socketserver.py line 394 - 460 ）： class TCPServer(BaseServer): address_family = socket.AF_INET # 网络家族的socket，IPV4 socket_type = socket.SOCK_STREAM # TCP协议 request_queue_size = 5 # 消息队列最大数，即backlog半链接池 allow_reuse_address = False # 重用端口，默认关闭 def __init__(self, server_address, RequestHandlerClass, bind_and_activate=True): BaseServer.__init__(self, server_address, RequestHandlerClass) self.socket = socket.socket(self.address_family, self.socket_type) if bind_and_activate: try: self.server_bind() self.server_activate() except: self.server_close() raise 在这里，它又调用了BaseServer.__init__()方法，所以我们先看一下（socketserver.py line 157 - 209）： class BaseServer: timeout = None def __init__(self, server_address, RequestHandlerClass): self.server_address = server_address # 即传入的(ip+port) self.RequestHandlerClass = RequestHandlerClass # 即我们自己传入的类 self.__is_shut_down = threading.Event() # 线程加事件锁 self.__shutdown_request = False 这里的（socketserver.py line 208）会去实例化出一把线程锁，目的是为了今后控制多个请求的处理顺序，所以暂时不用管。接着回到（socketserver.py line 394 - 460 ）的TCPServer类中__init__()方法： 首先它会实例化出一个对象 然后会判断默认参数bind_and_activate是否为True 执行self.server_bind() self.server_activate() class TCPServer(BaseServer): address_family = socket.AF_INET # 网络家族的socket，IPV4 socket_type = socket.SOCK_STREAM # TCP协议 request_queue_size = 5 # 消息队列最大数，即backlog半链接池 allow_reuse_address = False # 重用端口，默认关闭 def __init__(self, server_address, RequestHandlerClass, bind_and_activate=True): BaseServer.__init__(self, server_address, RequestHandlerClass) self.socket = socket.socket(self.address_family, self.socket_type) if bind_and_activate: # bind_and_activate是默认参数，也就是True try: self.server_bind() self.server_activate() except: self.server_close() raise 现在又需要去找self.server_bind()方法，我们要时刻铭记self是谁，self目前是ThreadingTCPServer类的实例对象，所以还需要回到ThreadingTCPServer类中寻找该方法。 最终可以在其第二父类，TCPServer中找到该方法（socketserver.py line 462 - 471 ）： def server_bind(self): # 判断是否重用端口，该属性是TCPServer类属性，默认为False，即不重用端口 if self.allow_reuse_address: self.socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1) # 绑定地址 self.socket.bind(self.server_address) # 获取socket名字，实际上就是 (\"ip\", port) self.server_address = self.socket.getsockname() 该方法执行完毕后又要去找self.server_activate()方法，老样子，先去ThreadingTCPServer类中找，找不到去第一父类ThreadingMixIn中找，依旧找不到，所以再找TCPServer类，最终在（socketserver.py line 473 - 498 ）中找到。 其实该方法就是开启监听，backlog参数为TCPServer类属性request_queue_size，为5： def server_activate(self): \"\"\"Called by constructor to activate the server. May be overridden. \"\"\" self.socket.listen(self.request_queue_size) 现在整个实例化流程已经跑完了，因为没有任何异常的发生，就不会触发self.server_bind()方法。 该方法定义在TCPServer中（socketserver.py line 481 - 487 ），一旦实例化出错将关闭套接字对象，即停止服务器运行： def server_close(self): \"\"\"Called to clean-up the server. May be overridden. \"\"\" self.socket.close() server_forever()启动服务分析 接下来是启动服务，启动服务的代码是： ins.server_forever() 所以我们需要到ThreadingTCPServer类中去寻找该方法，最终可以在其第二父类TCPServer的父类BaseServer中找到（socketserver.py line 219 - 246 ），其实说白了该类就是使用I/O多路复用机制进行不断的死循环监听，一旦有请求过来就立即进行三次握手，创建双向链接通道： def serve_forever(self, poll_interval=0.5): # self.__is_shut_down是一把事件锁，用于控制子线程的启动顺序。 # 这里的clear()代表清除，这个不是重点，往下看。 self.__is_shut_down.clear() try: # （socketserver.py line 151 - 154）中定义了I/O多路复用的机制 # 所以这里会自动选择 with _ServerSelector() as selector: # 事件注册，可读事件，self即当前ThreadingTCPServer的实例 selector.register(self, selectors.EVENT_READ) # 该条件是BaseServer.__init__()的实例属性，默认为False # 所以下面开始死循环进行监听 while not self.__shutdown_request: # 每隔0.5秒，循环监听一次 ready = selector.select(poll_interval) # 由于该属性为False，所以不会跳出 if self.__shutdown_request: break # 一旦有客户端请求链接，便立即运行下面的方法 if ready: self._handle_request_noblock() self.service_actions() finally: self.__shutdown_request = False self.__is_shut_down.set() 如果有链接请求，则会执行self._handle_request_noblock()方法，它在哪里呢？ 其实就在BaseServer中，位于（socketserver.py line 307- 328 ）： def _handle_request_noblock(self): try: # self.get_request()方法在TCPServer中定义 # 返回值为 self.socket.accept()，也就是说它这里会返回conn和clientAddr request, client_address = self.get_request() except OSError: return # self.verify_request()方法的返回结果永远都是True，其实就是验证 # 双向链接通道和客户端地址是否合法，不用太在意 if self.verify_request(request, client_address): try: self.process_request(request, client_address) except Exception: self.handle_error(request, client_address) self.shutdown_request(request) except: self.shutdown_request(request) raise else: self.shutdown_request(request) 这里又要去找self.process_request()方法了，self是ThreadingTCPServer的实例对象，所以先去ThreadingTCPServer类中找，最终该方法可以在其第一父类ThreadingMixIn中找到（socketserver.py line 660- 669 ）。 该方法主要是针对请求验证成功后，需要进行通信的客户端，会创建一个线程来对其进行服务： def process_request(self, request, client_address): # 创建子线程任务，子线程运行self.process_request_thread()方法 # 并且传入了参数双向链接通道request以及客户端地址 t = threading.Thread(target = self.process_request_thread, args = (request, client_address)) # ThreadingMixIn的类属性，为False t.daemon = self.daemon_threads # 第一个值为False，第二个值为True。他们都是ThreadingMixIn的类属性 # 故下面会执行 if not t.daemon and self._block_on_close: if self._threads is None: self._threads = [] # 创建空列表 self._threads.append(t) # 将子线程任务添加至空列表中 t.start() # 执行子线程任务 process_request_thread()方法是子线程处理通信的方法，该方法位于ThreadingMixIn类中，在（socketserver.py line 647- 658 ）处： def process_request_thread(self, request, client_address): \"\"\"Same as in BaseServer but as a thread. In addition, exception handling is done here. \"\"\" try: self.finish_request(request, client_address) except Exception: self.handle_error(request, client_address) finally: self.shutdown_request(request) # 它不会关闭这个线程，而是将其设置为wait()状态 再来接着看self.finish_request()方法，该方法位于BaseServer类中（socketserver.py line 362- 364）： def finish_request(self, request, client_address): \"\"\"Finish one request by instantiating RequestHandlerClass.\"\"\" self.RequestHandlerClass(request, client_address, self) self.RequestHandlerClass即我们自己传入的类，现在会对其进行实例化，我们自定义的类没有__init__()方法，所以他会去寻找该自定义类的父类BaseRequestHandler（socketserver.py line 700- 735）： class BaseRequestHandler: def __init__(self, request, client_address, server): self.request = request # 双向链接通道 self.client_address = client_address # 客户端信息 self.server = server # 实例本身，self self.setup() # 一个钩子函数 try: self.handle() # 我们覆写的handle() finally: self.finish() # 一个钩子函数 def setup(self): pass def handle(self): pass def finish(self): pass 所以现在，你应该明白为什么我们自己写的类一定要覆写handle()方法了。 内部调用顺序图示 以下是实例化过程图示： 以下是启动服务过程图示： UDP/socketserver分析 关于UDP的分析这里暂时就不做了，感兴趣的朋友可以按照继承关系图和上述的分析思路自己分析实现一次。 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-29 18:12:22 "},"Python/Python并发编程/summary.html":{"url":"Python/Python并发编程/summary.html","title":"Python并发编程","keywords":"","body":" 任务处理发展史 并发与并行 线程与进程 GIL锁 threading模块使用 threading线程锁 threading.local功能介绍 multiprocessing模块使用 线程或进程通信 生产者消费者模型 使用执行器提交任务 Linux五大I/O模型 常见I/O示例演示 协程 asynic Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-07-07 16:44:40 "},"Python/Python并发编程/任务处理发展史.html":{"url":"Python/Python并发编程/任务处理发展史.html","title":"任务处理发展史","keywords":"","body":"从任务处理角度看待操作系统发展史 操作系统的作用是管理硬件，目的是为了让用户更加方便的来操控计算机底层的硬件。 可以看到操作系统对于人们操控计算机进行作业有着不可小觑的功劳，那么在早期没有操作系统的时候你能想象是什么样子吗？现在我们来看一看。 手动化时代 早期的计算机并没有操作系统，而是通过纸带来进行程序的编辑。 它有3台设备，分别是： 输入机 计算机 输出机 那个时候的程序员需要一起约定好时间，来轮流的对自己的程序进行编辑，因为那个时候的计算机在同一时刻下只能由一个人去运行和掌控，我们来看一下它的计算流程： 这个时代的计算机一次只能跑一个人的程序，即同一时刻至多只能运行一个任务，不会受到其他因素的干扰。 它的缺点非常明显，一次只能一个人使用而后面想要使用的人必须得等待前一个人用完之后才行，其执行效率非常低下。 除此之外最关键的就是人在进行与计算机交互的时候计算机的运算器是没有任何工作的，这就造成了资源上极大的浪费，那么这种浪费可以理解为I/O阻塞。 批处理系统时代 相比于前一代计算机处理任务的方式，批处系统的诞生让这一代计算机有了极大的进步，并且输入也不再使用纸带，而是采用磁带，批处理操作系统可以将多个用户的任务同时提交（但是不能同时运行）。 注意：批处理系统并不是一个真正意义上的我们现在所理解的操作系统，而仅是一种支持多任务同时提交、区分不同任务的一段代码 假设有三个程序员需要使用这台计算机，他们需要将自己的程序全部交由一个程序员让其进行人机之间的交互，那么这样就节省了三倍的时间。 但是这样的缺点也很明显，大家只能等待三个人的程序全部处理完后大家才能拿到各自的结果，这个等待过程是十分漫长的。 批处理最大的问题还是在于拥有人手动与计算机交互的过程，此时会发生I/O阻塞，那么能不能把中间的两个小人全部干掉让计算机来做他们做的事儿呢？当然可以，但是当时的人还没想到这一点，如图，缺点如下： 任务提交虽然是同时提交，但是任务执行依旧是串行执行 仍然具有人为操作，I/O时间太长 我们再来想一个问题，如果程序员A的程序出错了，它第一时间拿不到结果，输出的时候会一直卡在那，程序员B和程序员C的程序结果也不用拿了，反正都出不来。是不是很蛋疼？ 后来慢慢的经过时间的积累与技术的发展，针对这一代的批处理系统的缺点，又出现了一种新的技术。 该技术名叫SPOOLING技术，这个技术的出现让上图的两个小人下岗了。SPOOLING技术的出现极大的减少了I/O阻塞的时间。 除此之外，该代操作系统还提出了一个非常重要的思想，即多道程序设计的思想，这个技术思想目前在我们的进程中依然存在，它的主要功能就是解决了程序串行执行的问题。 也就是说： SPOOLING技术解决了人为的I/O阻塞问题 多道程序设计解决了程序串行执行的问题 如图所示： 尽管这样做的确让程序效率提高了不少，但是我们还有一个问题。 计算机中依然是批处理系统，还是要等A、B、C的程序同时出结果才能拿到最终结果，这个时间太长了，就像上面说的如果程序员A的程序出错了卡住了程序员B和C的正常程序也取不出来。 分时系统时代 为了解决上述统一化打印结果的问题，出现了分时操作系统。 该系统很形象的一个比喻就是一台计算机给A、B、C每个程序员一个键盘鼠标和显示器，大家共有一个主机各玩各的互不影响，它们都认为自己的程序是独享的并且马上就能看到自己程序的运行结果，但是实际上大家还是共用的同一个CPU，分时操作系统一言以蔽之即多用户多任务的系统。 分时操作系统到现在依然存在，并且还十分常见，比如许多人去操作同一台服务器。 这时候大家就在考虑，你丫键盘鼠标显示器啥都给我了，为啥直接给我一个主机呢？这主要还是受限于当时的计算机高额的成本造价问题，但是到了如今计算机的成本以及体积都下来后，这些都不是问题了。 个人操作系统的诞生 科技在发展，时代在进步，当科学技术达到一定的水平后，计算机造价变的越来越低廉，此时便出现了个人操作系统。 个人操作系统的出现让任务处理变的越来越迅速，每个人都能做到真正意义上的互不影响。 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-30 14:36:25 "},"Python/Python并发编程/并发与并行.html":{"url":"Python/Python并发编程/并发与并行.html","title":"并发与并行","keywords":"","body":"并发与并行 并发和并行是指操作系统处理任务的能力。 即有多个任务时是一个一个的处理？还是一次处理多个？ 并发：操作系统具有处理多个任务的能力 并行：操作系统具有同时处理多个任务的能力 并发是包含并行的，这里再提出一个伪并行的概念，就是看起来像是同时处理多个任务，但是实际上这些任务并不是被同时处理的，而是具有一定的先后次序，由于这种任务处理切换的速度太快了，所以看起来像是同时处理。 同步与异步 同步和异步是指任务的提交方式。 即当一个任务提交完成后是否需要等待任务的反馈结果出现后再去做其他的事情。 同步：当任务提交完成后，原地等待任务的返回结果，等待的过程中不做任何事 程序上面表现出来的感觉就是卡住了 异步：任务提交之后，不原地等待任务的返回结果，直接去做其他事情 当任务结果出现后会自动反馈给调用者 同步很好理解，但是异步的执行结果是怎么自动反馈的呢？ 这是因为我们在提交异步任务的时候会给任务绑定一个回调函数，当任务完成后会自动的触发该回调函数获得任务执行结果。 阻塞与非阻塞 阻塞和非阻塞是指程序的运行状态。 即程序现在是否卡住了？卡住了就是阻塞，没卡住就是非阻塞，常见I/O操作。 阻塞：当调用某个函数的时候卡住不懂了，如input()函数 非阻塞：当调用某个函数的时候，如遇见I/O操作程序并不会卡住而是去做其他的事情 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-30 16:25:27 "},"Python/Python并发编程/线程与进程.html":{"url":"Python/Python并发编程/线程与进程.html","title":"线程与进程","keywords":"","body":"进程相关 程序和进程 程序是一堆躺在硬盘中的代码，是“死”的 进程是程序被调用执行时活动的状态，是“活”的 当程序运行时必定会产生很多的数据，那么这些数据会被保存在进程中，所以： 进程是最小的资源单元 注意一点，程序只有在运行状态时才会产生进程，而不运行时就是一堆代码而已。 因此，你可以理解为每一段程序运行时都会创建一个“小房子”，这个“小房子”中存放了很多资源。 进程是由谁创建的 进程必定是由操作系统所创建，每个程序运行时都必然会产生一个进程，当然也可以产生多个进程。 如下图所示： 进程间的数据交互 不同进程之间的数据一般来说不允许共享，因为每个进程都是独立的“小房子”，每个“小房子”的资源都是自己独享的。 但我们之前学过socket，这玩意儿最早就是用来解决进程间数据交互问题的。 所以，进程之间虽然默认不支持数据交互，但是我们可以使用某些特殊手段让两个进程之间支持数据交互，这样做需要付出一些代价。 进程中的切换 一个CPU核心同一时刻最多只能运行一个进程，而多个CPU核心同一时刻可以运行多个进程，这个就是并发的体现。 一个系统中肯定有大量的进程，所以CPU需要不断的进行进程切换： 进程切换实际上是由操作系统说了算，但是进程切换的消耗是非常大的，系统需要保留当前进程的状态，进行切换后还需要将进程状态进行恢复，下面介绍一些最基本的进程切换策略。 1）先来先服务策略： 谁先创建进程，CPU就先执行谁。 该算法对一个存活时间很短的进程是相当不利的，如果一个存活时间很长的进程占用了一个CPU核心，而恰巧这个CPU又是单核的，那么其他存活时间短的进程永远也得不到CPU的眷顾了。 所以操作系统的进程调度如果仅有这一种策略是行不通的。 2）短作业优先调度策略： 那个进程作业时间短，CPU就先执行谁。 显然，单一的这种算法会让长作业进程得不到CPU眷顾，故也不能一直采取这种策略。 3）时间片轮询策略： 什么意思呢？就是说假如有多个进程，我每个进程让你运行个三五秒就切换到另一个进程运行，如此来回切换就是时间片轮转，即将时间分段，每个进程只运行一段时间。 在类Unix系统中，我们可以为某个进程分配更多的时间片。 4）多级反馈队列： 这个其实是基于时间片轮转做的，它会将当前所有的活动进程送入一个队列中，根据存活时间来为其分配到不同的队列中，进程存活时间越久，其得到CPU眷顾的次数越低。 如图所示： 其实在Unix系统中，我们可以为一个进程分配更多的时间片与更高的优先级，这里不再举例。 专业性解释 进程就是一个程序在一个数据集上的一次动态执行过程。 进程一般由以下三部分组成： 程序 数据集 进程控制块 我们编写的程序用来描述进程要完成哪些功能以及如何完成； 数据集则是程序在执行过程中所需要使用的资源； 进程控制块用来记录进程的外部特征，描述进程的执行变化过程，系统可以利用它来控制和管理进程，它是系统感知进程存在的唯一标志。 数据集提供所有程序运行时需要的资源，进程控制块用来记录程序的状态，比如说挂起被切换状态还是运行状态等等 线程相关 线程和进程 每个进程创建时也会默认至少创建一个线程，如果把进程比喻为“小房子”，那么线程就是小房子中的人，是真正干活的单元。 因此： 线程是最小的执行单元 一个进程中的所有线程都会共享该进程的所有资源。 需要注意，线程一定是包含在进程内的。 必须先有进程后才能有线程，就像线程这个人必须住在进程的房子里一样： 线程是由谁创建的 线程有2种，一般所说的线程都是系统级别创建的，但也有用户级别创建的线程，这种线程常常被称之为纤程。 它们的区别在于： 系统级线程的切换消耗较大 用户级线程的切换消耗较小 所以，对任务执行效率来说，使用 纤程 > 线程。 线程间的数据交互 线程必须存在于进程中，我们上面说过一个进程可以有多个线程，那么想当然的该进程里的所有资源都可以被位于该进程中的线程所拿到。 而跨进程之间的线程数据交互就是属于进程间的数据交互了： 线程之间的通信一定要注意线程安全问题，举个例子，假如你和你的同学均是一个线程： 你和你的同学在一个房间中，房间里有一颗糖，趁着你干活的时候你同学将糖吃掉了，你干完活回来之后肯定会以为糖果还在，当你去拿糖果的时候由于糖果不在了所以就会抛出异常。 那么这个就是线程安全问题，如何解决线程安全问题这是之后要聊到的一个话题。 线程的切换 线程切换与进程切换如出一辙，看上面的就行了。 专业性解释 1） 一个程序至少有一个进程，一个进程至少有一个线程 2） 进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率。 3） 线程在执行过程中与进程还是有区别的。每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。 4） 进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动，进程是系统进行资源分配和调度的一个独立单元。而线程是进程的一个实体，是CPU调度和分派的基本单元，它是比进程更小的能独立运行的基本单元。 5）线程自己基本上不拥有系统资源，只拥有一点在运行中必不可少的资源（如程序计数器，一组寄存器和栈）但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源。 6） 一个线程可以创建和撤销另一个线程，同一个进程中的多个线程之间可以并发执行。 切换流程 为了控制进程的执行，内核必须有能力挂起正在CPU上运行的进程，并恢复以前挂起的某个进程的执行。这种切换是由操作系统来完成的。因此可以说，任何进程都是在操作系统内核的支持下运行的，是与内核紧密相关的。 从一个进程的运行转到另一个进程上运行，这个过程中经过下面这些变化： 　　　　1. 保存处理机上下文，包括程序计数器和其他寄存器。 　　　　2. 更新PCB信息。 　　　　3. 把进程的PCB移入相应的队列，如就绪、在某事件阻塞等队列。 　　　　4. 选择另一个进程执行，并更新其PCB。 　　　　5. 更新内存管理的数据结构。 　　　　6.恢复处理机上下文。 总而言之，进程的切换非常的消耗资源。 不同的进程之间能进行切换那么不同的线程之间也必定能进行切换，既然线程是最小的执行单元那么同一进程中的线程切换的代价必然是少于进程间的切换的。 程序计数器 我们都知道软件的数据是存储在硬盘上的，这个调用的过程十分缓慢，但是在内存中就会快很多。 同时，一个线程或者进程的切换挂起状态如果是存放在内存中那么是肯定不行的，这个速度对于切换毫秒级别的线程或者进程来说速度依旧不够快。 所以在CPU旁边有了一个程序计数器的存在，由于距离CPU比较近传输状态的时间也会相应缩短。 它的大小并不是很大只有小小的1 - 2kb，主要功能就是存储了这些进程或者线程切换状态的数据。 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-30 18:22:15 "},"Python/Python并发编程/GIL锁.html":{"url":"Python/Python并发编程/GIL锁.html","title":"GIL锁","keywords":"","body":"GIL锁是什么 GIL锁是CPython所独有的，全称为Global Interpreter Lock，译为全局解释器锁。 它是CPython经常被人诟病的一个槽点，直接让CPython的多线程变成了残废。 GIL锁产生的原因 CPython中的一个线程对应于C语言中的一个线程，而CPython在执行函数时会将函数转变为可执行的字节码，如果多个线程同时运行一段字节码是很有可能出错的，为了避免这个错误所以Python使用了GIL锁限制了多线程技术。 GIL锁使得同一个时刻的同一进程下的多个线程只能有一个在CPU上执行字节码，无法将这些线程映射到不同的CPU核心上去执行。 因此CPython的GIL锁注定了其在多线程任务处理方面并没有太大优势，只能做到伪并行的效果，如下图所示： 而对比Java语言，Java语言能够将多个线程映射到不同的CPU核心上，所以他的多线程任务处理是真正的并行化的： GIL锁抢占策略 由于CPython中同一时刻一个CPU只能执行一个线程，那么其他的线程该怎么办呢？ 这个时候其他线程就要对GIL锁进行抢占了，当GIL锁死一个线程之后，并不是非要等这个线程运行完后才会释放，而是会在适当的时候就进行释放 : 该线程遇到了I/O操作 该线程的时间片轮询到了 我们可以通过sys模块查看GIL锁的释放时机： import sys print(sys.getcheckinterval()) # 100 这代表CPU接收100个指令后会切换另一条线程进行执行。 如下图所示： I/O密集型操作 CPython中，多线程技术常于I/O密集型业务中使用，如网络爬虫。 因为GIL锁的释放时机是当一个线程遇到I/O操作后就切换至另一条线程，所以对于需要频繁进行网络I/O的爬虫业务来说，CPython多线程还是很有必要的，它比多进程切换代价更小。 计算密集型操作 CPython中，多进程技术常于计算密集型业务中使用。 因为GIL锁的存在，CPython中一个进程中的多个线程无法映射到不同的CPU核心上进行执行，但是多个进程中的线程则可以映射到不同的CPU核心上，所以当实现一些计算密集型业务时，应当考虑多进程操作。 如下图所示： 为什么不干掉GIL锁 参考文章：Python 有可能删除 GIL 吗？ Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-30 19:53:37 "},"Python/Python并发编程/threading模块使用.html":{"url":"Python/Python并发编程/threading模块使用.html","title":"threading模块使用","keywords":"","body":"threading模块 Python中提供了threading模块来实现线程并发编程，官方文档如下： 官方文档 添加子线程 实例化Thread类 使用该方式新增子线程任务是比较常见的，也是推荐使用的。 简单的代码示例如下，创建3个子线程并向其添加任务，然后运行并打印它们的线程ID和线程名字： import threading import time def task(params): print(\"sub thread run\") currentThread = threading.current_thread() time.sleep(3) print(\"current subthread id : %s\\ncurrent subthread name : %s\\ncurrent subthread params : %s\" % ( currentThread.ident, currentThread.name, params)) if __name__ == \"__main__\": print(\"main thread run\") for item in range(3): subThreadIns = threading.Thread(target=task, args=(item, )) subThreadIns.start() print(\"main thread run end\") # main thread run # sub thread run # sub thread run # sub thread run # main thread run end # current subthread id : 123145534398464 # current subthread name : Thread-1 # current subthread params : 0 # current subthread id : 123145544908800 # current subthread name : Thread-3 # current subthread params : 2 # current subthread id : 123145539653632 # current subthread name : Thread-2 # current subthread params : 1 ❶：返回一个线程对象，注意args的参数必须是一个tuple，否则抛出异常，也就是说单实参必须添加逗号 ❷：start()方法是指该线程对象能够被系统调度了，但不是立即运行该线程，而是等待系统调度后才运行。所以你会看见上面子线程的运行顺序是0、2、1，另外一个线程对象只能运行一次该方法，若多次运行则抛出RunTimeError的异常。 ❸：获取当前的线程对象 ❹：获取当前线程对象的编号和名字，以及传入的参数。当线程启动时，系统都会分配给它一个随机的编号和名字 首先上述代码会先运行主线程，然后会创建3个子线程并运行。 当子线程运行的时候碰到了sleep(3)这种I/O操作时会释放掉GIL锁，并将线程执行权交还给了主线程。 然后主线程就运行完毕了，此时主线程并不会被kill掉，而是等待子线程运行结束后才会被kill掉，而子线程则是运行完毕后会被立刻kill掉。 我们可以看见，上面3个任务如果按照串行执行共会花费9.+秒时间，而通过多线程来运行，则仅需花费3.+秒的时间，极大的提升了任务处理效率。 自定义类覆写run()方法 上面的子线程任务对象是一个全局函数，我们也可以将它作为方法来进行调用。 书写一个类并继承Threading类，覆写run()方法即可： import threading import time class TaskClass(threading.Thread): # ❶ def __init__(self, params): self.params = params # ❷ super(__class__, self).__init__() def run(self): print(\"sub thread run\") currentThread = threading.currentThread() time.sleep(3) print(\"current subthread id : %s\\ncurrent subthread name : %s\\ncurrent subthread params : %s\" % ( currentThread.ident, currentThread.name, self.params)) if __name__ == \"__main__\": print(\"main thread run\") for item in range(3): subThreadIns = TaskClass(item) subThreadIns.start() print(\"main thread run end\") # main thread run # sub thread run # sub thread run # sub thread run # main thread run end # current subthread id : 123145495068672 # current subthread name : Thread-1 # current subthread params : 0 # current subthread id : 123145500323840 # current subthread name : Thread-2 # current subthread params : 1 # current subthread id : 123145505579008 # current subthread name : Thread-3 # current subthread params : 2 ❶：必须继承Threading类并调用父类的__init__()方法 ❷：传入的参数 源码浅析 为什么添加子线程有2种截然不同的方式呢？它们之间有什么区别？这些都可以从源码中找到答案。 我们从Thread类的实例看起，首先是__init__()方法（threading.py line 738 - 800），它主要做了一些初始化的准备工作： class Thread: _initialized = False _exc_info = _sys.exc_info def __init__(self, group=None, target=None, name=None, args=(), kwargs=None, *, daemon=None): # 如果group不是None，就会抛出断言异常 assert group is None, \"group argument must be None for now\" # 如果kwargs是None，则构造一个空字典 if kwargs is None: kwargs = {} # 传入的执行任务的函数或者None self._target = target # 线程名字 self._name = str(name or _newname()) # 任务函数传入的元组参数 self._args = args # 任务函数传入的关键字参数 self._kwargs = kwargs # 是否是守护线程启动，如果不是None则以守护线程模式启动 if daemon is not None: self._daemonic = daemon # 如果是None，则继承当前线程的守护模式 else: self._daemonic = current_thread().daemon # 线程编号 self._ident = None # 锁定状态，None self._tstate_lock = None # 一把Event事件锁 self._started = Event() # 是否停止运行的标志位 self._is_stopped = False # 初始化状态改为True self._initialized = True self._stderr = _sys.stderr _dangling.add(self) 参数释义： group：应该为None，为了日后扩展ThreadGroup类而保留的 target：传入一个可调用对象，即线程任务task，默认为None，即可以不进行传入 name：线程启动时将不再由系统分配线程名称，而是自定义，默认情况下，系统分配的线程名称会由 \"Thread-N\" 的格式构成一个唯一的名称，其中 N 是小的十进制数 args：用于调用目标函数的参数元组，默认是()空元组，你必须传入一个元组 kwargs：用于调用目标函数的关键字参数字典，默认是None，你必须传入一个字典 daemon：命名关键字参数，应当传入一个布尔值，默认为None，它会指定该线程是否是以守护线程模式启动，如果为None，该线程将继承当前线程的守护模式属性 接下来看start()方法，它是告知系统当前线程完成调度，可随时启用的方法（threading.py line 828 - 851）： def start(self): # 如果初始状态不为True，则抛出异常 if not self._initialized: raise RuntimeError(\"thread.__init__() not called\") # 判断当前线程是否被锁住，如果被锁住则抛出异常 if self._started.is_set(): raise RuntimeError(\"threads can only be started once\") with _active_limbo_lock: _limbo[self] = self try: # 执行引导 _start_new_thread(self._bootstrap, ()) except Exception: with _active_limbo_lock: del _limbo[self] raise self._started.wait() 这里关键是看self._bootstrap()方法，该该方法位于（threading.py line 870 - 888），看看它会做什么事情： def _bootstrap(self): try: self._bootstrap_inner() except: if self._daemonic and _sys is None: return raise 继续找self._bootstrap_inner()方法，该该方法位于（threading.py line 901 - 964）。 在该方法的916行时，它会执行run()方法： def _bootstrap_inner(self): ... try: # 执行run self.run() except SystemExit: pass except: ... 如果此时你按照第二种添加子线程的方式，则直接会运行被子类TaskClass覆写的run()方法。 如果是第一种添加子线程的方式，则还需要往里面看（threading.py line 835 - 868）： def run(self): try: # self._target = 我们自己传递的可调用对象task if self._target: self._target(*self._args, **self._kwargs) finally: del self._target, self._args, self._kwargs 至此可以发现，不管是使用哪一种方式添加子线程，都会运行5个方法。 所以说它们内部实现其实都是一样的，没什么特别的，也不要觉得它特别神奇。 threading模块方法大全 以下是threading模块提供的类或方法： 类或方法 描述 返回值 threading.Thread(target, args, kwargs) 创建并返回一个线程对象 threadObject threading.Timer(interval, function, args, kwargs) 创建并返回一个延迟启动的线程对象 threadObject threading.active_count() 获取当前进程下存活的线程数量 int threading.enumerate() 查看当前进程存活了的所有线程对象，以列表形式返回 [threadObject, ...] threading.main_thread() 获取主线程对象 threadObject threading.current_thread() 获取当前正在执行的线程对象 threadObject threading.currentThread() 获取当前正在执行的线程对象 threadObject threading.get_ident() 获取当前正在执行的线程对象的编号 int 下面我将使用该代码对上述功能进行演示： import threading import time class TaskClass(threading.Thread): def run(self): time.sleep(3) pass if __name__ == \"__main__\": for i in range(3): subThreadIns = TaskClass() subThreadIns.start() 1）获取当前进程下存活的线程数量： print(threading.active_count()) # 4 2）查看当前进程存活了的所有线程对象，以列表形式返回： print(threading.enumerate()) # [, , , ] 3）获取主线程对象： print(threading.main_thread()) # 4）获取当前正在执行的线程对象： print(threading.currentThread()) # 5）获取当前正在执行的线程对象的编号： print(threading.get_ident()) # 4380034496 threadObject方法大全 以下是针对线程对象提供的属性或者方法： 方法/属性 描述 返回值 threadObject.start() 通知系统该线程调度完毕，可以随时进行启动，一个线程对象只能运行一次该方法，若多次运行则抛出RunTimeError异常 ... threadObject.join(timeout=None) 主线程默认会等待子线程运行结束后再继续执行，timeou为等待的秒数，如不设置该参数则一直等待。 ... threadObject.getName() 获取线程对象的名字 str threadObject.setName(name) 设置线程对象的名字 None threadObject.is_alive() 查看线程对象是否存活 bool threadObject.isAlive() 查看线程对象是否存活，不推荐使用 bool threadObject.isDaemon() 查看线程对象是否是守护线程 bool threadObject.setDaemon() 设置线程对象为守护线程，主线程运行完毕之后设置为守护线程的子线程便立即结束执行 None threadObject.ident 获取线程对象的编号 int threadObject.name 获取或者设置线程对象的名字 str or None threadObject.daemon 查看线程对象是否是守护线程 bool 主线程阻塞 默认情况下，当子线程启动后，主线程会依旧往下运行而不是等待所有的子线程运行完毕后再继续往下运行。 如图所示，主线程在运行结束后并不会被理解kill掉，而是所有的子线程运行完毕后主线程才会被kill掉： 我们可以利用threadObject.join(timeout=None)来让主线程等待子线程运行完毕后再继续向下运行，timeout为等待的秒数，如不设置该参数则一直等待。 如图所示，这是没有设置timeout的示意图，主线程必须等待所有子线程运行完毕后再接着运行： 代码示例： import threading import time class TaskClass(threading.Thread): def run(self): thName = threading.current_thread().name print(\"%s start run\" % thName) time.sleep(3) print(\"%s run end\" % thName) if __name__ == \"__main__\": print(\"main thread start run\") threadLst = [] for i in range(3): threadLst.append(TaskClass()) for ins in threadLst: ins.start() # 开始运行所有子线程 for ins in threadLst: ins.join() # 让主线程等待所有子线程运行完毕后再接着运行，注意，设置主线程等待的子线程必须处于活跃状态 print(\"main thread carry on run\") print(\"main thread run end\") # main thread start run # Thread-1 start run # Thread-2 start run # Thread-3 start run # Thread-1 run end # Thread-2 run end # Thread-3 run end # main thread carry on run # main thread run end 守护线程 守护线程是指当主线程运行完毕后，子线程是否还要继续运行。 默认threadObject.setDaemon()为None，也就是False，即当前主线程运行完毕后，子线程依旧可以接着运行。 如果threadObject.setDaemon()为True，则当前主线程运行完毕后，子线程即使没有运行完毕也会结束运行。 代码示例： import threading import time class TaskClass(threading.Thread): def run(self): thName = threading.current_thread().name print(\"%s start run\" % thName) time.sleep(3) print(\"%s run end\" % thName) if __name__ == \"__main__\": print(\"main thread start run\") threadLst = [] for i in range(3): threadLst.append(TaskClass()) for ins in threadLst: # 注意，守护线程的设置必须在线程未启动时设置 ins.setDaemon(True) ins.start() print(\"main thread carry on run\") print(\"main thread run end\") # main thread start run # Thread-1 start run # Thread-2 start run # Thread-3 start run # main thread carry on run # main thread run end join()与setDaemon(True)共存 如果同时设置setDaemon(True)与join()方法会怎么样呢？有两种情况： join()方法没有设置timeout（没有设置即表示死等）或者timeout的时间比子线程作业时间要长，这代表子线程会死在主线程之前，setDaemon(True)也就没有了意义，即失效了 join()设置了timeout并且timeout的时间比子线程作业时间要短，这代表主线程会死在子线程之前，setDaemon(True)生效，子线程会跟着主线程一起死亡。 情况一： import threading import time class TaskClass(threading.Thread): def run(self): thName = threading.current_thread().name print(\"%s start run\" % thName) time.sleep(3) print(\"%s run end\" % thName) if __name__ == \"__main__\": subThread = TaskClass() subThread.setDaemon(True) # 主线程运行完后会立即终止子线程的运行。但是由于有join()，故不生效。 subThread.start() subThread.join() # 主线程必须等待子线程运行结束后再接着运行 print(\"main thread run end\") # Thread-1 start run # Thread-1 run end # main thread run end 情况2： import threading import time class TaskClass(threading.Thread): def run(self): thName = threading.current_thread().name print(\"%s start run\" % thName) time.sleep(3) print(\"%s run end\" % thName) if __name__ == \"__main__\": subThread = TaskClass() subThread.setDaemon(True) # 主线程运行完后会立即终止子线程的运行。但是由于有join()，故不生效。 subThread.start() subThread.join(1) # 主线程必须等待子线程运行结束后再接着运行，只等待1s print(\"main thread run end\") # Thread-1 start run # main thread run end 线程延迟启动 使用threading模块中提供的Timer类，可让子线程延迟启动，如下所示： import threading import time def task(): print(\"sub thread start run\") time.sleep(3) print(\"sub thread run end\") if __name__ == \"__main__\": print(\"main thread run\") t1 = threading.Timer(interval=3, function=task) t1.start() # 3秒后才启动子线程 t1.join() print(\"main thread run end\") # main thread run # sub thread start run # sub thread run end # main thread run end 如果要用类的形式，则可以继承threading.Timer()类，并修改self.function属性，个人极度不推荐这样做。 如下所示，在不知道某一个方法怎么使用时扒扒源码看一看，翻翻官方文档就大概能了解： import threading import time class TaskClass(threading.Timer): def __init__(self, *args, **kwargs): # 必须要修改function为你想执行的方法 super(__class__, self).__init__(*args, **kwargs) self.function = self.task def task(self, x, y): print(\"sub thread start run\") time.sleep(3) print(\"parmas %s %s\" % (x, y)) print(\"sub thread run end\") if __name__ == \"__main__\": # 必须传入一个None t1 = TaskClass(interval=3, function=None, args=(1, 2)) t1.start() t1.join() print(\"main thread run end\") # sub thread start run # parmas 1 2 # sub thread run end # main thread run end 多线程编程应用场景 由于GIL锁的存在，Python中对于I/O操作来说可以使用多线程编程，如果是计算密集型的操作则不应该使用多线程进行处理，因为没有I/O操作就不能通过I/O切换来执行其他线程，故对于计算密集型的操作来说多线程没有什么优势，甚至还可能比普通串行还慢（因为涉及到线程切换，虽然是毫秒级别，但是计算的数值越大这个切换也就越密集，GIL锁是100个CPU指令切换一次的） 注意：我们是在Python2版本下进行此次测试，Python3版本确实相差不大，但是，从本质上来说依然是这样的。 计算密集型程序的普通串行运行时间： import threading import time num = 0 def add(): global num for i in range(10000000): # 一千万次 num += 1 def sub(): global num for i in range(10000000): # 一千万次 num -= 1 if __name__ == '__main__': start_time = time.time() add() sub() end_time = time.time() print(\"执行时间:\",end_time - start_time) # ==== 执行结果 ==== 三次采集 \"\"\" 大约在 1.3 - 1.4 秒 \"\"\" 计算密集型程序的多线程并发运行时间： # coding:utf-8 import threading import time num = 0 def add(): global num for i in range(10000000): # 一千万次 num += 1 def sub(): global num for i in range(10000000): # 一千万次 num -= 1 if __name__ == '__main__': start_time = time.time() t1 = threading.Thread(target=add,) t2 = threading.Thread(target=sub,) t1.start() t2.start() t1.join() t2.join() end_time = time.time() print(u\"执行时间:\",end_time - start_time) # ==== 执行结果 ==== 三次采集 \"\"\" 大约 4 - 5 秒 \"\"\" Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-07-02 21:02:03 "},"Python/Python并发编程/threading线程锁.html":{"url":"Python/Python并发编程/threading线程锁.html","title":"threading线程锁","keywords":"","body":"前言 本章节将继续围绕threading模块讲解，基本上是纯理论偏多。 对于日常开发者来讲很少会使用到本章节的内容，但是对框架作者等是必备知识，同时也是高频的面试常见问题。 官方文档 线程安全 线程安全是多线程或多进程编程中的一个概念，在拥有共享数据的多条线程并行执行的程序中，线程安全的代码会通过同步机制保证各个线程都可以正常且正确的执行，不会出现数据污染等意外情况。 线程安全的问题最主要还是由线程切换导致的，比如一个房间（进程）中有10颗糖（资源），除此之外还有3个小人（1个主线程、2个子线程），当小人A吃了3颗糖后被系统强制进行休息时他认为还剩下7颗糖，而当小人B工作后又吃掉了3颗糖，那么当小人A重新上岗时会认为糖还剩下7颗，但是实际上只有4颗了。 上述例子中线程A和线程B的数据不同步，这就是线程安全问题，它可能导致非常严重的意外情况发生，我们按下面这个示例来进行说明。 下面有一个数值num初始值为0，我们开启2条线程： 线程1对num进行一千万次+1的操作 线程2对num进行一千万次-1的操作 结果可能会令人咋舌，num最后并不是我们所想象的结果0： import threading num = 0 def add(): global num for i in range(10_000_000): num += 1 def sub(): global num for i in range(10_000_000): num -= 1 if __name__ == \"__main__\": subThread01 = threading.Thread(target=add) subThread02 = threading.Thread(target=sub) subThread01.start() subThread02.start() subThread01.join() subThread02.join() print(\"num result : %s\" % num) # 结果三次采集 # num result : 669214 # num result : -1849179 # num result : -525674 上面这就是一个非常好的案例，想要解决这个问题就必须通过锁来保障线程切换的时机。 需要我们值得留意的是，在Python基本数据类型中list、tuple、dict本身就是属于线程安全的，所以如果有多个线程对这3种容器做操作时，我们不必考虑线程安全问题。 　　 锁的作用 锁是Python提供给我们能够自行操控线程切换的一种手段，使用锁可以让线程的切换变的有序。 一旦线程的切换变的有序后，各个线程之间对数据的访问、修改就变的可控，所以若要保证线程安全，就必须使用锁。 threading模块中提供了5种最常见的锁，下面是按照功能进行划分： 同步锁：lock（一次只能放行一个） 递归锁：rlock（一次只能放行一个） 条件锁：condition（一次可以放行任意个） 事件锁：event（一次全部放行） 信号量锁：semaphore（一次可以放行特定个） Lock() 同步锁 基本介绍 Lock锁的称呼有很多，如： 同步锁 互斥锁 它们是什么意思呢？如下所示： 互斥指的是某一资源同一时刻仅能有一个访问者对其进行访问，具有唯一性和排他性，但是互斥无法限制访问者对资源的访问顺序，即访问是无序的 同步是指在互斥的基础上（大多数情况），通过其他机制实现访问者对资源的有序访问 同步其实已经实现了互斥，是互斥的一种更为复杂的实现，因为它在互斥的基础上实现了有序访问的特点 下面是threading模块与同步锁提供的相关方法： 方法 描述 threading.Lock() 返回一个同步锁对象 lockObject.acquire(blocking=True, timeout=1) 上锁，当一个线程在执行被上锁代码块时，将不允许切换到其他线程运行，默认锁失效时间为1秒 lockObject.release() 解锁，当一个线程在执行未被上锁代码块时，将允许系统根据策略自行切换到其他线程中运行 lockObject.locaked() 判断该锁对象是否处于上锁状态，返回一个布尔值 使用方式 同步锁一次只能放行一个线程，一个被加锁的线程在运行时不会将执行权交出去，只有当该线程被解锁时才会将执行权通过系统调度交由其他线程。 如下所示，使用同步锁解决最上面的问题： import threading num = 0 def add(): lock.acquire() global num for i in range(10_000_000): num += 1 lock.release() def sub(): lock.acquire() global num for i in range(10_000_000): num -= 1 lock.release() if __name__ == \"__main__\": lock = threading.Lock() subThread01 = threading.Thread(target=add) subThread02 = threading.Thread(target=sub) subThread01.start() subThread02.start() subThread01.join() subThread02.join() print(\"num result : %s\" % num) # 结果三次采集 # num result : 0 # num result : 0 # num result : 0 这样这个代码就完全变成了串行的状态，对于这种计算密集型I/O业务来说，还不如直接使用串行化单线程执行来得快，所以这个例子仅作为一个示例，不能概述锁真正的用途。 死锁现象 对于同步锁来说，一次acquire()必须对应一次release()，不能出现连续重复使用多次acquire()后再重复使用多次release()的操作，这样会引起死锁造成程序的阻塞，完全不动了，如下所示： import threading num = 0 def add(): lock.acquire() # 上锁 lock.acquire() # 死锁 # 不执行 global num for i in range(10_000_000): num += 1 lock.release() lock.release() def sub(): lock.acquire() # 上锁 lock.acquire() # 死锁 # 不执行 global num for i in range(10_000_000): num -= 1 lock.release() lock.release() if __name__ == \"__main__\": lock = threading.Lock() subThread01 = threading.Thread(target=add) subThread02 = threading.Thread(target=sub) subThread01.start() subThread02.start() subThread01.join() subThread02.join() print(\"num result : %s\" % num) with语句 由于threading.Lock()对象中实现了__enter__()与__exit__()方法，故我们可以使用with语句进行上下文管理形式的加锁解锁操作： import threading num = 0 def add(): with lock: # 自动加锁 global num for i in range(10_000_000): num += 1 # 自动解锁 def sub(): with lock: # 自动加锁 global num for i in range(10_000_000): num -= 1 # 自动解锁 if __name__ == \"__main__\": lock = threading.Lock() subThread01 = threading.Thread(target=add) subThread02 = threading.Thread(target=sub) subThread01.start() subThread02.start() subThread01.join() subThread02.join() print(\"num result : %s\" % num) # 结果三次采集 # num result : 0 # num result : 0 # num result : 0 RLock() 递归锁 基本介绍 递归锁是同步锁的一个升级版本，在同步锁的基础上可以做到连续重复使用多次acquire()后再重复使用多次release()的操作，但是一定要注意加锁次数和解锁次数必须一致，否则也将引发死锁现象。 下面是threading模块与递归锁提供的相关方法： 方法 描述 threading.RLock() 返回一个递归锁对象 lockObject.acquire(blocking=True, timeout=1) 上锁，当一个线程在执行被上锁代码块时，将不允许切换到其他线程运行，默认锁失效时间为1秒 lockObject.release() 解锁，当一个线程在执行未被上锁代码块时，将允许系统根据策略自行切换到其他线程中运行 lockObject.locaked() 判断该锁对象是否处于上锁状态，返回一个布尔值 使用方式 以下是递归锁的简单使用，下面这段操作如果使用同步锁则会发生死锁现象，但是递归锁不会： import threading num = 0 def add(): lock.acquire() lock.acquire() global num for i in range(10_000_000): num += 1 lock.release() lock.release() def sub(): lock.acquire() lock.acquire() global num for i in range(10_000_000): num -= 1 lock.release() lock.release() if __name__ == \"__main__\": lock = threading.RLock() subThread01 = threading.Thread(target=add) subThread02 = threading.Thread(target=sub) subThread01.start() subThread02.start() subThread01.join() subThread02.join() print(\"num result : %s\" % num) # 结果三次采集 # num result : 0 # num result : 0 # num result : 0 with语句 由于threading.RLock()对象中实现了__enter__()与__exit__()方法，故我们可以使用with语句进行上下文管理形式的加锁解锁操作： import threading num = 0 def add(): with lock: # 自动加锁 global num for i in range(10_000_000): num += 1 # 自动解锁 def sub(): with lock: # 自动加锁 global num for i in range(10_000_000): num -= 1 # 自动解锁 if __name__ == \"__main__\": lock = threading.RLock() subThread01 = threading.Thread(target=add) subThread02 = threading.Thread(target=sub) subThread01.start() subThread02.start() subThread01.join() subThread02.join() print(\"num result : %s\" % num) # 结果三次采集 # num result : 0 # num result : 0 # num result : 0 Condition() 条件锁 基本介绍 条件锁是在递归锁的基础上增加了能够暂停线程运行的功能。并且我们可以使用wait()与notify()来控制线程执行的个数。 注意：条件锁可以自由设定一次放行几个线程。 下面是threading模块与条件锁提供的相关方法： 方法 描述 threading.Condition() 返回一个条件锁对象 lockObject.acquire(blocking=True, timeout=1) 上锁，当一个线程在执行被上锁代码块时，将不允许切换到其他线程运行，默认锁失效时间为1秒 lockObject.release() 解锁，当一个线程在执行未被上锁代码块时，将允许系统根据策略自行切换到其他线程中运行 lockObject.wait(timeout=None) 将当前线程设置为“等待”状态，只有该线程接到“通知”或者超时时间到期之后才会继续运行，在“等待”状态下的线程将允许系统根据策略自行切换到其他线程中运行 lockObject.wait_for(predicate, timeout=None) 将当前线程设置为“等待”状态，只有该线程的predicate返回一个True或者超时时间到期之后才会继续运行，在“等待”状态下的线程将允许系统根据策略自行切换到其他线程中运行。注意：predicate参数应当传入一个可调用对象，且返回结果为bool类型 lockObject.notify(n=1) 通知一个当前状态为“等待”的线程继续运行，也可以通过参数n通知多个 lockObject.notify_all() 通知所有当前状态为“等待”的线程继续运行 使用方式 下面这个案例会启动10个子线程，并且会立即将10个子线程设置为等待状态。 然后我们可以发送一个或者多个通知，来恢复被等待的子线程继续运行： import threading currentRunThreadNumber = 0 maxSubThreadNumber = 10 def task(): global currentRunThreadNumber thName = threading.currentThread().name condLock.acquire() # 上锁 print(\"start and wait run thread : %s\" % thName) condLock.wait() # 暂停线程运行、等待唤醒 currentRunThreadNumber += 1 print(\"carry on run thread : %s\" % thName) condLock.release() # 解锁 if __name__ == \"__main__\": condLock = threading.Condition() for i in range(maxSubThreadNumber): subThreadIns = threading.Thread(target=task) subThreadIns.start() while currentRunThreadNumber with语句 由于threading.Condition()对象中实现了__enter__()与__exit__()方法，故我们可以使用with语句进行上下文管理形式的加锁解锁操作： import threading currentRunThreadNumber = 0 maxSubThreadNumber = 10 def task(): global currentRunThreadNumber thName = threading.currentThread().name with condLock: print(\"start and wait run thread : %s\" % thName) condLock.wait() # 暂停线程运行、等待唤醒 currentRunThreadNumber += 1 print(\"carry on run thread : %s\" % thName) if __name__ == \"__main__\": condLock = threading.Condition() for i in range(maxSubThreadNumber): subThreadIns = threading.Thread(target=task) subThreadIns.start() while currentRunThreadNumber Event() 事件锁 基本介绍 事件锁是基于条件锁来做的，它与条件锁的区别在于一次只能放行全部，不能放行任意个数量的子线程继续运行。 我们可以将事件锁看为红绿灯，当红灯时所有子线程都暂停运行，并进入“等待”状态，当绿灯时所有子线程都恢复“运行”。 下面是threading模块与事件锁提供的相关方法： 方法 描述 threading.Event() 返回一个事件锁对象 lockObject.clear() 将事件锁设为红灯状态，即所有线程暂停运行 lockObject.is_set() 用来判断当前事件锁状态，红灯为False，绿灯为True lockObject.set() 将事件锁设为绿灯状态，即所有线程恢复运行 lockObject.wait(timeout=None) 将当前线程设置为“等待”状态，只有该线程接到“绿灯通知”或者超时时间到期之后才会继续运行，在“等待”状态下的线程将允许系统根据策略自行切换到其他线程中运行 使用方式 事件锁不能利用with语句来进行使用，只能按照常规方式。 如下所示，我们来模拟线程和红绿灯的操作，红灯停，绿灯行： import threading maxSubThreadNumber = 3 def task(): thName = threading.currentThread().name print(\"start and wait run thread : %s\" % thName) eventLock.wait() # 暂停运行，等待绿灯 print(\"green light, %s carry on run\" % thName) print(\"red light, %s stop run\" % thName) eventLock.wait() # 暂停运行，等待绿灯 print(\"green light, %s carry on run\" % thName) print(\"sub thread %s run end\" % thName) if __name__ == \"__main__\": eventLock = threading.Event() for i in range(maxSubThreadNumber): subThreadIns = threading.Thread(target=task) subThreadIns.start() eventLock.set() # 设置为绿灯 eventLock.clear() # 设置为红灯 eventLock.set() # 设置为绿灯 # start and wait run thread : Thread-1 # start and wait run thread : Thread-2 # start and wait run thread : Thread-3 # green light, Thread-1 carry on run # red light, Thread-1 stop run # green light, Thread-1 carry on run # sub thread Thread-1 run end # green light, Thread-3 carry on run # red light, Thread-3 stop run # green light, Thread-3 carry on run # sub thread Thread-3 run end # green light, Thread-2 carry on run # red light, Thread-2 stop run # green light, Thread-2 carry on run # sub thread Thread-2 run end Semaphore() 信号量锁 基本介绍 信号量锁也是根据条件锁来做的，它与条件锁和事件锁的区别如下： 条件锁：一次可以放行任意个处于“等待”状态的线程 事件锁：一次可以放行全部的处于“等待”状态的线程 信号量锁：通过规定，成批的放行特定个处于“上锁”状态的线程 下面是threading模块与信号量锁提供的相关方法： 方法 描述 threading.Semaphore() 返回一个信号量锁对象 lockObject.acquire(blocking=True, timeout=1) 上锁，当一个线程在执行被上锁代码块时，将不允许切换到其他线程运行，默认锁失效时间为1秒 lockObject.release() 解锁，当一个线程在执行未被上锁代码块时，将允许系统根据策略自行切换到其他线程中运行 使用方式 以下是使用示例，你可以将它当做一段限宽的路段，每次只能放行相同数量的线程： import threading import time maxSubThreadNumber = 6 def task(): thName = threading.currentThread().name semaLock.acquire() print(\"run sub thread %s\" % thName) time.sleep(3) semaLock.release() if __name__ == \"__main__\": # 每次只能放行2个 semaLock = threading.Semaphore(2) for i in range(maxSubThreadNumber): subThreadIns = threading.Thread(target=task) subThreadIns.start() # run sub thread Thread-1 # run sub thread Thread-2 # run sub thread Thread-3 # run sub thread Thread-4 # run sub thread Thread-6 # run sub thread Thread-5 with语句 由于threading.Semaphore()对象中实现了__enter__()与__exit__()方法，故我们可以使用with语句进行上下文管理形式的加锁解锁操作： import threading import time maxSubThreadNumber = 6 def task(): thName = threading.currentThread().name with semaLock: print(\"run sub thread %s\" % thName) time.sleep(3) if __name__ == \"__main__\": semaLock = threading.Semaphore(2) for i in range(maxSubThreadNumber): subThreadIns = threading.Thread(target=task) subThreadIns.start() 锁关系浅析 上面5种锁可以说都是基于同步锁来做的，这些你都可以从源码中找到答案。 首先来看RLock递归锁，递归锁的实现非常简单，它的内部会维护着一个计数器，当计数器不为0的时候该线程不能被I/O操作和时间轮询机制切换。但是当计数器为0的时候便不会如此了： def __init__(self): self._block = _allocate_lock() self._owner = None self._count = 0 # 计数器 而Condition条件锁的内部其实是有两把锁的，一把底层锁（同步锁）一把高级锁(递归锁)。 低层锁的解锁方式有两种，使用wait()方法会暂时解开底层锁同时加上一把高级锁，只有当接收到别的线程里的notfiy()后才会解开高级锁和重新上锁低层锁，也就是说条件锁底层是根据同步锁和递归锁的不断切换来进行实现的： def __init__(self, lock=None): if lock is None: lock = RLock() # 可以看到条件锁的内部是基于递归锁，而递归锁又是基于同步锁来做的 self._lock = lock self.acquire = lock.acquire self.release = lock.release try: self._release_save = lock._release_save except AttributeError: pass try: self._acquire_restore = lock._acquire_restore except AttributeError: pass try: self._is_owned = lock._is_owned except AttributeError: pass self._waiters = _deque() Event事件锁内部是基于条件锁来做的： class Event: def __init__(self): self._cond = Condition(Lock()) # 实例化出了一个条件锁。 self._flag = False def _reset_internal_locks(self): # private! called by Thread._reset_internal_locks by _after_fork() self._cond.__init__(Lock()) def is_set(self): \"\"\"Return true if and only if the internal flag is true.\"\"\" return self._flag isSet = is_set Semaphore信号量锁内部也是基于条件锁来做的： class Semaphore: def __init__(self, value=1): if value = 0\") self._cond = Condition(Lock()) # 可以看到，这里是实例化出了一个条件锁 self._value = value 基本练习题 条件锁的应用 需求：一个空列表，两个线程轮番往里面加值（一个加偶数，一个加奇数），最终让该列表中的值为 1 - 100 ，且是有序排列的。 import threading def even(): \"\"\"加偶数\"\"\" with condLock: # 必须先启动加奇数 condLock.wait() for i in range(2, 101, 2): lst.append(i) condLock.notify() condLock.wait() def odd(): \"\"\"加奇数\"\"\" with condLock: for i in range(1, 101, 2): lst.append(i) condLock.notify() condLock.wait() condLock.notify() if __name__ == \"__main__\": lst = [] condLock = threading.Condition() addEvenTask = threading.Thread(target=even) addOddTask = threading.Thread(target=odd) addEvenTask.start() addOddTask.start() addEvenTask.join() addOddTask.join() print(lst) 事件锁的应用 有2个任务线程来扮演李白和杜甫，如何让他们一人一句进行对答？文本如下： 杜甫：老李啊，来喝酒！ 李白：老杜啊，不喝了我喝不下了！ 杜甫：老李啊，再来一壶？ 杜甫：...老李？ 李白：呼呼呼...睡着了.. 代码如下： import threading def libai(): event.wait() print(\"李白：老杜啊，不喝了我喝不下了！\") event.set() event.clear() event.wait() print(\"李白：呼呼呼...睡着了..\") def dufu(): print(\"杜甫：老李啊，来喝酒！\") event.set() event.clear() event.wait() print(\"杜甫：老李啊，再来一壶？\") print(\"杜甫：...老李？\") event.set() if __name__ == '__main__': event = threading.Event() t1 = threading.Thread(target=libai) t2 = threading.Thread(target=dufu) t1.start() t2.start() t1.join() t2.join() Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-07-03 15:00:49 "},"Python/Python并发编程/threading.local功能介绍.html":{"url":"Python/Python并发编程/threading.local功能介绍.html","title":"threading.local功能介绍","keywords":"","body":"threading.local() threading.local()方法可以让每个线程都拥有一些自己独立的数据，这些数据是其他线程访问不到的。 如图所示： 或者用另外一种更形象的比喻更加的贴切，将一个进程比喻成一个公司，该进程下的线程比喻成公司的员工，而将threading.local()比喻为公司的储物柜，每个员工都有一个单独的柜格，且每个员工也只能访问自己的柜格。 如图所示： 那么这个东西到底有什么作用？举个例子，当你使用迅雷进行多线程下载时，每个线程的下载进度是不一样的，那么这个下载进度如何进行存储就显得尤为重要。 数据的存储一定是方便数据的取出，存储结构做的好，查找取出数据的速度才会更快。 threading.local()的设计思想其实在flask框架的上下文管理机制中也会体现到，两者基本如出一辙，所以现在了解threading.local()的原理后对flask框架的源码阅读也会变得轻松。 基本使用 下面是基本使用，使用步骤如下： 储物柜 = threading.local() 在线程下使用 储物柜.物品名称 = 物品 即可，以后对于该物品只有该线程可以获取 获取或者使用时，直接使用 储物柜.物品名称 即可，若要获取的物品不是该线程存放的，则会抛出异常 示例案例： import threading def jack(article): locker.rose = article print(locker.rose) # 正常取出 print(locker.food) # 抛出异常 def ken(article): locker.food = article print(locker.food) # 正常取出 print(locker.rose) # 抛出异常 if __name__ == \"__main__\": locker = threading.local() jackTask = threading.Thread(target=jack, args=(\"rose\",)) kenTask = threading.Thread(target=ken, args=(\"food\",)) jackTask.start() kenTask.start() # rose # AttributeError: '_thread._local' object has no attribute 'food' # food # AttributeError: '_thread._local' object has no attribute 'rose' 原理分析 我们可以自己做一个全局字典，来实现类似的功能，字典格式如下： locker = { \"线程ID\" : {\"物品名称\" : \"物品本身\"}, \"线程ID\" : {\"物品名称\" : \"物品本身\"}, \"线程ID\" : {\"物品名称\" : \"物品本身\"}, } 如下所示： import threading def task(article): thId = threading.get_ident() # 开始存放东西 locker[thId] = { \"rose\": article } # 取出东西 print(locker[thId][\"rose\"]) if __name__ == \"__main__\": locker = {} subThreadIns = threading.Thread(target=task, args=(\"rose\",)) subThreadIns.start() # rose 代码优化 上面这样存取东西是不是显得特别麻烦？所以我们可以定义一个类，让这个储物柜的操作变的更加简单。 如下所示： import threading class Locker: locker = {} def __getattr__(self, name): \"\"\"当试图使用.访问对象属性且找不到该属性时触发该方法\"\"\" ident = threading.get_ident() return __class__.locker[ident][name] def __setattr__(self, name, value): \"\"\"当试图使用.修改或添加对象属性时触发该方法\"\"\" ident = threading.get_ident() if ident not in __class__.locker: __class__.locker[ident] = {} __class__.locker[ident].update({name: value}) def task(article): # 开始存放东西 locker.rose = article print(locker.rose) if __name__ == \"__main__\": locker = Locker() subThreadIns = threading.Thread(target=task, args=(\"rose\",)) subThreadIns.start() # rose Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-07-02 16:55:52 "},"Python/Python并发编程/multiprocessing模块使用.html":{"url":"Python/Python并发编程/multiprocessing模块使用.html","title":"multiprocessing模块使用","keywords":"","body":"multiprocessing模块 Python中提供了multiprocessing模块来实现进程并发编程，官方文档如下： 官方文档 由于GIL锁的存在，所以CPython中多线程是不能够并行运行的，但是多进程可以并行运行，该模块用到的地方基本很少，但是仍然需要进行掌握。 此外，它和threading模块99%的接口都一模一样，只有少量的差别。 添加子进程 针对不同平台选择添加子进程的方式 multiprocessing模块针对不同的平台，添加子进程的方式也有所区别： spawn：该方式是Windows平台下的默认方式，它会创建一个新的解释器进程，速度比较慢 fork：该方式是Unix平台下的默认方式，内部会通过os.fork()产生一个新的解释器分叉 需要注意的是，如果平台是Windows，则必须将启动代码书写到if __name__ == \"__main__”语句的下面，否则将会抛出异常。 如何指定新进程的启动方式？示例如下： import multiprocessing if __name__ == \"__main__\": multiprocessing.set_start_method(\"fork\") 实例化Process类 使用该方式新增子线程任务是比较常见的，也是推荐使用的。 简单的代码示例如下，创建3个子进程并向其添加任务，然后运行并打印它们的PID和进程名字： import multiprocessing import time def task(params): print(\"sub process run\") currentThread = multiprocessing.current_process() time.sleep(3) print(\"current subProcess id : %s\\ncurrent sub process name : %s\\ncurrent sub process params : %s\" % ( currentThread.ident, currentThread.name, params)) if __name__ == \"__main__\": print(\"main Process run\") for item in range(3): subProcessIns = multiprocessing.Process(target=task, args=(item, )) subProcessIns.start() print(\"main Process run end\") # main Process run # main Process run end # sub process run # current subProcess id : 7761 # current sub process name : Process-1 # current sub process params : 0 # sub process run # current subProcess id : 7762 # current sub process name : Process-2 # current sub process params : 1 # sub process run # current subProcess id : 7763 # current sub process name : Process-3 # current sub process params : 2 自定义类覆写run()方法 上面的子进程任务对象是一个全局函数，我们也可以将它作为方法来进行调用。 书写一个类并继承Process类，覆写run()方法即可： import multiprocessing import time class TaskClass(multiprocessing.Process): def __init__(self, params): self.params = params super(__class__, self).__init__() def run(self): print(\"sub process run\") currentProcess = multiprocessing.current_process() time.sleep(3) print(\"current sub process id : %s\\ncurrent sub process name : %s\\ncurrent sub process params : %s\" % ( currentProcess.ident, currentProcess.name, self.params)) if __name__ == \"__main__\": print(\"main process run\") for item in range(3): subThreadIns = TaskClass(item) subThreadIns.start() print(\"main process run end\") # main process run # main process run end # sub process run # current sub process id : 7800 # current sub process name : TaskClass-1 # current sub process params : 0 # sub process run # current sub process id : 7801 # current sub process name : TaskClass-2 # current sub process params : 1 # sub process run # current sub process id : 7802 # current sub process name : TaskClass-3 # current sub process params : 2 multiprocessing模块方法大全 以下是multiprocessing模块提供的类或方法： 类或方法 描述 返回值 multiprocessing.Process(target, args, kwargs) 创建并返回一个进程对象 processObject multiprocessing.active_children() 查看当前进程下的所有子进程对象，以列表形式返回 [processObject, ...] multiprocessing.current_process() 获取当前的进程对象 processObject 以下是好伙伴os模块所提供的2个方法： 方法 描述 返回值 os.getpid() 返回当前进程pid int os.getppid() 返回当前进程的父进程的pid int processObject方法大全 以下是针对进程对象提供的属性或者方法： 方法/属性 描述 返回值 processObject.start() 通知系统该进程调度完毕，可以随时进行启动，一个进程对象只能运行一次该方法，若多次运行则抛出RunTimeError异常 ... processObject.join(timeout=None) 主进程默认会等待子进程运行结束后再继续执行，timeou为等待的秒数，如不设置该参数则一直等待。 ... processObject.close() 关闭进程 ... processObject.terminate() 终止进程 ... processObject.kill() 终止进程 ... processObject.is_alive() 查看进程对象是否存活 bool processObject.ident 获取进程对象的编号 int processObject.pid 获取进程对象的编号 processObject.name 获取或者设置进程对象的名字 str or None processObject.daemon 查看进程对象是守护进程 bool processObject.exitcode 子进程的退出代码。如果进程尚未终止，这将是None。负值 -N 表示子进程被信号 N 终止 int processObject.authkey 获取进程的身份验证密码 bytes 守护进程示例 multiprocessing模块的守护进程和threading的守护线程设置有所不同。 它是通过赋值来进行设置的，如下所示： import multiprocessing import time class TaskClass(multiprocessing.Process): def run(self): pName = multiprocessing.current_process().name print(\"%s start run\" % pName) time.sleep(3) print(\"%s run end\" % pName) if __name__ == \"__main__\": print(\"main process start run\") processLst = [] for i in range(3): processLst.append(TaskClass()) for ins in processLst: # 注意，守护进程的设置必须在进程未启动时设置 ins.daemon = True ins.start() print(\"main process carry on run\") print(\"main process run end\") # main process start run # TaskClass-1 start run # main process carry on run # main process run end multiprocessing与threading模块异同 　　1.创建子进程的方式针对不同平台有着差异化 　　2.关于守护线程的设置接口是setDaemon(True)，而关于守护进程的接口是deamon = True 　　3.multiprocessing模块下的获取进程名与设置进程名没有threading模块下的getName()和setName()，而是直接采取属性name进行操作 锁的使用 multiprocessing模块中锁的接口和使用与threading中锁的接口和使用一致。 所以这里仅介绍一个lock锁即可： import multiprocessing num = 0 def add(): lock.acquire() global num for i in range(10_000_000): num += 1 lock.release() def sub(): lock.acquire() global num for i in range(10_000_000): num -= 1 lock.release() if __name__ == \"__main__\": lock = multiprocessing.Lock() subProcess01 = multiprocessing.Process(target=add) subProcess02 = multiprocessing.Process(target=sub) subProcess01.start() subProcess02.start() subProcess01.join() subProcess02.join() print(\"num result : %s\" % num) # 结果三次采集 # num result : 0 # num result : 0 # num result : 0 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-07-03 15:05:48 "},"Python/Python并发编程/线程或进程通信.html":{"url":"Python/Python并发编程/线程或进程通信.html","title":"线程或进程通信","keywords":"","body":"线程或进程通信 在同一个进程中，该进程下的所有数据资源都会被该进程下的线程共享。 为了保证数据安全性，我们在多个线程进行数据交互时必须使用一种线程安全的容器来承载交互信息。 如，常见的Redis数据库、MQ等消息中间件是非常好的选择。 当然，多进程也是如此。 但是在实际的测试环境中，我们需要更加方便的一些工具来测试代码是否准确，这时候就会用到下面介绍的工具了。 多线程通信 queue queue模块对于多线程通信来讲是十分明智的选择，它使用简单开箱即用，最关键的一点是它是Python的内置模块，故不用经历任何额外的下载、安装过程。 官方文档 queue本身是线程安全的，它其实就是管道 + 锁的组合，它提供了3种队列供用户使用： queue.Queue：先进先出队列 queue.LifoQueue：后进先出队列 quque.PriorityQueue：优先级队列 以下是queue模块各个队列中提供的常见方法： 方法 描述 Queue.qsize() 返回当前队列的大小 Queue.empty() 判断当前队列是否为空 Queue.full() 判断当前队列是否已满 Queue.put(item, block=True, timeout=None) 将item放入队列中，如果block为True，则队列已满时进行阻塞，timeout为阻塞超时时间，超过该时间后抛出Full的异常 Queue.put_nowait(item) 相当于Queue.put(item, block=False, timeout=None)，将item放入队列时一旦队列已满就立即抛出Full的异常 Queue.get(block=True, timeout=None) 从队列中取出项目，如果block为True，则队列为空时进行阻塞，timeout为阻塞超时时间，超过该时间后抛出Empty的异常 Queue.get_nowait() 相当于Queue.get(block=False, timeout=None)，从队列中取出项目时一旦队列为空就立即抛出Empty的异常 Queue.join() 阻塞队列，此时队列中不可取出任何数据 Queue.task_done() 通知取消阻塞队列，此时队列中可取出数据 先进先出队列 以下是先进先出队列的简单使用： import queue q = queue.Queue() # 可指定maxsize参数，定义当前队列的容量 q.put(1) q.put(2) q.put(3) print(q.get()) print(q.get()) print(q.get()) # 1 # 2 # 3 后进先出队列 以下是后进先出队列的简单使用： import queue q = queue.LifoQueue() # 可指定maxsize参数，定义当前队列的容量 q.put(1) q.put(2) q.put(3) print(q.get()) print(q.get()) print(q.get()) # 3 # 2 # 1 优先级队列 以下是优先级队列的简单使用，出队时优先级较小的先出队： import queue q = queue.PriorityQueue() # 可指定maxsize参数，定义当前队列的容量 q.put([10, \"A\"]) # [优先级, 数据项] q.put([50, \"B\"]) q.put([30, \"C\"]) print(q.get()) print(q.get()) print(q.get()) # [10, 'A'] # [30, 'C'] # [50, 'B'] 队列阻塞 下面是队列阻塞方法Queue.join()和Queue.task_done()的示例： import threading import queue def putTask(article): name = \"Ken\" # 放入玫瑰 q.put(article) print(\"%s put %s\" % (name, article)) # 通知对面可以取了 q.task_done() def getTask(): name = \"Jack\" # 如果先启动该线程，则会阻塞进行等待对吗的task_done()进行通知 q.join() # 取出玫瑰 print(\"%s get %s\" % (name, q.get())) if __name__ == \"__main__\": q = queue.Queue() gT = threading.Thread(target=getTask) pT = threading.Thread(target=putTask, args=(\"rose\", )) gT.start() pT.start() # Ken put rose # Jack get rose 内部原理图示 由于多线程都在一个进程中，故queue这个队列是共享的，任意该进程下的线程都能自由的对其进行数据项的读取。 如下图所示： 多进程通信 multiprocessing.Queue 多进程通信时不可使用普通的queue模块所提供的队列，而必须多进程模块multiprocessing所提供的Queue。 这个进程队列是没有提供task_done()方法与join()方法的，如果你想使用这2个方法，则可以导入multiprocessing.JoinableQueue这个队列。 以下是multiprocessing.Queue()所提供的方法： 方法 描述 Queue.qsize() 返回当前队列的大小 Queue.empty() 判断当前队列是否为空 Queue.full() 判断当前队列是否已满 Queue.put(item, block=True, timeout=None) 将item放入队列中，如果block为True，则队列已满时进行阻塞，timeout为阻塞超时时间，超过该时间后抛出Full的异常 Queue.put_nowait(item) 相当于Queue.put(item, block=False, timeout=None)，将item放入队列时一旦队列已满就立即抛出Full的异常 Queue.get(block=True, timeout=None) 从队列中取出项目，如果block为True，则队列为空时进行阻塞，timeout为阻塞超时时间，超过该时间后抛出Empty的异常 Queue.get_nowait() 相当于Queue.get(block=False, timeout=None)，从队列中取出项目时一旦队列为空就立即抛出Empty的异常 Queue.close() 关闭队列，该队列将变得不可put() Queue.join_thread() 等待后台线程。这个方法仅在调用了 close()方法之后可用。这会阻塞当前进程，直到后台线程退出，确保所有缓冲区中的数据都被写入管道中 Queue.cancel_join_thread() 防止 join_thread() 方法阻塞当前进程。具体而言，这防止进程退出时自动等待后台线程退出。详见 join_thread() 方法 个人还是推荐使用multiprocessing.JoinableQueue这个队列，因为它比multiprocessing.Queue强大一点。 需要注意的是，不管是multiprocessing.Queue还是multiprocessing.JoinableQueue，它们都是先进先出队列。 队列阻塞 以下是使用multiprocessing.JoinableQueue实现的队列阻塞： import multiprocessing import queue def putTask(article): name = \"Ken\" # 放入玫瑰 q.put(article) print(\"%s put %s\" % (name, article)) # 通知对面可以取了 q.task_done() def getTask(): name = \"Jack\" # 如果先启动该线程，则会阻塞进行等待对吗的task_done()进行通知 q.join() # 取出玫瑰 print(\"%s get %s\" % (name, q.get())) if __name__ == \"__main__\": q = multiprocessing.JoinableQueue() gT = multiprocessing.Process(target=getTask) pT = multiprocessing.Process(target=putTask, args=(\"rose\", )) gT.start() pT.start() # Ken put rose # Jack get rose 内部原理 为什么线程队列queue.Queue不能做到进程间数据共享呢？ 这是因为进程队列multiprocessing.Queue会采取一种映射的方式来同步数据，所以说进程队列的资源消耗比线程队列要庞大很多。 由于一个进程下的所有线程中的信息是共享的，所以线程队列根本不需要映射关系。 进程队列只是告诉你可以这样使用它达到进程间的数据共享，但是并不推荐你滥用它。 multiprocessing.Pipe 除开使用进程队列来实现进程间的通信，multiprocessing还提供了Pipe管道来进行通信。 他的资源消耗较少并且使用便捷，但是唯一的缺点便是只支持点对点。 Pipe有点类似socket通信。但是比socket通信更加简单，它不需要将字符串转换成字节后再进行发送，先来看一个实例： import multiprocessing from multiprocessing.connection import Pipe def putTask(article): name = \"Ken\" # 发送玫瑰 conn1.send(article) print(\"%s send %s\" % (name, article)) def getTask(): name = \"Jack\" # 接收玫瑰 article = conn2.recv() print(\"%s receive %s\" % (name, article)) if __name__ == \"__main__\": conn1, conn2 = multiprocessing.Pipe() # 实例化2个电话 gT = multiprocessing.Process(target=getTask) pT = multiprocessing.Process(target=putTask, args=(\"rose\", )) gT.start() pT.start() # Ken send rose # Jack receive rose Pipe()会去创建一个双向链接通道，如下所示： multiprocessing.Manager 除了进程队列multiprocessing.Queue，管道Pipe之外，multiprocessing还提供了Manager作为共享变量来提供多进程数据交互。 但是这种方式是不应该被直接使用的，因为它相较于进程队列Queue是数据不安全的。当多个进程同时修改一个共享变量势必导致结果出现问题，所以要想使用共享变量还得使用multiprocessin提供的进程锁才行。 Manager类是数据不安全的 Mangaer类支持的类型非常多，如：value, Array, List, Dict, Queue(进程池通信专用)，Lock等。 Mangaer实现了上下文管理器，可使用with语句创建多个对象 下面这个例子是使用multiprocessing.Manager来实现进程数据共享： import multiprocessing from multiprocessing import Manager def task_1(): dic[\"task_1\"] = \"A\" def task_2(): dic[\"task_2\"] = \"B\" if __name__ == \"__main__\": with Manager() as m: dic = m.dict() subProcessIns01 = multiprocessing.Process(target=task_1) subProcessIns02 = multiprocessing.Process(target=task_2) subProcessIns01.start() subProcessIns02.start() subProcessIns01.join() subProcessIns02.join() print(dic) # {'task_1': 'A', 'task_2': 'B'} 可以看见使用multiprocessing.Manager所提供的数据类用来数据交互展示很方便，但是要操纵数据则需要考虑数据安全问题： import multiprocessing from multiprocessing import Manager def task_1(): for i in range(1000): dic[\"number\"] -= 1 def task_2(): for i in range(1000): dic[\"number\"] += 1 if __name__ == \"__main__\": with Manager() as m: dic = m.dict() dic[\"number\"] = 0 subProcessIns01 = multiprocessing.Process(target=task_1) subProcessIns02 = multiprocessing.Process(target=task_2) subProcessIns01.start() subProcessIns02.start() subProcessIns01.join() subProcessIns02.join() print(dic) # 结果三次采集 # {'number': -13} # {'number': 5} # {'number': 8} 我们可以使用进程锁，来保证数据一致性： import multiprocessing from multiprocessing import Manager def task_1(): with lock: for i in range(1000): dic[\"number\"] -= 1 def task_2(): with lock: for i in range(1000): dic[\"number\"] += 1 if __name__ == \"__main__\": lock = multiprocessing.RLock() with Manager() as m: dic = m.dict() dic[\"number\"] = 0 subProcessIns01 = multiprocessing.Process(target=task_1) subProcessIns02 = multiprocessing.Process(target=task_2) subProcessIns01.start() subProcessIns02.start() subProcessIns01.join() subProcessIns02.join() print(dic) # 结果三次采集 # {'number': 0} # {'number': 0} # {'number': 0} Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-07-03 15:53:27 "},"Python/Python并发编程/生产者消费者模型.html":{"url":"Python/Python并发编程/生产者消费者模型.html","title":"生产者消费者模型","keywords":"","body":"生产者消费者模型 生产者消费者模型是一种设计思想，生产者生产出产品，消费者对产品进行消费。 但是他们之间不直接进行接触，而是通过中间件进行产品交易，这样做的好处是降低生产者与消费者之间的耦合度，使他们没有强制的关联。 如下图所示，当生产者生产出产品后会将产品放入中间件中，消费者监听中间件当中间件状态一旦发生变化后就立即获取出产品并消费： 多线程实现 下面将采用多线程实现生产者与消费者模型，需要借助queue.Queue()作为中间件： import threading import queue import time def producer(): thName = threading.current_thread().name product = 0 while 1: time.sleep(3) q.put(product) print(\"%s create %s\" % (thName, product)) product += 1 def consumer(): thName = threading.current_thread().name while 1: product = q.get() print(\"%s get %s\" % (thName, product)) if __name__ == \"__main__\": q = queue.Queue(maxsize=5) producerSubThread = threading.Thread(target=producer, name=\"producer\") producerSubThread.start() for i in range(3): consumerSubThread = threading.Thread( target=consumer, name=\"consumer - %s\" % i) consumerSubThread.start() 首先生产者会每隔3s生产出一个产品，然后将产品放入q队列中，消费者们会不断的从q队列中取出产品。 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-07-03 17:46:38 "},"Python/Python并发编程/使用执行器提交任务.html":{"url":"Python/Python并发编程/使用执行器提交任务.html","title":"使用执行器提交任务","keywords":"","body":"concurrent.futures 我们在以往创建线程或进程的时候都会使用threading与multiprocessing模块进行创建。 那么在本章节学习完成后就不要使用这两种方式创建线程或者进程了，而是应当使用concurrent.futures所提供的执行器来构建线程或进程并执行任务。 concurrent.futures提供了2种执行器，如下所示，它们的接口使用也都一模一样： from concurrent.futures import ThreadPoolExecutor # 线程池执行器 from concurrent.futures import ProcessPoolExecutor # 进程池执行器 注意，在Python2中是没有线程池执行器的。 官方文档 使用执行器和不使用执行器创建线程或进程两者2有什么不同呢？如下表所示： 普通线程 执行器 创建线程 惰性创建，需要执行任务时再创建线程 及早创建，在初始化执行器时就会创建一堆线程 提交任务 同步的提交任务，获取结果时需要等待，完成任务的线程会立即销毁 异步的提交任务，获取结果时将采用回调机制，完成任务的线程会立即返回至执行器中 销毁线程 任务完成后立即销毁线程 删除执行器或解释器析构时销毁线程 我们可以从这张图中看出2者的差距： 线程的创建和销毁是需要额外占据系统资源的，所以使用线程池执行器来管理线程性能上也会得到一定的提升。 执行器对象 方法大全 下面是执行器所提供的方法，用于创建子线程以及给子线程派发并执行任务： 方法 描述 ThreadPoolExecutor(max_workers=int) 返回一个线程池执行器对象，可指定该池中工作线程的最大数量 submit(fn, *args, **kwargs) 异步提交任务fn并派发给线程池执行器中的线程进行任务执行，返回期程对象 map(fn, *iterables, timeout=None, chunksize=1) 类似于内置函数map，它将map中fn的任务提交变更为异步的 shutdown(wait=True) 等待，类似于join()方法。在所有任务完成后关闭线程池执行器 基本使用 下面将创建一个包含5个线程的线程池执行器，然后给这5个线程分配10个任务并执行： from concurrent.futures import ThreadPoolExecutor import threading import time def task(): thName = threading.current_thread().name time.sleep(0.2) print(thName) if __name__ == \"__main__\": executor = ThreadPoolExecutor(max_workers=5) for i in range(10): executor.submit(task) # ThreadPoolExecutor-0_0 # ThreadPoolExecutor-0_1 # ThreadPoolExecutor-0_2 # ThreadPoolExecutor-0_3 # ThreadPoolExecutor-0_4 # ThreadPoolExecutor-0_1 # ThreadPoolExecutor-0_2 # ThreadPoolExecutor-0_0 # ThreadPoolExecutor-0_4 # ThreadPoolExecutor-0_3 with语句 我们也可以使用with语句来初始化线程池执行器： from concurrent.futures import ThreadPoolExecutor import threading import time def task(): thName = threading.current_thread().name time.sleep(0.2) print(thName) if __name__ == \"__main__\": with ThreadPoolExecutor(5) as executor: for i in range(10): executor.submit(task) map() 如果要多次调用同一个任务，而传入的参数不同时可使用map()函数。 如下所示，模拟爬取3个不同的网站： from concurrent.futures import ThreadPoolExecutor import threading import time def task(url): thName = threading.current_thread().name time.sleep(0.2) print(\"%s get %s\" % (thName, url)) if __name__ == \"__main__\": urlLst = [\"http://www.google.com\", \"http://www.baidu.com\", \"http://www.biying.com\"] with ThreadPoolExecutor(5) as executor: executor.map(task, urlLst) # ThreadPoolExecutor-0_0 get http://www.google.com # ThreadPoolExecutor-0_1 get http://www.baidu.com # ThreadPoolExecutor-0_2 get http://www.biying.com 期程对象 方法大全 当执行器的线程、进程任务执行完毕后，会返回一个期程对象（也被称为未来对象）。 下面是期程对象所提供的方法： 方法 描述 result(timeout=None) 从期程对象中获取任务执行结果，可设置超时时间timeout，若不设置该时间则一直等待，也就是说该方法是一个同步阻塞的获取执行结果的方法，若超时则引发cancelledError异常 add_done_callback(fn) 为期程对象添加回调函数，用于异步非阻塞的获取任务执行结果，fn为一个函数，该函数的形参会接受已完成任务的期程对象 exception(timeout=None) 返回由调用引发的异常。如果调用还没完成那么这个方法将等待 timeout 秒。如果在 timeout 秒内没有执行完成，concurrent.futures.TimeoutError将会被触发。timeout 可以是整数或浮点数。如果 timeout 没有指定或为 None，那么等待时间就没有限制。 cancel() 尝试取消任务的调用，如果当前任务正在执行或已经执行完毕则不能取消。若成功取消返回True，若取消失败则返回False cancelled() 如果调用成功则取消并返回True running() 如果调用正在执行而且不能被取消那么返回True done() 如果调用已被取消或正常结束那么返回True 期程对象 executor.submit()的返回结果是一个期程对象： from concurrent.futures import ThreadPoolExecutor import time def task(): time.sleep(0.2) if __name__ == \"__main__\": with ThreadPoolExecutor(1) as executor: for i in range(3): futureObject = executor.submit(task) print(futureObject) # # # 上面这个例子中执行器中包含1个线程，但是却要执行3个任务，所以你会发现它们的状态并不相同。 期程对象拥有5个状态，它们表示未来将可能出现的任务执行状态： _FUTURE_STATES = [ PENDING, # 等待执行任务 RUNNING, # 正在执行任务 CANCELLED, # 被取消 CANCELLED_AND_NOTIFIED, # 被取消 FINISHED # 已完成 ] 同步的获取结果 使用futureObject.result()可同步的获得任务的返回结果： from concurrent.futures import ThreadPoolExecutor import threading import time def task(params): taskIndex = params - 64 print(\"start carried out task, this is %s task\" % taskIndex) time.sleep(3) return \"task %s carried out end, result : %s\" % (taskIndex, chr(params)) if __name__ == \"__main__\": with ThreadPoolExecutor(5) as executor: for i in range(65, 91): futureObject = executor.submit(task, i) print(futureObject.result()) # start carried out task, this is 1 task # task 1 carried out end, result : A # start carried out task, this is 2 task # task 2 carried out end, result : B # start carried out task, this is 3 task # task 3 carried out end, result : C # start carried out task, this is 4 task # task 4 carried out end, result : D # start carried out task, this is 5 task # task 5 carried out end, result : E # ... 这将会引发主线程的阻塞，因为result()方法必须等待任务执行完毕后才能获取到结果，所以不应该这么使用。 异步的获取结果 由于executor.submit()的任务提交是异步提交，故我们应当采取绑定回调函数的策略来获得任务执行结果，而不是使用直接result()方法。 绑定回调函数并不会引起主线程的阻塞，一旦某个任务完成后便会立即触发回调函数的执行，并将期程对象传入该回调函数中。 因为此时的期程对象状态一定是FINISHED，所以使用result()方法便不会等待了。 如下所示，异步的获取结果，你可以看见它的打印结果和上面的例子是完全不同的： from concurrent.futures import ThreadPoolExecutor import threading import time def task(params): taskIndex = params - 64 print(\"start carried out task, this is %s task\" % taskIndex) time.sleep(3) return \"task %s carried out end, result : %s\" % (taskIndex, chr(params)) def callback(futureObject): print(futureObject.result()) if __name__ == \"__main__\": with ThreadPoolExecutor(5) as executor: for i in range(65, 91): futureObject = executor.submit(task, i) futureObject.add_done_callback(callback) # start carried out task, this is 1 task # start carried out task, this is 2 task # start carried out task, this is 3 task # start carried out task, this is 4 task # start carried out task, this is 5 task # task 1 carried out end, result : A # start carried out task, this is 6 task # task 2 carried out end, result : B # start carried out task, this is 7 task # task 4 carried out end, result : D # start carried out task, this is 8 task # task 5 carried out end, result : E # start carried out task, this is 9 task # task 3 carried out end, result : C # start carried out task, this is 10 task # ... 进程池执行器的进程通信 当我们使用进程池执行器启动多进程执行任务时，如果想用数据共享，单纯multiprocessing.Queue进程队列并不支持。 import multiprocessing from concurrent.futures import ProcessPoolExecutor # 进程池执行器 def task_1(q): q.put(\"玫瑰花\") print(\"放完了...\") def task_2(q): print(q.get()) print(\"取到了\") if __name__ == '__main__': q = multiprocessing.Queue() with ProcessPoolExecutor(max_workers=2) as pool: pool.submit(task_1,q) pool.submit(task_2,q) # 会阻塞住 这个时候我们需要用到multiprocessing中的Manager()中的Queue。只有它支持进程池的进程数据共享： from multiprocessing import Manager from concurrent.futures import ProcessPoolExecutor # 进程池执行器 def task_1(q): q.put(\"玫瑰花\") print(\"放完了...\") def task_2(q): print(q.get()) print(\"取到了\") if __name__ == '__main__': q = Manager().Queue() with ProcessPoolExecutor(max_workers=2) as pool: pool.submit(task_1,q) pool.submit(task_2,q) # 放完了... # 玫瑰花 # 取到了 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-07-03 23:37:22 "},"Python/Python并发编程/Linux五大IO模型.html":{"url":"Python/Python并发编程/Linux五大IO模型.html","title":"Linux五大I/O模型","keywords":"","body":"基础知识 I/O分类 常见的I/O主要分为以下几类，如下所示： 阻塞I/O（blocking I/O） 非阻塞I/O（non-blocking I/O） 同步I/O（sync I/O） 异步I/O（async I/O） 同步：调用端会一直等待服务端响应，直到返回结果 异步：调用端发起调用之后不会等待服务端响应。服务端通过某种通知机制或者回调函数来通知客户端 阻塞：服务端返回结果之前，客户端线程会被挂起，此时线程不可被CPU调度，线程暂停运行 非阻塞：在服务端返回前，函数不会阻塞调用端线程，而会立刻返回 用户态与内核态 用户态（User model）和内核态（Kernel model）是CPU的2种工作状态。 内核态下运行的必然是操作系统相关的代码，它允许直接操作硬件。 而用户态下运行的必然是应用程序相关的代码，用户态下不可以直接操纵底层硬件。 它必须通过操作系统调用才能间接的使用底层硬件，而应用程序的运行必然是要操纵底层硬件的，所以就必须让CPU不断的做2种状态的切换才行。 需要注意的是，核心态和内核态中所产生的数据是不允许直接交互的，而是只能通过一种映射的方式进行数据交互，可以理解为copy。 在CPU中有一个名叫psw的寄存器就是区分内核态和用户态的，它有2个状态位，当CPU指令集是0的时候对应到内核态，也就获取了所有的内存权限。 当指令集是1的时候对应到用户态，保留一部分内存不让访问。所以说真正的内存是不可划分的，都只是一个状态不同的问题。 当应用层面的程序被CPU执行时，那么可以肯定的是它的状态必定是1，限制了一些调度硬件的权限。 文件描述符 文件描述符简称为fd，全称为file descriptor。 Linux系统一切皆文件，因此文件描述符通常是用于描述指向文件的引用的抽象化概念。文件描述符在形式上是一个非负整数。实际上，它是一个索引值，指向内核为每一个进程所维护的该进程打开文件的记录表。 当程序打开一个现有文件或者创建一个新文件时，内核都会向进程返回一个文件描述符。 在程序设计中，一些涉及底层的程序编写往往会围绕着文件描述符展开。但是文件描述符这一概念往往只适用于Linux这样的操作系统。 缓存I/O 缓存I/O又被称作标准I/O，大多数文件系统的默认I/O操作都是缓存IO。 在Linux的缓存I/O机制中，操作系统会将 I/O的数据缓存在文件系统的页缓存（ page cache ）中，也就是说，数据会先被拷贝到操作系统内核的缓冲区中，然后才会从操作系统内核的缓冲区拷贝到应用程序的地址空间。 缓存I/O的缺点： 数据在传输过程中需要在应用程序地址空间和内核进行多次数据拷贝操作，这些数据拷贝操作所带来的 CPU 以及内存开销是非常大的。 其实缓存I/O出现的原因还是用户态和内核态的内存不允许直接进行数据交互而产生的，必须拥有这样一个缓存机制。 event loop event loop中文释义为事件循环，是一种常见的编程范式，常用于前端领域。 它是一种非线性的驱动模式，举个例子： 任何的UI编程都是基于事件循环的驱动模型来完成的，当我们的鼠标放在任何一段文字之上，它会根据文字不同而做出对应的不同反应。 并且，我们进入一个网页不仅仅可以用鼠标与网页产生交互，也可以使用键盘与网页产生交互，那么这里就会有很多很多种不同的选择，如果想尝试用传统的编程思想来解决识别用户的操作无疑效率是非常低下的。 传统编程思想解决方案： 死循环来不断的检测是否有鼠标点击，键盘按下，鼠标悬浮等等操作 通过阻塞的方式来等待用户的一次点击或者键盘按下或者鼠标悬浮的等等操作 这种解决方案看似十分完美，但是拥有很大的缺点： 死循环占用大量CPU资源，并且如果需要检测的事件太多势必会引发延迟问题 通过阻塞方式只能检测一种操作，并不能同时检测多种操作 为了解决这些缺点，故诞生了event loop，它的设计思路如下： 有一个事件(消息)队列，包括但不仅限于鼠标事件，键盘事件，悬浮事件等等 假设当鼠标按下，便往这个队列中增加一个点击事件(消息) 有一个循环，不断的从队列中取出事件，根据不同的事件调用不同的函数 事件（消息）一般都各自保存各自的处理函数指针，这样每个消息都有独立的处理函数 图解如下： 包含一个事件循环并且只有当外部事件发生时才使用回调机制来触发相应的处理。 也就是说程序运行的整个流程都是取决于用户触发的各种事件来决定的，开发者并不用关心大体流程，而只是需要做好每一个事件对应的处理方式即可。 Linux五大I/O模型 阻塞I/O模型 发起I/O系统调用后，进程会被阻塞，直至出现响应数据。 当响应数据出现后，系统会转到内核空间进行处理，将内核缓冲区的数据映射（或被称为拷贝）至应用程序中。 举例说明： 一个人去食堂买饭，他问了食堂大妈还有没有饭后就站在窗口原地的等，此时这个人什么也做不了。 非阻塞I/O模型 发起I/O系统调用后，进程不会阻塞，而是通过死循环不断的查看是否出现响应数据，如果响应数据未出现时就进行拷贝，则会引起异常。 当响应数据出现后，系统会转到内核空间进行处理，将内核缓冲区的数据映射（或被称为拷贝）至应用程序中。 举例说明： 一个人要去食堂买饭，他会先问食堂大妈有没有饭，食堂大妈说没有饭这个人就走开了，过一会又会过来问食堂大妈有没有饭，直至食堂大妈说饭好了后他才端上饭满意的离开。 I/O复用模型 I/O复用模型与事件驱动模型相似，它会先将I/O事件以及回调函数进行注册，然后再进行循环监听，一旦文件描述符状态发生改变后就会触发回调函数。 我们可以注册多个文件描述符，来达到同时监听多个I/O的目的，相较于前两种I/O模型，它拥有了监听机制，而正是因为有了这个机制，故并发量可以得到质的提升。 I/O复用模型拥有3种不同的监听机制，分别是select、poll以及epoll。 I/O复用模型的出现很大程度改变了一个进程多个I/O阻塞的问题，它能够实现一个线程下监听多个I/O的功能，极大的提升了程序的并发性，也是目前较为主流的一种解决方案。 举例说明： 一群人要买饭，于是托付给一个人去食堂，这个人去食堂后会先告诉食堂大妈，我这里有多少人要吃饭，这个人等待食堂大妈做好饭后会打电话通知某一个人过来拿饭，即一份饭做完之后立马让一个人来吃。 信号驱动式I/O模型 当进程发起一个IO操作，会向内核注册一个信号处理函数，然后进程返回不阻塞； 当内核数据就绪时会发送一个信号给进程，进程便在信号处理函数中调用I/O读取数据。 由于该种I/O模型的编码难度较大，故现在很少有应用程序使用这种模型进行编程了。 异步I/O模型 当进程发起一个I/O操作，进程返回（不阻塞），但也不能返回果结； 内核把整个I/O处理完后，会通知进程结果。 如果I/O操作成功则进程直接获取到数据。 举例说明： 一个人要去食堂买饭，他告诉食堂大妈，我要吃饭，饭好了你让人给我送过来，然后这个人就可以去做其他的事情了。 五种I/O模型对比 5种I/O模型中，异步I/O模型的性能最高，它全程无阻塞，以下是对比图示： I/O复用select、poll、epoll简介 select selelct监听模式一般应用在Windows平台上。 它会使用顺序表存储所有注册的I/O事件描述符。 支持最大同时监听1024（32位系统）或者2048（64位系统）个描述符。 同时，它会不断的去轮询查看所有描述符的状态是否发生改变，以便触发回调函数，所以他的性能有点低，当然这只是针对其他的监听模式而言。 当描述符状态发生改变后，会将内核缓冲区的数据映射到应用程序中，这相当于拷贝一次。 还是举个例子，一个班主任最多管理1024个学生，当班主任想知道谁没有交作业的时候他会对这1024个学生一个一个进行询问，学生只会被动的回答。 如，老师问第一个学生，你交作业了吗？学生说交了，老师再问第二个学生，你交作业了吗？以此类推... 总结： 支持最大监听的描述符数量：1024（32位系统）或者2048（64位系统） 描述符存储结构：顺序表 处理事件响应：轮询处理 消息传递方式：将内核缓冲区的数据映射到应用程序中，这相当于拷贝一次 poll poll监听模式一般应用在Linux平台上。 它会使用链表存储所有注册的I/O事件描述符。 最大支持同时监听的描述符数量无上限。 他会采用轮询方式来处理事件响应。 当描述符状态发生改变后，会将内核缓冲区的数据映射到应用程序中，这相当于拷贝一次。 总结： 支持最大监听的描述符数量：无限制，2G内存就可存放20W个描述符 描述符存储结构：链表 处理事件响应：轮询处理 消息传递方式：将内核缓冲区的数据映射到应用程序中，这相当于拷贝一次 epoll epoll监听模式一般应用在Linux平台上。 它会使用红黑树存储所有注册的I/O事件描述符。 最大支持同时监听的描述符数量无上限。 它会采用及时响应的方式来处理事件响应。 epoll监听模式下，内核缓冲区的数据并不需要映射到应用程序中，因为epoll通过内核与用户空间共享一块内存来实现免拷贝的过程。 举个例子，如果说select以及poll对处理事件响应的机制是一个一个问，那么poll就是举手。 老师想知道谁没交作业，只需要吼一声，谁还没交作业？此时立马就会有人举手，相比于轮询来说它的响应速度上快了很多。 总结： 支持最大监听的描述符数量：无限制，2G内存就可存放20W个描述符 描述符存储结构：红黑树 处理事件响应：主动响应 消息传递方式：通过内核与用户空间共享一块内存来实现免拷贝的过程 LT和ET 水平触发(level-trggered)和边缘触发(edge-triggered)是2种读取内核缓冲区数据的机制。 水平触发(level-trggered) 只要文件描述符关联的读内核缓冲区非空，有数据可以读取，就一直发出可读信号进行通知， 当文件描述符关联的内核写缓冲区不满，有空间可以写入，就一直发出可写信号进行通知 边缘触发(edge-triggered) 当文件描述符关联的读内核缓冲区由空转化为非空的时候，则发出可读信号进行通知， 当文件描述符关联的内核写缓冲区由满转化为不满的时候，则发出可写信号进行通知 水平触发是只要读缓冲区有数据，就会一直触发可读信号，而边缘触发仅仅在空变为非空的时候通知一次，举个例子： 读缓冲区刚开始是空的 读缓冲区写入2KB数据 水平触发和边缘触发模式此时都会发出可读信号 收到信号通知后，读取了1kb的数据，读缓冲区还剩余1KB数据 水平触发会再次进行通知，而边缘触发不会再进行通知 边缘触发的效率比水平触发的效率明显要高出许多，它减少了重复且无用的通知。 poll和epoll均支持ET，而select只支持LT，但是一定要注意，要想支持水平触发，I/O读取机制必须设置成非阻塞的。 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-07-06 16:28:09 "},"Python/Python并发编程/常见IO示例演示.html":{"url":"Python/Python并发编程/常见IO示例演示.html","title":"常见I/O示例演示","keywords":"","body":"阻塞I/O的socket服务端 使用socket模块与concurrent.futures实现阻塞式I/O的socket服务端。 开启多个子线程，每个子线程单独负责一个链接，这意味着该服务器最大的并发量取决于你CPU能够打开的最大有效线程数： import socket import threading import concurrent.futures class TcpServer: def __init__(self, bind_addr=(\"localhost\", 8001), allow_reuse_address=False): self.socket = socket.socket() self.backlog = 5 self.bufsize = 1024 self.server_addr = bind_addr self.allow_reuse_address = allow_reuse_address # 默认创建的线程数为cpu核心数 * 5 self.executor = concurrent.futures.ThreadPoolExecutor() def run_server(self): \"\"\"运行服务\"\"\" self.server_bind() self.server_activate() self.handle_request() def server_bind(self): \"\"\"绑定地址\"\"\" if self.allow_reuse_address: self.socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1) self.socket.bind(self.server_addr) def server_activate(self): \"\"\"开启监听\"\"\" self.socket.listen(self.backlog) def handle_request(self): \"\"\"处理链接\"\"\" while 1: # 阻塞点1：accept()函数会导致程序卡住，直至有新的链接请求到来 conn, addr = self.socket.accept() self.executor.submit( self.handle_communicate, conn, addr) def handle_communicate(self, conn, addr): \"\"\"多线程处理通信\"\"\" thName = threading.current_thread().name print(f\"{addr} connect server, handle thread : {thName}\") while 1: try: # 阻塞点2：recv()函数会导致程序卡住，直至有新的信息放入conn双向链接通道中 data = conn.recv(self.bufsize) if not data: raise Exception( f\"{addr} close connect, handle thread : {thName}\") conn.send(data.upper()) except Exception as e: self.close_connect(conn, e) break def close_connect(self, conn, msg): \"\"\"关闭链接\"\"\" conn.close() print(msg) if __name__ == \"__main__\": server = TcpServer(allow_reuse_address=True) server.run_server() 非阻塞I/O的socket服务端 将上述的socket服务端改为非阻塞的： import socket import threading import concurrent.futures class TcpServer: def __init__(self, bind_addr=(\"localhost\", 8001), allow_reuse_address=False): self.socket = socket.socket() # 设置为非阻塞 self.socket.setblocking(False) self.backlog = 5 self.bufsize = 1024 self.server_addr = bind_addr self.allow_reuse_address = allow_reuse_address # 默认创建的线程数为cpu核心数 * 5 self.executor = concurrent.futures.ThreadPoolExecutor() def run_server(self): \"\"\"运行服务\"\"\" self.server_bind() self.server_activate() self.handle_request() def server_bind(self): \"\"\"绑定地址\"\"\" if self.allow_reuse_address: self.socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1) self.socket.bind(self.server_addr) def server_activate(self): \"\"\"开启监听\"\"\" self.socket.listen(self.backlog) def handle_request(self): \"\"\"处理链接\"\"\" while 1: # 设置非阻塞I/O后，accept()这个原本会阻塞的函数变的非阻塞了 # 所以这里要不断的检测是否有新的链接请求 try: conn, addr = self.socket.accept() self.executor.submit( self.handle_communicate, conn, addr) except BlockingIOError as e: continue def handle_communicate(self, conn, addr): \"\"\"多线程处理通信\"\"\" thName = threading.current_thread().name print(f\"{addr} connect server, handle thread : {thName}\") while 1: try: # 设置非阻塞I/O后，recv()这个原本会阻塞的函数变的非阻塞了 # 所以这里要不断的检测是否有新的链接请求 data = conn.recv(self.bufsize) if not data: raise Exception( f\"{addr} close connect, handle thread : {thName}\") conn.send(data.upper()) except BlockingIOError as e: continue except Exception as e: self.close_connect(conn, e) break def close_connect(self, conn, msg): \"\"\"关闭链接\"\"\" conn.close() print(msg) if __name__ == \"__main__\": server = TcpServer(allow_reuse_address=True) server.run_server() I/O多路复用的socket服务端 上述的2个示例中，每个线程都会负责监听双向链接通道和处理通信请求，所以这意味着你的系统最大有效线程数决定了你服务器的最高并发数，显然效率是十分低下的。 而如果有一种机制让一个线程来监听所有的双向链接通道的话那么并发量就会得到质的提升，它不再是单纯的一对一服务了，而是一对多服务。 下面将利用select模块实现select监听模式的I/O多路复用机制，仅仅利用单线程，最大并发数量就能提升到2048个： import socket import select class TcpServer: def __init__(self, bind_addr=(\"localhost\", 8001), allow_reuse_address=False): self.socket = socket.socket() # 设置为非阻塞（高性能的边缘触发必备条件） self.socket.setblocking(False) self.backlog = 5 self.bufsize = 1024 self.server_addr = bind_addr self.allow_reuse_address = allow_reuse_address # 1.存放注册读取事件描述符的列表，当有可读事件发生时意味着客户端请求建立与服务端的双向链接通道 # 或者客户端有新的消息发送给服务端 self.r_list = [] # 2.存放注册可写事件描述符的列表，当有可写事件发生时意味着服务端可以主动向客户端发送信息 self.w_list = [] # 3.存放注册错误事件描述符的列表，... self.e_list = [] # 4.存放被监听描述符回调函数的字典 self.callback_dict = {} # 5.循环监听的时间间隔 self.poll_interval = 0.5 def run_server(self): \"\"\"运行服务\"\"\" self.server_bind() self.server_activate() self.server_forever() def server_bind(self): \"\"\"绑定地址\"\"\" if self.allow_reuse_address: self.socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1) self.socket.bind(self.server_addr) def server_activate(self): \"\"\"开启监听\"\"\" self.socket.listen(self.backlog) def server_forever(self): \"\"\"I/O多路复用\"\"\" # 注册self.sockt的可读事件并绑定回调函数为self.handle_request # 当客户端试图建立与服务端的双向链接通道时将触发self.socket的可读事件 self.register(obj=self.socket, event_type=\"read\", callback=self.handle_request) # 开始循环监听描述符，每次while循环间隔0.5s while 1: # 当可读事件列表、可写事件列表、错误事件列表中任何一个fd的状态发生改变后 # 都会添加到r、w、e中 r, w, e = select.select( self.r_list, self.w_list, self.e_list, self.poll_interval) # 查看是否有可读事件发生，如果有就运行其回调函数 for fd in r: # 运行回调函数 fd_callback = self.callback_dict[fd][\"r\"] fd_callback(fd) def handle_request(self, fd_socket): \"\"\"处理链接\"\"\" conn, addr = fd_socket.accept() print(f\"{addr} connect server\") # 注册conn的可读事件并绑定回调函数为self.handle_communicate # 当该客户端向服务端发送信息时将触会触发conn的可读事件 self.register(obj=conn, event_type=\"read\", callback=self.handle_communicate) def handle_communicate(self, fd_conn): \"\"\"处理通信\"\"\" # 实际上就是链接服务端的客户端地址 addr = getattr(fd_conn, \"getsockname\")() try: data = fd_conn.recv(self.bufsize) # 针对Unix环境：客户端强制断开链接 if not data: raise Exception( f\"{addr} close connect\") fd_conn.send(data.upper()) # 针对Windows环境：客户端强制断开链接 except Exception as e: # 关闭双向链接通道并注销可读事件，这意味着不再监听该双向链接通道 self.close_connect(fd_conn, e) self.unregister(obj=fd_conn, event_type=\"read\") def close_connect(self, conn, msg): \"\"\"关闭链接\"\"\" conn.close() print(msg) def register(self, obj, event_type, callback): \"\"\"事件注册\"\"\" if event_type == \"read\": self.r_list.append(obj) self.callback_dict[obj] = {\"r\": callback} elif event_type == \"write\": self.w_list.append(obj) self.callback_dict[obj] = {\"w\": callback} elif event_type == \"error\": self.e_list.append(obj) self.callback_dict[obj] = {\"e\": callback} else: raise TypeError(\"unknown event type %r\" % event_type) def unregister(self, obj, event_type): \"\"\"取消注册\"\"\" if event_type == \"read\": self.r_list.remove(obj) del self.callback_dict[obj][\"r\"] elif event_type == \"write\": self.w_list.remove(obj) del self.callback_dict[obj][\"w\"] elif event_type == \"error\": self.e_list.remove(obj) del self.callback_dict[obj][\"e\"] else: raise TypeError(\"unknown event type %r\" % event_type) if __name__ == \"__main__\": server = TcpServer(allow_reuse_address=True) server.run_server() 异步的socket服务端 selectors模块是select模块的升级版，他还会根据平台自动选择监听方式，是十分方便的。 　官方文档 注意，Windows平台下不支持poll或者epoll模式 epoll模式仅有Linux平台支持 现在很多框架的内部，如著名的异步框架tornado，Twisted ，等等都是通过epoll实现的异步，其实epoll到底属于不属于异步在网络上有很大的争议，下面会有一节会和大家一起讨论一下epoll和异步之间的关系。 下面是它的使用案例，基本步骤和select模块使用类似，也是注册事件、绑定回调、监听描述符。 相较于使用select模式的I/O多路复用机制来说，epoll模式的I/O多路复用机制单线程下的效率和最大支持并发量提升了不少： import socket import selectors class TcpServer: def __init__(self, bind_addr=(\"localhost\", 8001), allow_reuse_address=False): self.socket = socket.socket() # 设置为非阻塞（高性能的边缘触发必备条件） self.socket.setblocking(False) self.backlog = 5 self.bufsize = 1024 self.server_addr = bind_addr self.allow_reuse_address = allow_reuse_address # 1.自动选择监听模式:select、poll、epoll self.sel = selectors.DefaultSelector() # 2.循环监听的时间间隔 self.poll_interval = 0.5 def run_server(self): \"\"\"运行服务\"\"\" self.server_bind() self.server_activate() self.server_forever() def server_bind(self): \"\"\"绑定地址\"\"\" if self.allow_reuse_address: self.socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1) self.socket.bind(self.server_addr) def server_activate(self): \"\"\"开启监听\"\"\" self.socket.listen(self.backlog) def server_forever(self): \"\"\"I/O多路复用\"\"\" # 注册self.sockt的可读事件并绑定回调函数为self.handle_request # 当客户端试图建立与服务端的双向链接通道时将触发self.socket的可读事件 self.sel.register(self.socket, selectors.EVENT_READ, self.handle_request) # 开始循环监听描述符，每次while循环间隔0.5s while 1: # 当有已注册描述符状态发生改变后，都会添加至fd_list # fd_list = [(fd, event), ...] fd_list = self.sel.select(self.poll_interval) for fd, event in fd_list: # 运行回调函数 fd_callback = fd.data fd_callback(fd.fileobj) def handle_request(self, fd_socket): \"\"\"处理链接\"\"\" conn, addr = fd_socket.accept() print(f\"{addr} connect server\") # 注册conn的可读事件并绑定回调函数为self.handle_communicate # 当该客户端向服务端发送信息时将触会触发conn的可读事件 self.sel.register(conn, selectors.EVENT_READ, self.handle_communicate) def handle_communicate(self, fd_conn): \"\"\"处理通信\"\"\" # 实际上就是链接服务端的客户端地址 addr = getattr(fd_conn, \"getsockname\")() try: data = fd_conn.recv(self.bufsize) # 针对Unix环境：客户端强制断开链接 if not data: raise Exception( f\"{addr} close connect\") fd_conn.send(data.upper()) # 针对Windows环境：客户端强制断开链接 except Exception as e: # 关闭双向链接通道并注销可读事件，这意味着不再监听该双向链接通道 self.close_connect(fd_conn, e) self.sel.unregister(fd_conn) def close_connect(self, conn, msg): \"\"\"关闭链接\"\"\" conn.close() print(msg) if __name__ == \"__main__\": server = TcpServer(allow_reuse_address=True) server.run_server() 更高性能的提升 上述的I/O多路复用服务端都是用单线程来实现对于请求的处理，如果加上了多线程进行处理请求，那么效率上又会有很大的提升。 如下所示： import socket import selectors import concurrent.futures class TcpServer: def __init__(self, bind_addr=(\"localhost\", 8001), allow_reuse_address=False): self.socket = socket.socket() # 设置为非阻塞（高性能的边缘触发必备条件） self.socket.setblocking(False) self.backlog = 5 self.bufsize = 1024 self.server_addr = bind_addr self.allow_reuse_address = allow_reuse_address # 默认创建的线程数为cpu核心数 * 5 self.executor = concurrent.futures.ThreadPoolExecutor() # 1.自动选择监听模式:select、poll、epoll self.sel = selectors.DefaultSelector() # 2.循环监听的时间间隔 self.poll_interval = 0.5 def run_server(self): \"\"\"运行服务\"\"\" self.server_bind() self.server_activate() self.server_forever() def server_bind(self): \"\"\"绑定地址\"\"\" if self.allow_reuse_address: self.socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1) self.socket.bind(self.server_addr) def server_activate(self): \"\"\"开启监听\"\"\" self.socket.listen(self.backlog) def server_forever(self): \"\"\"I/O多路复用\"\"\" # 注册self.sockt的可读事件并绑定回调函数为self.handle_request # 当客户端试图建立与服务端的双向链接通道时将触发self.socket的可读事件 self.sel.register(self.socket, selectors.EVENT_READ, self.handle_request) # 开始循环监听描述符，每次while循环间隔0.5s while 1: # 当有已注册描述符状态发生改变后，都会添加至fd_list # fd_list = [(fd, event), ...] fd_list = self.sel.select(self.poll_interval) for fd, event in fd_list: # 多线程运行回调函数 fd_callback = fd.data self.executor.submit(fd_callback, fd.fileobj) def handle_request(self, fd_socket): \"\"\"处理链接\"\"\" conn, addr = fd_socket.accept() print(f\"{addr} connect server\") # 注册conn的可读事件并绑定回调函数为self.handle_communicate # 当该客户端向服务端发送信息时将触会触发conn的可读事件 self.sel.register(conn, selectors.EVENT_READ, self.handle_communicate) def handle_communicate(self, fd_conn): \"\"\"处理通信\"\"\" # 实际上就是链接服务端的客户端地址 addr = getattr(fd_conn, \"getsockname\")() try: data = fd_conn.recv(self.bufsize) # 针对Unix环境：客户端强制断开链接 if not data: raise Exception( f\"{addr} close connect\") fd_conn.send(data.upper()) # 针对Windows环境：客户端强制断开链接 except Exception as e: # 关闭双向链接通道并注销可读事件，这意味着不再监听该双向链接通道 self.close_connect(fd_conn, e) self.sel.unregister(fd_conn) def close_connect(self, conn, msg): \"\"\"关闭链接\"\"\" conn.close() print(msg) if __name__ == \"__main__\": server = TcpServer(allow_reuse_address=True) server.run_server() epoll到底是同步还是异步 摘自知乎： 学习tornado、asyncio这些异步网络库时，遇到了同样的问题，网上查到的也都说不明白，原来几个概念没搞清楚。 I/O操作有多种，处理socket是一种，磁盘读写也是一种，暂时分为网络I/O和文件I/O、 I/O多路复用是操作系统级别的，属于linux操作系统的五种I/O模型中的一种，是操作系统级别同步非阻塞的 异步网络库 twisted、tornado、asyncio所谓的异步，是应用级别的异步，底层确实是基于epoll实现，基本上都是处理网络 I/O，而且都是基于事件驱动的，使用时划分事件也大多是根据网络请求。 操作系统级别的异步I/O才是真正异步非阻塞的，然后并没有很多应用，貌似unix平台没有，windows NT平台有也很少，而且基本都是文件I/O I/O多路复用的实现用的比较多，linux平台的epoll，windows平台的select等，基于epoll，select的应用大多是实现网络I/O。 所以，遇到异步框架，异步网络库都应该知道是应用级别的异步，而且基本上都是基于epoll/select实现的。 已知tornado会根据系统平台，选择epoll还是select。 实现高并发有多种方式，python多进程可以利用多核优势，协程(gevent、asyncio)可以实现应用级别的异步，celery实现任务异步，消息队列实现服务解耦等等，项目中可以根据实际情况选择或组合不同的方式。 tornado(web框架/异步网络库)：进程+异步+epoll asyncio：协程+epoll，使用中需要相应的异步库，如常用的aiohttp gevent：greenlet+猴子补丁，猴子补丁把socket相关库改为非阻塞 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-07-06 16:32:03 "},"Python/Python并发编程/协程 asynic.html":{"url":"Python/Python并发编程/协程 asynic.html","title":"协程 asynic","keywords":"","body":"协程 协程（coroutine）并不是一个系统层面上真实存在的东西，而是由程序员进行创造。 你可以理解为协程是用户态的“线程”，因此协程也被称为“微线程”或者“纤程（Fiber）”。 协程能够做到在单线程下实现多线程的并发操作，这是非常厉害的一点。 既然协程和线程很像，那么它对比线程有什么优势呢？ 协程和线程一样能够做切换，但是其切换代价远远小于线程，极大的提升了运行效率 协程中修改共享数据时不需要为数据加锁，因为协程本身就是一个单线程 协程有2大重要的概念，如下所示： 作为用户态线程，它必然存在于内核态线程中，也就是说协程本身是一个非常纯粹的单线程 协程最重要的意义就是切换 普通的代码运行总是顺序执行的，而如果我们有某种机制让它能够遇见I/O后进行自动切换执行就非常牛逼了。 例如下面这个例子，普通的运行打印结果是1、2、3、4，而我们如果加上遇见I/O自动切换执行的策略的话它的打印结果就会变成1、3、2、4： import time def task_01(): print(1) time.sleep(1) # I/O操作 print(2) def task_02(): print(3) time.sleep(1) # I/O操作 print(4) task_01() task_02() # 1 # 2 # 3 # 4 如果真的实现了上述的功能，那么使用单线程实现并发就变的不是那么遥不可及了。 生成器 我们可以利用生成器函数的yield关键字来实现代码的切换，如下所示： import time def task_01(): print(1) time.sleep(1) # I/O操作 yield # 手动切换 print(2) def task_02(): print(3) time.sleep(1) # I/O操作 yield # 手动切换 print(4) # 创建生成器对象 genObject_01 = task_01() genObject_02 = task_02() # 待执行任务列表 task_list = [genObject_01, genObject_02] # 开启循环 while 1: # 可执行任务列表 executable_list = task_list.copy() # 已执行任务列表 completed_list = [] for run_generator in executable_list: try: next(run_generator) except StopIteration as e: # 如果任务执行完毕，添加到已执行任务列表中 completed_list.append(run_generator) for end_generator in completed_list: # 从待执行任务列表、已执行任务列表中删除已完成任务 task_list.remove(end_generator) executable_list.remove(end_generator) else: # 清空已完成任务列表 completed_list.clear() if not task_list: break # 1 # 3 # 2 # 4 就这样一个基础的协程就做好了，但是你可以发现它的编码难度较大。 并且每次遇见I/O操作后都需要我们手动进行切换，十分的不方便。 gevent模块 针对yield协程的缺点，我们可以利用gevent模块，让整个碰见I/O操作就切换的过程变为自动进行。 它是一个第三方模块，所以你需要手动进行安装下载： $ pip3 install gevent 代码如下所示： import gevent import time from gevent import monkey # 声明：下面代码碰见I/O操作自动切换 monkey.patch_all() def task_01(): print(1) time.sleep(1) # I/O操作，自动切换 print(2) time.sleep(1) # I/O操作，自动切换 def task_02(): print(3) time.sleep(1) # I/O操作，自动切换 print(4) # 创建协程对象 fiberObject_01 = gevent.spawn(task_01, ) # 后面可传递参数 fiberObject_02 = gevent.spawn(task_02, ) # 任务列表 task_list = [fiberObject_01, fiberObject_02] # 开始执行 gevent.joinall( task_list ) # 1 # 3 # 2 # 4 asyncio模块 Python3.4之后，官方提供了asyncio模块来提供对协程的支持。 下面是代码示例： import asyncio # 函数头部加上该装饰器，表明该函数是一个协程函数 @asyncio.coroutine def task_01(): print(1) yield from asyncio.sleep(1) # I/O操作 自动切换 print(2) @asyncio.coroutine def task_02(): print(3) yield from asyncio.sleep(1) # I/O操作 自动切换 print(4) # 创建协程对象，并将它包装为期程对象 fiberObject_01 = asyncio.ensure_future(task_01()) fiberObject_02 = asyncio.ensure_future(task_02()) # 任务列表 task_list = [fiberObject_01, fiberObject_02] # 获取并开启循环 loop = asyncio.get_event_loop() # 运行任务列表，并等待所有协程任务执行完毕 loop.run_until_complete(asyncio.wait(task_list)) # 1 # 3 # 2 # 4 我们要注意，如果一个协程函数中要调用另一个函数，则必须使用yield from关键字，yield form后面可以运行的对象类型： 协程对象 期程对象 task任务对象 另外，如果你想在协程函数中运行一些模块方法，那么一定要保证模块所提供的方法是异步方法，否则协程切换无效。 有关于yield from的使用，请参照Python基础生成器一章节。 async&awit语法 async和awit语法在Python3.5中被支持，它本质和asyncio模块使用没有任何区别，只是简化了语法。 async：用于定义协程函数，而不再使用@asyncio.coroutine装饰器来进行定义 awit：相当于yield from的简写形式，必须书写在协程函数中 以下是它的使用示例： import asyncio async def task_01(): print(1) await asyncio.sleep(1) # I/O操作 自动切换 print(2) async def task_02(): print(3) await asyncio.sleep(1) # I/O操作 自动切换 print(4) # 创建协程对象，并将它包装为期程对象 fiberObject_01 = asyncio.ensure_future(task_01()) fiberObject_02 = asyncio.ensure_future(task_02()) # 任务列表 task_list = [fiberObject_01, fiberObject_02] # 获取并开启循环 loop = asyncio.get_event_loop() # 运行任务列表，并等待所有协程任务执行完毕 loop.run_until_complete(asyncio.wait(task_list)) # 1 # 3 # 2 # 4 协程的作用 单纯的协程只是能够做切换，没有其他的任何特定功能。 也就是说，协程本身并不能提高并发量，但是如果能够加上碰见I/O自动切换的机制，那么协程的真正意义才能够被体现。 注意一点： 对于计算密集型的操作来说，利用协程来回进行切换是没有任何意义的，来回切换并保存状态，反倒会降低性能 对于I/O密集型的操作来说，利用协程在I/O等待时间中去切换并执行其他任务，当I/O结束后再进行回调，那么就会大大节省系统资源并提供高性能从而实现异步编程 接下来我们将使用一个简单的爬虫案例，来探究协程和多线程的执行效率到底提升了多少。 下面是多线程爬虫的示例，需要用到requests模块，所以你必须先安装它： $ pip3 install requests 一个任务负责爬取资源，一个任务负责解析资源，为了更加方便对比，我们将整个运行时长都*10： import requests import time from concurrent.futures import ThreadPoolExecutor headers = { \"user-agent\": \"User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/87.0.4280.88 Safari/537.36\" } urls = [ \"https://www.jianshu.com/\", \"https://www.csdn.net/\", \"https://www.cnblogs.com/\", ] start = time.time() # 任务函数 def func(url): response = requests.get(url, headers=headers) return response.text # 绑定回调函数 def callback(futuresObject): print(futuresObject.result()) if __name__ == \"__main__\": with ThreadPoolExecutor() as executor: for url in urls: futuresObject = executor.submit(func, url) futuresObject.add_done_callback(callback) end = time.time() print(f\"总计花费时长{(end - start) * 10}\") # 总计花费时长21.973369121551514 下面是协程爬虫的示例，由于协程中不允许同步方法的出现，而requests模块下的请求方法都是同步请求方法，所以需要使用aiohttp模块下的异步请求方法完成网络请求，你必须先安装它： $ pip3 install aiohttp 示例如下： import asyncio import aiohttp import time headers = { \"user-agent\": \"User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/87.0.4280.88 Safari/537.36\" } urls = [ \"https://www.jianshu.com/\", \"https://www.csdn.net/\", \"https://www.cnblogs.com/\", ] start = time.time() # 任务函数 async def func(url): # async wait 相当于是执行一个异步的 __enter__ 方法 async with aiohttp.ClientSession() as session: # 防止ssl抛出错误 async with session.get(url, headers=headers, verify_ssl=False) as response: return await response.text() # 绑定回调函数 def callback(futuresObject): print(futuresObject.result()) if __name__ == \"__main__\": # 创建协程任务列表 task_list = [] # 创建协程任务 for url in urls: # 创建协程对象，并将它包装为期程对象 fiberObject = asyncio.ensure_future(func(url)) # 为期程对象绑定回调函数 fiberObject.add_done_callback(callback) # 添加到协程任务列表 task_list.append(fiberObject) # 创建事件循环 event_loop = asyncio.get_event_loop() # 执行任务，并且主线程会等待协程任务列表中的所有任务处理完毕后再执行 event_loop.run_until_complete(asyncio.wait(task_list)) end = time.time() print(f\"总计花费时长{(end - start) * 10}\") # 总计花费时长14.334436416625977 可以看见，协程爬虫比多线程爬虫的执行效率提高了不止一星半点，它真正称得上是Python中I/O密集型任务处理的大杀器。 asyncio详细探究 基于协程实现高性能的异步编程，这是Python未来发展方向，诸如fastapi、tornado等非常出名的异步web框架内部其实都与协程息息相关。 此外，Python web领域大火的Django也在3.x版本中正式迈入异步领域，这意味着：异步编程，永远的神。 事件循环 事件循环是asyncio的关键，你可以将它理解为一个while循环，它会在循环中周期性的执行协程任务，并且在特定的条件下终止循环。 你可以参照生成器实现协程的代码或者下面的伪代码，这就是事件循环最直观的体现。 待执行任务列表 = [协程任务, 协程任务] while 1: 可执行任务列表 = 待执行任务列表[:] 已执行任务列表 = [] for 可执行任务 in 可执行任务列表： try: next(可执行任务) except StopIteration as e: 已执行任务列表.append(可执行任务) for 已执行任务 in 已执行任务列表: 待执行任务.remove(已执行任务) 可执行任务.remove(已执行任务) else: 已执行任务列表.clear() if not 待执行任务列表: break 使用asyncio模块时，你可以直接通过下面方式获取到该事件循环： event_loop = asyncio.get_event_loop() 协程对象 协程函数就是加上了@asyncio.coroutine装饰器的函数，或者以async开头定义的函数，如下所示： async def task(): pass 它和生成器有着一样的特性，即加括号时不会调用函数体内部代码，而是返回一个协程对象： fiberObject = task() print(type(fiberObject)) # 任务执行 当要执行任务的时候，必须先获取事件循环，然后再将协程对象任务添加到事件循环中： import asyncio async def task(): print(\"run task ...\") fiberObject = task() event_loop = asyncio.get_event_loop() event_loop.run_until_complete(fiberObject) print(\"run main ...\") # run task ... # run main ... event_loop.run_until_complete()方法会添加协程对象至事件循环中，并且执行协程对象，直至协程对象运行完毕后才跳出事件循环。 在Python3.7之前，我们每次要运行一个协程对象都必须先获取事件循环，再调用event_loop.run_until_complete()添加协程对象并执行，这很麻烦。 在Python3.7之后asyncio模块新增了run()方法，它简化了这2步操作，如下所示： import asyncio async def task(): print(\"run task ...\") fiberObject = task() asyncio.run(fiberObject) print(\"run main ...\") # run task ... # run main ... await await关键字只能在协程函数中使用，类似于yield from只能在生成器函数中使用一样。 它与生成器函数相同，都用于运行嵌套在一个协程函数中的另一个协程函数，具体可参照yield from： import asyncio async def inner(): print(\"run ... inner\") return 1 async def warpper(): print(\"run ... warpper\") result = await inner() print(result) if __name__ == \"__main__\": fiberObject = warpper() event_loop = asyncio.get_event_loop() event_loop.run_until_complete(fiberObject) # run ... warpper # run ... inner # 1 await后面可以运行的对象类型： 协程对象 期程对象 taskr任务对象 期程对象 上述所有的代码都是在事件循环中添加一个协程对象，当事件循环中仅有一个对象时是无法做到遇见I/O就切换的操作的。 同时，协程对象本身不能绑定回调函数，所以要想绑定回调函数必须将它包装为期程对象。 在Python3.7之前，你可以使用asyncio.ensure_future()函数将一个协程对象包装为期程对象，这样它就可以绑定回调函数了： import asyncio async def task(): await asyncio.sleep(3) return 1 def callback(fiberObject): print(fiberObject.result()) if __name__ == \"__main__\": fiberObject = asyncio.ensure_future(task()) fiberObject.add_done_callback(callback) event_loop = asyncio.get_event_loop() event_loop.run_until_complete(fiberObject) # 1 如果想同时在事件循环中添加多个期程对象，你可以创建一个任务列表，并使用asyncio.wait()方法来将任务列表中所有的期程对象都添加到事件循环中，如下所示： import asyncio async def task(param): print(f\"run task{param}\") await asyncio.sleep(3) return param def callback(fiberObject): print(fiberObject.result()) if __name__ == \"__main__\": task_list = [] for i in range(3): fiberObject = asyncio.ensure_future(task(i)) fiberObject.add_done_callback(callback) task_list.append(fiberObject) event_loop = asyncio.get_event_loop() event_loop.run_until_complete( asyncio.wait(task_list) ) # run task0 # run task1 # run task2 # 0 # 1 # 2 这样一个异步提交的案例就出现了。 任务对象 任务对象是基于期程对象的一个封装。 如果你的Python版本是Python3.7或者更高，则可以直接创建任务对象并绑定回调函数，然后将它丢入的事件循环循环中： import asyncio async def task(param): print(f\"run task{param}\") await asyncio.sleep(3) return param def callback(fiberObject): print(fiberObject.result()) async def main(): task_list = [] for i in range(3): fiberObject = asyncio.create_task(task(i), name=f\"task{i}\") fiberObject.add_done_callback(callback) task_list.append(fiberObject) done, pending = await asyncio.wait(task_list, timeout=None) print(done, pending) if __name__ == \"__main__\": asyncio.run(main()) # run task0 # run task1 # run task2 # 0 # 1 # 2 concurrent.futures.Futures 在concurrent.futures模块中，也有一个期程对象，该模块用于提供线程执行器和进程执行器，能够更加方便管理线程和进程，详情参照前面>一章。 concurrent.futures.Futures和asyncio的Futures对象还是有所不同的，下面是官方文档的说明： 与 asyncio Futures 不同， concurrent.futures.Future 实例不能等待 asyncio.Future.result() 和 asyncio.Future.exception() 不接受超时参数 asyncio.Future.result() 和 asyncio.Future.exception() 在 Future 未完成时引发 InvalidStateError 异常 使用 asyncio.Future.add_done_callback() 注册的回调不会立即调用。 它们是用 loop.call_soon() 来安排的 asyncio Future 与 concurrent.futures.wait() 和 concurrent.futures.as_completed() 函数不兼容 如果想将concurrent.futures.Futures变的和asyncio.Future相同，则可以使用asyncio所提供的方法wrap_future()。 其实，一般在程序开发中我们要么统一使用 asycio 的协程实现异步操作、要么都使用进程池和线程池实现异步操作。但如果 协程的异步和 进程池/线程池的异步 混搭时，那么就会用到此功能了。 import time import asyncio import concurrent.futures def func1(): # 某个耗时操作 time.sleep(2) return 1 async def main(): loop = asyncio.get_running_loop() # 1. Run in the default loop's executor ( 默认ThreadPoolExecutor ) # 第一步：内部会先调用 ThreadPoolExecutor 的 submit 方法去线程池中申请一个线程去执行func1函数，并返回一个concurrent.futures.Future对象 # 第二步：调用asyncio.wrap_future将concurrent.futures.Future对象包装为asycio.Future对象。 # 因为concurrent.futures.Future对象不支持await语法，所以需要包装为 asycio.Future对象 才能使用 fut = loop.run_in_executor(None, func1) result = await fut print('default thread pool', result) # 2. Run in a custom thread pool: # with concurrent.futures.ThreadPoolExecutor() as pool: # result = await loop.run_in_executor( # pool, func1) # print('custom thread pool', result) # 3. Run in a custom process pool: # with concurrent.futures.ProcessPoolExecutor() as pool: # result = await loop.run_in_executor( # pool, func1) # print('custom process pool', result) asyncio.run(main()) 应用场景：当项目以协程式的异步编程开发时，如果要使用一个第三方模块，而第三方模块不支持协程方式异步编程时，就需要用到这个功能，例如： import asyncio import requests async def download_image(url): # 发送网络请求，下载图片（遇到网络下载图片的IO请求，自动化切换到其他任务） print(\"开始下载:\", url) loop = asyncio.get_event_loop() # requests模块默认不支持异步操作，所以就使用线程池来配合实现了。 future = loop.run_in_executor(None, requests.get, url) response = await future print('下载完成') # 图片保存到本地文件 file_name = url.rsplit('_')[-1] with open(file_name, mode='wb') as file_object: file_object.write(response.content) if __name__ == '__main__': url_list = [ 'https://www3.autoimg.cn/newsdfs/g26/M02/35/A9/120x90_0_autohomecar__ChsEe12AXQ6AOOH_AAFocMs8nzU621.jpg', 'https://www2.autoimg.cn/newsdfs/g30/M01/3C/E2/120x90_0_autohomecar__ChcCSV2BBICAUntfAADjJFd6800429.jpg', 'https://www3.autoimg.cn/newsdfs/g26/M0B/3C/65/120x90_0_autohomecar__ChcCP12BFCmAIO83AAGq7vK0sGY193.jpg' ] tasks = [download_image(url) for url in url_list] loop = asyncio.get_event_loop() loop.run_until_complete(asyncio.wait(tasks)) async for 异步可迭代对象 async for语句是针对异步可迭代对象所使用的。 异步可迭代对象是指内部是实现了__aiter__()方法的对象，它必须返回一个await iterator对象 异步迭代器 异步迭代器是指内部实现了__aiter__()和__anext__()方法的对象，其中__anext__()方法必须返回一个awaitable对象。 async for会处理异步迭代器的 __anext__()方法所返回的可等待对象，直到其引发一个StopAsyncIteration异常。由 PEP 492引入。 代码实现 下面实现一个异步可迭代对象，它的可迭代器就是本身。 import asyncio class Reader(object): \"\"\" 自定义异步迭代器（同时也是异步可迭代对象） \"\"\" def __init__(self): self.count = 0 async def readline(self): # await asyncio.sleep(1) self.count += 1 if self.count == 100: return None return self.count def __aiter__(self): return self async def __anext__(self): val = await self.readline() if val == None: raise StopAsyncIteration return val async def func(): # 创建异步可迭代对象 async_iter = Reader() # async for 必须要放在async def函数内，否则语法错误。 async for item in async_iter: print(item) asyncio.run(func()) async wait 异步上下文管理 此种对象通过定义__aenter__()和__aexit__()方法来对 async with 语句中的环境进行控制。由 PEP 492 引入。 import asyncio class AsyncContextManager: def __init__(self): self.conn = conn async def do_something(self): # 异步操作数据库 return 666 async def __aenter__(self): # 异步链接数据库 self.conn = await asyncio.sleep(1) return self async def __aexit__(self, exc_type, exc, tb): # 异步关闭数据库链接 await asyncio.sleep(1) async def func(): async with AsyncContextManager() as f: result = await f.do_something() print(result) asyncio.run(func()) 这个异步的上下文管理器还是比较有用的，平时在开发过程中 打开、处理、关闭 操作时，就可以用这种方式来处理。 uvloop Python标准库中提供了asyncio模块，用于支持基于协程的异步编程。 uvloop是 asyncio 中的事件循环的替代方案，替换后可以使得asyncio性能提高。事实上，uvloop要比nodejs、gevent等其他python异步框架至少要快2倍，性能可以比肩Go语言。 安装uvloop pip3 install uvloop 在项目中想要使用uvloop替换asyncio的事件循环也非常简单，只要在代码中这么做就行。 import asyncio import uvloop asyncio.set_event_loop_policy(uvloop.EventLoopPolicy()) # 编写asyncio的代码，与之前写的代码一致。 # 内部的事件循环自动化会变为uvloop asyncio.run(...) 注意：知名的asgi uvicorn内部就是使用的uvloop的事件循环。 官方文档 在程序中只要看到async和await关键字，其内部就是基于协程实现的异步编程，这种异步编程是通过一个线程在I/O等待时间去执行其他任务，从而实现并发。 以上就是异步编程的常见操作，其他具体的内容可参考官方文档。 中文版：https://docs.python.org/zh-cn/3.8/library/asyncio.html 英文本：https://docs.python.org/3.8/library/asyncio.html 此外，此篇文章基本借鉴于武Sir，再次特别感谢。 原文地址 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-07-07 16:42:26 "},"Python/Python驱动程序/summary.html":{"url":"Python/Python驱动程序/summary.html","title":"Python驱动程序","keywords":"","body":"Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-13 20:41:50 "},"前端专栏/summary.html":{"url":"前端专栏/summary.html","title":"前端专栏","keywords":"","body":" HTML CSS JavaScript jQuery Vue Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-07-07 19:57:48 "},"前端专栏/HTML/summary.html":{"url":"前端专栏/HTML/summary.html","title":"HTML","keywords":"","body":" 基础知识 声明系标签 结构系标签 文本系标签 链接系标签 列表系标签 表格系标签 表单系标签 媒体系标签 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-07-10 19:51:55 "},"前端专栏/HTML/基础知识.html":{"url":"前端专栏/HTML/基础知识.html","title":"基础知识","keywords":"","body":"基础介绍 HTML全称为htyper text markup language，即超文本标记语言。 超文本：即超出了纯文字文本的范畴，它可以包含图片、链接、音乐等非文字元素 标记语言：由标签构成的语言，特点是学习简单上手容易 它最早诞生于1990年，由物理学家蒂姆·伯纳斯-李所创建，在1989年的时候蒂姆·伯纳斯-李就曾在一份备忘录中提出一个基于互联网的超文本系统这样的概念，并且在1990年规定出了HTML并在同年写出了浏览器与软件： 版本 年份 HTML 1991 HTML+ 1993 HTML 2.0 1995 HTML 3.2 1997 HTML 4.01 1999 XHTML 1.0 2000 HTML5 2012 XHTML5 2013 浏览器的作用 其实我们平时上网的过程就是一个不断上传、下载的过程。 浏览器会将我们输入的网址进行解析并请求服务器，服务器将资源返回后浏览器再将资源进行渲染并展示，最终构成了五彩缤纷的页面。 这里推荐大家统一使用Chrome浏览器，它应该算是目前前端开发人员首推的浏览器。 无论是渲染、调试等都是十分方便的，你可以打开浏览器后按f12得到控制台，在这里你可以做任何你想做的事。 而关于IDE的选择就有很多，你可以使用webstorm或者vscode。 认识文档树 我们拿一段最简单的HTML举例，可以暂时不用管他的内容，只看它的结构： Document HELLO WORLD 通过观察上面的这一小段代码，可以看出一个标准的HTML文档内容至少包含三部分，分别是最外部的标签，内部的标签和标签，而一个页面呈现的内容都会在标签中进行书写。 如果按照结构进行划分，那么我们就会得到一颗倒置的多叉树： 文档声明是什么 早期的浏览器种类繁杂，相同的代码在不同浏览器下的渲染结果都不相同。 为了避免这种差异化，万维网联盟（W3C）出台了一系列标准化的规范，如下这行代码： 就是声明该文档为HTML文档，告诉浏览器应当采用HTML标准模式进行渲染，如果不添加此标签代表使用浏览器自带的模式，也被称为怪异模式进行渲染，因此后面的学习中一定要将它加上。 怪异模式：BackCompat，浏览器使用自己的解析标准进行页面渲染 标准模式：CSS1Comapt，浏览器采用W3C的解析标准进行页面渲染 认识标签 什么是标签 标签是由一对儿尖括号包裹的单词构成，如就是一个标签。 标签分为闭合标签和自闭和标签。 闭合标签必须要有开始标签和结束标签，如： 自闭和标签则不需要结束标签，如： 自闭和标签我们通常会在后面加上一条斜杠，来更加容易区分： 标签名字不能以数字开头。 标签本身不区分大小写，如和渲染效果都是相同的，但是为了可读性更加推荐使用全小写。 此外，标签支持嵌套，如：，但是不支持交叉嵌套，如。 注释标签 注释标签是指不会被浏览器渲染的标签，作用是让人更好的理解这段代码的意思。 它以结尾。 内联标签 内联（inline）标签也被称为行内标签，它具有以下的一些特点： 不独占一行，可以和其他内联标签处于同一行上 不可设置宽度和高度，内联标签的宽高都是固定的 宽高本身是其内联标签文字或者图片的高度，不可以被改变 内联标签只能容纳文本或者嵌套其他的内联标签，不可嵌套块级标签 特殊的几个内联标签： img、input可以设置宽高，它们拥有内联标签和块级标签的特性，因此也被称为内联块级标签（inline-block） 块级标签 块级标签（block）常用于布局中，它具有以下的一些特点： 块级标签独占一行，这一行中不可并列其他的标签 可以设置宽度和高度 宽度的缺省值是容器的100%，除非设定一个宽度，换而言之就是一行占满 块级标签可以容纳文本或者嵌套其他的任何标签 特殊的几个块级标签： h~系、dt、p标签中只能包含内联标签，不能包含块级标签 认识属性 什么是属性 每个标签都能带上一些属性，这些属性或有特殊意义，或是开发人员自定义的用来存放某些特殊值的容器。 属性通常是以键值对形式出现，例如 gender=“male” 属性只能出现在开始标签或者自闭和标签中，不能出现在结束标签中 属性名字必须全部小写，属性值必须使用双引号或者单引号包裹，例如 gender=“male” 如果属性值合属性名一样，可以直接写属性名，例如 readonly id id属性是HTML4.0之后加入的，作用是用于定位某一个特定的标签，每一个标签的id属性在文档中必须是唯一的。 id属性在命名时，如果有多个单词则推荐使用 - 进行分割，这个主要涉及到与Js中window对象的冲突。 class class属性的作用是为一组相同功能的标签打上标识，用于对其添加CSS样式。 class属性在命名时，如果有多个单词则推荐使用 _ 进行分割，主要与id属性做区分。 文档渲染 渲染方式 浏览器的渲染是自上而下的，也就是说书写在HTML文档顶部的标签会比书写在HTML文档底部的标签先渲染到。 这个尤为重要，特别是后期学习CSS和JS的时候，它们的引入标签一般都要放在下面才能正确的找到并操纵HTML标签。 当然你也可以做一些特殊的处理，这里按下不表。 特殊字符 文档渲染的时候，有些字符不会被渲染出来。如多个空格仅显示一个，多个p标签仅一个生效等： h f 输入不会正常渲染等： 这个时候我们需要用到一些特殊字符来进行渲染，如下表所示： 特殊字符 含义 &nbsp; 空格 &lt; 小于号 &gt; 大于号 > &quot; 双引号 '' &copy; 圆圈c © &reg; 圆圈r ® &trade; 商标™ &amp; 符号& 流式排列 文档渲染的时候会按照自左向右自上而下的排列方式进行排列，这种排列方式也被称之为文档流排列。 如下所示，内联标签一行可以有多个，而块级标签独占一行。 标签修复 当一个HTML文档没有任何内容，仅只有一段文字时，浏览器会自动生成HTML结构并将文字放入body标签中： hello world 标签移动 所有的页面上展示的内容都要写在body标签中，如果写在了外面浏览器会自动将该内容移动进body标签里： Document this is title 渲染结果，h1标签被加入了body标签内： 表格处理 table标签中不允许放入非表格系的其他内容，否则浏览器在渲染时会将该内容放出去： Document this is title this is table 渲染结果，h1标签被移出了table标签内： 其他的知识 缩进规范 由于前端代码比较繁琐，故缩进推荐使用2空格进行缩进。 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-07-15 14:53:04 "},"前端专栏/HTML/声明系标签.html":{"url":"前端专栏/HTML/声明系标签.html","title":"声明系标签","keywords":"","body":"!DOCTYPE html 指定文档格式为HTML格式，浏览器会根据W3C的HTML标准格式渲染该文档中的内容。 该标签为必加标签。 html 根标签 HTML内容书写区域，也被称为根标签，所有的内容都应该写到他的内部。 属性：lang = “en” 表示页面是英文格式，翻译页面时会读取此值来获取当前页面是什么语言编写。 head 头部信息 该标签的作用是专门提供一下网页的配置信息，如网页的标题，检索内容，解码格式等等。 该部分内容虽然不会在页面展示，但也起到非常重要的作用。 title 页面标题 title标签用于指定网页的标题： link 页面图标 link标签可以设置网页标题上的图标： meta 元信息 meta标签可提供有关页面的元信息（meta-information），它能针对性的设置搜索引擎和更新频度相关的描述和关键词。 该标签位于head标签中，是一个自闭和标签。 它所提供的信息是用户不可见的。 字符编码 meta标签设置charset属性，可指定浏览器解析该文档时所使用的字符编码： Document 页面刷新 meta标签的http-equiv属性可用于页面刷新，指定该属性值为“Refresh”即可，此外你还应当在content属性中设置刷新频率。 下面这个示例中是五秒刷新一次页面，使用meta标签进行页面刷新的应用场景非常少，可忽略不计。 Document 页面跳转 meta标签的http-equiv属性还可用于页面跳转，指定该属性值为“Refresh”即可，此外你还应当在content属性中设置几秒后进行跳转，以及跳转的url，使用;进行分割。 下面这个示例中是两秒后跳转到google，使用meta标签进行页面跳转的应用场景非常少，可忽略不计。 Document 关键字筛选 meta标签的name属性可用于指定页面关键字，用于搜索引擎收录与关键字搜索。 如下所示，需要设置name属性为keywords以及在content中写入关键词即可： 网站描述 meta标签的name属性可用于书写网站描述信息，用于搜索引擎收录与网站分类。 如下所示，需要设置name属性为Description以及在content中写入网站描述即可： IE渲染 IE浏览器是前端开发领域最难搞的浏览器，因为它有一种自己的渲染规则，且每个IE版本的渲染规则都不一样。 meta标签的http-equiv属性设置为\"X-UA-Compatible”，即可告诉IE浏览器用最高级的渲染模式渲染当前页面： --> Document 国产浏览器渲染 一般的国产浏览器都会支持IE内核（兼容模式）和webkit内核（高速模式），且默认都是以兼容模式对页面进行渲染。 meta标签的name属性设置为”renderer”且content设置为“webkit”后，即可告诉国产浏览器用高速模式渲染当前页面： Document 触屏缩放 meta标签还可以设置页面是否支持触屏缩放的功能，只需将name设置为“viewport”以及在content中添加对应的选项即可。 如下所示： Document 常见的选项有： width=device-width：宽度按照设备屏幕宽度进行自适应 initial-scale=1.0：初始显示的缩放比例 minimum-scale=0.5：最小缩放比例 maximum-scale=1.0：最大缩放比例 user-scalable=yes：是否支持触屏缩放 常见的设置 上面就是关于head部分最常见的设置，最后放上一个模板： HTML学习 HELLO WORLD body 页面主体 body标签为页面主体标签，用户能看到的内容都包含在body标签内。 它里面能够书写的标签非常多，为了方便记忆我将它们分为了7类，如下所示： 文本系标签 结构系标签 链接系标签 列表系标签 表格系标签 表单系标签 媒体系标签 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-07-08 20:21:30 "},"前端专栏/HTML/结构系标签.html":{"url":"前端专栏/HTML/结构系标签.html","title":"结构系标签","keywords":"","body":"header 页眉标签 header标签代表一块内容区域的头部，一个页面中可以有一个或多个header标签。 它是一个块级标签： nav 导航标签 nav标签代表一块内容区域的导航，一个页面中可以有一个或多个nav标签。 它是一个块级标签： main 主内容标签 mian标签代表主要内容区域，一个页面中可以有一个或多个main标签，但通常只会定义一个。 它是一个块级标签： footer 页脚标签 footer标签代表一块内容区域的页脚，一个页面中可以有一个或多个footer标签，通常与header标签相对应。 它是一个块级标签： article 子内容标签 article标签代表一块子内容区域，一个页面中可以有一个或多个article标签。 它是一个块级标签： section 区块标签 article标签代表一个区块，一般是一组相似内容的排列组合，它可以有多个。 它是一个块级标签： aside 附加区域标签 aside标签代表一个附加内容块，可以放一些与主体内容无关的内容，如轮播图、广告、公告等。 它是一个块级标签： div 通用容器标签 div标签没有明确的界限来规定它做什么，与span标签类似。 上面标签能做的它都能做，所以他变成了一个万能的容器标签。 div标签是一个块级标签，你打开页面看见的都是它： Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-07-09 15:49:20 "},"前端专栏/HTML/文本系标签.html":{"url":"前端专栏/HTML/文本系标签.html","title":"文本系标签","keywords":"","body":"基础文本系标签 h~ 标题标签 h系列的标题标签拥有6个，即h1 - h6。 h系列标签会根据等级的大小，字体的粗细会发生相应的变化，h1最大、h6最小。 它是一个块级的自闭和标签，其内部只能嵌套内联标签，不能嵌套块级标签 Document h1 element h2 element h3 element h4 element h5 element h6 element 渲染结果： p 段落标签 p标签用于定义一段文本的内容，具有换行的功能。 p标签内只能存放文字系、图片系、表单系标签，其他的一律不要放进来，此外还需要注意p标签与br标签的区别。 它是一个块级标签： Document This is p element This is p element 渲染结果： br 换行标签 br标签用于对内容进行换行，注意与p标签的区别。 它是一个内联标签： Document This is p element This is p element this is a text this is a text 渲染结果： hr 水平线 hr标签会生成一条水平线，主要是用于对内容区域的划分。 它是一个块级标签： Document this is p element this is p element center 居中显示 center标签会将它内部的元素进行居中处理，h5中已经不推荐使用了。 它是一个块级标签： Document h1 element center h2 element don't center 渲染结果： font 普通文字 font标签没什么特别的效果，只有一个语义规定它应该包裹一串文字。被font包裹的文字可设置字体、尺寸和颜色，但是不推荐设置。 它是一个内联标签。 属性表： 属性 值 描述 color rgb(x, x, x) or #xxxxxx or color_name 设置字体颜色 face font_family 设置字体样式 size number 设置字体带下，1-7 如下所示： Document this is font 渲染结果： pre 原样显示 浏览器在渲染时，会对显示进行特殊处理，如多个空格压缩成一个。 此时可以选择使用pre标签对显示内容进行包裹，这样浏览器就不会特殊处理这一段显示内容了。 它是一个块级标签： Document A B C D E F 渲染结果： span 文本容器 span标签用于存放一些文本，它的语义并不是很明确，属于一个模糊的定位。 被span标签包裹的文本有极大的可能性后期会通过CSS进行样式修改，但若单纯使用HTML则没有任何明显的功能。 它是一个内联标签： Document #span-1{ color: red; font-style: italic; text-shadow: #ddd 5px 5px 0.4px; font-size: 22px; font-weight: bold; } This is a text 搭配CSS的渲染效果： 描述文本系标签 time 时间文本 time标签根据语义来进行区分的话可以用于存放时间类型的文本。 它是一个内联标签： Document current time 2016-02-18 渲染效果： abbr 描述文本 abbr标签用于存放一些具有描述的文本，它拥有一个title属性，title属性中可以放入一些描述信息。 当鼠标悬浮在abbr标签上，就可以显示title中所定义的描述信息。 它是一个内联标签： Document I want to say hello world 渲染效果，虽然具有下划线但是不必在意，后期CSS会帮你干掉他： sup - sub 角标 sup和sub用于定义上下角标，在书写一些数学公式时有用。 它们都是内联标签： Document sup : 3 2 sub : 3 2 渲染效果： code 代码文本 code标签中应当存放一些代码相关的文本，但是他没有任何特殊处理。 所以我们可以在外部套上pre标签，来达到代码原样显示的目的，这样代码的缩进才不会发生混乱。 它是内联标签： Document Here is a js code function show(){ console.log(\"hello world\"); } show() 渲染结果： progress 进度条 progress可生成一个进度条，它具有2个属性。 max：进度条长度 value：当前进度 后期可配合Js来进行控制。 它是一个内联标签： Document 渲染结果： address 地址信息 address用于设置地址信息。一般放在footer页脚中。 它是一个块级标签： Document 地址 : 北京市海淀区 渲染结果： 强调文本系标签 em - i 比较重要 em和i标签都意味着这段文字比较重要。 它们同属于内联标签： Document this is em element this is i element 渲染结果： strong - b 非常重要 strong和b标签都意味着这段文字非常重要。 它们同属于内联标签： Document this is strong element this is b element 渲染结果： del - s 已废弃 del和s标签都意味着这段文字已经废弃。 它们同属于内联标签： Document this is strong element this is b element 渲染结果： ins - u 已修正 ins和u标签都意味着这段文字已经修正，常和del与s标签搭配使用。 它们同属于内联标签： Document 原价：998 现价：9.8 渲染结果： mark 值得记录 mark标签都意味着这段文字值得记录，会以突出的方式进行显示。 它是一个内联标签： Document 普通文本 值得记录 渲染结果： 引用文本系标签 cite 引用信息 cite标签通常表示它所包含的文本对某个参考文献的引用，或文章作者的名字。 它属于块级标签： Document --再别康桥 &nbsp;&nbsp;轻轻的我走了，正如我轻轻地来 渲染结果： blockquote 块引用 blockquote标签通常来表示该段内容引用至其他地方。 它属于块级标签： Document --狂人日记 凡事总需研究，才会明白，古来时常吃人，我也还记得，可是不甚清楚。 我翻开历史一查，这历史没有年代，歪歪斜斜的每页上都写着“仁义道德”几个字。 我横竖睡不着，仔细看了半夜，才从字缝里看出来，满本都写着两个字是“吃人”！ 渲染结果： q 行内应用 q标签用于表示行内引用文本，在大部分浏览器中会加上引号。 它属于内联标签： Document --狂人日记 凡事总需研究，才会明白，古来时常吃人，我也还记得，可是不甚清楚。 我翻开历史一查，这历史没有年代，歪歪斜斜的每页上都写着“仁义道德”几个字。 我横竖睡不着，仔细看了半夜，才从字缝里看出来，满本都写着两个字是“吃人”！ 鲁迅先生的吃人一词用的恰到好处！ 渲染效果： Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-07-08 20:23:13 "},"前端专栏/HTML/链接系标签.html":{"url":"前端专栏/HTML/链接系标签.html","title":"链接系标签","keywords":"","body":"a 超链接 基本使用 a标签可定义一个超链接，用于从当前页面跳转到另一个页面。 a标签最重要的属性为href属性，它指向链接的目标。 它是一个内联标签： Document go to google search 渲染结果： 可以看见它虽然有一个下划线，但是不必在意，后期我们可以用CSS干掉他。 默认行为 如果一个a标签没有设置href属性的值，则默认它会刷新当前页面。 你可以给该属性的值设置为#或者“javascript:void(0)”以阻止它的默认行为： Document Don't Refresh 锚点定位 我们可以将a标签的href属性值设置为另一个标签的id属性，这样就可以做到锚点定位，href属性设置锚点的时候必须以#号跟上id的格式进行设置。 锚：指得是a标签的href属性 锚点：指的是被链接的标签id值 如下所示： Document goto chapter one goto chapter two goto chapter third goto chapter four Chapter One Chapter Two Chapter Third Chapter Four 拨打电话 针对移动端用户，a标签也可以用于拨打电话： Document call mobile customer service 渲染结果： 下载文件 如果a标签的href属性跟上一个下载链接地址，则可以下载到浏览器无法处理的文件。 如果要下载图像则需要后台语言先告知浏览器mime的类型： Document download image 常用属性 以下是a标签的常用属性： 属性 值 描述 href url 规定链接指向的url target _blank, _parent, _self, _top 规定在何处打开链接文档 title text 规定链接的标题描述 target属性是非常重要的，它有常用的4个属性，如下释义： _blank：在新窗口中打开链接文档 _parent：在父窗口中打开链接文档 _self：在当前窗口中打开链接文档（默认值） _top：在顶级窗口中打开链接文档 而title属性作用是在鼠标悬浮到a标签上时展示链接标题描述，这里不再例举。 img 图像资源 基本使用 img标签可使用src属性来链接一个图像资源，当前页面中会展示出该图像。 它是一个内联块级标签： Document 渲染结果： 三种格式 src属性支持3种格式的资源： base64位数据流格式 相对路径格式：./ 或者 ../ 网络资源格式：http:// 注意！它不支持file://，因为Unix下没有盘符的概念。 对于第一种，你可以打开网站图片数据流在线转换后传入图片获得base64位的数据流，然后添加至img标签的src属性中查看效果，这里不再进行演示。 等比缩放 如果要保证图像的等比例缩放，请只设置width和height属性其中一个。 Document 渲染结果： 图像链接 我们可以让a标签来包裹img标签，达到图像链接的目的。 前提是，a标签必须使用CSS将它设置为内联块级标签，以便内部嵌套img标签。 Document a{ display: inline-block; } 渲染效果： 常用属性 下面是img标签中常见的属性： 属性 值 描述 alt text 当图像加载失效后，将显示该属性值以替换图像 src url 图像的链接资源 width px、% 设置图像的宽度 height px、% 设置图像的高度 title text 设置图像的悬停文本 iframe 内联框架 基本使用 iframe标签的src属性可以将另外的整个页面都拿过来显示，类似于画中画的概念。 它是一个块级标签： Document Welcome to bilibili 渲染效果： 应用场景 钓鱼网站、伪Ajax请求。 iframe在实际开发中用的较少，但是在某些特定的场景下搭配一些其他的技术可达到令人意想不到的效果。 常用属性 下面是iframe标签中常见的属性： 属性 值 描述 name frame_name 规定iframe的名称 src url 规定在iframe中显示文档的url scrolling yes、no、auto 规定是否在iframe中显示滚动条 width px、% 规定iframe的宽度 height px、% 规定iframe的高度 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-08-03 18:42:23 "},"前端专栏/HTML/列表系标签.html":{"url":"前端专栏/HTML/列表系标签.html","title":"列表系标签","keywords":"","body":"ul - li 无序列表 基本使用 ul和li标签用于定义一个无序列表。 它们都是块级标签，使用ul来嵌套li标签，并在li标签中书写列表排列的元素. 你可以在li中书写任意元素，如a标签、纯文本、图片等： Document Unordered list go to google go to biying go to bilibili go to youtube 渲染结果： 样式修改 ul标签和li标签都可以修改样式，它们均有一个属性type，该属性可以定义以下的值： disc：实心圆（默认样式） circle：空心圆 square：实现块 1：数字列表（仅li支持设置） A：大写英文字母列表（仅li支持设置） a：小写英文字母列表（仅li支持设置） I：大写罗马字母列表（仅li支持设置） i：小写罗马字母列表（仅li支持设置） 如下所示： Document Unordered list set li styles separately DISC CIRCLE SQUARE Number Uppercase English letter Lowercase English letter Uppercase Rome letter Lowercase Rome letter Unordered list set ul styles unite SQUARE SQUARE SQUARE 渲染结果： 注意！当ul和li同时设置样式时，以li的样式为准。 ol - li 有序列表 基本使用 ol和li标签用于定义一个有序列表。 它们都是块级标签，使用ol来嵌套li标签，并在li标签中书写列表排列的元素。 你可以在li中书写任意元素，如a标签、纯文本、图片等： Document Ordered list go to google go to biying go to bilibili go to youtube 渲染结果： 样式修改 同ul一样，ol也支持修改列表样式，它的type属性共有以下8个值选项： disc：实心圆（默认样式） circle：空心圆 square：实现块 1：数字列表 A：大写英文字母列表 a：小写英文字母列表 I：大写罗马字母列表 i：小写罗马字母列表 我们单独设置li标签，来看一下不同的样式效果： Document Ordered list DISC CIRCLE SQUARE Number Uppercase English letter Lowercase English letter Uppercase Rome letter Lowercase Rome letter 渲染结果： 注意！当ol和li同时设置样式时，以li的样式为准。 升序降序 有序列表之所以称为有序，是因为它可以按照列表的排列对列表编号进行升序或者降序。 只需要使用ol标签的reversed属性进行设置即可，如果添加了该属性则是降序，不添加则为升序： Document asc A B C D E desc A B C D E 渲染结果： 起始值设定 给ul标签设置start属性，可用于生成初始编号，后续生成的编号都按照该初始编号进行生成： Document asc SQUARE SQUARE SQUARE SQUARE 渲染结果： dl - dt - dd 自定义列表 基本使用 使用dl、dt、dd来构建一个自定义列表，常见于小说章节预览、首页文章排列中。 dl用于声明这是一个自定义列表。 dt用于定义这是一个标题。 dd用于定义一个段落。 如下所示： Document dl dt dd Chapter One this is chapter one content ... Chapter Two this is chapter two content ... 渲染结果： Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-07-09 16:29:14 "},"前端专栏/HTML/表格系标签.html":{"url":"前端专栏/HTML/表格系标签.html","title":"表格系标签","keywords":"","body":"table 表格标签 table标签用于定义一个表格。 它是一个块级标签，内部可用于嵌套的元素较多： caption - 表格标题 thead - 表头结构（仅语义化标签，无实际作用） tbody - 表体结构（仅语义化标签，无实际作用） tfoot - 表尾结构（仅语义化标签，无实际作用） th - 表头单元格 td - 表体单元格 tr - 表行 如下所示，定义一个4行3列的表格： Document this is table name age gender Jack 18 male Mary 19 female .. .. .. 渲染结果： 边框合并 table标签应当设置的2个属性： border=\"1\" style=\"border-collapse:collapse;\" border：表格线的宽度，单位是px border-collapse：边框合并 这样看起来会好看许多： 表格大小 table标签可设置width和height属性，因此我们可以适当调整表格的大小： ... 渲染结果： 表格位置 表格的位置可以通过table标签的align属性来设置： left：表格居左 center：表格居中 right：表格居右 如下所示： ... 单元格合并 每个td或者th标签都有2个属性，rowspan和clospan，它们能够控制单元格的合并。 rowspan：纵向合并单元格（行合并） clospan：横向合并单元格（列合并） 如下所示： Document this is table name age gender other Jack 18 male Mary 19 female this is footage 渲染结果： Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-07-09 17:02:18 "},"前端专栏/HTML/表单系标签.html":{"url":"前端专栏/HTML/表单系标签.html","title":"表单系标签","keywords":"","body":"form 表单 基本介绍 form表单可用于向服务端提交数据，它是一个块级标签。 我们常见的登录框、留言板等很多功能都是通过form表单完成的，使用form表单进行数据提交会导致页面的刷新。 下面将采用flask框架作为后端，使用form表单进行一次数据提交。 后端代码，注意！表单action提交时不会触发浏览器的同源策略，所以后端并不需要做CORS： from flask import Flask from flask import request app = Flask(__name__) @app.route(\"/get\", methods=['GET']) def get_handler(): return f\"{request.args}\" @app.route(\"/post\", methods=['POST']) def post_handler(): return f\"{request.form}\" if __name__ == \"__main__\": app.run(debug=True) 前端代码： Document username password male female submit 整体效果如下： 前端提交的数据会被后端的服务器所接收到。 action 提交地址 form表单中action属性可设置表单内容的提交地址。 它指向一个url，一般情况下我们都会加上完整url，但如果你是前后端混合开发项目的话则可以不用加完整url。 下面这个是完整路径，如果点击提交表单它会朝这个url发起请求： 如果你把他改为非完整路径，它会朝当前页面发起请求，注意观察下面与上述地址栏中的端口变化： method 提交方式 form表单中的method属性可设置表单提交时的HTTP请求方式。 有2种选项： GET请求（form提交时的默认选择） POST请求 它们的区别如下。 GET请求： 没有请求体 数据必须控制在1KB之内 请求的数据会暴露在地址栏中（?之后，以&进行分割） POST请求： 有请求体 数据的大小没有上限 请求的数据不会暴露在地址栏中，因此相较于GET请求更加安全 以下行为将会触发GET请求： 地址栏直接输入地址并访问 点击页面a标签进行链接跳转 默认的form表单提交方式 img的图像资源请求 说的更直白一点，GET请求不能上传文件，但是POST请求可以上传文件。 enctype 数据编码 form表单中的enctype属性可设置表单提交时对于提交数据的编码方式。 application/x-www-form-urlencoded：url编码格式，也是form表单默认的编码格式，它不允许上传文件，一般配合GET方式使用 multipart/form-data：不对字符进行编码，它允许上传文件，一般配合POST方式进行使用 text/plain：将空格转换为“+”号，但不对特殊字符进行编码 url编码格式的特点： 将空格转换为 \"+\" 加号，特殊符号转换为 ASCII HEX 值 一言以蔽之，若想上传文件，则必须使用POST请求方式 + multipart/form-data的编码方式： target 提交结果 form表单中的target属性可设置表单提交后会在哪里打开action的提交结果。 有以下5个值： _blank：在新窗口中打开action的提交结果 _parent：在父窗口中打开action的提交结果 _self：在当前窗口中打开action的提交结果（默认值） _top：在顶级窗口中打开action的提交结果 framename：在内联框架iframe中打开action的提交结果 这个属性其实很少用到，但是该属性可以搭配一些其他的技术做到无页面刷新提交的功能，因此这里例举一下，后面也会有所介绍。 示例如下，提交后将会在新的页面打开提交结果： novalidate 取消验证 form表单中的novalidate属性可设置表单提交时不会验证填入数据的合法性。 有的input框可以设置为必填，如果一个必填的input框没有填入内容则在提交时浏览器将提示必须填写该字段，我们可以通过设定novalidate来取消这个验证功能。 如下是设置了提交验证的表单： submit 当点击提交时浏览器会提示你填入该字段： 如果为form表单加上了novalidate属性后，它将会直接提交，注意观察地址栏中的变化： submit 点击提交后页面会刷新一次，这代表已经绕过验证成功提交了： input 输入框 基本介绍 input标签为表单输入框，它是一个内联块级标签。 input框有多种形态，只需要设置属性type的值即可，如下表所示： 属性值 表现形式 对应代码 text 文本输入框 password 密码输入框 number 数字输入框 date 日期输入框 > checkbox 复选框 radio 单选框 submit 提交按钮 reset 重置按钮 button 普通按钮 hidden 隐藏输入框 file 文件选择框 list 数据列表栏 text 文本输入框 文本输入框可输入任何内容，它有2个最重要的属性name和value。 当form表单点击提交时，文本输入框会将输入的值赋值给value属性，并将name属性和value属性组成一组键值对提交给后端。 如果没有显式的设置value，那么这个文本输入框的内容是空的，当你输入内容后它会自动添加value属性并将所输入内容赋值给该属性： 渲染结果： 如果显式的设置了value，那么它就会作为默认值显示在文本输入框中： 渲染结果： 我们一般都不会这样做，而是利用placeholder属性来提示用户应该输入什么内容，placeholder属性在form表单提交时并不会被收集： 渲染结果： 除此之外，你可以使用required属性来规定该输入框是必填项，前提是form表单验证已被打开它才会生效： 如果使用了readonly属性，则该输入框就会变为只读，它通常和value设置的默认值搭配使用： 渲染结果： 你也可以使用disabled禁止该输入框，用户只能看到灰色被禁用的输入框，不能进行内容输入： 渲染结果： password 密码输入框 密码输入框和文本输入框差不多，不同的是输入内容时浏览器会用黑色实心圆遮蔽掉用户键入的内容： 渲染结果： 其他的属性和文本输入框通用。 number 数字输入框 数字输入框仅能够输入数字，不能输入其他的字符，可用于输入手机号： 其他的属性和文本输入框通用。 date 日期输入框 日期输入框可以上传一个年月日。 当input的type为datetime-local时，可以上传一份本地化的时间（年月日时分秒） 当input的type为date时，可以上传一份标准化的世界时间（年月日） 当input的type为month时，可以上传年份和月份 当input的type为time时，可以上传小时和分钟数 当input的type为week时，可以上传年份和周数 除此之外，你可以利用min属性设置开始时间，max属性设置结束时间，step属性设置步长即多少时间一个间隔： 如下所示： 渲染结果： checkbox 复选框 复选框常用于勾选兴趣爱好，一般来说都要具有多个。 像这种复选框或者单选框之类的，都应该显式的设置value，不然提交的数据则为空。 注意，一组复选框内的name应该都相同，而value则应该不同，如下所示： basketball: football: volleyball: 渲染结果： 当点击提交后，它会以列表的方式将所勾选的checkbox的value进行整合，类似于下面这种格式： { \"hobby\" : [\"basketball\", \"football\"] } 此外，如果你想让某个复选框设置为默认的，可为它添加checked属性即可： basketball: 这样在渲染页面时，该复选框就会被选中： 在某些特殊的情况下我们只会设置一个复选框，如用户必须点击已阅读协议后才能进行下一步操作，此时你可以将该复选框设置为required，即必填，然后搭配Js做到这样的效果，这里不再例举。 radio 单选框 单选框的使用与复选框基本相同。 必须显式的设置value，且name要一致： male: female: 提交 渲染结果： 此外，如果想设置默认值，则在radio上加上checked属性即可。 如果想设置多个radio中必须至少选择一个，则在任意一个同组的radio上添加属性required即可。 submit 提交按钮 input的type设置为submit后，可用于提交表单的内容，你可以为其设置value属性值来指定按钮显示内容： 当点击该按钮后，form表单将发送数据至后端。 渲染结果： reset 重置按钮 input的type设置为reset后，可用于清空表单的内容，你可以为其设置value属性值来指定按钮显示内容： 当点击该按钮后，form表单中所有以填项都会被清空。 渲染结果： button 普通按钮 input的type设置为button后，可用于与JavaScript代码进行交互，你可以为其设置value属性值来指定按钮显示内容： Document \"use strict\"; document.querySelector(\"input[type=button]\").addEventListener(\"click\", () => { console.log(\"click in button\") }) 为该按钮绑定Js事件，点击按钮后将触发Js事件。 渲染结果： hidden 隐藏输入框 隐藏输入框可用于存储一些用户不可见的数据，如用户的ID号等信息，这在修改用户密码时很常用。 在进行form表单提交时，它将一起提交给后端： Document old password : new password : submit button 提交后的结果： ImmutableMultiDict([('user-id', '31926'), ('old_password', '123'), ('new_password', '456')]) file 文件选择框 当input的属性为file时，可用于上传文件。 注意，如想成功上传文件，则： form表单的method必须为POST form表单的enctype必须为multipart/form-data 如下示例，需要注意文本选择框也必须设置name属性，否则将无法上传文件： Document avatar : submit button 渲染结果如下： 后端flask可用request.files进行文件接收，以下是接收内容： ImmutableMultiDict([('avatar', )]) 我们为文本选择框新增属性multiple，用于一次性上传多个文件： avatar : 除此之外，我们也可以为文本框新增属性accept，用来指定允许上传文件的mime类型： avatar : 这样在文件选择时，你只能选择png或者gif格式的图片了： datalist 数据列表 通过数据列表，我们可以展示一些信息供用户选择，它由3种标签构成分别是input、datalist、option。 input首先设置为文本输入框，然后添加属性list并给定一个关键字，此外你还需要设置name属性。 而后输入datalist标签，该标签的id和文本输入框的list关键字一致。 在datalist标签中嵌套option标签，并设置value值，这样数据列表就做好了： Document city: Beijing Shanghai Tianjin Chongqing submit button 渲染结果： 注意！数据列表中一次只能选定一个选项。 input的常见属性 下表中将例举input中常见的属性： 属性 值 描述 name field_name 表单提交时的键 value text 表单提交时的值 placeholder text 输入提示 checked checked radio和checkbox默认选中 readonly readonly 只读 disabled disabled 禁用 required required 必填 size number 定义输入框显示宽度 min number 定义输入的字段最小值 max number 定义输入的字段最大值 pattern regexp 对输入内容进行正则验证 oninvalid JavaScript 当正则验证失败后运行的代码 autocomplete on 、off 自动记录键入输入历史 以下是常用属性举例： Document placeholder male: female: checked readonly disabled required size:3 min:10 max:100 email autocomplete submit button label 标签 基本介绍 label标签通常与input标签绑定使用，它将作为input标签的标注出现，它是一个块级标签。 label有一个特殊的属性，for，该属性的值应当与被绑定的input标签id值相同。 我们看一个简单的例子来理解label标签的作用，下面这个例子中是没有label标签的，当点击关键字“male”或者“female”时，浏览器不会自动聚焦到radio上： Document male: female: 渲染结果： 如果使用label标签作为radio的标注，则点击label标签文本时，浏览器将会自动的聚焦在radio标签上： Document male: female: select 选择框 基本介绍 select标签与optgroup标签（可选）和option标签搭配可作出选择框的效果。 它类似于数据列表，但比数据列表更加强大，以下是这3个标签的可选常用属性。 首先是select标签，它最少要设定一个属性name，作为键与option的value进行搭配： 属性 值 描述 name text 规定发往服务器的选项键 multiple multiple 规定下拉列表是否可以多选 autofocus autofocus 页面加载完成后文本区域自动获取焦点 disabled disabled 禁用该下拉列表 required required 规定文本区域是必填的 size number 规定下拉列表中可见选项的数目 其次是optgroup标签，这是一个可选标签，也就是说选择框的组成它并不是必须的： 属性 值 描述 label text 为选项组规定描述 disabled disabled 禁用该选项组 最后是option标签，它最少要设定一个属性value，作为值与select标签的name进行搭配： 属性 值 描述 value text 规定发往服务器的选项值 label text 定义当使用optgroup时所使用的标注 selected selected 规定默认选中的选项 disabled disabled 规定此选项应当在首次加载时禁用 单项选择框 下面是一个单项选择框的示例： Document city: Beijing Shanghai Tianjin Chongqing NewYork SanFrancisco LosAngeles Miami submit button 渲染结果： 多项选择框 如果为select标签新增multiple属性，则该选择框可变为多选： Document city: Beijing Shanghai Tianjin Chongqing NewYork SanFrancisco LosAngeles Miami submit button 渲染结果： 默认选中 当option标签设置为selected后，该标签会被默认选中： Document city: Beijing Shanghai Tianjin Chongqing NewYork SanFrancisco LosAngeles Miami submit button 渲染结果： textarea 文本域 textarea标签与文本输入框类似，但是能够输入更多的内容。 它是一个内联标签，以下是常用属性： 属性 值 描述 name text 规定发往服务器的选项键 autofocus autofocus 规定在页面加载后文本区域自动获得焦点 maxlength number 规定该文本域所支持输入的最大字符数 placeholder text 规定描述文本区域预期值的简短提示 rows number 规定文本域的可见行数，即高度 cols number 规定文本域的可见列数，即宽度 required required 必填 readonly readonly 只读 disabled disabled 禁用 如下所示： Document submit button 渲染结果： fieldset - legend 美化标签 fieldset和legend标签都是块级标签，没什么特别明显的作用就是为了美化元素。 fieldset：为被包裹元素外加上一个框，主要为字段进行逻辑分组 legend：作为fieldset标签的标题出现 如下所示： Document 用户信息 用户名: 密码: 性别 male: female: 其他信息 爱好 篮球 足球 排球 个人介绍 居住城市 北京 上海 天津 重庆 纽约 旧金山 洛杉矶 迈阿密 提交 渲染结果： button 按钮 button标签是一个块级标签，它有一个非常重要的属性type，可设置以下3个常用值： submit：作用和相同，如果不指定type，默认就是它 button，作用和相同 reset，作用和相同 相较于input的按钮，我更倾向于使用button，因为它的语义更加明确。 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-08-14 22:32:26 "},"前端专栏/HTML/媒体系标签.html":{"url":"前端专栏/HTML/媒体系标签.html","title":"媒体系标签","keywords":"","body":"video 视频 video标签可用于播放视频，但是他的效果并不是很好，所以推荐使用一些第三方插件，如： 阿里云播放器 video.js 以下是viedo标签的常用属性，它是一个块级标签： 属性 描述 autoplay 视频自动播放，即视频加载完后会立即播放而不是等待用户进行手动点击 preload 视频预加载，设置为auto即可，它会根据网络情况自动加载视频 controls 视频播放按键，该属性是必须的 height 视频窗口高度 width 视频窗口宽度 loop 视频循环播放 muted 视频播放时静音 poster 视频未播放时显示的图像 src 视频地址 代码如下： Document 渲染结果： audio 音频 audio标签主要用于音频播放，它和video标签基本类似。 以下是audio标签的常用属性，它是一个块级标签： 属性 描述 autoplay 音频自动播放，即音频加载完后会立即播放而不是等待用户进行手动点击 preload 音频预加载，设置为auto即可，它会根据网络情况自动加载视频 controls 音频播放按键，该属性是必须的 loop 音频循环播放 muted 音频播放时静音 src 音频地址 具体效果这里不再演示。 source 媒介元素 有些浏览器不支持多媒体格式，我们可以在video标签或者audio标签中嵌套进source标签，让浏览器支持该种格式的媒体： 使用时注意source标签的src和type属性即可。 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-07-10 16:24:10 "},"前端专栏/CSS/summary.html":{"url":"前端专栏/CSS/summary.html","title":"CSS","keywords":"","body":" 基础知识 选择器 属性继承 常见单位 文本控制 数据样式 背景处理 盒子模型 浮动布局 定位布局 弹性布局 栅格布局 变形动画 过渡时间 帧动画 响应式布局 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-07-20 08:26:13 "},"前端专栏/CSS/基础知识.html":{"url":"前端专栏/CSS/基础知识.html","title":"基础知识","keywords":"","body":"CSS介绍 基本介绍 CSS全称为Cascading Style Sheet，译为层叠样式表。 它能够为HTML进行样式美化以及页面布局。 如果将单纯的HTML所构成的页面当做一副素描画，那么CSS的作用就是为这幅素描画进行上色处理。 当然CSS也能对HTML文档进行布局，让其不再使用默认的文档流排列方式，而是利用CSS让元素进行自由的组合、排列。 值得一提的是在早期没有出现CSS时，对HTML布局我们大多会使用table标签来进行，但是CSS诞生后就不会那么做了，使用CSS布局更加的方便。 关于CSS的学习可分为三大块： 如何选择标签元素 如何操纵标签元素 如何对页面进行布局 版本更迭 CSS1 1994年，哈肯·维姆·莱和伯特·波斯合作设计CSS。他们在1994年首次在芝加哥的一次会议上第一次展示了CSS的建议。 1996年[11]12月发表的CSS1的要求有：[13] 支持字体的大小、字形、强调 支持字的颜色、背景的颜色和其他元素 支持文章特征如字母、词和行之间的距离 支持文字的排列、图像、表格和其他元素 支持边缘、围框和其他关于排版的元素 支持id和class CSS2-2.1 1998年[11]5月W3C发表了CSS2[14]，其中包括新的内容如： 绝对的、相对的和固定的定比特素、媒体型的概念、 双向文件和 一个新的字体。 CSS2.1修改了CSS2中的一些错误，删除了其中基本不被支持的内容和增加了一些已有的浏览器的扩展内容。[15] CSS3 CSS3标准已部分公布，但仍未全部制订完毕，还会有其它新内容继续加入。W3C网站上有专页展示CSS3发展的进展[16]。 CSS3的标志。 CSS3分成了不同类别，称为“modules”。而每一个“modules”都有于CSS2中额外增加的功能，以及向后兼容。CSS3早于1999年已经开始制订。[17]直到2011年6月7日，CSS 3 Color Module终于发布为W3C Recommendation。[18] CSS3里增加了不少功能，如：“border-radius”、“text-shadow”、“transform”以及“transition”。CSS3亦支持动画（animation）及立体（preserved-3d）。 部分属性（例如旋转类属性（如：transform），动画类属性，立体类属性），由于现时不同浏览器支持程度不同，需要加上不同的浏览器前缀来区分。 CSS4 W3C于2011年9月29日开始了设计CSS4[19][20]。直至现时只有极少数的功能被部分网页浏览器支持，如使用在HTML而非SVG上的pointer-events[21]。 CSS4增加了一些更方便的选择器，并简化了一些现有选择器的用法。 如何使用CSS 行内式 直接在HTML标签元素中添加style属性并书写CSS代码的方式即为行内式。 行内式并不推荐使用，它对后期维护造成了一些很大的困惑，且代码复用性也较低： Document HELLO WORLD 渲染结果： 嵌入式 在head标签中内嵌style标签，并在style标签中书写CSS代码的方式被称为嵌入式。 嵌入式在调试代码时使用很方便，但是后期项目上线应该将CSS代码和HTML做好分离： Document span:nth-child(1){ background-color: red; color: white; padding: 5px; font-style: italic; } HELLO WORLD 渲染结果： 链接式 在head标签中内嵌子标签link，利用link标签来链接一个已经书写好的CSS样式文件的方式被称为链接式。 链接式是实际生产中最常用的导入CSS样式的方式。 HTML文档： Document HELLO WORLD CSS文件： span:nth-child(1){ background-color: red; color: white; padding: 5px; font-style: italic; } 渲染结果： 导入式 在head标签中内嵌子标签style，style标签中利用CSS所提供的语法@import url(“path”)来导入一个已经书写好的CSS样式文件的方式被称为导入式。 导入式的方式在整合CSS代码时比较常见，如下所示。 HTML文档： Document @import url(\"./all_style.css\"); HELLO WORLD HELLO CSS 整合的CSS文件，all_style.css： @import url(\"./style1.css\"); @import url(\"./style2.css\"); 单独的CSS文件，style1.css： span:nth-child(1){ background-color: red; color: white; padding: 5px; font-style: italic; } 单独的CSS文件，style2.css： div:nth-of-type(1){ background-color: blue; color: white; padding: 5px; font-style: italic; margin-top: 5px; } 渲染结果： 样式重置 所有的HTML都有一些自带的样式，比如body文档有边距并不是直接铺满整个屏幕的，ol、ul等默认样式都是黑色实心圆、a标签有下划线等。 在实际的项目开发中，我们应当将这些默认样式全部取消掉，因此有人专门做了一个CSS文件，名为CSS Rest即为CSS样式重置，在编写CSS代码之前，我们应当先导入这个文件： /* http://meyerweb.com/eric/tools/css/reset/ v2.0 | 20110126 License: none (public domain) */ html, body, div, span, applet, object, iframe, h1, h2, h3, h4, h5, h6, p, blockquote, pre, a, abbr, acronym, address, big, cite, code, del, dfn, em, img, ins, kbd, q, s, samp, small, strike, strong, sub, sup, tt, var, b, u, i, center, dl, dt, dd, ol, ul, li, fieldset, form, label, legend, table, caption, tbody, tfoot, thead, tr, th, td, article, aside, canvas, details, embed, figure, figcaption, footer, header, hgroup, menu, nav, output, ruby, section, summary, time, mark, audio, video { margin: 0; padding: 0; border: 0; font-size: 100%; font: inherit; vertical-align: baseline; } /* HTML5 display-role reset for older browsers */ article, aside, details, figcaption, figure, footer, header, hgroup, menu, nav, section { display: block; } body { line-height: 1; } ol, ul { list-style: none; } blockquote, q { quotes: none; } blockquote:before, blockquote:after, q:before, q:after { content: ''; content: none; } table { border-collapse: collapse; border-spacing: 0; } 注释语法 CSS中若要添加注释，格式如下： /* Comment */ 它可以支持多行注释。 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-07-11 15:33:22 "},"前端专栏/CSS/选择器.html":{"url":"前端专栏/CSS/选择器.html","title":"选择器","keywords":"","body":"基本选择器 * 通用选择器 *会选择所有元素，无视层级。常用于做样式清除，如内边距、外边距清除等。 示例如下，将所有的标签元素文本设置为红色： Document * { color: red; } span element mark element time element p element 渲染结果： E 名字选择器 名字选择器可通过标签名进行选择，无视层级。 示例如下，仅将p标签的文本设置为红色： Document p { color: red; } span element mark element time element p element 渲染结果： # ID选择器 根据标签的id属性来选择元素，无视层级，因HTML标签的id属性具有唯一性，故该选择器每次只能选择一个元素。 它以#作为关键字，后面跟上id即可。 示例如下，将id属性为a的标签文本设置为红色： Document #a { color: red; } span element mark element time element p element 渲染结果： . 类选择器 根据标签的class属性来选择元素，无视层级，因HTML标签的class属性不具有唯一性，故该选择器一次可以选择多个元素。 它以 . 作为关键字，后面跟上class即可。 示例如下，将class属性为inline的标签文本设置为红色： Document .inline { color: red; } span element mark element time element p element 渲染结果： 组合选择器 Feature 交集选择器 交集选择器可以从一组具有特性的共同的元素中取出一个具有独特特征的元素。 示例如下，有2个div： 一个div的id为a 一个div的class为a 若我们想选择其中的一个进行渲染，则必须要使用到交集选择器： 标签名字是div且id是a的标签会选择出第一个div 标签名字是div且class是a的标签会选择出第二个div 由于这种性质，交集选择器也可被称为特征选择器，示例如下： Document div#a { color: blue; } div.a { color: red; } div-id-a div-class-a 渲染结果： E, F 并集选择器 并集选择器可通过逗号来一次选取多个元素。 示例如下，将mark和time标签的文本设置为红色： Document mark, time { color: red; } span element mark element time element p element 渲染结果： E F 后代选择器 后代选择器可以寻找某个元素下的特定元素，它的寻找层级是没有上限的，关键字为空格， 示例如下，我们需要寻找div中嵌套的article中的id为a的mark标签，可直接通过后代选择器进行查找： Document div mark#a { color: red; } time element mark element time element mark element p element 渲染结果： E > F 子代选择器 子代选择器可以寻找某个元素子级下的特定元素，它的寻找层级为1层，关键字为>。 示例如下，我们需要寻找div中嵌套的article中的id为a的mark标签，通过子代查找器就必须严格的对元素关系进行书写，不能跨代： Document div>article>mark#a { color: red; } time element mark element time element mark element p element 渲染结果： E + F 同级毗邻选择器 E+F会查找紧随E元素后的F元素。 即通过哥哥元素找紧挨着自己的弟弟元素。 示例如下： Document /* div的后面必须是p，p的前面也必须是div */ div+p { color: red; } div p div p p 渲染结果： E ~ F 同级多跨选择器 E~F会查找在E元素后的所有F元素。 即通过哥哥元素找自己的所有弟弟元素。 示例如下： Document /* div后面的所有p */ div~p { color: red; } div span p p article p 渲染结果： 伪类选择器 动态伪类选择器 动态伪类选择器是比较常用的一种伪类选择器，如表所示： 选择器 类型 功能描述 E:link 链接伪类选择器 选择匹配的E元素，而且匹配元素被定义了超链接并未被访问过。常用于链接锚点上 E:visited 链接伪类选择器 选择匹配的E元素，而且匹配元素被定义了超链接并已被访问过。常用于链接锚点上 E:active 用户行为选择器 选择匹配的E元素，且匹配元素被激活。常用于链接锚点和按钮上 E:hover 用户行为选择器 选择匹配的E元素，且用户鼠标停留在元素E上。IE6及以下浏览器仅支持a:hover E:focus 用户行为选择器 选择匹配的E元素，而且匹配元素获取焦点时的行为 动态伪类选择器主要针对a标签： Document /* 没点过是红色 */ a:link { color: red; } /* 点击时是绿色 */ a:active { color: green; } /* 点过后是蓝色 */ a:visited { color: blue; } /* 鼠标悬浮时出现阴影 */ a:hover { box-shadow: #ddd 10px 2px 3px; } /* 获得焦点时显示边框 */ a:focus { border: 1px solid red; } click me 目标伪类选择器 目标伪类选择器只有1个，如表所示： 选择器 功能描述 :target 匹配a标签所指向的锚点 这个常用在a标签上，当点击这个a标签后，与这个a标签对应的锚点标签发生变化，示例如下： Document :target { background-color: red; } link first first element link second second element link third third element 渲染结果： 状态伪类选择器 状态伪类选择器主要针对input标签，如表所示： 选择器 示例 说明 :enabled input:enabled 选择每个启用的 input 元素 :disabled input:disabled 选择每个禁用的 input 元素 :checked input:checked 选择每个被选中的 input 元素 :required input:required 选择包含required属性的元素 :optional input:optional 选择不包含required属性的元素 :valid input:valid 选择验证通过的表单元素 :invalid input:invalid 选择验证不通过的表单 这些都很好理解，所以这里就不再进行演示了。 否定伪类选择器 否定伪类选择器只有1个，如表所示： 选择器 功能描述 E:not(F, G) 匹配所有E元素，包含F或者G条件的除外，如果直接使用:not(ele, ele)则相当于反选所有标签 示例如下，选择所有class属性为a的元素，h1排除在外： Document .a:not(h1) { color: red; } h1 element p element div element 渲染结果： 结构伪类选择器 结构伪类选择器是最常用的选择器，如表所示： 择器 功能描述 :root 匹配根元素，即html标签 E:first-child 匹配E元素，并且E元素要作为第一个子元素出现 E:last-child 匹配E元素，并且E元素要作为最后的子元素出现 E:nth-child(n) 根据位置匹配正数第n个子元素E。其中n可以是整数（1，2，3）、关键字（even，odd）、可以是公式（2n+1）,而且n值起始值为1，而不是0 E:nth-last-child(n) 根据位置匹配倒数第n个子元素E。此选择器与E:nth-child(n)选择器计算顺序刚好相反，但使用方法都是一样的，其中：nth-last-child(1)始终匹配最后一个元素，与last-child等同 E:nth-of-type(n) 根据类型匹配正数第n个E元素 E:nth-last-of-type(n) 根据类型匹配倒数第n个E元素 E:first-of-type 根据类型匹配第一个E元素 E:last-of-type 根据类型匹配最后一个E元素 E:only-child 匹配独生子E元素 E:only-of-type 匹配只有一个孩子的E元素 E:empty 匹配没有孩子的E元素 注意事项： :nth-child(n) 中参数只能是n，不可以用其他字母代替 :nth-child(odd) 选择的是奇数项，而使用:nth-last-child(odd)选择的却是偶数项· 这些选择器刚开始理解可能很难，但是用习惯了后会发现真的非常方便。 下面是案例代码： Document :root { /* 直接使用root，选择的是html标签 */ background-color: wheat; } h1:first-child { /* h1必须是第一个子元素，刚好body标签的第一个子元素就是h1 */ color: blue; font-size: 3rem; } main:last-child { /* main必须是最后一个子元素，刚好body标签的最后一个子元素就是main */ border: 1px solid #ddd; background-color: aqua; } main p:nth-child(2) { /* 选择main标签下的第二个子标签，该子标签必须为p */ background-color: red; } ul li:nth-last-child(2) { /* 选择ul标签下的倒数第二个子标签，该子标签必须为li */ background-color: aquamarine; } ul li:nth-of-type(1) { /* 选择ul标签下的第一个子标签，该子标签必须为li */ background-color: deeppink; } ul li:nth-last-of-type(3) { /* 选择ul标签下的倒数第三个子标签，该子标签必须为li */ background-color: deepskyblue; } li:first-of-type { /* 第一个出现的li标签 */ font-size: 1.5rem; } li:last-of-type { /* 最后一个出现的li标签 */ font-size: .9rem; } aside:only-child { /* 选择是独生子的标签，且该标签必须是aside标签 */ font-size: 1.8rem; } footer:only-of-type { /* 选择只有一个儿子的标签，且该标签必须是footer标签 */ background-color: aquamarine; } section:empty { /* 选择没有后代的标签(也包括文本)，且改标签必须是section */ height: 2rem; border: red 1px solid; } hello world li-1 li-2 li-3 div p article aside 属性选择器 属性选择器经常用到，使用它的时候应该考虑到和其他选择器一起搭配使用，如交集选择器。 选择器 功能描述 [attribute] 用于选取带有指定属性的元素 [attribute=value] 用于选取带有指定属性和值的元素 [attribute~=value] 用于选取属性值中包含指定词汇的元素 [attribute|=value] 用于选取带有以指定值开头的属性值的元素，该值必须是整个单词 [attribute^=value] 匹配属性值以指定值开头的每个元素 [attribute$=value] 匹配属性值以指定值结尾的每个元素 [attribute\\=*value] 匹配属性值中包含指定值的每个元素 示例如下，匹配type为text的input标签： Document input[type=text]{ background-color: red; } 渲染结果： 如果想匹配checked或者disabled这种属性名和属性值一样的标签元素，则只需要输入属性名即可： Document input[type=text][disabled]{ background-color: red; } 渲染结果： 文本选择器 文本选择器用的比较少，如表所示： 选择器 功能描述 ::first-line 匹配文本首行 ::first-letter 匹配文本首字母 ::selection 匹配被鼠标划中的文本 如下示例： Document blockquote::first-line{ color:blue; } blockquote::first-letter{ font-size: 2rem; } blockquote::selection{ background-color: yellow; } --狂人日记 凡事总需研究，才会明白，古来时常吃人，我也还记得，可是不甚清楚。 我翻开历史一查，这历史没有年代，歪歪斜斜的每页上都写着“仁义道德”几个字。 我横竖睡不着，仔细看了半夜，才从字缝里看出来，满本都写着两个字是“吃人”！ 渲染结果： 文本插入器 文本插入器有2个： 插入器 描述 ::before 使用 contnet 属性生成额外的内容并插入在标记中，插在前面 ::after 使用 content 属性生成额外的内容并插入在标记中，插在后面 相当于在被选中标签中再插入2个普通的inline标签，注意这2个标签的content的属性是必须的，它规定被插入标签的内容。 此外还需要注意，新插入的内容会改变原标签的大小，所以谨慎使用。 示例如下： Document div { color: yellowgreen; } div::before { content: \"before\"; color: deeppink; } div::after { content: \"after\"; color: deepskyblue; } &nbsp;mid&nbsp; 渲染结果： Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-07-15 15:51:40 "},"前端专栏/CSS/属性继承.html":{"url":"前端专栏/CSS/属性继承.html","title":"属性继承","keywords":"","body":"选择器优先级 不同的选择器具有优先级，如果一个元素同时被多个选择器所选择且设置了同名样式时，它会按照优先级来判定应用哪一个选择器的样式。 如果优先级相同，则下面的选择器生效，常见优先级示例： 行内式渲染：1000 id选择器：100 class选择器：10 name选择器：1 当使用组合选择器时，优先级会进行累加，如下所示： Document /* 有同名属性时会根据优先级排定应用哪一个属性 */ h1 { /* 优先级 = 1 */ color: blue; background-color: red; } h1#title { /* 优先级 = 1 + 100 */ color: white; } HELLO WORLD 最终结果，同名属性color会渲染为第二个选择器： !important 我们可以使用!important关键字来强制更改优先级，让其优先级变的无限高。 有2个需要注意的地方： 如果同名样式都设置成!important，则!important带来的优先级提升会相互抵消，依旧按照选择器优先级来选择最终样式的渲染 如果2个同名样式的选择器优先级相同，还是按照后者覆盖前者的特性进行渲染 所以说，!important不能滥用，大量使用!important可能导致你代码可读性变差： Document /* 有同名属性时会根据优先级排定应用哪一个属性 */ h1 { /* 优先级 = 1 + 无限 */ color: blue !important; background-color: red; } h1#title { /* 优先级 = 1 + 100 */ color: white; } HELLO WORLD 最终结果： 属性继承 对于子标签来说，其父级别或更高级别标签的某些样式是可以被继承的，如： 颜色相关样式 字体相关样式 文本相关样式 但是对于盒模型中的一些属性，如内外边距、浮动等是不能被继承的。 继承而来的属性无限趋于0，可直接被替换掉，并且不能使用!important来提升被继承属性标签的优先级，!!mportant只能影响自身。 如下所示，当div的background-color设置为red，color设置为white后，其内部嵌套标签也会继承到这些属性： Document div{ background-color: red; color: wheat; } h1 h2 h3 h4 h5 h6 渲染结果： 我们可以保留一些继承项，并覆盖掉一些继承项，如下所示： Document div{ background-color: red; color: wheat; } div :nth-child(odd){ background-color: blue; } h1 h2 h3 h4 h5 h6 渲染结果： Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-07-16 20:14:52 "},"前端专栏/CSS/常见单位.html":{"url":"前端专栏/CSS/常见单位.html","title":"常见单位","keywords":"","body":"像素大小 px px是固定的像素单位，如果你的网页要在多端进行使用那么尽可能的少使用它，它不具有响应式的特性。 如下所示： Document div:first-of-type{ font-size: 12px; } div:last-of-type{ font-size: 18px; } 字号设置：12px 字号设置：18px 渲染结果： % 百分数是子元素相对于父元素设置的大小，比如父元素的大小是18px，那么子元素设置为50%就是9px，如下所示： Document main{ font-size: 18px; } div:first-of-type{ font-size: 50%; } div:last-of-type{ font-size: 200%; } 字号设置：main 18px 字号设置：50% = 9px 字号设置：200% = 32px 渲染结果： em em和百分号类似，它也是相较于父元素设置子元素的大小，1em相当于100%，0.5rem相当于50%。 注意，如果是0.x开头的，可直接简写为.x，如下所示： Document main{ font-size: 18px; } div:first-of-type{ font-size: .5em; } div:last-of-type{ font-size: 2em; } 字号设置：main 18px 字号设置：.5em = 9px 字号设置：2em = 36px 渲染结果： rem rem是em的升级版，也是推荐使用的方式。所有的大小设置不会按照父元素的值变化而变化，而是统一以html文档的值做参照。 默认的Chorme浏览器的html文档字号大小为16px，如果某个元素设置为.5rem则是8px。 如下所示： Document :root{ font-size: 16px; } div:first-of-type{ font-size: .5rem; } div:last-of-type{ font-size: 2rem; } 字号设置：html 16px 字号设置：.5em = 8px 字号设置：2em = 32px 渲染结果： 颜色格式 #xxxxxx #xxxxxx（x为16进制数）中所有的x均相同时，可简写为#xxx。 如下所示： Document div:first-of-type{ color: #ddd; } div:last-of-type{ color: #ff0000; } 颜色设置：#ddd 颜色设置：#FF0000 渲染结果： word 可以直接用单词来设置颜色，如color:red;或者color:blue;等。 如下所示： Document div:first-of-type{ color: blue; } div:last-of-type{ color: red; } 颜色设置：blue 颜色设置：red 渲染结果： rgb(xxx, xxx, xxx) rgb是三原色，红绿蓝。格式为color:rgb(0~255, 0~255, 0~255)，括号中的数字也可以用单词代替。 如下所示： Document div:first-of-type { color: rgb(0, 0, 255); } div:last-of-type { color: rgb(255, 0, 0); } 颜色设置：blue 颜色设置：red 渲染结果： rgba(xxx, xxx, xxx, n) rgba相较于rgb来说，括号中多了第4位数值n，n的范围为0-1，用于指定透明度。 如下所示： Document div:first-of-type { color: rgba(0, 0, 255, .5); } div:last-of-type { color: rgba(255, 0, 0, .8); } 颜色设置：blue 透明度：50% 颜色设置：red 透明度：80% 渲染结果： RGB颜色对照表 以下是RGB颜色对照表： 图片格式 常见的图片格式有jpg、jpeg、png、gif、svg、tif、tiff等，它们都有不同的用途，以下是对这些格式的图片简单描述： jpg/jpeg：最适合保存照片或栩栩如生的图像。 绝大多数计算机和网络用户主要使用 JPEG 文件在线上传、下载或查看图像。保存在 JPEG 中可以压缩照片并使用相当小的文件大小，从而可以更快地下载和上传。这意味着使用 jpeg 可以获得高质量的图像，不会占用大量空间。从网络上传或下载图像时，JPEG 应该是首选的存储文件 png：最适合使用透明背景截屏和保存 PNG 文件主要供图形设计师、使用品牌和徽标的营销人员以及有大量空间在计算机上保存内容的网络用户使用。PNG 通常用于在图像上编辑图像，或在图像上编辑文本。这是因为保存为 PNG 允许将图像或图形放在透明背景上，因此可以创建徽标覆盖。对于线条或文本，PNG 还提供比 jpeg 更“清晰”的图像，因此它们也经常用于屏幕截图。由于 PNG 与 JPEG 文件相比占用了相当多的空间，因此最好避免使用它们，除非您需要透明的背景图像，或者文件大小不是问题 svg：最适合保存需要以数字方式放大或缩小的图形 SVG 文件主要由 Web 设计人员使用，这些设计人员处理的图像和图形将在许多不同大小的媒体上显示和使用。保存在 SVG 中可以实现无缝缩放，或允许图形在不同大小的屏幕上清晰显示（或在屏幕上放大）而不会损失图像质量或“像素化”。徽标通常使用 SVG 文件创建，因为徽标通常显示在视网膜屏幕上，或者需要在不降低质量的情况下放大和缩小 gif：最适合保存颜色有限的图像或短动画，或颜色有限的图形 历史上，GIF 文件主要用于存储颜色有限的图形或图像，不会占用大量存储空间。在当今世界，GIF 主要用作互联网上、消息平台之间来回以及流行文化中的有趣、短循环动画。尽管动画 GIF 占用的存储空间比视频少得多，但它们比 SVG 或 PNG 占用更多的空间。这个存储问题，除了动画循环的一些断断续续的交付（和有限的色谱）之外，还可能使 GIF 动画文件不如 SVG 或 PNG 文件受欢迎 tif、tiff：最适合保存将用于打印的图像 TIFF 文件主要由处理印刷材料的图形设计师使用。在使用数字媒体（网络使用的图像和图形、电子邮件等）时，TIFF 很可能不是您的首选媒体，因为它明显缺乏数字支持。虽然保存在 TIFF 中允许保存图层并在图形或照片中表示许多颜色，但它并不是所有 Web 浏览器或应用程序都支持的文件，并且它不能很好地压缩，因此仅适用于打印用 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-07-12 14:10:48 "},"前端专栏/CSS/文本控制.html":{"url":"前端专栏/CSS/文本控制.html","title":"文本控制","keywords":"","body":"基础设置 字体家族 font-family 使用font-family可定义多个字体，浏览器会按照从左至右的顺序进行查找这些字体。 为什么需要定义多个字体？原因是如果你只使用了一种字体而恰好用户的计算机中并没有该字体就会降低显示效果。 代码示例： Document :root { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; } English display result 中文显示结果 渲染结果： 自定义字体 @font-face 我们可以自定义一些字体，但是在使用自定义字体时应该先导入字体文件。 注意，字体文件导入后应当进行format，告知浏览器字体文件所代指字体的格式。 如下表所示： 字体文件后缀 format .otf opentype .woff woff .ttf truetype .eot Embedded-opentype 代码示例： Document /* 自定义一个字体*/ @font-face { /* 字体名字：mineFont */ font-family: \"mineFont\"; /* 导入字体文件并格式化，可以多设置几个url，字体文件可以是网络的，也可以是本地的 */ src: url(\"./ALLEGRO.ttf\") format(\"truetype\"), url(\"./ALLEGRO.ttf\") format(\"truetype\"); } :root { /* 优先使用自定义字体 */ font-family: 'mineFont', 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; } English display result 中文显示结果 渲染结果： 字体粗细 font-weight 使用font-weight可设置字体的粗细，它既可以指定数字（100-900），也可以指定单词。 它可设置的值如下表所示： 单词 数字 lighter（细） 100与lighter相同 normal（正常） 400与normal相同 bold（较粗） 700与bold相同 bolder（特粗） 900与bolder相同 代码示例： Document p:nth-of-type(1) { font-weight: 100; } p:nth-of-type(2) { font-weight: lighter; } p:nth-of-type(3) { font-weight: 400; } p:nth-of-type(4) { font-weight: normal; } p:nth-of-type(5) { font-weight: 700; } p:nth-of-type(6) { font-weight: bold; } p:nth-of-type(7) { font-weight: 900; } p:nth-of-type(8) { font-weight: bolder; } 100 lighter（细） 400 normal（正常） 700 bold（较粗） 900 bolder（特粗） 渲染结果： 字号大小 font-size 使用font-weight可设置字号的大小，可以使用单词、px、%、em、rem进行设置。 它可指定单词如下表所示： 单词 描述 xx-small 最小 x-small 较小 small 小 medium 中等 large 大 x-large 较大 xx-large 最大 代码示例： Document :root{ font-size: 16px; } p:nth-child(1){ font-size: xx-small; } p:nth-of-type(2) { font-size: x-small; } p:nth-of-type(3) { font-size: small; } p:nth-of-type(4) { font-size: medium; } p:nth-of-type(5) { font-size: large; } p:nth-of-type(6) { font-size: x-large; } p:nth-of-type(7) { font-size: xx-large; } 字号设置: xx-small 字号设置：x-small 字号设置：small 字号设置：medium 字号设置：large 字号设置：x-large 字号设置：xx-large 渲染结果： 文本颜色 color 使用color可设置文本的颜色，可以使用单词、rgb、rgba、#16进制色进行设置。 代码示例： Document p:first-of-type { color: red; } p:nth-of-type(2) { color: rgb(255, 0, 0); } p:nth-of-type(3) { color: rgba(255, 0, 0, 0.5); } p:last-of-type { color: #ff0000; } 文本颜色：red 文本颜色：rgb(255, 0, 0) 文本颜色：rgba(255, 0, 0, 0.5) 文本颜色：#ff0000 渲染结果： 文本行高 line-height 当一段文本放在一个标签中，默认会以标签左上角为起始点进行文本渲染。 如果我们想让文本垂直居中于元素内，可以使用 line-height: element-height 的设置。 代码示例： Document div { background-color: #ddd; color: #000; height: 10rem; width: 10rem; } div:last-of-type { line-height: 10rem; } p { font-style: italic; color: #bbb; margin: 20px 0; } 默认文本按照左上角为起始点 this is a text 将line-height设置为元素高度可令文本垂直居中 this is a text 渲染结果： 文本倾斜 font-style 使用font-style可令文本样式发生改变。 normal：正常 italic：倾斜 代码示例： Document p:first-of-type{ font-style: normal; } p:last-of-type{ font-style: italic; } 正常：normal 倾斜：italic 渲染结果： 组合定义 font 使用font可一次性定义上面的设置，语法如下： div { font : 文本倾斜 倾斜方式 字号大小/文本行高 字体 \"字体1\", \"字体2\"; } 注意，文本颜色不能进入组合定义之中，除此之外还需要留意： 必须要指定字号的大小 必须要指定文本的行高 代码示例： Document p:first-of-type { font: italic bold 1em/1.5 'Courier New', Courier, monospace; color: red; } p:nth-of-type(2) { font: italic bold /1.5 'Courier New', Courier, monospace; } p:last-of-type{ font: italic bold 1em/ 'Courier New', Courier, monospace; } 倾斜：italic 粗细：bold 字号：1em/行高:1.5 字体：'Courier New', Courier, monospace 颜色：rgba(255,0,0,.5) 失败，未定义字号大小 失败，未定义文本行高 渲染结果： 文本样式 字型设置 font-variant 使用font-variant可定义字型，让字型看起来不太一样。 它可设置的值如下表所示： 值 描述 normal 默认值，标准的字型 small-caps 浏览器会显示小型大写的字 inherit 从父元素继承font-variant的值 \u0014\u0014\u0014\u0014\u0014\u0014\u0003代码示例： Document p:first-of-type { font-variant: normal; } p:last-of-type { font-variant: small-caps; } 默认值 normal 小型大写 small-caps 渲染结果： 字母大小写 text-transform 使用text-transform可对文本的字母做大小写转换。 它可设置的值如下表所示： 值 描述 capitalize 首字母大写 uppercase 全字母大写 lowercase 全字母小写 代码示例： Document p:first-of-type { text-transform: capitalize; } p:nth-of-type(2) { text-transform: uppercase; } p:last-of-type { text-transform: lowercase; } capitalize uppercase lowercase 渲染结果： 文本线条 text-decoration 我们可以使用text-decoration来清除a标签自带的下划线。 它可设置的值如下表所示： 值 描述 none 无任何线条样式 underline 文本下的一条线 overline 文本上的一条线 line-through 文本中的一条线 blink 定义闪烁的文本 inherit 从父元素继承text-decoration的值 代码示例： Document a:first-of-type{ text-decoration: none; } p:first-of-type { text-decoration: underline; } p:nth-of-type(2) { text-decoration: overline; } p:last-of-type { text-decoration: line-through; } underline overline line-through 清除a标签样式：none 渲染结果： 文本阴影 text-shadow 使用text-shadow可对一段文本添加阴影效果。 设置参数顺序如下： 阴影颜色 水平偏移量 垂直偏移量 模糊度 代码示例： Document h1{ text-shadow: #ddd 15px 15px 6px; font-size: 3rem; font-style: italic; font-weight: bolder; } HELLO WORLD 渲染结果： 空白处理 white-space 由于浏览器的渲染特性，故出现多个空白时只会显示一个。 我们可以使用white-space来控制文本中的空白显示。 它可设置的值如下表所示： 值 描述 pre 原样显示，类似于pre标签 nowrap 不保留文本换行 pre-wrap 保留空白，保留换行 pre-line 合并空白，保留换行 代码示例： Document p:nth-of-type(1) { white-space: pre; } p:nth-of-type(2) { white-space: nowrap; } p:nth-of-type(3) { white-space: pre-wrap; } p:nth-of-type(4) { white-space: pre-line; } p { border: 1px solid black; width: 300px; height: 100px; padding: 10px; } mark { border-bottom: 1px solid black; border-top-left-radius: 30%; background-color: black; color: white; transform: translate(0, 1rem); padding: 5px; } pre 原样显示 A B C D E F nowrap 合并空白，禁止换行 A B C D E F pre-wrap 保留空白，保留换行 A B C D E F pre-wrap 合并空白，保留换行符 A B C D E F 渲染结果： 文本溢出 text-overflow 一个有宽度的容器中，如果一个文本字数超过了容器宽度，是不会进行换行的，这样就会发生溢出。 如下所示： Document p{ width: 80px; } ABCDEFGHIJKLMNOPQRSTUVWXYZ 我们可以使用 overflow-wrap: break-word 来让文本自动换行： Document p{ width: 80px; overflow-wrap: break-word; } ABCDEFGHIJKLMNOPQRSTUVWXYZ 或者可以设置 overflow: hidden 以及 text-overflow: ellipsis 来让超出容器宽度的文本隐藏并使用 … 进行代替。 注意，overflow: hidden 必须设置在 text-overflow: ellipsis 的上面。 Document p{ width: 80px; overflow: hidden; text-overflow: ellipsis; } ABCDEFGHIJKLMNOPQRSTUVWXYZ 渲染结果： 段落控制 文本缩进 text-indent 使用text-indent可进行文本缩进，单位可以是px、em或者rem。 代码示例： Document p { border: 1px dotted #ddd; text-indent: 2rem; font-size: 2rem; } 你好，世界 渲染结果： 水平对齐 text-align 使用text-align可对文本在容器内部的水平对齐方式进行设定。 它可设置的值如下表所示： 值 描述 left 左对齐 right 右对齐 center 水平居中对齐 代码示例： Document div { background-color: #ddd; color: #000; width: 150px; height: 150px; display: inline-block; } div:nth-of-type(1){ text-align: left; } div:nth-of-type(2){ text-align: center; } div:nth-of-type(3){ text-align: right; } left center right 渲染结果： 若想文字水平+垂直居中，可指定 line-height: element-height 和 text-align: center： Document div { background-color: #ddd; color: #000; width: 150px; height: 150px; display: inline-block; } div:nth-of-type(1){ line-height: 150px; text-align: center; } center 渲染结果： 垂直对齐 vertical-align 如果要在图片附近放上一段文本，那么你可以使用vertical-align定义该文本相较于图片的位置进行渲染。 vertical-align仅支持inline与inline-block标签，一般来说都是用图片和文字的垂直对齐方式，此外它还可以让表格单元格的内容进行垂直居中 它可设置的值如下表所示： 值 描述 top 文本相较于图片顶部进行对齐 middle 文本相较于图片中部进行对齐 bottom 文本相较于图片底部进行对齐 sub 图片垂直对齐文本的下标 super 图片垂直对齐文本的上标 text-top 图片与文本顶端对齐 text-bottom 图片与文本底端对其 % 使用 line-height 属性的百分比值来排列此元素，允许使用负值 inherit 从父元素继承vertical-align的值 代码示例： Document div { border: 1px dotted #ddd; padding: 1rem; font-size: 12px; } img { width: 100px; } body div:nth-of-type(1) img { vertical-align: top; } body div:nth-of-type(2) img { vertical-align: middle; } body div:nth-of-type(3) img { vertical-align: bottom; } top middle bottom 渲染结果： 单词间距 word-spacing 使用word-spacing来控制单词与单词之间的间距，单位可以是px、em或者rem。 代码示例： Document p { word-spacing: 1rem; } this is p element 渲染结果： 字符间距 letter-spacing 使用letter-spacing来控制字符与字符之间的间距，单位可以是px、em或者rem。 代码示例： Document p { letter-spacing: 1rem; } this is p element 渲染结果： 排版模式 writing-mode 如果想对文本进行排版，可使用writing-mode。 它可设置的值如下表所示： 值 描述 horizontal-tb 水平方向、自上而下进行排版 vertical-rl 垂直方向、自右而左进行排版 vertical-lr 垂直方向，自左而右进行排版 代码示例： Document p { writing-mode: vertical-rl; width: 8rem; height: 8rem; overflow-wrap: break-word; } 日照香炉生紫烟，遥看瀑布挂前川，飞流直下三千尺，疑似银河落九天。 渲染结果： Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-07-15 17:21:40 "},"前端专栏/CSS/数据样式.html":{"url":"前端专栏/CSS/数据样式.html","title":"数据样式","keywords":"","body":"表格 绘制表格 display 我们除了可以使用table标签进行表格绘制外，在CSS3中display也同样支持表格的绘制。 如下表所示： 样式规则 说明 table 对应 table table-caption 对应 caption table-row 对应 tr table-cell 对应 th 或 td table-row-group 对应 tbody table-header-group 对应 thead table-footer-group 对应 tfoot 代码示例： Document body main { display: table; border: 1px solid #ddd; } body main li { border: 1px solid #ddd; padding: 0.5rem; } body main h5 { display: table-caption; background-color: #bbb; padding: 0.5rem; text-align: center; } body main header { display: table-header-group; } body main header ul { display: table-row; } body main header ul li { display: table-cell; font-weight: bold; } body main section { display: table-row-group; } body main section ul { display: table-row; } body main section ul li { display: table-cell; } body main footer { display: table-footer-group; } body main footer ul { display: table-row; } body main footer ul li { display: table-cell; } user message name gender age Ken male 19 Jack male 18 Mary female 18 ... ... ... 渲染结果： 表格标题 caption-side 在table中使用caption-side来设置表格标题的位置。 值可以是top或者bottom，默认是top。 代码示例： Document table { caption-side: bottom; border: 1px solid #ddd; } table caption, table th, table td { border: 1px solid #ddd; padding: .5rem; } table caption { background-color: #bbb; } table th { font-weight: bold; } user message name gender age Ken male 19 Jack male 18 Mary female 18 ... ... ... 渲染结果： 内容对齐 text-align vertical-align 对于th，td的内容，我们可以在th、td中使用text-align以及vertical-align进行位置控制。 Ps：我个人更喜欢使用padding和text-align来使单元格根据内容而自动发生变化，而不是像下面的例子一样定死宽高。 水平对齐text-align： 值 描述 left 左对齐 right 右对齐 center 居中对齐 垂直对齐vertical-align： 属性 说明 top 顶对齐 middle 垂直居中 bottom 底部对齐 代码示例： Document table { caption-side: top; border: 1px solid #ddd; } table caption, table th, table td { border: 1px solid #ddd; } table caption { background-color: #bbb; } table th { font-weight: bold; } table th, table td { height: 3rem; width: 5rem; /* 水平、垂直居中 */ text-align: center; vertical-align: middle; } user message name gender age Ken male 19 Jack male 18 Mary female 18 ... ... ... 渲染结果： 颜色设置 我们可以为table中的任何HTML元素进行颜色设置。 代码示例： Document table { caption-side: top; border: 1px solid #ddd; } table caption, table th, table td { border: 1px solid #ddd; padding: .5rem; } table caption { background-color: #bbb; } table th { font-weight: bold; } table tbody tr:nth-child(odd) { background-color: #eee; } user message name gender age Ken male 19 Jack male 18 Mary female 18 ... ... ... 渲染结果： 边框间距 border-spacing 我们可以在table中使用border-spacing来设置表格边框与单元格边框的间距。 它有2个值，1个值对应上下边框、1个值对应左右边框，单位可以是px、em、rem、%等。 代码示例： Document table { caption-side: top; border: 1px solid #ddd; border-spacing: 2px 2px; /* 注意！在css reset文件中会进行边框合并 所以要想看见border-spacing的效果，必须取消边框合并 */ border-collapse: unset; } table caption, table th, table td { border: 1px solid #ddd; padding: .5rem; } table caption { background-color: #bbb; } table th { font-weight: bold; } table tbody tr:nth-child(odd) { background-color: #eee; } user message name gender age Ken male 19 Jack male 18 Mary female 18 ... ... ... 渲染结果： 边框合并 border-collapse 在table中使用border-collapse：collapse让表格边框与单元格边框进行合并。 如果使用了边框合并，边框间距失效。 注意！如果你使用了css reset文件，则该设置默认是打开的。 代码示例： Document table { caption-side: top; border-collapse: collapse; border: 1px solid #ddd; } table caption, table th, table td { border: 1px solid #ddd; padding: .5rem; } table caption { background-color: #bbb; } table th { font-weight: bold; } table tbody tr:nth-child(odd) { background-color: #eee; } user message name gender age Ken male 19 Jack male 18 Mary female 18 ... ... ... 渲染结果： 隐藏单元格 empty-cells 在table中使用empty-cells：hide来隐藏没有内容的单元格。 代码示例，由于tfoot中的td没有内容，所以他们将会被隐藏： Document table { caption-side: top; border-collapse: collapse; border: 1px solid #ddd; empty-cells: hide; } table caption, table th, table td { border: 1px solid #ddd; padding: .5rem; } table caption { background-color: #bbb; } table th { font-weight: bold; } table tbody tr:nth-child(odd) { background-color: #eee; } user message name gender age Ken male 19 Jack male 18 Mary female 18 渲染结果： 无边框表格 如果要使用无边框表格，可以利用选择器让左右边框隐藏。 代码示例： Document table { caption-side: top; border-collapse: collapse; border: 1px solid #ddd; } table caption, table th, table td { border: 1px solid #ddd; border-left-style: unset; border-right-style: unset; padding: .5rem; } table caption { background-color: #bbb; } table th { font-weight: bold; } table tbody tr:nth-child(odd) { background-color: #eee; } user message name gender age Ken male 19 Jack male 18 Mary female 18 ... ... ... 渲染结果： 数据表格 表格中可以嵌套input标签，通过:hover对tr做一些样式上的调整，比如变色、鼠标变小等。 代码示例： Document table { caption-side: top; border-collapse: collapse; border: 1px solid #ddd; empty-cells: hide; } table caption, table th, table td { border: 1px solid #ddd; border-left-style: unset; border-right-style: unset; padding: .5rem; } table caption { background-color: #bbb; } table th { font-weight: bold; } table tbody tr:nth-child(odd) { background-color: #eee; } table tbody tr:hover { background-color: #aaa; } table tbody tr * { cursor: pointer; } table tfoot tr td { text-align: right; } user message name gender age male female male female male female 渲染结果： 列表 列表符号 list-style-type 使用list-style-type对整个列表的标记设置样式，你也可以单独的为li标签的标记样式进行设置。 它们可设置的值如下所示： 值 描述 none 无标记 disc 默认，标记是实心圆 circle 标记是空心圆 square 标记是实心方块 decimal 标记是数字 decimal-leading-zero 0 开头的数字标记，如：01、02、03 等 lower-roman 小写罗马数字，如：i、 ii、 iii、 iv、 v 等 upper-roman 大写罗马数字，如：I、 II、 III、IV、V 等 lower-alpha 小写英文字母The marker is lower-alpha，如：a、b、c、d、e 等 upper-alpha 大写英文字母The marker is upper-alpha，如：A、B、C、D、E 等 lower-greek 小写希腊字母，如：alpha、beta、gamma 等 lower-latin 小写拉丁字母，如：a、 b、 c、 d、 e 等 upper-latin 大写拉丁字母，如：A、 B、 C、 D、 E 等 hebrew 传统的希伯来编号方式 armenian 传统的亚美尼亚编号方式 georgian 传统的乔治亚编号方式，如：an、 ban、 gan 等 cjk-ideographic 简单的表意数字 hiragana 标记是：a、 i、 u、 e、 o、 ka、 ki 等（日文片假名） katakana 标记是：A、 I、U、 E、 O、 KA、 KI 等（日文片假名） hiragana-iroha 标记是：i、ro、 ha、 ni、 ho、 he、 to 等（日文片假名） katakana-iroha 标记是：I、 RO、 HA、 NI、 HO、 HE、 TO等（日文片假名） 比如将所有的样式去除： ul { list-style-type: none; } 将标记定义为渐变色或者是img图片： ul { list-style-image: linear-gradient(to right, deeppink, deepskyblue); } 符号位置 list-style-position 使用list-style-position来定义列表标记符号的位置。 它可设置的值如下表所示： 值 描述 inside 内部 outside 外部 内部示例： ul { list-style-type: square; list-style-position: inside; } 外部示例： ul { list-style-type: square; list-style-position: outside; } 组合定义 list-style 使用list-style来一次性定义list-style-type与list-style-position。 代码示例： ul { list-style: square outside; } 渲染结果： 背景符号 我们可以先将每个li标签的list-style-type设置为none。 然后再对li标签增加背景图片，背景图片先调小然后设置为居左不重复，并配以文本缩进，让它来代替列表标记。 代码示例： ul li{ list-style: inside none; background: url(\"./img-002.png\") no-repeat; background-size: 1rem 1rem; text-indent: 2rem; } 渲染结果： 除此之外，我们也可以为li标签增加多个背景，一个背景做列表的标记符号，一个背景做li的标签背景。 代码示例： ul li { list-style: inside none; background: url(\"./img-002.png\") no-repeat, url(\"./width_background_image.jpeg\") no-repeat 1.8rem; background-size: 1rem 1rem, 80%; text-indent: 2rem; margin-bottom: .5rem; } 渲染结果： 追加内容 基本使用 ::after ::before 我们可以使用选择器::after向后追加内容，以及::before向前追加内容。 使用这2个选择器时一定要指定content属性，它们的content属性值将被加至被选择元素的content区域内。 注意，增加内容后会改变盒模型的面积大小，所以可能会引发布局混乱，谨慎使用。 代码示例： Document span{ border: 1px solid #ddd; } span:hover::before{ content: \"before \"; color: deeppink; } span:hover::after{ content: \" after\"; color: deepskyblue; } mid 渲染结果，可以发现盒模型被撑大了： 提取属性 attr() 在::before和::after中的content中，我们可以使用attr()方法提取出标签的属性值用作提示信息。 如下示例，当用户鼠标放到a标签上，会自动提取href属性并作为链接提示： Document a:hover::after { content: \"go to \"attr(href); background-color: #555; color: #fff; position: relative; top: 1.8rem; padding: .2rem; border-radius: 1rem; } link 渲染结果： 自定义输入框 原本的输入框比较丑，我们可以给他做出一些改变： 代码示例： Document div.fields { width: 170px; position: relative; } div.fields input[name=username] { outline: none; border: none; text-align: center; vertical-align: middle; /* 继承div宽度 */ width: 100%; } div.fields::after{ content: \"\"; display: block; /* 继承div宽度 */ width: 100%; height: 1px; background: linear-gradient(to right, white, blue, red, green, pink, white); } div.fields:hover::before{ /* 标签的属性如果是data-开头，则代表该属性专门用于被CSS或者JS提取的 */ content: attr(data-placeholder); position: absolute; top: -2rem; left: 0; color: #555; font-size: .5rem; } Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-07-15 17:36:38 "},"前端专栏/CSS/背景处理.html":{"url":"前端专栏/CSS/背景处理.html","title":"背景处理","keywords":"","body":"背景样式 纯色背景 background-color 使用background-color可定义纯色背景。 代码示例： Document div:nth-of-type(1){ background-color: red; color: #fff; font-style: italic; font-size: 3rem; padding: 2rem; width: 300px; text-align: center; } hello world 渲染结果： 图片背景 background-image 使用background-image: url(“path”)可定义图片背景。 图片背景本身不会改变盒模型的大小，这与在盒子中插入img标签是不同的。 代码示例： Document div:nth-of-type(1){ background-image: url(\"./width_background_image.jpeg\"); color: #fff; font-style: italic; font-size: 3rem; padding: 2rem; width: 300px; text-align: center; } hello world 渲染结果： 背景剪裁 background-clip 我们可以将背景设置为盒子的某一区域，比如content区域或者padding区域或者border区域。 请使用background-clip来进行指定。 它可设置的值如下表所示： 值 描述 border-box 包括边框 padding-box 不含边框，仅包含内边距与内容区域 content-box 不含边框、内边距，仅包含内容区域 代码示例： Document div:nth-of-type(1){ background-color: red; background-clip: content-box; color: #fff; font-style: italic; font-size: 3rem; padding: 2rem; width: 300px; text-align: center; border: 1px solid #ddd; } hello world 渲染结果： 背景重复 background-repeat 如果背景图小于盒子，那么默认会重复使用背景图铺满整个盒子。 我们可以使用background-repeat为它指定如何重复。 它可设置的值如下表所示： 值 描述 repeat 水平、垂直重复（默认） repeat-x 水平重复 repeat-y 垂直重复 no-repeat 不重复 space 背景图片对称均匀分布 代码示例，取消重复，并让背景图居中： Document div:nth-of-type(1){ background-image: url(\"./width_background_image.jpeg\"); background-repeat: no-repeat; background-position: center; color: #fff; font-style: italic; font-size: 3rem; padding: 2rem; width: 600px; text-align: center; border: 1px solid #ddd; } hello world 渲染结果： 背景滚动 background-attachment 使用background-attachment来设置背景是否固定。 它可设置的值如下表所示： 值 描述 scroll 背景跟随滚动条进行滚动 fixed 背景固定 背景位置 background-position 使用background-position来设置背景图居于容器中的位置。 它可设置的值如下表所示： 值 描述 left 左对齐 right 右对齐 center 居中对齐 top 顶部对齐 bottom 底部对齐 除开使用单词进行设置，也可以使用百分号进行设置，还可以同时设置2个值。 设置 left center为水平居左、垂直居中 设置 right center为水平居右，垂直居中 设置 center left 为水平居中，垂直居左 设置 center right 为水平居中，垂直居右 代码示例，使用%进行设置，50%为居中： Document div:nth-of-type(1){ background-image: url(\"./width_background_image.jpeg\"); background-repeat: no-repeat; background-position: 30% 50%; color: #fff; font-style: italic; font-size: 3rem; padding: 2rem; width: 600px; text-align: center; border: 1px solid #ddd; } hello world 渲染结果： 背景尺寸 background-size 使用background-size来定义背景尺寸，可以是单词、px、em、rem以及%。 如果该属性是用单词设置，一个词就可以搞定 如果该属性是用其他单位设置，需要2个值，一个是背景高度，一个是背景宽度 它可设置的单词如下表所示： 值 描述 cover 背景完全覆盖容器，可能会产生背景溢出 contain 背景不溢出容器，可能会产生容器部分留白 宽度固定高度自动的设置是最常用的： background-size: 50% auto; 代码示例，采用cover的单词选项： Document div:nth-of-type(1){ background-image: url(\"./width_background_image.jpeg\"); background-repeat: no-repeat; background-position: 50% 50%; background-size: cover; color: #fff; font-style: italic; font-size: 3rem; padding: 2rem; width: 600px; text-align: center; border: 1px solid #ddd; } hello world 渲染结果： 多个背景 background-image 我们可以一次指定多个背景，当指定多个背景之后，其他的属性要想作用到多个背景上，需要使用逗号对其进行分割： background-image: url(\"path1\"), url(\"path2\"); background-size: img_1_size, img_2_size; 代码示例： Document div:nth-of-type(1) { background-color: red; background-image: url(\"./img-001.jpeg\"), url(\"img-002.png\"); background-repeat: no-repeat, no-repeat; background-position: 4%, 96%; background-size: 40px, 40px; color: #fff; font-style: italic; font-size: 3rem; padding: 2rem; width: 300px; text-align: center; } hello world 渲染结果： 组合定义 background 使用background来进行组合定义。 推荐顺序为：颜色、图片地址、是否重复、背景剪裁、背景尺寸、是否跟随滚动。 如： background: color url(\"path\") no-repeat border-box center scroll; 也可以一次指定多个背景： background: url(\"path1\") left 50% no-repeat, url(\"path2\") right 100% no-repeat red; 代码示例： Document div:nth-of-type(1){ background: red url(\"./width_background_image.jpeg\") no-repeat border-box center scroll; color: #fff; font-style: italic; font-size: 3rem; padding: 2rem; width: 600px; text-align: center; border: 1px solid #ddd; } hello world 渲染结果： 背景阴影 box-shadow 使用box-shadow对盒子元素设置背景阴影。 设置参数顺序如下： 阴影颜色 水平偏移量 垂直偏移量 模糊度 代码示例： Document div:nth-of-type(1) { width: 100px; height: 100px; background-color: #eee; border: 1px solid #ddd; border-radius: 50%; box-shadow: rgba(100, 100, 100, .5) 10px 10px 5px; } 渲染结果： 颜色渐变 线性渐变 linear-gradient 渐变一般都是在背景颜色中进行使用，格式为background: linear-gradient(方向, 颜色, 颜色, ...); 下面这个示例中没有指定方向，所以方向是从上到下： /* 深粉到深空蓝 */ background: linear-gradient(deeppink, deepskyblue); 使用 deg 来改变渐变的角度，如果为负数则代表反方向： /* 倾斜30°，深粉到深空蓝 */ background: linear-gradient(30deg, deeppink, deepskyblue); 使用 to 方向1 方向2 来改变渐变的方向，但是它不能和倾斜同时用： /* 向右渐变，深粉到深空蓝 */ background: linear-gradient(to right, deeppink, deepskyblue); /* 向左渐变，深粉到深空蓝 */ background: linear-gradient(to left, deeppink, deepskyblue); /* 向左上方渐变，深粉到深空蓝 */ background: linear-gradient(to left top, deeppink, deepskyblue); /* 向右下方渐变，深粉到深空蓝 */ background: linear-gradient(to right bottom, deeppink, deepskyblue); 同时，我们也可以设置多颜色渐变，以及颜色透明度： Document div { width: 200px; height: 50px; margin-bottom: 1rem; } div:nth-of-type(1) { background: linear-gradient(90deg, #03001e 0%, #7303c0 33%, #ec38bc 66%, #fdeff9 100%); } div:nth-of-type(2) { background: linear-gradient(90deg, #feac5e 0%, #c779d0 50%, #4bc0c8 100%); } div:nth-of-type(3) { background: linear-gradient(90deg, #ada996 0%, #f2f2f2 33%, #dbdbdb 66%, #eaeaea 100%); } div:nth-of-type(4) { background: linear-gradient(90deg, #833ab4 0%, #fd1d1d 50%, #fcb045 100%); } 渲染结果： 径向渐变 radial-gradient 径向渐变的格式为 background: radial-gradient(方向, 宽度, 颜色, 颜色, ...); 它是从元素内部中心点向外进行扩散的渐变方式。 /* 深粉到深空蓝 */ background: radial-gradient(deeppink, deepskyblue); 我们可以设置渐变色的宽度。 /* 深粉到深空蓝 */ background: radial-gradient(20px 20px, deeppink, deepskyblue); 也可以使用 at 方向1 方向2 来进行渐变方向的控制。 /* 向右上方进行渐变，深粉到深空蓝, 深粉渐变标识位100px */ background: radial-gradient(at right top, deeppink 100px, deepskyblue); 我们依然可以设置很多的颜色来进行渐变： /* 从底部向中部进行渐变 */ background: radial-gradient(at bottom center, red, green ,blue ,yellow); 标识位 当未指定标识位时，渐变的过程是十分均匀的，一旦指定了标识位就会发生突变。 如下所示： /* 无标识位 */ background: linear-gradient(90deg, deeppink, deepskyblue); /* 单方设置标识位 */ background: linear-gradient(90deg, deeppink 50%, deepskyblue); /* 双方设置标识位 */ background: linear-gradient(90deg, deeppink 50%, deepskyblue 50%); 使用径向渐变加标识位绘制小太阳： 代码如下： Document div { width: 200px; height: 200px; border-radius: 50%; background: radial-gradient(red 10%, yellow 30%, black 70%) } 中间点阈值 所谓中间点阈值，指的就是两个颜色渐变的时候，从哪个点开始让一个颜色渐变到另一个颜色。 比如这个示例，红色标识位为60%，蓝色标识位为40%，渐变的中间点阈值就只能变成0了。 再比如这个示例，单方设置了标识位，那么它的阈值就是由系统产生的，所以我们才能看见它渐变的效果。 怎么设置中间点阈值呢？看下面这段代码： /* 0%就是中间点阈值，当设置为0后那么红色变蓝色会由0%的位置开始 */ background: linear-gradient(90deg, red ,0%, blue); 所以结果是： 将中间点阈值改为20%： /* 我们的中间点阈值是20%，先是红色占了10%，那么可观测范围中中间点阈值也就只有10%了，所以渐变区域为10% */ background: linear-gradient(90deg, red 10% ,20%, blue 80%); 重复的线性渐变 repeating-linear-gradient 要想使用线性渐变重复，请利用repeating-linear-gradient进行设置。 /* 一个格子为 75px */ background: repeating-linear-gradient(90deg, blue, 25px, red 50px); 如果我们想要生硬渐变过程，可以再随便加一个颜色充当过渡。 /* 过渡色和第一个渐变色的标志位设置为一样即可 */ background: repeating-linear-gradient(90deg, blue, 25px, yellow 25px, 25px, red 50px); 重复的径向渐变 repeating-radial-gradient 要想使用线性渐变重复，请利用repeating-radial-gradient进行设置。 background: repeating-radial-gradient(20px 20px, red 0%, yellow 20%, blue 30%, green 50%); 渲染结果： Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-07-15 14:45:06 "},"前端专栏/CSS/盒子模型.html":{"url":"前端专栏/CSS/盒子模型.html","title":"盒子模型","keywords":"","body":"盒子元素 基本介绍 每一个标签都可以看做一个盒子，在网页的布局中也是大盒子不断的嵌套小盒子。 每个盒子模型都包含以下名词： content：内容区域，可以由width与height来进行宽高设置，是盒子模型体积组成部分之一 padding：内边距，指的是content与border之间的距离，是盒子模型体积组成部分之一 border：边框，边框也算整个盒子模型的体积组成之一 margin：外边距，指的是该盒子与另一个盒子之间的距离 如下图所示： 一个盒子的可视面积由3部分所构成（content、padding、border）。 对其中任何一部分进行数值加减，都会影响到整个盒子可视面积的改变。 Ps：margin不可视，但它属于盒模型整体面积一部分。 宽高设置 我们很少来规定一个盒子的固定大小，基本都是由内容进行撑开。 内容区域可以通过width和height来设置宽高。 注意：使用width和height设计出的盒子仅针对content区域 如果后续对padding或者border进行修改都会改变整个盒子的大小从而引发整个页面的混乱，如果我们增加了padding或者border的数值，就需要减去content的width以及height的数值，反之亦然 代码示例： Document div { background-color: #ddd; width: 100px; height: 100px; } 渲染结果： 盒子整体占用面积： 如何手动计算一个标准盒模型的可视面积？公式如下： 宽度 = width + padding-left + padding-right + border-left + border-right 高度 = height + padding-top + padding-bottom + border-top + border-bottom 如果是计算整体占用面积，还需要加上margin。 box-sizing 默认的width和height设置的值仅针对内容区域，如果我们使用box-sizing来声明该盒子为边框盒子的话那么width和height设置值的应用范围就是整个盒子。 也就是说，如果你是边框盒子，那么后续对padding、border的修改都不会导致整体盒模型可视面积的变化了。 这个声明是强烈推荐使用的，它的出现让手动计算盒子可视面积的时代一去不复返。 box-sizing仅能设置2个值： box-sizing：border-box 边框盒子 box-sizing：content-box 内容盒子（默认值） 以下是内容盒子和边框盒子的对比： Document div { width: 200px; height: 200px; padding: 10px; text-align: center; line-height: 200px; font-weight: lighter; } div:first-of-type { border: 1px double #ddd; background-color: #ddd; } div:last-of-type { box-sizing: border-box; border: 1px double #eee; background-color: #eee; } content-box h-w:242px border-box h-w:200px 外边距 间距修改 如果想修改盒子的外边距，可使用margin进行修改，单位可以是px、em、rem以及%。 margin后面可以跟上1个至4个值，如下所示： 1个值：设置 (margin-top、margin-bottom、margin-left、margin-right) 的值 上下左右 2个值：设置 (margin-top、margin-bottom) | (margin-left、margin-right) 的值 上下 左右 3个值： 设置 (margin-top) | (margin-left、margin-right) | (margin-bottom) 的值 上 左右 下 4个值：设置 (margin-top) |( margin-right) | (margin-bottom) | (margin-left) 的值 上 右 下 左 或者你也可以单独的设置4个方向。 代码示例： Document p{ background-color: #bbb; height: 100px; width: 100%; } div { background-color: #ddd; width: 100px; height: 100px; display: inline-block; margin-top: 50px; margin-bottom: 50px; } div:nth-of-type(2){ margin: 50px; } 渲染结果： 盒子居中 当大盒子中嵌套了一个小盒子时，如果我们想让小盒子水平居中可对小盒子设置margin: auto。 Ps：如果小盒子想要垂直居中，就必然涉及到塌陷问题，这个后面会慢慢探讨。 代码示例： Document main { width: 100%; background-color: #bbb; height: 2rem; } div { height: 1rem; width: 1rem; background-color: #eee; margin: auto; } 渲染结果： 负值设置 当小盒子的margin-left或者margin-right有负值设置时，小盒子可能会跑出大盒子外面。 代码示例： Document main { width: 300px; height: 300px; background-color: #bbb; margin: auto; } div { height: 100px; width: 100px; background-color: #eee; margin: 0 -50px; } 渲染结果： 同级纵向合并 同级纵向合并是指2个并列的（无嵌套关系）的盒子一个设置margin-bottom、另一个设置margin-top的话会比较这2个值的大小，然后取最大值进行设置。 如下所示： 代码示例： Document div{ margin: auto; width: 100px; height: 100px; } div:nth-child(1){ background-color: #ddd; margin-bottom: 40px; } div:nth-child(2){ background-color: #eee; margin-top: 20px; } 结果展示： 越级纵向合并 当一个子级盒子想去设置margin-top或者margin-bottom与父盒子保持一定距离时，那么这个父盒子就必须要拥有一些内容。 若父盒子没有任何内容，子盒子就会不断的向上找，找父盒子的兄弟、找父盒子的父亲，直至找到html标签为止。 如下这个示例，由于父盒子中没有任何内容，子盒子在设置margin-top:20px后不仅没有拉开与父盒子之前的距离，反而让父盒子与html文档拉开了距离： Document html { background-color: deepskyblue; } main{ width: 200px; height: 200px; background-color: #ddd; } div { width: 100px; height: 100px; background-color: #eee; margin-top: 20px; } 如果父盒子有内容，就不会发生越级纵向合并问题了，现在往父盒子中加入了一个空格符号再看看结果。 可以看到子盒子与父盒子的距离拉开了： Document html { background-color: deepskyblue; } main{ width: 200px; height: 200px; background-color: #ddd; } div { width: 100px; height: 100px; background-color: #eee; margin-top: 20px; } &nbsp; 内边距 间距修改 内边距关键词是padding，我们可以使用padding来定义内边距。 使用规则和margin一样： Document div{ margin:50px; padding: 10px; background-color: #ddd; } content 渲染结果： 盒子居中 使用padding配合margin: auto，我们可以快速的让小盒子居中在大盒子内部。 大盒子不设置height，而是使用padding撑开 小盒子设置margin：auto 代码示例： Document main{ background-color: #ddd; padding: 10px; } div{ background-color: #eee; height: 20px; width: 20px; margin: auto; } 渲染结果： 边框设计 边框样式 使用border-style定义边框样式。 它可设置的值如下表所示： 值 描述 none 定义无边框 dotted 定义点状边框。在大多数浏览器中呈现为实线 dashed 定义虚线。在大多数浏览器中呈现为实线 solid 定义实线 double 定义双线。双线的宽度等于 border-width 的值 groove 定义 3D 凹槽边框。其效果取决于 border-color 的值 ridge 定义 3D 垄状边框。其效果取决于 border-color 的值 inset 定义 3D inset 边框。其效果取决于 border-color 的值 outset 定义 3D outset 边框。其效果取决于 border-color 的值 边框宽度 以下属性可用于定义边框宽度，它们的值可以是px、em、rem、%。 属性名称 说明 border-top-width 顶边宽度 border-right-width 右边宽度 border-bottom-width 下边宽度 border-left-width 左边宽度 border-width 四边宽度 边框颜色 使用以下属性可用于定义边框颜色，它们的值可以是单词、rgb、rgba、#16进制色。 属性名称 说明 border-top-color 顶边颜色 border-right-color 右边颜色 border-bottom-color 下边颜色 border-left-color 左边颜色 border-color 四边颜色 组合定义 使用以下属性可对边框样式、边框宽度、边框颜色进行组合定义。 可以一次只定义一条边，也可以定义四边： 属性名称 说明 border-top 顶边 border-right 右边 border-bottom 下边 border-left 左边 border 四边 代码示例： Document div { height: 80px; width: 100px; background-color: #eee; margin: 20px; display: inline-block; text-align: center; line-height: 80px; font-weight: lighter; } div:nth-of-type(1) { border: 3px dotted #bbb; } div:nth-of-type(2) { border: 3px dashed #bbb; } div:nth-of-type(3) { border: 3px solid #bbb; } div:nth-of-type(4) { border: 3px double #bbb; } div:nth-of-type(5) { border: 3px groove #bbb; } div:nth-of-type(6) { border: 3px ridge #bbb; } div:nth-of-type(7) { border: 3px inset #bbb; } div:nth-of-type(8) { border: 3px outset #bbb; } dotted dashed solid double groove ridge inset outset 渲染结果： 圆角边框 使用以下属性对边框单角或者四角设置为圆角，圆角支持px、%等单位。 属性 说明 border-top-left-radius 上左角 border-top-right-radius 上右角 border-bottom-left-radius 下左角 border-bottom-right-radius 下右角 border-radius 全部角 代码示例： Document div { height: 200px; width: 200px; background-color: #eee; margin: 20px; border: 1px dotted #bbb; border-radius: 50%; } 渲染结果： 外轮廓线 基础设置 外轮廓线与边框的使用一模一样，但是它不是盒子面积构成的一部分。 所以： 外轮廓线显示在边框外面 外轮廓线不会影响页面布局 此外，外轮廓线没有圆角设计。 我们可以使用outline来进行外轮廓线的组合定义，如下所示： Document div { height: 200px; width: 200px; background-color: #eee; margin: 20px; outline: 1px solid #bbb; } 渲染结果： input设置 input框在选中（focus）时会出现一个外轮廓线，非常的不美观： 我们可以做一些其他的设置，让它更好看： 代码如下： Document input{ border: none; background-color: #eee; } input:focus{ outline: 1px inset #bbb; } div{ margin-bottom: 1rem; } display 特性置换 通过display属性，我们可以将一个标签的特性进行置换。 它可设置的值如下表所示： 值 描述 inline 转换为内联标签 block 转换为块级标签 inline-block 转换为内联块级标签 代码示例： Document :not(hr, body, html) { margin: 1rem; border: 1px solid #ddd; } aside { display: inline; width: 200px; } span { display: block; } a { display: inline-block; height: 24px; } block -> inline block -> inline inline -> block inline -> block inline -> inline_block inline -> inline_block 渲染结果： 隐藏标签 使用display: none后，元素将被隐藏，它不会留下被隐藏元素的空间位置。 代码示例： Document div { width: 100px; height: 100px; } div:nth-of-type(1) { background-color: #ddd; display: none; } div:nth-of-type(2) { background-color: #eee; } 渲染结果： visibility 使用visibility: hidden后，元素将被隐藏，它会留下被隐藏元素的空间位置，实际上就是元素可见度设置为0。 代码示例： Document div { width: 100px; height: 100px; } div:nth-of-type(1) { background-color: #ddd; visibility: hidden; } div:nth-of-type(2) { background-color: #eee; } 渲染结果： overflow 使用overflow: hidden后，容器中溢出的内容将会被隐藏： Document div { width: 100px; height: 100px; overflow: hidden; background-color: #ddd; } ABCDEFGHIJKLMNOPQRSTUVWXYZ 或者你也可以将overflow的值设置为auto，这样容器就会出现滚动条（scroll）： Document div { width: 100px; height: 100px; overflow: auto; background-color: #ddd; } ABCDEFGHIJKLMNOPQRSTUVWXYZ 尺寸定义 min-w h&max-w h min-width与min-height常用于嵌套关系之中。 举个例子，一个大盒子中要放入一张图片，那么这张图片应该占据大盒子的多少空间呢？ min-width：定义元素的最小宽度 min-height：定义元素的最大高度 max-width：定义元素的最大宽度 max-height：定义元素的最大高度 注意： 子元素在使用时min-width会继承父元素的width 优先级问题：min-width > max-width > width 优先级问题：min-height > max-height > height 优先级问题是指元素同时设置这3个属性时，浏览器会选用哪一个。 代码示例： Document main { width: 200px; height: 200px; background-color: #ddd; } div { background-color: #eee; min-height: 90%; max-width: 90%; } 渲染结果： fill-available 设置w、h为fill-available的子元素会填满整个父元素可用空间。 在chorme浏览器中使用该属性时需要加上前缀 -webkit 进行样式书写。 width: -webkit-fill-available; height: -webkit-fill-available; 代码示例： Document main { width: 200px; height: 200px; background-color: #ddd; } div { background-color: #eee; width: -webkit-fill-available; height: -webkit-fill-available; } 渲染结果： fit-content 设置w、h为fit-content的容器，不管有多少内容都不会造成溢出。 他会根据内容的宽高自动调整整个容器的宽高，常用于移动端。 width: fit-content; height: fit-content; 代码示例： Document div { width: fit-content; height: fit-content; background-color: #ddd; } ABCDEFGHIJKLMNOPQRSTUVWXYZ 渲染结果： min-content&max-content min-content和max-content也是移动端使用较多。 它会根据元素内容来自动设置content区域大小： width: min-content; height: min-content; width: max-content; height: max-content; 代码示例： Document div:nth-of-type(1) { width: min-content; height: min-content; background-color: #ddd; } div:nth-of-type(2) { width: min-content; height: min-content; background-color: #eee; } ABCDEFGHIJKLMNOPQRSTUVWXYZ ABCDEFGHIJKLMNOPQRSTUVWXYZ 渲染结果： Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-07-16 20:15:18 "},"前端专栏/CSS/浮动布局.html":{"url":"前端专栏/CSS/浮动布局.html","title":"浮动布局","keywords":"","body":"浮动布局 基本介绍 浮动布局是CSS早期最常使用的一种布局方式。 说白了就是使元素进行漂浮，从而脱离默认文档流排列的一种技术手段。 使用浮动布局应该注意以下几点： 浮动应当发生在一个大盒子内部（body标签也可以看做一个大盒子） 浮动后的元素会影响后面未浮动元素的排列方式 浮动元素会自动转换为inline-block状态 浮动元素只会在父盒子的content区域，不会溢出到父盒子的padding区域 当一个父盒子中所有的元素都进行浮动后，可能会造成父盒子高度塌陷的问题 使用浮动 对一个元素使用float就可以让该元素漂浮起来，它可以指定以下一些方向： 选项 说明 left 向左浮动 right 向右浮动 none 不浮动 注意！使用向右浮动会发生倒序排列，1234变为4321，而左浮动则是正序排列。 如果你不想右浮动改变他们的排列顺序，则可以将它们全部包装在一个父级标签中，将父级标签右浮动，再将子标签做浮动。 如下图所示： 文档流 文档流排列是一种自上而下，自左向右的排列方式。 对于block块级元素来说，它应该是独占一行的。 代码示例： Document * { box-sizing: border-box; } main { width: 230px; padding: .5rem; border: 1px solid #000; } main div { width: 100px; height: 100px; } main div:nth-of-type(1) { border: 1px solid blue; } main div:nth-of-type(2) { background-color: red; } 渲染结果： 空间占用 在同级情况下，排列在前的一个标签如果进行浮动设置从而脱离了文档流，那么排列在后的标签会占用之前标签的位置。 如下所示，排列在前的蓝框div如果float: left后，排列在后的红色背景div会向上顶，占用掉之前蓝框div所在的空间位置，而蓝框div则漂浮在了红色背景div的上方。 main div:nth-of-type(1) { border: 1px solid blue; float: left; } 如果排列在前的蓝框div设置为float: right后，排列在后的红色背景div依旧会向上顶，占用掉之前蓝框div所在的空间位置。 main div:nth-of-type(1) { border: 1px solid blue; float: right; } 如果我们对排列在后的红色背景div进行浮动设置的话，排列在前的标签并不会受此影响，但会出现父级高度塌陷问题，即父级盒子的高度会出现令人意外的情况： main div:nth-of-type(2) { background-color: red; float: right; } 状态转换 设置为浮动的元素都会变为inline-block状态。 如下所示，对一个inline标签进行浮动，它变的可以设置宽高了，对一个block标签进行浮动，它变的不会独占一行了： 代码示例： Document * { box-sizing: border-box; } main { width: 230px; padding: .5rem; border: 1px solid #000; /* 为了防止父盒子塌陷，所以这里给他定一个高度 */ height: 200px; } main span, div { width: 100px; height: 100px; text-align: center; line-height: 100px; } main span { float: left; border: 1px solid blue; } main div{ float: right; background-color: red; } inline block 浮动边界 父盒子中的浮动元素始终会位于父盒子的content区域中，不会超出padding区域。 如下所示： content：蓝色 padding：绿色 margin：黄色 代码示例： Document * { box-sizing: border-box; } main { width: 230px; padding: .5rem; border: 1px solid #000; /* 为了防止父盒子塌陷，所以这里给他定一个高度 */ height: 200px; } main span, div { width: 100px; height: 100px; text-align: center; line-height: 100px; } main span { float: left; border: 1px solid blue; } main div{ float: right; background-color: red; } inline block 清除浮动 塌陷问题 当一个没有高度的父盒子中所有子元素都进行漂浮后，父盒子会产生高度塌陷的问题： Document * { box-sizing: border-box; } main { width: 230px; padding: .5rem; border: 1px solid #000; } main div { width: 100px; height: 100px; } main div:nth-of-type(1) { border: 1px solid blue; float: left; } main div:nth-of-type(2) { background-color: red; float: right; } 父盒子出现高度塌陷后，会影响整体布局的混乱。 这是正常情况下的布局： Document * { box-sizing: border-box; } main { width: 440px; padding: .5rem; border: 1px solid #000; height: 120px; } main div { border: 1px solid blue; float: left; width: 100px; height: 100px; margin-right: 5px; text-align: center; line-height: 100px; color: #fff; background-color: deeppink; } img img img img this is description message this is description message this is description message this is description message 这是高度塌陷后出现的布局情况： Document * { box-sizing: border-box; } main { width: 440px; padding: .5rem; border: 1px solid #000; /* height: 120px; */ } main div { border: 1px solid blue; float: left; width: 100px; height: 100px; margin-right: 5px; text-align: center; line-height: 100px; color: #fff; background-color: deeppink; } img img img img this is description message this is description message this is description message this is description message 解决这个问题的方案非常简单，就是给父盒子设定一个固定的高度，但这样做是不现实的。 我们以下面这个京东滚动条来进行说明，仔细观察它的结构你会发现它其实就是一个a标签中套着img，和我们上面所示例的布局情况非常相似。 a标签是设置为float：left的，这就意味着黑框的div部分可能会出现高度塌陷问题，让整个页面都乱掉： 如果你为黑框div设置了一个高度，假如后续新一轮方案中img高度发生变化后我们还需要调整div的高度，显然是非常麻烦的。 所以，为父盒子设置高度解决塌陷问题是不可取的。 clear 内墙法 我们可以使用 clear 内墙法来解决父盒子高度塌陷的问题。 步骤如下： step01：在父盒子中加入一个不浮动的空白块级标签，放在所有浮动元素的下面 step02：为该标签新增 clear 属性，并配置选项 clear可设置的选项值如下表所示： 值 描述 left 左边远离浮动元素 right 右边远离浮动元素 both 左右都远离浮动元素 它的意思是该标签的某个方向不允许有浮动元素，如果有就另起一行。 下面是设置了clear内墙法后的父盒子，不再产生高度塌陷问题了： 我们注意看下面这段代码，clear元素必须是块级元素，且必须设置在浮动元素的下面，因为浮动元素只会影响排列在后的标签，并不会影响排列在前的标签： Document * { box-sizing: border-box; } main { width: 230px; padding: .5rem; border: 1px solid #000; } main div { width: 100px; height: 100px; } main div:nth-of-type(1) { border: 1px solid blue; float: left; } main div:nth-of-type(2) { background-color: red; float: right; } .clearfix { /* clear:both 代表如果两边有浮动，我就另起一行，不占据漂浮元素的空间位置 */ clear: both; } 伪元素 内墙法 clear 内墙法虽然能够很好的解决父盒子高度塌陷问题，但是使用非常麻烦。 我们需要为每一个有浮动元素的父盒子都建立一个空标签并新增clearfix类，整个步骤还是比较繁琐的。 所以可以使用伪元素内墙法，使用::after插入器为父盒子自动创建一个元素。 注意，一定要使用::after才有效，因为它是将文本插入到浮动元素的后面，如果使用::before是没有效果的，浮动元素并不会影响之前元素的排列方式。 伪元素内墙法应该是个人比较推崇的一种方式，他非常的简单。 代码示例： Document * { box-sizing: border-box; } main { width: 230px; padding: .5rem; border: 1px solid #000; } main div { width: 100px; height: 100px; } main div:nth-of-type(1) { border: 1px solid blue; float: left; } main div:nth-of-type(2) { background-color: red; float: right; } .clearfix::after { content: \"\"; display: block; /* clear:both 代表如果两边有浮动，我就另起一行，不占据漂浮元素的空间位置 */ clear: both; } overflow 最后这种方式更加的简单，只需要为父盒子设置 overflow: auto; 或者overflow: hidden; 即可解决高度塌陷问题。 它会触发一个BFC机制来解决高度塌陷问题，但可能会产生子元素内容丢失的情况。 具体BFC机制比较麻烦，这里不进行探讨，会用就行： 代码示例： Document * { box-sizing: border-box; } main { width: 230px; padding: .5rem; border: 1px solid #000; } main div { width: 100px; height: 100px; } main div:nth-of-type(1) { border: 1px solid blue; float: left; } main div:nth-of-type(2) { background-color: red; float: right; } .clearfix { /* overflow会触发BFC机制，缺点是可能会造成浮动元素部分内容缺失 */ overflow: auto; } 浮动环绕 基本介绍 浮动环绕就是让文本内容对浮动元素进行环绕，类似于word中的排版环绕。 如果浮动元素是img，则img链接图片必须是具有透明度的png格式图片。 下面是效果展示： 距离控制 对浮动元素使用shape-outside可进行浮动元素与同级文本之间的距离控制。 它可设置的值如下表所示： 值 说明 margin-box 外边距环绕 padding-box 内边距环绕 border-box 边框 content-box 内容环绕 1）外边距环绕，文字依照浮动元素的外边距进行环绕： 2）内边距环绕，文字依照浮动元素的内边距进行环绕： 3）边框环绕文，字依照浮动元素的边框进行环绕： 4）内容环绕，文字依照浮动元素的内容进行环绕： 代码示例： Document main { width: 22rem; } main img { width: 50px; float: left; padding: .5rem; margin: 1rem; border: 3px solid #bbb; shape-outside: content-box; /* shape-outside: border-box; shape-outside: padding-box; shape-outside: margin-box; */ } .clearfix { overflow: auto; } 滑稽起源于百度贴吧，由百度团队设计，最初名字叫“斜眼笑”。由于其可以同时表达多种复杂的感情，2012年时已被在极易引战的贴吧广泛应用。 2012年10月，有微博网友发了张小孩儿怕打针缩墙角的照片，将害怕这种情绪表现得非常到位，被灵魂画手描了个形，做成最初的【墙角害怕】。 2016年10月，“滑稽”表情抱枕正式登陆日本亚马逊，售价1550日元，约合人民币101元。 内移距离 shape-outside除了可以使用上面的单词来控制浮动元素与文本之间的距离外，还可以使用inset手动指定浮动元素的内移距离。 指定顺序为：上、右、下、左 代码示例： Document main { width: 22rem; } main img { width: 50px; float: left; padding: .5rem; margin: 1rem; border: 3px solid #bbb; shape-outside: inset(0px -30px 0px 50px) border-box; } .clearfix { overflow: auto; } 滑稽起源于百度贴吧，由百度团队设计，最初名字叫“斜眼笑”。由于其可以同时表达多种复杂的感情，2012年时已被在极易引战的贴吧广泛应用。 2012年10月，有微博网友发了张小孩儿怕打针缩墙角的照片，将害怕这种情绪表现得非常到位，被灵魂画手描了个形，做成最初的【墙角害怕】。 2016年10月，“滑稽”表情抱枕正式登陆日本亚马逊，售价1550日元，约合人民币101元。 环绕模式 浮动元素的shape-outside还可以指定文本环绕模式： 它可设置的值如下表所示： 值 说明 circle 圆形 ellipse 椭圆 polygon 多边形 1）正圆外边距环绕： 2）椭圆外边距环绕： 3）多边形外边距环绕： 代码示例： Document main { width: 22rem; } main img { width: 50px; float: left; padding: .5rem; margin: 1rem; border: 3px solid #bbb; shape-outside: polygon(50% 0, 100% 100%, 0 100%) margin-box; /* 正圆外边距环绕 shape-outside: circle(50%) margin-box; 椭圆外边距环绕： shape-outside: ellipse(50% 80%) margin-box; 多边形外边距环绕： shape-outside: polygon(50% 0, 100% 100%, 0 100%) margin-box; */ } .clearfix { overflow: auto; } 滑稽起源于百度贴吧，由百度团队设计，最初名字叫“斜眼笑”。由于其可以同时表达多种复杂的感情，2012年时已被在极易引战的贴吧广泛应用。 2012年10月，有微博网友发了张小孩儿怕打针缩墙角的照片，将害怕这种情绪表现得非常到位，被灵魂画手描了个形，做成最初的【墙角害怕】。 2016年10月，“滑稽”表情抱枕正式登陆日本亚马逊，售价1550日元，约合人民币101元。 显示区域 对浮动元素使用clip-path可控制其显示的形状。 它可设置的值如下表所示： 值 说明 circle 圆形 ellipse 椭圆 polygon 多边形 1）圆形 2）椭圆形 3）多边形 代码示例： Document main { width: 22rem; } main div { width: 50px; height: 50px; float: left; padding: .5rem; margin: 1rem; background-color: #eee; clip-path: polygon(50% 0, 100% 100%, 0 100%); /* 代表正圆，圆心在中间 clip-path: clip-path: circle(50% at center); 代表椭圆，圆心在右边 两个数，一个代表宽度，一个代表高度，圆心在右上角 clip-path: ellipse(50% 80% at 100% 0); 代表三角形 clip-path: polygon(50% 0, 100% 100%, 0 100%); */ } .clearfix { overflow: auto; } 滑稽起源于百度贴吧，由百度团队设计，最初名字叫“斜眼笑”。由于其可以同时表达多种复杂的感情，2012年时已被在极易引战的贴吧广泛应用。 2012年10月，有微博网友发了张小孩儿怕打针缩墙角的照片，将害怕这种情绪表现得非常到位，被灵魂画手描了个形，做成最初的【墙角害怕】。 2016年10月，“滑稽”表情抱枕正式登陆日本亚马逊，售价1550日元，约合人民币101元。 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-07-18 21:59:55 "},"前端专栏/CSS/定位布局.html":{"url":"前端专栏/CSS/定位布局.html","title":"定位布局","keywords":"","body":"定位布局 基本介绍 CSS中，定位布局是非常常见的技术手段，它可以将任意元素放在页面中任意的位置上。 早期的页面基本都是由浮动+定位布局来完成的。 我们以京东为例，这就是一个非常好的定位布局小例子： 定位布局虽然常用但是不能滥用，他可能会出现一些意料之外的情况，我们应该只对一些特定元素进行定位，而对不需要定位的元素则可对其使用默认文档流和浮动的手段进行布局排列。 定位类型 position 使用position对一个元素进行定位。 它可设置的值如下表所示： 值 描述 static 默认定位，即文档流布局定位 relative 相对定位，仍然是文档流定位 absolute 绝对定位，脱离文档流 fixed 固定定位，脱离文档流 sticky 粘性定位 位置偏移 一个被定位的元素可以进行上下左右的偏移，你可以指定方向与偏移距离。 可指定方向如下表所示，偏移距离单位可以是px、em、rem、%等： 方向 描述 top 距离顶边 bottom 距离下边 left 距离左部 right 距离右边 相对定位 relative 示例演示 相对定位relative是相对元素原本的位置进行偏移控制。 当元素发生偏移时，原空间位置保留（不脱离文档流，其他元素不会顶上来）。 这是原本位置： 对第一个元素进行相对定位后，向右偏移30px，向下偏移10px。可以发现p标签并没有顶上去： 代码示例： Document main { width: 200px; height: 200px; border: 1px solid #bbb; background-color: #ddd; } main div:nth-of-type(1) { width: 100px; height: 100px; border: 1px solid #bbb; /* position: relative; top: 20px; left: 30px; */ } main p:nth-of-type(1) { border: 1px solid #bbb; font-weight: lighter; } this is p element 绝对定位 absolute 示例演示 绝对定位absolute是脱离文档流的定位方式，你可以将它理解为可以偏移到任意位置的漂浮。 被绝对定位后的元素拥有inline-block的特性。 被绝对定位的元素是会影响同级的正常排列的文档流元素的，即后面的元素会自动向上补齐。 此外，子元素的绝对定位不会影响父元素的整体高度，这与浮动布局不同，浮动布局中子元素的float会导致父元素的高度塌陷问题，这点在绝对定位中是不存在的。 下面我们将演示绝对定位的脱离文档流特点。 这是原本位置： 对第一个元素进行绝对定位后，向右偏移30px，向下偏移10px。可以发现p标签顶上去了： 代码示例： Document main { width: 200px; height: 200px; border: 1px solid #bbb; background-color: #ddd; } main div:nth-of-type(1) { width: 100px; height: 100px; border: 1px solid #bbb; /* position: absolute; top: 20px; left: 30px; */ } main p:nth-of-type(1) { border: 1px solid #bbb; font-weight: lighter; } this is p element 参照元素 绝对定位的元素不受文档流的控制，所以默认它会按照页面左上角进行定位以及偏移。 但是如果被绝对定位元素的父元素设置了relative或者fixed以及sticky定位的话，则该绝对定位子元素将会参照此父元素左上角位置进行定位以及偏移。 下面这个示例中，父元素没有设置为relative或者fixed以及sticky定位，子元素的绝对定位会以页面左上角作为参照点： Document body{ border: 2px solid #bbb; } main { width: 200px; height: 200px; border: 1px solid #bbb; background-color: #ddd; margin-top: 100px; margin-left: 100px; } main div:nth-of-type(1) { width: 100px; height: 100px; border: 1px solid #bbb; position: absolute; top: 20px; left: 30px; } 下面这个示例中，父元素设置了relative定位，子元素的绝对定位会以父元素左上角作为参照点： Document body{ border: 2px solid #bbb; } main { width: 200px; height: 200px; border: 1px solid #bbb; background-color: #ddd; margin-top: 100px; margin-left: 100px; position: relative; } main div:nth-of-type(1) { width: 100px; height: 100px; border: 1px solid #bbb; position: absolute; top: 20px; left: 30px; } 所以，当一个子元素要设置为absolute绝对定位时，父元素应当设置为relative相对定位。 居中定位 如果想对绝对定位的子元素设置水平垂直居中，则可以： top设置为50% left设置为50% margin-left设置为子元素宽度的一半 margin-right设置为子元素宽度的一半 如下示例： 代码演示： Document main { width: 200px; height: 200px; border: 1px solid #bbb; background-color: #ddd; position: relative; } main div:nth-of-type(1) { width: 100px; height: 100px; border: 1px solid #bbb; position: absolute; left: 50%; top: 50%; margin-left: -50px; margin-top: -50px; } 默认位置 如果被定位的子元素没有设置任何偏移，那么它将会受到父元素padding等属性的影响。 但是使用定位的元素一般都会进行偏移设置。 示例如下： Document main { width: 200px; height: 200px; border: 1px solid #bbb; background-color: #ddd; position: relative; } main div:nth-of-type(1) { width: 100px; height: 100px; border: 1px solid #bbb; position: absolute; } 跟随滚动 无论是绝对定位抑或是相对定位的元素，都会随着滚动条发生滚动。 Document main { width: 200px; height: 200px; border: 1px solid #bbb; background-color: #ddd; position: relative; /* Y轴滚动条 */ overflow-y: scroll; } main div:nth-of-type(1) { width: 100px; height: 100px; border: 1px solid #bbb; position: absolute; left: 50%; top: 50%; margin-left: -50px; margin-top: -50px; } main p:nth-of-type(1){ /* p元素比main要长，才能滚动 */ height:1000px; } z-index 如果2个同级别的元素都进行定位且位置相同。那么后定位的元素会层叠在先定位的元素之上，这个时候我们就需要用到z-index来改变层叠优先级。 默认所有元素的层叠优先级均为0，较大优先级的元素会显示在上方。 如下示例，后定位的元素是矩形div，他会显示在圆形div的上方，当我们改变圆形div的z-index后，圆形div会显示在矩形div的上方： Document main { width: 200px; height: 200px; border: 1px solid #bbb; background-color: #ddd; position: relative; /* Y轴滚动条 */ overflow-y: scroll; } main div { width: 100px; height: 100px; border: 1px solid #bbb; position: absolute; } main div:nth-of-type(1) { border-radius: 50%; background-color: deeppink; z-index: 1; } main div:nth-of-type(2) { background-color: deepskyblue; } 固定定位 fixed 固定定位fixed是脱离文档流的定位方式。 固定定位的元素不会随着滚动条进行滚动，他的偏移参照点是页面左上角。 如下所示，我们使用a标签锚点与固定定位，实现快速返回页面顶部的按钮功能： Document div { height: 200px; } div:nth-of-type(1) { background-color: red; } div:nth-of-type(2) { background-color: blue } div:nth-of-type(3) { background-color: green; } div:nth-of-type(4) { background-color: yellow; } div:nth-of-type(5) { background-color: pink; } button { position: fixed; bottom: 2rem; right: 2rem; box-shadow: 5px 5px 5px #555; } go to top 粘性定位 sticky 同级粘性定位 同级粘性定位sticky是会进行层叠的，后面的粘性定位元素不会挤掉上面的粘性定位元素。 同级指的就是不同的粘性定位元素粘的是同一个父级元素。 Document section { overflow-y: scroll; width: 250px; height: 180px; text-align: center; } section h2 { padding: 13px; color: #fff; font-weight: bolder; position: sticky; top: 0; } section h2:nth-of-type(1) { background-color: orange; } section h2:nth-of-type(2) { background-color: blue; } section h2:nth-of-type(3) { background-color: yellowgreen; } section img { width: 130px; margin-top: 1rem; } HTML CSS JavScript 非同级粘性定位 非同级粘性定位sticky是不会进行层叠的，后面的粘性定位元素会挤掉上面的粘性定位元素。 非同级指的就是不同的粘性定位元素粘的不是同一个父级元素。 Document section { overflow-y: scroll; width: 250px; height: 180px; text-align: center; } section h2 { padding: 13px; color: #fff; font-weight: bolder; position: sticky; top: 0; } section article:nth-of-type(1) h2 { background-color: orange; } section article:nth-of-type(2) h2 { background-color: blue; } section article:nth-of-type(3) h2 { background-color: yellowgreen; } section img { width: 130px; margin-top: 1rem; } HTML CSS JavScript 导航条示例 使用浮动 + 定位布局，来快速构建一个导航条： Document * { box-sizing: border-box; } :root { font-size: 16px; } .clearfix::after { content: \"\"; display: block; clear: both; } header { padding: 1rem; background: #1b1b1b; color: #fff; position: fixed; width: 100%; } header nav section div { cursor: pointer; padding: 0.5rem; z-index: 1; } header nav section div:hover { background: #eee; border-radius: 20px; color: #000; } header nav section:nth-of-type(1) { float: left; } header nav section:nth-of-type(1) div { float: left; } header nav section:nth-of-type(2) { float: right; } header nav section:nth-of-type(2) div { float: left; margin-left: 1rem; } header nav section:nth-of-type(2) div:nth-of-type(2), header nav section:nth-of-type(2) div:nth-of-type(3) { position: relative; } header nav section:nth-of-type(2) div:nth-of-type(2) ul, header nav section:nth-of-type(2) div:nth-of-type(3) ul { position: absolute; left: 5px; background: #eee; color: #000; font-size: 0.8rem; padding: 0.5rem; display: none; } header nav section:nth-of-type(2) div:nth-of-type(2) ul li, header nav section:nth-of-type(2) div:nth-of-type(3) ul li { margin-top: 0.6rem; padding: 1px; } header nav section:nth-of-type(2) div:nth-of-type(2) ul li:hover, header nav section:nth-of-type(2) div:nth-of-type(3) ul li:hover { background-color: #1b1b1b; color: #fff; } header nav section:nth-of-type(2) div:nth-of-type(2):hover ul, header nav section:nth-of-type(2) div:nth-of-type(3):hover ul { display: block; } main { background: #e3e2e2; height: 80vh; } footer { background: #5a5a5a; height: 20vh; } 首页 我的关注 我的收藏 默认收藏 观看最多 点赞最多 个人设置 头像设置 界面设置 资料设置 退出登录 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-07-18 22:13:48 "},"前端专栏/CSS/弹性布局.html":{"url":"前端专栏/CSS/弹性布局.html","title":"弹性布局","keywords":"","body":"弹性布局 基本介绍 弹性布局flex是CSS3新增的一种布局方式，相较于浮动布局，弹性布局在开发效率与维护性上都远胜前者。 flex全称为flexible box，因此也被称之为弹性盒子。 学习弹性布局最主要从2个方面入手： 弹性容器：被设置为display: flex或display: inline-flex的容器元素 弹性元素：弹性容器中包裹的元素 一个大的弹性容器中可以包含多个小的弹性容器，我们可以控制弹性容器中元素的排列方式，也可以为弹性元素进行单独的区域划分以及改变其排列方式，总之而言使用弹性盒模型布局非常方便。 弹性容器 容器声明 使用display: flex或者display: inline-flex声明一个元素为弹性容器。 flex：容器本身是block状态，但是其内部的弹性元素是inline-block状态 inline-flex：容器本身是inline-block状态，内部的弹性元素也是inline-block状态 flex，可以看见容器本身是独占一行的，容器内元素div变为inline-block状态： inline-flex，容器本身不会独占一行，容器内元素div变为inline-block状态： Document main{ display:inline-flex; background-color:#ddd; } main div{ width: 50px; height: 50px; background: #eee content-box; padding: .5rem; text-align: center; line-height: 50px; } 1 2 3 this is span element 排列方式 flex-direction 我们可以在弹性容器中设置flex-direction来控制容器内部弹性元素的排列方式。 它可设置的值如下表所示： 值 描述 row 从左到右水平排列元素（默认值） row-reverse 从右向左水平排列元素 column 从上到下垂直排列元素 column-reverse 从下到上垂直排列元素 1） 从左到右水平排列元素（默认值），row： 2）从右向左水平排列元素，row-reverse： 3）从上到下垂直排列元素，column： 4）从下到上垂直排列元素，column-reverse： 代码示例： Document main{ display:flex; flex-direction: row; /* flex-direction: row; flex-direction: row-reverse; flex-direction: column; flex-direction: column-reverse; */ width:300px; height:300px; background-color:#ddd; } main div{ width: 50px; height: 50px; background: #eee content-box; padding: .5rem; text-align: center; line-height: 50px; } 1 2 3 是否换行 flex-wrap 当一个弹性容器中的弹性元素太多时，默认是不会进行换行的而是挤压内部的弹性元素。 我们可以使用flex-wrap来规定弹性元素是否换行显示，并且还可以指定是否反向换行。 它可设置的值如下表所示： 值 描述 nowrap 元素不拆行或不拆列（默认值） wrap 容器元素在必要的时候拆行或拆列 wrap-reverse 容器元素在必要的时候拆行或拆列，但是以相反的顺序 1）水平方向row排列与不换行nowrap（默认设置）： 2）水平方向row排列与换行wrap： 3）水平方向row排列与反向换行： 代码示例： Document main{ display:flex; flex-direction: row; /* flex-direction: row; flex-direction: row-reverse; flex-direction: column; flex-direction: column-reverse; */ flex-wrap: wrap-reverse; /* flex-wrap: wrap; flex-wrap: wrap-reverse; */ width:300px; height:300px; background-color:#ddd; } main div{ width: 50px; height: 50px; background: #eee content-box; padding: .5rem; text-align: center; line-height: 50px; } 1 2 3 4 5 6 7 8 9 组合定义 flex-flow 使用flex-flow可进行组合定义，它提供了对flex-direction与flex-wrap的简写。 示例： flex-flow: row column; 轴与排列 轴的介绍 一个弹性容器拥有2根轴： 主轴 交叉轴（从轴） 轴是根据排列方式flex-direction值的不同来进行变化而并非是一成不变的。 常见变化如下所示： 1）如果flex-direction为row，则主轴为水平轴，交叉轴为垂直轴： 2）如果flex-direction为column，则主轴为垂直轴，交叉轴为水平轴： 此外，如果flex-direction为row-reverse或者column-reverse，那么轴的起始位置和结束位置也会发生变化。 这里不在举例，因为使用的比较少。 主轴控制 justify-content justify-content用于控制弹性元素在主轴上的排列方式。 它可设置的值如下表所示： 值 描述 flex-start 弹性元素排列从主轴起始点开始（默认值） flex-end 弹性元素排列从主轴结束点开始 center 弹性元素排列从弹性盒子中心点开始 space-between 第一个元素靠起点，最后一个元素靠终点，余下元素平均分配空间 space-around 每个元素两侧的间隔相等，所以，项目之间的间隔比项目与边框的间隔大一倍 space-evenly 元素间距离平均分配 1）flex-start 弹性元素排列从主轴起始点开始（默认值）： 2）flex-end 弹性元素排列从主轴结束点开始： 3）center 弹性元素排列从弹性容器中心点开始： 4）space-between 第一个元素靠起点，最后一个元素靠终点，余下元素平均分配空间： 5）space-around 每个元素两侧的间隔相等，所以，项目之间的间隔比项目与边框的间隔大一倍： 6）space-evenly 元素间距离平均分配： 代码示例： Document main{ display:flex; flex-flow: row wrap; justify-content: space-evenly; width:300px; height:300px; background-color:#ddd; } main div{ width: 50px; height: 50px; background: #eee content-box; padding: .5rem; text-align: center; line-height: 50px; } 1 2 3 4 5 6 7 8 9 交叉轴元素控制 align-items align-items用于控制弹性元素在交叉轴上的排列方式。 该设置仅在弹性元素只有一行时适用。 它可设置的值如下表所示： 值 描述 stretch 元素被拉伸以适应容器（默认值） center 元素位于容器的中心 flex-start 元素位于容器的交叉轴开头（默认值） flex-end 元素位于容器的交叉轴结尾 注意，如果弹性元素设置了 width | height | min-height | min-width | max-width | max-height ，将影响stretch的结果，因 stretch优先级低于宽高设置。 1）stretch 元素被拉伸以适应容器（默认值）： 2）center 元素位于容器的中心： 3）flex-start 元素位于容器的交叉轴开头（默认值）： 4）flex-end 元素位于容器的交叉轴结尾： 代码示例： Document main{ display:flex; flex-flow: row; justify-content: space-evenly; align-items: flex-end; /* align-items: stretch; align-items: center; align-items: flex-start; */ width:300px; height:300px; background-color:#ddd; } main div{ width: 50px; /* 如果验证stretch，请取消弹性元素的高度设置 */ height: 50px; background: #eee content-box; padding: .5rem; text-align: center; line-height: 50px; } 1 2 3 4 交叉轴内容控制 align-content align-content只适用于多行显示的弹性容器，它能够控制每一行（注意不是弹性元素）在交叉轴上的排列方式。 该设置仅在弹性元素具有多行时适用。 它可设置的值如下表所示： 值 描述 stretch 将空间平均分配给内容 flex-start 内容紧靠交叉轴起点 flex-end 内容紧靠交叉轴终点 center 内容从弹性容器中心开始 space-between 第一行元素靠起点，最后一行元素靠终点，余下元素平均分配空间 space-around 每行元素两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍 space-evenly 元素行间距离平均分配 1）stretch 将空间平均分配给内容： 2）flex-start 内容紧靠交叉轴起点： 3）flex-end 内容紧靠交叉轴终点： 4）center 内容从弹性容器中心开始： 5）space-between 第一行元素靠起点，最后一行元素靠终点，余下元素平均分配空间： 6）space-around 每行元素两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍： 7）space-evenly 元素行间距离平均分配： 代码示例： Document main { display: flex; flex-flow: row wrap; justify-content: space-evenly; align-content: space-evenly; /* align-content: stretch; align-content: flex-start; align-content: flex-end; align-content: center; align-content: space-between; align-content: space-evenly; */ width: 300px; height: 300px; background-color: #ddd; } main div { width: 50px; height: 50px; background: #eee content-box; padding: .5rem; text-align: center; line-height: 50px; } 1 2 3 4 5 6 7 8 9 弹性元素 交叉轴控制 align-self align-self用于控制单个弹性元素在交叉轴上的排列方式。 注意区分align-items与align-content和align-self的区别： align-items：弹性容器中设置，控制单行 align-content：弹性容器中设置，控制多行 align-self：弹性元素中设置，控制自己，即一个元素 它们的优先级如下： align-items 由于align-self的优先级小于align-content，故设置了align-content后就不要再使用align-self设置单个弹性元素的排列方式了。 它可设置的值如下表所示： 值 描述 stretch 元素被拉伸以适应容器（默认值） flex-start 元素紧靠主轴起点 flex-end 元素紧靠主轴终点 center 元素从弹性容器中心开始 示例如下，仅改变元素 1 在交叉轴的排列方式。 代码示例： Document main { display: flex; flex-flow: row wrap; justify-content: space-evenly; align-items: flex-end; width: 300px; height: 300px; background-color: #ddd; } main div { width: 50px; height: 50px; background: #eee content-box; padding: .5rem; text-align: center; line-height: 50px; } main div:nth-of-type(1){ align-self: center; } 1 2 3 4 增加自身可用空间 flex-grow 对弹性元素使用flex-grow，将弹性容器内部可用空间分配给该弹性元素，可以使用整数或小数声明空间占比。 如下示例，弹性容器的排列方式为row，content宽度为300px，其内部共有3个弹性元素，将它们的空间占用分别划分为1、3、6。 即将弹性容器整体宽度300px分为10份，然后按照1、3、6的比例分配给每个弹性元素。 计算规则： 弹性容器总宽度 / (元素1占比 + 元素2占比 + 元素3占比) * 要算的元素占比 元素1占用宽度为 ： 300 / (1 + 3 + 6) * 1 = 30px 元素2占用宽度为 ： 300 / (1 + 3 + 6) * 3 = 90px 元素3占用宽度为 ： 300 / (1 + 3 + 6) * 6 = 180px Document main { display: flex; flex-flow: row wrap; width: 300px; background-color: #ddd; } main div { background: #eee content-box; text-align: center; line-height: 50px; } main div:nth-of-type(1) { flex-grow: 1; background-color: deeppink; } main div:nth-of-type(2) { flex-grow: 3; background-color: deepskyblue; } main div:nth-of-type(3) { flex-grow: 6; background-color: violet; } 1 2 3 如果弹性元素设置了宽度，请把弹性容器宽度 - 所有弹性元素宽度总和后再按照flex-grow进行分配。 下面每个弹性元素的宽度为50px，总宽度为150px，弹性容器的宽度为300px，余下可分配空间为300px - 150px。 计算规则： 弹性容器剩余宽度 / (元素1占比 + 元素2占比 + 元素3占比) * 要算的元素占比 元素1占用宽度为 ： 150 / (1 + 3 + 6) * 1 = 15px + 50px（已有宽度） 元素2占用宽度为 ： 150 / (1 + 3 + 6) * 3 = 45px + 50px（已有宽度） 元素3占用宽度为 ： 150 / (1 + 3 + 6) * 6 = 90px + 50px（已有宽度） Document main { display: flex; flex-flow: row wrap; width: 300px; background-color: #ddd; } main div { background: #eee content-box; text-align: center; line-height: 50px; width: 50px; } main div:nth-of-type(1) { flex-grow: 1; background-color: deeppink; } main div:nth-of-type(2) { flex-grow: 3; background-color: deepskyblue; } main div:nth-of-type(3) { flex-grow: 6; background-color: violet; } 1 2 3 缩小自身可用空间 flex-shrink 与flex-grow相反flex-shrink是在弹性容器装不下元素时定义的缩小值。 注意！要取消弹性容器的换行，flex-shrink才能生效，否则无效，装不下时就直接换行了 计算规则如下： 溢出空间 = 元素1宽度 + 元素2宽度 + 元素n宽度 - 弹性容器宽度 最终尺寸 = 溢出空间 - (溢出空间 / (元素1宽度 * 元素1缩放比例 + 元素2宽度 * 元素2缩放比例 + 元素n宽度 * 元素n缩放比例) * 待计算元素的缩放比例 ) * 待计算元素宽度 如下示例，我们在宽度为300px且排列方式为row的弹性容器中放下了3个宽度为150px的弹性元素。很明显弹性容器会压缩器内部的弹性元素。 各个弹性元素的缩放比例为1， 3， 6。 开始套用规则进行计算： 溢出空间：3 * 150 - 300 = 150 元素1最终尺寸：150 - ( 150 / (150 * 1 + 150 * 3 + 150 * 6) * 1 ) * 150 = 135px 元素2最终尺寸：150 - ( 150 / (150 * 1 + 150 * 3 + 150 * 6) * 3 ) * 150 = 105px 元素3最终尺寸：150 - ( 150 / (150 * 1 + 150 * 3 + 150 * 6) * 6 ) * 150 = 60px Document main { display: flex; flex-flow: row nowrap; width: 300px; background-color: #ddd; } main div { background: #eee content-box; text-align: center; line-height: 50px; width: 150px; } main div:nth-of-type(1) { flex-shrink: 1; background-color: deeppink; } main div:nth-of-type(2) { flex-shrink: 3; background-color: deepskyblue; } main div:nth-of-type(3) { flex-shrink: 6; background-color: violet; } 1 2 3 定义基准尺寸 flex-basis 如果将轴的宽度看做100%，我们可以对弹性元素使用flex-basis来定义它占据主轴的百分比。 使用时需要注意一点，该项设置的优先级大于width和height。 如下所示，主轴宽度为300px，3个弹性元素占比为20%，20%，60%： Document main { display: flex; flex-flow: row nowrap; width: 300px; background-color: #ddd; } main div { background: #eee content-box; text-align: center; line-height: 50px; } main div:nth-of-type(1) { flex-basis: 20%; background-color: deeppink; } main div:nth-of-type(2) { flex-basis: 20%; background-color: deepskyblue; } main div:nth-of-type(3) { flex-basis: 60%; background-color: violet; } 1 2 3 组合定义 flex 使用flex可对flex-grow、flex-sharink以及flex-basis进行简写。 即：增容比例、缩容比例、基准尺寸占比。 在这其中，基准尺寸占比的优先级最大。 建议不要仅在flex中设置单独的1个值。 如下示例： Document main { display: flex; flex-flow: row nowrap; width: 300px; background-color: #ddd; } main div { background: #eee content-box; text-align: center; line-height: 50px; } main div:nth-of-type(1) { /* 增容比例、缩容比例、基准尺寸占比 */ flex: 1 0 40%; background-color: deeppink; } main div:nth-of-type(2) { flex: 3 1 20%; background-color: deepskyblue; } main div:nth-of-type(3) { flex: 3 1 20%; background-color: violet; } 1 2 3 元素排序优先级 order 所有的弹性元素优先级默认均为0，优先级越低越靠近主轴起始点。 Document main { display: flex; flex-flow: row nowrap; width: 300px; background-color: #ddd; } main div { background: #eee content-box; text-align: center; line-height: 50px; } main div:nth-of-type(1) { order: 3; flex-grow: 1; background-color: deeppink; } main div:nth-of-type(2) { order: 2; flex-grow: 1; background-color: deepskyblue; } main div:nth-of-type(3) { order: 1; flex-grow: 1; background-color: violet; } A-order 3 B-order 2 C-order 1 文本元素 文本也可以作为弹性元素。 Document main { display: flex; flex-flow: row nowrap; justify-content: center; align-items: center; width: 300px; height: 300px; background-color: #ddd; font-size: 4rem; } text 绝对定位 绝对定位的元素是不会参与到弹性布局中的。 可以看见弹性容器中绝对定位的元素交叉轴拉伸是不起作用的： Document main { display: flex; flex-flow: row nowrap; justify-content: center; align-items: stretch; width: 300px; height: 300px; background-color: #ddd; position: relative; } main div{ background-color: #eee; padding: .5rem; } main div:nth-child(2){ position: absolute; left: 1rem; top: 3rem; } stream absolute 自动空间 使用margin-right: auto可令弹性元素自动撑开余下的空间。 如下这个案例，我们是水平排列方式，要将滑稽头像放在最右边，但是对于滑稽这个弹性元素来说没有那种能够将自己放在水平主轴结束位置的选项。 所以我们可以对左边的ul弹性元素使用margin-right: auto;来进行自动将右边撑开： 或者也可以对header使用justify-content: space-between，达到相同的效果。 Document header { display: flex; flex-flow: row nowrap; width: 60%; background-color: #f3f3f3; box-shadow: 0 0 5px rgba(0, 0, 0, .2); /* 二选一 justify-content*: space-between */ } header ul { display: flex; /* 二选一 */ margin-right: auto; } header ul li { padding: 1rem; } header img { width: 3rem; margin-right: 1rem; border-radius: 50%; } 主页 我的关注 我的文章 我的好友 微信布局 使用弹性布局快速搭建微信布局： Document :root { background-color: #ccc; } header, main, footer { display: flex; flex-flow: row nowrap; padding: 0 1rem; border-bottom: 1px solid #bbb; justify-content: space-between; align-items: center; } header { height: 10vh; } main { height: 80vh; } main ul { width: 100%; display: flex; flex-flow: column nowrap; /* 优先级大于 align-items */ align-self: flex-start; } main ul li { margin-top: 3rem; display: flex; align-items: center; } main ul li:last-of-type { align-self: flex-end; } main ul li *:last-child { margin-left: .5rem; } main ul li i.icon-huaji, main ul li i.icon-mojinghuaji { font-size: 2rem; color: green; background-color: #ddd; } main ul li span { background-color: #fff; border: 1px solid #aaa; padding: .4rem; border-radius: 10px; } footer { height: 10vh; } footer i { font-size: 2rem !important; } footer input { height: 50%; } &lt; 大神 ... 老弟在吗？ 一起去看电影 哥我不去了，今天没时间 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-08-05 22:51:48 "},"前端专栏/CSS/栅格布局.html":{"url":"前端专栏/CSS/栅格布局.html","title":"栅格布局","keywords":"","body":"栅格布局 基本介绍 CSS的栅格布局也被称为网格布局(Grid Layout)，它是一种新兴的布局方式。 栅格布局是一个二维系统，这意味着它可以同时处理列和行，与弹性布局相似，栅格系统也是由栅格容器包裹栅格元素进行使用。 对于栅格布局来说，它的思想实际上非常简单，将一块区域绘制成格子，然后将元素填进去即可。 作为学习者应该从下面两个角度来学习栅格布局： 怎么样画出栅格容器 怎么样将元素放进栅格容器中的某一区域 　值得一提的是，现在的一些旧版浏览器对于栅格布局并没有较好的支持性，所以这项技术的应用场景其实相比于传统式的浮动布局以及弹性布局来说会少一些。 栅格容器 容器声明 使用display: grid或者display: inline-gid声明一个元素为栅格容器。 grid：块级栅格容器，独占一行 inline-grid：内联块级栅格容器，不独占一行 首先声明grid，即块级栅格容器，可以看见容器本身是独占一行的： 其次是inline-grid，即内联块级栅格容器，容器本身不会独占一行： 代码示例： Document main { border: solid 5px silver; /* 声明容器 */ display: inline-grid; /* display: grid; display: inline-grid; */ /* 划分行列 */ grid-template-rows: repeat(3, 100px); grid-template-columns: repeat(3, 100px); } main div { background: blueviolet content-box; padding: 10px; border: 1px #000 dashed; text-align: center; line-height: 80px; color: #fff; } 1 2 3 4 5 6 7 8 9 this is span element 栅格容器之行列划分 划分行列 光有栅格容器没有用，我们还需要为栅格容器划分行列以及指定宽度。 grid-template-rows：划分行数 grid-template-columns：划分列数 下面介绍几种划分行列的方式。 固定宽高 如我们想画一个2行3列固定宽高的栅格容器，可以使用下面的方法进行绘制： grid-template-rows: 100px 100px; grid-template-columns: 100px 100px 100px; 渲染结果，高度200px，款度300px： 代码示例： Document main { border: solid 5px silver; /* 声明容器 */ display: inline-grid; /* 划分行列 */ grid-template-rows: 100px 100px; grid-template-columns: 100px 100px 100px; } main div { background: blueviolet content-box; padding: 10px; border: 1px #000 dashed; text-align: center; line-height: 80px; color: #fff; } 1 2 3 4 5 6 百分比宽高 使用百分比来绘制行列线，使用这种方式你必须先指定栅格容器的宽高。 如下面示例中为一个300 * 300的栅格容器绘制出2行4列的线条： grid-template-rows: 50% 50%; grid-template-columns: 25% 25% 25% 25%; 渲染结果： 代码示例： Document main { border: solid 5px silver; width: 300px; height: 300px; /* 声明容器 */ display: inline-grid; /* 划分行列 */ grid-template-rows: 50% 50%; grid-template-columns: 25% 25% 25% 25%; } main div { background: blueviolet content-box; padding: 10px; border: 1px #000 dashed; text-align: center; line-height: 150px; color: #fff; } 1 2 3 4 5 6 7 8 重复划分 若每行或每列的间距是相同的，则直接可以使用重复绘制更加简便的划分行列。 grid-template-rows: repeat(3, 100px); grid-template-columns: repeat(3, 100px); 代码示例： Document main { border: solid 5px silver; /* 声明容器 */ display: inline-grid; /* 划分行列 */ grid-template-rows: repeat(3, 100px); grid-template-columns: repeat(3, 100px); } main div { background: blueviolet content-box; padding: 10px; border: 1px #000 dashed; text-align: center; line-height: 80px; color: #fff; } 1 2 3 4 5 6 7 8 9 我们也可以重复绘制不同宽度的单元格，比如奇数项的列要宽一点，偶数项的列要窄一点： grid-template-rows: repeat(3, 100px); grid-template-columns: repeat(2, 100px 50px); 代码示例： Document main { border: solid 5px silver; /* 声明容器 */ display: inline-grid; /* 划分行列 */ grid-template-rows: repeat(3, 100px); /* 重复2次， 奇数项列宽为100px、偶数项列宽为50px 最终总列数 = 重复次数 * 后面跟上的个数 即 2 * 2 = 4列 */ grid-template-columns: repeat(2, 100px 50px); } main div { background: blueviolet content-box; padding: 10px; border: 1px #000 dashed; text-align: center; line-height: 80px; color: #fff; } 1 2 3 4 5 6 7 8 9 10 11 12 自动划分 自动划分是指不指定划分多少行或者列，而是只给他一个行列占比的具体数值，它会自动根据容器的大小来进行划分。 我们想在一个宽和高都是300px的栅格容器中进行绘制，而每个单元格的宽高都是100px，那就设置一下交给他自动绘制。 grid-template-rows: repeat(auto-fill, 100px); grid-template-columns: repeat(auto-fill, 100px); 代码示例： Document main { width: 300px; height: 300px; border: solid 5px silver; /* 声明容器 */ display: inline-grid; /* 划分行列 */ grid-template-rows: repeat(auto-fill, 100px); grid-template-columns: repeat(auto-fill, 100px); } main div { background: blueviolet content-box; padding: 10px; border: 1px #000 dashed; text-align: center; line-height: 80px; color: #fff; } 1 2 3 4 5 6 7 8 9 比例划分 如果你的栅格容器已设置宽高，则我们可以按照空间比例进行行列划分。单位是fr。 如下所示，这是一个3行3列的栅格容器，第一行和最后一行的高度都为3fr，中间一行的高度为4fr，第一列和最后一列的宽度都为2fr，中间一列的宽度为6fr： grid-template-rows: 3fr 4fr 3fr; grid-template-columns: 2fr 6fr 2fr; 代码示例： Document main { width: 300px; height: 300px; border: solid 5px silver; /* 声明容器 */ display: inline-grid; /* 划分行列 */ grid-template-rows: 3fr 4fr 3fr; grid-template-columns: 2fr 6fr 2fr; } main div { background: blueviolet content-box; padding: 10px; border: 1px #000 dashed; text-align: center; line-height: 80px; color: #fff; } 1 2 3 4 5 6 7 8 9 组合定义 grid-template是grid-template-rows、grid-template-columns、grid-template-areas 的三个属性的简写。 但是我们目前还没有介绍到grid-template-areas，所以仅演示用grid-template来划分行列。 如下将采用组合定义的方式构建出一个3行3列宽高均为100px的栅格容器： 注意：先行后列 grid-template: repeat(3, 100px) / repeat(3, 100px); 代码示例： Document main { border: solid 5px silver; /* 声明容器 */ display: inline-grid; /* 划分行列 先行后列 */ grid-template: repeat(3, 100px) / repeat(3, 100px); } main div { background: blueviolet content-box; padding: 10px; border: 1px #000 dashed; text-align: center; line-height: 80px; color: #fff; } 1 2 3 4 5 6 7 8 9 minmax划分 如果你的栅格容器设置了宽高，且栅格容器中单元格的宽高大于整体栅格容器的宽高就会发生溢出现象。 我们在划分行列时，可以指定minmax，为行线或者列线设定一个动态的取值数值来防止溢出的发生。 上面这个例子中，栅格容器宽高为200px 300px，但是行列划分时设定是3列3行100px，所以就造成了列溢出。 此时我们可以在列划分时设置minmax来进行单元格的自动缩容或者扩容： 释义：列线3根，最小取值范围为50px，最大取值范围为100px grid-template: repeat(3, 100px) / repeat(3, minmax(50px, 100px)); 栅格容器之间距定义 行间距 row-gap 栅格容器中每一个元素，现在看是紧密挨在一起的。我们可以对栅格元素本身进行margin或者padding来将彼此之前撑开留出间隙，也可以使用栅格容器提供的方法。 使用row-gap设置行间距。 Document * { padding: 0; margin: 0; } body { padding: 100px; } main { width: 300px; /* height: 300px; */ border: solid 5px silver; display: grid; /* 行数，列数 */ grid-template: repeat(3,100px)/repeat(3,minmax(50px,100px)); /* 行间距 */ row-gap:30px ; } section { background-color: blueviolet; background-clip: content-box; padding: 10px; border: dashed 1px black; text-align: center; line-height: 78px; color: #fff; } 1 2 3 4 5 6 7 8 9 列间距 columns-gap 使用column-gap定义列间距。 Document * { padding: 0; margin: 0; } body { padding: 100px; } main { width: 300px; /* height: 300px; */ border: solid 5px silver; display: grid; /* 行数，列数 */ grid-template: repeat(3,100px)/repeat(3,minmax(50px,100px)); /* 列间距 */ column-gap:30px ; } section { background-color: blueviolet; background-clip: content-box; padding: 10px; border: dashed 1px black; text-align: center; line-height: 78px; color: #fff; } 1 2 3 4 5 6 7 8 9 组合定义 gap 使用gap规则可以一次定义行、列间距，如果间距一样可以只设置一个值。 Document * { padding: 0; margin: 0; } body { padding: 100px; } main { width: 300px; /* height: 300px; */ border: solid 5px silver; display: grid; /* 行数，列数 */ grid-template: repeat(3,100px)/repeat(3,minmax(50px,100px)); /* 行列间距 */ gap:30px ; } section { background-color: blueviolet; background-clip: content-box; padding: 10px; border: dashed 1px black; text-align: center; line-height: 78px; color: #fff; } 1 2 3 4 5 6 7 8 9 栅格容器之栅格线命名 基础知识 可以发现，其实最少有2条线的数据就可以定位一个栅格元素所在的位置。 如果我们想将元素放入正中间，可以这样设置： 行线开始位：2号线开始或者1号线结束位置 列线开始位：2号线开始或者1号线结束位置 行线结束位：3号线开始或者2号线结束位置 列线结束位：3号线开始或者2号线结束位置 那么这样，我们就可以将元素定位在该容器正中，并且大小只占据1个单元格。 独立命名 我们可以为每一条栅格线都进行独立命名，现在就来将上面的伪代码实现一下。 grid-template-rows: [r1-start] 100px [r1-end r2-start] 100px [r2-end r3-start] 100px [r3-end]; grid-template-columns: [c1-start] 100px [c1-end c2-start] 100px [c2-start c3-start] 100px [c3-end]; 每条线可以有多个名字，在使用的时候可以使用其任意的且具有的名字。 当我们需要定位的时候，使用如下格式对一个元素进行定位： grid-row-start: r2-start; grid-column-start:c1-end; grid-row-end: r2-end; grid-column-end: c3-start; 注意！默认的栅格容器是不会展示栅格线的，此时需要打开浏览器的检查功能就会看到栅格线。 Document * { padding: 0; margin: 0; } body { padding: 100px; } main { width: 300px; /* height: 300px; */ border: solid 5px silver; display: grid; /* 行数，列数 */ grid-template-rows: [r1-start] 100px [r1-end r2-start] 100px [r2-end r3-start] 100px [r3-end]; grid-template-columns: [c1-start] 100px [c1-end c2-start] 100px [c2-start c3-start] 100px [c3-end]; } section { background-color: blueviolet; background-clip: content-box; padding: 10px; border: dashed 1px black; text-align: center; line-height: 78px; color: #fff; grid-row-start: r2-start; grid-column-start: c1-end; grid-row-end: r2-end; grid-column-end: c3-start; } 中间 自动命名 对于重复设置的栅格容器系统会为它自动命名，使用时使用r1、c2的方式定位栅格。 r代表行 c代表列 重复设置，命名前缀： grid-template-rows: repeat(3, [r-start] 100px [r-end]); grid-template-columns: repeat(3, [c-start] 100px [c-end]); 在使用自动命名的栅格线进行定位时，应该按照如下格式： grid-row-start: r-start 2; grid-column-start: c-start 2; grid-row-end: r-start 2; grid-column-end: c-end 2; Document * { padding: 0; margin: 0; } body { padding: 100px; } main { width: 300px; /* height: 300px; */ border: solid 5px silver; display: grid; /* 行数，列数 */ grid-template-rows: repeat(3, [r-start] 100px [r-end]); grid-template-columns: repeat(3, [c-start] 100px [c-end]); } section { background-color: blueviolet; background-clip: content-box; padding: 10px; border: dashed 1px black; text-align: center; line-height: 78px; color: #fff; grid-row-start: r-start 2; grid-column-start: c-start 2; grid-row-end: r-start 2; grid-column-end: c-end 2; } 中间 栅格元素之元素定位 定位方法 我们可以使用以下方法对栅格元素进行定位，但是关于如何定位又分为很多种。 选项 描述 grid-row-start 行开始栅格线 grid-row-end 行结束栅格线 grid-column-start 列开始栅格线 grid-column-end 列结束栅格线 栅格线位置定位 栅格线位置定位实际上就是数数，在水平的第几根线，在垂直的第几根线。 还是老办法，规定行开始线位置与行结束线位置以及列开始线位置和列结束线位置。 如下，可以看到，单纯的就是数数，非常的简单粗暴。 grid-row-start: 2; grid-column-start: 2; grid-row-end: 2; grid-column-end: 2; Document * { padding: 0; margin: 0; } body { padding: 100px; } main { width: 300px; /* height: 300px; */ border: solid 5px silver; display: grid; /* 行数，列数 */ grid-template-rows: repeat(3, 100px); grid-template-columns: repeat(3, 100px); } section { background-color: blueviolet; background-clip: content-box; padding: 10px; border: dashed 1px black; text-align: center; line-height: 78px; color: #fff; grid-row-start: 2; grid-column-start: 2; grid-row-end: 2; grid-column-end: 2; } 中间 栅格线名称定位 我们说过栅格线有独立命名和自动命名。 根据栅格线名称也可以进行定位，这里不再举例，具体参见栅格线命名一章。 偏移量定位 这个其实也比较简单，我们只需要指定行线的开始位置以及列线的开始位置即可，关于结束为止也是数数，使用span来数，往后走一根线还是两根线。 grid-row-start: 1; grid-column-start: 1; /\\ 代表从行线开始位置向后数3根线 */* grid-row-end: span 3; /\\ 代表从列线开始位置向后数3根线 */* grid-column-end: span 3; Document * { padding: 0; margin: 0; } body { padding: 100px; } main { width: 300px; /* height: 300px; */ border: solid 5px silver; display: grid; /* 行数，列数 */ grid-template-rows: repeat(3, 100px); grid-template-columns: repeat(3, 100px); } section { background-color: blueviolet; background-clip: content-box; padding: 10px; border: dashed 1px black; text-align: center; line-height: 300px; color: #fff; grid-row-start: 1; grid-column-start: 1; /* 代表从行线开始位置向后数3根线 */ grid-row-end: span 3; /* 代表从列线开始位置向后数3根线 */ grid-column-end: span 3; } 全占 简写模式 可以使用grid-row设置行开始栅格线，使用grid-column设置结束栅格线。 grid-row: 3/span 3; grid-column: 2/span 3; Document * { padding: 0; margin: 0; } body { padding: 100px; } main { width: 300px; /* height: 300px; */ border: solid 5px silver; display: grid; /* 行数，列数 */ grid-template-rows: repeat(3, 100px); grid-template-columns: repeat(3, 100px); } section { background-color: blueviolet; background-clip: content-box; padding: 10px; border: dashed 1px black; text-align: center; line-height: 78px; color: #fff; grid-row: 3/span 3; grid-column: 2/span 3; } 右下角两格 极简模式 grid-area是对上面的简写模式grid-row以及grid-column的再次简写，它的语法结构如下： 行线开始/列线开始/行线结束/列线结束 grid-area: 2/1/span 1/span 3; Document * { padding: 0; margin: 0; } body { padding: 100px; } main { width: 300px; /* height: 300px; */ border: solid 5px silver; display: grid; /* 行数，列数 */ grid-template-rows: repeat(3, 100px); grid-template-columns: repeat(3, 100px); } section { background-color: blueviolet; background-clip: content-box; padding: 10px; border: dashed 1px black; text-align: center; line-height: 78px; color: #fff; grid-area: 2/1/span 1/span 3; } 中间三格 bootstrap 栅格原理 bootstrap中的栅格系统将整个栅格容器分为了12个块，其实它的原理非常简单。 我们用目前所学的知识也能开发类似的组件，如下图： Document * { padding: 0; margin: 0; } body { padding: 100px; } .row { padding: 10px; width: 600px; border: solid 5px silver; display: grid; grid-template-columns: repeat(12, 1fr); gap: 10px 10px; } .col-1 { grid-column-end: span 1; } .col-2 { grid-column-end: span 2; } .col-3 { grid-column-end: span 3; } .col-4 { grid-column-end: span 4; } .col-5 { grid-column-end: span 5; } .col-6 { grid-column-end: span 6; } .col-7 { grid-column-end: span 7; } .col-8 { grid-column-end: span 8; } .col-9 { grid-column-end: span 9; } .col-10 { grid-column-end: span 10; } .col-11 { grid-column-end: span 11; } .col-12 { grid-column-end: span 12; } [class^=\"col-\"] { background-color: blueviolet; background-clip: content-box; height: 30px; text-align: center; color: #fff; } col-8 col-4 col-4 col-4 col-4 col-6 col-6 栅格容器之栅格区域 基础介绍 栅格区域说白了就是一堆栅格的单元格组成的区域，一个单元格也是一个区域。 我们可以使用栅格区域更方便的放置元素而不用再慢慢的数线放置，栅格区域放置元素通常用在大布局上。 使用grid-template-areas声明栅格区域时需要注意一点，栅格区域放置元素必须是矩形的。 你不能这样放置这样的一个元素： 区域命名 来看一个简单的案例，如何使用grid-template-areas对栅格区域进行命名并填充元素。 Document * { padding: 0; margin: 0; } body { padding: 100px; } main { width: 300px; /* height: 300px; */ border: solid 5px silver; display: grid; /* 行数，列数 */ grid-template-rows: repeat(3, 100px); grid-template-columns: repeat(3, 100px); grid-template-areas: \"top top top\" \"mid mid mid\" \"bottom bottom bottom\"; /* 由于绘制了9*9的单元格，我们必须给每个单元格进行了命名 ，而且一定要是这种格式*/ } main * { background-clip: content-box; padding: 10px; border: dashed 1px black; } main header { /* 完整的写法，推荐使用下面的简写方式*/ /* grid-area: top-start/top-start//top-start/top-end/top-end/top-end; */ grid-area: top; background-color: blueviolet; } main article { grid-area: mid; background-color: violet; } main footer { grid-area: bottom; background-color: yellowgreen; } 自动命名 栅格容器中的每个单元格的列行线都会根据单元格名称自动进行命名，如下图所示： 按图中这种命名来进行实验： Document * { padding: 0; margin: 0; } body { padding: 100px; } main { width: 300px; /* height: 300px; */ border: solid 5px silver; display: grid; /* 行数，列数 */ grid-template-rows: repeat(3, 100px); grid-template-columns: repeat(3, 100px); grid-template-areas: \"top-left top-center top-right\" \"mid-left mid-center mid-right\" \"bottom-left bottom-center bottom-right\"; /* 由于绘制了9*9的单元格，我们必须给每个单元格进行了命名 ，而且一定要是这种格式*/ } main * { background-clip: content-box; padding: 10px; border: dashed 1px black; } main div:first-of-type { grid-area: top-left-start/top-left-start/mid-center-end/mid-center-end; background-color: blueviolet; } main div:last-of-type { grid-area: bottom-left-start/bottom-left-start/bottom-right-end/bottom-right-end; background-color: violet; } 占位命名 栅格区域命名占位就是说有的区域不想给他取名，那么就直接.就行。 为什么要这么做呢？看下图以及代码就能理解，我们在进行区域划分的时候就想好了这一块区域是来干什么的，应该有多大，那么多余的地方直接.占位即可。 Document * { padding: 0; margin: 0; } body { padding: 100px; } main { width: 300px; /* height: 300px; */ border: solid 5px silver; display: grid; /* 行数，列数 */ grid-template-rows: repeat(3, 100px); grid-template-columns: repeat(3, 100px); grid-template-areas: \"top top top\" \"mid mid .\" \"bottom . .\"; /* 由于绘制了9*9的单元格，我们给每个单元格进行了命名 ，一定要是这种格式*/ } main * { background-clip: content-box; padding: 10px; border: dashed 1px black; } main header { /* 完整的写法，推荐使用下面的简写方式*/ /* grid-area: top-start/top-start//top-start/top-end/top-end/top-end; */ grid-area: top; background-color: blueviolet; } main article { grid-area: mid; background-color: violet; } main footer { grid-area: bottom; background-color: yellowgreen; } 栅格元素之元素排序 排序方式 默认情况下，整个栅格元素都是以行（水平）进行填充排序，我们可以在容器中设置grid-auto-flow属性可以改变元素排序的方式。 值 描述 column 按列排序 row 按行排列 Document * { padding: 0; margin: 0; } body { padding: 100px; } main { width: 300px; height: 300px; border: solid 5px silver; display: grid; /* 行数，列数 */ grid-template: repeat(3, 100px)/repeat(3, 100px); /* 排序方式：垂直 */ grid-auto-flow: column; } section { background-color: blueviolet; background-clip: content-box; padding: 10px; border: dashed 1px black; text-align: center; line-height: 78px; color: #fff; } 1 2 3 4 5 6 7 8 9 空间填充 当元素在栅格中放不下时，将会发生换行产生留白，使用grid-auto-flow: row dense; 可以执行填充空白区域操作。 如下图，产生了两个空间。 当设置之后可以发现，1和2的位置都没变，3和4填充了上来： Document * { padding: 0; margin: 0; } body { padding: 100px; } main { width: 300px; height: 300px; border: solid 5px silver; display: grid; /* 行数，列数 */ grid-template: repeat(3, 100px)/repeat(3, 100px); /* 排序方式：水平 是否填充空间：填充 */ grid-auto-flow: row dense; } section { background-color: blueviolet; background-clip: content-box; padding: 10px; border: dashed 1px black; text-align: center; line-height: 78px; color: #fff; } main section:nth-of-type(1) { /* 列线 第1根开始往后数2根的区域 */ grid-column: 1/span 2; } main section:nth-of-type(2) { /* 列线 第2根开始往后数2根的区域 */ grid-column: 2/span 2; } 1 2 3 4 对齐方式 对齐选项 可以通过属性方便的定义栅格容器内栅格元素的对齐方式，可用值包括 start | end | center | stretch | space-between | space-evenly | space-around。 下面是提供对齐的属性： 属性 描述 对象 align-items 栅格内所有元素的垂直排列方式 栅格容器 justify-items 栅格内所有元素的横向排列方式 栅格容器 justify-content 所有栅格在容器中的水平对齐方式，容器有额外空间时 栅格容器 align-content 所有栅格在容器中的垂直对齐方式，容器有额外空间时 栅格容器 align-self 元素在栅格中垂直对齐方式 栅格元素 justify-self 元素在栅格中水平对齐方式 栅格元素 下面是属性中可填入的值： 值 描述 start 元素按排序方式顺序排列 end 元素按排序方式倒序排列 center 元素在容器中 space-between 第一个元素靠起点，最后一个元素靠终点，余下元素平均分配空间 space-around 每个元素两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍 space-evenly 元素间距离平均分配 整体区域对齐 其实这些和弹性布局中的用法都差不多，可以看一下前一章写的弹性布局，那么这里就举例一个平均分配吧。 平均分布指的是，栅格容器中的栅格区域（即单元格），在栅格容器中的对齐方式。 注意：栅格容器一定要有多余空间。 指定所有区域对齐方式使用justify-content与align-content： Document * { padding: 0; margin: 0; } body { padding: 100px; } main { width: 600px; /* 宽度和高度要足够大 */ height: 600px; border: solid 5px silver; display: grid; /* 行数，列数 */ grid-template: repeat(3, 100px)/repeat(3, 100px); /* 水平平均 */ justify-content: space-evenly; /* 垂直平均 */ justify-content: space-evenly; align-content: space-evenly; } section { background-color: blueviolet; background-clip: content-box; padding: 10px; border: dashed 1px black; text-align: center; line-height: 78px; color: #fff; } 1 2 3 4 5 6 7 8 9 所有元素对齐 指的是栅格区域中具体的栅格元素的对齐方式，比如说一个单元格太大了，那么里面内容又太小了该怎么做。 指定所有栅格区域中的具体元素使用：justify-items与align-items 注意：栅格区域一定要有多余空间。 Document * { padding: 0; margin: 0; } body { padding: 100px; } main { width: 300px; height: 300px; border: solid 5px silver; display: grid; /* 行数，列数 */ grid-template: repeat(3, 100px)/repeat(3, 100px); /* 控制具体元素在单元格中的位置 */ justify-items: center; align-items: center; } section { background-color: blueviolet; background-clip: content-box; padding: 10px; border: dashed 1px black; text-align: center; color: #fff; width: 30px; height: 30px; line-height: 30px; } 1 2 3 4 5 6 7 8 9 单个元素对齐 如果想控制单个元素对齐方式，使用justify-self与align-self即可。 注意：盛放该元素的栅格区域一定要有多余空间。 Document * { padding: 0; margin: 0; } body { padding: 100px; } main { width: 300px; height: 300px; border: solid 5px silver; display: grid; /* 行数，列数 */ grid-template: repeat(3, 100px)/repeat(3, 100px); /* 控制具体元素在单元格中的位置 */ justify-items: center; align-items: center; } section { background-color: blueviolet; background-clip: content-box; padding: 10px; border: dashed 1px black; text-align: center; color: #fff; width: 30px; height: 30px; line-height: 30px; } main section:nth-of-type(1) { justify-self: end; align-self: end; } main section:nth-of-type(2) { justify-self: start; align-self: end; } main section:nth-of-type(4) { justify-self: end; align-self: start; } main section:nth-of-type(5) { justify-self: start; align-self: start; } 1 2 3 4 5 6 7 8 9 简写模式 1）place-content用于控制栅格中所有区域的对齐方式，语法如下： place-content: 2）place-items用于控制所有区域中所有元素的对齐方式，语法如下： place-items: 3）place-self用于控制区域中单个元素的对齐方式，语法如下： place-self: Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-07-20 08:17:09 "},"前端专栏/CSS/变形动画.html":{"url":"前端专栏/CSS/变形动画.html","title":"变形动画","keywords":"","body":"前言 在开始介绍CSS变形动画之前，可以先了解一下学习了它之后能做什么，有什么用，这样你看这篇文章可能会有一些动力。 学习了CSS变形动画后，你可以为你的页面做出很多炫酷的效果，如一个3D的魔方，一个很酷的旋转菜单等等。 在本章节中将会采用大量的实例进行演示，相信你如果看完这篇文章后写出的页面会更加的吸引眼球。 基础知识 坐标系统 首先我们要学习的变形动画，想达到在上图中出现的3D效果单纯的X与Y两个轴是实现不了的，还需要加入一条纵深轴，即Y轴的参与才有一个3D的视觉感受。 那么如何来理解X,Y,Z这三条轴的关系呢？可以看一下下面这张图。 X轴代表水平轴 Y轴代表垂直轴 Z轴代表纵深轴 X和Y轴都非常好理解，怎么理解这个Z轴呢？ CSS的中文名称叫做层叠样式表，那么它肯定是一层一层的。之前学习过z-index就是用来设置层的优先级，优先级越高越在上面，也可以理解为离我们肉眼越近，它把优先级低的层给盖住了，所以Z轴可以理解为我们观察的视角与被观察物体之间的一条轴。 Z轴数值越大，说明观测距离越远。 Z轴的数值可以无限大，所以设置的时候一定要小心。 变形操作 可以使用transform规则控制元素的变形操作，包括元素移动、旋转、倾斜、3D转换等等。 下表中是CSS提供的变形动作，在接下来的学习中将会对一个变形动作进行详解。 选项 说明 none 定义不进行转换。 translate(x,y) 定义 2D 转换。 translate3d(x,y,z) 定义 3D 转换。 translateX(x) 定义转换，只是用 X 轴的值。 translateY(y) 定义转换，只是用 Y 轴的值。 translateZ(z) 定义 3D 转换，只是用 Z 轴的值。 scale(x,y) 定义 2D 缩放转换。 scale3d(x,y,z) 定义 3D 缩放转换。 scaleX(x) 通过设置 X 轴的值来定义缩放转换。 scaleY(y) 通过设置 Y 轴的值来定义缩放转换。 scaleZ(z) 通过设置 Z 轴的值来定义 3D 缩放转换。 rotate(angle) 定义 2D 旋转，在参数中规定角度。 rotate3d(x,y,z,angle) 定义 3D 旋转。 rotateX(angle) 定义沿着 X 轴的 3D 旋转。 rotateY(angle) 定义沿着 Y 轴的 3D 旋转。 rotateZ(angle) 定义沿着 Z 轴的 3D 旋转。 skew(x-angle,y-angle) 定义沿着 X 和 Y 轴的 2D 倾斜转换。 skewX(angle) 定义沿着 X 轴的 2D 倾斜转换。 skewY(angle) 定义沿着 Y 轴的 2D 倾斜转换。 perspective(n) 为 3D 转换元素定义透视视图。 变形叠加 这其实是一个坑点，在使用变形中一定要注意，重复对元素设置变形操作时只在元素的原形态上操作。 我们可以先看一下下面的案例，不懂代码没关系，懂这个意思就行了。 默认处理 下面设置了两次移动，并不会移动550px 而是只移动50px。 我们在元素中先设置了右移500px，鼠标放上去时再往右移动50px，可是下面却出现了向左移动的场景，这是因为对div进行了位置居中处理，它必须要按照之前居中的位置进行50px的移动。而不是按照居中后设置的500px的地方再进行向右移动50px。 上面这句话有点绕，总之。上面设置了，位置改变了，下面再设置，不会按照已改变的位置进行变化，而是按照原位置。 代码示例： Document * { margin: 0; padding: 0; box-sizing: border-box; list-style: none; } body { height: 100vh; width: 100vw; background-color: aliceblue; display: flex; justify-content: center; align-items: center; } div { width: 200px; height: 200px; background-color: blueviolet; /* 意思就是说按x轴移动500px */ transform: translateX(500px); /* 过渡时间2s */ transition: 2s; } div:hover { /* 意思就是说按x轴移动50px */ transform: translateX(50px); } 伪类叠加 还是设置两次移动，如果移动的方向都一样，且伪类设置的移动比原本的移动多一点，就在原本的基础上直接进行变形，而不用再找开始位置了。 我们还是拿上面的案例，只不过伪类移动的数值将50px改为600px，比第一次设置大100px，那么此时他就不会再往左走，而是直接在原有基础上进行叠加，向右移动100px。 代码示例： Document * { margin: 0; padding: 0; box-sizing: border-box; list-style: none; } body { height: 100vh; width: 100vw; background-color: aliceblue; display: flex; justify-content: center; align-items: center; } div { width: 200px; height: 200px; background-color: blueviolet; /* 意思就是说按x轴移动500px */ transform: translateX(500px); /* 过渡时间2s */ transition: 2s; } div:hover { /* 意思就是说按x轴移动600px */ transform: translateX(600px); } 内联元素 内联元素即行级元素，inline元素是不能参与变形的，将其转为 inline-block 或 block 以及弹性元素时才可以产生变化效果。 :hover伪类 鼠标移动到某一元素上发生的用户行为。 当该行为出现时，我们可以为它指定一些参数的改变。 如下，改变颜色。 :target伪类 意思就是说你点击一个\\，该\\标签中的href指向的锚点标签会发生变化。 点击第一个\\元素，与之相对的锚点元素发生变化。 点击第二个\\元素，与第一个\\元素相对的锚点变化停止，与第二个\\元素相对的锚点发生变化。 代码示例： Document * { padding: 0; margin: 0; list-style: none; box-sizing: border-box; } body { width: 100vw; height: 100vh; display: flex; flex-flow: column; justify-content: center; align-items: center; } div { width: 200px; height: 200px; display: flex; justify-content: center; align-items: center; color: #fff; font-size: 2em; } div:nth-child(1) { background: red; } div:nth-child(2) { background: blue; } #div-1:target { background-color: green; } #div-2:target { background-color: black; } 原本颜色：红 原本颜色：蓝 让div-1变绿 让div-2变黑 最后注意一点 事件元素上放过渡时间，:hover上放具体的事件，如移动，旋转，倾斜等操作。 如果你设置了移动却将过渡时间放在了:hover里面，那么就会出现下面这种情况。 可以看见，直勾勾的就回来了，这种效果显然不是我们想要的。 代码示例： Document * { padding: 0; margin: 0; list-style: none; box-sizing: border-box; } body { width: 100vw; height: 100vh; display: flex; justify-content: center; align-items: center; } main { width: 400px; height: 200px; border: 1px solid #ccc; display: flex; justify-content: center; align-items: center; /* 为了设置第一个div的中心点，所以这里设置一个定位，让子元素的绝对定位参照该元素进行偏移 */ position: relative; } div:first-child { height: 8px; width: 8px; background-color: black; z-index: 1; border-radius: 50%; /* 脱离文档流并居中 */ position: absolute; left: 50%; top: 50%; margin-left: -4px; margin-top: -4px; } div:last-child { height: 100px; width: 100px; background-color: blueviolet; /* 过渡时间1s,应该放这里，而不是:hover上面 */ /* transition: 1s; */ } div:last-child:hover { transform: translateX(100px); } 移动元素 沿X轴移动时正值向右移动、负值向左移动 沿Y轴移动时正值向下移动、负值向上移动 如果使用百分数将控制元素的原尺寸计算百分比然后移动 可同时设置多个值，解析器会从左向右依次执行 变形是在原基础上更改，即第二次设置值时不是在第一次值上变化 translateX 控制元素在X轴上的移动，正值向右、负值向左。 如，我们下面设置translateX(100px)，过渡时间为1s。 代码示例： Document * { padding: 0; margin: 0; list-style: none; box-sizing: border-box; } body { width: 100vw; height: 100vh; display: flex; justify-content: center; align-items: center; } main { width: 400px; height: 200px; border: 1px solid #ccc; display: flex; justify-content: center; align-items: center; /* 为了设置第一个div的中心点，所以这里设置一个定位，让子元素的绝对定位参照该元素进行偏移 */ position: relative; } div:first-child { height: 8px; width: 8px; background-color: black; z-index: 1; border-radius: 50%; /* 脱离文档流并居中 */ position: absolute; left: 50%; top: 50%; margin-left: -4px; margin-top: -4px; } div:last-child { height: 100px; width: 100px; background-color: blueviolet; /* 过渡时间1s,应该放这里，而不是:hover上面 */ transition: 1s; } div:last-child:hover { transform: translateX(100px); } translateY 控制元素在X轴上的移动，正值向下、负值向上。 如，我们下面设置translateY(100px)，过渡时间为1s。 代码示例： Document * { padding: 0; margin: 0; list-style: none; box-sizing: border-box; } body { width: 100vw; height: 100vh; display: flex; justify-content: center; align-items: center; } main { width: 200px; height: 400px; border: 1px solid #ccc; display: flex; justify-content: center; align-items: center; /* 为了设置第一个div的中心点，所以这里设置一个定位，让子元素的绝对定位参照该元素进行偏移 */ position: relative; } div:first-child { height: 8px; width: 8px; background-color: black; z-index: 1; border-radius: 50%; /* 脱离文档流并居中 */ position: absolute; left: 50%; top: 50%; margin-left: -4px; margin-top: -4px; } div:last-child { height: 100px; width: 100px; background-color: blueviolet; /* 过渡时间1s,应该放这里，而不是:hover上面 */ transition: 1s; } div:last-child:hover { transform: translateY(100px); } translate translate是translateX以及translateY的简写模式，第一个值控制X移动，第二个值控制Y移动。 一句话，设置X与Y轴的移动，注意，这个方法中不包含Z轴，因为一旦有Z轴参与就会变为3D效果。 代码示例： Document * { padding: 0; margin: 0; list-style: none; box-sizing: border-box; } body { width: 100vw; height: 100vh; display: flex; justify-content: center; align-items: center; } main { width: 400px; height: 400px; border: 1px solid #ccc; display: flex; justify-content: center; align-items: center; /* 为了设置第一个div的中心点，所以这里设置一个定位，让子元素的绝对定位参照该元素进行偏移 */ position: relative; } div:first-child { height: 8px; width: 8px; background-color: black; z-index: 1; border-radius: 50%; /* 脱离文档流并居中 */ position: absolute; left: 50%; top: 50%; margin-left: -4px; margin-top: -4px; } div:last-child { height: 100px; width: 100px; background-color: blueviolet; /* 过渡时间1s,应该放这里，而不是:hover上面 */ transition: 1s; } div:last-child:hover { /* 先设置X轴，再设置Y轴 */ transform: translate(100px, 100px); } 百分比移动 当要移动的元素宽高为100px时，如果使用50%进行移动，则代表移动50px。 代码示例： Document * { padding: 0; margin: 0; list-style: none; box-sizing: border-box; } body { width: 100vw; height: 100vh; display: flex; justify-content: center; align-items: center; } main { width: 400px; height: 400px; border: 1px solid #ccc; display: flex; justify-content: center; align-items: center; /* 为了设置第一个div的中心点，所以这里设置一个定位，让子元素的绝对定位参照该元素进行偏移 */ position: relative; } div:first-child { height: 8px; width: 8px; background-color: black; z-index: 1; border-radius: 50%; /* 脱离文档流并居中 */ position: absolute; left: 50%; top: 50%; margin-left: -4px; margin-top: -4px; } div:last-child { height: 100px; width: 100px; background-color: blueviolet; /* 过渡时间1s,应该放这里，而不是:hover上面 */ transition: 1s; } div:last-child:hover { /* 先设置X轴，再设置Y轴 */ transform: translate(50%, 50%); } 元素居中 我们之前介绍过很多元素居中的方法，如定位操作，弹性盒模型，其实使用移动也可以达到元素居中的效果。 给你丢一套模板。 /* 让子元素脱离文档流并参照副父级元素偏移。这是定位+margin的居中方法 */ position: absolute; left: 50%; top: 50%; /* left和top设置子元素宽高的负的50%就行 */ margin-left: -3px; margin-top: -3px; /* 这是弹性盒模型控制元素居中的方法 */ display: flex; justify-content: center; align-items: center; /* 让子元素脱离文档流并参照副父级元素偏移。这是定位+移动的居中方法 */ position: absolute; left: 50%; top: 50%; /* X和Y设置子元素宽高的负的50%就行 */ transform: translate(-50%, -50%); translateZ 控制Z轴移动，正数向外（距离我们近）、负数向里移动（距离我们远）。因为Z轴是透视轴没有像X/Y一样的固定尺寸，所以不能使用百分数。 代码示例： Document * { padding: 0; margin: 0; list-style: none; box-sizing: border-box; } body { width: 100vw; height: 100vh; display: flex; justify-content: center; align-items: center; } main { width: 200px; height: 200px; display: flex; justify-content: center; align-items: center; border: 1px solid #ccc; /* 如果将Z轴移动的:hover放在div上，我们不方便一直将鼠标放在div上面，故我们设置成放在main上面让div进行Z轴移动 */ /* 为了更好的视觉效果，我们给main容器做一个透视 ,并且让它按照Y轴旋转60度，按Z轴放大5倍*/ transform: perspective(900px) rotateY(60deg) scaleZ(5); /* 使用 transform-style 用于控制3d透视 */ transform-style: preserve-3d; } main:hover div:nth-child(2) { transform: translateZ(-100px); } div { height: 100px; width: 100px; background-color: blueviolet; /* 让子元素脱离文档流并参照副父级元素偏移。这是定位+移动的居中方法 */ position: absolute; left: 50%; top: 50%; transform: translate(-50%, -50%); } div:nth-child(1) { background-color: yellow; } div:nth-child(2) { background-color: blueviolet; /* 过渡时间1s */ transition: 1s; } translate3d 用于同时控制X/Y/Z轴的移动，三个值必须输入如果某个轴不需要移动时设置为零。 代码示例： Document * { padding: 0; margin: 0; list-style: none; box-sizing: border-box; } body { width: 100vw; height: 100vh; display: flex; justify-content: center; align-items: center; } main { width: 200px; height: 200px; display: flex; justify-content: center; align-items: center; border: 1px solid #ccc; /* 如果将Z轴移动的:hover放在div上，我们不方便一直将鼠标放在div上面，故我们设置成放在main上面让div进行Z轴移动 */ /* 为了更好的视觉效果，我们给main容器做一个透视 ,并且让它按照Y轴旋转60度，按Z轴放大5倍*/ transform: perspective(900px) rotateY(60deg) scaleZ(5); /* 使用 transform-style 用于控制3d透视 */ transform-style: preserve-3d; } main:hover div:nth-child(2) { /* 由于Z轴可以无限远，所以不能用百分比 */ transform: translate3d(50%, 50%, 100px); } div { height: 100px; width: 100px; background-color: blueviolet; /* 让子元素脱离文档流并参照副父级元素偏移。这是定位+移动的居中方法 */ position: absolute; left: 50%; top: 50%; transform: translate(-50%, -50%); } div:nth-child(1) { background-color: yellow; } div:nth-child(2) { background-color: blueviolet; /* 过渡时间1s */ transition: 1s; } 渐变输入框 代码示例： Document * { padding: 0; margin: 0; list-style: none; box-sizing: border-box; } body { width: 100vw; height: 100vh; display: flex; justify-content: center; align-items: center; background: #34495e; } #form-style-gradient { width: 200px; height: 200px; display: flex; flex-flow: column; justify-content: center; align-items: center; border: 1px solid #ccc; } #form-style-gradient label input { padding: 10px; outline: none; border: none; background-color: #ecf0f1; } #form-style-gradient label { width: 80%; position: relative; overflow: hidden; margin-bottom: 20px; display: flex; flex-flow: column; justify-content: center; align-self: center; } #form-style-gradient label::before { content: ''; position: absolute; /* 移动到最下面 */ left: 0; bottom: 0; height: 2px; width: 100%; background: linear-gradient(to right, white, #1abc9c, #f1c40f, #e74c3c, white); /* 移动到label标签外，然后会被隐藏掉 */ transform: translateX(-100%); transition: 2s; } #form-style-gradient label:hover::before { /* 移动回来 */ transform: translateX(100%); } 页面切换 代码示例： Document * { padding: 0; margin: 0; } a { text-decoration: none; } body { display: flex; width: 100vw; height: 100vh; flex-direction: column; } main { position: relative; background: #f3f3f3; flex: 1; overflow: hidden; } nav { display: flex; justify-content: space-around; align-items: center; height: 8vh; text-align: center; background: #34495e; } nav a { flex: 1; font-size: 1.3em; text-transform: uppercase; font-weight: bold; opacity: .8; color: white; } nav a:nth-child(2) { border-right: solid 1px #aaa; border-left: solid 1px #aaa; } main>div { position: absolute; left: 0; top: 0; width: 100%; height: 100%; transition: all 1s; z-index: 1; background: #f3f3f3; opacity: 0; display: flex; flex-direction: column; justify-content: center; align-items: center; transform: translate(0, -100%); color: white; font-size: 2em; } main>div:target { opacity: 1; transform: translate(0%, 0%); } main>div:nth-of-type(1):target { background: #3498db; } main>div:nth-of-type(2):target { background: #9b59b6; } main>div:nth-of-type(3):target { background: #16a085; } div i[class^=\"fa\"] { font-size: 100px; color: white; } houdunren.com home video live 缩放元素 比如数值为2时表示为原尺寸的两倍。 数值为.5时为原尺寸的一半。 scaleX 按X轴缩放一半。 代码示例： Document * { padding: 0; margin: 0; list-style: none; box-sizing: border-box; } body { width: 100vw; height: 100vh; display: flex; justify-content: center; align-items: center; } main { width: 400px; height: 200px; border: 1px solid #ccc; display: flex; justify-content: center; align-items: center; /* 为了设置第一个div的中心点，所以这里设置一个定位，让子元素的绝对定位参照该元素进行偏移 */ position: relative; } div:first-child { height: 8px; width: 8px; background-color: black; z-index: 1; border-radius: 50%; /* 脱离文档流并居中 */ position: absolute; left: 50%; top: 50%; margin-left: -4px; margin-top: -4px; } div:last-child { height: 100px; width: 100px; background-color: blueviolet; /* 过渡时间1s,应该放这里，而不是:hover上面 */ transition: 1s; } div:last-child:hover { transform: scaleX(.5); } scaleY 按Y轴缩放一半。 代码示例： Document * { padding: 0; margin: 0; list-style: none; box-sizing: border-box; } body { width: 100vw; height: 100vh; display: flex; justify-content: center; align-items: center; } main { width: 200px; height: 400px; border: 1px solid #ccc; display: flex; justify-content: center; align-items: center; /* 为了设置第一个div的中心点，所以这里设置一个定位，让子元素的绝对定位参照该元素进行偏移 */ position: relative; } div:first-child { height: 8px; width: 8px; background-color: black; z-index: 1; border-radius: 50%; /* 脱离文档流并居中 */ position: absolute; left: 50%; top: 50%; margin-left: -4px; margin-top: -4px; } div:last-child { height: 100px; width: 100px; background-color: blueviolet; /* 过渡时间1s,应该放这里，而不是:hover上面 */ transition: 1s; } div:last-child:hover { transform: scaleY(.5); } scale 使用 scale 可同时设置 X/Y 轴的缩放，如果只设置一个值时表示两轴缩放相同。 使用数值定义缩放，如 .5 表示缩小一半，2 表示放大两倍。 代码示例： Document * { padding: 0; margin: 0; list-style: none; box-sizing: border-box; } body { width: 100vw; height: 100vh; display: flex; justify-content: center; align-items: center; } main { width: 200px; height: 400px; border: 1px solid #ccc; display: flex; justify-content: center; align-items: center; /* 为了设置第一个div的中心点，所以这里设置一个定位，让子元素的绝对定位参照该元素进行偏移 */ position: relative; } div:first-child { height: 8px; width: 8px; background-color: black; z-index: 1; border-radius: 50%; /* 脱离文档流并居中 */ position: absolute; left: 50%; top: 50%; margin-left: -4px; margin-top: -4px; } div:last-child { height: 100px; width: 100px; background-color: blueviolet; /* 过渡时间1s,应该放这里，而不是:hover上面 */ transition: 1s; } div:last-child:hover { transform: scale(.5, 2); } scaleZ 沿Z轴缩放元素，需要有3D透视才可以查看到效果。 代码示例： Document * { padding: 0; margin: 0; list-style: none; box-sizing: border-box; } body { width: 100vw; height: 100vh; display: flex; justify-content: center; align-items: center; } main { width: 200px; height: 200px; display: flex; justify-content: center; align-items: center; border: 1px solid #ccc; /* 如果将Z轴移动的:hover放在div上，我们不方便一直将鼠标放在div上面，故我们设置成放在main上面让div进行Z轴移动 */ /* 为了更好的视觉效果，我们给main容器做一个透视 ,并且让它按照Y轴旋转60度，按Z轴放大5倍*/ transform: perspective(900px) rotateY(45deg) scaleZ(5); /* 使用 transform-style 用于控制3d透视 */ transform-style: preserve-3d; } main:hover div:nth-child(2) { /* 放大5倍 */ transform: scaleZ(5); } div { height: 100px; width: 100px; background-color: blueviolet; /* 让子元素脱离文档流并参照副父级元素偏移。这是定位+移动的居中方法 */ position: absolute; left: 50%; top: 50%; transform: translate(-50%, -50%); } div:nth-child(1) { background-color: yellow; } div:nth-child(2) { background-color: blueviolet; /* 过渡时间1s */ transition: 1s; transform: translateZ(100px); } scale3d 沿X/Y/Z三个轴缩放元素。 代码示例： Document * { padding: 0; margin: 0; list-style: none; box-sizing: border-box; } body { width: 100vw; height: 100vh; display: flex; justify-content: center; align-items: center; } main { width: 200px; height: 200px; display: flex; justify-content: center; align-items: center; border: 1px solid #ccc; /* 如果将Z轴移动的:hover放在div上，我们不方便一直将鼠标放在div上面，故我们设置成放在main上面让div进行Z轴移动 */ /* 为了更好的视觉效果，我们给main容器做一个透视 ,并且让它按照Y轴旋转60度，按Z轴放大5倍*/ transform: perspective(900px) rotateY(45deg) scaleZ(5); /* 使用 transform-style 用于控制3d透视 */ transform-style: preserve-3d; } main:hover div:nth-child(2) { /* 放大5倍 */ transform: scale3d(.5, .5, .5); } div { height: 100px; width: 100px; background-color: blueviolet; /* 让子元素脱离文档流并参照副父级元素偏移。这是定位+移动的居中方法 */ position: absolute; left: 50%; top: 50%; transform: translate(-50%, -50%); } div:nth-child(1) { background-color: yellow; } div:nth-child(2) { background-color: blueviolet; /* 过渡时间1s */ transition: 1s; transform: translateZ(100px); } 菜单缩放 代码示例： Document * { margin: 0; padding: 0; list-style: none; box-sizing: border-box; text-decoration: none; } body { height: 100vh; width: 100vw; display: flex; flex-flow: column; justify-content: center; align-items: center; } main { width: 100px; } div i { display: inline-block; background: darkgray; font-size: 30px !important; display: flex; justify-content: center; align-items: center; } ul { display: flex; flex-flow: column; justify-content: center; align-items: center; border: 1px solid #ddd; text-transform: uppercase; /* 基点设置为左上 */ transform-origin: left top; /* 鼠标放上去有个小手 */ cursor: pointer; /* 透明度 */ opacity: .6; transform: scale(0); transition: 1s; } ul>* { margin: 3px; } main:hover ul { transform: scale(1); } 我的资料 我的关注 我的收藏 相册放大 代码示例： Document * { margin: 0; padding: 0; list-style: none; box-sizing: border-box; text-decoration: none; } body { height: 100vh; width: 100vw; display: flex; justify-content: center; align-items: center; background-color: deepskyblue; } img { height: 100px; /* 高斯模糊 */ filter: blur(10px); transform: scale(.6); transition: .5s; /* 鼠标小手 */ cursor: pointer; border: 3px double black; } img:hover { filter: none; transform: scale(1.3); } 旋转元素 使用CSS可以控制元素按照不同坐标轴进行旋转。 rotateX 控制元素按照X轴进行旋转操作。单位为deg，即°度的意思。 按水平轴发生旋转，如果旋转90deg 将不可见。 正数向上翻，负数向下翻。 如何让他可见呢？我们只需要将父级容器也旋转一下，并加上透视3D效果即可。 代码示例： Document * { padding: 0; margin: 0; list-style: none; box-sizing: border-box; } body { width: 100vw; height: 100vh; display: flex; justify-content: center; align-items: center; } main { width: 400px; height: 200px; border: 1px solid #ccc; display: flex; justify-content: center; align-items: center; /* 使用 transform-style 用于控制3d透视 */ transform-style: preserve-3d; /* 为了更好的视觉效果，我们给main容器做一个透视 ,并且让它按照X轴旋转-45度 */ transform: perspective(900px) rotateX(-45deg); /* 为了设置第一个div的中心点，所以这里设置一个定位，让子元素的绝对定位参照该元素进行偏移 */ position: relative; } div { height: 100px; width: 150px; background-color: blueviolet; display: flex; justify-content: center; align-items: center; color: #fff; font-size: 14px; /* 过渡时间1s,应该放这里，而不是:hover上面 */ transition: 1s; } div:hover { transform: rotateX(90deg); } 将按照X轴旋转90deg rotateY 按垂直轴发生旋转，如果旋转90deg 将不可见。 正数向右翻，负数向左翻。 代码示例： Document * { padding: 0; margin: 0; list-style: none; box-sizing: border-box; } body { width: 100vw; height: 100vh; display: flex; justify-content: center; align-items: center; } main { width: 400px; height: 200px; border: 1px solid #ccc; display: flex; justify-content: center; align-items: center; /* 为了设置第一个div的中心点，所以这里设置一个定位，让子元素的绝对定位参照该元素进行偏移 */ position: relative; } div { height: 100px; width: 150px; background-color: blueviolet; display: flex; justify-content: center; align-items: center; color: #fff; font-size: 14px; /* 过渡时间1s,应该放这里，而不是:hover上面 */ transition: 1s; } div:hover { transform: rotateY(90deg); } 将按照Y轴旋转90deg rotateZ 按Z轴旋转元素，效果就是沿X/Y轴的平面旋转。 代码示例： Document * { padding: 0; margin: 0; list-style: none; box-sizing: border-box; } body { width: 100vw; height: 100vh; display: flex; justify-content: center; align-items: center; } main { width: 400px; height: 200px; border: 1px solid #ccc; display: flex; justify-content: center; align-items: center; /* 使用 transform-style 用于控制3d透视 */ transform-style: preserve-3d; /* 为了更好的视觉效果，我们给main容器做一个透视 ,并且让它按照X轴旋转-45度 */ transform: perspective(900px) rotateX(-45deg); /* 为了设置第一个div的中心点，所以这里设置一个定位，让子元素的绝对定位参照该元素进行偏移 */ position: relative; } div { height: 100px; width: 150px; background-color: blueviolet; display: flex; justify-content: center; align-items: center; color: #fff; font-size: 14px; /* 过渡时间1s,应该放这里，而不是:hover上面 */ transition: 1s; } div:hover { transform: rotateZ(90deg); } 将按照Z轴旋转90deg rotate 在X与Y轴平面旋转，效果与使用 rotateZ 相同。 代码示例： Document * { padding: 0; margin: 0; list-style: none; box-sizing: border-box; } body { width: 100vw; height: 100vh; display: flex; justify-content: center; align-items: center; } main { width: 400px; height: 200px; border: 1px solid #ccc; display: flex; justify-content: center; align-items: center; /* 使用 transform-style 用于控制3d透视 */ transform-style: preserve-3d; /* 为了更好的视觉效果，我们给main容器做一个透视 ,并且让它按照X轴旋转-45度 */ transform: perspective(900px) rotateX(-45deg); /* 为了设置第一个div的中心点，所以这里设置一个定位，让子元素的绝对定位参照该元素进行偏移 */ position: relative; } div { height: 100px; width: 150px; background-color: blueviolet; display: flex; justify-content: center; align-items: center; color: #fff; font-size: 14px; /* 过渡时间1s,应该放这里，而不是:hover上面 */ transition: 1s; } div:hover { transform: rotate(90deg); } 将按照Z轴旋转90deg rotate3d 同时设置X/Y/Z轴的旋转向量值来控制元素的旋转。 需要同时设置如下四个参数。 这个是按照向量进行旋转的，比如第四个参数是90deg，那么前三个参数填1就代表各转90°。 rotate3d(tx,ty,tz,angle) 1）只转X/Y轴 2）只转Y/Z轴 3）X/Y/Z都转 代码示例： Document * { padding: 0; margin: 0; list-style: none; box-sizing: border-box; } body { width: 100vw; height: 100vh; display: flex; justify-content: center; align-items: center; } main { width: 400px; height: 200px; border: 1px solid #ccc; display: flex; justify-content: center; align-items: center; /* 使用 transform-style 用于控制3d透视 */ transform-style: preserve-3d; /* 为了更好的视觉效果，我们给main容器做一个透视 ,并且让它按照X轴旋转-45度 */ transform: perspective(900px) rotateX(-45deg); /* 为了设置第一个div的中心点，所以这里设置一个定位，让子元素的绝对定位参照该元素进行偏移 */ position: relative; } div { height: 100px; width: 150px; background-color: blueviolet; display: flex; justify-content: center; align-items: center; color: #fff; font-size: 14px; /* 过渡时间1s,应该放这里，而不是:hover上面 */ transition: 1s; } div:hover { /* X/Y/Z */ transform: rotate3d(1, 1, 1, 180deg); } X/Y/Z 180° 参数顺序 可以同时设置多个旋转规则，顺序不同结果也会不同。 如下，先按X轴转90，再按Y轴转60 div:hover { transform: rotateX(90deg) rotateY(60deg); } 代码示例： Document * { padding: 0; margin: 0; list-style: none; box-sizing: border-box; } body { width: 100vw; height: 100vh; display: flex; justify-content: center; align-items: center; } main { width: 400px; height: 200px; border: 1px solid #ccc; display: flex; justify-content: center; align-items: center; /* 使用 transform-style 用于控制3d透视 */ transform-style: preserve-3d; /* 为了更好的视觉效果，我们给main容器做一个透视 ,并且让它按照X轴旋转-45度 */ transform: perspective(900px) rotateX(-45deg); /* 为了设置第一个div的中心点，所以这里设置一个定位，让子元素的绝对定位参照该元素进行偏移 */ position: relative; } div { height: 100px; width: 150px; background-color: blueviolet; display: flex; justify-content: center; align-items: center; color: #fff; font-size: 14px; /* 过渡时间1s,应该放这里，而不是:hover上面 */ transition: 1s; } div:hover { transform: rotateX(90deg) rotateY(60deg); } X 90° Y 60° 旋转文字 代码示例： Document * { margin: 0; padding: 0; list-style: none; box-sizing: border-box; } body { height: 100vh; width: 100vw; display: flex; justify-content: center; align-items: center; } main { width: 100px; height: 100px; display: flex; flex-flow: column; justify-content: center; align-items: center; background-color: blueviolet; } main p { display: flex; justify-content: center; align-items: center; color: white; } main p span { width: 50%; height: 50%; padding: 5px; font-size: 1em; box-shadow: 0 2px 10px rgba(0, 0, 0, .3); border-radius: 50%; /* 过渡时间 */ transition: 1s; display: flex; justify-content: center; align-items: center; } main p span:first-of-type { color: green; background-color: yellow; } main p span:nth-of-type(2) { color: yellow; background-color: green; } main p span:nth-of-type(3) { color: white; background-color: deeppink; } main p span:last-of-type { color: red; background-color: rgb(140, 173, 155); } main:hover p span:nth-of-type(odd) { transform: rotate(360deg); } main:hover p span:nth-of-type(even) { transform: rotate(-360deg); } CSS 3 动画 电子时钟 这个层级有点多，每个刻度都是一个元素，每个刻度之间距离都是30°，然后再加上3根针就好了。 其实应该分四层，一层做事件驱动，一层做最下面的黑色背景，一层做红色下面的指针，一层做红色。 我就做了三层，所以事件驱动就只能放在\\上了。 样式有点丑，别介意... 代码示例： Document * { margin: 0; padding: 0; box-sizing: border-box; list-style: none; } body { height: 100vh; width: 100vw; display: flex; justify-content: center; align-items: center; } main { height: 400px; width: 400px; background-color: #000; border-radius: 50%; position: relative; } main div { height: 5%; width: 5%; background-color: green; border-radius: 50%; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); z-index: 3; } main ul:nth-of-type(1) { height: 80%; width: 80%; background-color: red; border-radius: 50%; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); z-index: 2; } main ul:nth-of-type(1) li { background-color: #fff; position: absolute; top: 50%; left: 50%; /* 全部按照上方开始转 */ transform-origin: top; transition: 10s; } body:hover main ul:nth-of-type(1) li:nth-child(1) { transform: rotate(360deg) } main ul:nth-of-type(1) li:nth-child(1) { /* 秒针 */ width: 5px; height: 46%; } main ul:nth-of-type(1) li:nth-child(2) { /* 分针 */ width: 5px; height: 40%; transform: rotate(10deg); } main ul:nth-of-type(1) li:nth-child(3) { /* 分针 */ width: 10px; height: 30%; transform: rotate(60deg); } main ul:nth-of-type(2) { height: 95%; width: 90%; border-radius: 50%; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); z-index: 1; } main ul:nth-of-type(2) li { width: 10px; height: 100%; background-color: #fff; position: absolute; top: 50%; left: 50%; } main ul:nth-of-type(2) li:nth-child(1) { /* 由于不会叠加，所以我们需要在每个元素中设置 */ transform: translate(-50%, -50%) rotate(0deg); } main ul:nth-of-type(2) li:nth-child(2) { transform: translate(-50%, -50%) rotate(30deg); } main ul:nth-of-type(2) li:nth-child(3) { transform: translate(-50%, -50%) rotate(60deg); } main ul:nth-of-type(2) li:nth-child(4) { transform: translate(-50%, -50%) rotate(90deg); } main ul:nth-of-type(2) li:nth-child(5) { transform: translate(-50%, -50%) rotate(120deg); } main ul:nth-of-type(2) li:nth-child(6) { transform: translate(-50%, -50%) rotate(150deg); } 倾斜元素 倾斜元素的单位也是deg，即为度数°。 skewX 按X轴倾斜60deg 代码示例： Document * { padding: 0; margin: 0; list-style: none; box-sizing: border-box; } body { width: 100vw; height: 100vh; display: flex; justify-content: center; align-items: center; } main { width: 400px; height: 200px; border: 1px solid #ccc; display: flex; justify-content: center; align-items: center; /* 为了设置第一个div的中心点，所以这里设置一个定位，让子元素的绝对定位参照该元素进行偏移 */ position: relative; } div:first-child { height: 8px; width: 8px; background-color: black; z-index: 1; border-radius: 50%; /* 脱离文档流并居中 */ position: absolute; left: 50%; top: 50%; margin-left: -4px; margin-top: -4px; } div:last-child { height: 100px; width: 100px; background-color: blueviolet; /* 过渡时间1s,应该放这里，而不是:hover上面 */ transition: 1s; } div:last-child:hover { transform: skewX(60deg); } skewY 按Y轴倾斜60deg 代码示例： Document * { padding: 0; margin: 0; list-style: none; box-sizing: border-box; } body { width: 100vw; height: 100vh; display: flex; justify-content: center; align-items: center; } main { width: 200px; height: 400px; border: 1px solid #ccc; display: flex; justify-content: center; align-items: center; /* 为了设置第一个div的中心点，所以这里设置一个定位，让子元素的绝对定位参照该元素进行偏移 */ position: relative; } div:first-child { height: 8px; width: 8px; background-color: black; z-index: 1; border-radius: 50%; /* 脱离文档流并居中 */ position: absolute; left: 50%; top: 50%; margin-left: -4px; margin-top: -4px; } div:last-child { height: 100px; width: 100px; background-color: blueviolet; /* 过渡时间1s,应该放这里，而不是:hover上面 */ transition: 1s; } div:last-child:hover { transform: skewY(60deg); } skew 同时设置X/Y轴倾斜操作，不指定第二个参数时Y轴倾斜为零。 代码示例： Document * { padding: 0; margin: 0; list-style: none; box-sizing: border-box; } body { width: 100vw; height: 100vh; display: flex; justify-content: center; align-items: center; } main { width: 400px; height: 400px; border: 1px solid #ccc; display: flex; justify-content: center; align-items: center; /* 为了设置第一个div的中心点，所以这里设置一个定位，让子元素的绝对定位参照该元素进行偏移 */ position: relative; } div:first-child { height: 8px; width: 8px; background-color: black; z-index: 1; border-radius: 50%; /* 脱离文档流并居中 */ position: absolute; left: 50%; top: 50%; margin-left: -4px; margin-top: -4px; } div:last-child { height: 100px; width: 100px; background-color: blueviolet; /* 过渡时间1s,应该放这里，而不是:hover上面 */ transition: 1s; } div:last-child:hover { transform: skew(60deg, 60deg); } 按钮特效 代码示例： Document * { padding: 0; margin: 0; list-style: none; box-sizing: border-box; } body { width: 100vw; height: 100vh; display: flex; justify-content: center; align-items: center; } div { display: flex; justify-content: center; align-items: center; padding: 10px 50px; border: 5px double #ddd; box-shadow: 0 3px 8px rgba(0, 0, 0, .3); background: #fa7d09; color: #fff; cursor: pointer; position: relative; overflow: hidden; z-index: 0; } div::before { content: \"\"; background: #679b9b; height: 100%; position: absolute; /* 必须设置宽度，倾斜才会生效 */ width: 0; align-self: center; transform: skewX(-45deg); transition: all .8s; z-index: -1; } div:hover::before { width: 200%; } 按钮 立体按钮 代码示例： Document * { padding: 0; margin: 0; list-style: none; box-sizing: border-box; text-decoration: none; } body { width: 100vw; height: 100vh; display: flex; justify-content: center; align-items: center; } a { width: 100px; height: 30px; font-size: 12px; background: #900d0d; color: white; text-align: center; line-height: 30px; position: relative; transform: skew(25deg, 0) rotate(-15deg); } a::after { content: \"\"; background: #900d0d; height: 100%; width: 10px; position: absolute; left: -10px; transform: skew(0, -45deg) translate(0, 5px); } a::before { content: \"\"; background: #900d0d; height: 10px; width: 100%; position: absolute; bottom: -10px; left: 0; transform: skew(-45deg, 0) translate(-5px, 0); } 一砖下去可能要命 变形基点 使用 transform-origin 设置元素的X/YZ操作的基点，用于控制旋转、倾斜等操作。 可以使用百分比，也可使用英文单词进行修改。 百分比是按照变形元素的宽高进行取值。 旋转默认以元素中心进行旋转，改变基点后可控制旋转点位置 元素移动不受变形基点所影响 平面旋转 transform-origin: bottom right;将基点改在右下。 代码示例： Document * { padding: 0; margin: 0; list-style: none; box-sizing: border-box; } body { width: 100vw; height: 100vh; display: flex; justify-content: center; align-items: center; } main { width: 400px; height: 200px; border: 1px solid #ccc; display: flex; justify-content: center; align-items: center; /* 使用 transform-style 用于控制3d透视 */ transform-style: preserve-3d; /* 为了更好的视觉效果，我们给main容器做一个透视 ,并且让它按照X轴旋转-45度 */ transform: perspective(900px) rotateX(-45deg); /* 为了设置第一个div的中心点，所以这里设置一个定位，让子元素的绝对定位参照该元素进行偏移 */ position: relative; } div { height: 100px; width: 220px; background-color: blueviolet; display: flex; justify-content: center; align-items: center; color: #fff; font-size: 14px; /* 过渡时间1s,应该放这里，而不是:hover上面 */ transition: 1s; /* 修改基点 */ transform-origin: bottom right; } main:hover div { transform: rotate(90deg); } 将按照Z轴旋转90deg 基点在右下 倾斜控制 我们依然按照右下进行倾斜。 代码示例： Document * { padding: 0; margin: 0; list-style: none; box-sizing: border-box; } body { width: 100vw; height: 100vh; display: flex; justify-content: center; align-items: center; } main { width: 400px; height: 200px; border: 1px solid #ccc; display: flex; justify-content: center; align-items: center; /* 为了设置第一个div的中心点，所以这里设置一个定位，让子元素的绝对定位参照该元素进行偏移 */ position: relative; } div:first-child { height: 8px; width: 8px; background-color: black; z-index: 1; border-radius: 50%; /* 脱离文档流并居中 */ position: absolute; left: 50%; top: 50%; margin-left: -4px; margin-top: -4px; } div:last-child { height: 100px; width: 100px; background-color: blueviolet; /* 过渡时间1s,应该放这里，而不是:hover上面 */ transition: 1s; /* 基点改在右下 */ transform-origin: bottom right; } div:last-child:hover { transform: skewX(60deg); } 三维旋转 三维旋转需要新增Y轴的基点，还是老规矩，Y轴的基点不能使用百分比。 代码示例： Document * { padding: 0; margin: 0; list-style: none; box-sizing: border-box; } body { width: 100vw; height: 100vh; display: flex; justify-content: center; align-items: center; } main { width: 400px; height: 200px; border: 1px solid #ccc; display: flex; justify-content: center; align-items: center; /* 使用 transform-style 用于控制3d透视 */ transform-style: preserve-3d; /* 为了更好的视觉效果，我们给main容器做一个透视 ,并且让它按照X轴旋转-45度 */ transform: perspective(900px) rotateX(-45deg); /* 为了设置第一个div的中心点，所以这里设置一个定位，让子元素的绝对定位参照该元素进行偏移 */ position: relative; } div { height: 100px; width: 210px; background-color: blueviolet; display: flex; justify-content: center; align-items: center; color: #fff; font-size: 14px; /* 过渡时间2s,应该放这里，而不是:hover上面 */ transition: 2s; /* 基点 */ transform-origin: right center 100px; } main:hover div { /* X/Y/Z */ transform: rotate3d(1, 1, 1, 720deg); } X right/Y center/Z 100px 720° 新年贺卡 使用变形基点，然后加上旋转元素即可。 代码示例： Document * { padding: 0; margin: 0; list-style: none; box-sizing: border-box; } body { width: 100vw; height: 100vh; display: flex; justify-content: center; align-items: center; } div { width: 200px; height: 150px; background: #fa7d09; display: flex; justify-content: center; align-items: center; color: #fff; font-size: 25px; position: relative; transform-style: preserve-3d; transform: perspective(600px) rotateX(35deg) rotateY(15deg); } div:after { content: \"新年\"; height: 100%; width: 50%; position: absolute; background-color: #fa1616; left: 0; transition: 1s; transform-origin: center left; display: flex; justify-content: flex-end; align-items: center; } div:before { content: \"快乐\"; height: 100%; width: 50%; position: absolute; background-color: #fa1616; right: 0; transition: 1s; transform-origin: center right; display: flex; justify-content: flex-start; align-items: center; } div:hover::before { transform: rotateY(180deg); } div:hover::after { transform: rotateY(-180deg); } 祝你年年有余 动感菜单 这个应该是最难的一个了，那么首先我们要有一个大圆。 鼠标放上去之后所有的小圆跟随大圆的中心点旋转转出来，然后小圆也进行旋转，围绕自身的中心点。 代码示例： Document * { padding: 0; margin: 0; list-style: none; } body { display: flex; justify-content: center; align-items: center; width: 100vw; height: 100vh; } nav { width: 400px; height: 400px; display: flex; justify-content: center; align-items: center; cursor: pointer; } nav::before { content: \"\"; background: #e74c3c; border-radius: 50%; width: 200px; height: 200px; position: absolute; box-shadow: 3px 3px 0px #34495e; } nav::after { content: \"点我\"; background: #e74c3c; border-radius: 50%; width: 200px; height: 200px; display: flex; justify-content: center; align-items: center; position: absolute; font-size: 3em; color: #fff; } nav:hover ul { transform: scale(1); } ul { transition: .5s; transform: scale(0); width: 300px; height: 300px; border-radius: 50%; } ul li { width: 80px; height: 80px; background: #e49; border-radius: 50%; position: absolute; display: flex; justify-content: center; align-items: center; font-size: 2em; color: #fff; transition: 1s; transform-origin: 150px 150px; } ul li span { display: flex; justify-content: center; align-items: center; transition: 1s; } ul li span i { font-size: 1.6em !important; } nav:hover li:nth-of-type(1) { transform: rotate(60deg); } nav:hover li:nth-of-type(2) { transform: rotate(120deg); } nav:hover li:nth-of-type(3) { transform: rotate(180deg); } nav:hover li:nth-of-type(4) { transform: rotate(240deg); } nav:hover li:nth-of-type(5) { transform: rotate(300deg); } nav:hover li:nth-of-type(6) { transform: rotate(360deg); } /* 解决小图标倾斜 */ nav:hover li:nth-of-type(1) span { transform: rotate(300deg); } nav:hover li:nth-of-type(2) span { transform: rotate(600deg); } nav:hover li:nth-of-type(3) span { transform: rotate(900deg); } nav:hover li:nth-of-type(4) span { transform: rotate(1200deg); } nav:hover li:nth-of-type(5) span { transform: rotate(1500deg); } nav:hover li:nth-of-type(6) span { transform: rotate(1800deg); } 透视景深 perspective 使用 perspective 来控制元素的透视景深 perspective 规则为舞台元素控制景深， perspective 属性为控制单个元素 舞台透视 perspective 规则用于将父级整个做为透视元素，会造成里面的每个子元素的透视是不一样的。就像现实中摆一排杯子，是使用统一透视的，每个杯子的透视不一样，造成有大有小。 代码示例： Document * { padding: 0; margin: 0; list-style: none; } body { display: flex; justify-content: center; align-items: center; width: 100vw; height: 100vh; } main { width: 400px; height: 200px; /* 给整个台子做透视 */ perspective: 200px; position: relative; border: solid 5px silver; display: flex; justify-content: center; align-items: center; } main div { width: 50%; height: 50%; background-color: blueviolet; display: flex; justify-content: center; align-items: center; color: #fff; margin: 20px; transform: rotateY(60deg); } 车1 车2 单独透视 perspective 函数用于为元素设置单独透视，下面是为元素单独设置透视参数，每个元素的透视效果是一样的。 代码示例： Document * { padding: 0; margin: 0; list-style: none; } body { display: flex; justify-content: center; align-items: center; width: 100vw; height: 100vh; } main { width: 400px; height: 200px; position: relative; border: solid 5px silver; display: flex; justify-content: center; align-items: center; } main div { width: 50%; height: 50%; background-color: blueviolet; display: flex; justify-content: center; align-items: center; color: #fff; margin: 20px; /* 给每个车做透视，现在每辆车都以相同的角度对着你 */ transform: perspective(100px) rotateY(60deg); } 车1 车2 立方体 代码示例： Document * { padding: 0; margin: 0; box-sizing: border-box; list-style: none; } body { background: #34495e; } main { position: absolute; left: 50%; top: 50%; width: 200px; height: 200px; transform-style: preserve-3d; transform-origin: 50% 50% 50px; transform: translate(-50%, -50%) rotateY(0deg); transition: 2s; } main:hover { transform: translate(-50%, -50%) rotate3d(1, 1, 0, 180deg); } div { position: absolute; width: 200px; height: 200px; background: #000; display: flex; justify-content: center; align-items: center; font-size: 4em; } div:nth-child(1) { transform-origin: right; background: #1abc9c; transform-origin: bottom; transform: translateY(-200px) rotateX(-90deg); opacity: .8; } div:nth-child(2) { transform-origin: right; background: #27ae60; transform-origin: top; transform: translateY(200px) rotateX(90deg); opacity: .8; } div:nth-child(3) { transform-origin: bottom; background: #e67e22; transform-origin: right; transform: translateX(-200px) rotateY(90deg); opacity: .8; } div:nth-child(4) { transform-origin: top; background: #8e44ad; transform-origin: left; transform: translateX(200px) rotateY(-90deg); opacity: .8; } div:nth-child(5) { transform-origin: left bottom; background: #ecf0f1; opacity: .8; } div:nth-child(6) { transform-origin: left bottom; background: #ecf0f1; opacity: .5; transform: translateZ(200px); } 1 2 3 4 5 6 3D透视 transform-style 使用 transform-style 用于控制3d透视。 应用于舞台即变形元素的父级元素 设置 overflow:visible 时 preserve-3d 才无效 选项 描述 flat 2D平面舞台 preserve-3d 3D透视舞台 三维图集 代码示例： Document body { background: #34495e; } main { position: absolute; width: 400px; height: 200px; left: 50%; top: 50%; transform-style: preserve-3d; transform-origin: center center -300px; transform: translate(-50%, -50%) rotateX(-45deg); transition: 2s; } body:hover main { transform: translate(-50%, -50%) rotateX(-45deg) rotateY(900deg); } div { position: absolute; width: 100%; height: 100%; transform-origin: center center -300px; overflow: hidden; background: content-box; padding: 10px; opacity: .5; } div:nth-child(1) { background-color: #ade498; transform: rotateY(60deg); } div:nth-child(2) { background-color: #d3de32; transform: rotateY(120deg); } div:nth-child(3) { background-color: #ffffdd; transform: rotateY(180deg); } div:nth-child(4) { background-color: #006a71; transform: rotateY(240deg); } div:nth-child(5) { background-color: #fe91ca; transform: rotateY(300deg); } div:nth-child(6) { background-color: #cffe0f; transform: rotateY(360deg); } 观看视角 perspective-origin perspective-origin用于控制视线的落点，就像我们眼睛看物体时的聚焦点。可以理解眼镜看物体的位置，比如看一台汽车，是在看车头左边看还是车头右边看。 需要设置 perspective 透视后才可以看到效果。 一般设置在舞台元素上来控制子元素 取值 说明 x-axis 定义该视图在 x 轴上的位置。默认值：50%。可能的值：left、center、right、length、% y-axis 定义该视图在 y 轴上的位置。默认值：50%。可能的值：top、center、bottom、length、% 隐藏背面 backface-visibility 使用 backface-visibility 用于控制是否可以看到元素的背面。 一般设置在元素上而不是舞台元素上 需要舞台元素（父级元素）设置 transform-style: preserve-3d 选项 说明 visible 背面可见 hidden 背面隐藏 翻转卡片 下面使用隐藏背面与透视技术制作的翻转卡片效果。 代码示例： Document * { padding: 0; margin: 0; box-sizing: border-box; } main { position: absolute; width: 100vw; height: 100vh; transition: 2s; transform-style: preserve-3d; } main.login { transform: perspective(900px) rotateY(0deg); } main.register { transform: perspective(900px) rotateY(180deg); } div { position: absolute; width: 100%; height: 100%; font-size: 5em; display: flex; flex-direction: column; justify-content: center; align-items: center; backface-visibility: hidden; transition: 2s; text-transform: uppercase; color: white; } div span { text-transform: lowercase; letter-spacing: .2em; font-size: .2em; color: #2c3e50; } div:nth-child(1) { background: #2ecc71; transform: rotateY(0deg); } div:nth-child(2) { background: #e74c3c; transform: rotateY(180deg); } nav { position: absolute; width: 100%; height: 100%; z-index: 99; text-align: center; display: flex; align-items: flex-end; justify-content: center; padding-bottom: 30px; } nav a { padding: 10px; text-decoration: none; font-size: 1em; background: #000; color: white; margin-right: 10px; cursor: pointer; left: 0; top: 0; } login houdunren.com register houdunren.com 登录 注册 function change(t) { switch (t) { case 'login': $(\"main\").removeClass().addClass('login'); break; case 'register': $(\"main\").removeClass().addClass('register'); break; } } Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-07-20 08:19:08 "},"前端专栏/CSS/过渡时间.html":{"url":"前端专栏/CSS/过渡时间.html","title":"过渡时间","keywords":"","body":"过渡时间 基础知识 在了解CSS过渡时间之前，你应该先了解一下CSS的变形动画，可以参考之前的一篇博客。 我们的元素在属性发生变化时，如果没有特地的为它设置过渡时间，整个变化过程其实是以毫秒级别进行的，过程非常快，肉眼不易察觉。 故我们要学习CSS过渡时间，来让它的变化过程更加平滑。 动画属性 不是所有css属性都有过渡效果，查看支持动画的CSS属性 ，一般来讲有中间值的属性都可以设置动画如宽度、透明度等。 可以看一下下面这个例子，比如边框的样式就不支持过渡效果，而其他的诸如背景颜色，高度宽度等等都是支持过渡效果的。 可以看到，在鼠标放上去的瞬间，边框的样式就发生变化了，而不是再跟随过渡时间进行渐变。 而其他的属性，诸如背景颜色，圆角等都是跟随过渡时间进行渐变的。 代码示例： Document * { margin: 0; padding: 0; } body { display: flex; justify-content: center; align-items: center; height: 100vh; width: 100vw; } div { height: 50px; width: 50px; background: #747d8c; border: 10px solid #ff6348; /* 添加过渡时间 1s */ transition: 1s; } body:hover div { background: #5352ed; border: 10px dotted #ffa502; width: 100px; height: 100px; border-radius: 50%; transform: translate(100px, 100px); } 元素状态 初始形态 指当页面加载后的样式状态，下面是表单设置的初始样式。 变化形态 指元素由初始状态变化后的状态，比如鼠标放上、表单获得焦点后的形态。 代码示例： Document * { padding: 0; margin: 0; } body { background: #2c3e50; display: flex; flex-direction: column; justify-content: center; align-items: center; box-sizing: border-box; width: 100vw; height: 100vh; • padding: 20px; } input { border: solid 5px #e67e22; height: 60px; width: 400px; margin-bottom: 20px; transition: 2s; } input:hover { border: solid 5px #000 !important; } input:focus { background: #e67e22; } input:checked { position: relative; width: 60px; height: 60; border: none; } input:checked::before { content: '⩗'; color: white; display: flex; justify-content: center; align-items: center; font-size: 3em; position: absolute; left: 0; top: 0; right: 0; bottom: 0; box-sizing: border-box; background: #3498db; } 过渡效果 transition-property 用于设置哪些属性应用过渡效果。 默认值为all即所有属性都发生过渡效果 多个属性使用逗号分隔 当我们使用该选项时，注意要和transition-duration搭配使用才能生效，这个才是非简写的过渡时间。 transition只是一种简写形式，如果使用transition-duration与transition进行搭配使用，则不会生效transition-duration。 属性设置 注意看，下面的这张图片里transition-duration只设置了圆角与透明度，其他的诸如宽度高度背景颜色等均未设置，所以在鼠标放上去的一瞬间未设置的属性立刻产生了变化，而圆角和透明度是随着过渡时间渐渐变化的。 代码示例： Document * { margin: 0; padding: 0; box-sizing: border-box; } body { display: flex; justify-content: center; align-items: center; width: 100vw; height: 100vh; } main { width: 400px; height: 400px; display: flex; justify-content: center; align-items: center; } div { width: 100px; height: 100px; background: #f39c12; transition-property: border-radius, opacity; /* 这个才是真正的设置过渡时间， transition只是简写形式 */ transition-duration: 1s; opacity: .5; } main:hover div { border-radius: 50%; width: 150px; height: 150px; background: #2ecc71; opacity: 1; } 禁用属性 当设置transition-property:none;后，所有的变化形态均不会跟随过渡时间发生变化。 也就是说全部都是瞬发完成。 代码示例： Document * { margin: 0; padding: 0; box-sizing: border-box; } body { display: flex; justify-content: center; align-items: center; width: 100vw; height: 100vh; } main { width: 400px; height: 400px; display: flex; justify-content: center; align-items: center; } div { width: 100px; height: 100px; background: #f39c12; transition-property: none; /* 这个才是真正的设置过渡时间， transition只是简写形式 */ transition-duration: 1s; opacity: .5; } main:hover div { border-radius: 50%; width: 150px; height: 150px; background: #2ecc71; opacity: 1; } 结束事件 transitionend 用于控制过渡结束后执行的JS事件，简写属性会触发多次如 border-radius 会触发四次事件，不难理解因为可以为border-bottom-left-radius 等四个属性独立设置过渡，所以就会有四次事件。 属性 说明 propertyName 结束过渡样式 elapsedTime 过渡需要的时间 pseudoElement 过渡的伪元素 isTrusted true:用户触发，false:脚本触发 我们只需要有JS来监听该事件即可，如下图。 当我们检测的\\标签过渡时间结束后触发了transitionend事件，然后才显示出了恭候多时的字样。 　　 代码示例： Document * { margin: 0; padding: 0; box-sizing: border-box; } body { display: flex; justify-content: center; align-items: center; width: 100vw; height: 100vh; background-color: #57606f; } main { width: 400px; height: 400px; display: flex; justify-content: center; align-items: center; } div { width: 100px; height: 100px; background: #f39c12; transition-duration: 1s; position: relative; } div:after { content: \"恭候多时\"; color: #fff; width: 100%; font-size: 1.4em; display: flex; justify-content: center; align-items: center; position: absolute; bottom: -50px; transform: scale(0); transition-duration: 1s; } main:hover div { transform: rotate(360deg); } main:hover div.show-after::after { transform: scale(1) skew(360deg); } // 检测div的 transitionend 事件 document.querySelector('div').addEventListener('transitionend', function (e) { console.log(e); // 给div添加class为show-after document.querySelector('div').className = 'show-after'; }) 此时查看一下浏览器控制台，正好对应上表中的属性。 过渡时间 transition-duration 用于设置过渡时间，需要注意以下几点： 可使用单位为 ms毫秒、s秒 默认值为0s不产生过渡效果 一个值时，所有属性使用同样的时间 二个值时，奇数属性使用第一个，偶数属性使用第二个 变化属性数量大于时间数量时，后面的属性再从第一个时间开始重复使用 统一时间 让所有动画的变形在统一时间内完成： 代码示例： Document * { padding: 0; margin: 0; } body { background: #2c3e50; display: flex; flex-direction: column; justify-content: center; align-items: center; box-sizing: border-box; width: 100vw; height: 100vh; padding: 80px; } main { width: 400px; height: 400px; } div { width: 150px; height: 150px; background-color: #34495e; border-radius: 50%; opacity: 0.2; transition-property: background-color, transform, opacity, border-radius; transition-duration: 3s; } div:hover { opacity: 1; border-radius: 0; transform: scale(2) rotate(180deg); background-color: #e67e22; } 两个时间 下面共有四个属性并设置了两个时间值，1,3属性使用第一个值，2,4属性使用第二个值。 ... div { width: 150px; height: 150px; border-radius: 50%; opacity: 0.2; transition-property: background-color, transform, opacity, border-radius; transition-duration: 200ms, 5s; } ... 多个时间 下面共有四个属性并设置了三个时间值，1,2,3属性使用1,2,3时间值，第四个属性再从新使用第一个时间值。 ... div { width: 150px; height: 150px; border-radius: 50%; opacity: 0.2; transition-property: background-color, transform, opacity, border-radius; transition-duration: 200ms, 5s, 2s; } ... 不同时间 可以为初始与变化状态设置不同的时间。 下面是将hover设置为3s，当鼠标放上时变化时间为3s。 初始设置为1s即表示变化到初始状态需要1s。 代码示例： Document * { padding: 0; margin: 0; } body { background: #2c3e50; display: flex; flex-direction: column; justify-content: center; align-items: center; box-sizing: border-box; width: 100vw; height: 100vh; padding: 80px; } main { width: 400px; height: 400px; } div { width: 150px; height: 150px; background-color: #e67e22; border-radius: 50%; transition-property: background-color, transform, opacity, border-radius; /* 结束时间，变回初始状态 如果只有该时间，则过渡时间也采用它 */ transition-duration: 1s; } div:hover { border-radius: 0; transform: scale(2) rotate(180deg); background-color: #e67e22; /* 过渡时间 */ transition-duration: 3s; } 过渡速率 transition-timing-function 用于设置整体过渡效果的速度，可在 https://cubic-bezier.com 网站在线体验效果差异。 默认参数 以下是常见的transition-timing-function过渡效果： 值 描述 linear 规定以相同速度开始至结束的过渡效果（等于 cubic-bezier(0,0,1,1)） ease 开始慢，然后快，慢下来，结束时非常慢（cubic-bezier(0.25,0.1,0.25,1)）。默认值 ease-in 开始慢，结束快（等于 cubic-bezier(0.42,0,1,1)） ease-out 开始快，结束慢（等于 cubic-bezier(0,0,0.58,1)） ease-in-out 中间快，两边慢（等于 cubic-bezier(0.42,0,0.58,1)） cubic-bezier(n,n,n,n) 在 cubic-bezier 函数中定义自己的值 差异对比 我们用linear和ease来做一个对比，左边是linear，右边是ease。 其实他们的过渡时间都是一模一样的，只是视觉上有所差异。 代码示例： Document * { margin: 0; padding: 0; box-sizing: border-box; } body { height: 100vh; width: 100vw; display: flex; justify-content: center; align-items: center; } main { height: 400px; width: 400px; display: flex; justify-content: center; align-items: center; border: 1px solid #ddd; } main div { height: 100px; width: 100px; margin: 20px; transition-duration: 3s; } main div:nth-child(1) { background-color: #ff4757; transition-timing-function: linear; } main div:nth-child(2) { background-color: #3742fa; transition-timing-function: ease; } main:hover div { width: 150px; height: 150px; border-radius: 50%; } 贝塞尔曲线 其实不管是linear或者是ease都是由贝塞尔曲线来完成的。 我们需要设置四个值 cubic-bezier(\\, \\, \\, \\)来控制曲线速度，可在 https://cubic-bezier.com 网站在线体验效果。 　　如以下是我自己调的一个数值，右边的那个，对比的是linear。 代码示例： Document * { margin: 0; padding: 0; box-sizing: border-box; } body { height: 100vh; width: 100vw; display: flex; justify-content: center; align-items: center; } main { height: 400px; width: 400px; display: flex; justify-content: center; align-items: center; border: 1px solid #ddd; } main div { height: 100px; width: 100px; margin: 20px; transition-duration: 3s; } main div:nth-child(1) { background-color: #ff4757; transition-timing-function: linear; } main div:nth-child(2) { background-color: #3742fa; transition-timing-function: cubic-bezier(.17, .67, .88, -0.47); } main:hover div { width: 150px; height: 150px; border-radius: 50%; } 步进速度 过渡使用阶梯化呈现，有点像现实生活中的机械舞，下面是把过渡分3步完成。 选项 说明 steps(n, start) 设置n个时间点，第一时间点变化状态 steps(n, end) 设置n个时间点，第一时间点初始状态 step-start 等于steps(1,start)，可以理解为从下一步开始 step-end 等于steps(1,end)，可以理解为从当前步开始 start总是先走，end总是后走。 代码示例： Document * { margin: 0; padding: 0; box-sizing: border-box; } body { height: 100vh; width: 100vw; display: flex; justify-content: center; align-items: center; } main { height: 400px; width: 800px; display: flex; border: 1px solid #ddd; position: relative; } main div { width: 200px; height: 100%; border: 1px solid #ddd; } main::after { content: \"START\"; height: 30%; width: 25%; background: #ff4757; color: #fff; font-size: 2em; /* 过渡时间2s */ transition: 2s; /* 相当于把2s分成三步走 */ transition-timing-function: steps(3, start); position: absolute; top: 0; display: flex; justify-content: center; align-items: center; } main::before { content: \"END\"; height: 30%; width: 25%; background: #70a1ff; color: #fff; font-size: 2em; /* 过渡时间2s */ transition: 2s; /* 相当于把2s分成三步走 */ transition-timing-function: steps(3, end); position: absolute; bottom: 0; display: flex; justify-content: center; align-items: center; } main:hover::before { transform: translateX(600px); } main:hover::after { transform: translateX(600px); } 时钟效果 其实步进这样一帧一帧的来走非常时候做时钟，那么这里就做一个非常简陋的时钟吧。 代码示例： Document * { margin: 0; padding: 0; box-sizing: border-box; } body { height: 100vh; width: 100vw; display: flex; justify-content: center; align-items: center; } main { height: 400px; width: 400px; display: flex; position: relative; background: #ffa502; box-shadow: 3px 3px 3px #2f3542; border-radius: 50%; } main::after { content: \"\"; height: 20px; width: 20px; border-radius: 50%; position: absolute; left: 50%; top: 50%; transform: translate(-50%, -50%); background: #1e90ff; } main::before { content: \"\"; height: 48%; width: 6px; position: absolute; left: 50%; bottom: 50%; transform: translate(-50%, 0); background: #1e90ff; transition-duration: 60s; transition-timing-function: steps(60, start); transform-origin: bottom; } main:hover::before { transform: translateX(-50%) rotate(360deg); } 延迟过渡 transition-delay 用于设置延迟过渡的时间。 默认为0s即立刻开始过渡 值可以为负数 变化属性数量大于时间数量时，后面的属性再从第一个时间开始重复使用 基本使用 下面设置了延迟时间为1s，当鼠标放上时产生变化。 代码示例： Document * { padding: 0; margin: 0; } body { background: #2c3e50; display: flex; flex-direction: column; justify-content: center; align-items: center; box-sizing: border-box; width: 100vw; height: 100vh; padding: 80px; } main { width: 400px; height: 400px; } div { width: 150px; height: 150px; background-color: #e67e22; border-radius: 50%; transition-property: background-color, transform, opacity, border-radius; transition-duration: 1s; transition-delay: 1s; } div:hover { border-radius: 0; transform: scale(2) rotate(180deg); background-color: #e67e22; } 多值延迟 可以设置不同属性的延迟时间。 代码示例： Document * { padding: 0; margin: 0; } body { background: #2c3e50; display: flex; flex-direction: column; justify-content: center; align-items: center; box-sizing: border-box; width: 100vw; height: 100vh; padding: 80px; } main { width: 400px; height: 400px; } div { width: 150px; height: 150px; background-color: #fff; /* 一一对应 */ transition-property: background-color, transform, border-radius; transition-duration: 1s, 2s, 3s; transition-delay: 1s, 3s, 5s; } div:hover { border-radius: 50%; transform: scale(2) rotate(180deg); background-color: #e67e22; } 使用负值 下例圆角属性的过渡时间为4s，设置延迟为 -4s，表示鼠标放上时直接显示在4s上的效果。如果设置为-2s显示圆角变形一半的效果。 即对圆角来说不产生过渡，是瞬发的。 代码示例： Document * { padding: 0; margin: 0; } body { background: #2c3e50; display: flex; flex-direction: column; justify-content: center; align-items: center; box-sizing: border-box; width: 100vw; height: 100vh; padding: 80px; } main { width: 400px; height: 400px; } div { width: 150px; height: 150px; background-color: #fff; transition-property: background-color, transform, border-radius; transition-duration: 1s, 2s, 4s; transition-delay: 1s, 2s, -4s; } div:hover { border-radius: 50%; transform: scale(2) rotate(180deg); background-color: #e67e22; } 组合定义 transition 可以使用transition 指令将过渡规则统一设置，需要注意以下几点。 必须设置过渡时间 延迟时间放在逗号或结束前 如果只设置一个数值，那么该数值会认为是过渡时间 transition: border-radius linear 2s 0s, background 2s 2s, width linear 2s 4s, height linear 2s 4s; /* 参与过渡的动画 贝塞尔曲线 过渡时间 延迟时间 */ 点赞案例 代码示例： Document body { width: 100vw; height: 100vh; display: flex; justify-content: center; align-items: center; background: #ecf0f1; } div { position: relative; width: 100px; height: 100px; cursor: pointer; display: flex; justify-content: center; align-items: center; } div i.fa { font-size: 100px; position: absolute; transition: all .5s; color: #ddd; } div.heart i.fa { font-size: 400px; color: #e74c3c; opacity: 0; } div.heart i.fa:nth-child(2) { font-size: 80px; color: #e74c3c; opacity: 1; } function heart() { $(\"div\").toggleClass('heart'); } Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-07-19 22:23:18 "},"前端专栏/CSS/帧动画.html":{"url":"前端专栏/CSS/帧动画.html","title":"帧动画","keywords":"","body":"基础知识 通过定义一段动画中的关键点、关键状态来创建动画。@Keyframes相比transition对动画过程和细节有更强的控制。 过渡动画是两个状态间的变化，帧动画可以处理动画过程中不同时间的细节变化， 对过渡动画理解后再学习习帧动画会非常容易，也可以把帧动画理解为多个帧之间的过渡动画。 关键帧 使用@keyframes 规则配置动画中的各个帧 from 表示起始点 to表示终点 可以使用百分数如 20% 代表动画运行到20%处 基本使用 下面使用 @keyframes 定义了动画叫 radius 并配置了两个帧动作from/to ，然后在main:hover div中使用animation-name 引用了动画并使用animation-duration声明执行三秒。 注意：动画命名不要使用CSS关键字如 none 可以看到上面的动画是从30%的圆角过渡到了50%的圆角，但是整个动画的结束是瞬间结束，并不完美。 不要着急，下面会介绍各种方法让你的帧动画随心所欲。 代码示例： Document * { margin: 0; padding: 0; list-style: none; box-sizing: border-box; } body { height: 100vh; width: 100vw; display: flex; justify-content: center; align-items: center; } main { height: 200px; width: 200px; display: flex; justify-content: center; align-items: center; border: 1px solid #ddd; } div { height: 100px; width: 100px; background: #5352ed; } main:hover div { /* 一组帧的名字 */ animation-name: radius; /* 动画时长 */ animation-duration: 3s; } @keyframes radius { from { border-radius: 30%; } to { border-radius: 50%; } } 时间点 帧动画需要定义在不同时间执行的动作，开始与结束可以使用 form/to 或 0%/100% 声明。 必须添加百分号，25%是正确写法 时间点没有顺序要求，即100%写在25%前也可以 未设置0%与100% 时将使用元素原始状态 你可以这么理解，目前所学的一组帧动画它的运行应该是这样的 初始状态 ---> 0% 或者 from ---> 100% 或者 to ---> 初始状态 　所以现在看上面的动画，就知道为什么看起来比较生硬了。 物体移动 下面定义不同时间点来让物体元素移动一圈，下例中可以不设置from/to 系统将定义为元素初始状态。 代码示例： Document * { margin: 0; padding: 0; list-style: none; box-sizing: border-box; } body { height: 100vh; width: 100vw; display: flex; justify-content: center; align-items: center; } main { height: 400px; width: 400px; display: flex; justify-content: flex-start; align-items: flex-start; border: 1px solid #ddd; } div { height: 100px; width: 100px; background: #5352ed; } main:hover div { /* 一组帧的名字 */ animation-name: move; /* 动画时长 */ animation-duration: 3s; } @keyframes move { /* 初始状态 ---> 帧 ---> 初始状态 */ 25% { transform: translate(300px, 0); } 50% { transform: translate(300px, 300px); } 75% { transform: translate(0, 300px); } } 同时声明 时间点可以动画样式一样时可以一起声明，下面将25%/75%背景一起声明。 代码示例： Document * { margin: 0; padding: 0; list-style: none; box-sizing: border-box; } body { height: 100vh; width: 100vw; display: flex; justify-content: center; align-items: center; } main { height: 400px; width: 400px; display: flex; justify-content: flex-start; align-items: flex-start; border: 1px solid #ddd; } div { height: 100px; width: 100px; background: #5352ed; } main:hover div { /* 一组帧的名字 */ animation-name: move; /* 动画时长 */ animation-duration: 3s; } @keyframes move { /* 初始状态 ---> 帧 ---> 初始状态 */ 25% { transform: translate(300px, 0); } 50% { transform: translate(300px, 300px); } 75% { transform: translate(0, 300px); } 25%, 75% { background: #ff4757; } 50%, 100% { background: #5352ed; } } 使用动画 使用animation-name 规则可以在元素身上同时使用多个动画。 使用多个动画时用逗号分隔多个 动画有相同属性时，后面动画的属性优先使用 基本使用 代码示例： Document * { margin: 0; padding: 0; list-style: none; box-sizing: border-box; } body { height: 100vh; width: 100vw; display: flex; justify-content: center; align-items: center; } main { height: 400px; width: 400px; display: flex; justify-content: flex-start; align-items: flex-start; border: 1px solid #ddd; } div { height: 100px; width: 100px; background: #5352ed; } main:hover div { /* 一组帧的名字 可以使用多组帧*/ animation-name: move, radius; /* 动画时长 */ animation-duration: 3s; } @keyframes move { /* 初始状态 ---> 帧 ---> 初始状态 */ 25% { transform: translate(300px, 0); } 50% { transform: translate(300px, 300px); } 75% { transform: translate(0, 300px); } /* 相同设置，前者不生效 */ 25%, 75% { background: #ff4757; } 50%, 100% { background: #5352ed; } } @keyframes radius { 25% { border-radius: 50%; } 50% { border-radius: 30%; } 75% { border-radius: 50%; } /* 相同设置后者覆盖前者，所以移动时的颜色会变为下面两种 */ 25%, 75% { background: #ffa502; } 50%, 100% { background: #2ed573; } } 动画时间 使用 animation-duration 可以声明动画播放的时间，即把所有帧执行一遍所需要的时间。 可以使用m秒，ms毫秒时间单位 可为不同动画单独设置执行时间 如果动画数量大于时间数量，将重新从时间列表中计算 。 如一个动画有Move,Radius,Background 而时间是1s,2s，那么Move的时间是1s，Radius的时间是2s，Background的时间从头开始数，又是1s. 效果体验 如下图的过渡时间，圆角是六秒完成，背景色是四秒完成，移动是两秒完成，但是他们的开始时间都是一样的。 代码示例： Document * { margin: 0; padding: 0; list-style: none; box-sizing: border-box; } body { height: 100vh; width: 100vw; display: flex; justify-content: center; align-items: center; } main { height: 400px; width: 400px; display: flex; justify-content: center; align-items: flex-start; border: 1px solid #ddd; } div { height: 100px; width: 100px; background: #5352ed; } main:hover div { /* 一组帧的名字 可以使用多组帧*/ animation-name: radius, background, move; /* 动画时长 圆角是六秒完成，背景色是四秒完成，移动是两秒完成，但是他们的开始时间都是一样的 */ animation-duration: 6s, 4s, 2s; /* 将动画停留在最后一帧 */ animation-fill-mode: forwards; } @keyframes radius { to { border-radius: 50%; } } @keyframes background { to {} } @keyframes move { to { transform: translate(0, 150px); } } 动画属性 不是所有css属性都有过渡效果，查看支持动画的CSS属性 ，一般来讲有中间值的属性都可以设置动画如宽度、透明度等。 如何理解中间值？ 比如，一个元素的宽度从100px变为200px，那么它们之间就有中间值。 而一个元素的边框样式从实心线变为虚心线，他们就没有中间值。 效果体验 看下面这张图，从实心线变为虚心线是瞬间变化，而背景颜色的改变却是跟着动画时间来进行渐变的。 代码示例： Document * { margin: 0; padding: 0; list-style: none; box-sizing: border-box; } body { height: 100vh; width: 100vw; display: flex; justify-content: center; align-items: center; } main { height: 400px; width: 400px; display: flex; justify-content: center; align-items: flex-start; border: 1px solid #ddd; } div { height: 100px; width: 100px; background: #5352ed; } main:hover div { /* 一组帧的名字 可以使用多组帧*/ animation-name: radius, background, move; /* 动画时长 圆角是六秒完成，背景色是四秒完成，移动是两秒完成，但是他们的开始时间都是一样的 */ animation-duration: 6s, 4s, 2s; /* 将动画停留在最后一帧 */ animation-fill-mode: forwards; } @keyframes radius { to { border-radius: 50%; } } @keyframes background { to {} } @keyframes move { to { transform: translate(0, 150px); } } 中间值 可以看下下面这个例子，左边的块from与to设置的尺寸单位没有中间值，所以是瞬间变大。 而右边块的from与to设置的尺寸单位是具有中间值的，所以是跟随动画时间进行渐变。 代码示例： Document * { margin: 0; padding: 0; list-style: none; box-sizing: border-box; } body { height: 100vh; width: 100vw; display: flex; justify-content: center; align-items: center; } main { height: 400px; width: 400px; display: flex; justify-content: space-evenly; align-items: center; border: 1px solid #ddd; } main div:nth-child(1) { background: #5352ed; } main div:nth-child(2) { background: #ff4757; } main:hover div:nth-child(1) { /* 一组帧的名字 可以使用多组帧*/ animation-name: size-percentage; /* 动画时长 */ animation-duration: 2s; /* 将动画停留在最后一帧 */ animation-fill-mode: forwards; } main:hover div:nth-child(2) { /* 一组帧的名字 可以使用多组帧*/ animation-name: size-px; /* 动画时长 */ animation-duration: 2s; /* 将动画停留在最后一帧 */ animation-fill-mode: forwards; } @keyframes size-percentage { from { width: 200px; height: 200px; } /* px 与 % 之间没有中间值，所以是瞬间出现 */ to { width: 50%; height: 50%; } } @keyframes size-px { from { width: 100px; height: 100px; } /* 有中间值，跟随动画时间进行渐变 */ to { width: 200px; height: 200px; } } 重复动画 使用animation-iteration-count 规则设置动画重复执行次数，可以给一个数字。当设置值为 infinite 表示无限循环执行。 可同时设置元素的多个动画重复，使用逗号分隔 如果动画数量大于重复数量定义，后面的动画将重新计算重复 效果体验 如下面这个案例，移动的次数是一次，而变化圆角是无限次。 代码示例： Document * { margin: 0; padding: 0; list-style: none; box-sizing: border-box; } body { height: 100vh; width: 100vw; display: flex; justify-content: center; align-items: center; } main { height: 400px; width: 400px; display: flex; justify-content: flex-start; align-items: flex-start; border: 1px solid #ddd; } div { height: 100px; width: 100px; background: #5352ed; } main:hover div { /* 一组帧的名字 可以使用多组帧*/ animation-name: move, radius; /* 动画时长 */ animation-duration: 3s; /* 代表移动只走一遍，随后就不断的圆角变化，进入死循环 */ animation-iteration-count: 1, infinite; } @keyframes move { /* 初始状态 ---> 帧 ---> 初始状态 */ 25% { transform: translate(300px, 0); } 50% { transform: translate(300px, 300px); } 75% { transform: translate(0, 300px); } /* 相同设置，前者不生效 */ 25%, 75% { background: #ff4757; } 50%, 100% { background: #5352ed; } } @keyframes radius { 25% { border-radius: 50%; } 50% { border-radius: 30%; } 75% { border-radius: 50%; } /* 相同设置后者覆盖前者，所以移动时的颜色会变为下面两种 */ 25%, 75% { background: #ffa502; } 50%, 100% { background: #2ed573; } } 心动感觉 使用循环动画绘制心动效果。 代码示例： Document * { margin: 0; padding: 0; list-style: none; box-sizing: border-box; } body { height: 100vh; width: 100vw; display: flex; justify-content: center; align-items: center; } main { height: 400px; width: 400px; display: flex; justify-content: center; align-items: center; border: 1px solid #ddd; } main i.iconfont { font-size: 100px; color: red; } main:hover i { /* 添加一组帧动画 */ animation-name: xin; /* 时间 */ animation-duration: .5s; /* 循环次数 死循环 */ animation-iteration-count: infinite; } @keyframes xin { to { opacity: .5; font-size: 120px; } 20% { opacity: .6; font-size: 130px; } 40% { opacity: .7; font-size: 140px; } 60% { opacity: .8; font-size: 150px; } 80% { opacity: .9; font-size: 160px; } to { opacity: 1; font-size: 140px; } } 动画方向 使用 animation-direction 控制动画运行的方向。 选项 说明 normal 从0%到100%运行动画 reverse 从100%到0%运行动画 alternate 先从0%到100%，然后从100%到0% alternate-reverse 先从100%到0%，然后从0%到100% 效果对比 代码示例： Document * { margin: 0; padding: 0; list-style: none; box-sizing: border-box; } body { height: 100vh; width: 100vw; display: flex; justify-content: center; align-items: center; } main { height: 400px; width: 800px; display: flex; justify-content: space-evenly; align-items: center; border: 1px solid #ddd; } main i.iconfont { font-size: 100px; color: red; position: relative; } main:hover i { /* 添加一组帧动画 */ animation-name: xin; /* 时间 */ animation-duration: .5s; /* 循环次数 死循环 */ animation-iteration-count: infinite; } main i:nth-child(1):after { content: \"normal\"; font-size: 15px; color: white; position: absolute; left: 50%; top: 50%; transform: translate(-50%, -50%); } main i:nth-child(2):after { content: \"normal-reverse\"; font-size: 15px; color: white; position: absolute; left: 50%; top: 50%; transform: translate(-50%, -50%); } main i:nth-child(3):after { content: \"alternate\"; font-size: 15px; color: white; position: absolute; left: 50%; top: 50%; transform: translate(-50%, -50%); } main i:nth-child(4):after { content: \"alternate-reverse\"; font-size: 15px; color: white; position: absolute; left: 50%; top: 50%; transform: translate(-50%, -50%); } main:hover i:nth-child(1) { /* 0-100 */ animation-direction: normal; } main:hover i:nth-child(2) { /* 100-0 */ animation-direction: reverse; } main:hover i:nth-child(3) { /* 0-100 100-0 */ animation-direction: alternate; } main:hover i:nth-child(4) { /* 100-0 0-100 */ animation-direction: alternate-reverse; } @keyframes xin { to { opacity: .5; font-size: 120px; } 20% { opacity: .6; font-size: 130px; } 40% { opacity: .7; font-size: 140px; } 60% { opacity: .8; font-size: 150px; } 80% { opacity: .9; font-size: 160px; } to { opacity: 1; font-size: 140px; } } 弹跳球 alternate-reverse是100-0 0-100，因此非常适合用来做弹跳球。 我们先把球和阴影都定义在下方，然后使用alternate-reverse将球转移到上方即可。 代码示例： Document * { margin: 0; padding: 0; list-style: none; box-sizing: border-box; } body { height: 100vh; width: 100vw; display: flex; justify-content: center; align-items: center; } main { height: 400px; width: 400px; display: flex; flex-flow: column; justify-content: flex-end; align-items: center; border: 1px solid #ddd; } main div { height: 100px; width: 100px; background: linear-gradient(45deg, #7bed9f, #2ed573, #1e90ff, #3742fa); border-radius: 50%; } main section { width: 140px; height: 20px; background: #2f3542; border-radius: 75%; /* 高斯模糊 */ filter: blur(3px); } main:hover div { /* 添加一组帧动画 */ animation-name: beat; /* 动画时间 */ animation-duration: 1s; /* 运动方式 100-0 0-100 */ animation-direction: alternate-reverse; /* 死循环 */ animation-iteration-count: infinite; } main:hover section { /* 添加一组帧动画 */ animation-name: size; /* 动画时间 */ animation-duration: 1s; /* 运动方式 100-0 0-100 */ animation-direction: alternate-reverse; /* 死循环 */ animation-iteration-count: infinite; } @keyframes beat { from { background: linear-gradient(90deg, #7bed9f, #2ed573, #1e90ff, #3742fa); width: 140px; } to { transform: translateY(-280px); } } @keyframes size { to { width: 70px; } } 延迟动画 使用 animation-delay 规则定义动画等待多长时间后执行。 我们可以为多个动画指定不同的延迟时间，与动画时间的使用规则相同。 效果体验 延迟动画 圆角3s后执行，背景色2s后执行，移动1s后执行 代码示例： Document * { margin: 0; padding: 0; list-style: none; box-sizing: border-box; } body { height: 100vh; width: 100vw; display: flex; justify-content: center; align-items: center; } main { height: 400px; width: 400px; display: flex; justify-content: center; align-items: flex-start; border: 1px solid #ddd; } div { height: 100px; width: 100px; background: #5352ed; } main:hover div { /* 一组帧的名字 可以使用多组帧*/ animation-name: radius, background, move; /* 动画时长 */ animation-duration: 2s; /* 延迟动画 圆角3s后执行，背景色2s后执行，移动1s后执行*/ animation-delay: 3s, 2s, 1s; /* 将动画停留在最后一帧 */ animation-fill-mode: forwards; } @keyframes radius { to { border-radius: 50%; } } @keyframes background { to { background-color: #ffa502; } } @keyframes move { to { transform: translate(0, 150px); } } 动画速率 系统属性 使用animation-timing-function来控制动画速率 值 描述 linear 规定以相同速度开始至结束的过渡效果（等于 cubic-bezier(0,0,1,1)）。 ease 开始慢，然后快，慢下来，结束时非常慢（cubic-bezier(0.25,0.1,0.25,1)）默认值。 ease-in 开始慢，结束快（等于 cubic-bezier(0.42,0,1,1)） ease-out 开始快，结束慢（等于 cubic-bezier(0,0,0.58,1)） ease-in-out 中间快，两边慢（等于 cubic-bezier(0.42,0,0.58,1)） cubic-bezier(n,n,n,n) 在 cubic-bezier 函数中定义自己的值 可以在帧中单独定义，将影响当前帧的速率 贝塞尔曲线 其实不管是linear或者是ease都是由贝塞尔曲线来完成的。 我们需要设置四个值 cubic-bezier(\\, \\, \\, \\)来控制曲线速度，可在 https://cubic-bezier.com 网站在线体验效果。 效果体验 代码示例： Document * { margin: 0; padding: 0; list-style: none; box-sizing: border-box; } body { height: 100vh; width: 100vw; display: flex; justify-content: center; align-items: center; } main { height: 400px; width: 400px; display: flex; justify-content: space-evenly; align-items: flex-end; border: 1px solid #ddd; } div { padding: 10px; height: 100%; width: 25%; text-align: center; background: #ff4757 content-box; color: white; } main:hover div { /* 一组帧的名字 可以使用多组帧*/ animation-name: move; /* 动画时长 */ animation-duration: 3s; /* 重复动画 死循环 */ animation-iteration-count: infinite; } main:hover div:nth-child(1) { animation-timing-function: linear; } main:hover div:nth-child(2) { animation-timing-function: ease; } main:hover div:nth-child(3) { animation-timing-function: ease-in; } main:hover div:nth-child(4) { animation-timing-function: ease-out; } main:hover div:nth-child(5) { animation-timing-function: ease-in-out; } @keyframes move { to { height: 0; } } linear ease ease-in ease-out ease-in-out 弹跳球 ease-out是开始快，结束慢，而ease-in是结束快，开始慢。因此这两个组合做弹跳小球刚好。 代码示例： Document * { margin: 0; padding: 0; list-style: none; box-sizing: border-box; } body { height: 100vh; width: 100vw; display: flex; justify-content: center; align-items: center; } main { height: 400px; width: 400px; display: flex; flex-flow: column; justify-content: space-between; align-items: center; border: 1px solid #ddd; } main div { height: 100px; width: 100px; background: linear-gradient(45deg, #eccc68, #ffa502, #ff6b81, #ff4757); border-radius: 50%; } main section { width: 70px; height: 20px; background: #2f3542; border-radius: 75%; /* 高斯模糊 */ filter: blur(3px); } main:hover div { /* 添加一组帧动画 */ animation-name: beat; /* 动画时间 */ animation-duration: 3s; /* 死循环 */ animation-iteration-count: infinite; } main:hover section { /* 添加一组帧动画 */ animation-name: size; /* 动画时间 */ animation-duration: 3s; /* 死循环 */ animation-iteration-count: infinite; } @keyframes beat { 0% { background: linear-gradient(60deg, #eccc68, #ffa502, #ff6b81, #ff4757); transform: translateY(0px); animation-timing-function: ease-in; width: 100px; } 30% { background: linear-gradient(120deg, #eccc68, #ffa502, #ff6b81, #ff4757); transform: translateY(50px); animation-timing-function: ease-in; width: 100px; } 60% { background: linear-gradient(240deg, #eccc68, #ffa502, #ff6b81, #ff4757); transform: translateY(100px); animation-timing-function: ease-in; width: 100px; } 80% { background: linear-gradient(300deg, #eccc68, #ffa502, #ff6b81, #ff4757); transform: translateY(150px); animation-timing-function: ease-in; width: 100px; } 95% { background: linear-gradient(340deg, #eccc68, #ffa502, #ff6b81, #ff4757); transform: translateY(200px); animation-timing-function: ease-in; width: 100px; } 15%, 45%, 70%, 85%, 100% { width: 140px; transform: translateY(280px); animation-timing-function: ease-out; } } @keyframes size { 0% { width: 80px; } 30% { width: 85px; } 60% { width: 95px; } 80% { width: 110px; } 95% { width: 120px; } 15%, 45%, 70%, 85%, 100% { width: 140px; } } 按钮提交 这个需要用到盒子阴影，一个元素可以有多个阴影。 盒子阴影的设置规则如下： 水平偏移度/垂直偏移度/模糊度/颜色 对于颜色而言可以使用currentColor来获取当前盒子的color属性。 代码示例： Document * { margin: 0; padding: 0; list-style: none; box-sizing: border-box; } body { height: 100vh; width: 100vw; display: flex; justify-content: center; align-items: center; } main { height: 400px; width: 400px; display: flex; justify-content: center; align-items: center; border: 1px solid #ddd; } main button { height: 40px; width: 100px; background-color: #747d8c; color: white; display: flex; justify-content: center; align-items: center; } main button::after { content: ''; display: inline-block; height: 3px; width: 3px; margin-left: 5px; } /* Js中可换成点击事件 */ button:hover::after { /* 添加一组帧动画 */ animation-name: point; /* 动画时间 */ animation-duration: 2s; /* 死循环 */ animation-iteration-count: infinite; /* 动画速率 */ animation-timing-function: linear; } @keyframes point { 60% { box-shadow: none; } 30% { box-shadow: 3px 0 currentColor; } 60% { box-shadow: 3px 0 currentColor, 9px 0 currentColor; } to { box-shadow: 3px 0 currentColor, 9px 0 currentColor, 15px 0 currentColor; } } 提交 步进速度 过渡使用阶梯化呈现，有点像现实生活中的机械舞，下面是把过渡分3步完成。 选项 说明 steps(n,start) 设置n个时间点，第一时间点变化状态 steps(n,end) 设置n个时间点，第一时间点初始状态 step-start 等于steps(1,start)，可以理解为从下一步开始 step-end 等于steps(1,end)，可以理解为从当前步开始 start总是先走，end总是后走. 代码示例： Document * { margin: 0; padding: 0; box-sizing: border-box; } body { height: 100vh; width: 100vw; display: flex; justify-content: center; align-items: center; } main { height: 400px; width: 800px; display: flex; border: 1px solid #ddd; position: relative; } main div { width: 200px; height: 100%; border: 1px solid #ddd; } main::after { content: \"START\"; height: 30%; width: 25%; background: #ff4757; color: #fff; font-size: 2em; position: absolute; top: 0; display: flex; justify-content: center; align-items: center; } main::before { content: \"END\"; height: 30%; width: 25%; background: #70a1ff; color: #fff; font-size: 2em; position: absolute; bottom: 0; display: flex; justify-content: center; align-items: center; } main:hover::after { /* 添加一组动画帧 */ animation-name: move; /* 步进动画，3步 */ animation-timing-function: steps(3, start); /* 动画时长2s */ animation-duration: 2s; } main:hover::before { /* 添加一组动画帧 */ animation-name: move; /* 步进动画，3步 */ animation-timing-function: steps(3, end); /* 动画时长2s */ animation-duration: 2s; } @keyframes move { to { transform: translateX(600px); } } 播放状态 使用 animation-play-state 可以控制动画的暂停与运行。 选项 说明 paused 鼠标放上时暂停 running 鼠标放上时运行 轮播图 代码示例： Document * { padding: 0; margin: 0; } body { width: 100vw; height: 100vh; display: flex; justify-content: center; align-items: center; background: #2c3e50; } main { width: 400px; border: solid 5px #ddd; border-width: 5px 0 5px 0; overflow: hidden; position: relative; } main:hover section { animation-play-state: paused; } main:hover ul::before { animation-play-state: paused; } section { width: 1600px; height: 200px; display: flex; flex-direction: row; animation-name: slide; animation-duration: 4s; animation-iteration-count: infinite; animation-timing-function: steps(4, end); } section div { width: 400px; height: 200px; overflow: hidden; } section div img { width: 100%; } ul { width: 200px; position: absolute; list-style: none; display: flex; justify-content: center; align-items: center; z-index: 3; bottom: 20px; left: 50%; transform: translateX(-50%); } ul li { font-size: 2em; font-weight: bold; color: white; width: 50px; height: 50px; border-radius: 50%; border: solid 3px transparent; box-sizing: border-box; display: flex; justify-content: center; align-items: center; z-index: 2; background: rgba(0, 0, 0, .3); box-shadow: 0 0 3px rgba(0, 0, 0, 1); } ul::before { content: ''; width: 50px; height: 50px; border-radius: 50%; position: absolute; background: #e74c3c; left: 0; animation-name: num; animation-duration: 4s; animation-iteration-count: infinite; animation-timing-function: steps(4, end); z-index: 1; } @keyframes slide { from { transform: translateX(0px); } to { transform: translateX(-100%); } } @keyframes num { 100% { transform: translateX(200px); } } 1 2 3 4 填充模式 animation-fill-mode 用于定义动画播放结束后的处理模式，是回到原来状态还是停止在动画结束状态。 选项 说明 none 需要等延迟结束，起始帧属性才应用 backwards 动画效果在起始帧，不等延迟结束 forwards 结束后停留动画的最后一帧 both 包含backwards与forwards规则，即动画效果在起始帧，不等延迟结束，并且在结束后停止在最后一帧 效果对比 代码示例： Document * { margin: 0; padding: 0; box-sizing: content-box; } body { display: flex; justify-content: center; align-items: center; height: 100vh; width: 100vw; } main { display: flex; justify-content: space-evenly; align-items: center; height: 200px; width: 800px; border: 1px solid #ddd; } div { height: 80px; width: 200px; background: #000 content-box; padding: 10px; display: flex; justify-content: space-evenly; align-items: center; color: #fff; position: relative; } main:hover div { /* 添加一组帧动画 */ animation-name: background; /* 运行时间 */ animation-duration: 3s; /* 延迟时间 */ animation-delay: 2s; } main div:nth-child(1)::before { content: \"等待延迟 不停留最后一帧\"; display: flex; justify-content: space-evenly; align-items: center; color: red; font-weight: bolder; position: absolute; top: -20px; } main div:nth-child(2)::before { content: \"不等待延迟 不停留最后一帧 \"; display: flex; justify-content: space-evenly; align-items: center; color: red; font-weight: bolder; position: absolute; top: -20px; } main div:nth-child(3)::before { content: \"等待延迟 停留最后一帧 \"; display: flex; justify-content: space-evenly; align-items: center; color: red; font-weight: bolder; position: absolute; top: -20px; } main div:nth-child(4)::before { content: \"不等待延迟 停留最后一帧 \"; display: flex; justify-content: space-evenly; align-items: center; color: red; font-weight: bolder; position: absolute; top: -20px; } main:hover div:nth-child(1) { animation-fill-mode: none; } main:hover div:nth-child(2) { animation-fill-mode: backwards; } main:hover div:nth-child(3) { animation-fill-mode: forwards; } main:hover div:nth-child(4) { animation-fill-mode: both; } @keyframes background { from { background-color: #ff6348; } 30% { background-color: #ffa502; } 60% { background-color: #eccc68; } to { background-color: #2ed573; } } none backwards forwards both 简写模式 和CSS中的其他属性一样，可以使用animation组合定义帧动画。animation 属性是一个简写属性，用于设置六个动画属性： animation-name 帧动画名字 animation-duration 帧动画运行时间 animation-timing-function 帧动画速率 animation-delay 帧动画播放状态（暂停/运行） animation-iteration-count 帧动画循环次数 animation-direction 延迟时间 必须存在 animation-duration属性，否则过渡时间为0没有动画效果。 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-07-20 00:00:32 "},"前端专栏/CSS/响应式布局.html":{"url":"前端专栏/CSS/响应式布局.html","title":"响应式布局","keywords":"","body":"媒体查询 媒体查询是响应式布局中非常常用的一种手段，在学习媒体查询之前要先了解什么是响应式。 所谓响应式即在不同尺寸屏幕设备上响应的内容不同 相信在之前你写的页面在PC端看非常华丽工整，但是一拿到移动端全部乱了套，这就是因为没有对页面做响应式处理。 Media Queries能在不同的条件下使用不同的样式，使页面在不同在终端设备下达到不同的渲染效果。 媒体类型 选项 说明 all 所有媒体类型 screen 用于电脑屏幕，平板电脑，智能手机等 print 打印设备 speech 应用于屏幕阅读器等发声设备 另外还有很多设备类型，如tty, tv, projection, handheld, braille, embossed, aural 等等，但是这些类型已经被废弃。 可以使用 link 与 style 中定义媒体查询 也可以使用 @import url(screen.css) screen 形式媒体使用的样式 可以用逗号分隔同时支持多个媒体设备 未指定媒体设备时等同于all style 下面我们来感受一下在screen屏幕设备与print打印设备上同一个元素给出的不同响应。 在screen上响应出红色，而在print上响应出绿色。 我们平时用的style并未指定media，此时默认为all，即所有媒体设备。 代码示例： Document h1 { color: red; } h1 { color: green; } 屏幕设备上显示红色打印设备上显示绿色 link 在 link 标签中通过 media 属性可以设置样式使用的媒体设备。 common.css 没有指定媒体所以全局应用 screen.css 应用在屏幕设备 print.css 应用在打印设备 我们平时用的link并未指定media，此时默认为all，即所有媒体设备。 代码示例： Document 屏幕设备上显示红色打印设备上显示绿色 @import 使用@import 可以引入指定设备的样式规则。文件中引入一个样式文件，在这个文件中再引入其他媒体的样式文件。 /* 引入全局的CSS样式 */ /* 在全局的CSS样式中分别导入不同设备的CSS样式 */ @import url(screen.css) screen; @import url(print.css) print; @media 可以使用 @media 做到更细的控制，即在一个样式表中为多个媒体设备定义样式。 代码示例： Document @media screen { /* 屏幕设备 */ h1 { color: red; } } @media print { /* 打印设备 */ h1 { color: green; } } 屏幕设备上显示红色打印设备上显示绿色 多媒体支持 前面已经说过，如果没有进行限制media则默认是all，all代表全部，如果我们只想让一部分媒体设备应用样式，则可以使用逗号将它们分开。 @import url(screen.css) screen,print; @media screen,print {...} 查询条件 可以使用不同条件限制使用的样式 注意：条件表达式需要放在扩号中 逻辑与 需要满足多个条件时才使用样式，多个条件使用and 连接。下例中满足以下要求才使用样式。 横屏显示 宽度不能超过768px 代码示例： Document @media screen and (orientation: landscape) and (max-width: 768px) { /* 屏幕设备 必须是宽屏 宽度小于768px */ h1 { color: red; } } 必须是屏幕设备并且宽度小于768px 逻辑或 多个或条件查询使用,逗号连接，不像其他程序中使用 or 语法。 下面的示例中如果设备是横屏显示或宽度不超768px时就使用样式规则。 代码示例： Document @media screen and (orientation: landscape), screen and (max-width: 768px) { /* 屏幕设备 必须是横屏 宽度小于768px */ h1 { color: red; } } 必须是屏幕设备并且是横屏显示 或者是屏幕设备并且宽度小于768px 逻辑非 not 表示不应用样式，即所有条件都满足时不应用样式。 必须将not写在查询的最前面 代码示例： Document @media not screen { h1 { color: red; } } 如果是屏幕设备则不应用 反之 如果是不是屏幕设备则应用 only 用来排除不支持媒体查询的浏览器。 对支持媒体查询的设备，正常调用样式，此时就当only不存在 对不支持媒体查询的设备不使用样式 only 和 not 一样只能出现在媒体查询的开始 /* 必须支持媒体查询 必须是屏幕设备并且是横屏显示还有最小宽度为768px */ @media only screen and (orientation: landscape) and (max-width: 768px) { ... } 查询特性 根据查询特性筛选出使用样式的设备。 常用特性 下面列出常用的媒体查询特性 特性 说明 orientation: landscape \\ portrait landscape横屏，portrait竖屏 width 设备宽度 height 设备高度 min-width 最小宽度（可以理解为大于该数值即成立） max-width 最大宽度（可以理解为小于该数值即成立） min-height 最小高度（可以理解为大于该数值即成立） max-height 最大高度（可以理解为小于该数值即成立） 使用示例 　　在设备宽度为568px时使用样式 @media only screen and (width:568px) { ... } 　　在设备大于 569px时使用样式 @media only screen and (min-width:569px) { ... } 　　橫屏设备并且宽度大于569px时使用样式 @media only screen and (orientation: landscape) and (min-width:569px) { ... } 响应尺寸 设备像素 不同设备的像素尺寸差异很大，比如2K的27寸屏幕与4K的27寸屏幕的像素数量是不一样的。如果我们编写CSS时还要判断设备的物理像素就会很麻烦。 我们希望编写CSS时还是按照以往方式编写，至于具体绘制到屏幕上使用的具体像素让浏览器或小程序等自动计算就可以，这是最佳解决方案。 使用以下代码可以轻松解决上面的问题了。（ 在\\标签中插入） 初始样式 有些标签默认含有内外边距，且不同浏览器大小也不一样。为了统一我们可以重置标签的CSS默认样式。 最简单的方式就是使用插件css-reset完成 自动响应 实际操作中不同设备只能取宽或高一个尺寸为响应处理，一般情况下我们取宽度响应，高度自动处理。小尺寸时高度产生滚动条，这并不影响什么。 计算公式： 使用rem单位来处理响应，因为改变rem单位会影响所有使用rem的元素，这确实非常的方便。 rem是在根元素中定义的font-size rem用来在多个设备响应处理时使用 html元素也可以使用:root选择器选择 另外还有一个单位即vw与vh 100vw表示100%设备宽度 100vh代表100%设备高度 因为使用了vw宽度系统会根据不同设备自动计算rem :root{ font-size:15px; } Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-07-20 08:11:32 "},"前端专栏/JavaScript/summary.html":{"url":"前端专栏/JavaScript/summary.html","title":"JavaScript","keywords":"","body":"Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-07-07 19:51:50 "},"前端专栏/jQuery/summary.html":{"url":"前端专栏/jQuery/summary.html","title":"jQuery","keywords":"","body":"Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-07-07 19:51:50 "},"前端专栏/Vue/summary.html":{"url":"前端专栏/Vue/summary.html","title":"Vue","keywords":"","body":"Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-07-07 19:51:50 "}}