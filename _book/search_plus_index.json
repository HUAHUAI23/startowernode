{"./":{"url":"./","title":"Introduction","keywords":"","body":"专题阅读 我从2016年开始系统学习编程之后，便一直零零散散的记录着各种各样的笔记。 其中收集过很多相关资料，但是一直没有汇集成册。 刚好最近比较有空闲，就将自己的学习笔记汇聚成册，希望能够给大家提供帮助。 整体笔风可能不是特别面向新手，但是也应该能够对你有所帮助。 涵盖3大编程语言：Python\\Golang\\JavaScript 涵盖4大数据库产品：MySQL\\Redis\\Elasticsearch\\MongoDB 关于系统着重使用MacOS 10.14.6以及CentOS 7.3，暂时不提供Windows的相关文章。 系统配置是Core i5 4核心4线程、8G RAM、256SSD，也算是比较老的配置了。 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-05-12 17:14:06 "},"杂谈专栏/summary.html":{"url":"杂谈专栏/summary.html","title":"杂谈专栏","keywords":"","body":"这一个专题更加的符合通用性，不拘泥于语言，或者说适用于大部分语言。 为什么命名为杂谈呢？因为实在是不好归类... Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-05-12 16:57:15 "},"杂谈专栏/编程语言区别.html":{"url":"杂谈专栏/编程语言区别.html","title":"编程语言区别","keywords":"","body":"低级语言 语言的高级和低级之分并不是说语言本身的层次高低，而是指的是与底层硬件的密切程度。 就如同机器语言与汇编语言就是直接与底层硬件打交道的语言，故也被称为低级语言。 机器语言 机器语言是不通过任何操作系统就可以直接与底层硬件打交道的语言，说白了就是计算机能读懂的二进制。 想要使用机器语言就得充分的了解计算机底层硬件的各个知识。 虽然这可能会花上你半生的时间，但是机器语言的执行效率却是无与伦比的高，计算机不需要通过任何编译就能直接运行。 与之相反的是机器语言的开发效率却是慢到令人发指，除了你需要去学习底层硬件相关的知识外还需要对每一条二进制指令烂熟于心，更加恐怖的是面对满屏的010101如果敲错一个字符就全部推倒重来，显然这已经超出了普通人所能承受的极限。 #指令部份的示例 0000 代表 加载（LOAD） 0001 代表 存储（STORE） ... ​ #暂存器部份的示例 0000 代表暂存器 A 0001 代表暂存器 B ... ​ #存储器部份的示例 000000000000 代表地址为 0 的存储器 000000000001 代表地址为 1 的存储器 000000010000 代表地址为 16 的存储器 100000000000 代表地址为 2^11 的存储器 ​ #集成示例 0000,0000,000000010000 代表 LOAD A, 16 0000,0001,000000000001 代表 LOAD B, 1 0001,0001,000000010000 代表 STORE B, 16 0001,0001,000000000001 代表 STORE B, 1[1] 名词 描述 执行效率 极高 开发效率 极低 跨平台性 极差（由于必须依赖具体的硬件，故移植性极差） 汇编语言 汇编语言仅仅是用一个英文标签代表一组二进制指令，毫无疑问，比起机器语言，汇编语言是一种进步，但汇编语言的本质仍然是直接操作硬件，因此汇编语言仍是比较低级/底层的语言、因为它十分的贴近计算机硬件。 汇编的中打印一句hello world，需要写十多行，如下： ; hello.asm section .data ; 数据段声明 msg db \"Hello, world!\", 0xA ; 要输出的字符串 len equ $ - msg ; 字串长度 section .text ; 代码段声明 global _start ; 指定入口函数 _start: ; 在屏幕上显示一个字符串 mov edx, len ; 参数三：字符串长度 mov ecx, msg ; 参数二：要显示的字符串 mov ebx, 1 ; 参数一：文件描述符(stdout) mov eax, 4 ; 系统调用号(sys_write) int 0x80 ; 调用内核功能 ; 退出程序 mov ebx, 0 ; 参数一：退出代码 mov eax, 1 ; 系统调用号(sys_exit) int 0x80 ; 调用内核功能 名词 描述 执行效率 极高 开发效率 低 跨平台性 极差（由于必须依赖具体的硬件，故移植性极差） 高级语言 高级语言并不关心底层硬件到底怎么样，因为高级语言是在和操作系统打交道。 而操作系统又是管控硬件的软件，所以高级语言相较于低级语言来说它的开发效率肯定是要快上不少，但是在执行效率上却有所损失。 对于语言的好坏一味的按照执行效率来区分并非是正确的，语言本身只是一种工具，使用语言的人才是真正的操纵者。 语言的对比只应场景适不适用，其本身并无强弱之分。 比如要对底层硬件进行开发，那么无疑汇编语言是最佳的选择，它能与本机硬件打交道所以能充分发挥自己执行效率高的特性，再比如要做一款网络爬虫相关的软件，由于网络具有延迟性会拖慢程序整体的运行速度，故使用汇编语言来编写爬虫便成了弱势（开发周期长，网络环境让汇编语言的高执行效率也体现不出来）。 高级语言中按照翻译方式的不同又大体可分为两类，分别是编译型语言与解释型语言。 编译型语言 如Golang，C语言等均为编译型语言。 编译型语言特点： 执行效率高：生成的目标文件可以脱离语言环境独立执行（因为都是存的二进制指令） 开发效率低：如果程序需要修改某一功能则必须修改源程序中的代码后再次生成目标程序，倘若只有目标程序而没有源程序的话则修改原本的功能是一件很困难的事情，这样做的好处是保证了代码的安全性，除开通过反编译技术手段否则看不见源代码 跨平台性差：大多数编译型语言的代码只针对某一个平台下进行编译，前平台下的编译结果（目标程序）无法拿到不同的平台上使用 其他：现在大多数的编程语言都是编译型的。编译程序（GCC）将源程序翻译成目标程序后保存在另一个文件中，该目标程序可脱离编译程序直接在计算机上多次运行。大多数软件产品都是以目标程序形式发行给用户的，不仅便于直接运行提升执行效率，同时又使他人难于盗用其中的技术 解释型语言 如Python，JavaScript均为解释型语言。 解释型语言特点： 执行效率低：在解释型语言的实现中，解释器并不产生目标机器代码，而是产生易于执行的中间代码。这种中间代码与机器代码是不同的，中间代码的解释是由软件支持的，不能直接使用硬件，软件解释器通常会导致执行效率偏低 开发效率高：用解释型语言编写的程序是由另一个可以理解中间代码的解释程序执行的，与编译程序不同的是，解释程序的任务是逐一将源程序的语句解释成可执行的机器指令，不需要将源程序翻译成目标代码再执行。解释程序的优点是当语句出现语法错误时，可以立即引起程序员的注意。让程序员在程序开发期间就能进行校正，故开发效率高于编译性语言 跨平台性强：代码运行是依赖于解释器，不同平台有对应版本的解释器，所以解释型语言的跨平台性更强 其他：对于解释型Basic语言，需要一个专门的解释器解释执行Basic程序，每条语句只有在执行时才被翻译，这种解释型语言每执行一次就翻译一次，因而效率低下。一般地，动态语言都是解释型的，例如：Tcl、Perl、Ruby、VBScript、JavaScript等 除此之外，还有一种混合型语言，如Java：Java语言首先会生成Java汇编，然后通过虚拟机进一步转换成计算机可以识别的二进制汇编语言。 动态与静态 动态类型：如果一门语言可以在运行时改变变量的类型，那我们称之为动态类型语言（如Python） 静态类型：相反，如果一门语言不可以在运行时改变变量的类型，则称之为静态类型语言（如Golang） 动态类型示例（Python演示）： >>> string = str(\"hello,world\") >>> type(string) >>> string = b\"\" >>> type(string) >>> 静态类型示例（Golang演示）： func main() { var str string str = \"hello,world\" fmt.Printf(\"%T\",str) str = 't' // 编译出现异常，不允许改变类型 } 强类型与弱类型 强类型：如果一门语言不倾向于对变量的类型做隐式转换，那我们将其称之为强类型语言（如Python） 弱类型：相反，如果一门语言倾向于对变量的类型做隐式转换，那我们则称之为弱类型语言（如JavaScript） 强类型示例（Python演示）： >>> 1 == \"1\" False 弱类型示例（JavaScript演示）： \"use strict\"; console.log(1 == \"1\"); // true Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-05-12 17:01:52 "},"杂谈专栏/详解字符编码.html":{"url":"杂谈专栏/详解字符编码.html","title":"详解字符编码","keywords":"","body":"字符编码 计算机使用计算机语言（2进制）表示数据，人类使用自然语言表示数据。 人类若想和计算机进行无障碍沟通，必须要通过一本记载着计算机语言与自然语言关系的词典。 而通过这本词典与计算机进行沟通交互的过程即可被称为字符的编码、解码的过程： 编码是指将自然语言转换为计算机语言的过程。 解码是指将计算机语言转换为自然语言的过程。 ASCII 计算机由西方世界发明，所以第一个字符编码表仅记录了一些英文与符号，该表也被称为ASCII码表。 它仅支持一些英文字符与特殊符号，不支持其他国家的语言字符。 实际上ASCII码表在设计之初，就预留了一些位置，最初的ASCII码表中每一个字符仅占用7bit的位置，也就最多表示128个字符。 最初的ASCII码表仅有128个字符，后来经过扩展，又新增了128个字符，此时的ASCII码表中，一个字符占用1Bytes（8bit）的位置。： GBK 随着计算机在世界范围内高速发展，ASCII码表已经不满足广大用户的需求了。 此时，各个国家开始推出自己的字符编码表，如： 日本的Shift-JIS表等 韩国的Euc-Kr表等 中国的gb2312、GBK表等 ... 这些表都有一个特点，即除了包含原本的ASCII码表之外还包含了本国的通用语言。 在GBK编码表中，一个英文字符占用1Bytes(8bit)，而一个中文字符则占用2Bytes(16bit)。 此时，出现了1个严重的问题，即跨国的通信问题，如下图所示： Unicode 为了解决这个问题，在1990年的时候推出了Unicode表，并且在1994年正式使用。 它详细的记录了所有自然语言与计算机语言的对应关系，在（usc2标准）中每一个字符不管是英文还是中文都占用2个Bytes（16bit），而在（usc4标准）中则统一占用4个Bytes（32bit），这样就解决了跨国通信的问题。 对比ASCII码表英文字符仅占用1个Bytes而言，如果直接使用Unicode编码进行文件存储则存储空间会直接翻倍，因此Unicode表仅存在于内存之中，而在网络传输以及文件存储上则采用了另外的编码格式。 换句话说，Unicode仅作为翻译词典存在于计算机内部，Unicode因为包含了所有自然语言与计算机语言的关系，因此作为翻译词典是最合适不过的。 UTF8 如下图，中文网站由GBK编码存储，国内的计算机中应该都有GBK编码，所以访问该网站非常轻松，而在日本计算机上若想访问该网站则必须要先下载GBK后方能以GBK的解码形式打开该网站，否则会产生乱码问题。 那么有没有一种编码，能够统一整个互联网，让所有计算机都用这种编码进行文件存储、网络传输呢？ 此时，出现了UTF8编码，全称为Unicode Transformation Format，即Unicode的转换格式，它是一种可变长的编码格式。 在UTF8编码格式中，英文字符统一占用1Bytes(8bit)的位置，而中文字符则占用3Bytes(24bit)或者4Bytes(32Bytes)的位置。 UTF8编码是未来的发展趋势，它与Unicode对比的唯一区别在于它不包含其他字符编码表。 在依然存在以GBK编码格式、Shift-JIS编码格式进行文件存储的环境下，使用UTF8作为翻译词典并不合适。 但是如果有一天所有人都统一使用UTF8进行文件存储网络传输的话，那么就不再需要包含其他字符编码表了，此时UTF8将会真正代替Unicode入驻内存中成为翻译词典，当然这是后话，目前还没有达到这样的理想情况。 UTF8的编解码 编码过程 如我们要将“云”字根据UTF8格式存储到磁盘中： 1.通过站长工具先得出该字符Unicode的16进制表现形式： \\u4e91 2.再将这个16进制的Unicode字符转换为2进制，那么这个2进制就是“云”字在内存中存储的样子： >>> bin(int(\"4e91\",base=16)) '0b100111010010001' 3.现在，计算机要把“云”字写入磁盘中，由于是使用的UTF8编码格式，所以先确定它的占用空间是3Bytes还是4Bytes，规则如下，套用表即可： 码位范围（Unicode十六进制） utf-8 0000 ~ 007F 用1个Bytes表示 0080 ~ 07FF 用2个Bytes表示 0800 ~ FFFF 用3个Bytes表示 4e91 在这里，第3分区 10000 ~ 10FFFF 用4个Bytes表示 4.确定了“云”字占用3Bytes，我们可以通过一个模板，将Unicode的2进制转换为UTF8的2进制： 码位范围（十六进制） 转换模板 0000 ~ 007F 0XXXXXXX 0080 ~ 07FF 110XXXXX 10XXXXXX 0800 ~ FFFF 1110XXXX 10XXXXXX 10XXXXXX 10000 ~ 10FFFF 11110XXX 10XXXXXX 10XXXXXX 10XXXXXX 5.根据分区信息，选用3Bytes的模板，进行转换，从右至左依次填充，不够的使用0进行填充： 1110XXXX 10XXXXXX 10XXXXXX 100 111010 010001 1110XXXX 10XXXXXX 10XXXXXX 0100 111010 010001 # 填充0 11100100 10111010 10010001 # 结果 所以最后得出的结果，“云”用UTF8格式保存至磁盘的话，2进制格式为11100100 10111010 10010001。 解码过程 如果要将“云”字UTF8的2进制格式转换为字符，则还是需要通过Unicode进行解码过程。 当计算机读取到这个文件是以UTF8格式进行存储后，内部已经做好了通过UTF8进行解码的准备。 开始读取后，计算机会将硬盘中存储的UTF8的2进制格式文字信息加载至内存中： 11100100 10111010 10010001 现在，Unicode会参照模板，通过UTF8分区信息提取出该文字Unicode的2进制格式： 码位范围（十六进制） 转换模板 0000 ~ 007F 0XXXXXXX 0080 ~ 07FF 110XXXXX 10XXXXXX 0800 ~ FFFF 1110XXXX 10XXXXXX 10XXXXXX 10000 ~ 10FFFF 11110XXX 10XXXXXX 10XXXXXX 10XXXXXX 11100100 10111010 10010001 “云”字的二进制信息格式刚好对应第3分区，那么我们按照第3分区的模板格式对UTF8的2进制表现形式进行掐头工作，将它转变为Unicode的2进制表现格式。 1110XXXX 10XXXXXX 10XXXXXX 11100100 10111010 10010001 0100 111010 010001 # 掐头 100111010010001 # 结果 得到了结果为100111010010001，现在将它转换为Unicode字符，可以直接通过UU工具进行转换： 总结 UTF8与Unicode的关系如下： Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-05-16 21:18:49 "},"Python/summary.html":{"url":"Python/summary.html","title":"Python专栏","keywords":"","body":"HELLO! PYTHON! Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-05-12 20:27:56 "},"Python/Python快速入门/summary.html":{"url":"Python/Python快速入门/summary.html","title":"Python快速入门","keywords":"","body":"Python快速入门这一章节主要介绍Python、了解Python、并且安装一些Python的常用工具。 Python简介 Python安装 pip简单使用 Python虚拟环境 Python常用工具 PEP8规范说明 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-05-12 18:17:17 "},"Python/Python快速入门/Python简介.html":{"url":"Python/Python快速入门/Python简介.html","title":"Python简介","keywords":"","body":"Python简述 Python诞生于1989年圣诞节，由仁慈的独裁者（Benevolent Dictator For Life，缩写BDFL）吉多·范罗苏姆（Guido van Rossum）基于C语言开发。 Python的名字来源于龟叔（Guido van Rossum在Python界的爱称）十分喜欢的一部名为Monty Python's Flying的电视剧，一想到这个风靡全球的编程语言名字居然来的这么随意，不禁让人哑然失笑。 作为一门解释性的动态强类型语言，Python的开发效率奇高，因此在Python界流传着这样一句至理名言： 人生苦短，我用Python！ Python并不是毫无缺点的孩子，作为一门动态语言，它的执行效率是偏低的。 作为80年代的产物，它的并发性支持也可能不太好，但是这并不妨碍我们对它的热爱，相信只要拥入Python的怀抱你一定会爱上这一门优雅的语言。 Python解释器 由于是动态语言，Python在代码执行时必须先将代码转换为字节码，然后通过字节码再转换为机器可读的机器码。 而解释器就是负责这一切工作的小蜜蜂。 我们常说的Python是基于C语言开发而来的CPython，除此之外还有基于Java开发而来的Jython、以及基于C#开发而来的IronPython。 不论是Jython还是IronPython，我们在学习时都不会去考虑，而是统一选择CPython，因为它们相较于传统的CPython多了一个转换环节所以会导致执行效率的降低。 低效率的执行 动态语言是逐行翻译，我们可以将它理解为一种边跑边看的策略。 无疑，这样做的后果是方便代码排查，缺点是拉低执行效率。 常见的Python解释器（包括CPython）等都是采用这种策略，故Python的执行效率一直被人诟病。 PyPy解释器 熟悉Python的朋友都知道，有一款Python解释器打破了人们对于Python低执行效率的印象。 它就是PyPy解释器，PyPy是另一个Python解释器，它的目标是执行速度。 PyPy采用JIT技术，对Python代码进行动态编译（注意不是解释），所以可以显著提高Python代码的执行速度。 绝大部分Python代码都可以在PyPy下运行，但是PyPy和CPython有一些是不同的，这就导致相同的Python代码在两种解释器下执行可能会有不同的结果。 如果你的代码要放到PyPy下执行，就需要了解PyPy和CPython的不同点。 你可以简单的这么理解： 代码第一次运行时：进行动态编译，生成目标文件 代码第二次运行时：使用目标文件进行运行，没必要再进行逐行翻译，故执行效率提升 如果你需要较高的执行效率，可以选用该解释器，但是本专题中不会使用它。 因为PyPy终究不是正统，所以对很多第三方库的依赖兼容不如CPython。 版本介绍 由于我们平常讲的Python实际上都为CPython，故我们接下来的学习也是围绕CPython（以下简称Python）展开的。 目前Python版本已经更迭到了3.9。 以下是Python的发展历程： 1989年，Guido开始写Python语言的解释器。 1991年，第一个Python解释器诞生，它是用C语言实现的，并能够调用C语言的库文件。 从一出生，Python已经具有了：类，函数，异常处理，包含表和词典在内的核心数据类型，以及模块为基础的拓展系统。 Granddaddy of Python web frameworks, Zope 1 was released in 1999 Python 1.0 - January 1994 增加了 lambda, map, filter and reduce. Python 2.0 - October 16, 2000，加入了内存回收机制，构成了现在Python语言框架的基础 Python 2.4 - November 30, 2004, 同年目前最流行的WEB框架Django诞生 Python 2.5 - September 19, 2006 Python 2.6 - October 1, 2008 Python 2.7 - July 3, 2010 In November 2014, it was announced that Python 2.7 would be supported until 2020, and reaffirmed that there would be no 2.8 release as users were expected to move to Python 3.4+ as soon as possible Python 3.0 - December 3, 2008 Python 3.1 - June 27, 2009 Python 3.2 - February 20, 2011 Python 3.3 - September 29, 2012 Python 3.4 - March 16, 2014 Python 3.5 - September 13, 2015 Python 3.6 - 2016-12 Python 3.7 - 2018 Python 3.8 - 2019 ... 细心的读者会发现，08年时就推出了3.0，2010年反而又推出了2.7？ 这是因为3.0不向下兼容2.0，而很多公司已经基于2.0版本开发出了大量程序，公司已然投入了大量的人财物力，这就导致大家都拒绝升级3.0，无奈官方只能推出2.7过渡版本，之后我们都应该采用3.0解释器开发程序，但为了方便读者维护2.0版本的软件，在遇到两种版本的差异时会专门指出来。 应用方向 Python的应用领域十分广泛，如：人工智能，数据处理，爬虫，金融量化，云计算，WEB开发，自动化运维/测试，游戏开发，网络服务，图像处理等众多领域。 并且国内外很多知名的企业也都在使用Python，如：Youtube、DropBox、BT、Quora（中国知乎）、豆瓣、知乎、Google、Yahoo、FaceBook、NASA、百度、腾讯、汽车之家、美团等等。 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-05-12 17:47:08 "},"Python/Python快速入门/Python安装.html":{"url":"Python/Python快速入门/Python安装.html","title":"Python安装","keywords":"","body":"本机示例 虽然目前的Python版本已经更迭到了3.9，但是在这里将会使用Python3.6.8来进行开发。 Python3.6系列应该是目前使用最为广泛的一个版本系列，相较于最新版的3.9来说它支持的库更多、兼容性更好。 需要注意的是在类Unix平台中，Python2版本已经自带，所以我们只需安装Python3.6即可。 MAC安装 MAC下有源码安装Source，和界面化.pkg安装，我们选择pkg安装。 第一步：打开Python官网，点我跳转： 第二步，下载对应版本的pkg安装程序： 第三步，一直点击下一步即可： 上述的安装方式会自动将Python安装至以下目录： /Library/Frameworks/Python.framework/Versions/3.6/ 安装完成之后系统会自动的将常用软件ln -s到/usr/local/bin中： $ ls /usr/local/bin/ | grep p.*3 pip3 pip3.6 pydoc3 pydoc3.6 python3 python3-config python3.6 python3.6-config python3.6m python3.6m-config pyvenv-3.6 Linux安装 Linux下有源码安装Source，和免编译安装Binary，我们选择免编译安装。 第一步，下载gcc工具： $ yum install gcc gcc-c++ -y 第二步，下载wget工具： $ yum install wget -y 第三步，下载Python3.6.8的Binary版本： $ cd ~ $ wget https://www.python.org/ftp/python/3.6.8/Python-3.6.8.tgz 第五步，将归档文件tgz解压至当前目录： $ > tar xvf Python-3.6.8.tgz -C ./ $ > ls anaconda-ks.cfg Python-3.6.8 Python-3.6.8.tgz 第六步，进入解压的目录中，进行编译安装（由于CPython基于C语言，而C语言又是编译性语言，故需要进行编译后安装）： $ > cd Python-3.6.8 $ > ./configure --prefix=/usr/local/Python36 $ > make $ > make install 第七步，添加环境变量： $ vim /etc/profile # 写入内容 export PATH=/usr/local/Python36/bin:$PATH $ source /etc/profile 交互测试 安装完成之后，分别在shell中输入python（自带的版本）以及python3，查看是否能进入交互式环境中。 如果能成功进入则按照成功，如果不能请谷歌排查原因。 若想退出交互式环境，输入exit()即可： $ python Python 2.7.10 (default, Feb 22 2019, 21:55:15) [GCC 4.2.1 Compatible Apple LLVM 10.0.1 (clang-1001.0.37.14)] on darwin Type \"help\", \"copyright\", \"credits\" or \"license\" for more information. >>> exit() $ python3 Python 3.6.8 (v3.6.8:3c6b436a57, Dec 24 2018, 02:04:31) [GCC 4.2.1 Compatible Apple LLVM 6.0 (clang-600.0.57)] on darwin Type \"help\", \"copyright\", \"credits\" or \"license\" for more information. >>> exit() Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-05-12 18:00:22 "},"Python/Python快速入门/pip简单使用.html":{"url":"Python/Python快速入门/pip简单使用.html","title":"pip简单使用","keywords":"","body":"pip工具 pip是Python的包管理工具，该工具提供了对Python第三方包的查找、下载、安装、卸载等功能。 Python 2.7.9+ 或 Python 3.4+ 以上版本都自带pip工具，在安装Python时会一并安装。 如果你安装了两个版本的Python，则对应的pip命令就是pip2或者pip3。 $ ls /usr/local/bin/pip* /usr/local/bin/pip /usr/local/bin/pip2 /usr/local/bin/pip2.7 /usr/local/bin/pip3 /usr/local/bin/pip3.6 Ps：类似于NodeJS的NPM 常用命令 在shell中可使用的pip常用命令如下： 命令 描述 pip --version 显示版本和路径 pip --help 获取帮助 pip install -U pip pip升级 pip install 包名 安装包 pip install --upgrade 包名 升级包 pip uninstall 包名 卸载包 pip search 包名 搜索包 pip list 查看所有已安装的包 pip list -o 查看所有可升级的包 pip升级 使用以下命令进行pip工具进行升级： Windows平台： $ python -m pip install -U pip # python2.x $ python -m pip3 install -U pip # python3.x Linux&Mac平台： $ pip install --upgrade pip # python2.x $ pip3 install --upgrade pip # python3.x 换源配置 pip下载的包默认是从国外源下载，速度较慢，因此可以为其设置为国内源（阿里云）。 下面介绍类Unix平台与Windows平台的换源方式。 Windows 直接在user目录中创建一个pip目录，如：C:\\Users\\username\\pip，新建文件pip.ini，然后填入以下内容： [global] index-url = https://mirrors.aliyun.com/pypi/simple Unix 类Unix平台需要依次运行如下命令： $ cd ~ # 进入用户家目录 $ mkdir .pip # 创建隐藏文件夹 $ vim .pip/pip.conf # 创建pip3的配置文件 然后在配置文件pip.conf中填入以下内容： [global] index-url = https://mirrors.aliyun.com/pypi/simple Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-05-12 18:06:07 "},"Python/Python快速入门/Python虚拟环境.html":{"url":"Python/Python快速入门/Python虚拟环境.html","title":"Python虚拟环境","keywords":"","body":"虚拟环境 虚拟环境是真实的Python解释器的一份拷贝。 由于真实的Python解释器可能在不断的添加各种第三方库，而我们的项目中又没有用到这些库所以就会造成一个环境的污染，可能会造成打包exe文件后体积过大等问题。 一个项目的环境干净是十分重要的，而虚拟环境就是为了净化项目环境而生的一种措施。 我们在这里使用virtualenv与virtualenvwrapper这两个第三方模块来更加方便的管理我们的虚拟环境。 Windows 需要使用两个第三方模块，在终端中使用pip3命令下载安装： $ pip3 install virtualenv $ pip3 install virtualenvwrapper-win 创建虚拟环境工作目录，新建一个文件夹，从此之后所有的虚拟环境都会存放至该文件夹下： $ D: mkdir .virtualenvs 然后需要配置虚拟环境工作目录： 打开环境变量，在用户变量中新建，变量名为WORKON_HOME，值为虚拟环境的配置路径，即.virtualenvs的路径 打开原本的Python3环境安装目录，找到Scripts文件夹，双击执行其下的virtualenvwrapper.bat Linux&Mac 需要使用两个第三方模块，在shell中使用pip3命令下载安装： $ pip3 install -i https://pypi.douban.com/simple virtualenv $ pip3 install -i https://pypi.douban.com/simple virtualenvwrapper 创建虚拟环境工作目录，新建一个文件夹，从此之后所有的虚拟环境都会存放至该文件夹下： $ mkdir ~/.virtualenvs 配置环境变量，编辑userHome/.bash_profile文件，如果是Mac用户且终端为zsh，则配置userHome/.zshrc文件，新增以下内容： # Setting virtual environment save path # 填入你的虚拟环境存放目录 export WORKON_HOME=\"~/.virtualenvs\" # Setting virtual environment copy python path # 填入你的真实Python3解释器路径，用于虚拟环境的拷贝 export VIRTUALENVWRAPPER_PYTHON=/Library/Frameworks/Python.framework/Versions/3.6/bin/python3.6 # Setting virtualenvwrapper.sh run path # 填入virtualenvwrapper.sh的脚本路径 source /Library/Frameworks/Python.framework/Versions/3.6/bin/virtualenvwrapper.sh 最后刷新一下该文件的配置： $ source ~/.bash_profile 命令概览 shell中可指定的命令如下： 命令 描述 workon 列出所有虚拟环境 mkvirtualenv -p python3 虚拟环境名字 创建新的虚拟环境 rmvirtualenv 虚拟环境名字 删除指定的虚拟环境 workon 虚拟环境名字 使用指定的虚拟环境 示例演示，创建一个LearnPython的虚拟环境： $ mkvirtualenv -p python3 LearnPython $ workon 现在你会发现，shell的提示符改变了： (LearnPython) YunYadeMacBook-Pro:~ yunya$ Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-05-12 18:08:04 "},"Python/Python快速入门/Python常用工具.html":{"url":"Python/Python快速入门/Python常用工具.html","title":"Python常用工具","keywords":"","body":"运行方式 REPL交互式 REPL名为交互式解释器（Read Eval Print Loop），提供了一个CLI(command-line interface:命令行界面)下读取值、求值、输出值、循环代码的环境。 这种交互式的方式会经常用到，适用于快速的进行一些功能测试，如函数传参、求值测试等。 现在让我们以REPL交互式来运行第一条Python代码，在shell中进行执行： $ python3 >>> print(\"hello world\") hello world >>> 如果要退出REPL环境，则使用exit()即可。 脚本调用式 外部调用 在一个文件中，书写好Python代码后进行调用的方式被称为脚本调用式。 也是非常常用的一种方式，通常文件后缀名以py结尾，标识这是一个Python脚本文件。 使用Python调用脚本时，其实并不关心文件后缀名是什么，后缀名更多的作用是给使用者看的，便于区分不同类型的文件 $ echo \"print('hello world')\" > helloWorld.py $ python3 helloWorld.py hello world 在此示例中我们使用Python3的解释器在外部对其进行调用，并执行了其中的代码打印了hello world。 内部调用 除开外部调用，我们也可以在脚本内部指定Python解释器，并通过./进行代码执行，对上述文件内容进行修改： #!/usr/bin/env python3 print('hello world') 修改完成并保存，再修改文件的执行权限： $ chmod 775 helloWorld.py 直接使用./进行代码执行： $ ./helloWorld.py hello world 使用内部调用需要注意：指定Python解释器的语句一定要放在文件头部，因此该代码也被称为头文件代码。 常见的头文件代码除开指定Python解释器以外，还有指定解释器解码格式、声明作者和日期等，如下所示： #!/usr/bin/env python3 # -*- coding:utf-8 -*- # author: YunYa # date: 2017-01-28 头文件代码调用说明：env是类Unix平台的环境变量别称，当我们在头文件代码中指定/usr/bin/env python3的时候，它内部会运行env | grep python3，找到python3解释器，并对文件进行执行，前提是该文件必须具有可执行权限。 $ env | grep python3 VIRTUALENVWRAPPER_PYTHON=/Library/Frameworks/Python.framework/Versions/3.6/bin/python3.6 执行过程 一个Python程序被解释器解释并执行，可粗略的分为三个步骤： 启动Python解释器 Python解释器发起系统调用，将脚本内容载入内存，此时并不会做任何处理 Python解释器开始识别Python语法，解释并执行内存中存储的脚本文件内容 IDE介绍 IDE简介 IDE的全称是Integrated Development Environment，即集成开发环境。 它是一种辅助程序开发人员开发软件的应用软件，在开发工具内部就可以辅助编写源代码文本、并编译打包成为可用的程序，有些甚至可以设计图形接口。 如果单纯的touch出一个文本，并在其内部书写代码是很容易出现问题的。 没有语法高亮，这意味着某个字符少打了、某个单词拼错了都不能被及时发现，并且这样学习对新手难度极大 没有debug功能，当业务逻辑越来越复杂时，程序不可避免的会出现一些bug，此时如果没有debug程序来检测出现问题的原因，整个排查的过程将变的异常艰难 而使用IDE开发则可以完全避免这些问题。 Python IDLE Python自带了一款类似的工具，名为Python IDLE，是Python的集成开发和学习环境。 官方文档：https://docs.python.org/3/library/idle.html 它自带了2种模式，一种是REPL交互模式，一种是脚本调用模式。 当你打开它后默认会进入REPL交互模式，此时只需要新建一个文件即可开始编写我们的代码。 CTRL+N：新建文件 CTRL+S：保存文件 F5：运行程序 可以发现，当我们想使用print()功能时，它会提示该功能需要哪些参数： 当编写完代码后，即可使用F5来进行文件的保存与运行，如下所示： IDLE适用于刚入门起步学习Python的同学，但对于大的项目构建来说还是十分的不方便。 推荐指数：⭐️⭐️⭐️ PyCharm PyCharm是由JetBrains公司开发，也是最受欢迎的Python IDE工具。 官方网站：https://www.jetbrains.com/pycharm/ 优点是功能强大，你能想到的不能想到的它都给你提供了。 缺点是收费，并且软件本身比较臃肿，但是比起它的优秀来说这些缺点可以忽略不计。 推荐指数：⭐️⭐️⭐️⭐️⭐️ VsCode VsCode是由Microsoft Corporation开发，是近年来最火的一款轻量级编辑器。 官方网站：https://code.visualstudio.com/ 优点是支持多语言，Golang、C、Python等手到擒来，此外它是完全免费的。 缺点是配置比较繁琐，对新手不太友好。 推荐指数：⭐️⭐️⭐️⭐️ 个人使用 我自己平常写一些小的脚本，会首选VsCode，若是要搭建一些比较大型的项目，则会选择PyCharm。 在这里并没有详细指出每种工具的安装，因为互联网上类似的教程太多了。 推荐在初次接触Python时，建议统一使用Python IDLE，因为PyCharm本身会对Python许多地方做出优化，而恰好这些优化对新手并不友好。 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-05-15 21:21:59 "},"Python/Python快速入门/PEP8规范说明.html":{"url":"Python/Python快速入门/PEP8规范说明.html","title":"PEP8规范说明","keywords":"","body":"PEP8规范 每种语言都有其一种特定的书写规范，而PEP8规范则是Python中的书写规范。 以下的内容对于初学者来说可能会显得有些超纲，但是我为什么要将它放在第一章呢？就是为了警示你书写规范其实很重要。 尽管现在你可能看不懂，但是没有关系，你看得懂的时候就一定要去学会遵守它。 Ps：其实我自己就是一个不太遵守规范的家伙... 缩进与续行 每一级缩进使用4个空格，而不是使用table def main(): print(\"hello,world\") # --- def main(): print(\"hello,world\") 续行应该与其包裹元素对齐，要么使用圆括号、方括号和花括号内的隐式行连接来垂直对齐，要么使用挂行缩进对齐 def main( param1, param2, param3, param4 ): print(\"hello,world\") # --- def main(param1, param2, param3, param4 ): print(\"hello,world\") 分割与宽度 每行最大的字符数不可超过79，文档字符或者注释每行不可超过72 def main(): # this is a test function ... # this is a test function ... # this is a test function ... print(\"hello,world\") # --- def main(): # this is a test function ... this is a test function ... this is a test function ... print(\"hello,world\") 顶层函数和类的定义，前后用两个空行隔开，类里的方法定义用一个空行隔开 模块的导入 导入不同模块，应当进行分行 导入模块的位置应当总是位于文件顶部，且在头文件代码之后 标准库导入放最前、相关第三方库导入放其次，而后是本地库导入 每一组导入语句之间加入空行分割，以区分是内置库、三方库、还是自建库 推荐使用绝对导入 import sys import os # --- import sys, os 注释 在更改代码之前，推荐先更改注释 释应该是完整的句子。如果一个注释是一个短语或句子，它的第一个单词应该大写，除非它是以小写字母开头的标识符(永远不要改变标识符的大小写！) 如果注释很短，结尾的句号可以省略。块注释一般由完整句子的一个或多个段落组成，并且每句话结束有个句号 在句尾结束的时候应该使用两个空格 当用英文书写时，遵循Strunk and White （译注：《Strunk and White, The Elements of Style》）的书写风格 在非英语国家的Python程序员，请使用英文写注释，除非你120%的确信你的代码不会被使用其他语言的人阅读 块注释通常适用于跟随它们的某些（或全部）代码，并缩进到与代码相同的级别。块注释的每一行开头使用一个#和一个空格（除非块注释内部缩进文本）。 块注释内部的段落通过只有一个#的空行分隔 有节制地使用行内注释 行内注释是与代码语句同行的注释。行内注释和代码至少要有两个空格分隔。注释由#和一个空格开始 文档字符串 要为所有的公共模块，函数，类以及方法编写文档说明 非公共的方法没有必要，但是应该有一个描述方法具体作用的注释。这个注释应该在def那一行之后 PEP 257描述了写出好的文档说明相关的约定。特别需要注意的是，多行文档说明使用的结尾三引号应该自成一行，例如： \"\"\"Return a foobang Optional plotz says to frobnicate the bizbaz first. \"\"\" 对于单行的文档说明，尾部的三引号应该和文档在同一行 命名规范 应该避免的名字 永远不要使用字母‘l’（小写的L），‘O’（大写的O），或者‘I’（大写的I）作为单字符变量名 在有些字体里，这些字符无法和数字0和1区分，如果想用‘l’，用‘L’代替 类名 类名一般使用首字母大写的约定 在接口被文档化并且主要被用于调用的情况下，可以使用函数的命名风格代替 注意，对于内置的变量命名有一个单独的约定：大部分内置变量是单个单词（或者两个单词连接在一起），首字母大写的命名法只用于异常名或者内部的常量 函数名 函数名应该小写，如果想提高可读性可以用下划线分隔 大小写混合仅在为了兼容原来主要以大小写混合风格的情况下使用（比如 threading.py），保持向后兼容性 函数和方法参数 始终要将 self 作为实例方法的的第一个参数 始终要将 cls 作为类静态方法的第一个参数 如果函数的参数名和已有的关键词冲突，在最后加单一下划线比缩写或随意拼写更好。因此 class_ 比 clss 更好（也许最好用同义词来避免这种冲突） 编程建议 代码应该用不损害其他Python实现的方式去编写（PyPy，Jython，IronPython，Cython，Psyco 等） 比如，不要依赖于在CPython中高效的内置字符连接语句 a += b 或者 a = a + b 这种优化甚至在CPython中都是脆弱的（它只适用于某些类型）并且没有出现在不使用引用计数的实现中。在性能要求比较高的库中，可以用“”.join() 代替 这可以确保字符关联在不同的实现中都可以以线性时间发生 和像None这样的单例对象进行比较的时候应该始终用 is 或者 is not，永远不要用等号运算符 另外，如果你在写 if x 的时候，请注意你是否表达的意思是 if x is not None。举个例子，当测试一个默认值为None的变量或者参数是否被设置为其他值的时候。这个其他值应该是在上下文中能成为bool类型false的值 使用 is not 运算符，而不是 not … is 虽然这两种表达式在功能上完全相同，但前者更易于阅读，所以优先考虑 推荐： if foo is not None 不推荐： if not foo is None: Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-05-12 18:20:25 "},"Python/Python基础知识/summary.html":{"url":"Python/Python基础知识/summary.html","title":"Python基础知识","keywords":"","body":"本章节将开始正式的系统性Python介绍。 了解Python中如何组织数据，控制代码流程，以及数据模型的底层实现原理。 此外本章节中还介绍Python内存管理机制以及深浅拷贝。 所有源码分析均基于Python3.6版本，总体来说Python3版本的源码差异都不是很大，请放心食用。 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-05-14 17:50:48 "},"Python/Python基础知识/代码与注释.html":{"url":"Python/Python基础知识/代码与注释.html","title":"代码与注释","keywords":"","body":"代码注释 学习任何一门语言首要的就是学习它的注释。注释就是说你的脚本程序在运行过程中不会被解释器解释与执行的一部分，它的功能主要是给人阅读方便代码的后期维护。 在Python中（Python2和Python3均可），主要有3种注释方式，其中单行注释1种，多行注释2种。 #号注释 单个#号注释是属于单行注释，如下示例： # This is a single line comment 要注意的是，我们一般会在#后面添加上一个空格，如果#号前面有代码，一般会间隔两个空格。 print(\"HELLO,WORLD\") # 它将打印HELLO,WORLD -- - 三单引号注释 ''' '''三个单引号可以进行跨行注释，如下示例： def func(): ''' 用于进行一个功能的描述与说明 ''' pass 三双引号注释 \"\"\" \"\"\"三个双引号的注释与三个单引号的注释语义相同，基本上在能够使用三个单引号的地方都可以使用三个双引号： def func(): \"\"\" 用于进行一个功能的描述与说明 \"\"\" pass Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-05-12 18:32:46 "},"Python/Python基础知识/变量与常量.html":{"url":"Python/Python基础知识/变量与常量.html","title":"变量与常量","keywords":"","body":"标识符与对象 在Python中有一个核心的概念，叫做一切皆对象。 我们定义的数据、资源等皆可称之为对象，对象均存放在内存中。 而如果要使用这个对象，则必须通过标识符与对象进行绑定，为其取一个名字。 一般来讲，一次绑定分为三部分操作： 创建资源对象（值） 创建标识符（名字） 建立绑定关系（赋值符号） 如下所示： 整个绑定的过程，被称为常量\\变量赋值或者对象定义，用=号将标识符与对象进行链接。 如下所示，我们用多个对象表示一个人的信息： name = \"yunya\" age = 18 height = 1.92 print(\"姓名:%s\\n年龄:%s\\n身高:%s\\n\"%(name, age, height)) # 姓名:yunya # 年龄:18 # 身高:1.92 先定义后使用 对象必须先定义，后使用，如果未定义就使用则会抛出异常。 print(\"这位帅哥的名字是:\",name) name = \"yunya\" # NameError: name 'name' is not defined 命名风格 下面介绍几种常用的标识符命名方式： Camel-Case之小驼峰式：个人比较喜欢的风格，但是Python中并不建议使用小驼峰。 单词开头的字母小写，而后每个单词的分割首字母采用大写形式： userAge = 18 Camel-Case之大驼峰式：大驼峰式在Python中比较常见，一般定义类名时使用，不要滥用大驼峰。 每个单词都首字母都大写 UserInfo = {} 匈牙利类型标记法：前面的小写字母为变量类型，如，i代表int类型、s代表str类型： iUserAge = 18 蛇形命名法：小写+下划线，是Python中更推荐使用的标识符命名方式： user_age = 18 命名规范 表示符的命名需要遵从以下规范： 标识符应当见名知意 标识符由数字，字母，下划线组成。并且开头不能为数字 标识符不能使用Python中的关键字（关键字：是指某些具有特殊功能的单词，如break） 错误的示范： $name = 'yunya' # 具有特殊字符 1year = 365 # 数字开头 *_size = 1024 # 具有特殊字符 and = 123 # 使用了关键字 年级 = 3 # 强烈不建议使用中文（占用内存大） (color) = 'red' # 虽然这种命名方式可行但是也极为不推荐 正确的示范： name = 'yunya' __age = 18 # ① page_1 = '首页' ①：Python中双下划线开头的标识符一般有隐私的这种说法，因此一般不建议使用 同时，个人十分不推荐在标识符中加上任何的数字，这样的做法显得很莽撞。如item1，item2等... 绑定映射 Python中所有的数据均被称之为对象（object），对象存放至堆（heap）区内存中。 在堆区内存中Python会为其分配具体的内存空间，此地址即为对象在内存中的存放位置。 而在栈（stack）区内存中，则存放对象的引用（reference），即对象在堆内存中的地址。 当一个对象被赋值给一个标识符后，在栈区内存中会创建一种映射（mapping）关系，此时标识符和对象就建立了联系，并且标识符本身也会被存放至栈区内存中。 name = \"yunya\" # 记录姓名 age = 18 # 记录年龄 height = 1.92 # 记录身高 盒子声明 在很多其他的编程语言中，声明一个数据的过程可以被称作盒子声明，当遇到赋值操作时，它会进行如下的流程： 创建一个具体的盒子（开辟内存，创建盒子，并且为盒子打上标识） 放入具体的数据（将对象放入盒子中） 而在Python中，则没有盒子声明这种说法，我更喜欢将它称作贴纸声明，当遇到赋值操作时，它会进行如下的流程： 先创建一个对象（自动在遇到=符号时，开辟内存并创建对象，如果该对象已存在，则进行引用） 将=符号左侧的标识符与对象绑定（像贴纸一样） 两者对比一下： 其他编程语言中总是先进行标识符盒子的初始化，再之后将数据对象放入盒子中 Python中总是先创建对象，并且再将标识符与对象做绑定 如下图所示： 引用传递 Python中所有的标识符与对象的绑定均为引用，不论是函数传参，单纯赋值等，标识符都与对象的内存地址做绑定，而不和对象本身的值做绑定。 Python中一个对象可以被多个标识符所引用，而一个标识符仅能引用一个对象。 你可以理解为Python中所有数据类型均为引用类型，没有值类型。 如下所示，我们将声明2个不同的标识符，标识符都指向了同一个int对象： oldAge = 18 newAge = oldAge print(id(oldAge)) print(id(newAge)) # 4550527568 # 4550527568 如下图所示： 在Golang中，如果进行上面的操作，因为盒子声明的缘故新的标识符newAge会创建出一片新的内存空间，并且将oldAge的值进行一次拷贝后存放至新内存空间中： package main import \"fmt\" func main() { var oldAge int = 18 var newAge int = oldAge fmt.Println(oldAge, &oldAge) fmt.Println(newAge, &newAge) } // 18 0xc42008e168 // 18 0xc42008e190 如下图所示： 变量 变量指的是该标识符所绑定的对象允许在运行时刻发生变化，是用来记录事物变化状态的一种东西。 举个例子： 进入游戏：等级为0 一天之后：等级为10 一月之后：等级为100 标识符（等级）与表示等级的对象所绑定，并且该等级在不断的变化，那么这就是一个变量： # 进入游戏 level = 0 # 一天后 level = 10 # 一月后 level = 100 # 现在的等级 print(level) # 100 变量命名 变量标识符的命名一般以蛇形命名法和小驼峰命名法为准。 不可使用大驼峰式命名法，同时全大写命名法也不要进行使用。 匿名变量 如果一个变量标识符为_，则代表该变量为匿名变量。 匿名变量的作用是当做一个垃圾桶，对于一些不会用到的对象可以命名为_，仅做到一个占位的作用，这在解构赋值中经常会被使用到。 其实官方没有匿名变量的定义，这也是Python社区中一条不成文的规定，因为实在是懒得对一个不用的对象想名字，干脆就用_进行命名。 常量 常量指的是该标识符所绑定的对象不允许在运行时刻发生变化，表示一个恒定的数据。 举个例子： 圆周率PI是恒定的，不能因为程序的运行而改变 人的性别是恒定的，不能因为程序的运行而改变 很遗憾，在应用领域来说Python并未提供常量的定义，但是在Python社区中有一个不成文的规定。 如果一个标识符所有字母都是大写的话，则认为该标识符是常量标识符： PI = 3.1415926535897 SEX = \"男\" 常量池 上面说过，尽管在应用领域中Python并未提供常量的定义，但是在内部实现中处处可见常量的影子。 如小整数常量池就是一个很好的例子。 在其他的编程语言，类似Golang、JavaScript中，常量定义的关键词为const，很快你也会在Python中见到这个单词。 相关方法 id() 使用id()函数可拿到标识符所对应对象在堆区内存中的地址号。 name = \"yunya\" print(id(name)) # 2933298725640 type() 使用type()函数可获取到该标识符对应对象的数据类型。 name = \"yunya\" print(type(name)) # del 使用del跟上标识符名字，将对该标识符所关联的对象进行解绑操作，同时也会取消该标识符的定义，将其从栈区内存中抹去。 name = \"yunya\" del name print(name) # NameError: name 'name' is not defined Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-05-14 21:18:09 "},"Python/Python基础知识/整形与浮点型.html":{"url":"Python/Python基础知识/整形与浮点型.html","title":"整形与浮点型","keywords":"","body":"整形 整形概述 Python中对于整形的划分非常简单，仅仅只有一个int类型。 整形是不可变类型，即对象本身的属性不会根据外部变化而变化 整形属于原子类型，即不可被分割 基本声明 以下是使用类实例化的形式进行对象声明： age = int(12) print(\"值:%r,类型：%r\" % (age, type(age))) # 值:12,类型： 也可以选择使用更方便的字面量形式进行对象声明： age = 12 print(\"值:%r,类型：%r\" % (age, type(age))) # 值:12,类型： 类型转换 整形可以与布尔型，浮点型，字符串等做转换，使用对应的构造函数即可： num = 1 strNum = str(num) boolNum = bool(num) floatNum = float(num) print(\"值：%r,类型：%r\" % (strNum, type(strNum))) print(\"值：%r,类型：%r\" % (boolNum, type(boolNum))) print(\"值：%r,类型：%r\" % (floatNum, type(floatNum))) # 值：'1',类型： # 值：True,类型： # 值：1.0,类型： 进制转换 使用以下三个内置函数，可进行进制转换： 函数名 描述 bin() 十进制转二进制 oct() 十进制转八进制 hex() 十进制转十六进制 示例如下： num = 100 print(bin(num)) print(oct(num)) print(hex(num)) # 0b1100100 # 0o144 # 0x64 如果想二进制、八进制、十六进制转换十进制，则可通过指定int()的第二参数base实现，如下所示： print(int(\"0b1100100\", base=2)) print(int(\"0o144\", base=8)) print(int(\"0x64\", base=16)) # 100 # 100 # 100 ASCII转换 使用以下两个内置函数，可进行任意单字符的ASCII码转换： 函数名 描述 chr() 根据字符，转换为ASCII码 ord() 根据ASCII码，转换为字符 示例如下： >>> chr(65) 'A' >>> ord(\"A\") 65 long类型 在Python2中，如果整形后面加上L则代表长整型，在Python3中取消了这种设定。 >>> num = 100L >>> type(num) 浮点型 浮点型概述 Python中对于浮点型的划分非常简单，仅仅只有一个float类型。 浮点形是不可变类型，即对象本身的属性不会根据外部变化而变化 浮点形属于原子类型，即不可被分割 基本声明 以下是使用类实例化的形式进行声明： f = float(3.15) print(\"值:%f,类型:%r\" % (f, type(f))) # 值:3.150000,类型: 也可以选择使用更方便的字面量形式： f = 3.15 print(\"值:%f,类型:%r\" % (f, type(f))) # 值:3.150000,类型: 类型转换 浮点形可以与布尔型、整型、字符串等做转换，使用对应的构造函数即可： num = 1.9 strNum = str(num) boolNum = bool(num) intNum = int(num) print(\"值：%r,类型：%r\" % (strNum, type(strNum))) print(\"值：%r,类型：%r\" % (boolNum, type(boolNum))) print(\"值：%r,类型：%r\" % (intNum, type(intNum))) # 值：'1.9',类型： # 值：True,类型： # 值：1,类型： 四则运算 整形与浮点型均支持四则运算。 但是需要注意的是当整形与浮点型进行运算后，所得到的结果必然是浮点型： print(100 * 1.0) # 100.0 同时，整形也可以与字符串进行乘法运算： print(\"hello\" * 3) # hellohellohello 他两都支持与布尔型进行运算，布尔型的本质就是1和0，这里不再例举。 _的形式 在Python3中提供了对数字的_分割表现形式。 旨在更加方便阅读大数字： >>> a = 100_00 >>> a 10000 >>> b = 100_00.1 >>> b 10000.1 强类型 由于Python是强类型语言，故不会出现隐式转换的问题（Python2中是允许字符串与数字做比较的，且数字永远小于字符串）。 如下，使用整形与字符串做对比，返回的结果永远是False。 print(\"100\" == 100) # False 但是整形可以和浮点型做比较，因为它们同属于数值类型： print(100.00 == 100) # True 他两都支持与布尔型进行比较，布尔型的本质就是1和0，这里不再例举。 小整数池 Python解释器觉得有一些整数会经常被使用（-5到255之间），故当脚本程序运行前就将这些数字写入堆区内存中。 当用户定义int对象且使用到其中的数值时会直接将该数值的内存地址引用到存在于栈内存的变量标识符上，这样做极大节省了内存空间。 如：一个程序中使用了100000次1这个数值，那么如果没有Python的这个机制则会开辟出100000个内存空间用来存放相同的数值。 这么做显然极大的浪费了内存。 故Python的这种机制是十分高效且合理的，并且它的名字叫做小整数常量池，或简称为小整数池（范围：-5,255）： int_1 = 1 int_2 = 1 print(id(int_1)) # 1558801440 print(id(int_2)) # 1558801440 # 超出小整数池范围 int_3 = -6 int_4 = -6 print(id(int_3)) # 2264143854288 print(id(int_4)) # 2264143854448 绝对引用 数值拥有绝对引用的特性，无论是深拷贝还是浅拷贝，都不会获得其副本，而是直接对源对象进行引用： >>> import copy >>> oldN = 1_0000 >>> id(oldN) 4373791728 >>> n1 = copy.copy(oldN) >>> id(n1) 4373791728 >>> n2 = copy.deepcopy(oldN) >>> id(n2) 4373791728 声明速率 时间对比 对于所有的Python内置数据模型来说，字面量形式的对象声明永远要比类实例化的形式对象声明速度要快。 时间差大约3倍或者更多，我们可以做一个小实验来观察，使用timeit模块检测2者时间差： $ python3 -m timeit -n 1000000 -r 5 -v \"int(1)\" raw times: 0.138 0.136 0.135 0.152 0.16 1000000 loops, best of 5: 0.135 usec per loop $ python3 -m timeit -n 1000000 -r 5 -v \"1\" raw times: 0.00974 0.00961 0.0107 0.0107 0.00991 1000000 loops, best of 5: 0.00961 usec per loop ① -n 语句执行多少次 ② -r 重复计时器的次数，默认为5 可以看类实例化声明1百万次int类型时长为0.135秒。 而字面量形式声明1百万次int类型时长为0.00961秒。 整个差距居然有14倍！当然，如果是一些复杂的类型声明，这个差距会变小。 底层探究 为什么会出现这样的情况，可以使用dis模块来探索，该模块会通过反汇编来查看到语句执行情况的字节码。 $ echo \"int(1)\" > demo.py $ python3 -m dis demo.py 1 0 LOAD_NAME 0 (int) 2 LOAD_CONST 0 (1) 4 CALL_FUNCTION 1 6 POP_TOP 8 LOAD_CONST 1 (None) 10 RETURN_VALUE $ echo \"1\" > demo.py $ python3 -m dis demo.py 1 0 LOAD_CONST 0 (None) 2 RETURN_VALUE 使用类实例化声明对象时，必定会调用到底层函数__init__()，而调用函数的过程会发起系统调用栈的进出栈操作，故更加耗时。 此外，我们也从上面的LOAD_CONST可以观察出，int类型小整数1确实会从小整数常量池中加载数据。 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-05-13 09:53:07 "},"Python/Python基础知识/列表类型.html":{"url":"Python/Python基础知识/列表类型.html","title":"列表类型","keywords":"","body":"列表 Python中的列表（list）是最常用的数据类型之一。 Python中的列表可以存储任意类型的数据，这与其他语言中的数组（array）不同。 被存入列表中的内容可称之为元素（element）或者数据项（data item）亦或是值（value）。 虽然Python列表支持存储任意类型的数据项，但不建议这么做，事实上这么做的概率也很低。 列表特性 列表特性如下： 列表属于容器序列 列表属于可变类型，即对象本身的属性会根据外部变化而变化，例如长度 列表底层由顺序存储组成，而顺序存储是线性结构的一种 基本声明 以下是使用类实例化的形式进行对象声明： li = list((1, 2, 3, 4, 5)) print(\"值:%r,类型：%r\" % (li, type(li))) # 值:[1, 2, 3, 4, 5],类型： 也可以选择使用更方便的字面量形式进行对象声明，利用[]对数据项进行包裹，并且使用逗号将数据项之间进行分割： li = [1, 2, 3, 4, 5] print(\"值:%r,类型：%r\" % (li, type(li))) # 值:[1, 2, 3, 4, 5],类型： 多维列表 当一个列表中嵌套另一个列表，该列表就可以称为多维列表。 如下，定义一个2维列表： li = [1, 2, [\"三\",\"四\"]] print(\"值:%r,类型：%r\" % (li, type(li))) 值:[1, 2, ['三', '四']],类型： 续行操作 在Python中，列表中的数据项如果过多，可能会导致整个列表太长，太长的列表是不符合PEP8规范的。 每行最大的字符数不可超过79，文档字符或者注释每行不可超过72 Python虽然提供了续行符\\，但是在列表中可以忽略续行符，如下所示： li = [ 1, 2, 3, 4, 5 ] print(\"值:%r,类型：%r\" % (li, type(li))) # 值:[1, 2, 3, 4, 5],类型： 类型转换 列表支持与布尔型、字符串、元组、以及集合类型进行类型转换： li = [1, 2, 3] bLi = bool(li) # 布尔类型 strLi = str(li) # 字符串类型 tupLi = tuple(li) # 元组类型 setLi = set(li) # 集合类型 print(\"值:%r,类型：%r\" % (bLi, type(bLi))) print(\"值:%r,类型：%r\" % (strLi, type(strLi))) print(\"值:%r,类型：%r\" % (tupLi, type(tupLi))) print(\"值:%r,类型：%r\" % (setLi, type(setLi))) # 值:True,类型： # 值:'[1, 2, 3]',类型： # 值:(1, 2, 3),类型： # 值:{1, 2, 3},类型： 如果一个2维列表遵循一定的规律，那么也可以将其转换为字典类型： li = [[\"k1\", \"v1\"], [\"k2\", \"v2\"], [\"k3\", \"v3\"]] dictList = dict(li) print(\"值:%r,类型：%r\" % (dictList, type(dictList))) # 值:{'k1': 'v1', 'k2': 'v2', 'k3': 'v3'},类型： 四则运算 列表支持与元组，列表进行加法运算： +：合并2个列表并生成新列表： li1 = [1, 2, 3] li2 = [4, 5, 6] newLi = li1 + li2 print(newLi) # [1, 2, 3, 4, 5, 6] +=：扩展已有列表，相当于extend()方法： oldLi = [1, 2, 3] newLi = [4, 5, 6] oldLi += newLi print(oldLi) # [1, 2, 3, 4, 5, 6] 列表支持与数字进行乘法运算： *：生成一个重复旧列表数据项的新列表： oldLi = [1, 2, 3] newLi = oldLi * 3 print(newLi) # [1, 2, 3, 1, 2, 3, 1, 2, 3] *=：扩展已有列表，将已有列表的数据项进行重复添加： oldLi = [1, 2, 3] oldLi *= 3 print(oldLi) # [1, 2, 3, 1, 2, 3, 1, 2, 3] 索引切片 索引的概念 列表底层是以一种连续的顺序结构存储数据项，故可以使用索引（index）对数据项进行获取、删除、截取、替换等操作。 ----------------------------| | A | B | C | D | E | F | G | ----------------------------| | 0 | 1 | 2 | 3 | 4 | 5 | 6 | |-7 |-6 |-5 |-4 |-3 |-2 |-1 | 正向索引都是从0开始，负向索引都是从-1开始。 enumerate() 我们以一个内置函数enumerate()来举例，该函数返回一个迭代器，将其转换为list()后可以查看数据项以及正向索引： li = [\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\"] print(list(enumerate(li))) # [(0, 'A'), (1, 'B'), (2, 'C'), (3, 'D'), (4, 'E'), (5, 'F'), (6, 'G')] 更多的关于enumerate()函数的妙用，将会放在循环章节中进行探讨。 slice() slice()函数有三个参数： start：索引开始的位置 stop：索引结束的位置 step：步长间距，默认为1 如果为正数代表正取，如果为负数代表倒取 如果为1代表连续取，如果为2代表隔一个取一个，以此类推 使用方法如下示例，先使用slice()确定截取数据项的范围，然后再使用列表的[]操作形式取出指定范围的数据项。 注意：所有的切片都是顾头不顾尾： li = [\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\"] # 取出A # 释义：从0开始取，取1个，步长为0 s = slice(0, 1, None) print(li[s]) # ['A'] [::]形式 使用slice()函数会比较繁琐，直接使用[::]形式进行切片会比较简单。 签名如下： [start:stop:step] 参数描述和slice()相同，当某一参数不设置时可省略前面的参数。 增删改截操作演示： >>> # 获取第2个数据项 >>> li = [\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\"] >>> li[1] 'B' >>> # 删除第3个数据项 >>> del li[2] >>> li ['A', 'B', 'D', 'E', 'F', 'G'] >>> # 从第1个数据项开始向后替换2个数据项，替换内容为123 >>> li[0:3] = 1,2,3 >>> li [1, 2, 3, 'E', 'F', 'G'] >>> # 从第1个数据项开始获取2个数据项 >>> li[0:3] [1, 2, 3] >>> # 试图访问一个超出索引之外的数据项，将引发异常 >>> li[100] IndexError: list index out of range 需要注意的是，如果使用[:]则会创建一个新的列表，再将原有列表中的数据项全部引用至新的列表中，类似于浅拷贝的概念。 如下所示： l1 = [\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\"] l2 = l1[:] print(\"值:%s，地址:%s\" % (l1, id(l1))) print(\"值:%s，地址:%s\" % (l2, id(l2))) # 值:['A', 'B', 'C', 'D', 'E', 'F', 'G']，地址:4366350216 # 值:['A', 'B', 'C', 'D', 'E', 'F', 'G']，地址:4366660104 正向切片 正向切片即使用正向索引，索引从0开始进行切片。 如下示例： >>> li = [\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\"] >>> li[0:3] ['A', 'B', 'C'] 反向切片 反向切片即使用反向索引，索引从-1开始进行切片。 如下示例： >>> li = [\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\"] >>> li[-3:] ['E', 'F', 'G'] 多维切片 列表是支持多维切片的，如下示例，拿出2维列表中的数据项A： >>> li = [1, 2, [\"A\", \"B\"]] >>> li[-1][0] 'A' 高级切片 反向和正向切片可以混合使用，下面是一些高级切片的用法： >>> li = [\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\"] >>> li[:] ① ['A', 'B', 'C', 'D', 'E', 'F', 'G'] >>> li[2:4] ② ['C', 'D'] >>> li[::2] ③ ['A', 'C', 'E', 'G'] >>> li[::-2] ['G', 'E', 'C', 'A'] ④ >>> li[::-1] ⑤ ['G', 'F', 'E', 'D', 'C', 'B', 'A'] >>> li[:-5:-2] ⑥ ['G', 'E'] >>> li[0::-1] ⑦ ['A'] >>> li[5::-2] ⑧ ['F', 'D', 'B'] 如何一眼读懂高级切片，通过以下步骤判定： 第一步先观察step，是负数还是正数，负数代表倒着取 第二步观察start，确定切片的开始位置 第三步观察stop，确定切片的结束位置 上述示例演示的说明，带*的是比较重要的方式。 ①：列表的[:]操作是创建一个新的列表，再将原有列表中的数据项全部引用一次至新的列表* ②：步长为空，代表正着取，从第2号索引位置的数据项开始，到第4号索引位置的数据项结束，根据顾头不顾尾原则，取2，3号索引的数据项* ③：步长为2，代表正着取，隔一个取一个，即从0号索引位置的数据项开始，每次往后数到2的时候再取* ④：步长为-2，代表倒着取，隔一个取一个，即从-1号索引位置的数据项开始，每次向前数到2的时候再取* ⑤：步长为-1，代表倒着取，即从-1号索引位置的数据项开始，取到索引0号位置结束* ⑥：步长为-2，代表倒着取，隔一个位置取一个，取到-5索引位置结束，根据顾头不顾尾原则，不取-5索引位置的数据项 ⑦：步长为-1，代表倒着取，开始位置为0，结束位置未标记，则取1个 ⑧：步长为-2，代表倒着取，隔一个取一个，开始位置为5号索引，则从第5号索引开始向前取 解构方法 *语法 使用*语法可对列表进行解构，将列表中的数据项全部提取出来： li = [1, 2, 3] print(*li) # 1 2 3 我们可以利用*语法的特性，来达到两个列表进行合并产生新列表的效果，类似于+： l1 = [1, 2, 3] l2 = [4, 5, 6] result = [*l1, *l2] print(result) # [1, 2, 3, 4, 5, 6] 解构赋值 如果一个列表中的数据项需要赋值到变量中，可使用解构赋值，需要注意的是变量接收位置与列表中的数据项位置需要一一对应： li = [\"A\", \"B\"] item1, item2 = li print(item1, item2) # A B 我们只想取出列表中前2个数据项时，可使用*语法将剩下的数据项全部打包到一个变量中： li = [\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\"] item1, item2, *otherItems = li print(item1, item2) print(otherItems) # A B # ['C', 'D', 'E', 'F', 'G'] 如果只想取第1个后和最后2个，中间的都不想要怎么办？也可以通过*语法： li = [\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\"] itemFirst, *_, itemLast1, itemLast2 = li # ① print(itemFirst, itemLast1, itemLast2) print(_) # A F G # ['B', 'C', 'D', 'E'] ①：_为匿名变量，参见变量与常量一章节中的释义 常用方法 方法一览 常用的list方法一览表： 方法名 返回值 描述 append() None 将数据项添加至列表的末尾 extend() None 通过附加来自可迭代对象的数据项来扩展列表 insert() None 在索引之前插入对象 pop() item 删除并返回索引处的项目（默认为-1）。如果列表为空或索引超出范围，则引发IndexError copy() list 返回L的浅拷贝 remove() None 删除列表中第一次出现的数据项。如果不存在该数据项，则引发ValueError clear() None 从L移除所有项目 count() integer 返回数据项在L中出现的次数 index() integer 返回第一个数据项在L中出现位置的索引，若值不存在，则抛出ValueError sort() None 对列表进行原地排序，可指定参数reverse，若不指定该参数则默认升序排列，指定该参数则为降序排列 基础公用函数： 函数名 返回值 描述 len() integer 返回容器中的项目数 enumerate() iterator for index, value of iterable 返回一个可迭代对象，其中以小元组的形式包裹数据项与正向索引的对应关系 reversed() ... 详情参见函数章节 sorted() ... 详情参见函数章节 获取长度 使用len()方法来获取列表的长度。 返回int类型的值。 li = [\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\"] print(len(li)) # 7 Python在对内置的数据类型使用len()方法时，实际上是会直接的从PyVarObject结构体中获取ob_size属性，这是一种非常高效的策略。 PyVarObject是表示内存中长度可变的内置对象的C语言结构体。 直接读取这个值比调用一个方法要快很多。 追加元素 使用append()方法为当前列表追加一个数据项。 返回None： li = [\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\"] li.append(\"H\") print(li) # ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H'] 你也可以使用+=进行操作，但个人并不推荐这样使用。 在某些极端情况下，可能会出现一些难以察觉的Bug： li = [\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\"] li += \"H\" print(li) # ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H'] 列表合并 使用extend()方法来让当前列表与另一个可迭代对象进行合并。 返回None： l1 = [\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\"] l2 = [\"H\", \"J\", \"K\", \"L\"] l1.extend(l2) print(l1) # ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'J', 'K', 'L'] 你也可以使用+=进行操作，但个人并不推荐这样使用。 在某些极端情况下，可能会出现一些难以察觉的Bug： l1 = [\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\"] l2 = [\"H\", \"J\", \"K\", \"L\"] l1 += l2 print(l1) # ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'J', 'K', 'L'] 插入元素 使用insert()方法将数据项插入当前列表中的指定位置。 返回None： li = [\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\"] li.insert(0, \"a\") print(li) # ['a', 'A', 'B', 'C', 'D', 'E', 'F', 'G'] 列表拷贝 使用copy()方法将当前列表进行浅拷贝。 返回当前列表的拷贝对象： oldLi = [\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\"] newLi = oldLi.copy() print(oldLi) print(newLi) print(id(oldLi)) print(id(newLi)) print(id(oldLi[0])) print(id(oldLi[0])) # ['A', 'B', 'C', 'D', 'E', 'F', 'G'] # ['A', 'B', 'C', 'D', 'E', 'F', 'G'] # 4329305992 # 4329607688 # 4328383520 # 4328383520 弹出元素 使用pop()方法弹出当前列表中在此索引位置的数据项，列表中该数据项将被删除，并返回被弹出的数据项。 若不指定位置，则默认弹出-1号索引位置的数据项： li = [\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\"] popItem1 = li.pop() popItem2 = li.pop(2) print(li) print(popItem1) print(popItem2) # ['A', 'B', 'D', 'E', 'F'] # G # C 删除元素 使用remove()方法删除当前列表中的数据项，根据数据项的名字进行删除。 如果具有多个同名的数据项，则只会删除第一个。 返回None： li = [\"A\", \"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\"] li.remove(\"A\") print(li) # ['A', 'B', 'C', 'D', 'E', 'F', 'G'] 我们也可以使用del li[index]进行数据项的删除： li = [\"A\", \"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\"] del li[0] print(li) # ['A', 'B', 'C', 'D', 'E', 'F', 'G'] 这种方式还可以删除多个： li = [\"A\", \"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\"] del li[0:3] print(li) # ['C', 'D', 'E', 'F', 'G'] 清空元素 使用clear()方法将当前列表进行清空，即删除所有数据项。 返回None： li = [\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\"] li.clear() print(li) # [] 我们也可以使用del li[:]进行列表的清空： li = [\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\"] del li[:] print(li) # [] 统计次数 使用count()方法统计数据项在该列表中出现的次数。 返回int： li = [\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\", \"A\"] aInLiCount = li.count(\"A\") print(aInLiCount) # 2 查找位置 使用index()方法找到数据项在当前列表中首次出现的位置索引值，如数据项不存在则抛出异常。 返回int。 li = [\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\", \"A\"] aInLiIndex = li.index(\"A\") print(aInLiIndex) # 0 顺序排列 使用sort(li)将当前列表中的数据项按照ASCII码顺序进行排列，默认从小到大。 可指定参数resverse，用于是否翻转列表，如翻转列表则代表从大到小。 返回None： li = [\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\", \"A\"] li.sort(reverse=True) print(li) # 'G', 'F', 'E', 'D', 'C', 'B', 'A', 'A'] sort()方法内部采用timsort算法，这是一种非常优秀的算法，速度快且稳定。 底层探究 容器序列 这里引出一个新的概念，容器序列： 容器中能存放不同类型的数据项，如list就是标准的一个容器 序列是指具有长度的对象，且该对象能使用[]进行内部数据项的操作 容器序列存放的是它们所包含的任意类型的对象的引用，如下定义了一个列表： x = [“A”, “B”, “C”] 它的内部存储结构如下图所示： 在CPython源码中，列表数据项的引用为PyObject **ob_item属性，即指针的指针。 元素调整 列表中，pop()和insert()方法都具有指定索引值的功能。 如果使用pop(0)，或者insert(0)则都会引起整个列表中数据项的调整。 pop(0)会将队首的数据项弹出并删除，后面的所有数据项都要向前挪一个位置。1变成0，2变成1，以此类推 insert(0)会将新的数据项插入至队首，后面的所有数据项都要向后挪一个位置。0变成1，1变成2，以此类推 而单纯的使用pop()或者append()则不会发生数据项调整，因为它们总是在队尾做操作。 总而言之，任何一个方法只要不是操作的队尾数据项，都会引起该列表中其他所有数据项的调整。 图示如下： 扩容机制 在对列表进行添加数据项时，如果列表内部的容量已满则会触发扩容机制。 我们要理解2个概念： 容量：容量指的是列表底层在开辟内存时，开辟了多大的内存空间，能够容纳多少数据项，可以理解为一共有多少个槽位 大小：大小指的是当前列表中，数据项已占据的容量，可以理解为已用了多少个槽位 在CPython源码中，列表容量的属性为Py_ssize_t allocated，而列表大小的属性为Py_ssize_t ob_size 在初始化列表时，容量和大小总是等于数据项的总个数，如： 一个空列表，容量和大小都为0 有8个槽位的列表，容量和大小都为8 如果对一个已有的列表进行增加数据项的操作时会有以下2条判断，判定当前列表是否需要扩容： 当前列表容量 > 已有数据项个数+1 and 已有数据项个数 >= 当前列表容量的一半 则直接添加数据项，不进行扩容 并且新增数据项个数 Py_ssize_t ob_size + 1 当前列表容量 则先进行扩容后再添加数据项 扩容是一种线性增长，增长规律为：0、4、8、16、24、32、40、52、64、76 …，总是为4的倍数 在扩容时不必担心发生内存溢出，因为内部已经设置了最大值 为：PY_SSIZE_T_MAX *（9/8）+ 6 缩容机制 缩容机制建立在列表有空余空间的情况下。 我们如果使用pop()方法删除了最后一个数据项，其实并不会将最后一个列表槽位所占用的内存空间给释放掉而是进行保留，内部仅进行一次Py_ssize_t ob_size - 1的操作。 这样做的好处是，后面再添加数据项时，其实就不用再次进行扩容了。 但是在添加数据项之前，会判断整个列表的容量是否过大，如果过大即代表还有很多空的位置，此时要进行缩容机制： 如果数据项个数 + 1 则进行缩容，删除空的列表槽位 如果是clear()清空列表中的数据项，则直接非常干脆的将容量以及大小都重置为0，并且将该列表所有槽位占据的内存空间进行释放。 迁徙机制 因为列表底层是顺序存储，必须占用一个连续的内存空间。 如果在进行扩容时，发现后面连续的内存空间被其他对象所占据，则会将整个列表进行一次拷贝。 然后迁徙到新的位置开辟内存，确保所有的列表槽位都是连续的。 列表缓存 当删除一个列表之后，会将该列表中槽位引用的数据项地址全部清空。 并且将该列表的引用存放至一个叫做free_list的缓存中，下次如果再需要创建列表，则直接从free_list缓存中获取。 free_list最多可以缓存80个列表 示例，旧列表被删除后将空列表的引用存放至free_list缓存中，当再次创建一个新列表时，会直接从free_list缓存中获取旧列表，并且填入数据项： li1 = [1, 2, 3] print(id(li1)) del li1 li2 = [4, 5, 6, 7] print(id(li2)) # 4405732936 # 4405732936 listobject.c源码 官网参考：点我跳转 源码一览：点我跳转 以下是截取了一些关键性源代码，并且做上了中文注释，方便查阅。 每一个列表都有几个关键性的属性： Py_ssize_t ob_refcnt; // 引用计数器 PyObject **ob_item; // 列表内部槽位的数据项指针，即指针的指针 Py_ssize_t ob_size; // 列表大小 Py_ssize_t allocated; // 列表容量 创建列表 PyObject * PyList_New(Py_ssize_t size) { // 空列表 if (size numfree != -1); #endif // 判断是否有free_list中是否有缓存 if (state->numfree) { // 有缓存，free_list缓存的列表个数减1 state->numfree--; op = state->free_list[state->numfree]; // 建立新的引用关系 _Py_NewReference((PyObject *)op); } else { // 无缓存，创建新列表，先开辟内存 op = PyObject_GC_New(PyListObject, &PyList_Type); if (op == NULL) { return NULL; } } if (size ob_item = NULL; } else { // 如果列表不是空的，则将每个槽位的数据项地址进行引用 op->ob_item = (PyObject **) PyMem_Calloc(size, sizeof(PyObject *)); if (op->ob_item == NULL) { Py_DECREF(op); return PyErr_NoMemory(); } } // 设置列表中数据项占据的容量大小 Py_SET_SIZE(op, size); // 设置列表的整体容量 op->allocated = size; // 将列表放入双向链表中以进行内存管理 _PyObject_GC_TRACK(op); // 返回列表的结构体指针 return (PyObject *) op; } 添加元素 static int app1(PyListObject *self, PyObject *v) { // 获取列表的大小（已占用容量） Py_ssize_t n = PyList_GET_SIZE(self); assert (v != NULL); assert((size_t)n + 1 static int list_resize(PyListObject *self, Py_ssize_t newsize) { PyObject **items; size_t new_allocated, num_allocated_bytes; Py_ssize_t allocated = self->allocated; /* Bypass realloc() when a previous overallocation is large enough to accommodate the newsize. If the newsize falls lower than half the allocated size, then proceed with the realloc() to shrink the list. */ // 扩容、缩容机制调用realloc()函数 // allocated = 容量 // newsize代表已存在的数据项个数 + 1 // 当前列表容量 > 已有数据项个数+1 and 已有数据项个数 >= 当前列表容量的一半 if (allocated >= newsize && newsize >= (allocated >> 1)) { assert(self->ob_item != NULL || newsize == 0); // 则直接添加数据项，不进行扩容 // 并新增数据项个数 Py_ssize_t ob_size + 1 Py_SET_SIZE(self, newsize); return 0; } /* This over-allocates proportional to the list size, making room * for additional growth. The over-allocation is mild, but is * enough to give linear-time amortized behavior over a long * sequence of appends() in the presence of a poorly-performing * system realloc(). * Add padding to make the allocated size multiple of 4. * The growth pattern is: 0, 4, 8, 16, 24, 32, 40, 52, 64, 76, ... * Note: new_allocated won't overflow because the largest possible value * is PY_SSIZE_T_MAX * (9 / 8) + 6 which always fits in a size_t. */ new_allocated = ((size_t)newsize + (newsize >> 3) + 6) & ~(size_t)3; /* Do not overallocate if the new size is closer to overallocated size * than to the old size. */ // 如果数据项个数 + 1 (Py_ssize_t)(new_allocated - newsize)) new_allocated = ((size_t)newsize + 3) & ~(size_t)3; // 全是空的 if (newsize == 0) new_allocated = 0; num_allocated_bytes = new_allocated * sizeof(PyObject *); // 基于realloc()进行扩容或者缩容，内部会包含数据项的位置调整 items = (PyObject **)PyMem_Realloc(self->ob_item, num_allocated_bytes); if (items == NULL) { PyErr_NoMemory(); return -1; } // 重新设置列表的 ob_item、obsize、allocated self->ob_item = items; Py_SET_SIZE(self, newsize); self->allocated = new_allocated; return 0; } 插入元素 static int ins1(PyListObject *self, Py_ssize_t where, PyObject *v) { // 获取数据项个数 Py_ssize_t i, n = Py_SIZE(self); PyObject **items; // 插入数据项确保不是NULL if (v == NULL) { PyErr_BadInternalCall(); return -1; } assert((size_t)n + 1 n) where = n; // 拿到列表中所有数据项的引用 items = self->ob_item; // 让插入位置之后的所有数据项开始向后挪动1个位置，腾出位置来插入新的数据项 for (i = n; --i >= where; ) // i + 1指的是数据项指针地址，每次 - 1 items[i+1] = items[i]; // 新增数据项的引用计数 + 1 Py_INCREF(v); // 新的数据项索引位置和值做绑定 items[where] = v; return 0; } int PyList_Insert(PyObject *op, Py_ssize_t where, PyObject *newitem) { // 传入列表的引用， 插入的位置，还有新的数据项引用，并且验证列表和数据项 if (!PyList_Check(op)) { PyErr_BadInternalCall(); return -1; } // 进行插入 return ins1((PyListObject *)op, where, newitem); } 移除元素 static PyObject * list_pop_impl(PyListObject *self, Py_ssize_t index) // 传入列表的引用，列表的弹出数据项索引位置 { PyObject *v; int status; // 如果是一个空列表，则抛出异常 if (Py_SIZE(self) == 0) { /* Special-case most common failure cause */ PyErr_SetString(PyExc_IndexError, \"pop from empty list\"); return NULL; } if (index ob_item[index]; // 如果弹出的数据项是列表中的最后一个 if (index == Py_SIZE(self) - 1) { // list_resize()内部只会做size - 1，而不会回收内存进行缩容 status = list_resize(self, Py_SIZE(self) - 1); if (status >= 0) return v; /* and v now owns the reference the list had */ else return NULL; } // 增加一次引用计数器 Py_INCREF(v); // 如果弹出的数据项不是列表中的最后一个，则需要进行位置调整 status = list_ass_slice(self, index, index+1, (PyObject *)NULL); if (status 清空元素 static int _list_clear(PyListObject *a) { Py_ssize_t i; PyObject **item = a->ob_item; if (item != NULL) { /* Because XDECREF can recursively invoke operations on this list, we make it empty first. */ i = Py_SIZE(a); // 重新设置大小为0 Py_SET_SIZE(a, 0); // 将列表中插槽引用的对象全部设置为None a->ob_item = NULL; // 重新设置容量为0 a->allocated = 0; // 循环列表中的数据项，令所有数据项的引用计数-1 while (--i >= 0) { Py_XDECREF(item[i]); } PyMem_Free(item); } /* Never fails; the return value can be ignored. Note that there is no guarantee that the list is actually empty at this point, because XDECREF may have populated it again! */ return 0; } 删除列表 static void list_dealloc(PyListObject *op) { Py_ssize_t i; // 内部会判断这个列表是否还有其他标识符引用，如果为0则代表没有其他标识符引用 // 可以通过内部GC机制将该列表所占据的内存空间进行释放 PyObject_GC_UnTrack(op); Py_TRASHCAN_BEGIN(op, list_dealloc) if (op->ob_item != NULL) { /* Do it backwards, for Christian Tismer. There's a simple test case where somehow this reduces thrashing when a *very* large list is created and immediately deleted. */ // 获取列表中已有数据项的个数（即大小） i = Py_SIZE(op); // 循环列表中的数据项，令所有数据项的引用计数-1 while (--i >= 0) { Py_XDECREF(op->ob_item[i]); } PyMem_Free(op->ob_item); } struct _Py_list_state *state = get_list_state(); #ifdef Py_DEBUG // list_dealloc() must not be called after _PyList_Fini() assert(state->numfree != -1); #endif // 判断free_list中的已缓存列表个数是否大于80，这里是没满 // 在free_list中添加空列表的引用即可 if (state->numfree free_list[state->numfree++] = op; } else { // 如果free_list的大小已达到容量限制 // 则直接在内存中销毁列表的结构体对象 Py_TYPE(op)->tp_free((PyObject *)op); } Py_TRASHCAN_END } Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-05-14 16:33:35 "},"Python/Python基础知识/元组类型.html":{"url":"Python/Python基础知识/元组类型.html","title":"元组类型","keywords":"","body":"元组 Python中的元组容器序列（tuple）与列表容器序列（list）具有极大的相似之处，因此也常被称为不可变的列表。 但是两者之间也有很多的差距，元组侧重于数据的展示，而列表侧重于数据的存储与操作。 它们非常相似，虽然都可以存储任意类型的数据，但是一个元组定义好之后就不能够再进行修改。 元组特性 元组特性如下： 元组属于容器序列 元组属于不可变类型 元组底层由顺序存储组成，而顺序存储是线性结构的一种 基本声明 以下是使用类实例化的形式进行对象声明： tup = tuple((1, 2, 3, 4, 5)) print(\"值:%r,类型：%r\" % (tup, type(tup))) # 值:(1, 2, 3, 4, 5),类型： 也可以选择使用更方便的字面量形式进行对象声明，使用逗号对数据项之间进行分割： tup = 1, 2, 3, 4, 5 print(\"值:%r,类型：%r\" % (tup, type(tup))) # 值:(1, 2, 3, 4, 5),类型： 为了美观，我们一般会在两侧加上()，但是要确定一点，元组定义是逗号分隔的数据项，而并非是()包裹的数据项： tup = (1, 2, 3, 4, 5) print(\"值:%r,类型：%r\" % (tup, type(tup))) # 值:(1, 2, 3, 4, 5),类型： 多维元组 当一个元组中嵌套另一个元组，该元组就可以称为多维元组。 如下，定义一个2维元组： tup = (1, 2, (\"三\", \"四\")) print(\"值:%r,类型：%r\" % (tup, type(tup))) # 值:(1, 2, ('三', '四')),类型： 续行操作 在Python中，元组中的数据项如果过多，可能会导致整个元组太长，太长的元组是不符合PEP8规范的。 每行最大的字符数不可超过79，文档字符或者注释每行不可超过72 Python虽然提供了续行符\\，但是在元组中可以忽略续行符，如下所示： tup = ( 1, 2, 3, 4, 5 ) print(\"值:%r,类型：%r\" % (tup, type(tup))) # 值:(1, 2, 3, 4, 5),类型： 类型转换 元组支持与布尔型、字符串、列表、以及集合类型进行类型转换： tup = (1, 2, 3) bTup = bool(tup) # 布尔类型 strTup = str(tup) # 字符串类型 liTup = list(tup) # 列表类型 setTup = set(tup) # 集合类型 print(\"值:%r,类型：%r\" % (bTup, type(bTup))) print(\"值:%r,类型：%r\" % (strTup, type(strTup))) print(\"值:%r,类型：%r\" % (liTup, type(liTup))) print(\"值:%r,类型：%r\" % (setTup, type(setTup))) # 值:True,类型： # 值:'(1, 2, 3)',类型： # 值:[1, 2, 3],类型： # 值:{1, 2, 3},类型： 如果一个2维元组遵循一定的规律，那么也可以将其转换为字典类型： tup = ((\"k1\", \"v1\"), (\"k2\", \"v2\"), (\"k3\", \"v3\")) dictTuple = dict(tup) print(\"值:%r,类型：%r\" % (dictTuple, type(dictTuple))) # 值:{'k1': 'v1', 'k2': 'v2', 'k3': 'v3'},类型： 索引操作 元组的索引操作仅支持获取数据项。 其他的任意索引操作均不被支持。 使用方法参照列表的索引切片一节。 绝对引用 元组拥有绝对引用的特性，无论是深拷贝还是浅拷贝，都不会获得其副本，而是直接对源对象进行引用。 但是列表没有绝对引用的特性，代码验证如下： >>> import copy >>> # 列表的深浅拷贝均创建新列表... >>> oldLi = [1, 2, 3] >>> id(oldLi) 4542649096 >>> li1 = copy.copy(oldLi) >>> id(li1) 4542648840 >>> li2 = copy.deepcopy(oldLi) >>> id(li2) 4542651208 >>> # 元组的深浅拷贝始终引用老元组 >>> oldTup = (1, 2, 3) >>> id(oldTup) 4542652920 >>> tup1 = copy.copy(oldTup) >>> id(tup1) 4542652920 >>> tup2 = copy.deepcopy(oldTup) >>> id(tup2) 4542652920 Python为何要这样设计？其实仔细想想不难发现，元组不能对其进行操作，仅能获取数据项。 那么也就没有生成多个副本提供给开发人员操作的必要了，因为你修改不了元组，索性直接使用绝对引用策略。 值得注意的一点：[:]也是浅拷贝，故对元组来说属于绝对引用范畴。 元组的陷阱 Leonardo Rochael在2013年的Python巴西会议提出了一个非常具有思考意义的问题。 我们先来看一下： >>> t = (1, 2, [30, 40]) >>> t[-1] += [50, 60] Traceback (most recent call last): File \"\", line 1, in TypeError: 'tuple' object does not support item assignment 现在，t到底会发生下面4种情况中的哪一种？ t 变成 (1, 2, [30, 40, 50, 60])。 因为 tuple 不支持对它的数据项赋值，所以会抛出 TypeError 异常。 以上两个都不是。 a 和 b 都是对的。 正确答案是4，t确实会变成 (1, 2, [30, 40, 50, 60])，但同时元组是不可变类型故会引发TypeError异常的出现。 >>> t (1, 2, [30, 40, 50, 60]) 如果是使用extend()对t[-1]的列表进行数据项的增加，则答案会变成1。 我当初在看了这个问题后，暗自告诉自己了2件事情： list的数据项增加尽量不要使用+=，而应该使用append()或者extend() Ps：我也不知道自己为什么会产生这样的想法，但这个想法确实伴随我很长时间，直至现在 tuple中不要存放可变类型的数据，如list、set、dict等.. 元组更多的作用是展示数据，而不是操作数据。 举个例子，当用户根据某个操作获取到了众多数据项之后，你可以将这些数据项做出元组并返回。 用户对被返回的原对象只能看，不能修改，若想修改则必须创建新其他类型对象。 解构方法 元组的解构方法与列表使用相同。 使用方法参照列表的解构方法一节。 常用方法 方法一览 常用的list方法一览表： 方法名 返回值 描述 count() integer 返回数据项在T中出现的次数 index() integer 返回第一个数据项在T中出现位置的索引，若值不存在，则抛出ValueError 基础公用函数： 函数名 返回值 描述 len() integer 返回容器中的项目数 enumerate() iterator for index, value of iterable 返回一个可迭代对象，其中以小元组的形式包裹数据项与正向索引的对应关系 reversed() ... 详情参见函数章节 sorted() ... 详情参见函数章节 获取长度 使用len()方法来获取元组的长度。 返回int类型的值。 tup = (\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\") print(len(tup)) # 7 Python在对内置的数据类型使用len()方法时，实际上是会直接的从PyVarObject结构体中获取ob_size属性，这是一种非常高效的策略。 PyVarObject是表示内存中长度可变的内置对象的C语言结构体。 直接读取这个值比调用一个方法要快很多。 统计次数 使用count()方法统计数据项在该元组中出现的次数。 返回int： tup = (\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\", \"A\") aInTupCount = tup.count(\"A\") print(aInTupCount) # 2 查找位置 使用index()方法找到数据项在当前元组中首次出现的位置索引值，如数据项不存在则抛出异常。 返回int。 tup = (\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\", \"A\") aInTupIndex = tup.index(\"A\") print(aInTupIndex) # 0 底层探究 内存开辟 Python内部实现中，列表和元组还是有一定的差别的。 元组在创建对象申请内存的时候，内存空间大小便进行了固定，后续不可更改（如果是传入了一个可迭代对象，例如tupe(range(100))，这种情况会进行扩容与缩容，下面的章节将进行探讨研究）。 而列表在创建对象申请内存的时候，内存空间大小不是固定的，如果后续对其新增或删除数据项，列表会进行扩容或者缩容机制。 元组创建 空元组 若创建一个空元组，会直接进行创建，然后将这个空元组丢到缓存free_list中。 元组的free_list最多能缓存 20 * 2000 个元组，这个在下面会进行讲解。 如图所示： 元组转元组 这样的代码会进行元组转元组： tup = tuple((1, 2, 3)) 首先内部本身就是一个元组（1， 2， 3），所以会直接将内部的这个元组拿出来并返回引用，并不会再次创建。 代码验证： >>> oldTup = (1, 2, 3) >>> id(oldTup) 4384908128 >>> newTup = tuple(oldTup) >>> id(newTup) 4384908128 >>> 列表转元组 列表转元组会将列表中的每一个数据项都拿出来，然后放入至元组中： tup = tuple([1, 2, 3]) 所以你会发现，列表和元组中的数据项引用都是相同的： >>> li1 = [\"A\", \"B\", \"C\"] >>> tup = tuple(li1) >>> print(id(li1[0])) 4383760656 >>> print(id(tup[0])) 4383760656 >>> 可迭代对象转元组 可迭代对象是没有长度这一概念的，如果是可迭代对象转换为元组，会先对可迭代对象的长度做一个猜想。 并且根据这个猜想，为元组开辟一片内存空间，用于存放可迭代对象的数据项。 然后内部会获取可迭代对象的迭代器，对其进行遍历操作，拿出数据项后放至元组中。 如果猜想的长度太小，会导致元组内部的内存不够存放下所有的迭代器数据项，此时该元组会进行内部的扩容机制，直至可迭代对象中的数据项全部被添加至元组中。 rangeObject = range(1, 101) tup = tuple(rangeObject) // 假如猜想的是9 // 第一步：+ 10 // 第二步：+ (原长度+10) * 0.25 // 其实，就是增加【原长度*0.25 + 2.5】 如果猜想的长度太大，而实际上迭代器中的数据量偏少，则需要对该元组进行缩容。 切片取值 对元组进行切片取值的时候，会开辟一个新元组用于存放切片后得到的数据项。 tup = (1, 2, 3) newSliceTup = tup[0:2] 当然，如果是[:]的操作，则参照绝对引用，直接返回被切片的元组引用。 代码验证： >>> id(tup) 4384908416 >>> newSliceTup = tup[0:2] >>> id(newSliceTup) 4384904392 缓存机制 free_list缓存 元组的缓存机制和列表的缓存机制不同。 元组的free_list会缓存0 - 19长度的共20种元组，其中每一种长度的元组通过单向链表横向扩展缓存至2000个，如下图所示： 当每一次的del操作有数据项的元组时，都会将该元组数据项清空并挂载至free_list单向链表的头部的位置。 del 元组1 del 元组2 del 元组3 如下图所示： 当要创建一个元组时，会通过创建元组的长度，从free_list单向链表的头部取出一个元组，然后将数据项存放进去。 前提是free_list单向链表中缓存的有该长度的元组。 tup = (1, 2, 3) 空元组与非空元组的缓存 空元组的缓存是一经创建就缓存到free_list单向链表中。 而非空元组的缓存必须是del操作后才缓存到free_list单向链表中。 空元组的创建 第一次创建空元组后，空元组会缓存至free_list单向链表中。 以后的每一次空元组创建，返回的其实都是同一个引用，也就是说空元组在free_list单向链表中即使被引用了也不会被销毁。 >>> t1 = () >>> id(t1) 4511088712 >>> t2 = () >>> id(t2) 4511088712 非空元组的创建 当free_list单向链表中有相同长度的元组时，会进行引用并删除。 这个在上图中已经示例过了，就是这个： 代码示例： $ python3 Python 3.6.8 (v3.6.8:3c6b436a57, Dec 24 2018, 02:04:31) [GCC 4.2.1 Compatible Apple LLVM 6.0 (clang-600.0.57)] on darwin Type \"help\", \"copyright\", \"credits\" or \"license\" for more information. >>> v1 = (None, None, None) >>> id(v1) 4384907696 >>> v2 = (None, None, None) >>> id(v2) 4384908056 >>> del v1 >>> del v2 # ① >>> v3 = (None, None, None) >>> id(v3) # ② 4384908056 >>> v4 = (None, None, None) >>> id(v4) # ③ 4384907696 >>> ①：free_list num_free=3 单向链表结构：v2 —> v1 ②：创建了v3，拿出v2的空元组，填入v3数据项，故v2和v3的id值相等，证明引用同一个元组，此时free_list num_free=3 单向链表结构为：—> v1 ③：创建了v4，拿出v1的空元组，填入v4数据项，故v1和v4的id值相等，证明引用同一个元组 tupleobject.c源码 官网参考：点我跳转 源码一览：点我跳转 以下是截取了一些关键性源代码，并且做上了中文注释，方便查阅。 每一个元组都有几个关键性的属性： Py_ssize_t ob_refcnt; // 引用计数器 Py_ssize_t ob_size; // 数据项个数，即元组大小 PyObject *ob_item[1]; // 存储元组中的数据项 [指针, ] 关于缓存free_list的属性： PyTuple_MAXSAVESIZE // 相当于图中的 free_num ，最大20，即纵向扩展的缓存元组长度 PyTuple_MAXFREELIST // 图中 free_list 的横向扩展缓存列表个数，最大2000 创建元组 空元组 PyObject * PyTuple_New(Py_ssize_t size) { PyTupleObject *op; // 缓存相关 Py_ssize_t i; // 元组的大小不能小于0 if (size 0 // 创建空元组，优先从缓存中获取 // size = 0 表示这是一个空元组，从free_list[0]中获取空元组 if (size == 0 && free_list[0]) { // op就是空元组 op = free_list[0]; // 新增空元组引用计数器 + 1 Py_INCREF(op); #ifdef COUNT_ALLOCS tuple_zero_allocs++; #endif // 返回空元组的指针 return (PyObject *) op; } // 如果创建的不是空元组，且这个创建的元组数据项个数小于20，并且free_list[size]不等于空，表示有缓存 // 则从缓存中去获取，不再重新开辟内存 if (size ob_item[0]; // num_free减1 numfree[size]--; #ifdef COUNT_ALLOCS fast_tuple_allocs++; #endif /* Inline PyObject_InitVar */ // 初始化，定义这个元组的长度为数据项个数 #ifdef Py_TRACE_REFS Py_SIZE(op) = size; // 定义类型为 tuple Py_TYPE(op) = &PyTuple_Type; #endif // 增加一次新的引用 _Py_NewReference((PyObject *)op); } // 如果是空元组 else #endif { // 检查内存情况，是否充足 /* Check for overflow */ if ((size_t)size > ((size_t)PY_SSIZE_T_MAX - sizeof(PyTupleObject) - sizeof(PyObject *)) / sizeof(PyObject *)) { return PyErr_NoMemory(); } // 开辟内存，并获得一个元组：op op = PyObject_GC_NewVar(PyTupleObject, &PyTuple_Type, size); if (op == NULL) return NULL; } // 空元组的每一个槽位都是NULL for (i=0; i ob_item[i] = NULL; #if PyTuple_MAXSAVESIZE > 0 // 缓存空元组 if (size == 0) { free_list[0] = op; ++numfree[0]; Py_INCREF(op); /* extra INCREF so that this is never freed */ } #endif #ifdef SHOW_TRACK_COUNT count_tracked++; #endif // 将元组加入到GC机制中，用于内存管理 _PyObject_GC_TRACK(op); return (PyObject *) op; } 可迭代对象转元组 这个不在tupleobject.c源码中，而是在abstract.c源码中。 官网参考：点我跳转 源码一览：点我跳转 PyObject * PySequence_Tuple(PyObject *v) { PyObject *it; /* iter(v) */ Py_ssize_t n; /* guess for result tuple size */ PyObject *result = NULL; Py_ssize_t j; if (v == NULL) { return null_error(); } /* Special-case the common tuple and list cases, for efficiency. */ // 如果是元组转换元组，如 tup = (1, 2, 3) 或者 tup = ((1, 2, 3))直接返回内存地址 if (PyTuple_CheckExact(v)) { Py_INCREF(v); return v; } // 如果是列表转换元组，则执行PyList_AsTuple()，将列表转换为元组 // 如 tup = ([1, 2, 3]) if (PyList_CheckExact(v)) return PyList_AsTuple(v); /* Get iterator. */ // 获取迭代器， tup = (range(1, 4).__iter__()) it = PyObject_GetIter(v); if (it == NULL) return NULL; /* Guess result size and allocate space. */ // 猜想迭代器长度，也就是猜一下有多少个数据项 n = PyObject_LengthHint(v, 10); if (n == -1) goto Fail; // 根据猜想的迭代器长度，进行元组的内存开辟 result = PyTuple_New(n); if (result == NULL) goto Fail; /* Fill the tuple. */ // 将迭代器中每个数据项添加至元组中 for (j = 0; ; ++j) { PyObject *item = PyIter_Next(it); if (item == NULL) { if (PyErr_Occurred()) goto Fail; break; } //如果迭代器中数据项比猜想的多，则证明开辟内存不足需要需要进行扩容 if (j >= n) { size_t newn = (size_t)n; /* The over-allocation strategy can grow a bit faster than for lists because unlike lists the over-allocation isn't permanent -- we reclaim the excess before the end of this routine. So, grow by ten and then add 25%. */ // 假如猜想的是9 // 第一步：+ 10 // 第二步：+ (原长度+10) * 0.25 // 其实，就是增加【原长度*0.25 + 2.5】 newn += 10u; newn += newn >> 2; // 判断是否超过了元组的数据项个数限制（sys.maxsize） if (newn > PY_SSIZE_T_MAX) { /* Check for overflow */ PyErr_NoMemory(); Py_DECREF(item); goto Fail; } n = (Py_ssize_t)newn; // 扩容机制 if (_PyTuple_Resize(&result, n) != 0) { Py_DECREF(item); goto Fail; } } // 将数据项放入元组之中 PyTuple_SET_ITEM(result, j, item); } /* Cut tuple back if guess was too large. */ // 如果猜想的数据项太多，而实际上迭代器中的数据量偏少 // 则需要对该元组进行缩容 if (j 列表转元组 这个不在tupleobject.c源码中，而是在listobject.c源码中。 官网参考：点我跳转 源码一览：点我跳转 PyObject * PyList_AsTuple(PyObject *v) { PyObject *w; PyObject **p, **q; Py_ssize_t n; // 例如：tup = ([1, 2, 3]) // 进行列表的验证 if (v == NULL || !PyList_Check(v)) { PyErr_BadInternalCall(); return NULL; } // 获取大小，即数据项个数 n = Py_SIZE(v); // 开辟内存 w = PyTuple_New(n); // 如果是空元组 if (w == NULL) return NULL; // 执行迁徙操作 p = ((PyTupleObject *)w)->ob_item; q = ((PyListObject *)v)->ob_item; // 将列表中数据项的引用，也给元组进行引用 // 这样列表中数据项和元组中的数据项都引用同1个对象 while (--n >= 0) { // 数据项引用计数 + 1 Py_INCREF(*q); *p = *q; p++; q++; } // 返回元组 return w; } 切片取值 PyObject * PyTuple_GetSlice(PyObject *op, Py_ssize_t i, Py_ssize_t j) // 切片会触发该方法 { // 如果对空元组进行切片，则会抛出异常 if (op == NULL || !PyTuple_Check(op)) { PyErr_BadInternalCall(); return NULL; } // 内部的具体实现方法 return tupleslice((PyTupleObject *)op, i, j); } static PyObject * tupleslice(PyTupleObject *a, Py_ssize_t ilow, Py_ssize_t ihigh) { PyTupleObject *np; PyObject **src, **dest; Py_ssize_t i; Py_ssize_t len; // 计算索引位置 if (ilow Py_SIZE(a)) ihigh = Py_SIZE(a); if (ihigh ob_item + ilow; dest = np->ob_item; // 对源元组中的数据项的引用计数+1 for (i = 0; i 缓存相关 static void tupledealloc(PyTupleObject *op) { Py_ssize_t i; Py_ssize_t len = Py_SIZE(op); PyObject_GC_UnTrack(op); Py_TRASHCAN_SAFE_BEGIN(op) // 如果元组的长度大于0，则不是一个非空元组 if (len > 0) { i = len; // 将内部的数据项引用计数都 - 1 while (--i >= 0) Py_XDECREF(op->ob_item[i]); #if PyTuple_MAXSAVESIZE > 0 // 准备缓存，判断num_free是否小于20，并且单向链表中的已缓存元组个数小于2000 if (len ob_item[0] = (PyObject *) free_list[len]; // 将num_free + 1 numfree[len]++; free_list[len] = op; goto done; /* return */ } #endif } // 内存中进行销毁 Py_TYPE(op)->tp_free((PyObject *)op); done: Py_TRASHCAN_SAFE_END(op) } Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-05-14 15:57:44 "},"Python/Python基础知识/字符串类型.html":{"url":"Python/Python基础知识/字符串类型.html","title":"字符串类型","keywords":"","body":"字符串 字符串（str）一般是指Unicode字符串，见名知意，字符串是由多个字符所构成的一个串。 它是Python中最常用的数据类型之一，因此十分重要。 字符串有一个最显著的特征，即不可变，也就是说你无法使用索引来改变字符串中的字符，仅限于获取。 字符串特性 字符串特性如下： 字符串属于扁平序列 字符串是不可变的 字符串底层是一段连续的内存空间 基本声明 以下是使用类实例化的形式进行对象声明： string = str(\"ABCDEFG\") print(\"值:%r,类型：%r\" % (string, type(string))) # 值:'ABCDEFG',类型： 也可以选择使用更方便的字面量形式进行对象声明，使用英文状态下的单引号、双引号、三单引号、三双引号将数据项进行包裹即可： string = \"ABCDEFG\" print(\"值:%r,类型：%r\" % (string, type(string))) # 值:'ABCDEFG',类型： 个人并不推荐常规的使用三单引号或三双引号进行字符串定义，它们还具有文档注释的功能。 续行操作 在Python中，如果一个字符串过长，可能会导致不符合PEP8规范的情况出现。 每行最大的字符数不可超过79，文档字符或者注释每行不可超过72 如果要定义这样的长字符串，推荐使用三单引号或者三双引号进行定义，这样即可进行换行（但会保留特殊字符，如\\n）: string = \"\"\" 江雪 柳宗元 千山鸟飞绝 万径人踪灭 孤舟蓑笠翁 独钓寒江雪 \"\"\" print(\"值:%r,类型：%r\" % (string, type(string))) # 值:'\\n 江雪\\n 柳宗元\\n千山鸟飞绝\\n万径人踪灭\\n孤舟蓑笠翁\\n独钓寒江雪\\n',类型： 类型转换 字符串支持与布尔型、整形、以及浮点型进行转换，这是最常用的操作： string = \"100\" iStr = int(string) bStr = bool(string) fStr = float(string) print(\"值:%r,类型：%r\" % (iStr, type(iStr))) print(\"值:%r,类型：%r\" % (bStr, type(bStr))) print(\"值:%r,类型：%r\" % (fStr, type(fStr))) # 值:100,类型： # 值:True,类型： # 值:100.0,类型： 需要注意的是，如果一个字符串不是纯数字，那么将其转换为整形或浮点型时将会出现异常： string = \"非纯数字：100\" iStr = int(string) # 整形 fStr = float(string) # 浮点型 print(\"值:%r,类型：%r\" % (iStr, type(iStr))) print(\"值:%r,类型：%r\" % (fStr, type(fStr))) # ValueError: invalid literal for int() with base 10: '非纯数字：100' 此外，字符串也支持转换为列表以及集合： string = \"一零二四\" setStr = set(string) # 集合类型 listStr = list(string) # 列表类型 print(\"值:%r,类型：%r\" % (setStr, type(setStr))) print(\"值:%r,类型：%r\" % (listStr, type(listStr))) # 值:{'一', '零', '四', '二'},类型： # 值:['一', '零', '二', '四'],类型： 特殊的\\ 在普通的声明字符串中，\\后面一般都会跟上一个特殊字符。 该字符表示特殊的意义，如\\n代表换行，\\t代表制表符等，这种具有特殊意义的\\char组合被称为转义字符。 转义字符 意义 ASCII码值（十进制） \\a 响铃(BEL) 007 \\b 退格(BS) ，将当前位置移到前一列 008 \\f 换页(FF)，将当前位置移到下页开头 012 \\n 换行(LF) ，将当前位置移到下一行开头 010 \\r 回车(CR) ，将当前位置移到本行开头 013 \\t 水平制表(HT) （跳到下一个TAB位置） 009 \\v 垂直制表(VT) 011 \\ 代表一个反斜线字符''' 092 \\' 代表一个单引号（撇号）字符 039 \\\" 代表一个双引号字符 034 ? 代表一个问号 063 \\0 空字符(NUL) 000 \\ddd 1到3位八进制数所代表的任意字符 三位八进制 \\xhh 十六进制所代表的任意字符 十六进制 如果你还是不能理解，那么可看下面这个示例： 我想打印 hello”world，并且我的字符串字面量声明采用 “ 进行包裹。 我们必须进行“的转义，让它变为一个普通字符，而不是Python中字符串的字面量表示法，否则将会抛出语法错误： print(\"hello\\\"world\") # hello\"world r字符串 如果在声明字符串的前面加上字符r，则代表该字符串中不会存在转义字符，所有字符将按照普通的方式进行解读。 r字符串也被称为原始字符串： s1 = r\"\\n\\t\\b\" print(s1) # \\n\\t\\b 字节串 字节串（bytes）是字符串的另一种表现形式。 它记录内存中的原始数据，你可以将它理解为2进制数据。 字节串可用于网络传输、多媒体持久化存储中，它和字符串拥有相同的特性，即不可变。 字节串仅在Python3中出现，Python2中不存在该类型，但是Python2存在bytesarray。 同时，字节串拥有与字符串相同的特性。 基本声明 以下是使用类实例化的形式进行对象声明，必须传入一个字符串及指定该字符串的编码格式，如不传入字符串，则默认生成空的bytes对象： bitStr = bytes(\"ABCDEFG\".encode(\"u8\")) print(\"值:%r,类型：%r\" % (bitStr, type(bitStr))) # 值:b'ABCDEFG',类型： 也可以选择使用更方便的字面量形式进行对象声明，使用英文状态下的b加上单引号、双引号、三单引号、三双引号将数据项进行包裹即可，注意数据项必须位于ASCII码表之内： bitStr = bytes(b\"ABCDEFG\") print(\"值:%r,类型：%r\" % (bitStr, type(bitStr))) # 值:b'ABCDEFG',类型： 个人并不推荐常规的使用三单引号或三双引号进行字节串定义，它们还具有文档注释的功能。 编码解码 一个字符串要变为字节串，必须通过encode()方法来做指定编码格式。 而一个字节串要想变为字符串，也必须通过decode()方式做指定解码格式。 s = \"你好，世界，hello，world!\" bitStr = bytes(s.encode(encoding=\"u8\")) print(bitStr) string = str(bitStr.decode(encoding=\"u8\")) print(string) # b'\\xe4\\xbd\\xa0\\xe5\\xa5\\xbd\\xef\\xbc\\x8c\\xe4\\xb8\\x96\\xe7\\x95\\x8c\\xef\\xbc\\x8chello\\xef\\xbc\\x8cworld!' # 你好，世界，hello，world! 如果直接使用str.encode()则自动将str转变为bytes类型。 反之，如果直接使用bytes.decode()时bytes也会自动转为str类型。 因此我们可以省略bytes()和str()在外部的包裹： s = \"你好，世界，hello，world!\" bitStr = s.encode(encoding=\"u8\") print(bitStr) string = bitStr.decode(encoding=\"u8\") print(string) # b'\\xe4\\xbd\\xa0\\xe5\\xa5\\xbd\\xef\\xbc\\x8c\\xe4\\xb8\\x96\\xe7\\x95\\x8c\\xef\\xbc\\x8chello\\xef\\xbc\\x8cworld!' # 你好，世界，hello，world! 四则运算 基本操作 字符串支持与字符串进行加法运算，做到拼接的效果： s1 = \"字符串1\" s2 = \"字符串2\" print(s1 + s2) # 字符串1字符串2 字符串支持与整形进行乘法运算，做到重复打印的效果： s1 = \"*\" print(s1 * 3) # *** “可变”的字符串 str可以使用+=操作，来使原本的字符串与新的字符串进行拼接。 +=是一种常见的操作，所以CPython内部为其做了优化。 一个str在初始化内存的时候，程序会为它留出额外的可扩展空间，因此进行增量操作的时候，并不会涉及复制原有字符串到新位置这类操作，而是在原有字符串位置的后面添加上新的字符串。 此举会产生2种情况，情况1会开辟新的内存空间返回新的字符串，而情况2则不会开辟新的内存空间直接返回原来的字符串，可以变相的认为”改变“了字符串。 >>> a = \"a\" # 字符串初始化 >>> a 'a' >>> id(a) 4555528656 >>> a += \"b\" # 字符串没被改变，生成了新的字符串 >>> a 'ab' >>> id(a) 4557068976 >>> a += \"c\" # 字符串被改变了！ >>> a 'abc' >>> id(a) 4557068976 至于为何会发生这样的情况，目前仍然在探究当中... 我用了一百次测试，结果令人意外，字符串不变的情况占多数，仅变化了14次： a = \"a\" dic = {} for i in range(100): k = id(a) if dic.get(k): dic[k][-1] += 1 else: dic[k] = [\"第%s次出现\"%i, 1] a += \"a\" print(dic) print(len(dic)) 如果将a或者+=的拼接字符串做修改，次数又会发生改变，实在是找不到任何规律.. 字符间隙 看一个有趣的例子： s1 = \"HELLO\" boolRET = \"\" in s1 print(boolRET) # True 下一个例子，使用count()方法计算该字符串中空白字符的数量： s1 = \"HELLO\" print(s1.count(\"\")) # 6 小问号你是否充满了很多朋友？ 实际上，Python内部进行str存储的时候会为每个字符之间留一个空隙，如下所示： 所以才会造成上述情况的发生。 intern机制 intern机制是Python解释器为了节省内存而做出的一种策略。 当第一次创建一个短字符串的时候，都会用一个全局的字典将该字符串进行存储，而短字符串的定义如下： 长度不超过20，不含空格的字符串即可被认为是短字符串 当再次创建这个短字符串，会先查看全局字典中是否存在该短字符串，如果存在则不创建而是直接进行引用。 这种策略也被称之为短字符串驻留机制。 下面这个示例字符串是符合短字符串的，因此会进行驻留： >>> s1 = \"Python\" >>> s2 = \"Python\" >>> s1 is s2 True 由于字符串中含有空格，故该字符串不会触发驻留机制： >>> s1 = \"Pytho n\" >>> s2 = \"Pytho n\" >>> s1 is s2 False 字符串长度超过20，也不会触发驻留机制： >>> s1 = \"Python\" * 10 >>> s2 = \"Python\" * 10 >>> s1 is s2 False 如果是空字符串，也会有驻留机制： >>> s1 = \"\" >>> s2 = \"\" >>> id(s1) 4360137392 >>> id(s2) 4360137392 绝对引用 字符串拥有绝对引用的特性，则无论是深拷贝还是浅拷贝，都不会获得其副本，而是直接对源对象进行引用： >>> import copy >>> oldStr = \"0\" * 100 >>> id(oldStr) 4373971144 >>> s1 = copy.copy(oldStr) >>> id(s1) 4373971144 >>> s2 = copy.deepcopy(oldStr) >>> id(s2) 4373971144 索引切片 字符串的索引切片参照列表章节。 但是字符串不支持多维切片，因为字符串本身就是1维的。 并且字符串的切片不支持修改，与元组相似。 常用方法 方法一览 常用的str方法一览： 方法名 返回值 描述 strip() str 移除字符串两侧指定的字符，如不进行指定，则默认移除\\n、\\t以及空格。 split() list 按照指定字符进行从左到右的分割，以列表形式返回。可指定maxslipt限制切分次数 rsplit() list 按照指定字符进行从右到左的分割，以列表形式返回。可指定maxslipt限制切分次数 join() str 将一个列表中的数据项以指定字符拼接成新的字符串 replace() str 将字符串中的指定子串替换成另一个子串 count() integer 统计子串在父串中出现的次数 title() str 令字符串中的每一个单词首字母大写 capitalize() Str 令字符串中的句首单词首字母变为大写 find() integer 查找子串首次出现在父串中的索引值，若存在则返回索引，若不存在则返回-1，从左至右查找 rfind() integer 同上，从右至左查找 upper() str 令字符串中所有的小写字母转换为大写 lower() str 令字符串中所有的大写字母转换为小写 startswith() bool 判断字符串是否以特定子串开头 endswith() bool 判断字符串是否以特定子串结束 isdigit() bool 判断该字符串是否是一个数字串 基础公用函数： 函数名 返回值 描述 len() integer 返回容器中的项目数 enumerate() iterator for index, value of iterable 返回一个可迭代对象，其中以小元组的形式包裹数据项与正向索引的对应关系 reversed() ... 详情参见函数章节 sorted() ... 详情参见函数章节 获取长度 使用len()方法来进行字符串长度的获取。 返回int类型的值。 s1 = \"abcdefg\" print(len(s1)) # 7 Python在对内置的数据类型使用len()方法时，实际上是会直接的从PyVarObject结构体中获取ob_size属性，这是一种非常高效的策略。 PyVarObject是表示内存中长度可变的内置对象的C语言结构体。 直接读取这个值比调用一个方法要快很多。 移除空白 使用strip()方法移除字符串两侧指定的字符，如不进行指定，则默认移除\\n、\\t以及空格。 返回str类型的值。 s1 = \" abcdefg $$$\" res = s1.strip(\" $\") print(res) # abcdefg 拆分列表 使用split()方法按照指定字符进行从左到右的分割，以列表形式返回。可指定maxslipt限制切分次数。 返回list类型的值。 s1 = \"ab,cd,ef,gh\" res = s1.split(\",\",maxsplit=1) print(res) # ['ab', 'cd,ef,gh'] 使用rsplit()方法按照指定字符进行从右到左的分割，以列表形式返回。可指定maxslipt限制切分次数。 返回list类型的值。 s1 = \"ab,cd,ef,gh\" res = s1.rsplit(\",\",maxsplit=1) print(res) # ['ab,cd,ef', 'gh'] 列表合并 使用join()方法将一个列表中的数据项以指定字符拼接成新的字符串。 返回str类型的值。 l1 = [\"a\",\"b\",\"c\"] res = \"-\".join(l1) print(res) # a-b-c 替换操作 使用replace()方法将字符串中的指定子串替换成另一个子串。 返回str类型的值。 s1 = \"ABCDEFG\" res = s1.replace(\"BCD\",\"bcd\") print(res) # AbcdEFG 次数统计 使用count()方法统计子串在父串中出现的次数。 返回int类型的值。 s1 = \"HELLO\" res = s1.count(\"L\") print(res) # 2 词首大写 使用title()方法令字符串中的每一个单词首字母大写。 返回str类型的值。 s1 = \"hello world\" res = s1.title() print(res) # Hello World 句首大写 使用capitalize()方法令字符串中的句首单词变为大写。 返回str类型的值。 s1 = \"hello world\" res = s1.capitalize() print(res) # Hello world 索引位置 使用find()方法查找子串首次出现在父串中的索引值，若存在则返回索引，若不存在则返回-1，这是从左至右查找，rfind()则是从右至左查找。 返回int类型的值。 s1 = \"hello world\" res = s1.find(\"w\") print(res) # 6 小写转大写 使用upper()方法令字符串中所有的小写字母转换为大写。 返回str类型的值。 s1 = \"hello world\" res = s1.upper() print(res) # HELLO WORLD 大写转小写 使用lower()方法令字符串中所有的大写字母转换为小写。 返回str类型的值。 s1 = \"HELLO WORLD\" res = s1.lower() print(res) # hello world 指定开头 使用startswith()方法判断字符串是否以特定子串开头。 返回bool类型的值。 s1 = \"HELLO WORLD\" res = s1.startswith(\"HE\") print(res) # True 指定结尾 使用endswith()方法判断字符串是否以特定子串结束。 返回bool类型的值。 s1 = \"HELLO WORLD\" res = s1.endswith(\"LD\") print(res) # False 数字串 使用isdigit()方法判断该字符串是否是一个数字串。 返回bool类型的值。 s1 = \"100\" res = s1.isdigit() print(res) # True 其他方法 以下是一些其他不太常用的方法： 方法名 返回值 描述 index() integer 同find()，唯一区别找不到抛出异常，find()是返回-1，从左至右查找 rindex() integer 同上，从右至左查找 swapcase() str 字符串中大小进行翻转。大写转小写，小写转大写。 expandtabs() str 指定字符串中的tab长度，\\t代表制表符，默认长度为8 center() str 指定宽度，指定字符。若字符串的长度不够则将字符串放在中间，两侧使用指定字符填充 ljust() str 指定宽度，指定字符。若字符串的长度不够则将字符串放在左边，右侧使用指定字符填充 rjust() str 指定宽度，指定字符。若字符串的长度不够则将字符串放在右边，左侧使用指定字符填充 zfill() str 同rjust()，但是不可指定填充字符。按0进行填充 isdecimal() bool 判断字符串是否由数字组成。只支持unicode并且没有bytes的使用 isnumeric() bool 判断字符串是否由数字组成。只支持unicode，中文数字，罗马数字并且没有bytes的使用 isalnum() bool 判断字符串是否仅由数字和字母构成 isalpha() bool 判断字符串是否仅由字母构成 isspace() bool 判断字符串是否仅由空格构成 islower() bool 判断字符串是否纯小写 isupper() bool 判断字符串是否纯大写 istitle() bool 判断字符串中的单词是否首字母大写 index()与rindex()方法： s1 = \"Python\" s1.index(\"a\") s1.rindex(\"a\") # ValueError: substring not found 字符串翻转swapcase()方法： s1 = \"Python\" print(s1.swapcase()) # pYTHON 指定制表符长度的expandtabs()方法，默认制表符的长度为8，下面指定为4： s1 = \"P\\ty\\tt\\th\\to\\tn\" print(s1) print(s1.expandtabs(4)) # P y t h o n # P y t h o n 字符填充系列： s2 = \"H\" print(s2.center(20, \"+\")) print(s2.ljust(20, '+')) print(s2.rjust(20, '+')) print(s2.zfill(20)) # 0 填充，不可指定填充字符 # 其实总体来说就是将一个字符必须按照指定字符扩展为指定长度 # 区别在于源字符串的位置在指定填充符的中间、左侧、还是右侧 # +++++++++H++++++++++ # H+++++++++++++++++++ # +++++++++++++++++++H # 0000000000000000000H 字符串判断系列之数字串检测： s1 = b\"4\" # 字节数字串 s2 = u\"4\" # unicode数字串，默认Python3的str就是unicode编码，可以不用加u s3 = \"四\" # 中文数字串 s4 = \"Ⅳ\" # 罗马数字串 # isdigt()检测是否为数字串，只支持bytes和unicode print(s1.isdigit()) # True print(s2.isdigit()) # True print(s3.isdigit()) # False print(s4.isdigit()) # False # isdecimal()检测是否为数字串，只支持unicode字符串，如果是bytes字节串则抛出异常 print(s2.isdecimal()) # True print(s3.isdecimal()) # False print(s4.isdecimal()) # False # isnumeric()检测是否为数字串，不支持bytes字节串，支持unicode字符串、中文数字串、罗马数字串 print(s2.isnumeric()) # True print(s3.isnumeric()) # True print(s4.isnumeric()) # True 字符串判断之成员检测： s1 = \"Python3.6.8\" # isalnum() 判断字符串是否仅由数字和字母构成 print(s1.isalnum()) # False # isalpha() 判断字符串是否仅由字母构成 print(s1.isalpha()) # False # isspace() 判断字符串是否仅由空格构成 print(s1.isspace()) # False 字符串判断之大小写检测： s1 = \"Python3.6.8\" # islower() 判断字符串是否纯小写 print(s1.islower()) # False # isupper() 判断字符串是否纯大写 print(s1.isupper()) # False # istitle() 判断字符串中的单词是否首字母大写 print(s1.istitle()) # True 版本区别 数字与字符串对比 在Python2中是支持字符串与数字进行比较的，字符串永远比数字大： >>> \"0\" > 1 True 但是在Python3中，这种比较会抛出异常： >>> \"0\" > 1 Traceback (most recent call last): File \"\", line 1, in TypeError: '>' not supported between instances of 'str' and 'int' 表现形式 Python2的字符串表现形式为原始字节序列： >>> s1 = \"你好，世界\" >>> s1 '\\xe4\\xbd\\xa0\\xe5\\xa5\\xbd\\xef\\xbc\\x8c\\xe4\\xb8\\x96\\xe7\\x95\\x8c' 但是在Python3中的字符串表现形式不是这样的： >>> s1 = \"你好，世界\" >>> s1 '你好，世界' 编码方式 Python2和Python3中字符串的编码方式有很大的区别。 这个在字符编码一章节中会进行详细探讨。 底层探究 扁平序列 这里引出一个新的概念，扁平序列。 扁平序列其实更加紧凑，但是它里面只能存放诸如字符、字节和数值这种基础类型 扁平序列里存放的是值而不是引用 扁平序列不支持多维的说法，仅有一个维度 字符串为什么要设计成不可变类型？这是由于字符串内部是采用连续存储的方式。 因为字符串是连续的一块内存存放（在c语言体现中其实是一个数组，以\\0结尾），被看做为一个整体，修改其中某一个数据项那么必定会导致后面的内存发生变化，链式反应滚起雪球需要处理的数据量很庞大，于是Python干脆不支持修改字符串。 strobject.c源码 官网参考：点我跳转 源码一览：点我跳转 关于字符串的源码阅读，感兴趣的朋友可以看一下，这里不再进行延伸阅读。 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-05-14 22:39:31 "},"Python/Python基础知识/字典类型.html":{"url":"Python/Python基础知识/字典类型.html","title":"字典类型","keywords":"","body":"字典 Python中的字典（dict）也被称为映射（mapping）或者散列（hash），是支持Python底层实现的重要数据结构。 同时，它也是应用最为广泛的数据结构，内部采用hash存储，存储方式为键值对。 字典本身属于可变容器类型，但键（key）必须为不可变类型，而值（value）可以是任意类型。。 字典的优点是单点查找速度极快，但不能够支持范围查找，此外也比较占用内存。 字典特性 字典特性如下： 字典是一个可变的容器类型 字典内部由散列表组成 字典的单点读写速度很快，但是不支持范围查找 字典的key必须是不可变的，只有不可变对象才能被hash 字典在3.6之后变得有序了，这样做提升了遍历效率 基本声明 以下是使用类实例化的形式进行对象声明： userInfo = dict(name=\"YunYa\", age=18, hobby=[\"football, music\"]) print(\"值:%r,类型：%r\" % (userInfo, type(userInfo))) # 值:{'name': 'YunYa', 'age': 18, 'hobby': ['football, music']},类型： 也可以选择使用更方便的字面量形式进行对象声明，使用{}对键值对进行包裹，键值对采用k:v的形式分割，多个键值对之间使用逗号进行分割： userInfo = {\"name\": \"YunYa\", \"age\": 18, \"hobby\": [\"football, music\"]} print(\"值:%r,类型：%r\" % (userInfo, type(userInfo))) # 值:{'name': 'YunYa', 'age': 18, 'hobby': ['football, music']},类型： 声明字典时，千万注意key只能是不可变类型。 如字符串（str），整形（int），浮点型（float），布尔型（bool），元组类型（tuple）等等，使用可变类型作为key会抛出异常。 续行操作 在Python中，字典中的键值对如果过多，可能会导致整个字典太长，太长的字典是不符合PEP8规范的。 每行最大的字符数不可超过79，文档字符或者注释每行不可超过72 Python虽然提供了续行符\\，但是在字典中可以忽略续行符，如下所示： userInfo = { \"name\": \"YunYa\", \"age\": 18, \"hobby\": [\"football, music\"]} print(\"值:%r,类型：%r\" % (userInfo, type(userInfo))) # 值:{'name': 'YunYa', 'age': 18, 'hobby': ['football, music']},类型： 多维嵌套 字典中可以进行多维嵌套，如字典套字典，字典套元组，字典套列表等： dic = { \"k1\": [1, 2, 3], \"k2\": (1, 2, 3), \"k3\": { \"k3-1\": 1, \"k3-2\": 2, }, } 类型转换 字典可以与布尔类型和字符串进行转换，这是最常用的： dic = {\"k1\": \"v1\", \"k2\": \"v2\"} boolDict = bool(dic) # 布尔类型 strDict = str(dic) # 字符串类型 print(\"值:%r,类型：%r\" % (boolDict, type(boolDict))) print(\"值:%r,类型：%r\" % (strDict, type(strDict))) # 值:True,类型： # 值:\"{'k1': 'v1', 'k2': 'v2'}\",类型： 如果要将字典转换为列表、元组、集合类型，直接转换只会拿到键，并不会拿到值。 尤其注意这一点，但是其实这样用的场景十分少见，记住就行了： dic = {\"k1\": \"v1\", \"k2\": \"v2\"} listDict = list(dic) # 列表类型 tupleDict = tuple(dic) # 元组类型 setDict = set(dic) # 集合类型 print(\"值:%r,类型：%r\" % (listDict, type(listDict))) print(\"值:%r,类型：%r\" % (tupleDict, type(tupleDict))) print(\"值:%r,类型：%r\" % (setDict, type(setDict))) # 值:['k1', 'k2'],类型： # 值:('k1', 'k2'),类型： # 值:{'k2', 'k1'},类型： 重复key 一个字典中的key必须是唯一的，若不是唯一的则value可能面临被覆盖的危险： dic = {\"name\": \"云崖\", \"age\": 18, \"name\": \"Yunya\"} print(dic) # {'name': 'Yunya', 'age': 18} 同理，True和1，False和0也会彼此进行覆盖： dic = {True: \"云崖\", \"age\": 18, 1: \"Yunya\"} print(dic) # {True: 'Yunya', 'age': 18} []操作字典 由于字典并非顺序存储（下面会简单介绍），故不支持索引操作。 但是字典也提供了[]操作语法，它是根据key来操作value的。 增删改查 以下示例展示了如何使用[]对字典中的value进行操纵： dic = {\"k1\": \"v1\", \"k2\": \"v2\"} # 增 dic[\"k3\"] = \"v3\" print(dic) # {'k1': 'v1', 'k2': 'v2', 'k3': 'v3'} # 删，如果没有该key，则抛出keyError del dic[\"k2\"] print(dic) # {'k1': 'v1', 'k3': 'v3'} # 改，如果没有该key，则抛出keyError dic[\"k3\"] = \"VV3\" print(dic) # {'k1': 'v1', 'k3': 'VV3'} # 查，如果没有该key，则抛出keyError result = dic[\"k1\"] print(result) # v1 多维操作 字典套列表的多维操作如下，首先需要拿到该列表： dic = {\"k1\": [1, 2, 3, 4]} # 取出3 result = dic[\"k1\"][2] print(result) # 3 # k1的列表，添加数据项 \"A\" dic[\"k1\"].append(\"A\") print(dic) # {'k1': [1, 2, 3, 4, 'A']} 字典套字典的多维操作如下，首先需要拿到被操纵的字典： dic = { \"k1\":{ \"k1-1\":{ \"k1-2\":{ \"k1-3\":\"HELLO,WORLD\", } } } } # 拿到 k1-3 对应的value result = dic[\"k1\"][\"k1-1\"][\"k1-2\"][\"k1-3\"] print(result) # HELLO,WORLD 解构语法 **语法 **语法用于将字典中的k:v全部提取出来。 我们可以利用该语法的特性来对字典进行合并，将两个旧字典合并成一个新字典： dic_1 = {\"d1k1\": \"A\", \"d1k2\": \"B\"} dic_2 = {\"d2k1\": \"C\", \"d2k2\": \"D\"} result = {**dic_1, **dic_2} print(result) # {'d1k1': 'A', 'd1k2': 'B', 'd2k1': 'C', 'd2k2': 'D'} 解构赋值 字典支持平行变量赋值操作吗？当然可以！但是这样只会拿到字典的key： dic = {\"k1\": \"v1\", \"k2\": \"v2\"} first, last = dic print(first) print(last) # k1 # k2 有办法拿到value么？借助字典的values()方法即可做到，它的本质是将value全部提取出来，组成一个可迭代对象： dic = {\"k1\": \"v1\", \"k2\": \"v2\"} first, last = dic.values() print(first) print(last) # v1 # v2 你可以理解为，将value全部提取出来后转换为一个列表，类似于[“v1”, “v2”]，在Python2中的确是这样，但是到了Python3中做法改变了，目前按下不表。 对于一些不想要的数据项，你也可以按照列表的解构赋值操作来进行，这里不再举例。 常用方法 方法一览 常用的dict方法一览： 方法名 返回值 描述 get() v or None 取字典key对应的value，如果key不存在返回None setdefault() v 获取字典key对应的value，如该字典中不存在被获取的key则会进行新增k:v，并返回v update() None 对原有的字典进行更新 pop() v 删除该字典中的键值对，如果不填入参数key或者key不存在则抛出异常 keys() Iterable 返回一个可迭代对象，该可迭代对象中只存有字典的所有key values() Iterable 返回一个可迭代对象，该可迭代对象中只存有字典的所有value items() Iterable 返回一个可迭代对象，该可迭代对象中存有字典中所有的key与value，类似于列表套元组 clear() None 清空当前字典 基础公用函数： 函数名 返回值 描述 len() integer 返回容器中的项目数 获取长度 使用len()方法来进行字典长度的获取。 返回int类型的值。 dic = {\"name\": \"云崖\", \"age\": 18} print(len(dic)) # 2 一组键值对被视为一个数据项，故2组键值对长度为2 Python在对内置的数据类型使用len()方法时，实际上是会直接的从PyVarObject结构体中获取ob_size属性，这是一种非常高效的策略。 PyVarObject是表示内存中长度可变的内置对象的C语言结构体。 直接读取这个值比调用一个方法要快很多。 get() 使用get()方法获取字典key对应的value，相比于[]操作更加的人性化，因为[]一旦获取不存在的key则会抛出异常，而该方法则是返回None。 dic = {\"name\": \"云崖\", \"age\": 18} username = dic.get(\"name\") userhobby = dic.get(\"hobby\") print(\"用户姓名:\",username) print(\"用户爱好:\",userhobby) # 用户姓名: 云崖 # 用户爱好: None setdefault() 使用setdefault()方法来获取字典key对应的value，如该字典中不存在被获取的key则会进行新增k:v，并返回v。 返回字典原有的value或者新设置的k:v。 dic = {\"name\": \"云崖\", \"age\": 18} # 字典有name，则取字典里的name username = dic.setdefault(\"name\",\"云崖先生\") # 字典没有hobby，则设置hobby的value为足球与篮球并返回 userhobby = dic.setdefault(\"hobby\",\"足球与篮球\") print(\"用户姓名:\",username) print(\"用户爱好:\",userhobby) # 用户姓名: 云崖 # 用户爱好: 足球与篮球 update() 使用update()方法对原有的字典进行更新。 返回None。 dic = {\"name\": \"云崖\", \"age\": 18} dic.update( {\"hobby\": [\"篮球\", \"足球\"]} ) print(dic) # {'name': '云崖', 'age': 18, 'hobby': ['篮球', '足球']} pop() 使用pop()方法删除该字典中的键值对，如果不填入参数key或者key不存在则抛出异常。 返回被删除的value。 dic = {\"name\": \"云崖\", \"age\": 18} result = dic.pop(\"age\") print(result) print(dic) # 18 # {'name': '云崖'} keys() 返回一个可迭代对象，该可迭代对象中只存有字典的所有key。 Python2中返回的是列表，Python3中返回的是可迭代对象。 dic = {\"name\": \"云崖\", \"age\": 18} key_iter = dic.keys() print(key_iter) # dict_keys(['name', 'age']) values() 返回一个可迭代对象，该可迭代对象中只存有字典的所有value。 Python2中返回的是列表，Python3中返回的是可迭代对象。 dic = {\"name\": \"云崖\", \"age\": 18} value_iter = dic.values() print(value_iter) # dict_values(['云崖', 18]) items() 返回一个可迭代对象，该可迭代对象中存有字典中所有的key与value，类似于列表套元组。 Python2中返回的是二维列表，Python3中返回的是可迭代对象。 dic = {\"name\": \"云崖\", \"age\": 18} items_iter = dic.items() print(items_iter) # dict_items([('name', '云崖'), ('age', 18)]) clear() 清空当前字典。 返回None。 dic = {\"name\": \"云崖\", \"age\": 18} dic.clear() print(dic) # {} 其他方法 方法 返回值 描述 popitem() (k, v) 随机删除一组键值对,并将删除的键值放到元组内返回 fromkeys(iter,value) dict 第一个参数是可迭代对象，其中每一个数据项都为新生成字典的key，第二个参数为同一的value值 示例演示： dic1 = dict(k1=\"v1\", k2=\"v2\", k3=\"v3\", k4=\"v4\") print(dic1.popitem()) # ('k4', 'v4') dic2 = dict.fromkeys([1, 2, 3, 4], None) print(dic2) # {1: None, 2: None, 3: None, 4: None} 底层探究 高效查找 为什么要有字典这种数据结构？ 如果对一个无序的列表查找其中某一个value（不能进行排序），必须经过一个一个的遍历，速度会很慢。 [3, 2, 8, 9, 11, 13] # 如果要获取数据项11，必须经过5次查找 有没有一种办法，能够让速度加快？ 为了不违背不能排序的前提，我们只能在列表存入value的时候做文章。 我们可以为每个value都造一个独一无二的身份标识，根据这个身份标识符计算出value需要插入到列表的索引位置。 在取的时候同理，通过身份标识符直接就可以拿到value所在列表的索引值，无疑速度会快很多。 一个小总结： 有一个身份标识，身份标识必须是唯一的 提供一个根据身份标识计算出插入位置的算法 回到字典的本质，字典的key就是value的身份标识，而根据key计算出插入位置的算法被封装在了hash()函数中，这个算法也被称之为hash算法。 为什么key必须是唯一的，参照下面这个示例： [\"k1\", \"k2\", \"k3\", \"k4\", \"k5\", \"k6\"] [ 3, 2, 8, 9, 11, 13] 假如k5变成了k6，那么就有2个k6对应2个不同的value 这么做的后果就是，使用k6获取value的时候，根本不知道你需要的value是哪一个 所以，干脆Python规定，key必须是不可变类型！如果有重复则新的覆盖旧的。 或者说，只有不可变对象才能被hash。 hash()过程 如何通过hash()函数，确定value的插入位置？ 实际上每个键值对在存入字典之前，都会通过hash()函数对key计算出一个hash值（也被称为散列值）： >>> hash(\"k1\") 7036545863130266253 而字典的底层结构是由一个2维数组嵌套组成的，也被称为散列表、hash表。 如下所示，每次创建字典的时候，字典都会初始化生成一个固定长度且内容全是空的2维数组，Python内部生成的散列表长度为8（可参见dictobject.c结构体源码）： [ ① ② ③ [空, 空, 空], index: 0 [空, 空, 空], index: 1 [空, 空, 空], index: 2 [空, 空, 空], index: 3 [空, 空, 空], index: 4 [空, 空, 空], index: 5 [空, 空, 空], index: 6 [空, 空, 空] index: 7 ] ①：存放根据key计算出的hash值 ②：存放key的引用 ③：存放value的引用 现在，我们要存储name:yunya的键值对，对name计算hash值： >>> hash(\"name\") 3181345887314224636 用计算出的hash值与散列表长度进行求余运算： >>> 3181345887314224636 % 8 4 得到结果是4，就在散列表4的索引位置插入： [ ① ② ③ [空, 空, 空], index: 0 [空, 空, 空], index: 1 [空, 空, 空], index: 2 [空, 空, 空], index: 3 [3181345887314224636, \"name\"的引用, \"yunya\"], index: 4 [空, 空, 空], index: 5 [空, 空, 空], index: 6 [空, 空, 空] index: 7 ] 再次插入age:18，并用计算出的hash值与散列表长度进行求余运算: >>> hash(\"age\") 7064862892218627464 >>> 7064862892218627464 % 8 0 得到的结果是0，就在散列表0的索引位置插入： [ ① ② ③ [7064862892218627464, \"age\"的引用, 18], index: 0 [空, 空, 空], index: 1 [空, 空, 空], index: 2 [空, 空, 空], index: 3 [3181345887314224636, \"name\"的引用, \"yunya\"], index: 4 [空, 空, 空], index: 5 [空, 空, 空], index: 6 [空, 空, 空] index: 7 ] 可以看见，这个2维数组不是按照顺序进行插入的，总有一些空的位置存在，该数组也被称为稀松数组。 由于数组是稀松的，所以dict不支持范围获取（能获取到空值），但单点存取的速度很快。 读取的时候也同理，但是Python的hash函数底层实现是否真的利用hash值对稀松数组长度进行简单的求余运算，这个还有待商榷。 因为hash算法的实现有很多种，长度求余只是最为简单的一种而已，这里用作举例，如果想具体了解其算法可以查看Python源码，dictobject.c中的perturb。 散列冲突 现在，我们的这个散列表中0和4的索引位置都已经存在数据了。 如果现在存入一个teacher:wang，那么结果会是怎么样？ >>> hash(\"teacher\") 4789346189807557228 >>> 4789346189807557228 % 8 4 可以发现，teacher的hash值求余算结果也是4，这个时候就会发生散列冲突。 最常见的做法是，向后挪！因为索引5的位置是空的，我们可以将这个键值对插入到索引5的位置： [ ① ② ③ [7064862892218627464, \"age\"的引用, 18], index: 0 [空, 空, 空], index: 1 [空, 空, 空], index: 2 [空, 空, 空], index: 3 [3181345887314224636, \"name\"的引用, \"yunya\"], index: 4 [4789346189807557228, \"teacher\"的引用, \"wang\"], index: 5 [空, 空, 空], index: 6 [空, 空, 空] index: 7 ] 这种查找空位的方法叫做开放定址法（openaddressing），向后查找也被称为线性探测（linearprobing）。 如果此时又插入一个数据项，最后key的插入索引位置也是4，则继续向后查找空位，如果查找到7还是没有空位，又从0开始找。 上述方法是解决散列冲突的基础方案，当然也还有更多的其他解决方案，这里再说就过头了，放在后面数构一章中再进行介绍吧。 扩容机制 Python的dict会对散列表的容量做出判定。 当容量超过三分之二时，即进行扩容（resize）机制。 如果散列表大小为8，在即将插入第3个键值对时进行扩容，扩容策略为已有散列表键值对个数 * 2。 即散列表大小扩展为12。 如果整个散列表已有键值对个数达到了50000，则扩容策略为已有散列表键值对个数 * 4。 此外，dict只会进行扩容，不会进行缩容，如果删除了1个键值对，其内存空间占用的位置并不会释放。 不同key的优化 整形是其本身 整形的hash值是其本身： >>> hash(1) 1 >>> hash(2) 2 >>> hash(3) 3 >>> hash(10000) 10000 加盐策略 在Python3.3开始，str、bytes、datetime等对象在计算散列值的时候会进行加盐处理。 这个盐引用内部的一个常量，该常量在每次CPython启动时会生成不同的盐值。 所以你会发现每次重启Python3.3以后的解释器，对相同字符串进行hash()求散列值得出的结果总是不一样的： $ python3 Python 3.6.8 (v3.6.8:3c6b436a57, Dec 24 2018, 02:04:31) [GCC 4.2.1 Compatible Apple LLVM 6.0 (clang-600.0.57)] on darwin Type \"help\", \"copyright\", \"credits\" or \"license\" for more information. >>> hash(\"k1\") 8214688532022610754 >>> exit() $ python3 Python 3.6.8 (v3.6.8:3c6b436a57, Dec 24 2018, 02:04:31) [GCC 4.2.1 Compatible Apple LLVM 6.0 (clang-600.0.57)] on darwin Type \"help\", \"copyright\", \"credits\" or \"license\" for more information. >>> hash(\"k1\") -7444020267993088839 >>> exit() 再看Python2.7，由于没有加盐策略，所以每次重启得到的hash结果是相同的： $ python Python 2.7.10 (default, Feb 22 2019, 21:55:15) [GCC 4.2.1 Compatible Apple LLVM 10.0.1 (clang-1001.0.37.14)] on darwin Type \"help\", \"copyright\", \"credits\" or \"license\" for more information. >>> hash(\"k1\") 13696082283123634 >>> exit() $ python Python 2.7.10 (default, Feb 22 2019, 21:55:15) [GCC 4.2.1 Compatible Apple LLVM 10.0.1 (clang-1001.0.37.14)] on darwin Type \"help\", \"copyright\", \"credits\" or \"license\" for more information. >>> hash(\"k1\") 13696082283123634 >>> exit() 有序字典 字典无序的观念似乎已经深入人心，但那已经都是过去式了。 在Python3.6之后，字典变的有序了。 2012年12月10日星期一的时候，R. David Murray向Python官方发送了一封邮件，提出建议让Python的字典变的有序。 这样的做法能够让Python字典的空间占用量更小，迭代速度更快，以下是邮件内容： https://mail.python.org/pipermail/python-dev/2012-December/123028.html 我们先看看2.7中的字典： >>> {chr(i) : i for i in range(10)} {'\\x01': 1, '\\x00': 0, '\\x03': 3, '\\x02': 2, '\\x05': 5, '\\x04': 4, '\\x07': 7, '\\x06': 6, '\\t': 9, '\\x08': 8} 再来看3.6中的字典： >>> {chr(i) : i for i in range(10)} {'\\x00': 0, '\\x01': 1, '\\x02': 2, '\\x03': 3, '\\x04': 4, '\\x05': 5, '\\x06': 6, '\\x07': 7, '\\x08': 8, '\\t': 9} 果然！它确实变的有序了，关于具体细节，可以参照这封邮件，已经表述的很清楚了，下面做一个简单的示例。 首先，以前的散列表就是一个单纯的稀松二维数组： [ [空, 空, 空], index: 0 [空, 空, 空], index: 1 [空, 空, 空], index: 2 ... ] 键值对的读取顺序来源与填加顺序。 索引靠前的会被先遍历拿到，索引靠后只能后被遍历出来。 如果这个散列表长度为8，前7个都没有数据项存入，仅有8才有，那么遍历完整个散列表需要8次： [ [空, 空, 空], index: 0 [空, 空, 空], index: 1 [空, 空, 空], index: 2 ... [hash值, key的引用, value的引用], index: 7 ] 而Python3.6之后，又新增了一个顺序数组，该数组与散列表的长度相等，初始均为8，并且会跟随散列表的扩容而进行扩容，如下示例初始状态： [None, None, None, ...] [ [空, 空, 空], index: 0 [空, 空, 空], index: 1 [空, 空, 空], index: 2 ... ] 如果说第1个键值对，被插入到散列表索引1的位置，那么在顺序数组中，则在索引0处记录下该键值对被插入在散列表中的位置(1)，如下图所示： [1, None, None, ...] [ [空, 空, 空], index: 0 [hash值, key的引用, value的引用], index: 1 [空, 空, 空], index: 2 ... ] 如果第2个键值对，被插入到散列表索引0的位置，那么在顺序数组中，则在索引1处记录下该键值对被插入在散列表中的位置(0)，如下图所示： [1, 0, None, ...] [ [hash值, key的引用, value的引用], index: 0 [hash值, key的引用, value的引用], index: 1 [空, 空, 空], index: 2 ... ] 再插入一个键值对，该键值对被插到了索引7的位置，那么在顺序数组中，则在索引2处记录下该键值对被插入在散列表中的位置(7)，如下图所示： [1, 0, 7, None, None, None, None, None] [ [hash值, key的引用, value的引用], index: 0 [hash值, key的引用, value的引用], index: 1 [空, 空, 空], index: 2 ... [hash值, key的引用, value的引用], index: 7 ] 在遍历的时候，会遍历这个顺序数组，然后通过索引值拿到散列表中对应位置的数据项，如果遍历到的值为None就结束遍历，而不用遍历完整个散列表： 类似于： hashTableOrderArray = [1, 0, 7, None, None, None, None, None] hashTable = [ [\"hash\", \"k2\", \"v2\"], [\"hash\", \"k1\", \"v1\"], [None, None, None], [None, None, None], [None, None, None], [None, None, None], [None, None, None], [\"hash\", \"k3\", \"v3\"], ] n = 0 while n 这样只需遍历3次即可，而如果不用这个顺序数组，则要完整遍历整个散列表，即8次才能拿出所有的键值对。 dictobject.c源码 官网参考：点我跳转 源码一览：点我跳转 关于字典的源码阅读，感兴趣的朋友可以看一下，这里不再进行延伸阅读。 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-05-14 16:33:08 "},"Python/Python基础知识/集合类型.html":{"url":"Python/Python基础知识/集合类型.html","title":"集合类型","keywords":"","body":"集合 Python中的集合（set）内部存储也采用hash存储，是一种容器类型。 所以它与字典有类似之处，你可以将集合理解为没有value的字典（仅有key）。 集合本身是可变的数据类型，但是其内部数据项必须是不可变的，能被hash()的对象，这与字典的key特性相同。 集合特性 集合特性如下： 集合是一个可变的容器类型 集合中的数据项必须是不可变类型 集合更多的是用来操纵数据，而不是存储数据 嗯，再说一个冷门知识点，集合的速度比字典的存读速度更快！因为它的数据项仅有1部分，而字典的数据项拥有2部分，即键与值。 基本声明 以下是使用类实例化的形式进行对象声明： s = set((1, 2, 3, 4, 5)) print(\"值:%r,类型：%r\" % (s, type(s))) # 值:{1, 2, 3, 4, 5},类型： 也可以选择使用更方便的字面量形式进行对象声明，使用{}对数据项进行包裹，每个数据项间用逗号进行分割： s = {1, 2, 3, 4, 5} print(\"值:%r,类型：%r\" % (s, type(s))) # 值:{1, 2, 3, 4, 5},类型： 注意一个集合声明的陷阱，如果要声明一个空集合必须使用类实例的形式进行声明。 如果用一个空的{}进行字面量声明会生成一个字典。 声明集合时，千万注意数据项只能是不可变类型。 如字符串（str），整形（int），浮点型（float），布尔型（bool），元组类型（tuple）等等，使用可变类型作为数据项加入至集合中会抛出TypeError异常。 续行操作 在Python中，集合中的数据项如果过多，可能会导致整个集合太长，太长的集合是不符合PEP8规范的。 每行最大的字符数不可超过79，文档字符或者注释每行不可超过72 Python虽然提供了续行符\\，但是在集合中可以忽略续行符，如下所示： s = { 1, 2, 3, 4, 5 } print(\"值:%r,类型：%r\" % (s, type(s))) # 值:{1, 2, 3, 4, 5},类型： 类型转换 集合可以和布尔型、列表、元组、字符串类型进行转换： s = {1, 2, 3, 4, 5} boolSet = bool(s) strSet = str(s) listSet = list(s) tupleSet = tuple(s) print(\"值:%r,类型：%r\" % (boolSet, type(boolSet))) print(\"值:%r,类型：%r\" % (strSet, type(strSet))) print(\"值:%r,类型：%r\" % (listSet, type(listSet))) print(\"值:%r,类型：%r\" % (tupleSet, type(tupleSet))) # 值:True,类型： # 值:'{1, 2, 3, 4, 5}',类型： # 值:[1, 2, 3, 4, 5],类型： # 值:(1, 2, 3, 4, 5),类型： 无序特性 Python本身并未对集合新增顺序数组，因此集合不论是Python3还是Python2中都是无序的。 Python2.7.10示例： >>> {chr(i) for i in range(10)} set(['\\x01', '\\x00', '\\x03', '\\x02', '\\x05', '\\x04', '\\x07', '\\x06', '\\t', '\\x08']) Python3.6.8示例： >>> {chr(i) for i in range(10)} {'\\x07', '\\x06', '\\t', '\\x02', '\\x00', '\\x05', '\\x04', '\\x03', '\\x01', '\\x08'} 去重特性 得益于内部hash存储方式，集合具有去处重复的特性，我们可以让其与列表结合，将列表中重复的数据项剔除： repeatList = [1, 1, 2, 2, 3, 4, 5, 1, 2] newList = list(set(repeatList)) print(newList) # [1, 2, 3, 4, 5] 集合中的数据项怎么拿出来 集合虽然是容器类型，但是更多的作用是操作数据项，存储非它所长（存了就不好取了）。 集合没有提供[]语法： 它没有key，无法像字典一样通过key来操作value 也没有index，因为它不是顺序存储。 虽然set中没有提供单拿数据项的方法，但是我们可以将其转换为list后再通过index将某个数据项拿出来。 或者是通过遍历。 常用方法 常用的set方法一览，set有一部分方法可以进行符号操作： 方法名 符号表示 返回值 描述 add() 无 None 为集合中新增数据项 pop() 无 Data item 弹出随机数据项 remove() 无 None 删除指定数据项，若不存在则抛出异常 discard() 无 None 同上、但不存在不会抛出异常 clear() 无 None 清空集合 copy() 无 set 对集合进行浅拷贝 update() 无 None 原地更新集合 intersection() & set 求a集合与b集合的交集 difference() - set 求a集合与b集合的差集 union() set 求a集合与b集合的合集/并集 symmetric_difference() ^ set 求a集合与b集合的对称差集 issuperset() >或者>= bool 判定a集合是否为b集合的父级 issubset() bool 判断a集合是否为b集合的子集 isdisjoint() 无 bool 判断两个集合是否完全独立没有共同部分返回 intersection_update() 无 None 求出a集合与b集合的交集后并更新a集合 difference_update() 无 None 求出a集合与b集合的差集后并更新a集合 基础公用函数： 函数名 返回值 描述 len() integer 返回容器中的项目数 数据管理 示例演示： s1 = set() # 增加数据项 s1.add(1) print(s1) # {1} # 更新数据项 s1.update({2, 3, 4, 5}) print(s1) # {1, 2, 3, 4, 5} # 删除数据项， 不存在则抛出异常 s1.remove(2) print(s1) # {1, 3, 4, 5} # 删除数据项， 即使不存在也不会抛出异常 s1.discard(2) print(s1) # {1, 3, 4, 5} # 随机弹出数据项 print(s1.pop()) # 1 print(s1) # {3, 4, 5} # 浅拷贝 print(s1.copy()) # {3, 4, 5} # 清空数据项 s1.clear() print(s1) # set() 关系图解 集合关系图示： 关系获取 示例演示： s1 = {1, 2, 3, 4, 5} s2 = {4, 5, 6, 7, 8} # 交集 print(s1 & s2) print(set.intersection(s1, s2)) # {4, 5} # 差集 print(s1 - s2) print(set.difference(s1, s2)) # {1, 2, 3} # 合集、并集 print(s1 | s2) print(set.union(s1, s2)) # {1, 2, 3, 4, 5, 6, 7, 8} # 对称差集 print(s1 ^ s2) print(set.symmetric_difference(s1, s2)) # {1, 2, 3, 6, 7, 8} # 父子集 s3 = {1, 2, 3} s4 = {1,2} # 父级 print(s3 > s4) print(s3 >= s4) print(set.issuperset(s3, s4)) # True # 子集 print(s4 不可变的集合 frozenset()创建的集合拥有元组的特性，一旦集合创建完成后将不可以修改。 fs = frozenset((1, 2, 3)) print(fs) # frozenset({1, 2, 3}) 可以与普通的set集合进行关系获取，但是不能够进行数据项管理（可以copy，copy也是绝对引用）。 2.3以前怎么办 Python2.3的set和frozenset首次以模块的形式加入到Python中。 并且在Python2.6之后，提升为内置模块。 在Python2.3以前，我们常用字典来进行与集合相同的操作，因为字典的key也具有去重的特性嘛！ repeatList = [1, 1, 2, 2, 3, 4, 5, 1, 2] newList = list(dict.fromkeys(repeatList, None).keys()) print(newList) # [1, 2, 3, 4, 5] 如果是求交叉并集这种关系，则实现会更加复杂一点，这里不再举例。 dictobject.c源码 官网参考：点我跳转 源码一览：点我跳转 关于集合的源码阅读，感兴趣的朋友可以看一下，这里不再进行延伸阅读。 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-05-14 17:21:24 "},"Python/Python基础知识/布尔类型.html":{"url":"Python/Python基础知识/布尔类型.html","title":"布尔类型","keywords":"","body":"布尔类型 布尔类型的值被称为布尔值，常用于分支流程中，仅有2种表现形式： True：代表条件为真 False：代表条件为假 布尔属于不可变类型，同时也是基础的原子类型，即不可分割，不能容纳其他对象。 基本声明 以下是使用类实例化的形式进行对象声明： term = bool(True) print(\"值:%r,类型：%r\" % (term, type(term))) # 值:True,类型： 也可以选择使用更方便的字面量形式进行对象声明： term = True print(\"值:%r,类型：%r\" % (term, type(term))) # 值:True,类型： 类型转换 布尔值仅能转换为数字、字符串，使用对应的构造函数即可： termTrue = True termFalse = False iTrue = int(termTrue) iFalse = int(termFalse) fTrue = float(termTrue) fFalse = float(termFalse) sTrue = str(termTrue) sFalse = str(termFalse) print(\"值：%r,类型：%r\" % (iTrue, type(iTrue))) print(\"值：%r,类型：%r\" % (iFalse, type(iFalse))) print(\"值：%r,类型：%r\" % (fTrue, type(fTrue))) print(\"值：%r,类型：%r\" % (fFalse, type(fFalse))) print(\"值：%r,类型：%r\" % (sTrue, type(sTrue))) print(\"值：%r,类型：%r\" % (sFalse, type(sFalse))) # 值：1,类型： # 值：0,类型： # 值：1.0,类型： # 值：0.0,类型： # 值：'True',类型： # 值：'False',类型： 除此之外，使用bool()将任意类型对象包裹均能获得其布尔值的表现形式。 以下举例Python内置数据类型在不同状态下的布尔值表示： 类型 True False int&float 不为0 为0 str&bytes 不为空串 为空串 list&tuple 不为空容器 为空容器 dict&set 不为空映射 为空映射 示例如下： >>> # --- int & float --- >>> bool(0) False >>> bool(1) True >>> bool(-1) True >>> bool(0.1) True >>> bool(-0.1) True >>> # --- str & bytes --- >>> bool(\"\") False >>> bool(b\"\") False >>> bool(\"string\") True >>> bool(b\"bytes\") True >>> # --- list & tuple --- >>> bool(list()) False >>> bool(tuple()) False >>> bool(list((1, 2, 3))) True >>> bool(tuple((1, 2, 3))) True >>> # --- dict & set --- >>> bool(dict()) False >>> bool(set()) False >>> bool(dict(k1=\"v1\", k2=\"v2\")) True >>> bool(set((\"ele1\", \"ele2\"))) True 布尔常量池 True和False是会被经常使用到的，因此在Python解释器启动时就会进行创建，我将他两归类为布尔常量池中（实际上并不存在）。 与小整数常量池中的数字类似，即使经历不同的实例化过程，但每次得到的True和False都来自同一引用： >>> id(True) 4495471488 >>> id(False) 4495471456 >>> id(bool(1)) 4495471488 >>> id(bool(0)) 4495471456 True&False与1&0 布尔值参与四则运算的时候，True等价于1，False等价于0： >>> True + 1 2 >>> False + 1 1 >>> True - False 1 实际上，True和False当采用运算时将会从小整数池中取出1和0，但是若使用id()方法查看True和1的地址号，会发现是不同的： >>> id(True) 4495471488 >>> id(1) 4495853616 如果使用hash()函数呢，可以发现它们的结果都是1，即布尔值进行运算时始终会拿出其等价的整型值来参与运算： >>> hash(True) 1 >>> hash(1) 1 为什么会出现这种情况？其实点开bool类型的源代码就可以发现，在Python3中bool类继承至int类： class bool(int): 当传入一个任意类型构建bool类的实例对象时，通过内部一系列判定都会返回True或者False这种形式。 若要将布尔类型参与运算（四则运算、hash运算），则会通过内部某种特殊的机制拿到1或者0。 id()方法返回的是对象的地址号，而bool的实例对象和int的实例对象必定在堆区内存中由不同的位置进行存储，故它们的结果不一样。 而运算时，布尔类型会去小整数池中拿到对应的整型值来参与运算，故True和1的hash运算的结果都是相同的。 如下图所示： 绝对引用 布尔类型拥有绝对引用的特性，则无论是深拷贝还是浅拷贝，都不会获得其副本，而是直接对源对象进行引用： >>> import copy >>> oldBool = True >>> id(oldBool) 4369122176 >>> b1 = copy.copy(oldBool) >>> id(b1) 4369122176 >>> b2 = copy.deepcopy(oldBool) >>> id(b2) 4369122176 boolobject.c源码 官网参考：点我跳转 源码一览：点我跳转 现有的名称 Py_False 和 Py_True 引用独一无二的布尔对象 False 和 True （之前，它们分别引用了值为 0 和 1 的静态整数对象，是众多整数之一）。 一个新的 API，即PyObject *PyBool_FromLong(long) ，会接收一个 C长整型参数，并返回对 Py_False （当参数为零时）或 Py_True （当非零时）的新引用。 要检查对象是否为布尔对象，可以使用宏PyBool_Check()。 布尔实例的类型是 PyBoolObject*。 布尔类型对象可作为PyBool_Type使用。 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-05-14 17:42:41 "},"Python/Python基础知识/单例None.html":{"url":"Python/Python基础知识/单例None.html","title":"单例None","keywords":"","body":"None None是Python中经常出现的一种类型，但其实关于它的描述并不是很多，很多人也会忽略。 其实None里也有一些需要了解的知识点。 它常用于初始化数据，并且是函数默认的返回值。 None是一种不可变类型，同时也是基础的原子类型，即不可分割，不能容纳其他对象。 基本声明 Node的声明方式仅有字面量声明： empty = None print(\"值:%r,类型：%r\" % (empty, type(empty))) # 值:None,类型： NoneType与单例 尽管可以看到None的实例化类为NoneType，但是你可能无法直接找到NoneType： print(NoneType) # NameError: name 'NoneType' is not defined NoneType实现了单例模式，我们虽然无法直接拿到NoneType这个类，但是可以通过 __class__属性拿到。 以下实例化多个None，查看id()是否相同： NoneType = None.__class__ none1 = NoneType() none2 = NoneType() print(id(none1)) print(id(none2)) # 4377856088 # 4377856088 绝对引用 None类型也是绝对引用，无论是深拷贝还是浅拷贝，都不会获得其副本，而是直接对源对象进行引用： >>> import copy >>> oldNone = None >>> id(oldNone) 4369221720 >>> no1 = copy.copy(oldNone) >>> id(no1) 4369221720 >>> no2 = copy.deepcopy(oldNone) >>> id(no2) 4369221720 None的使用 None一般用于对一个变量进行初始化，可能我们还没想好这个变量存什么内容时可以用None先代替进行存入。 这种变量可称之为临时变量，即只在一定的场景下进行使用，而并不会常驻使用： temp = None 除此之外，None也常见于function的返回值中，并且Python中function默认的返回值就是None。 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-05-14 17:49:44 "},"Python/Python基础知识/内存管理.html":{"url":"Python/Python基础知识/内存管理.html","title":"内存管理","keywords":"","body":"Gc简介 Gc（garbage collection）中文直译为垃圾回收，是一种回收内存空间避免内存泄漏的机制。 我们在程序的运行中会产生大量的对象用于保存数据，而有时候有些对象已经没有用了就需要被清理释放掉该对象所占据的内存空间。 在一些较为低级的语言中对于内存空间的释放是需要编程人员来手动进行的，这种与底层硬件直接打交道的操作是十分的危险与繁琐的，而基于C语言开发而来的Python为了解决掉这种顾虑则自带了一种垃圾回收机制，从而让开发人员不必过分担心内存的使用情况而可以全身心的投入到开发中去。 引用计数 最简单的Gc机制，引用计数。 首先将堆区内存中的对象与栈区内存中标识符的绑定数量做一个计数。 示例如下： >>> a = \"Python\" >>> b = \"Python\" >>> c = \"Python\" 我们的图示按照标识符的引用次数为准，并忽略临时引用，下图中Python这个str对象的引用计数目前为3： 每次标识符与对象取消绑定关系，则计数-1，当计数减到0的时候将自动清理该对象。 示例如下： >>> del a >>> del b >>> del c 标记清除 循环引用 引用计数能够解决百分之九十的问题，但是有一种特殊的情况是引用计数处理不了的，即循环引用（也被称为交叉引用）。 什么是循环引用，举一个简单的例子就是列表的互相嵌套，如下所示，l1和l2的引用计数都为2（标识符+1次引用，两个列表的[-1]索引处+1次引用）： >>> l1 = [1,2,3] >>> l2 = [1,2,3,l1] >>> l1.append(l2) >>> l1 [1, 2, 3, [1, 2, 3, [...]]] >>> l2 [1, 2, 3, [1, 2, 3, [...]]] 接着往下看，我们取消标识符与对象的绑定关系： >>> del l1 >>> del l2 现在，由于2个列表对象的计数都为1，故引用计数的策略显得不好使了。 因为2个列表对象的引用计数都未清0： 解决方案 为了解决循环引用带来的内存泄露问题，出现了标记清除法。 标记清除的意思在于当应用程序可用内存空间即将被耗尽时便开始遍历栈区所有的标识符，并且会顺着栈区标识符对其引用的在堆区中的对象做一个标记。 如果堆区内存中存在没有与栈区标识符进行绑定的对象，该对象则会认为是无用的对象，将会被清理。 分代回收 基于引用计数的垃圾回收机制每一次执行清理操作前都会将整个堆区对象的引用计数做一次遍历统计。 这样做是非常消耗时间的，所以Python垃圾回收机制为了效率的提升加入了分代回收的策略。 即： 当多次扫描后，若该对象的引用计数一直不为0，且也没有被标记清除法所清理掉，则证明 该对象会被经常使用，因此降低该对象的扫描频率，以提升效率。 优秀文章推荐 其实Python内部的内存管理机制远不如此。 所以这里推荐一个知乎博主写的系列文章，感兴趣的朋友可以跳转后继续深入阅读，该博主对Python底层内存机制剖析的极为透彻，是不可多得的好文章： 点我跳转 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-05-14 18:24:54 "},"Python/Python基础知识/深浅拷贝.html":{"url":"Python/Python基础知识/深浅拷贝.html","title":"深浅拷贝","keywords":"","body":"拷贝 copy即拷贝，意在将相同的数据进行复制，以便将复制出的副本应用于不同的操作上，而本体不会受到任何影响。 绝大多数语言中都有深浅拷贝的概念，故此篇文章也是属于通用性文章。 在Python中，除开手动导入copy模块并使用deepcopy()函数的拷贝是深拷贝，其他的所有的拷贝操作都是浅拷贝。 在开始之前，介绍几个基本概念： 不可变类型：int、float、str、bool、None、tuple、frozenset 可变类型：list、dict、set（均是容器） 绝对引用：所有的不可变类型，都具有绝对引用的特性，即深浅拷贝都不会获得其副本，而是直接对源对象进行引用 赋值 赋值就是引用，代码如下： #!/usr/bin/env python3 # -*- coding:utf-8 -*- oldLi = [\"A\", [1, ], (1,)] newLi = oldLi if id(oldLi) == id(newLi): print(\"外部大容器：可变类型：list来自同一个引用\") else: print(\"外部大容器：可变类型：list来自不同的引用\") if id(oldLi[0] == id(newLi[0])): print(\"内部第1个元素：不可变类型：str来自同一个引用\") else: print(\"内部第1个元素：不可变类型：str来自不同的引用\") if id(oldLi[1]) == id(newLi[1]): print(\"内部第1个大容器：可变类型：list来自同一个引用\") else: print(\"内部第1个大容器：可变类型：list来自不同的引用\") if id(oldLi[1][0]) == id(newLi[1][0]): print(\"内部第1个大容器的数据项：不可变类型：int ：%r来自同一个引用\" % oldLi[1][0]) else: print(\"内部第1个大容器的数据项：不可变类型：int ：%r来自不同的引用\" % oldLi[1][0]) if id(oldLi[2]) == id(newLi[2]): print(\"内部第2个大容器：不可变类型：tuple来自同一个引用\") else: print(\"内部第2个大容器：不可变类型：tuple来自不同的引用\") if id(oldLi[2][0]) == id(newLi[2][0]): print(\"内部第2个大容器的数据项：不可变类型：int ：%r来自同一个引用\" % oldLi[2][0]) else: print(\"内部第2个大容器的数据项：不可变类型：int ：%r来自不同的引用\" % oldLi[2][0]) # 外部大容器：可变类型：list来自同一个引用 # 内部第1个元素：不可变类型：str来自同一个引用 # 内部第1个大容器：可变类型：list来自同一个引用 # 内部第1个大容器的数据项：不可变类型：int ：1来自同一个引用 # 内部第2个大容器：不可变类型：tuple来自同一个引用 # 内部第2个大容器的数据项：不可变类型：int ：1来自同一个引用 如图所示： 所有引用都相同，这代表着oldLi中任意一个数据项改变后，newLi中的数据项也会跟着发生改变： oldLi[0] = \"B\" print(\"oldLi -> index0:type=str -> %r\" % oldLi[0]) print(\"newLi -> index0:type=str -> %r\" % newLi[0]) oldLi[1][0] = 10 print(\"oldLi -> index1:type=list --> index0:type=int -> %r\" % oldLi[1][0]) print(\"newLi -> index1:type=list --> index0:type=int -> %r\" % newLi[1][0]) # oldLi -> index0:type=str -> 'B' # newLi -> index0:type=str -> 'B' # oldLi -> index1:type=list --> index0:type=int -> 10 # newLi -> index1:type=list --> index0:type=int -> 10 图示如下： 浅拷贝 被浅拷贝的对象如果是可变类型，则创建副本，如果是不可变类型，则是引用，浅拷贝仅拷贝1层。 代码如下： #!/usr/bin/env python3 # -*- coding:utf-8 -*- import copy oldLi = [\"A\", [1, ], (1,)] newLi = copy.copy(oldLi) if id(oldLi) == id(newLi): print(\"外部大容器：可变类型：list来自同一个引用\") else: print(\"外部大容器：可变类型：list来自不同的引用\") if id(oldLi[0] == id(newLi[0])): print(\"内部第1个元素：不可变类型：str来自同一个引用\") else: print(\"内部第1个元素：不可变类型：str来自不同的引用\") if id(oldLi[1]) == id(newLi[1]): print(\"内部第1个大容器：可变类型：list来自同一个引用\") else: print(\"内部第1个大容器：可变类型：list来自不同的引用\") if id(oldLi[1][0]) == id(newLi[1][0]): print(\"内部第1个大容器的数据项：不可变类型：int ：%r来自同一个引用\" % oldLi[1][0]) else: print(\"内部第1个大容器的数据项：不可变类型：int ：%r来自不同的引用\" % oldLi[1][0]) if id(oldLi[2]) == id(newLi[2]): print(\"内部第2个大容器：不可变类型：tuple来自同一个引用\") else: print(\"内部第2个大容器：不可变类型：tuple来自不同的引用\") if id(oldLi[2][0]) == id(newLi[2][0]): print(\"内部第2个大容器的数据项：不可变类型：int ：%r来自同一个引用\" % oldLi[2][0]) else: print(\"内部第2个大容器的数据项：不可变类型：int ：%r来自不同的引用\" % oldLi[2][0]) # 外部大容器：可变类型：list来自不同的引用 # 内部第1个元素：不可变类型：str来自同一个引用 # 内部第1个大容器：可变类型：list来自同一个引用 # 内部第1个大容器的数据项：不可变类型：int ：1来自同一个引用 # 内部第2个大容器：不可变类型：tuple来自同一个引用 # 内部第2个大容器的数据项：不可变类型：int ：1来自同一个引用 如图所示，浅拷贝为什么浅，因为只拷贝了一层： 如果修改oldLi第1层的index指向，newLi并不会受到影响，而如果修改oldLi第2层的index指向，则newLi会受到影响，如下所示： oldLi[0] = \"B\" print(\"oldLi -> index0:type=str -> %r\" % oldLi[0]) print(\"newLi -> index0:type=str -> %r\" % newLi[0]) oldLi[1][0] = 10 print(\"oldLi -> index1:type=list --> index0:type=int -> %r\" % oldLi[1][0]) print(\"newLi -> index1:type=list --> index0:type=int -> %r\" % newLi[1][0]) # oldLi -> index0:type=str -> 'B' # newLi -> index0:type=str -> 'A' # oldLi -> index1:type=list --> index0:type=int -> 10 # newLi -> index1:type=list --> index0:type=int -> 10 图示如下： 深拷贝 深拷贝是递归的拷贝，即在浅拷贝的基础上也会递归的判定其子数据项是否能被拷贝。 如果是可变类型则拷贝，如果是不可变类型则不拷贝，代码如下： #!/usr/bin/env python3 # -*- coding:utf-8 -*- import copy oldLi = [\"A\", [1, ], (1,)] newLi = copy.deepcopy(oldLi) if id(oldLi) == id(newLi): print(\"外部大容器：可变类型：list来自同一个引用\") else: print(\"外部大容器：可变类型：list来自不同的引用\") if id(oldLi[0] == id(newLi[0])): print(\"内部第1个元素：不可变类型：str来自同一个引用\") else: print(\"内部第1个元素：不可变类型：str来自不同的引用\") if id(oldLi[1]) == id(newLi[1]): print(\"内部第1个大容器：可变类型：list来自同一个引用\") else: print(\"内部第1个大容器：可变类型：list来自不同的引用\") if id(oldLi[1][0]) == id(newLi[1][0]): print(\"内部第1个大容器的数据项：不可变类型：int ：%r来自同一个引用\" % oldLi[1][0]) else: print(\"内部第1个大容器的数据项：不可变类型：int ：%r来自不同的引用\" % oldLi[1][0]) if id(oldLi[2]) == id(newLi[2]): print(\"内部第2个大容器：不可变类型：tuple来自同一个引用\") else: print(\"内部第2个大容器：不可变类型：tuple来自不同的引用\") if id(oldLi[2][0]) == id(newLi[2][0]): print(\"内部第2个大容器的数据项：不可变类型：int ：%r来自同一个引用\" % oldLi[2][0]) else: print(\"内部第2个大容器的数据项：不可变类型：int ：%r来自不同的引用\" % oldLi[2][0]) # 外部大容器：可变类型：list来自不同的引用 # 内部第1个元素：不可变类型：str来自同一个引用 # 内部第1个大容器：可变类型：list来自不同的引用 # 内部第1个大容器的数据项：不可变类型：int ：1来自同一个引用 # 内部第2个大容器：不可变类型：tuple来自同一个引用 # 内部第2个大容器的数据项：不可变类型：int ：1来自同一个引用 如图所示，深拷贝把能拷贝的，不是绝对引用的都拷贝了： 无论怎么修改oldLi，newLi都不会受到影响： oldLi[0] = \"B\" print(\"oldLi -> index0:type=str -> %r\" % oldLi[0]) print(\"newLi -> index0:type=str -> %r\" % newLi[0]) oldLi[1][0] = 10 print(\"oldLi -> index1:type=list --> index0:type=int -> %r\" % oldLi[1][0]) print(\"newLi -> index1:type=list --> index0:type=int -> %r\" % newLi[1][0]) # oldLi -> index0:type=str -> 'B' # newLi -> index0:type=str -> 'A' # oldLi -> index1:type=list --> index0:type=int -> 10 # newLi -> index1:type=list --> index0:type=int -> 1 图示如下： Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-05-14 18:28:25 "},"Python/Python基础知识/输入与输出.html":{"url":"Python/Python基础知识/输入与输出.html","title":"输入与输出","keywords":"","body":"输入与输出 输入输出让计算机能够听懂人类的指令，并且能够告诉人类它目前的状态。 标准输出 print() 在Python3中，print()函数默认会将对象的表现形式输出至屏幕上： print(\"hello world\") # hello world 而在Python2中，print后面不必加括号，加上对象即可： print \"hello world\" 除此之外，print()函数还可以接收3个参数，分别是：sep、end、file sep参数 该参数用来显示逗号间隔中的链接字符，默认为一个空格： # 不指定sep参数 print(\"hello\", \"world\") # hello world # 指定sep参数 print(\"hello\", \"world\", sep=\"-------\") # hello-------world end参数 该参数用于指定当print()完成后所在行尾指定的字符，默认为\\n即换行符。 print('hello',end='file参数 该参数默认内部为标准输出，即输出至用户屏幕，我们可以通过该参数来指定print()的内容写入到某个指定的文件句柄中： with open(file='a.txt',mode='w',encoding='utf-8') as f: print('这一行将被写入文件中去...',file=f) 格式化输出 如果我们想将一个字符串与一个对象的表现形式相结合，可使用格式化输出。 % %格式化的历史悠久，很多码龄较长的程序员都喜欢用它进行格式化输出。 我们来看一个例子： name = \"云崖先生\" age = 19 s1 = \"姓名是:%s,年龄是:%d\"%(name,age) # ① print(s1) # 姓名是:云崖先生,年龄是:19 ①：字符串中的%s、%d等都是占位符，占位符要和对象匹配，在进行格式化时%char会被对象的表现形式所代替。 常见的占位符如下表所示： 占位符 描述 %s 接收任意类型的值，以字符串形式显示 %r 接收任意类型的值，以r字符串形式显示 %c 只接收单个字符 %b 接收int类型的值，二进制整数形式显示 %d 接收int类型的值，十进制整数形式显示 %i 接收int类型的值，十进制整数形式显示 %o 接收int类型的值，八进制整数形式显示 %x 接收int类型的值，十六进制整数形式显示 %e 接收float类型的值，指数形式显示 (基底写为e) %E 接收float类型的值，指数形式显示 (基底写为E) %f 接收float类型的值，浮点数形式显示 %F 接收float类型的值，浮点数形式显示 %g 接收float类型的值，指数(e)或浮点数 (根据显示长度) %G 接收float类型的值，指数(E)或浮点数 (根据显示长度) %% 即打印1个百分号 位置传参 一个占位符对应一个对象，当对象与占位符有多个时便需要将%后面的对象跟上括号做出一个元组，如若只有一个则不需要加上括号，%后元组中的对象数量必须与占位符的数量一致，且位置要一一对应： name = \"云崖先生\" age = 19 s1 = \"姓名是:%s,年龄是:%d\" % (name, age) print(s1) # 姓名是:云崖先生,年龄是:19 如上所示：%s对应name、%d对应age。 优点：便于维护 缺点：对象与占位符必须一一对应，数量必须保持一致 关键字传参 标识符存储对象的内存地址引用。 而使用关键字传参可以打破位置传参中占位符和标识符顺序以及数量必须统一的限制： name = \"云崖先生\" age = 19 s1 = \"姓名是:%(name)s,年龄是:%(age)d\" % {\"age\": age, \"name\": name} print(s1) # 姓名是:云崖先生,年龄是:19 如上所示：%(name)s代表将dict中key为name的值转换为字符串形式显示，而%(age)d则代表将dict中key为age的值转换为字符串形式显示。 优点：使用灵活 缺点：如果被格式化的占位符过多，可能导致维护不便的情况发生 格式化百分号 如果想打印%多少，则可以使用下面的方式 %%百分号代表一个% 。放在 %d后面的%则代表格式化出后的结果是3%: s1 = \"%d%%\"%3 print(s1) # 3% 格式化精度控制 如果要格式化一个小数，保留点后2位该怎么做？ 如下示例： PI = 3.1415926 print(\"pi = %.2f\" % PI) # pi = 3.14 format() %虽然能够满足基本需求。但在Python2.6中新增的format()方法，它更加强大以及速度更快。 推荐今后使用format()的方法进行字符串格式化 。 注意:format()中的s只接受str类型的传值而不接受全部类型 如下所示，必须一个{}对应format()中的一个对象： name = \"yunya\" age = 18 s1 = \"姓名是{},年龄是{}\".format(name, age) # ① print(s1) # 姓名是yunya,年龄是18 ①：第1个{}对应format()中传入的第1个对象name，而第2个{}对应format()中传入的第2个对象age 或者也可以使用对象的方法调用形式： name = \"yunya\" age = 18 s1 = str.format(\"姓名是{},年龄是{}\", name, age) print(s1) # 姓名是yunya,年龄是18 位置传参 基本使用，采用{}进行占位，需要注意的是format中的s不是接收全部类型的对象，只能接收str类型的对象： name = \"yunya\" age = 18 s1 = \"姓名是{:s},年龄是{:d}\".format(name, age) # ① print(s1) # 姓名是yunya,年龄是18 如果不指定类型，则{}中默认接收全部类型的对象： name = \"yunya\" age = 18 s1 = \"姓名是{},年龄是{}\".format(name, age) print(s1) # 姓名是yunya,年龄是18 索引传参 索引传参是format()方法所独有的。 采用{}进行占位，并在其中使用索引值进行format()中传入的对象定位，如下所示： name = \"yunya\" age = 18 s1 = \"姓名是{1:d},年龄是{0:s}\".format(name, age) # s1 = \"姓名是{1},年龄是{0}\" .format(name,age） # 仅指定位置，不指定类型 print(s1) # 姓名是yunya,年龄是18 关键字传参 format()方法传参时使用键值对的方式进行传参： name = \"yunya\" age = 18 s1 = \"姓名是{name:s},年龄是{age:d}\".format(name=name, age=age) # s1 = \"姓名是{name},年龄是{age}\" .format(name=name,age=age) # 仅指定关键字，不指定类型 print(s1) # 姓名是yunya,年龄是18 你也可以直接传入一个字典，通过**语法对字典解包： name = \"yunya\" age = 18 s1 = \"姓名是{name:s},年龄是{age:d}\".format(**{\"name\" : name, \"age\": age}) # s1 = \"姓名是{name},年龄是{age}\" .format(**{\"name\" : name, \"age\": age}) # 仅指定关键字，不指定类型 print(s1) # 姓名是yunya,年龄是18 字符填充功能 format()方法格式化时支持字符填充，如下表所示： 填充位置符号 描述 往右填充 > 往左填充 ^ 两侧填充 示例如下： char = \"M\" # 右填充*，字符串长度为10时停止填充 rightFill = str.format(\"{0:*10}\", char) print(leftFill) # *********M # 两侧填充*，字符串长度为10时停止填充 midFill = str.format(\"{0:*^10}\", char) print(midFill) # ****M***** 格式化百分号 format()方法格式化百分号方法如下，它比%的格式化更加简单： s1 = str.format(\"{0}%\", 3) print(s1) # 3% 格式化{}大括号 如果使用format()方法，格式化时要输出“{char}“该怎么做？ 在外部套用2次大括号即可，如下所示： s1 = str.format(\"{{{0}}}\", \"☺\") print(s1) # {☺} 内部的{0}代表要格式化后面的☺，而外部的2个{}格式化完成后则表现为1个{}。 格式化精度控制 如果要使用format()方法格式化一个小数，保留点后2位该怎么做？ 如下示例： PI = 3.1415926 print(\"pi = {0:.2f}\".format(PI)) # pi = 3.14 其他的格式化 进制转换、如下所示： # 进制转换 sBit = str.format(\"{:b}\", 10) # 2进制 sOct = str.format(\"{:o}\", 10) # 8进制 sHex = str.format(\"{:x}\", 10) # 16进制 print(sBit) # 1010 print(sOct) # 12 print(sHex) # a 如果1代表百分之百，该怎么表示？如下所示： # .2%中的2代表保留2小数点后2位 s1 = str.format(\"{:.2%}\", 1) print(s1) s2 = str.format(\"{:.2%}\", 0.5) print(s2) # 100.00% # 50.00% 千分位表示，用逗号进行分割： s = str.format(\"{:,}\", 100000000) print(s) # 100,000,000 f 尽管format()已经非常方便了。但是如果传入的参数值太多依旧会看着十分混乱，于是Python3.6中新增了 f 格式字符串的操作。 这种方法的速度最快，但是却不推荐使用，因为程序还要考虑一个向下兼容性的问题。 name = \"yunya\" age = 18 s1 = f'我的名字叫做{name},我的年龄是{age}岁。' print(s1) # 我的名字叫做yunya,我的年龄是18岁。 具体使用方法参照上面，与原始字符串r使用差不多，用f添加在字符串前面，并且使用{}进行占位，{}中放入对象即可。 关于其他的字符串填充、精度控制、格式化转换等功能均和format()使用相同，这里不再举例。 标准输入 input() Python2和Python3中均有input()函数来接收用户的输入。 需要注意的是，Python3中input()所得到的所有用户输入的数据，类型都是str，举个例子，用户输入小键盘数字1，得到的类型也为str，所以我们可能需要额外的进行类型转换。 而在Python2中，则会自动转换类型为int，Python2会检测用户输入的内容是否符合Python语法，如不符合语法就会抛出异常，因此Python3中才摈弃了这种设定。 Python3中获得的所有输入结果类型均为str： username = input(\"请输入姓名>>>\") userage = input(\"请输入年龄>>>\") print(\"类型:%s，值:%s\" % (username, type(username))) print(\"类型:%s，值:%s\" % (userage, type(userage))) # 请输入姓名>>>yunya # 请输入年龄>>>18 # 类型:yunya，值: # 类型:18，值: 所以我们需要对其做一次类型转换： username = input(\"请输入姓名>>>\") userage = int(input(\"请输入年龄>>>\")) ... # 请输入姓名>>>yunya # 请输入年龄>>>18 # 类型:yunya，值: # 类型:18，值: Python2中如果用户没有按照Python语法进行数据的录入，则会抛出异常： # coding:u8 username = input(\"请输入姓名>>>\") userage = input(\"请输入年龄>>>\") print u\"类型:%s，值:%s\" % (username, type(username)) print u\"类型:%s，值:%s\" % (userage, type(userage)) # -- 输入了 yunya 会抛出 name 'yunya' is not defined # -- 而输入了 \"yunya\" 则会正常 raw_input() raw_input()是Python2中独有的，与Python3的input()效果相同。 这还是因为Python2中input()的缺点而导致raw_input()的诞生。 >>> name = input(\"请输入姓名:\") 请输入姓名:yunya # 注意：这里没加引号，Python2的input()会认为这是一个变量。而改变了未绑定堆区变量值，所以抛出 yunya 未定义的这么一个异常。 Traceback (most recent call last): File \"\", line 1, in File \"\", line 1, in NameError: name 'yunya' is not defined >>> name = input(\"请输入姓名:\") 请输入姓名:\"yunya\" >>> name 'yunya' # 用户必须按照Python语法规范来输入，极大的拉低了用户体验 >>> >>> city = input(\"请输入城市:\") #假 如用户输入了不符合Python语法数据便直接抛出异常。 请输入城市:[\"哈尔滨\"， Traceback (most recent call last): File \"\", line 1, in File \"\", line 1 [\"哈尔滨\"， ^ SyntaxError: invalid syntax 更进一步了解输出 stdin&stdout&stderr 在Linux下，当一个用户进程被创建的时候，系统会自动为该进程创建三个数据流，分别是stdin、stdout、stderr。 stdin：标准输入、指向用户键盘 stdout：标准输出、指向用户屏幕 stderr：标准错误、指向用户屏幕 print()的指向 Python3的print()函数，内部则是引用了stdout，也就是说会默认的将数据显示在用户屏幕上。 我们可以从Python中print()函数签名中看到： def print(self, *args, sep=' ', end='\\n', file=None): # known special case of print \"\"\" print(value, ..., sep=' ', end='\\n', file=sys.stdout, flush=False) Prints the values to a stream, or to sys.stdout by default. Optional keyword arguments: file: a file-like object (stream); defaults to the current sys.stdout. sep: string inserted between values, default a space. end: string appended after the last value, default a newline. flush: whether to forcibly flush the stream. \"\"\" pass 而关于flush参数，则可以理解为刷新机制。 默认是False即代表是流式的输出，而改为True则会拥有类似于帧动画的特性，以下代码将进行验证，推荐使用Python IDLE查看效果： import time print('下载中',end=\"\") for i in range(100): time.sleep(0.1) if i == 99: print('#',flush=True) break print('#',flush=True,end=\"\") Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-05-14 20:41:02 "},"Python/Python基础知识/运算符相关.html":{"url":"Python/Python基础知识/运算符相关.html","title":"运算符相关","keywords":"","body":"算数运算符 符号意义 以下是常用的算数运算符： 符号 意义 + 加法运算 - 减法运算 * 乘法运算 / 除法运算，精确除法（返回float） // 除法运算，地板除法（向下取整，生成int） ** 幂运算 % 求余运算 对于不同的类型，所支持的符号也不一样： 类型 运算符 支持连接的类型 注意事项 int + int、float、bool int与float进行加法运算，返回float float + float、int、bool int与float进行加法运算，返回float bool + bool、int、float int与bool进行加法运算，返回int，float与bool进行加法运算，返回float list + list list与list进行加法运算，将会对符号左侧的list进行元素扩充 str + str str与str进行加法运算，生成新的str tuple + tuple tuple与tuple进行加法运算，生成新的tuple int - int、float、bool int与float进行减法运算，返回float float - int、float、bool int与float进行减法运算，返回float bool - int、float、bool int与bool进行减法运算，返回int，float与bool进行减法运算，返回float int * int、float、bool、list、str、tuple int与list进行乘法运算，将会对list进行元素扩充，与str以及tuple进行乘法运算，均返回新的str或tuple float * float、int、bool 暂无 list * int int与list进行乘法运算，将会对list进行元素扩充 str * int int与str进行乘法运算，将会返回新的str tuple * int int与tuple进行乘法运算，将会返回新的tuple int / int、float、bool 返回float，此外//相同 float / float、int、bool 返回float，此外//相同 bool / bool、int、float 返回float，此外//相同 注意事项： float与int或者bool做运算，得到的结果均为float >>> 1 + 1.0 2.0 >>> 1 - 1.0 0.0 >>> 1 * 1.0 1.0 >>> 1 / 1.0 1.0 **幂运算仅支持int 、float、 bool 三种类型 >>> 2 ** 3 8 >>> 2.0 ** 3 8.0 >>> True ** 3 1 >>> %求余运算只支持 int 、float、 bool 三种类型，如果被求余数小于求余数，那么余数就为被求余数本身 >>> 6 % 8 6 示例演示 加法运算 print(1 + 1) print(1 + 1.1) print(1 + True) print([1, 2, 3] + [4, 5, 6]) print('OldStr ' + ' NewStr') # 改变引用值，生成新对象 print((1, 2, 3) + (4, 5, 6)) # 改变引用值，生成新对象 # 2 # 2.1 # 2 # OldStr NewStr # [1, 2, 3, 4, 5, 6] # (1, 2, 3, 4, 5, 6) 减法运算 print(1 - 1) print(1 - 1.1) print(1 - True) # 0 # -0.10000000000000009 # 0 乘法运算 s1 = '￥' l1 = [1, 2, 3] t1 = (1, 2, 3) print(1 * 2) print(1 * 2.0) print(1 * True) print(3 * l1) print(3 * s1) # 改变引用值，生成新的str对象 print(3 * t1) # 改变引用值，生成新的tuple对象 # 2 # 2.0 # 1 # [1, 2, 3, 1, 2, 3, 1, 2, 3] # ￥￥￥ # (1, 2, 3, 1, 2, 3, 1, 2, 3) 精确除法 print(10 / 2) print(10 / 2.0) print(10.1 / True) print(10.1 / True) print(10.1 / True) print(10.1 / True) print(False / 10) print(True / 2) print(True / 2.0) # 5.0 # 5.0 # 10.1 # 10.1 # 10.1 # 10.1 # 0.0 # 0.5 # 0.5 赋值运算符 符号意义 以下是常用的赋值运算符： 符号 意义 = 普通的赋值 + 增量加法赋值 - 增量减法赋值 * 增量乘法赋值 / 增量精确除法赋值 // 增量地板除法赋值 ** 增量幂运算赋值 % 增量求余赋值 普通赋值 赋值运算符为=，切记一个=才是赋值： >>> x = 1 >>> x 1 增量赋值 在原本标识符所指向的对象基础上进行增量的运算后，再将运算结果赋值给原本的标识符。 增量赋值运算符就是将赋值符号和算术运算符结合起来达到简写的目的： 普通的先运算后赋值： >>> x = 1 >>> x = x + 10 >>> x 11 >>> x = x - 10 >>> x 1 >>> x = x * 10 >>> x 10 >>> x = x / 10 >>> x 1.0 >>> x = x // 10 >>> x 0.0 >>> x = x ** 10 >>> x 0.0 >>> x = x % 10 >>> x 0.0 简便的增量运算符： >>> x = 1 >>> x += 10 >>> x 11 >>> x -= 10 >>> x 1 >>> x *= 10 >>> x 10 >>> x /= 10 >>> x 1.0 >>> x //= 10 >>> x 0.0 >>> x **= 10 >>> x 0.0 >>> x %= 10 >>> x 0.0 平行赋值 平行赋值，一次为多个标识符进行赋值： >>> x, y, z = 1, 2, 3 >>> x 1 >>> y 2 >>> z 3 链式赋值 链式赋值，多个标识符引用同一个对象： >>> x = y = z = \"Object\" >>> x 'Object' >>> y 'Object' >>> z 'Object' 脸是复制也被称之为间接赋值。 交叉赋值 交叉赋值，将2个标识符所指向的对象进行互换： >>> x = \"Object001\" >>> y = \"Object002\" >>> x, y = y, x >>> x 'Object002' >>> y 'Object001' 解压赋值 解压赋值这里不再进行赘述了，前面在介绍内置数据类型的时候已经介绍过了。 比较运算符 符号意义 比较运算符的返回结果总是为True或者False，一般是用于比较2个相同类型的值的大小。 常用于条件分支结构中： 符号 意义 > 大于 小于 == 等于 != 不等于 >= 大于或者等于 小于或者等于 示例演示 比较运算符得到的结果必然是bool类型： >>> 1 >> 1 > 2 False >>> 1 == 1.0 True >>> 1 == True True 比较方式 字符串与字符串之间的比较会一位一位对照ASCII表来进行比对： >>> ord(\"y\") 121 >>> ord(\"k\") 107 >>> \"y\" > \"k\" True 如果是非ASCII字符，则会调用其他的比较机制，如调用locale模块下的strxfrm()函数对字符串进行本地化处理： print(\"中\" > \"美\") 如果是数字串，则会一位一位进行比较： >>> \"100\" > \"4\" False # 第一位比较：1 小于 4，后续不再比较 数字与数字之间的比较会之间比较整体： >>> 100 > 1000 False 元组、列表之间的比较会根据相同的索引值进行一位一位的比较： >>> (\"100\", ) > (\"45\", \"b\") False # 1比4小 逻辑运算符 逻辑词汇 不同于其他编程语言的&&和||，Python中使用单词代表与或非。 单词 意义 not 非，统一取反 and 与，一真一假取一假，两个为真才取真 or 或，一真一假取一真，两个为假才取假 优先级 优先级的意思是如下： not True and False or True # 第一个True是该给not还是and做运算呢？ 牢记：NOT>AND>OR 故上面的结果为： True 以下是推算流程： False and False or True False or True True 示例演示 使用not进行取反： >>> not 1 > 2 True 使用and进行多条件连接： >>> name = \"Yunya\" >>> age = 18 >>> name == \"Yunya\" and age == 18 True >>> 使用or进行或逻辑判断： >>> name = \"Yunya\" >>> age = 18 >>> name == \"Yunya\" or age == 100 True >>> 短路运算 如果一次逻辑运算中的逻辑运算符号全部为 and 或者 or 则会从左至右依次进行逻辑运算。如果每一次都进行运算是很消耗时间的，所以这个时候出现了短路机制。看图说话： 与或运算 如果不是对True或者False进行and or运算而是对数字进行and or运算呢？ 实际上经过计算后的结果会得出布尔值，牢记0是False非0是True即可： >>> 1 and 0 or 3 3 >>> 3 + 1 and 4 or 0 4 每次的结果，都取最后一个True值： >>> 1 and 2 2 >>> 2 and 1 1 >>> 1 or 0 1 >>> 0 or 1 1 成员运算符 in in用来判断容器类型的某一个数据项是否在其中，支持的类型有str、list、tuple、dict、set、frozenset，所有的判定严格区分大小写。 in：在其中 not in：不在其中 需要注意的是如果是对dict做in的成员判定，只会判定key是否在其中： >>> string = \"ABCDEFG\" >>> \"A\" in string True >>> \"a\" in string False >>> li1 = [1, 2, 3] >>> 1 in li1 True >>> 0 in li1 False >>> tup = (1, 2, 3) >>> 1 in tup True >>> 0 in tup False >>> dic = {\"k1\" : \"v1\", \"k2\" : \"v2\"} >>> \"k1\" in dic True >>> \"v1\" in dic False >>> s1 = {1, 2, 3} >>> 1 in s1 True >>> 0 in s1 False 身份运算符 is is判定对象是否来自同一引用，即是否是同一个对象，用来判断引用是否相等： >>> x = y = z = \"I love Python\" >>> x is y True >>> x is z True is&==的异同 ==仅判断对象的表现形式是否相同，不关心是否引用自同一对象： >>> x = \"I love Python\" >>> y = \"I love Python\" >>> x == y True >>> x is y False 两者的区别在于使用is时相当于使用 id(obj) == id(obj)，即对象是否为同一引用： >>> x = \"I love Python\" >>> y = \"I love Python\" >>> id(x) 4305667952 >>> id(y) 4305668016 >>> id(x) == id(y) # is False 而==则不会判定id，仅判断形式值是否相同，即是否为相同表示： >>> x = \"I love Python\" >>> y = \"I love Python\" >>> id(x) 4305667952 >>> id(y) 4305668016 >>> x == y True 小结： is：引用判定，引用相等的对象表现则必然相等 ==：表现判定，表现相等的对象引用不一定相等 is None 一般来说，我们对None做判断时都会使用is None而不是 == None，这是因为None本身就是一个单例形式。 所有的None对象其实内部都引用自同一对象，在PEP8规范中明确表示，对于None的判定应该使用is而不是==： r = None print(r is None) print(r == None) # True # True 虽然这么使用毫无问题，但是在PyCharm中会报出PEP8不规范的提示： 对象的增量与普通运算操作 记住一句话，增量是原地操作，不会开辟新的内存空间（字符串的+=除外）。 而普通的运算操作则会开辟新的内存空间，返回1个新对象。 我们以列表举例： >>> li1 = [1, 2, 3] >>> li2 = li1 * 3 >>> li1 is li2 False >>> li2 [1, 2, 3, 1, 2, 3, 1, 2, 3] >>> li1 = [1, 2, 3] >>> id(li1) 4346207752 >>> li1 *= 3 >>> id(li1) 4346207752 >>> li1 [1, 2, 3, 1, 2, 3, 1, 2, 3] Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-05-15 11:39:59 "},"Python/Python基础知识/分支结构.html":{"url":"Python/Python基础知识/分支结构.html","title":"分支结构","keywords":"","body":"分支结构 分支结构能够让计算机像人一样进行思考，应对不同的场景做出不同的回应。 Python中不支持switch语法，目前仅支持if/else形式，但是在Python3.10的测试版本中，貌似支持了switch语法，这里不做例举。 if 多条if语句出现会逐行进行判断，条件为真则执行其下的代码块，条件为假则略过： if 条件判断： 逻辑代码... if 条件判断: 逻辑代码... if 条件判断: 逻辑代码... 示例演示： userAge = int(input(\"请输入你的年龄:\")) if userAge = 18 and userAge = 30 and userAge = 60 and userAge =80: print(\"尚能饭矣\") if/else if代表如果怎样就怎样，else代表否则怎样就怎样。 一组if/else只会执行其中的一个。 以下是Python中if/else语法： if 条件判断： 逻辑代码... else： 逻辑代码... 示例演示： userinput = input(\"输入任意字符，判断是否为数字串:\") if userinput.isdigit(): print(\"是数字串\") else: print(\"不是数字串\") if/elif/else 多条if会按顺序依次执行，对每一条if语句都进行判定，而如果使用elif则只会从多条逻辑判定中取出最先为True的进行执行，后续的判定将不会被执行。 也就是说，if/elif/else三者只会执行一个。 语法使用如下： if 条件判断： 逻辑代码... elif 条件判断: # 如果条件成立，剩下同级别下的elif与else都不将再继续执行。 逻辑代码... elif 条件判断: 逻辑代码... else: 逻辑代码 示例演示： userAge = int(input(\">>>\")) if userAge 三元表达式 三元表达式中有三个重要的元素： 条件是第一元素 　 条件成立返回的值是第二元素 　 条件不成立返回的值是第三元素 普通形式 如果只是一个简单if/else判定，我们可以将代码写在一行，语法如下： if else 示例演示： age = int(input(\">>>\")) result = \"成年\" if age >= 18 else \"未成年\" print(result) 其他形式 上面的三元表达式是最常见的一种，除此之外再介绍几种不常见的。 第二种，这种有一个BUG，不能区分0或者Fasle： and or 如下所示，如果1大于0就返回0，否则返回False，但是第二种的返回的结果永远是False： result = 1 > 0 and 0 or False print(result) # False 如果使用第一种，就不会有这样的问题： result = 0 if 1 > 0 else False print(result) # False 第三种，语法如下： (, )[condition] 示例如下： age = int(input(\">>>\")) result = (\"未成年\", \"已成年\") [age >= 18] print(result) 第四种，语法如下： {True: , False: }[] 示例如下： age = int(input(\">>>\")) result = {True: \"已成年\", False: \"未成年\"}[age >= 18] print(result) Python语法糖 链式比较 在Python中的判定支持一种链式比较，下面是常规的比较： print(3 > 2 and 2 > 1) print(3 > 1 and 1 > 2) # True # False 通过链式比较进行简写： print(3 > 2 > 1) print(3 > 1 > 2) # True # False 获得布尔值 判定用户输入的是否为数字串，如果为数字串result变量为True，否则为False。 很多情况下，初学者可能会写出下面这种代码： userInput = input(\">>>\") result = None if userInput.isdigit(): result = True else: result = False print(result) 其实一行代码就可以搞定： userInput = input(\">>>\") result = bool(userInput.isdigit()) print(result) 或者你也可以使用另一种方式： userInput = input(\">>>\") result = userInput.isdigit() or False print(result) 实例练习 输入一个数字，判断该数字是奇数还是偶数： num = int(input(\"输入一个数字: \")) if (num % 2) == 0: print(\"{0} 是偶数\".format(num)) else: print(\"{0} 是奇数\".format(num)) 输入一个年份，判断该年份是否是闰年？ year = int(input(\"输入一个年份: \")) if (year % 4) == 0: if (year % 100) == 0: if (year % 400) == 0: print(\"{0} 是闰年\".format(year)) # 整百年能被400整除的是闰年 else: print(\"{0} 不是闰年\".format(year)) else: print(\"{0} 是闰年\".format(year)) # 非整百年能被4整除的为闰年 else: print(\"{0} 不是闰年\".format(year)) 输入某年某月某日，判断这一天是这一年的第几天？ year = int(input('year:\\n')) month = int(input('month:\\n')) day = int(input('day:\\n')) sumInt = None months = (0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334) if 0 2): sum += 1 print('it is the %dth day.' % sum) Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-05-15 15:25:34 "},"Python/Python基础知识/流程控制.html":{"url":"Python/Python基础知识/流程控制.html","title":"流程控制","keywords":"","body":"流程控制 流程控制以循环为主，旨在让计算机重复的完成事情。 条件循环 while while循环是基于条件的循环，while本身具有if判断的功能，当条件为真时开始重复执行子代码块中的内容直至条件为假后跳出循环。 tag = 10 while tag > 5: print(\"tag的数值目前是:{num}\".format(num=tag)) tag -= 1 print('while循环执行完毕') print(tag) tag = 10 while tag > 5: print(\"tag的数值目前是:{num}\".format(num=tag)) tag -= 1 print('while循环执行完毕') print(tag) # tag的数值目前是:10 # tag的数值目前是:9 # tag的数值目前是:8 # tag的数值目前是:7 # tag的数值目前是:6 # while循环执行完毕 # 5 条件退出 while只有在每一次的循环开始前才会检测条件是否为真，如果条件在子代码块内部发生改变则本次的循环并不会立即退出，如下所示： count = 5 while count != 10: # 修改条件后。不会立刻退出 count = 10 print(\"当前count的数值为:\", count) print(\"----> 执行中\") print(\"执行完毕..\") # 当前count的数值为: 10 # ----> 执行中 # 执行完毕.. while/else while循环正常结束后，会执行else代码块中的代码： 正常结束的while循环是指不被强制break的while循环 tag = 3 while tag: print(tag) tag -= 1 else: print(\"else...\") # 3 # 2 # 1 # else... 死循环 当while的结果永远为真时，将引发死循环。 单纯的死循环不会引来性能损耗问题，但是如果做一些计算操作则必将会对CPU带来极大的性能压力。 tag = 1 while 1: tag += 10 # CPU没有休息时间 迭代循环 for for循环内部是基于while循环来完成的，for循环在对容器的取值上比while循环更加的方便。 for循环常用于取值操作，以下是语法介绍： for 迭代变量 in 可迭代对象（暂时可理解为容器类型） 逻辑操作... 以下是使用while循环进行取值，相当麻烦： li = [1, 2, 3, 4, 5] index = 0 while 1: try: print(li[index]) except IndexError: break index += 1 # 1 # 2 # 3 # 4 # 5 如果使用for循环，那么就变的简单许多： li = [1, 2, 3, 4, 5] for i in li: print(i) # 1 # 2 # 3 # 4 # 5 迭代退出 for循环的正常退出是遍历完整个可迭代对象之后进行退出。 li = [1, 2, 3, 4, 5] for i in li: print(i) print(\"结束了\") # 1 # 2 # 3 # 4 # 5 # 结束了 for/else 当for循环正常退出结束后，会执行else下的代码块： 正常结束的for循环是指不被强制break的for循环 li = [1, 2, 3, 4, 5] for i in li: print(i) else: print(\"else..\") # 1 # 2 # 3 # 4 # 5 # else.. range() 如果我们有一个需求需要让计算机重复打印5次hello,world，你可能会这样做： count = 5 while count: print(\"hello,world\") count -= 1 也可以使用for循环来进行完成，但是这样会很麻烦，由于使用for循环必须遍历一个可迭代对象，所以要先创建一个可迭代对象： count = [0, 1, 2, 3, 4] for i in count: print(\"hello,world\") 如果你使用range()，这一切都会变得非常简单，range()会帮助你快速的创建一个可迭代对象，我们只需要指定它的次数即可： for i in range(5): print(\"hello,world\") 关于range()方法的其他讲解，会在下面进行。 容器遍历 字符串遍历 示例演示： string = \"hello,world\" for i in string: print(\"索引:{0:d},值:{1:s}\".format(string.index(i), i)) # 索引:0,值:h # 索引:1,值:e # 索引:2,值:l # 索引:2,值:l # 索引:4,值:o # 索引:5,值:, # 索引:6,值:w # 索引:4,值:o # 索引:8,值:r # 索引:2,值:l # 索引:10,值:d 列表遍历 普通遍历： li1 = [1, 2, 3, 4] for i in li1: print(i) 通过enumerate()函数来同时遍历2个相同长度的列表： li1 = [\"A\", \"B\", \"C\", \"D\"] li2 = [\"a\", \"b\", \"c\", \"d\"] for index, item in enumerate(li1): li1Message = str.format(\"li1 -> {0:d} -> {1:s}\", index, item) print(li1Message) li2Message = str.format(\"li2 -> {0:d} -> {1:s}\", index, li2[index]) print(li2Message) 通过[::-1]来反向遍历列表： li1 = [\"A\", \"B\", \"C\", \"D\"] for i in li1[::-1]: print(i) 隔一个取一个的遍历列表： li1 = [\"A\", \"B\", \"C\", \"D\"] for i in li1[::2]: print(i) 字典遍历 普通的遍历只会遍历出key，这样的操作等同于遍历dict.keys()： dic = { \"k1\": \"v1\", \"k2\": \"v2\", \"k3\": \"v3\", } for k in dic: print(k) # k1 # k2 # k3 如果你想取出value，则可以遍历dict.values()： dic = { \"k1\": \"v1\", \"k2\": \"v2\", \"k3\": \"v3\", } for v in dic.values(): print(v) # v1 # v2 # v3 如果你想同时取出key和value，则可以遍历dict.items(): dic = { \"k1\": \"v1\", \"k2\": \"v2\", \"k3\": \"v3\", } for k, v in dic.items(): print(k, v) # k1 v1 # k2 v2 # k3 v3 局部作用域 如果一个迭代变量的命名为i，那么这个迭代变量能在外部访问到吗？答案是能！ 其实在Python2和Python3中，普通的for循环语句是没有局部作用域这一个说法的，希望在未来版本能有所改进。 for i in range(10): pass # pass代表省略 print(i) # 9 循环控制 countinue 在while/for中均可以使用countinue跳过本次循环。 以下用for循环进行举例： for i in range(5): if i == 3: continue else: print(i) # 0 # 1 # 2 # 4 break 在while/for中均可以使用break结束本层循环。 以下用for循环进行举例： for i in range(5): if i == 3: break else: print(i) # 0 # 1 # 2 循环嵌套 while嵌套 while循环支持多层嵌套，在使用时注意下面的事项： 如果是使用基于条件退出那么所有的while循环都必须遵循同一个条件才能退出。 break只针对当前的while循环体退出，对于非当前的while循环体不生效。 continue只针对当前while循环体跳过，对于非当前的while循环体不生效。 对于注意事项1的示例如下： # 错误示范 tag1 = 1 tag2 = 2 while tag1 == 1: print(\"一层..\") while tag2 == 2: print(\" 二层..\") while tag2 == 2: print(\" 三层..\") tag2 = 3 # 由于条件不同。只退出 第二层和第三层。 # ==== 执行结果 ==== \"\"\" 一层.. 二层.. 三层.. 一层.. 一层.. 一层.. （无限打印） \"\"\" # ==============================================手动分割线============================================== # 正确示范 tag3 = 3 while tag3: print(\"一层..\") while tag3: print(\" 二层..\") while tag3: print(\" 三层..\") tag3 = False # 可以看到全部退出了。 # ==== 执行结果 ==== \"\"\" 一层.. 二层.. 三层.. \"\"\" 对于注意事项2的示例如下，注意事项3同理： # ==== 多层while循环基于break退出注意事项 ==== # 错误示范 tag1 = 1 tag2 = 2 while tag1 == 1: print(\"一层..\") while tag2 == 2: print(\" 二层..\") while tag2 == 2: print(\" 三层..\") break # 跳出三层。回到二层。执行三层。跳出三层。回到二层。执行三层。 # ==== 执行结果 ==== \"\"\" 一层.. 二层.. 三层.. 二层.. 三层.. 二层.. 三层.. （无限打印） \"\"\" # ==============================================手动分割线============================================== # 正确示范 tag3 = 3 while tag3: print(\"一层..\") while tag3: print(\" 二层..\") while tag3: print(\" 三层..\") break # 跳出三层 break # 跳出二层 break # 跳出一层 # ==== 执行结果 ==== \"\"\" 一层.. 二层.. 三层.. \"\"\" for嵌套 for循环同样支持嵌套。 外层执行1次，内层的for循环要全部循环完成才回到外层执行第2次。 li1 = [\"a\", \"b\"] li2 = range(2) # 0,1 for i in li1: print(\"============\") print(\"外层循环\") print(i) for j in li2: print(\" 内层循环\") print(\" \", j) \"\"\" ============ 外层循环 a 内层循环 0 内层循环 1 ============ 外层循环 b 内层循环 0 内层循环 1 \"\"\" 以下是使用for循环打印乘法表的例子： for i in range(1, 10): for j in range(1, i+1): print(\"%d*%d=%d \" % (j, i, i*j), end=\"\") print(\"\") # 1*1=1 # 1*2=2 2*2=4 # 1*3=3 2*3=6 3*3=9 # 1*4=4 2*4=8 3*4=12 4*4=16 # 1*5=5 2*5=10 3*5=15 4*5=20 5*5=25 # 1*6=6 2*6=12 3*6=18 4*6=24 5*6=30 6*6=36 # 1*7=7 2*7=14 3*7=21 4*7=28 5*7=35 6*7=42 7*7=49 # 1*8=8 2*8=16 3*8=24 4*8=32 5*8=40 6*8=48 7*8=56 8*8=64 # 1*9=9 2*9=18 3*9=27 4*9=36 5*9=45 6*9=54 7*9=63 8*9=72 9*9=81 range()详解 range() range()方法在Python2中返回的是一个列表，而在Python3中返回的是一个可迭代对象（这种可迭代对象不会存值，而是惰性求值，类似于生成器）。 range()方法有三个参数，如下表所示： 参数介绍 描述 start 从几开始生成 stop 生成到几结束 step 步长间距 在使用range()进行生成时，需要注意顾头不顾尾。 如下所示： li = list(range(1, 10, 2)) print(li) # [1, 3, 5, 7, 9] xrange() Python2中的xrange()与Python3中的range()相同，均返回可迭代对象，而非列表。 关于为什么做，其实是为了节省内存空间。 列表中的具体值会存在内存中，而如果是一个通过计算可惰性求值的可迭代对象，则不会消耗太大的内存，以下是自定义range()的实现。 class MyRange(): def __init__(self, start, stop, step=0): self.start = start self.stop = stop self.step = step self.old = start # 开始值 def __iter__(self): return self def __next__(self): if self.old 实例练习 使用for循环打印三角形： for i in range(1, 6): for j in range(1, 6 - i): print(\" \", end=\"\") for k in range(1, i + 1): print(\"* \", end=\"\") print(\"\") # * # * * # * * * # * * * * # * * * * * 有四个数字：1、2、3、4，能组成多少个互不相同且无重复数字的三位数？各是多少？ count = 0 for i in range(5): for j in range(1, 5): for k in range(1, 5): if (i != k) and (i != j) and (j != k): count += 1 print(i, j, k) print(count) # 36 斐波拉契数列是这样的一个数列：0、1、1、2、3、5、8、13、21、34、…… 前2个值加起来的结果恰好等于第3个值，求一个长度为10的斐波拉契数列： n = 10 fibArray = [] a , b = 0, 1 for i in range(n): fibArray.append(a) a, b = b, a + b print(fibArray) # [0, 1, 1, 2, 3, 5, 8, 13, 21, 34] 输入2个数字，求2个数字的最小公倍数： x = int(input(\">>>\")) y = int(input(\">>>\")) minCommonMultiple = None if x > y: greater = y else: greater = x while 1: if ((greater % x == 0 ) and (greater % y == 0)): minCommonMultiple = greater break greater += 1 msg = str.format(\"{0}和{1}的最小公倍数为{2}\", x, y, minCommonMultiple) print(msg) 输入2个数字，求2个数字的最大公约数： x = int(input(\">>>\")) y = int(input(\">>>\")) maxCommonDivisor = None if x > y: smaller = y else: smaller = x for i in range(1, smaller + 1): if ((x % i == 0) and (y % i == 0)): maxCommonDivisor = i msg = str.format(\"{0}和{1}的最大公约数为{2}\", x, y, maxCommonDivisor) print(msg) Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-05-15 15:23:27 "},"Python/Python基础知识/推导式.html":{"url":"Python/Python基础知识/推导式.html","title":"推导式","keywords":"","body":"推导式 推导式意在能用最精简的代码创建出一个容器类型，是在不丧失代码可读性的前提下最大程度精简代码的一系列操作。 Python从Haskell语言中取得灵感，创建了一系列的推导式。 列表推导式 应用场景 有一个列表中存了一些人名和性别的元组数据项，我需要将性别为男性的数据项提取至一个新的列表中。 如下所示，在没有学习列表推导式之前， 你可能会这样做： oldList = [ [\"Tom\", \"Male\"], [\"Jack\", \"Male\"], [\"Mary\", \"Female\"], [\"Laura\", \"Female\"] ] newList = [] for li in oldList: if li[-1].lower() == \"male\": newList.append(li) print(newList) # [['Tom', 'Male'], ['Jack', 'Male']] 如果有列表推导式的帮助，这样的场景就简单很多，它的语法如下： newList = [ 被添加/操作的数据项 for 迭代变量 in 可迭代对象 if 条件] 那么精简后的代码如下所示： oldList = [ [\"Tom\", \"Male\"], [\"Jack\", \"Male\"], [\"Mary\", \"Female\"], [\"Laura\", \"Female\"] ] newList = [li for li in oldList if li[-1].lower() == \"male\"] print(newList) # [['Tom', 'Male'], ['Jack', 'Male']] 只有if条件成立后迭代变量才会被添加至新列表中，注意不能跟else，不符合条件的迭代变量将会被直接舍弃。 快速创建列表 使用列表推导式可以快速的创建一个列表，如下所示，推导出了1个1-10的列表： newLi = [i for i in range(1, 11)] print(newLi) # [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] 下面的示例中，我们可以快速的推导出了一副扑克牌的列表： newLi = [ i + str(j) for i in [\"❤\", \"♧\", \"♤\", \"♢\"] for j in range(1, 14)] newLi.append(\"bigKing\") newLi.append(\"smallKing\") print(newLi) 结果如下： ['❤1', '❤2', '❤3', '❤4', '❤5', '❤6', '❤7', '❤8', '❤9', '❤10', '❤11', '❤12', '❤13', '♧1', '♧2', '♧3', '♧4', '♧5', '♧6', '♧7', '♧8', '♧9', '♧10', '♧11', '♧12', '♧13', '♤1', '♤2', '♤3', '♤4', '♤5', '♤6', '♤7', '♤8', '♤9', '♤10', '♤11', '♤12', '♤13', '♢1', '♢2', '♢3', '♢4', '♢5', '♢6', '♢7', '♢8', '♢9', '♢10', '♢11', '♢12', '♢13', 'bigKing', 'smallKing'] 元素的处理 数据项在添加至列表之前，可以为其进行一些操作。 比如在上面扑克牌的示例中，我们将int对象转换为了str对象，同理也可以做一些别的操作。 如下示例，我们将推导出一个从1 - 26个字母的列表： newLi = [chr(i) for i in range(65, 64 + 27)] print(newLi) # ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'] 迭代变量 需要注意的是，迭代变量与条件成立后添加的数据项没有任何关系，如下所示，仅循环10次，添加了10个A，迭代变量i根本没被用到： newLi = [chr(65) for i in range(10)] print(newLi) # ['A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A'] 字典推导式 使用示例 字典推导式和列表推导式基本差不多，但是外部是用花括号包裹，并且要有:进行key和value的区分。 第1个例子，基本使用，快速的推导出ASCII码表的对照关系： asciiDict = {i: chr(i) for i in range(0, 128)} print(asciiDict) 结果如下： {0: '\\x00', 1: '\\x01', 2: '\\x02', 3: '\\x03', 4: '\\x04', 5: '\\x05', 6: '\\x06', 7: '\\x07', 8: '\\x08', 9: '\\t', 10: '\\n', 11: '\\x0b', 12: '\\x0c', 13: '\\r', 14: '\\x0e', 15: '\\x0f', 16: '\\x10', 17: '\\x11', 18: '\\x12', 19: '\\x13', 20: '\\x14', 21: '\\x15', 22: '\\x16', 23: '\\x17', 24: '\\x18', 25: '\\x19', 26: '\\x1a', 27: '\\x1b', 28: '\\x1c', 29: '\\x1d', 30: '\\x1e', 31: '\\x1f', 32: ' ', 33: '!', 34: '\"', 35: '#', 36: '$', 37: '%', 38: '&', 39: \"'\", 40: '(', 41: ')', 42: '*', 43: '+', 44: ',', 45: '-', 46: '.', 47: '/', 48: '0', 49: '1', 50: '2', 51: '3', 52: '4', 53: '5', 54: '6', 55: '7', 56: '8', 57: '9', 58: ':', 59: ';', 60: '', 63: '?', 64: '@', 65: 'A', 66: 'B', 67: 'C', 68: 'D', 69: 'E', 70: 'F', 71: 'G', 72: 'H', 73: 'I', 74: 'J', 75: 'K', 76: 'L', 77: 'M', 78: 'N', 79: 'O', 80: 'P', 81: 'Q', 82: 'R', 83: 'S', 84: 'T', 85: 'U', 86: 'V', 87: 'W', 88: 'X', 89: 'Y', 90: 'Z', 91: '[', 92: '\\\\', 93: ']', 94: '^', 95: '_', 96: '`', 97: 'a', 98: 'b', 99: 'c', 100: 'd', 101: 'e', 102: 'f', 103: 'g', 104: 'h', 105: 'i', 106: 'j', 107: 'k', 108: 'l', 109: 'm', 110: 'n', 111: 'o', 112: 'p', 113: 'q', 114: 'r', 115: 's', 116: 't', 117: 'u', 118: 'v', 119: 'w', 120: 'x', 121: 'y', 122: 'z', 123: '{', 124: '|', 125: '}', 126: '~', 127: '\\x7f'} 第2个例子，对于迭代一些特殊格式的容器，可以直接生成出一个字典： userMessage = [(\"name\", \"Yunya\"), (\"age\", 18), (\"gender\", \"male\")] newDict = {k: v for k, v in li1} print(newDict) # {'name': 'Yunya', 'age': 18, 'gender': 'male'} 集合推导式 使用示例 集合推导式和字典推导式相同，唯一区别仅在与不需要：和value，以下是示例演示： newSet = {chr(i) for i in range(65, 64 + 27)} print(newSet) # {'E', 'Q', 'G', 'Z', 'A', 'R', 'P', 'M', 'H', 'V', 'W', 'I', 'B', 'X', 'D', 'J', 'S', 'F', 'Y', 'N', 'T', 'L', 'C', 'U', 'K', 'O'} 局部作用域 之前聊过普通的for循环中是不存在局部作用域的，那么在推导式当中是否存在局部作用域呢？ 以列表举例： newList = [i for i in range(10)] print(i) # NameError: name 'i' is not defined 可以看见，在推导式中的局部作用域是存在的。 元组推导式？ 我们上面介绍了基本的4大容器中的3大容器推导式，为何没有介绍元组推导式？ 其实，Python中并未提供元组推导式，而是提供了生成器表达式。 元组本身就是不可变类型，对比列表推导式，它的工作原理其实就是迭代一个可迭代对象然后使用append()进行添加数据项。 由于元组是不可变类型故不能尝试改变其本身容器中数据项的个数。 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-05-15 19:01:48 "},"Python/Python函数相关/summary.html":{"url":"Python/Python函数相关/summary.html","title":"Python函数相关","keywords":"","body":"Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-05-12 13:02:58 "},"Python/Python模块与包/summary.html":{"url":"Python/Python模块与包/summary.html","title":"Python模块与包","keywords":"","body":"Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-05-12 13:06:53 "},"Python/Python面向对象/summary.html":{"url":"Python/Python面向对象/summary.html","title":"Python面向对象","keywords":"","body":"Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-05-12 13:02:58 "},"Python/Python数算基础/summary.html":{"url":"Python/Python数算基础/summary.html","title":"Python数算基础","keywords":"","body":"Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-05-12 13:02:58 "},"Python/Python设计模式/summary.html":{"url":"Python/Python设计模式/summary.html","title":"Python设计模式","keywords":"","body":"Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-05-12 13:02:58 "},"Python/Python网络编程/summary.html":{"url":"Python/Python网络编程/summary.html","title":"Python网络编程","keywords":"","body":"Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-05-12 13:02:58 "},"Python/Python并发编程/summary.html":{"url":"Python/Python并发编程/summary.html","title":"Python并发编程","keywords":"","body":"Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-05-12 13:02:58 "},"Python/Python驱动程序/summary.html":{"url":"Python/Python驱动程序/summary.html","title":"Python驱动程序","keywords":"","body":"Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-05-12 16:48:48 "},"Python/Python基础知识/字符编码.html":{"url":"Python/Python基础知识/字符编码.html","title":"字符编码","keywords":"","body":"存储编码 一般来说，我们用什么方式进行文件存储，就用什么编码方式对其进行打开。 现在，一般使用UTF8进行存储即可。 这样在打开文件后，计算机内部能够使用Unicode为UTF8进行解码工作。 执行编码 Python3中在执行代码时，解释器都会按照UTF8编码格式将脚本文件中的代码加载至内存中，所以一般不会出现问题。 但是在Python2里解释器则是使用ASCII的编码格式进行脚本文件内容的解码，这是因为Python2出现时，Unicode字符编码还没有投入使用。 所以你可能会遇上下面的情况： SyntaxError:Non-ASCII character .... in file ... 解决这个办法，可以利用头文件代码，让Python解释器在解码脚本文件内容时，以UTF8格式进行解码： # --*-- coding:UTF8 --*-- # 开始书写你的代码 Unicode字符串 Python2中的字符串，根据不同的系统平台会按照不同的格式进行解码。 如Mac/Linux/PyCharm下都会使用Unicode对字符串进行解码， 而Windows环境下会使用GBK对字符串进行解码。 Python3中的字符串，不论平台，统一会都会按照Unicode进行解码。 所以你可能在打印某一条语句时，发现Python2中的字符串会显示乱码，解决方案就是在字符串前加上u，指定该字符串的解码方式为Unicode： print u\"这是使用Unicode进行解码的字符串\" ​ Python2解决乱码 使用头文件代码，指定脚本加载时采用UTF8进行解码： # -*- coding:utf-8 -*- 在字符串前面，加上u，指定字符串的解码方式为Unicode： print u\"这是使用Unicode进行解码的字符串\" Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-05-16 21:32:03 "},"Python/Python基础知识/文件操作.html":{"url":"Python/Python基础知识/文件操作.html","title":"文件操作","keywords":"","body":"open() Python中提供了open()方法用于对文件进行操作，并且返回一个文件对象。 文件内容本身全部属于str类型，故使用open()方法对其进行操作必然涉及字符编码的问题。 以下是open()方法的函数签名： def open(file: Union[str, bytes, int, _PathLike[Any]], mode: str = ..., buffering: int = ..., encoding: Optional[str] = ..., errors: Optional[str] = ..., newline: Optional[str] = ..., closefd: bool = ..., opener: Optional[Callable[[str, int], int]] = ...) -> IO[Any]: 下面是对常用参数的解释： 参数名 描述 file 必需，文件路径（相对或者绝对路径） mode 可选，文件内容读取与操作模式，*t模式以为文本内容读取模式打开文件。需要填入encoding，b模式为二进制模式读取文件内容，默认该参数为*t 。*代表操作模式 encoding 可选（Python2没有该参数），当mode为 *t 时指定编码或解码格式。一般设置为 utf-8。如不指定Windows平台默认为GBK，Mac和Linux平台为utf-8 buffering 设置缓冲 errors 报错级别 newline 是否区分换行符，默认为True closefd 传入的file参数类型 以下是在Python3中进行读取文件的简单示例： f = open(file=\"test.txt\", mode=\"rt\", encoding=\"utf-8\") print(f.read()) # ① f.close() # ② ①：read()读取所有内容 ②：关闭文件句柄 with语句 在open()后要切记关闭文件句柄，释放系统资源。 但是可能会对关闭文件句柄的操作进行遗忘，推荐使用with语句进行操作，它将在with子代码块结束后自动关闭文件句柄。 with open(file=\"test.txt\", mode=\"rt\", encoding=\"utf-8\") as f: print(f.read()) 使用with语句还可以同时打开多个文件，示例如下，\\可进行换行： with open(file=\"test.txt\",mode=\"rt\",encoding=\"utf-8\") as f1,\\ open(file=\"test2.txt\",mode=\"rt\",encoding=\"utf-8\") as f2: data1 = f1.read() print (data1) data2 = f2.read() print (data2) 读写内容模式 t模式 当打开一个文件时，默认以*t模式打开。 t代表以文本方式读取文件内容，读取的都是字符。 with open(file=\"test.txt\", mode=\"rt\", encoding=\"utf-8\") as f: result = f.read(3) # ① print(result) ①：指定读取的字符数量 b模式 如果以b模式打开文件，则读取到的都是字节。 字节模式打开文件，不存在字符编码的问题 with open(file=\"test.txt\", mode=\"rb\") as f: result = f.read(3) # ① print(result) # b'\\xe6\\xb5\\x8b' hans = result.decode(\"utf-8\") print(hans) # ② ①：指定读取的字节数量 ②：解码 读写操作模式 r模式 r代表只读，当使用r模式打开文件时文件的指针将跑到最开始，并且如果文件不存在将会抛出异常。并且只能使用读取相关的方法。 with open(file=\"test.txt\", mode=\"rb\") as f: print(f.readlines()) w模式 w模式代表只写，当使用w模式打开文件时就相当于新建一个文件。如果文件已存在将清空原本文件中所有的内容，如果文件不存在则创建新文件，只能使用写入相关的方法。 with open(file=\"test.txt\", mode=\"wb\") as f: data = \"你好世界\" f.write(data.encode(\"utf-8\")) a模式 a模式为追写模式，当文件不存在时创建新文件。只能执行写相关的操作，当文件存在时则打开文件，文件指针放到最后，所以被称为追写模式。 强调 w 模式与 a模式的异同： 相同点：在打开的文件不关闭的情况下，连续的写入，新写的内容总会跟在前写的内容之后 不同点：以 a 模式重新打开文件，不会清空原文件内容，会将文件指针直接移动到文件末尾，新写的内容永远写在最后 with open(file=\"test.txt\", mode=\"ab\") as f: f.write(b'\\nnew line...') x模式 x模式与w模式都相同。 唯一不同的地方在于如果需要打开的文件已存在，x模式会抛出异常。 而w模式会新建一个同名文件并且删除掉旧文件。 with open(file=\"test.txt\", mode=\"xb\") as f: f.write(b'\\nnew line...') # FileExistsError: [Errno 17] File exists: 'test.txt' +模式 +这里是对 r w a 的一种扩展。 代表可读可写，但是打开文件后文件指针的位置还是依照 r w a 原本的位置，应该尽量少用+方法。 with open(file=\"test.txt\", mode=\"r+b\") as f: data = f.read() print(data) f.seek(0, 2) f.write(b\"A new line again\\n\") 文件指针 使用seek()函数可以对文件指针进行操作。 以下是seek()函数的签名： def seek(self, offset: int, whence: int = 0) -> int 注意，使用文件指针应该在*b模式下进行使用，它的移动将会按照字节进行移动。 如果是*t模式下，按照字符移动可能会出现某些错误。 参数 描述 offset 偏移量，负数代表向前移动指针，正数代表向后移动指针 whence 偏移位置，0代表起始位置，1代表当前位置，2代表结束位置 示例如下： with open(file=\"test.txt\", mode=\"rb\") as f: # ① print(f.tell()) # ② f.seek(2, 0) f.seek(10, 0) f.seek(20, 0) print(f.tell()) # ③ f.seek(-2, 1) f.seek(-3, 1) f.seek(-4, 1) print(f.tell()) # ④ # 0 # 20 # 11 ①：注意，文件指针除了（0，0）和（0,2）外，其他都应该用b模式进行。 ②：打印当前文件指针的位置 0 ③：打印当前文件指针的位置 20 ④：由于是相对定位，故可以累加。 20 - 9 ，文件指针在 11 循环读取 for循环 如果直接使用f.read()。当文件内容过于庞大时，这些内容全部会存放于Python程序的内存空间中。会给内存带来极大的压力，故在文件较小时才使用f.read()，太大的话将使用其他解决方案，如下面的for循环进行读取： data = b\"\" with open(\"test.txt\", mode=\"rb\") as f: for line in f: # ① data += line print(data.decode(\"utf-8\")) ①：直接读取f代表每次读一行，以\\n为单位 while循环 如果一个文件只有一行，如压缩版的前端代码。 在读取时则可使用while循环进行读取，示例如下： data = b\"\" with open(\"test.txt\", mode=\"rb\") as f: while 1: temp = f.read(512) data += temp if not len(temp): break print(data.decode(\"utf-8\")) 文件写入 内存写入 文本编辑器的原理是在打开一个文本文件时其中所有的内容都会存放于内存中。 对该文本内容的修改实际上全部都是在修改内存中的数据，当修改完成后点击保存时才会将内存的数据重新写入至硬盘中。 你应该深有体会，打开一个特别大的文本文件时速度很慢，哪怕没做任何修改保存时速度也还是很慢。那么就是这个原因导致的。 以下是模拟内存写入，打开文件后将“计算机”替换为“电脑”： data = \"\" # ① with open(file=\"BigFileTest.txt\", mode=\"rt\", encoding=\"utf-8\") as f: # ② while 1: temp = f.read(512) data += temp # ③ print(data) # ④ if not len(temp): # ⑤ break print(\"读取完毕..\") data = data.replace(\"计算机\", \"电脑\") # ⑥ with open(file=\"BigFileTest.txt\", mode=\"wt\", encoding=\"utf-8\") as f: # ⑦ f.write(data) print(\"写入完毕..\") ①：用于存放数据 ②：r模式的指针默认放在0位置 ③：代表每次读取512个字符 ④：这里可以做其他操作 ⑤：代表没有新的内容。 len(temp) == 0 ⑥：模拟手动修改文件内容。将计算机修改为电脑，注意此时修改的是内存中的数据 ⑦：读取后将Python应用程序中维护的data变量中的数据全部写入该文件。w模式会清空源文件的内容 硬盘时刷 文本编辑器的做法是在内部维护了一个变量，用于提供给用户修改内容。 这么做的好处就是用户可以在修改文件内容时能够查看到所有的文件内容，但是坏处是占用内存空间太大。 这里再介绍一种减少内存压力的方式。 注意：两种方式没有优劣之分，只有使用场景不同的区别，还是和上面一样的操作，将“计算机”替换为“电脑”。 import os with open(file=\"BigFileTest.txt\", mode=\"rt\", encoding=\"utf-8\") as f1, \\ open(file=\".BigFileTest.txt.swap\", mode=\"wt\", encoding=\"utf-8\") as f2: # ① for line in f1: line = line.replace(\"计算机\", \"电脑\") # ② f2.write(line) # ③ print(\"操作完成..\") os.remove(\"BigFileTest.txt\") # ④ os.rename(\".BigFileTest.txt.swap\", \"BigFileTest.txt\") # ⑤ 这么做的坏处是没办法随时的修改内存中的变量数据，因为内存中根本没存文本文件内容。 只能按照设定好的程序走一遍，但是极大的节省了内存空间的占用。 ①：以. 开头的文件代表隐藏文件。以swap结尾的文件代表交换文件（可以理解为临时文件） ②：每次拿到和修改的只有line ③：写入交换文件中 ④：删除源文件 ⑤：修改临时文件的名字。与源文件保持一致 操作方法 以下是文件操作中常用的方法： 方法 描述 read() 读取某个文件(全部内容)。也可指定大小，t模式的大小为字符单位，b模式为字节单位 readline() 读取一行文件内容 readlines() 读取所有文件内容并返回一个列表，以行割开 write() 写入一行数据，默认不会\\n需要手动换行 writelines() 写入一行数据，通过列表的方式写到文件里面 tell() 显示当前文件光标的位置 seek() 移动当前文件光标的位置(字节为单位，建议在b模式下使用) readable() 文件是否可读 writable() 文件是否可写 closed 文件是否关闭 encoding 如果文件打开模式是b,则没有该属性 flush() 立刻将文件内容从内存刷到硬盘（测试模式下使用） Python2-open() 　由于Python2中不能使用encoding参数指定编解码的方式。所以我们看看在Python2中open()应该怎样使用： #!/usr/bin/env python2 # coding:utf-8 # import sys # reload(sys) # sys.setdefaultencoding('utf-8') # 设置默认的解码方式为 utf-8。如果这样操作就不用设置decode()了。 f = open(file=\"test.txt\",mode=\"rt\",) data = unicode(f.read().decode(\"utf-8\")) # unicode()将读取出的字符转为unicode字符存储于内存中。 print data f.close() Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-05-16 21:44:09 "}}