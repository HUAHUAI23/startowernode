{"./":{"url":"./","title":"Introduction","keywords":"","body":"专题阅读 我从2016年开始系统学习编程之后，便一直零零散散的记录着各种各样的笔记。 其中收集过很多相关资料，但是一直没有汇集成册。 刚好最近比较有空闲，就将自己的学习笔记汇聚成册，希望能够给大家提供帮助。 整体笔风可能不是特别面向新手，但是也应该能够对你有所帮助。 涵盖3大编程语言：Python\\Golang\\JavaScript 涵盖4大数据库产品：MySQL\\Redis\\Elasticsearch\\MongoDB 关于系统着重使用MacOS 10.14.6以及CentOS 7.3，暂时不提供Windows的相关文章。 系统配置是Core i5 4核心4线程、16G RAM、256SSD，也算是比较老的配置了。 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-21 14:10:14 "},"杂谈专栏/summary.html":{"url":"杂谈专栏/summary.html","title":"杂谈专栏","keywords":"","body":"Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-08-21 15:24:18 "},"杂谈专栏/编程语言区别.html":{"url":"杂谈专栏/编程语言区别.html","title":"编程语言区别","keywords":"","body":"低级语言 语言的高级和低级之分并不是说语言本身的层次高低，而是指的是与底层硬件的密切程度。 就如同机器语言与汇编语言就是直接与底层硬件打交道的语言，故也被称为低级语言。 机器语言 机器语言是不通过任何操作系统就可以直接与底层硬件打交道的语言，说白了就是计算机能读懂的二进制。 想要使用机器语言就得充分的了解计算机底层硬件的各个知识。 虽然这可能会花上你半生的时间，但是机器语言的执行效率却是无与伦比的高，计算机不需要通过任何编译就能直接运行。 与之相反的是机器语言的开发效率却是慢到令人发指，除了你需要去学习底层硬件相关的知识外还需要对每一条二进制指令烂熟于心，更加恐怖的是面对满屏的010101如果敲错一个字符就全部推倒重来，显然这已经超出了普通人所能承受的极限。 #指令部份的示例 0000 代表 加载（LOAD） 0001 代表 存储（STORE） ... ​ #暂存器部份的示例 0000 代表暂存器 A 0001 代表暂存器 B ... ​ #存储器部份的示例 000000000000 代表地址为 0 的存储器 000000000001 代表地址为 1 的存储器 000000010000 代表地址为 16 的存储器 100000000000 代表地址为 2^11 的存储器 ​ #集成示例 0000,0000,000000010000 代表 LOAD A, 16 0000,0001,000000000001 代表 LOAD B, 1 0001,0001,000000010000 代表 STORE B, 16 0001,0001,000000000001 代表 STORE B, 1[1] 名词 描述 执行效率 极高 开发效率 极低 跨平台性 极差（由于必须依赖具体的硬件，故移植性极差） 汇编语言 汇编语言仅仅是用一个英文标签代表一组二进制指令，毫无疑问，比起机器语言，汇编语言是一种进步，但汇编语言的本质仍然是直接操作硬件，因此汇编语言仍是比较低级/底层的语言、因为它十分的贴近计算机硬件。 汇编的中打印一句hello world，需要写十多行，如下： ; hello.asm section .data ; 数据段声明 msg db \"Hello, world!\", 0xA ; 要输出的字符串 len equ $ - msg ; 字串长度 section .text ; 代码段声明 global _start ; 指定入口函数 _start: ; 在屏幕上显示一个字符串 mov edx, len ; 参数三：字符串长度 mov ecx, msg ; 参数二：要显示的字符串 mov ebx, 1 ; 参数一：文件描述符(stdout) mov eax, 4 ; 系统调用号(sys_write) int 0x80 ; 调用内核功能 ; 退出程序 mov ebx, 0 ; 参数一：退出代码 mov eax, 1 ; 系统调用号(sys_exit) int 0x80 ; 调用内核功能 名词 描述 执行效率 极高 开发效率 低 跨平台性 极差（由于必须依赖具体的硬件，故移植性极差） 高级语言 高级语言并不关心底层硬件到底怎么样，因为高级语言是在和操作系统打交道。 而操作系统又是管控硬件的软件，所以高级语言相较于低级语言来说它的开发效率肯定是要快上不少，但是在执行效率上却有所损失。 对于语言的好坏一味的按照执行效率来区分并非是正确的，语言本身只是一种工具，使用语言的人才是真正的操纵者。 语言的对比只应场景适不适用，其本身并无强弱之分。 比如要对底层硬件进行开发，那么无疑汇编语言是最佳的选择，它能与本机硬件打交道所以能充分发挥自己执行效率高的特性，再比如要做一款网络爬虫相关的软件，由于网络具有延迟性会拖慢程序整体的运行速度，故使用汇编语言来编写爬虫便成了弱势（开发周期长，网络环境让汇编语言的高执行效率也体现不出来）。 高级语言中按照翻译方式的不同又大体可分为两类，分别是编译型语言与解释型语言。 编译型语言 如Golang，C语言等均为编译型语言。 编译型语言特点： 执行效率高：生成的目标文件可以脱离语言环境独立执行（因为都是存的二进制指令） 开发效率低：如果程序需要修改某一功能则必须修改源程序中的代码后再次生成目标程序，倘若只有目标程序而没有源程序的话则修改原本的功能是一件很困难的事情，这样做的好处是保证了代码的安全性，除开通过反编译技术手段否则看不见源代码 跨平台性差：大多数编译型语言的代码只针对某一个平台下进行编译，前平台下的编译结果（目标程序）无法拿到不同的平台上使用 其他：现在大多数的编程语言都是编译型的。编译程序（GCC）将源程序翻译成目标程序后保存在另一个文件中，该目标程序可脱离编译程序直接在计算机上多次运行。大多数软件产品都是以目标程序形式发行给用户的，不仅便于直接运行提升执行效率，同时又使他人难于盗用其中的技术 解释型语言 如Python，JavaScript均为解释型语言。 解释型语言特点： 执行效率低：在解释型语言的实现中，解释器并不产生目标机器代码，而是产生易于执行的中间代码。这种中间代码与机器代码是不同的，中间代码的解释是由软件支持的，不能直接使用硬件，软件解释器通常会导致执行效率偏低 开发效率高：用解释型语言编写的程序是由另一个可以理解中间代码的解释程序执行的，与编译程序不同的是，解释程序的任务是逐一将源程序的语句解释成可执行的机器指令，不需要将源程序翻译成目标代码再执行。解释程序的优点是当语句出现语法错误时，可以立即引起程序员的注意。让程序员在程序开发期间就能进行校正，故开发效率高于编译性语言 跨平台性强：代码运行是依赖于解释器，不同平台有对应版本的解释器，所以解释型语言的跨平台性更强 其他：对于解释型Basic语言，需要一个专门的解释器解释执行Basic程序，每条语句只有在执行时才被翻译，这种解释型语言每执行一次就翻译一次，因而效率低下。一般地，动态语言都是解释型的，例如：Tcl、Perl、Ruby、VBScript、JavaScript等 除此之外，还有一种混合型语言，如Java：Java语言首先会生成Java汇编，然后通过虚拟机进一步转换成计算机可以识别的二进制汇编语言。 动态与静态 动态类型：如果一门语言可以在运行时改变变量的类型，那我们称之为动态类型语言（如Python） 静态类型：相反，如果一门语言不可以在运行时改变变量的类型，则称之为静态类型语言（如Golang） 动态类型示例（Python演示）： >>> string = str(\"hello,world\") >>> type(string) >>> string = b\"\" >>> type(string) >>> 静态类型示例（Golang演示）： func main() { var str string str = \"hello,world\" fmt.Printf(\"%T\",str) str = 't' // 编译出现异常，不允许改变类型 } 强类型与弱类型 强类型：如果一门语言不倾向于对变量的类型做隐式转换，那我们将其称之为强类型语言（如Python） 弱类型：相反，如果一门语言倾向于对变量的类型做隐式转换，那我们则称之为弱类型语言（如JavaScript） 强类型示例（Python演示）： >>> 1 == \"1\" False 弱类型示例（JavaScript演示）： \"use strict\"; console.log(1 == \"1\"); // true Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-13 20:41:52 "},"杂谈专栏/详解字符编码.html":{"url":"杂谈专栏/详解字符编码.html","title":"详解字符编码","keywords":"","body":"字符编码 计算机使用计算机语言（2进制）表示数据，人类使用自然语言表示数据。 人类若想和计算机进行无障碍沟通，必须要通过一本记载着计算机语言与自然语言关系的词典。 而通过这本词典与计算机进行沟通交互的过程即可被称为字符的编码、解码的过程： 编码是指将自然语言转换为计算机语言的过程。 解码是指将计算机语言转换为自然语言的过程。 ASCII 计算机由西方世界发明，所以第一个字符编码表仅记录了一些英文与符号，该表也被称为ASCII码表。 它仅支持一些英文字符与特殊符号，不支持其他国家的语言字符。 实际上ASCII码表在设计之初，就预留了一些位置，最初的ASCII码表中每一个字符仅占用7bit的位置，也就最多表示128个字符。 最初的ASCII码表仅有128个字符，后来经过扩展，又新增了128个字符，此时的ASCII码表中，一个字符占用1Bytes（8bit）的位置。： GBK 随着计算机在世界范围内高速发展，ASCII码表已经不满足广大用户的需求了。 此时，各个国家开始推出自己的字符编码表，如： 日本的Shift-JIS表等 韩国的Euc-Kr表等 中国的gb2312、GBK表等 ... 这些表都有一个特点，即除了包含原本的ASCII码表之外还包含了本国的通用语言。 在GBK编码表中，一个英文字符占用1Bytes(8bit)，而一个中文字符则占用2Bytes(16bit)。 此时，出现了1个严重的问题，即跨国的通信问题，如下图所示： Unicode 为了解决这个问题，在1990年的时候推出了Unicode表，并且在1994年正式使用。 它详细的记录了所有自然语言与计算机语言的对应关系，在（usc2标准）中每一个字符不管是英文还是中文都占用2个Bytes（16bit），而在（usc4标准）中则统一占用4个Bytes（32bit），这样就解决了跨国通信的问题。 对比ASCII码表英文字符仅占用1个Bytes而言，如果直接使用Unicode编码进行文件存储则存储空间会直接翻倍，因此Unicode表仅存在于内存之中，而在网络传输以及文件存储上则采用了另外的编码格式。 换句话说，Unicode仅作为翻译词典存在于计算机内部，Unicode因为包含了所有自然语言与计算机语言的关系，因此作为翻译词典是最合适不过的。 UTF8 如下图，中文网站由GBK编码存储，国内的计算机中应该都有GBK编码，所以访问该网站非常轻松，而在日本计算机上若想访问该网站则必须要先下载GBK后方能以GBK的解码形式打开该网站，否则会产生乱码问题。 那么有没有一种编码，能够统一整个互联网，让所有计算机都用这种编码进行文件存储、网络传输呢？ 此时，出现了UTF8编码，全称为Unicode Transformation Format，即Unicode的转换格式，它是一种可变长的编码格式。 在UTF8编码格式中，英文字符统一占用1Bytes(8bit)的位置，而中文字符则占用3Bytes(24bit)或者4Bytes(32Bytes)的位置。 UTF8编码是未来的发展趋势，它与Unicode对比的唯一区别在于它不包含其他字符编码表。 在依然存在以GBK编码格式、Shift-JIS编码格式进行文件存储的环境下，使用UTF8作为翻译词典并不合适。 但是如果有一天所有人都统一使用UTF8进行文件存储网络传输的话，那么就不再需要包含其他字符编码表了，此时UTF8将会真正代替Unicode入驻内存中成为翻译词典，当然这是后话，目前还没有达到这样的理想情况。 UTF8的编解码 UTF8与Unicode的关系如下： 编码过程 如我们要将“云”字根据UTF8格式存储到磁盘中： 1.通过Python3中的hex()和ord()函数先得出该字符Unicode的16进制表现形式： >>> hex(ord(\"云\")) '0x4e91' 2.再将这个16进制的Unicode字符转换为2进制，那么这个2进制就是“云”字在内存中存储的样子： >>> bin(int(\"4e91\",base=16)) '0b100111010010001' 3.现在，计算机要把“云”字写入磁盘中，由于是使用的UTF8编码格式，所以先确定它的占用空间是3Bytes还是4Bytes，规则如下，套用表即可： 码位范围（Unicode十六进制） utf-8 0000 ~ 007F 用1个Bytes表示 0080 ~ 07FF 用2个Bytes表示 0800 ~ FFFF 用3个Bytes表示 4e91 在这里，第3分区 10000 ~ 10FFFF 用4个Bytes表示 4.确定了“云”字占用3Bytes，我们可以通过一个模板，将Unicode的2进制转换为UTF8的2进制： 码位范围（十六进制） 转换模板 0000 ~ 007F 0XXXXXXX 0080 ~ 07FF 110XXXXX 10XXXXXX 0800 ~ FFFF 1110XXXX 10XXXXXX 10XXXXXX 10000 ~ 10FFFF 11110XXX 10XXXXXX 10XXXXXX 10XXXXXX 5.根据分区信息，选用3Bytes的模板，进行转换，从右至左依次填充，不够的使用0进行填充： 1110XXXX 10XXXXXX 10XXXXXX 100 111010 010001 1110XXXX 10XXXXXX 10XXXXXX 0100 111010 010001 # 填充0 11100100 10111010 10010001 # 结果 所以最后得出的结果，“云”用UTF8格式保存至磁盘的话，2进制格式为11100100 10111010 10010001。 解码过程 如果要将“云”字UTF8的2进制格式转换为字符，则还是需要通过Unicode进行解码过程。 当计算机读取到这个文件是以UTF8格式进行存储后，内部已经做好了通过UTF8进行解码的准备。 开始读取后，计算机会将硬盘中存储的UTF8的2进制格式文字信息加载至内存中： 11100100 10111010 10010001 现在，Unicode会参照模板，通过UTF8分区信息提取出该文字Unicode的2进制格式： 码位范围（十六进制） 转换模板 0000 ~ 007F 0XXXXXXX 0080 ~ 07FF 110XXXXX 10XXXXXX 0800 ~ FFFF 1110XXXX 10XXXXXX 10XXXXXX 10000 ~ 10FFFF 11110XXX 10XXXXXX 10XXXXXX 10XXXXXX 11100100 10111010 10010001 “云”字的二进制信息格式刚好对应第3分区，那么我们按照第3分区的模板格式对UTF8的2进制表现形式进行掐头工作，将它转变为Unicode的2进制表现格式。 1110XXXX 10XXXXXX 10XXXXXX 11100100 10111010 10010001 0100 111010 010001 # 掐头 100111010010001 # 结果 得到了结果为100111010010001，现在可以通过一系列Python3函数将它转换为Unicode字符，转换过程如下所示： >>> int(\"100111010010001\",base=2) 20113 >>> hex(20113) '0x4e91' >>> \"\\u4e91\" '云' Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-13 20:41:52 "},"杂谈专栏/放一些常见题目.html":{"url":"杂谈专栏/放一些常见题目.html","title":"常见问题大全","keywords":"","body":"常见问题 Python 基础知识 %accordion%解释器版本升级%accordion% py2项目如何迁移成py3? 答案： six模块 使用py3自带的2to3.py工具将py2转换为py3 %/accordion% %accordion%值比较与引用比较%accordion% 聊聊is和==的区别？ 答案： is会判断2个对象是否来自同一引用 ==仅2个对象的判断表现形式是否相同 %/accordion% %accordion%内存管理%accordion% Python是如何进行内存管理的? Python的程序会内存泄漏吗?说说有没有什么方面阻止或检测内存泄漏 答案： python是使用私有堆进行内存管理的，我们无法访问，只能通过接口进行一些相关操作，python程序存在内存泄漏，主要是由于python是使用的引用计数的方式进行内存管理的，而如果重写__del__方法时声明了变量，因为计数还未变为0，所以会存在内存泄露。 阻止或检测的方法： 1. 程序员管理好每个python对象的引用，尽量在不需要使用对象的时候，断开所有引用 2. 尽量少通过循环引用组织数据，可以改用weakref做弱引用或者用id之类的句柄访问对象 3. 通过gc模块的接口可以检查出每次垃圾回收有哪些对象不能自动处理，再逐个逐个处理 %/accordion% %accordion%深浅拷贝%accordion% 简述Python深浅拷贝？ 答案： 不可变类型没有深浅拷贝，所有对不可变类型的深浅拷贝均是引用 所以深浅拷贝仅针对容器类型： 浅拷贝：仅拷贝容器的第一层，将不是不可变类型的对象都复制一份 深拷贝：递归的拷贝容器中所有层，将不是不可变类型的对象都复制一份 %/accordion% %accordion%循环打印乘法表%accordion% 用Python实现99乘法表(用两种不同的方法实现) 答案1： for i in range(1, 10): for j in range(1, 1 + i): print(\"{} * {} = {}\".format(i, j, i * j), end=\"\\t\") print(\"\") 答案2： i = 1 j = 1 while i %/accordion% %accordion%文件读取%accordion% 一个大小为100G的文件etl_log.txt, 要读取文件中的内容, 写出具体过程代码？ 答案： with open(\"fileName\", mode=\"rt\", encoding=\"utf8\") as f: for item in f: print(item) # file对象就是一个迭代器，具有惰性求值的功能 %/accordion% %accordion%计数器实现%accordion% 有一个数组[3, 4, 1, 2, 5, 6, 6, 5, 4, 3, 3] 请写一个函数, 找出该数组中没有重复的数的总和 ，例如上面数据的没有重复的总和为1+2=3。 答案： def add(seq): result = 0 saveTable = {} for item in seq: if item not in saveTable: saveTable[item] = 1 else: saveTable[item] += 1 for sumNumber in saveTable: if saveTable[sumNumber] == 1: result += sumNumber return result print(add([3, 4, 1, 2, 5, 6, 6, 5, 4, 3, 3])) %/accordion% 数据类型 %accordion%布尔类型判断%accordion% 下列哪种说法是错误的 除字典类型外, 所有标准对象均可用于布尔测试 空字符串的布尔值是False 空列表对象的布尔值是False 值为0的任何数字对象的布尔值是False 答案： 1 字典类型也能用于布尔测试 %/accordion% %accordion%字典的hash%accordion% 选择代码的运行结果： country_counter ={} def addone(country): if country in country_counter: country_counter[country ]+=1 else: country_counter[country ]= 1 addone(\"China\") addone(\"Japan\") addone(\"china\") print len(country_counter ) A:0 B:1 C:2 D:3 E:4 答案：D，China和china的hash值不同 %/accordion% %accordion%字典的key是否存在？%accordion% 如何判断一个字典中的key是否存在？方法越多越好 答案： dic = {chr(i):i for i in range(65, 65 + 26)} # 1 print(dic.get(\"A\")) # 2 print(\"A\" in dic) # 3 print(dic[\"A\"]) # 4 print(dic.pop(\"A\")) %/accordion% %accordion%列表推导式%accordion% 如何用一行代码生成[1, 4, 9, 16, 25, 36, 49, 64, 81, 100] ? 答案： print( [i ** 2 for i in range(1, 11)] ) %/accordion% %accordion%序列翻转%accordion% 翻转1个字符串，如”1234“翻转为”4321“： 答案： string = \"1234\" print(string[::-1]) print(str.join(\"\", list(reversed(string)))) %/accordion% %accordion%字典的setdefault()方法%accordion% 将列表内的元素,根据位数合并成字典，列表如下： lst = [1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 32769, 65536, 4294967296] 答案： lst = [1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 32769, 65536, 4294967296] dic = {} for i in lst: k = len(str(i)) # 如果不存在该键，这该键等同于一个空列表 dic.setdefault(k, []) dic[k].append(i) print(dic) %/accordion% 函数相关 %accordion%形参类型必须为不可变%accordion% 写出程序运行结果： def add_end(l=[]): l.append(\"end\") return l add_end() add_end() 答案： [\"end\"] [\"end\", \"end\"] %/accordion% %accordion%命名空间%accordion% 全局变量和局部变量的区别, 如何给function里面的一个全局变量赋值? 答案： 全局变量是指存放在global namespace中的变量，它允许在任何命名空间中访问 全局有效，全局存活 局部变量是指存放在local namespace中的变量，它仅允许在当前函数的运行时访问，同时，也允许该函数中嵌套定义的子函数在运行时访问 局部有效，局部存活。 function里面如果要对1个全局变量进行赋值，可使用global关键字，如： x = 1 def func(): global x x += 1 %/accordion% %accordion%标识符命名冲突问题%accordion% 请写出下面程序的运行结果： a = 1 def fun(a): a = 2 fun(a) print(a) a = [] def fun(a): a.append(1) fun(a) print(a) 答案： 1 [1] %/accordion% %accordion%lambda表达式？%accordion% 简述lambda表达式格式以及应用场景。 答案： 格式如下： lambda x, y : x + y 形参可以没有，不必显式return 常与内置函数搭配使用，如filter，map，sorted，max等 %/accordion% %accordion%多装饰器嵌套%accordion% 请给出下面代码片段的输出： def say_hi(func): def wrapper(*args, **kwargs): print(\"HI\") ret = func(*args, **kwargs) print(\"BYE\") return ret return wrapper def say_yo(func): def wrapper(*args, **kwargs): print(\"YO\") return func(*args, **kwargs) return wrapper @say_hi @say_yo def func(): print(\"ROCK & ROLL\") func() 答案： print(\"HI\") print(\"YO\") print(\"ROCK & ROLL\") print(\"BYE\") %/accordion% %accordion%生成器与普通函数的区别？%accordion% 解释生成器与函数的不同, 并实现和简单使用generator 答案： 当一个函数中具有yield关键字时，此函数即为生成器函数 区别如下： 普通函数加括号是立即调用函数，执行函数体内部代码 生成器函数加括号是返回一个生成器对象，必须通过for循环或者手动使用send(None)或者调用其下的next()方法进行启动 生成器函数比普通函数的运行栈帧会多一个保存当前函数挂起状态的C语言结构体，因为yield关键字之后会将函数状态进行挂起，而return直接会返回并将函数栈帧从系统调用栈中踢出来 生成器对象可以通过send()方法与生成器函数体中yield进行数据交互，而普通的函数则不行，一经return直接结束函数运行 值得一提的是低版本中，yield和return不能同时出现 def genFunc(): yield 1 yield 2 yield 3 genObject = genFunc() for item in genObject: print(item) %/accordion% %accordion%递归打印%accordion% 有一个多层嵌套的列表A=[1,2,[3,4,[\"434\",...]]], 请写一段代码遍历A中的每一个元素并打印出来 答案： def func(li): for item in li: if isinstance(item, list): func(item) else: print(item) func([1, 2, [3, 4, [\"434\"]]]) %/accordion% %accordion%sorted()函数中key参数的使用%accordion% 将以下字典按照value的大小进行排序： d = {\"a\": 26, \"g\": 20, \"e\": 20, \"c\": 24, \"d\": 23, \"f\": 21, \"b\": 25} 答案： d = {\"a\": 26, \"g\": 20, \"e\": 20, \"c\": 24, \"d\": 23, \"f\": 21, \"b\": 25} print(sorted(d, key=lambda k:d[k])) %/accordion% %accordion%zip的使用%accordion% 写代码 tupleA = (\"a\",\"b\",\"c\",\"d\",\"e\") tupleB = (1,2,3,4,5) RES = {\"a\":1,\"b\":2,\"c\":3,\"d\":4,\"e\":5} 写出由tupleA和tupleB得到res的及具体实现过程 答案： dict(zip(tupleA, tupleB)) %/accordion% %accordion%ord()和chr()使用%accordion% 写一个base62encode函数，实现62进制解码。 范围0-10，a-z，A-Z def base62encode(number): if number 61: raise ValueError(\"Must be between 0 - 61\") encodeTable = ( *[i for i in range(10)], *[chr(i) for i in range(97, 123)], *[chr(i) for i in range(65, 91)],) return encodeTable[number] print(base62encode(61)) # Z %/accordion% %accordion%生成器编写斐波拉契数列%accordion% 使用生成器编写fib函数，函数声明为fib(max)，输入一个参数max值，使得该函数可以这样调用： for i in range(0,100): print fib(1000) 并产生如下结果(斐波那契数列) 1, 1, 2, 3, 5, 8, 13, 21... 答案： def fib(max): count, currentValue, nextValue = 0, 0, 1 while count %/accordion% %accordion%IP地址转换%accordion% 请编写一个函数实现将IP地址转换成一个整数。 如 10.3.9.12 转换规则为： 10 00001010 3 00000011 9 00001001 12 00001100 再将以上二进制拼接起来计算十进制结果：00001010 00000011 00001001 00001100 = ？ 答案： def transformIpAddr(ip): bitIpList = list(map(lambda x: str(bin(int(x)))[ 2:].rjust(8, \"0\"), ip.strip().split(\".\"))) return int(\"\".join(bitIpList), base=2) print(transformIpAddr(\"10.3.9.12\")) %/accordion% %accordion%计时装饰器实现%accordion% 请实现一个装饰器, 限制该函数被调用的频率, 如10秒一次 答案： import datetime import time def warpper(s=10): def outer(func): nextRunTime = None def inner(*args, **kwargs): nonlocal nextRunTime nowTime = datetime.datetime.now() if nextRunTime is None or nowTime > nextRunTime: result = func(*args, **kwargs) nextRunTime = datetime.timedelta(seconds=s) + nowTime return result print(nextRunTime - nowTime) return inner return outer @warpper(10) def func(): print(\"run...\") for i in range(10): time.sleep(2) func() %/accordion% %accordion%可迭代对象%accordion% 下列数据结构中,哪一种是不可迭代的 A. dict B. object C. set D. str 答案： B %/accordion% 算法与数构 %accordion%哈希冲突回避算法有哪几种, 分别有什么特点？%accordion% 开放定址法： 所谓的开放定址法就是一旦发生了冲突，就去寻找下一个空的散列地址，只要散列表足够大，空的散列地址总能找到，并将记录存入 再哈希法： 再哈希法又叫双哈希法，有多个不同的Hash函数，当发生冲突时，使用第二个，第三个，….，等哈希函数 计算地址，直到无冲突。虽然不易发生聚集，但是增加了计算时间。 链地址法： 链地址法的基本思想是：每个哈希表节点都有一个next指针，多个哈希表节点可以用next指针构成一个单向链表，被分配到同一个索引上的多个节点可以用这个单向链表向后排列。 建立公共溢出区： 这种方法的基本思想是：将哈希表分为基本表和溢出表两部分，凡是和基本表发生冲突的元素，一律填入溢出表 %/accordion% 模块相关 %accordion%pip命令的使用%accordion% 如何安装第三方模块？ 答案： pip install module name %/accordion% %accordion%datetime模块%accordion% 输入某年某日, 判断这是这一年的第几天?(可以用Python的内置模块) 答案： import datetime def dayofyear(): year = input(\"请输入年份：\") month = input(\"请输入月份：\") day = input(\"请输入天：\") date1 = datetime.date(year=int(year),month=int(month),day=int(day)) date2 = datetime.date(year=int(year),month=1,day=1) return (date1 - date2).days + 1 print(dayofyear()) %/accordion% %accordion%random使用%accordion% 如何生成一个随机数？ 答案： random.random() 生成0-1之间的随机小数。 %/accordion% %accordion%sys与模块路径查找%accordion% sys.path.append(\"/root/mods\")的作用？ 答案： 添加/root/mods路径至硬盘模块查找中 %/accordion% %accordion%os模块应用%accordion% 如何用Python删除1个文件？ os.remove() %/accordion% %accordion%文件递归%accordion% 写代码实现查看一个目录下的所有文件。 答案： import os def pathRecursion(path): print(path) if os.path.isdir(path): for subPath in os.listdir(path): pathRecursion(os.path.join(path, subPath)) pathRecursion(os.path.abspath(os.getcwd())) %/accordion% %accordion%JSON转中文%accordion% json序列化时，默认遇到中文会转换成unicode，如果想要保留中文怎么办？ 答案： 序列化时添加参数： ensure_ascii=False %/accordion% %accordion%JSON扩展%accordion% json序列化时，可以处理的数据类型有哪些？如何定制支持datetime类型？ 答案: json序列化只能序列化Python基本数据类型。 如果要想序列化非Python基本数据类型，则可以使用参数cls进行定制，详情参见Python模块一章。 json.dumps(data, cls=自己写的类) %/accordion% %accordion%简述logging模块作用%accordion% logging模块的作用？以及应用场景？ 答案： 日志记录 %/accordion% %accordion%正则表达式贪婪匹配%accordion% 什么是正则的贪婪匹配？或 正则匹配中的贪婪模式与非贪婪模式的区别？ 答案： *+?{n, m}都是贪婪模式，即有多个的时候匹配多个。 通过?可取消贪婪模式，即及时有多个也取最少的 %/accordion% %accordion%正则表达式%accordion% 请写出以字母或下划线开始, 以数字结束的正则表达式 答案： import re result = re.search(pattern=r\"^[A-Za-z0-9_].*\\d$\", string=\"321\") print(result.group()) %/accordion% %accordion%re模块中search和match的区别？%accordion% 请问re模块中search()和match()有什么区别？ 答案： search和match都有1个共同点，即只会成功匹配1次 不同点在于match只会匹配开头，相当于search基础上加了^ %/accordion% %accordion%如何判断一个邮箱是否合法？%accordion% 如何判断一个邮箱是否合法？ 答案： ^[a-zA-Z0-9_-]+@[a-zA-Z0-9_-]+(\\.[a-zA-Z0-9_-]+)+$ %/accordion% %accordion%itertools模块%accordion% 写代码：用户输入一个字符串，打印该字符串的所有不重复排列组合。 答案： from itertools import permutations a = input() for i in permutations(a, len(a)): print(''.join(i)) %/accordion% 面向对象 %accordion%简述oop三大特性%accordion% 请简述oop三大特性。 答案： 封装：将代码封装起来，只留下接口，通过接口访问对象 继承：实现多复用，子类的公用方法和属性可以从父类继承，减少代码冗余 多态，面向对象最灵活的地方，可以动态绑定，一种事物，多种形态，也称鸭子类型 %/accordion% %accordion%类变量和实例变量的区别%accordion% 请简述类变量和实例变量的区别。 答案： 实例变量仅存在实例对象的内存空间，类是无法调用实例变量。 类变量 存在整个类对象的内存空间，所有该类实例化出来的对象都可以调用到这些变量 %/accordion% %accordion%类与实例作用域%accordion% 以下代码输出是什么? 请给出答案并解释： class Parent(object): x = 1 class Child1(Parent): pass class Child2(Parent): pass print Parent.x, Child1.x, Child2.x Child1.x = 2 print Parent.x, Child1.x, Child2.x Parent.x = 3 print Parent.x, Child1.x, Child2.x 答案： 1 1 1 1 2 1 3 2 3 详情参见类与对象一篇，类与实例命名空间和标识符查找顺序。 %/accordion% %accordion%类方法与静态方法%accordion% 请简单解释Python中的static method(静态方法)和class method(类方法),并将以下代码填写完整 class A(object): def foo(self,x) print 'executing foo(%s, %s)'%(self,x) @classmethod def class_foo(cls,x): print 'executing class_foo(%s, %s)'%(cls,x) @staticmethod def static_foo(x): print 'executing static_foo(%s)'%(x) a= A() # 调用foo函数,参数传入1 ____________________ # 调用class_foo函数,参数传入1 ____________________ # 调用static_foo函数,参数传入1 答案： @classmethod：类的绑定方法，只能由类调用 @staticmethod：类的静态方法，类和instance都能调用 a.foo(1) A.class_foo(1) A.static_foo(1) a.static_foo(1) %/accordion% %accordion%上下文管理机制%accordion% 有用过with statement（语句）吗？它的好处是什么？ 答案： 上下文管理，with完成后自动调用__exit__(). 故可以在__exit__()中关闭系统占用资源 %/accordion% %accordion%上下文管理器实现%accordion% 参考下面代码片段 class Context: pass with Content() as ctx: ctx.do_something() 请在Context类下添加代码完成该类的实现 答案： class Context: def __enter__(self): print(\"run .. enter\") return self def __exit__(self,exc_type,exc_val,exc_tb): print(\"run .. exit\") return self def do_something(self): print(\"run .. do something\") return self with Context() as ctx: ctx.do_something() %/accordion% %accordion%super()方法%accordion% super()的作用？ 答案： 根据mro属性查找顺序列表来依次访问父类、超类、基类。 达到方法借用的目的。 %/accordion% %accordion%单例模式%accordion% 实现一个Singleton单例类, 要求遵循基本语言编程规范（用尽量多的方式）。 方式1，元类实现： class MetaClass(type): def __call__(self, *args, **kwargs): \"\"\" self : class Singleton \"\"\" if not hasattr(self, \"ins\"): insObject = super(__class__, self).__call__(*args, **kwargs) setattr(self, \"ins\", insObject) return getattr(self, \"ins\") class Singleton(object, metaclass=MetaClass): pass if __name__ == \"__main__\": ins = Singleton() print(id(ins)) ins = Singleton() print(id(ins)) 方式2，继承实现： class ParentClass: def __new__(cls, *args, **kwargs) -> object: \"\"\" cls : class Singeton \"\"\" if not hasattr(cls, \"ins\"): insObject = super(__class__, cls).__new__(cls, *args, **kwargs) setattr(cls, \"ins\", insObject) return getattr(cls, \"ins\") class Singleton(ParentClass): pass if __name__ == \"__main__\": ins = Singleton() print(id(ins)) ins = Singleton() print(id(ins)) 方式3，装饰器实现： def warpper(clsObject): def inner(*args, **kwargs): if not hasattr(clsObject, \"ins\"): insObject = clsObject(*args, **kwargs) setattr(clsObject, \"ins\", insObject) return getattr(clsObject, \"ins\") return inner @warpper class Singleton: pass if __name__ == \"__main__\": ins = Singleton() print(id(ins)) ins = Singleton() print(id(ins)) 方式4，模块实现： - foo.py --> ins = Singleton() - bar.py --> from foo import ins 方式5，@classmethod实现单例模式： class Singleton: @classmethod def getSingletonInstanceObject(cls, *args, **kwargs): if not hasattr(cls, \"ins\"): insObject = cls(*args, **kwargs) setattr(cls, \"ins\", insObject) return getattr(cls, \"ins\") if __name__ == \"__main__\": ins = Singleton.getSingletonInstanceObject() print(id(ins)) ins = Singleton.getSingletonInstanceObject() print(id(ins)) %/accordion% %accordion%双下方法举例%accordion% 列举面向对象中带双下划线的特殊方法。 答案： __getitem__ __setitem__ __delitem__ __getattr__ __setattr__ __delattr__ __continar__ .. %/accordion% %accordion%isinstance和type%accordion% 简述isinstance()和type()的区别。 答案： isinstance判断一个对象是否来自于一个类的实例，返回布尔值 type用于返回指定实例的类型，返回类对象本身 %/accordion% %accordion%简述duke type%accordion% 什么是鸭子类型？ 答案： 如果它走起来像鸭子，而且叫起来像鸭子，那么它就是鸭子 也就是说，我们只关注对象行为而不关注对象本身 %/accordion% %accordion%单下划线和双下划线的区别？%accordion% 简述单下划线开头的变量名和双下滑先开的变量名有什么区别？ 答案： 单下划线开头的变量名逻辑上是私有变量，即不推荐外部进行访问，但是外部仍然可以访问到，并未对变量名本身做任何处理。 双下划线开头的变量名逻辑上是私有变量，即禁止外部进行访问，会将变量名重命名，规则为 _类名.__变量名 %/accordion% %accordion%简述mro%accordion% mro是什么？有什么作用？如何获取？ 答案： mro是属性查找顺序列表，由c3算法生成。 仅新式类具有该属性，经典类没有。 调用方式： className.mro() or className.__mro__ %/accordion% %accordion%可调用对象%accordion% python中如何判断一个对象是否可调用? 那些对象可以是可调用对象?如何定义一个类, 使其对象本身就是可调用对象? 答案： 使用callable(Object)判断一个对象是否可调用 函数，类都是可调用对象 如果想 className() ，则需要在其metaclass中定义 __call__() 方法， 如果想instanceName()， 则需要在其实现类中定义 __call__() 方法 %/accordion% 格式 %accordion%Some title here%accordion% Any content here %/accordion% Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-13 20:41:52 "},"杂谈专栏/一些常见软件的安装目录.html":{"url":"杂谈专栏/一些常见软件的安装目录.html","title":"常见软件安装目录","keywords":"","body":"brew brew install下载的软件，安装在： /usr/local/Cellar/* Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-08-24 21:44:58 "},"杂谈专栏/HTTP服务相关.html":{"url":"杂谈专栏/HTTP服务相关.html","title":"HTTP服务相关","keywords":"","body":"常见状态码 HTTP状态码由三个十进制数字组成，第一个十进制数字定义了状态码的类型，后两个数字没有分类的作用。HTTP状态码共分为5种类型： 分类 分类描述 1** 信息，服务器收到请求，需要请求者继续执行操作 2** 成功，操作被成功接收并处理 3** 重定向，需要进一步的操作以完成请求 4** 客户端错误，请求包含语法错误或无法完成请求 5** 服务器错误，服务器在处理请求的过程中发生了错误 HTTP状态码列表: 状态码 状态码英文名称 中文描述 100 Continue 继续。客户端应继续其请求 101 Switching Protocols 切换协议。服务器根据客户端的请求切换协议。只能切换到更高级的协议，例如，切换到HTTP的新版本协议 200 OK 请求成功。一般用于GET与POST请求 201 Created 已创建。成功请求并创建了新的资源 202 Accepted 已接受。已经接受请求，但未处理完成 203 Non-Authoritative Information 非授权信息。请求成功。但返回的meta信息不在原始的服务器，而是一个副本 204 No Content 无内容。服务器成功处理，但未返回内容。在未更新网页的情况下，可确保浏览器继续显示当前文档 205 Reset Content 重置内容。服务器处理成功，用户终端（例如：浏览器）应重置文档视图。可通过此返回码清除浏览器的表单域 206 Partial Content 部分内容。服务器成功处理了部分GET请求 300 Multiple Choices 多种选择。请求的资源可包括多个位置，相应可返回一个资源特征与地址的列表用于用户终端（例如：浏览器）选择 301 Moved Permanently 永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替 302 Found 临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI 303 See Other 查看其它地址。与301类似。使用GET和POST请求查看 304 Not Modified 未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源 305 Use Proxy 使用代理。所请求的资源必须通过代理访问 306 Unused 已经被废弃的HTTP状态码 307 Temporary Redirect 临时重定向。与302类似。使用GET请求重定向 400 Bad Request 客户端请求的语法错误，服务器无法理解 401 Unauthorized 请求要求用户的身份认证 402 Payment Required 保留，将来使用 403 Forbidden 服务器理解请求客户端的请求，但是拒绝执行此请求 404 Not Found 服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置\"您所请求的资源无法找到\"的个性页面 405 Method Not Allowed 客户端请求中的方法被禁止 406 Not Acceptable 服务器无法根据客户端请求的内容特性完成请求 407 Proxy Authentication Required 请求要求代理的身份认证，与401类似，但请求者应当使用代理进行授权 408 Request Time-out 服务器等待客户端发送的请求时间过长，超时 409 Conflict 服务器完成客户端的 PUT 请求时可能返回此代码，服务器处理请求时发生了冲突 410 Gone 客户端请求的资源已经不存在。410不同于404，如果资源以前有现在被永久删除了可使用410代码，网站设计人员可通过301代码指定资源的新位置 411 Length Required 服务器无法处理客户端发送的不带Content-Length的请求信息 412 Precondition Failed 客户端请求信息的先决条件错误 413 Request Entity Too Large 由于请求的实体过大，服务器无法处理，因此拒绝请求。为防止客户端的连续请求，服务器可能会关闭连接。如果只是服务器暂时无法处理，则会包含一个Retry-After的响应信息 414 Request-URI Too Large 请求的URI过长（URI通常为网址），服务器无法处理 415 Unsupported Media Type 服务器无法处理请求附带的媒体格式 416 Requested range not satisfiable 客户端请求的范围无效 417 Expectation Failed 服务器无法满足Expect的请求头信息 500 Internal Server Error 服务器内部错误，无法完成请求 501 Not Implemented 服务器不支持请求的功能，无法完成请求 502 Bad Gateway 作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到了一个无效的响应 503 Service Unavailable 由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的Retry-After头信息中 504 Gateway Time-out 充当网关或代理的服务器，未及时从远端服务器获取请求 505 HTTP Version not supported 服务器不支持请求的HTTP协议的版本，无法完成处理 常见MIME 以下例举常见的mime类型： 类型/字类型 扩展名 text/plain *.txt 或 其他文本文件 text/html .html 或 .htm text/css *.css text/javascript *.js application/json *.json image/gif *.gif image/png *.png image/jpeg .jpg 或 .jpeg image/bmp *.bmp image/webp *.webp image/svg+xml *.svg(矢量图) image/x-icon *.ico audio/wav *.wav audio/webm *.webm audio/ogg *.ogg audio/mpeg *.mp3 video/webm *.webm video/ogg *.ogg video/mp4 *.mp4 application/octet-stream .*（ 二进制流，不知道下载文件类型） Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-09-01 13:58:48 "},"杂谈专栏/推荐电子书.html":{"url":"杂谈专栏/推荐电子书.html","title":"推荐电子书","keywords":"","body":" koa2框架学习 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-09-01 14:22:40 "},"Python/summary.html":{"url":"Python/summary.html","title":"Python专栏","keywords":"","body":" Python快速入门 Python基础知识 Python函数相关 Python模块与包 Python面向对象 Python数算基础 Python设计模式 Python网络编程 Python并发编程 Python驱动程序 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-07-07 19:43:36 "},"Python/Python快速入门/summary.html":{"url":"Python/Python快速入门/summary.html","title":"Python快速入门","keywords":"","body":" Python简介 Python安装 pip简单使用 Python虚拟环境 Python常用工具 PEP8规范说明 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-13 20:41:50 "},"Python/Python快速入门/Python简介.html":{"url":"Python/Python快速入门/Python简介.html","title":"Python简介","keywords":"","body":"Python简述 Python诞生于1989年圣诞节，由仁慈的独裁者（Benevolent Dictator For Life，缩写BDFL）吉多·范罗苏姆（Guido van Rossum）基于C语言开发。 Python的名字来源于龟叔（Guido van Rossum在Python界的爱称）十分喜欢的一部名为Monty Python's Flying的电视剧，一想到这个风靡全球的编程语言名字居然来的这么随意，不禁让人哑然失笑。 作为一门解释性的动态强类型语言，Python的开发效率奇高，因此在Python界流传着这样一句至理名言： 人生苦短，我用Python Python并不是毫无缺点的孩子，作为一门动态语言，它的执行效率是偏低的。 作为80年代的产物，它的并发性支持也可能不太好，但是这并不妨碍我们对它的热爱，相信只要拥入Python的怀抱你一定会爱上这一门优雅的语言。 Python解释器 由于是动态语言，Python在代码执行时必须先将代码转换为字节码，然后通过字节码再转换为机器可读的机器码。 而解释器就是负责这一切工作的小蜜蜂。 我们常说的Python是基于C语言开发而来的CPython，除此之外还有基于Java开发而来的Jython、以及基于C#开发而来的IronPython。 不论是Jython还是IronPython，我们在学习时都不会去考虑，而是统一选择CPython，因为它们相较于传统的CPython多了一个转换环节所以会导致执行效率的降低。 低效率的执行 动态语言是逐行翻译，我们可以将它理解为一种边跑边看的策略。 这样做的后果是方便代码排查，缺点是拉低执行效率。 常见的Python解释器（包括CPython）等都是采用这种策略，故Python的执行效率一直被人诟病。 PyPy解释器 熟悉Python的朋友都知道，有一款Python解释器打破了人们对于Python低执行效率的印象。 它就是PyPy解释器，PyPy是另一个Python解释器，它的目标是执行速度。 PyPy采用JIT技术，对Python代码进行动态编译（注意不是解释），所以可以显著提高Python代码的执行速度。 绝大部分Python代码都可以在PyPy下运行，但是PyPy和CPython有一些是不同的，这就导致相同的Python代码在两种解释器下执行可能会有不同的结果。 如果你的代码要放到PyPy下执行，就需要了解PyPy和CPython的不同点。 你可以简单的这么理解： 代码第一次运行时：进行动态编译，生成目标文件 代码第二次运行时：使用目标文件进行运行，没必要再进行逐行翻译，故执行效率提升 如果你需要较高的执行效率，可以选用该解释器，但是本专题中不会使用它。 因为PyPy终究不是正统，所以对很多第三方库的依赖性和兼容性不如CPython。 版本介绍 由于我们平常讲的Python实际上都为CPython，故我们接下来的学习也是围绕CPython（以下简称Python）展开的。 目前Python版本已经更迭到了3.9。 以下是Python的发展历程： 1989年，Guido开始写Python语言的解释器。 1991年，第一个Python解释器诞生，它是用C语言实现的，并能够调用C语言的库文件。 从一出生，Python已经具有了：类，函数，异常处理，包含表和词典在内的核心数据类型，以及模块为基础的拓展系统。 Granddaddy of Python web frameworks, Zope 1 was released in 1999 Python 1.0 - January 1994 增加了 lambda, map, filter and reduce. Python 2.0 - October 16, 2000，加入了内存回收机制，构成了现在Python语言框架的基础 Python 2.4 - November 30, 2004, 同年目前最流行的WEB框架Django诞生 Python 2.5 - September 19, 2006 Python 2.6 - October 1, 2008 Python 2.7 - July 3, 2010 In November 2014, it was announced that Python 2.7 would be supported until 2020, and reaffirmed that there would be no 2.8 release as users were expected to move to Python 3.4+ as soon as possible Python 3.0 - December 3, 2008 Python 3.1 - June 27, 2009 Python 3.2 - February 20, 2011 Python 3.3 - September 29, 2012 Python 3.4 - March 16, 2014 Python 3.5 - September 13, 2015 Python 3.6 - 2016-12 Python 3.7 - 2018 Python 3.8 - 2019 ... 细心的读者会发现，08年时就推出了3.0，2010年反而又推出了2.7？ 这是因为3.0不向下兼容2.0，而很多公司已经基于2.0版本开发出了大量程序，公司已然投入了大量的人财物力，这就导致大家都拒绝升级3.0，无奈官方只能推出2.7过渡版本，之后我们都应该采用3.0解释器开发程序，但为了方便读者维护2.0版本的软件，在遇到两种版本的差异时会专门指出来。 应用方向 Python的应用领域十分广泛，如：人工智能，数据处理，爬虫，金融量化，云计算，WEB开发，自动化运维/测试，游戏开发，网络服务，图像处理等众多领域。 并且国内外很多知名的企业也都在使用Python，如：Youtube、DropBox、BT、Quora（中国知乎）、豆瓣、知乎、Google、Yahoo、FaceBook、NASA、百度、腾讯、汽车之家、美团等等。 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-13 20:41:50 "},"Python/Python快速入门/Python安装.html":{"url":"Python/Python快速入门/Python安装.html","title":"Python安装","keywords":"","body":"本机示例 虽然目前的Python版本已经更迭到了3.9，但是在这里将会使用Python3.6.8来进行开发。 Python3.6系列应该是目前使用最为广泛的一个版本系列，相较于最新版的3.9来说它支持的库更多、兼容性更好。 需要注意的是在类Unix平台中，Python2版本已经自带，所以我们只需安装Python3.6即可。 MAC安装 MAC下有源码安装Source，和界面化.pkg安装，我们选择pkg安装。 第一步：打开Python官网，点我跳转： 第二步，下载对应版本的pkg安装程序： 第三步，一直点击下一步即可： 上述的安装方式会自动将Python安装至以下目录： /Library/Frameworks/Python.framework/Versions/3.6/ 安装完成之后系统会自动的将常用软件ln -s到/usr/local/bin中： $ ls /usr/local/bin/ | grep p.*3 pip3 pip3.6 pydoc3 pydoc3.6 python3 python3-config python3.6 python3.6-config python3.6m python3.6m-config pyvenv-3.6 Linux安装 Linux下有源码安装Source，和免编译安装Binary，我们选择免编译安装。 第一步，下载gcc工具： $ yum install gcc gcc-c++ -y 第二步，下载wget工具： $ yum install wget -y 第三步，下载Python3.6.8的Binary版本： $ cd ~ $ wget https://www.python.org/ftp/python/3.6.8/Python-3.6.8.tgz 第五步，将归档文件tgz解压至当前目录： $ > tar xvf Python-3.6.8.tgz -C ./ $ > ls anaconda-ks.cfg Python-3.6.8 Python-3.6.8.tgz 第六步，进入解压的目录中，进行编译安装（由于CPython基于C语言，而C语言又是编译性语言，故需要进行编译后安装）： $ > cd Python-3.6.8 $ > ./configure --prefix=/usr/local/Python36 $ > make $ > make install 第七步，添加环境变量： $ vim /etc/profile # 写入内容 export PATH=/usr/local/Python36/bin:$PATH $ source /etc/profile 交互测试 安装完成之后，分别在shell中输入python（自带的版本）以及python3，查看是否能进入交互式环境中。 如果能成功进入则按照成功，如果不能请谷歌排查原因。 若想退出交互式环境，输入exit()即可： $ python Python 2.7.10 (default, Feb 22 2019, 21:55:15) [GCC 4.2.1 Compatible Apple LLVM 10.0.1 (clang-1001.0.37.14)] on darwin Type \"help\", \"copyright\", \"credits\" or \"license\" for more information. >>> exit() $ python3 Python 3.6.8 (v3.6.8:3c6b436a57, Dec 24 2018, 02:04:31) [GCC 4.2.1 Compatible Apple LLVM 6.0 (clang-600.0.57)] on darwin Type \"help\", \"copyright\", \"credits\" or \"license\" for more information. >>> exit() Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-13 20:41:50 "},"Python/Python快速入门/pip简单使用.html":{"url":"Python/Python快速入门/pip简单使用.html","title":"pip简单使用","keywords":"","body":"pip工具 pip是Python的包管理工具，该工具提供了对Python第三方包的查找、下载、安装、卸载等功能。 Python 2.7.9+ 或 Python 3.4+ 以上版本都自带pip工具，在安装Python时会一并安装。 如果你安装了两个版本的Python，则对应的pip命令就是pip2或者pip3。 $ ls /usr/local/bin/pip* /usr/local/bin/pip /usr/local/bin/pip2 /usr/local/bin/pip2.7 /usr/local/bin/pip3 /usr/local/bin/pip3.6 Ps：类似于NodeJS的NPM 常用命令 在shell中可使用的pip常用命令如下： 命令 描述 pip --version 显示版本和路径 pip --help 获取帮助 pip install -U pip pip升级 pip install 包名 安装包 pip install --upgrade 包名 升级包 pip uninstall 包名 卸载包 pip search 包名 搜索包 pip list 查看所有已安装的包 pip list -o 查看所有可升级的包 pip升级 使用以下命令进行pip工具进行升级： Windows平台： $ python -m pip install -U pip # python2.x $ python -m pip3 install -U pip # python3.x Linux&Mac平台： $ pip install --upgrade pip # python2.x $ pip3 install --upgrade pip # python3.x 换源配置 pip下载的包默认是从国外源下载，速度较慢，因此可以为其设置为国内源（阿里云）。 下面介绍类Unix平台与Windows平台的换源方式。 Windows 直接在user目录中创建一个pip目录，如：C:\\Users\\username\\pip，新建文件pip.ini，然后填入以下内容： [global] index-url = https://mirrors.aliyun.com/pypi/simple Unix 类Unix平台需要依次运行如下命令： $ cd ~ # 进入用户家目录 $ mkdir .pip # 创建隐藏文件夹 $ vim .pip/pip.conf # 创建pip3的配置文件 然后在配置文件pip.conf中填入以下内容： [global] index-url = https://mirrors.aliyun.com/pypi/simple Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-13 20:41:50 "},"Python/Python快速入门/Python常用工具.html":{"url":"Python/Python快速入门/Python常用工具.html","title":"Python常用工具","keywords":"","body":"运行方式 REPL交互式 REPL名为交互式解释器（Read Eval Print Loop），提供了一个CLI(command-line interface:命令行界面)下读取值、求值、输出值、循环代码的环境。 这种交互式的方式会经常用到，适用于快速的进行一些功能测试，如函数传参、求值测试等。 现在让我们以REPL交互式来运行第一条Python代码，在shell中进行执行： $ python3 >>> print(\"hello world\") hello world >>> 如果要退出REPL环境，则使用exit()即可。 脚本调用式 外部调用 在一个文件中，书写好Python代码后进行调用的方式被称为脚本调用式。 也是非常常用的一种方式，通常文件后缀名以py结尾，标识这是一个Python脚本文件。 使用Python调用脚本时，其实并不关心文件后缀名是什么，后缀名更多的作用是给使用者看的，便于区分不同类型的文件 $ echo \"print('hello world')\" > helloWorld.py $ python3 helloWorld.py hello world 在此示例中我们使用Python3的解释器在外部对其进行调用，并执行了其中的代码打印了hello world。 内部调用 除开外部调用，我们也可以在脚本内部指定Python解释器，并通过./进行代码执行，对上述文件内容进行修改： #!/usr/bin/env python3 print('hello world') 修改完成并保存，再修改文件的执行权限： $ chmod 775 helloWorld.py 直接使用./进行代码执行： $ ./helloWorld.py hello world 使用内部调用需要注意：指定Python解释器的语句一定要放在文件头部，因此该代码也被称为头文件代码。 常见的头文件代码除开指定Python解释器以外，还有指定解释器解码格式、声明作者和日期等，如下所示： #!/usr/bin/env python3 # -*- coding:utf-8 -*- # author: YunYa # date: 2017-01-28 头文件代码调用说明：env是类Unix平台的环境变量别称，当我们在头文件代码中指定/usr/bin/env python3的时候，它内部会运行env | grep python3，找到python3解释器，并对文件进行执行，前提是该文件必须具有可执行权限。 $ env | grep python3 VIRTUALENVWRAPPER_PYTHON=/Library/Frameworks/Python.framework/Versions/3.6/bin/python3.6 执行过程 一个Python程序被解释器解释并执行，可粗略的分为三个步骤： 启动Python解释器 Python解释器发起系统调用，将脚本内容载入内存，此时并不会做任何处理 Python解释器开始识别Python语法，解释并执行内存中存储的脚本文件内容 IDE介绍 IDE简介 IDE的全称是Integrated Development Environment，即集成开发环境。 它是一种辅助程序开发人员开发软件的应用软件，在开发工具内部就可以辅助编写源代码文本、并编译打包成为可用的程序，有些甚至可以设计图形接口。 如果单纯的touch出一个文本，并在其内部书写代码是很容易出现问题的。 没有语法高亮，这意味着某个字符少打了、某个单词拼错了都不能被及时发现，并且这样学习对新手难度极大 没有debug功能，当业务逻辑越来越复杂时，程序不可避免的会出现一些bug，此时如果没有debug程序来检测出现问题的原因，整个排查的过程将变的异常艰难 而使用IDE开发则可以完全避免这些问题。 Python IDLE Python自带了一款类似的工具，名为Python IDLE，是Python的集成开发和学习环境。 官方文档：https://docs.python.org/3/library/idle.html 它自带了2种模式，一种是REPL交互模式，一种是脚本调用模式。 当你打开它后默认会进入REPL交互模式，此时只需要新建一个文件即可开始编写我们的代码。 CTRL+N：新建文件 CTRL+S：保存文件 F5：运行程序 可以发现，当我们想使用print()功能时，它会提示该功能需要哪些参数： 当编写完代码后，即可使用F5来进行文件的保存与运行，如下所示： IDLE适用于刚入门起步学习Python的同学，但对于大的项目构建来说还是十分的不方便。 推荐指数：⭐️⭐️⭐️ PyCharm PyCharm是由JetBrains公司开发，也是最受欢迎的Python IDE工具。 官方网站：https://www.jetbrains.com/pycharm/ 优点是功能强大，你能想到的不能想到的它都给你提供了。 缺点是收费，并且软件本身比较臃肿，但是比起它的优秀来说这些缺点可以忽略不计。 推荐指数：⭐️⭐️⭐️⭐️⭐️ VsCode VsCode是由Microsoft Corporation开发，是近年来最火的一款轻量级编辑器。 官方网站：https://code.visualstudio.com/ 优点是支持多语言，Golang、C、Python等手到擒来，此外它是完全免费的。 缺点是配置比较繁琐，对新手不太友好。 推荐指数：⭐️⭐️⭐️⭐️ 个人使用 我自己平常写一些小的脚本，会首选VsCode，若是要搭建一些比较大型的项目，则会选择PyCharm。 在这里并没有详细指出每种工具的安装，因为互联网上类似的教程太多了。 推荐在初次接触Python时，建议统一使用Python IDLE，因为PyCharm本身会对Python许多地方做出优化，而恰好这些优化对新手并不友好。 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-13 20:41:50 "},"Python/Python快速入门/PEP8规范说明.html":{"url":"Python/Python快速入门/PEP8规范说明.html","title":"PEP8规范说明","keywords":"","body":"PEP8规范 每种语言都有其一种特定的书写规范，而PEP8规范则是Python中的书写规范。 以下的内容对于初学者来说可能会显得有些超纲，但是我为什么要将它放在第一章呢？就是为了警示你书写规范其实很重要。 尽管现在你可能看不懂，但是没有关系，你看得懂的时候就一定要去学会遵守它。 Ps：其实我自己就是一个不太遵守规范的家伙... 缩进与续行 每一级缩进使用4个空格，而不是使用table def main(): print(\"hello,world\") # --- def main(): print(\"hello,world\") 续行应该与其包裹元素对齐，要么使用圆括号、方括号和花括号内的隐式行连接来垂直对齐，要么使用挂行缩进对齐 def main( param1, param2, param3, param4 ): print(\"hello,world\") # --- def main(param1, param2, param3, param4 ): print(\"hello,world\") 分割与宽度 每行最大的字符数不可超过79，文档字符或者注释每行不可超过72 def main(): # this is a test function ... # this is a test function ... # this is a test function ... print(\"hello,world\") # --- def main(): # this is a test function ... this is a test function ... this is a test function ... print(\"hello,world\") 顶层函数和类的定义，前后用两个空行隔开，类里的方法定义用一个空行隔开 模块的导入 导入不同模块，应当进行分行 导入模块的位置应当总是位于文件顶部，且在头文件代码之后 标准库导入放最前、相关第三方库导入放其次，而后是本地库导入 每一组导入语句之间加入空行分割，以区分是内置库、三方库、还是自建库 推荐使用绝对导入 import sys import os # --- import sys, os 注释 在更改代码之前，推荐先更改注释 释应该是完整的句子。如果一个注释是一个短语或句子，它的第一个单词应该大写，除非它是以小写字母开头的标识符(永远不要改变标识符的大小写！) 如果注释很短，结尾的句号可以省略。块注释一般由完整句子的一个或多个段落组成，并且每句话结束有个句号 在句尾结束的时候应该使用两个空格 当用英文书写时，遵循Strunk and White （译注：《Strunk and White, The Elements of Style》）的书写风格 在非英语国家的Python程序员，请使用英文写注释，除非你120%的确信你的代码不会被使用其他语言的人阅读 块注释通常适用于跟随它们的某些（或全部）代码，并缩进到与代码相同的级别。块注释的每一行开头使用一个#和一个空格（除非块注释内部缩进文本）。 块注释内部的段落通过只有一个#的空行分隔 有节制地使用行内注释 行内注释是与代码语句同行的注释。行内注释和代码至少要有两个空格分隔。注释由#和一个空格开始 文档字符串 要为所有的公共模块，函数，类以及方法编写文档说明 非公共的方法没有必要，但是应该有一个描述方法具体作用的注释。这个注释应该在def那一行之后 PEP 257描述了写出好的文档说明相关的约定。特别需要注意的是，多行文档说明使用的结尾三引号应该自成一行，例如： \"\"\"Return a foobang Optional plotz says to frobnicate the bizbaz first. \"\"\" 对于单行的文档说明，尾部的三引号应该和文档在同一行 命名规范 应该避免的名字 永远不要使用字母‘l’（小写的L），‘O’（大写的O），或者‘I’（大写的I）作为单字符变量名 在有些字体里，这些字符无法和数字0和1区分，如果想用‘l’，用‘L’代替 类名 类名一般使用首字母大写的约定 在接口被文档化并且主要被用于调用的情况下，可以使用函数的命名风格代替 注意，对于内置的变量命名有一个单独的约定：大部分内置变量是单个单词（或者两个单词连接在一起），首字母大写的命名法只用于异常名或者内部的常量 函数名 函数名应该小写，如果想提高可读性可以用下划线分隔 大小写混合仅在为了兼容原来主要以大小写混合风格的情况下使用（比如 threading.py），保持向后兼容性 函数和方法参数 始终要将 self 作为实例方法的的第一个参数 始终要将 cls 作为类静态方法的第一个参数 如果函数的参数名和已有的关键词冲突，在最后加单一下划线比缩写或随意拼写更好。因此 class_ 比 clss 更好（也许最好用同义词来避免这种冲突） 编程建议 代码应该用不损害其他Python实现的方式去编写（PyPy，Jython，IronPython，Cython，Psyco 等） 比如，不要依赖于在CPython中高效的内置字符连接语句 a += b 或者 a = a + b 这种优化甚至在CPython中都是脆弱的（它只适用于某些类型）并且没有出现在不使用引用计数的实现中。在性能要求比较高的库中，可以用“”.join() 代替 这可以确保字符关联在不同的实现中都可以以线性时间发生 和像None这样的单例对象进行比较的时候应该始终用 is 或者 is not，永远不要用等号运算符 另外，如果你在写 if x 的时候，请注意你是否表达的意思是 if x is not None。举个例子，当测试一个默认值为None的变量或者参数是否被设置为其他值的时候。这个其他值应该是在上下文中能成为bool类型false的值 使用 is not 运算符，而不是 not … is 虽然这两种表达式在功能上完全相同，但前者更易于阅读，所以优先考虑 推荐： if foo is not None 不推荐： if not foo is None: Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-13 20:41:50 "},"Python/Python基础知识/summary.html":{"url":"Python/Python基础知识/summary.html","title":"Python基础知识","keywords":"","body":" 代码与注释 变量与常量 整形与浮点型 列表类型 元组类型 字符串类型 字典类型 集合类型 布尔类型 单例None 内存管理 深浅拷贝 输入与输出 运算符相关 分支结构 流程控制 推导式 字符编码 文件操作 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-13 20:41:50 "},"Python/Python基础知识/代码与注释.html":{"url":"Python/Python基础知识/代码与注释.html","title":"代码与注释","keywords":"","body":"代码注释 学习任何一门语言首要的就是学习它的注释。注释就是说你的脚本程序在运行过程中不会被解释器解释与执行的一部分，它的功能主要是给人阅读方便代码的后期维护。 在Python中（Python2和Python3均可），主要有3种注释方式，其中单行注释1种，多行注释2种。 #号注释 单个#号注释是属于单行注释，如下示例： # This is a single line comment 要注意的是，我们一般会在#后面添加上一个空格，如果#号前面有代码，一般会间隔两个空格。 print(\"HELLO,WORLD\") # 它将打印HELLO,WORLD -- - 三单引号注释 ''' '''三个单引号可以进行跨行注释，如下示例： def func(): ''' 用于进行一个功能的描述与说明 ''' pass 三双引号注释 \"\"\" \"\"\"三个双引号的注释与三个单引号的注释语义相同，基本上在能够使用三个单引号的地方都可以使用三个双引号： def func(): \"\"\" 用于进行一个功能的描述与说明 \"\"\" pass Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-13 20:41:50 "},"Python/Python基础知识/变量与常量.html":{"url":"Python/Python基础知识/变量与常量.html","title":"变量与常量","keywords":"","body":"标识符与对象 在Python中有一个核心的概念，叫做一切皆对象。 我们定义的数据、资源等皆可称之为对象，对象均存放在内存中。 而如果要使用这个对象，则必须通过标识符与对象进行绑定，说的通俗一点就是，为对象取一个名字。 一般来讲，一次绑定分为三部分操作： 创建资源对象（值） 创建标识符（名字） 建立绑定关系（赋值符号） 如下所示： 整个绑定的过程，被称为常量\\变量赋值或者对象定义，用=号将标识符与对象进行链接。 如下所示，我们用多个对象表示一个人的信息： name = \"yunya\" age = 18 height = 1.92 print(\"name : %s\\nage : %s\\nheight : %s\\n\" % (name, age, height)) # name : yunya # age : 18 # height : 1.92 先定义后使用 对象必须先定义，后使用，如果未定义就使用则会抛出异常。 print(\"My name is :\", name) name = \"yunya\" # NameError: name 'name' is not defined 命名风格 下面介绍几种常用的标识符命名方式： Camel-Case之小驼峰式：个人比较喜欢的风格，但是Python中并不建议使用小驼峰。 单词开头的字母小写，而后每个单词的分割首字母采用大写形式： userAge = 18 Camel-Case之大驼峰式：大驼峰式在Python中比较常见，一般定义类名时使用，不要滥用大驼峰。 每个单词都首字母都大写 UserInfo = {} 匈牙利类型标记法：前面的小写字母为变量类型，如，i代表int类型、s代表str类型： iUserAge = 18 蛇形命名法：小写+下划线，是Python中更推荐使用的标识符命名方式： user_age = 18 命名规范 标识符的命名需要遵从以下规范： 标识符应当见名知意 标识符由数字，字母，下划线组成。并且开头不能为数字 标识符不能使用Python中的关键字 错误的示范： $name = 'yunya' # 具有特殊字符 1year = 365 # 数字开头 *_size = 1024 # 具有特殊字符 and = 123 # 使用了关键字 年级 = 3 # 强烈不建议使用中文（占用内存大） (color) = 'red' # 虽然这种命名方式可行但是也极为不推荐 正确的示范： name = 'yunya' __age = 18 # Python中双下划线开头的标识符一般有隐私的这种说法，因此一般不建议使用 page_1 = 'home page' 同时，个人十分不推荐在标识符中加上任何的数字，这样的做法显得很莽撞。如item1，item2等... 绑定映射 Python中所有的数据均被称之为对象（object），对象存放至堆（heap）区内存中。 在对象存入堆区内存时，会为对象开辟一块内存空间并保存。 而在栈（stack）区内存中，则存放对象的引用（reference），即对象在堆区内存中的地址。 当一个对象被赋值给一个标识符后，在栈区内存中会创建一种映射（mapping）关系，此时标识符和对象就建立了联系，并且标识符本身也会被存放至栈区内存中。 name = \"yunya\" age = 18 height = 1.92 盒子声明 在很多其他的编程语言中，声明一个数据的过程可以被称作盒子声明，当遇到赋值操作时，它会进行如下的流程： 创建一个具体的盒子（开辟内存，创建盒子，并且为盒子打上标识） 放入具体的数据（将对象放入盒子中） 而在Python中，则没有盒子声明这种说法，我更喜欢将它称作贴纸声明，当遇到赋值操作时，它会进行如下的流程： 先创建一个对象（自动的在遇到=符号时，开辟内存并创建对象，如果该对象已存在，则进行引用） 将=符号左侧的标识符与对象绑定（像贴纸一样） 两者对比一下： 其他编程语言中总是先进行标识符盒子的初始化，再之后将数据对象放入盒子中 Python中总是先创建对象，并且再将标识符与对象做绑定 如下图所示： 引用传递 Python中所有的标识符与对象的绑定均为引用，不论是函数传参，单纯赋值等，标识符都与对象的内存地址做绑定，而不和对象本身的值做绑定。 Python中一个对象可以被多个标识符所引用，而一个标识符仅能引用一个对象。 你可以理解为Python中所有数据类型均为引用类型，没有值类型。 如下所示，我们将声明2个不同的标识符，标识符都指向了同一个int对象： oldAge = 18 newAge = oldAge print(id(oldAge)) print(id(newAge)) # 4550527568 # 4550527568 如下图所示： 在Golang中，如果进行上面的操作，因为盒子声明的缘故新的标识符newAge会创建出一片新的内存空间，并且将oldAge的值进行一次拷贝后存放至新内存空间中： package main import \"fmt\" func main() { var oldAge int = 18 var newAge int = oldAge fmt.Println(oldAge, &oldAge) fmt.Println(newAge, &newAge) } // 18 0xc42008e168 // 18 0xc42008e190 如下图所示： 变量 变量指的是该标识符所绑定的对象允许在运行时刻发生变化，是用来记录事物变化状态的一种东西。 举个例子： 进入游戏：等级为0 一天之后：等级为10 一月之后：等级为100 标识符（等级）与表示等级的对象所绑定，并且该等级在不断的变化，那么这个标识符可以称为变量标识符，与变量标识符绑定的对象是可以随意改变的： # 进入游戏 level = 0 # 一天后 level = 10 # 一月后 level = 100 # 现在的等级 print(level) # 100 变量命名 变量标识符的命名一般以蛇形命名法和小驼峰命名法为准。 不可使用大驼峰式命名法，同时全大写命名法也不要进行使用。 匿名变量 如果一个变量标识符为_，则代表该变量为匿名变量。 匿名变量的作用是当做一个垃圾桶，对于一些不会用到的对象可以命名为_，仅做到一个占位的作用，这在解构赋值中经常会被使用到。 其实官方没有匿名变量的定义，这也是Python社区中一条不成文的规定，因为实在是懒得对一个不用的对象想名字，干脆就用_进行命名。 常量 常量指的是该标识符所绑定的对象不允许在运行时刻发生变化，表示一个恒定的数据。 举个例子： 圆周率PI是恒定的，不能因为程序的运行而改变 人的性别是恒定的，不能因为程序的运行而改变 很遗憾，在应用领域来说Python并未提供常量的定义，但是在Python社区中有一个不成文的规定。 如果一个标识符所有字母都是大写的话，则认为该标识符是常量标识符： PI = 3.1415926535897 SEX = \"男\" 常量池 上面说过，尽管在应用领域中Python并未提供常量的定义，但是在内部实现中处处可见常量的影子。 如小整数常量池就是一个很好的例子。 在其他的编程语言，类似Golang、JavaScript中，常量定义的关键词为const，很快你也会在Python中见到这个单词。 相关方法 id() 使用id()函数可拿到标识符所对应对象在堆区内存中的地址号。 name = \"yunya\" print(id(name)) # 2933298725640 type() 使用type()函数可获取到该标识符对应对象的数据类型，返回类本身。 name = \"yunya\" print(type(name)) # del 使用del跟上标识符名字，将对该标识符所关联的对象进行解绑操作，同时也会取消该标识符的定义，将其从栈区内存中抹去。 name = \"yunya\" del name print(name) # NameError: name 'name' is not defined Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-13 20:41:50 "},"Python/Python基础知识/整形与浮点型.html":{"url":"Python/Python基础知识/整形与浮点型.html","title":"整形与浮点型","keywords":"","body":"整形 整形概述 Python中对于整形的划分非常简单，仅仅只有一个int类型。 整形是不可变类型，即对象本身的属性不会根据外部变化而变化 整形属于原子类型，即不可被分割 基本声明 以下是使用类实例化的形式进行对象声明： age = int(12) print(\"value : %r\\ntype : %r\" % (age, type(age))) # value : 12 # type : 也可以选择使用更方便的字面量形式进行对象声明： age = 12 print(\"value : %r\\ntype : %r\" % (age, type(age))) # value : 12 # type : 类型转换 整形可以与布尔型，浮点型，字符串等做转换，使用对应的工厂函数即可： num = 1 strNum = str(num) boolNum = bool(num) floatNum = float(num) print(\"value : %r\\ntype : %r\" % (strNum, type(strNum))) print(\"value : %r\\ntype : %r\" % (boolNum, type(boolNum))) print(\"value : %r\\ntype : %r\" % (floatNum, type(floatNum))) # value : '1' # type : # value : True # type : # value : 1.0 # type : 进制转换 使用以下三个内置函数，可进行进制转换： 函数名 描述 bin() 十进制转二进制 oct() 十进制转八进制 hex() 十进制转十六进制 示例如下： num = 100 print(bin(num)) print(oct(num)) print(hex(num)) # 0b1100100 # 0o144 # 0x64 如果想二进制、八进制、十六进制转换十进制，则可通过指定int()的第二参数base实现，如下所示： print(int(\"0b1100100\", base=2)) print(int(\"0o144\", base=8)) print(int(\"0x64\", base=16)) # 100 # 100 # 100 Unicode转换 使用以下两个内置函数，可进行整形与Unicode互转： 函数名 描述 chr() 传入0-1114111之间的整形，将其转换为Unicode字符 ord() 传入单个Unicode字符，将其转换为Unicode字符十进制整形 示例如下： >>> chr(65) 'A' >>> ord(\"A\") 65 long类型 在Python2中，如果整形后面加上L则代表长整型，在Python3中取消了这种设定。 >>> num = 100L >>> type(num) 浮点型 浮点型概述 Python中对于浮点型的划分非常简单，仅仅只有一个float类型。 浮点形是不可变类型，即对象本身的属性不会根据外部变化而变化 浮点形属于原子类型，即不可被分割 基本声明 以下是使用类实例化的形式进行声明： f = float(3.15) print(\"value : %r\\ntype : %r\" % (f, type(f))) # value : 3.15 # type : 也可以选择使用更方便的字面量形式： f = 3.15 print(\"value : %r\\ntype : %r\" % (f, type(f))) # value : 3.15 # type : 类型转换 浮点形可以与布尔型、整型、字符串等做转换，使用对应的工厂函数即可： num = 1.9 strNum = str(num) boolNum = bool(num) intNum = int(num) print(\"value : %r\\ntype : %r\" % (strNum, type(strNum))) print(\"value : %r\\ntype : %r\" % (boolNum, type(boolNum))) print(\"value : %r\\ntype : %r\" % (intNum, type(intNum))) # value : '1.9' # type : # value : True # type : # value : 1 # type : 四则运算 整形与浮点型均支持四则运算。 但是需要注意的是当整形与浮点型进行运算后，所得到的结果必然是浮点型： print(100 * 1.0) # 100.0 同时，整形也可以与字符串进行乘法运算： print(\"hello\" * 3) # hellohellohello 他两都支持与布尔型进行运算，布尔型的本质就是1和0，这里不再例举。 _的形式 在Python3中提供了对数字的_分割表现形式。 旨在更加方便阅读大数字： >>> a = 100_00 >>> a 10000 >>> b = 100_00.1 >>> b 10000.1 强类型 由于Python是强类型语言，故不会出现隐式转换的问题（Python2中是允许字符串与数字做比较的，且数字永远小于字符串）。 如下，使用整形与字符串做对比，返回的结果永远是False。 print(\"100\" == 100) # False 但是整形可以和浮点型做比较，因为它们同属于数值类型： print(100.00 == 100) # True 他两都支持与布尔型进行比较，布尔型的本质就是1和0，这里不再例举。 小整数池 Python解释器觉得有一些整数会经常被使用（-5到255之间），故当脚本程序运行前就将这些数字写入堆区内存中。 当用户定义int对象且使用到其中的数值时会直接将该数值的内存地址引用到存在于栈内存的变量标识符上，这样做极大节省了内存空间。 如：一个程序中使用了100000次1这个数值，那么如果没有Python的这个机制则会开辟出100000个内存空间用来存放相同的数值。 这么做显然极大的浪费了内存。 故Python的这种机制是十分高效且合理的，并且它的名字叫做小整数常量池，或简称为小整数池（范围：-5,255）： int_1 = 1 int_2 = 1 print(id(int_1)) # 1558801440 print(id(int_2)) # 1558801440 # 超出小整数池范围 int_3 = -6 int_4 = -6 print(id(int_3)) # 2264143854288 print(id(int_4)) # 2264143854448 绝对引用 数值拥有绝对引用的特性，无论是深拷贝还是浅拷贝，都不会获得其副本，而是直接对源对象进行引用： >>> import copy >>> oldN = 1_0000 >>> id(oldN) 4373791728 >>> n1 = copy.copy(oldN) >>> id(n1) 4373791728 >>> n2 = copy.deepcopy(oldN) >>> id(n2) 4373791728 声明速率 时间对比 对于所有的Python内置数据模型来说，字面量形式的对象声明永远要比类实例化的形式对象声明速度要快。 时间差大约3倍或者更多，我们可以做一个小实验来观察，使用timeit模块检测2者时间差： $ python3 -m timeit -n 1000000 -r 5 -v \"int(1)\" raw times: 0.138 0.136 0.135 0.152 0.16 1000000 loops, best of 5: 0.135 usec per loop $ python3 -m timeit -n 1000000 -r 5 -v \"1\" raw times: 0.00974 0.00961 0.0107 0.0107 0.00991 1000000 loops, best of 5: 0.00961 usec per loop ❶ -n 语句执行多少次 ❷ -r 重复计时器的次数，默认为5 可以看类实例化声明1百万次int类型时长为0.135秒。 而字面量形式声明1百万次int类型时长为0.00961秒。 整个差距居然有14倍！当然，如果是一些复杂的类型声明，这个差距会变小。 底层探究 为什么会出现这样的情况，可以使用dis模块来探索，该模块会通过反汇编来查看到语句执行情况的字节码。 $ echo \"int(1)\" > demo.py $ python3 -m dis demo.py 1 0 LOAD_NAME 0 (int) 2 LOAD_CONST 0 (1) 4 CALL_FUNCTION 1 6 POP_TOP 8 LOAD_CONST 1 (None) 10 RETURN_VALUE $ echo \"1\" > demo.py $ python3 -m dis demo.py 1 0 LOAD_CONST 0 (None) 2 RETURN_VALUE 使用类实例化声明对象时，必定会调用到底层函数__init__()，而调用函数的过程会发起系统调用栈的进出栈操作，故更加耗时。 此外，我们也从上面的LOAD_CONST可以观察出，int类型小整数1确实会从小整数常量池中加载数据。 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-13 20:41:50 "},"Python/Python基础知识/列表类型.html":{"url":"Python/Python基础知识/列表类型.html","title":"列表类型","keywords":"","body":"列表 Python中的列表（list）是最常用的数据类型之一。 Python中的列表可以存储任意类型的数据，这与其他语言中的数组（array）不同。 被存入列表中的内容可称之为元素（element）或者数据项（data item）亦或是值（value）。 虽然Python列表支持存储任意类型的数据项，但不建议这么做，事实上这么做的概率也很低。 列表特性 列表特性如下： 列表属于线性容器序列 列表属于可变类型，即对象本身的属性会根据外部变化而变化，例如长度 列表底层由顺序存储组成，而顺序存储是线性结构的一种 基本声明 以下是使用类实例化的形式进行对象声明： lst = list((1, 2, 3, 4, 5)) print(\"value : %r\\ntype : %r\" % (lst, type(lst))) # value : [1, 2, 3, 4, 5] # type : 也可以选择使用更方便的字面量形式进行对象声明，利用[]对数据项进行包裹，并且使用逗号将数据项之间进行分割： lst = [1, 2, 3, 4, 5] print(\"value : %r\\ntype : %r\" % (lst, type(lst))) # value : [1, 2, 3, 4, 5] # type : 多维列表 当一个列表中嵌套另一个列表，该列表就可以称为多维列表。 如下，定义一个2维列表： lst = [1, 2, [\"三\",\"四\"]] print(\"value : %r\\ntype : %r\" % (lst, type(lst))) # value : [1, 2, ['三', '四']] # type : 续行操作 在Python中，列表中的数据项如果过多，可能会导致整个列表太长，太长的列表是不符合PEP8规范的。 每行最大的字符数不可超过79，文档字符或者注释每行不可超过72 Python虽然提供了续行符\\，但是在列表中可以忽略续行符，如下所示： lst = [ 1, 2, 3, 4, 5 ] print(\"value : %r\\ntype : %r\" % (lst, type(lst))) # value : [1, 2, 3, 4, 5] # type : 类型转换 列表支持与布尔型、字符串、元组、以及集合类型进行类型转换： lst = [1, 2, 3] bLi = bool(lst) strLi = str(lst) tupLi = tuple(lst) setLi = set(lst) print(\"value : %r\\ntype : %r\" % (bLi, type(bLi))) print(\"value : %r\\ntype : %r\" % (strLi, type(strLi))) print(\"value : %r\\ntype : %r\" % (tupLi, type(tupLi))) print(\"value : %r\\ntype : %r\" % (setLi, type(setLi))) # value : True # type : # value : '[1, 2, 3]' # type : # value : (1, 2, 3) # type : # value : {1, 2, 3} # type : 如果一个2维列表遵循一定的规律，那么也可以将其转换为字典类型： lst = [[\"k1\", \"v1\"], [\"k2\", \"v2\"], [\"k3\", \"v3\"]] dictList = dict(lst) print(\"value : %r\\ntype : %r\" % (dictList, type(dictList))) # value : {'k1': 'v1', 'k2': 'v2', 'k3': 'v3'} # type : 四则运算 列表支持与元组，列表进行加法运算： +：合并2个列表并生成新列表： lst1 = [1, 2, 3] lst2 = [4, 5, 6] newLi = lst1 + lst2 print(newLi) # [1, 2, 3, 4, 5, 6] +=：扩展已有列表，相当于extend()方法： oldLi = [1, 2, 3] newLi = [4, 5, 6] oldLi += newLi print(oldLi) # [1, 2, 3, 4, 5, 6] 列表支持与数字进行乘法运算： *：生成一个重复旧列表数据项的新列表： oldLi = [1, 2, 3] newLi = oldLi * 3 print(newLi) # [1, 2, 3, 1, 2, 3, 1, 2, 3] *=：扩展已有列表，将已有列表的数据项进行重复添加： oldLi = [1, 2, 3] oldLi *= 3 print(oldLi) # [1, 2, 3, 1, 2, 3, 1, 2, 3] 索引切片 索引的概念 列表底层是以一种连续的顺序结构存储数据项，故可以使用索引（index）对数据项进行获取、删除、截取、替换等操作。 ----------------------------| | A | B | C | D | E | F | G | ----------------------------| | 0 | 1 | 2 | 3 | 4 | 5 | 6 | |-7 |-6 |-5 |-4 |-3 |-2 |-1 | 正向索引都是从0开始，负向索引都是从-1开始。 enumerate() 我们以一个内置函数enumerate()来举例，该函数返回一个迭代器，将其转换为list()后可以查看数据项以及正向索引： lst = [\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\"] print(list(enumerate(lst))) # [(0, 'A'), (1, 'B'), (2, 'C'), (3, 'D'), (4, 'E'), (5, 'F'), (6, 'G')] 更多的关于enumerate()函数的妙用，将会放在循环章节中进行探讨。 slice() slice()函数有三个参数： start：索引开始的位置 stop：索引结束的位置 step：步长间距，默认为1 如果为正数代表正取，如果为负数代表倒取 如果为1代表连续取，如果为2代表隔一个取一个，以此类推 使用方法如下示例，先使用slice()确定截取数据项的范围，然后再使用列表的[]操作形式取出指定范围的数据项。 注意：所有的切片都是顾头不顾尾： lst = [\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\"] # 取出A # 释义：从0开始取，取1个，步长为0 s = slice(0, 1, None) print(lst[s]) # ['A'] [::]形式 使用slice()函数会比较繁琐，直接使用[::]形式进行切片会比较简单。 签名如下： [start:stop:step] 参数描述和slice()相同，当某一参数不设置时可省略前面的参数。 增删改截操作演示： >>> # 获取第2个数据项 >>> lst = [\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\"] >>> lst[1] 'B' >>> # 删除第3个数据项 >>> del lst[2] >>> lst ['A', 'B', 'D', 'E', 'F', 'G'] >>> # 从第1个数据项开始向后替换2个数据项，替换内容为123 >>> lst[0:3] = 1,2,3 >>> lst [1, 2, 3, 'E', 'F', 'G'] >>> # 从第1个数据项开始获取2个数据项 >>> lst[0:3] [1, 2, 3] >>> # 试图访问一个超出索引之外的数据项，将引发异常 >>> lst[100] IndexError: lstst index out of range 需要注意的是，如果使用[:]则会创建一个新的列表，再将原有列表中的数据项全部引用至新的列表中，类似于浅拷贝的概念。 如下所示： lst1 = [\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\"] lst2 = lst1[:] print(\"value : %r\\naddr : %r\" % (lst1, id(lst1))) print(\"value : %r\\naddr : %r\" % (lst2, id(lst2))) # value : ['A', 'B', 'C', 'D', 'E', 'F', 'G'] # addr : 4307969608 # value : ['A', 'B', 'C', 'D', 'E', 'F', 'G'] # addr : 4308270792 正向切片 正向切片即使用正向索引进行切片，索引从0处开始进行切片。 如下示例： >>> lst = [\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\"] >>> lst[0:3] ['A', 'B', 'C'] 反向切片 反向切片即使用反向索引进行切片，索引从-1处开始进行切片。 如下示例： >>> lst = [\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\"] >>> lst[-3:] ['E', 'F', 'G'] 多维切片 列表是支持多维切片的，如下示例，拿出2维列表中的数据项A： >>> lst = [1, 2, [\"A\", \"B\"]] >>> lst[-1][0] 'A' 高级切片 反向和正向切片可以混合使用，下面是一些高级切片的用法： >>> lst = [\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\"] >>> lst[:] ❶ ['A', 'B', 'C', 'D', 'E', 'F', 'G'] >>> lst[2:4] ❷ ['C', 'D'] >>> lst[::2] ❸ ['A', 'C', 'E', 'G'] >>> lst[::-2] ['G', 'E', 'C', 'A'] ❹ >>> lst[::-1] ❺ ['G', 'F', 'E', 'D', 'C', 'B', 'A'] >>> lst[:-5:-2] ❻ ['G', 'E'] >>> lst[0::-1] ❼ ['A'] >>> lst[5::-2] ❽ ['F', 'D', 'B'] 如何一眼读懂高级切片，通过以下步骤判定： 第一步先观察step，是负数还是正数，负数代表倒着取 第二步观察start，确定切片的开始位置 第三步观察stop，确定切片的结束位置 上述示例演示的说明，带*的是比较重要的方式。 ❶：列表的[:]操作是创建一个新的列表，再将原有列表中的数据项全部引用一次至新的列表* ❷：步长为空，代表正着取，从第2号索引位置的数据项开始，到第4号索引位置的数据项结束，根据顾头不顾尾原则，取2，3号索引的数据项* ❸：步长为2，代表正着取，隔一个取一个，即从0号索引位置的数据项开始，每次往后数到2的时候再取* ❹：步长为-2，代表倒着取，隔一个取一个，即从-1号索引位置的数据项开始，每次向前数到2的时候再取* ❺：步长为-1，代表倒着取，即从-1号索引位置的数据项开始，取到索引0号位置结束* ❻：步长为-2，代表倒着取，隔一个位置取一个，取到-5索引位置结束，根据顾头不顾尾原则，不取-5索引位置的数据项 ❼：步长为-1，代表倒着取，开始位置为0，结束位置未标记，则取1个 ❽：步长为-2，代表倒着取，隔一个取一个，开始位置为5号索引，则从第5号索引开始向前取 解构方法 *语法 使用*语法可对列表进行解构，将列表中的数据项全部提取出来： lst = [1, 2, 3] print(*lst) # 1 2 3 我们可以利用*语法的特性，来达到两个列表进行合并产生新列表的效果，类似于+： lst1 = [1, 2, 3] lst2 = [4, 5, 6] result = [*lst1, *lst2] print(result) # [1, 2, 3, 4, 5, 6] 解构赋值 如果一个列表中的数据项需要赋值到变量中，可使用解构赋值，需要注意的是变量接收位置与列表中的数据项位置需要一一对应： lst = [\"A\", \"B\"] item1, item2 = lst print(item1, item2) # A B 我们只想取出列表中前2个数据项时，可使用*语法将剩下的数据项全部打包到一个变量中： lst = [\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\"] item1, item2, *otherItems = lst print(item1, item2) print(otherItems) # A B # ['C', 'D', 'E', 'F', 'G'] 如果只想取第1个后和最后2个，中间的都不想要怎么办？也可以通过*语法： lst = [\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\"] itemFirst, *_, itemLast1, itemLast2 = lst # ❶ print(itemFirst, itemLast1, itemLast2) print(_) # A F G # ['B', 'C', 'D', 'E'] ❶：_为匿名变量，参见变量与常量一章节中的释义 常用方法 方法一览 常用的list方法一览表： 方法名 返回值 描述 append() None 将数据项添加至列表的末尾 extend() None 通过附加来自可迭代对象的数据项来扩展列表 insert() None 在索引之前插入对象 pop() item 删除并返回索引处的项目（默认为-1）。如果列表为空或索引超出范围，则引发IndexError copy() list 返回L的浅拷贝 remove() None 删除列表中第一次出现的数据项。如果不存在该数据项，则引发ValueError clear() None 从L移除所有项目 count() integer 返回数据项在L中出现的次数 index() integer 返回第一个数据项在L中出现位置的索引，若值不存在，则抛出ValueError sort() None 对列表进行原地排序，可指定参数reverse，若不指定该参数则默认升序排列，指定该参数则为降序排列 基础公用函数： 函数名 返回值 描述 len() integer 返回容器中的项目数 enumerate() iterator for index, value of iterable 返回一个可迭代对象，其中以小元组的形式包裹数据项与正向索引的对应关系 reversed() ... 详情参见函数章节 sorted() ... 详情参见函数章节 获取长度 使用len()方法来获取列表的长度。 返回int类型的值。 lst = [\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\"] print(len(lst)) # 7 Python在对内置的数据类型使用len()方法时，实际上是会直接的从PyVarObject结构体中获取ob_size属性，这是一种非常高效的策略。 PyVarObject是表示内存中长度可变的内置对象的C语言结构体。 直接读取这个值比调用一个方法要快很多。 追加元素 使用append()方法为当前列表追加一个数据项。 返回None： lst = [\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\"] lst.append(\"H\") print(lst) # ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H'] 你也可以使用+=进行操作，但个人并不推荐这样使用。 lst = [\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\"] lst += \"H\" print(lst) # ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H'] 列表合并 使用extend()方法来让当前列表与另一个可迭代对象进行合并。 返回None： lst1 = [\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\"] lst2 = [\"H\", \"J\", \"K\", \"L\"] lst1.extend(lst2) print(lst1) # ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'J', 'K', 'L'] 你也可以使用+=进行操作，但个人并不推荐这样使用。 lst1 = [\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\"] lst2 = [\"H\", \"J\", \"K\", \"L\"] lst1 += lst2 print(lst1) # ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'J', 'K', 'L'] 插入元素 使用insert()方法将数据项插入当前列表中的指定位置。 返回None： lst = [\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\"] lst.insert(0, \"a\") print(lst) # ['a', 'A', 'B', 'C', 'D', 'E', 'F', 'G'] 列表拷贝 使用copy()方法将当前列表进行浅拷贝。 返回当前列表的拷贝对象： oldLi = [\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\"] newLi = oldLi.copy() print(oldLi) print(newLi) print(id(oldLi)) print(id(newLi)) print(id(oldLi[0])) print(id(oldLi[0])) # ['A', 'B', 'C', 'D', 'E', 'F', 'G'] # ['A', 'B', 'C', 'D', 'E', 'F', 'G'] # 4329305992 # 4329607688 # 4328383520 # 4328383520 弹出元素 使用pop()方法弹出当前列表中在此索引位置的数据项，列表中该数据项将被删除，并返回被弹出的数据项。 若不指定位置，则默认弹出-1号索引位置的数据项： lst = [\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\"] popItem1 = lst.pop() popItem2 = lst.pop(2) print(lst) print(popItem1) print(popItem2) # ['A', 'B', 'D', 'E', 'F'] # G # C 删除元素 使用remove()方法删除当前列表中的数据项，根据数据项的名字进行删除。 如果具有多个同名的数据项，则只会删除第一个。 返回None： lst = [\"A\", \"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\"] lst.remove(\"A\") print(lst) # ['A', 'B', 'C', 'D', 'E', 'F', 'G'] 我们也可以使用del lst[index]进行数据项的删除： lst = [\"A\", \"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\"] del lst[0] print(lst) # ['A', 'B', 'C', 'D', 'E', 'F', 'G'] 这种方式还可以删除多个： lst = [\"A\", \"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\"] del lst[0:3] print(lst) # ['C', 'D', 'E', 'F', 'G'] 清空元素 使用clear()方法将当前列表进行清空，即删除所有数据项。 返回None： lst = [\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\"] lst.clear() print(lst) # [] 我们也可以使用del lst[:]进行列表的清空： lst = [\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\"] del lst[:] print(lst) # [] 统计次数 使用count()方法统计数据项在该列表中出现的次数。 返回int： lst = [\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\", \"A\"] aInLiCount = lst.count(\"A\") print(aInLiCount) # 2 查找位置 使用index()方法找到数据项在当前列表中首次出现的位置索引值，如数据项不存在则抛出异常。 返回int。 lst = [\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\", \"A\"] aInLiIndex = lst.index(\"A\") print(aInLiIndex) # 0 顺序排列 使用sort()方法将当前列表中的数据项按照ASCII码顺序进行排列，默认从小到大。 可指定参数resverse，用于是否翻转列表，如翻转列表则代表从大到小。 返回None： lst = [\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\", \"A\"] lst.sort(reverse=True) print(lst) # ['G', 'F', 'E', 'D', 'C', 'B', 'A', 'A'] sort()方法内部采用timsort算法，这是一种非常优秀的算法，速度快且稳定。 底层探究 容器序列 这里引出一个新的概念，线性容器序列： 线性是指该对象内部是由连续的内存空间组成 容器中能存放不同类型的数据项，如list就是标准的一个容器 序列是指具有长度的对象，且该对象能使用index进行内部数据项的操作 容器序列存放的是它们所包含的任意类型的对象的引用，如下定义了一个列表： x = [“A”, “B”, “C”] 它的内部存储结构如下图所示： 在CPython源码中，列表数据项的引用为PyObject **ob_item属性，即指针的指针。 元素调整 列表中，pop()和insert()方法都具有指定索引值的功能。 如果使用pop(0)，或者insert(0)则都会引起整个列表中数据项的调整。 pop(0)会将队首的数据项弹出并删除，后面的所有数据项都要向前挪一个位置。1变成0，2变成1，以此类推 insert(0)会将新的数据项插入至队首，后面的所有数据项都要向后挪一个位置。0变成1，1变成2，以此类推 而单纯的使用pop()或者append()则不会发生数据项调整，因为它们总是在队尾做操作。 总而言之，任何一个方法只要不是操作的队尾数据项，都会引起该列表中其他所有数据项的调整。 图示如下： 扩容机制 在对列表进行添加数据项时，如果列表内部的容量已满则会触发扩容机制。 我们要理解2个概念： 容量：容量指的是列表底层在开辟内存时，开辟了多大的内存空间，能够容纳多少数据项，可以理解为一共有多少个槽位 大小：大小指的是当前列表中，数据项已占据的容量，可以理解为已用了多少个槽位 在CPython源码中，列表容量的属性为Py_ssize_t allocated，而列表大小的属性为Py_ssize_t ob_size 在初始化列表时，容量和大小总是等于数据项的总个数，如： 一个空列表，容量和大小都为0 有8个槽位的列表，容量和大小都为8 如果对一个已有的列表进行增加数据项的操作时会有以下2条判断，判定当前列表是否需要扩容： 当前列表容量 > 已有数据项个数+1 and 已有数据项个数 >= 当前列表容量的一半 则直接添加数据项，不进行扩容 并且新增数据项个数 Py_ssize_t ob_size + 1 当前列表容量 则先进行扩容后再添加数据项 扩容是一种线性增长，增长规律为：0、4、8、16、24、32、40、52、64、76 …，总是为4的倍数 在扩容时不必担心发生内存溢出，因为内部已经设置了最大值 为：PY_SSIZE_T_MAX *（9/8）+ 6 缩容机制 缩容机制建立在列表有空余空间的情况下。 我们如果使用pop()方法删除了最后一个数据项，其实并不会将最后一个列表槽位所占用的内存空间给释放掉而是进行保留，内部仅进行一次Py_ssize_t ob_size - 1的操作。 这样做的好处是，后面再添加数据项时，其实就不用再次进行扩容了。 但是在添加数据项之前，会判断整个列表的容量是否过大，如果过大即代表还有很多空的位置，此时要进行缩容机制： 如果数据项个数 + 1 则进行缩容，删除空的列表槽位 如果是clear()清空列表中的数据项，则直接非常干脆的将容量以及大小都重置为0，并且将该列表所有槽位占据的内存空间进行释放。 迁徙机制 因为列表底层是顺序存储，必须占用一个连续的内存空间。 如果在进行扩容时，发现后面连续的内存空间被其他对象所占据，则会将整个列表进行一次拷贝。 然后迁徙到新的位置开辟内存，确保所有的列表槽位都是连续的。 列表缓存 当删除一个列表之后，会将该列表中槽位引用的数据项地址全部清空。 并且将该列表的引用存放至一个叫做free_list的缓存中，下次如果再需要创建列表，则直接从free_list缓存中获取。 free_list最多可以缓存80个列表 示例，旧列表被删除后将空列表的引用存放至free_list缓存中，当再次创建一个新列表时，会直接从free_list缓存中获取旧列表，并且填入数据项： lst1 = [1, 2, 3] print(id(lst1)) del lst1 lst2 = [4, 5, 6, 7] print(id(lst2)) # 4405732936 # 4405732936 listobject.c源码 官网参考：点我跳转 源码一览：点我跳转 以下是截取了一些关键性源代码，并且做上了中文注释，方便查阅。 每一个列表都有几个关键性的属性： Py_ssize_t ob_refcnt; // 引用计数器 PyObject **ob_item; // 列表内部槽位的数据项指针，即指针的指针 Py_ssize_t ob_size; // 列表大小 Py_ssize_t allocated; // 列表容量 创建列表 PyObject * PyList_New(Py_ssize_t size) { // 空列表 if (size numfree != -1); #endif // 判断是否有free_list中是否有缓存 if (state->numfree) { // 有缓存，free_list缓存的列表个数减1 state->numfree--; op = state->free_list[state->numfree]; // 建立新的引用关系 _Py_NewReference((PyObject *)op); } else { // 无缓存，创建新列表，先开辟内存 op = PyObject_GC_New(PyListObject, &PyList_Type); if (op == NULL) { return NULL; } } if (size ob_item = NULL; } else { // 如果列表不是空的，则将每个槽位的数据项地址进行引用 op->ob_item = (PyObject **) PyMem_Calloc(size, sizeof(PyObject *)); if (op->ob_item == NULL) { Py_DECREF(op); return PyErr_NoMemory(); } } // 设置列表中数据项占据的容量大小 Py_SET_SIZE(op, size); // 设置列表的整体容量 op->allocated = size; // 将列表放入双向链表中以进行内存管理 _PyObject_GC_TRACK(op); // 返回列表的结构体指针 return (PyObject *) op; } 添加元素 static int app1(PyListObject *self, PyObject *v) { // 获取列表的大小（已占用容量） Py_ssize_t n = PyList_GET_SIZE(self); assert (v != NULL); assert((size_t)n + 1 static int list_resize(PyListObject *self, Py_ssize_t newsize) { PyObject **items; size_t new_allocated, num_allocated_bytes; Py_ssize_t allocated = self->allocated; /* Bypass realloc() when a previous overallocation is large enough to accommodate the newsize. If the newsize falls lower than half the allocated size, then proceed with the realloc() to shrink the list. */ // 扩容、缩容机制调用realloc()函数 // allocated = 容量 // newsize代表已存在的数据项个数 + 1 // 当前列表容量 > 已有数据项个数+1 and 已有数据项个数 >= 当前列表容量的一半 if (allocated >= newsize && newsize >= (allocated >> 1)) { assert(self->ob_item != NULL || newsize == 0); // 则直接添加数据项，不进行扩容 // 并新增数据项个数 Py_ssize_t ob_size + 1 Py_SET_SIZE(self, newsize); return 0; } /* This over-allocates proportional to the list size, making room * for additional growth. The over-allocation is mild, but is * enough to give linear-time amortized behavior over a long * sequence of appends() in the presence of a poorly-performing * system realloc(). * Add padding to make the allocated size multiple of 4. * The growth pattern is: 0, 4, 8, 16, 24, 32, 40, 52, 64, 76, ... * Note: new_allocated won't overflow because the largest possible value * is PY_SSIZE_T_MAX * (9 / 8) + 6 which always fits in a size_t. */ new_allocated = ((size_t)newsize + (newsize >> 3) + 6) & ~(size_t)3; /* Do not overallocate if the new size is closer to overallocated size * than to the old size. */ // 如果数据项个数 + 1 (Py_ssize_t)(new_allocated - newsize)) new_allocated = ((size_t)newsize + 3) & ~(size_t)3; // 全是空的 if (newsize == 0) new_allocated = 0; num_allocated_bytes = new_allocated * sizeof(PyObject *); // 基于realloc()进行扩容或者缩容，内部会包含数据项的位置调整 items = (PyObject **)PyMem_Realloc(self->ob_item, num_allocated_bytes); if (items == NULL) { PyErr_NoMemory(); return -1; } // 重新设置列表的 ob_item、obsize、allocated self->ob_item = items; Py_SET_SIZE(self, newsize); self->allocated = new_allocated; return 0; } 插入元素 static int ins1(PyListObject *self, Py_ssize_t where, PyObject *v) { // 获取数据项个数 Py_ssize_t i, n = Py_SIZE(self); PyObject **items; // 插入数据项确保不是NULL if (v == NULL) { PyErr_BadInternalCall(); return -1; } assert((size_t)n + 1 n) where = n; // 拿到列表中所有数据项的引用 items = self->ob_item; // 让插入位置之后的所有数据项开始向后挪动1个位置，腾出位置来插入新的数据项 for (i = n; --i >= where; ) // i + 1指的是数据项指针地址，每次 - 1 items[i+1] = items[i]; // 新增数据项的引用计数 + 1 Py_INCREF(v); // 新的数据项索引位置和值做绑定 items[where] = v; return 0; } int PyList_Insert(PyObject *op, Py_ssize_t where, PyObject *newitem) { // 传入列表的引用， 插入的位置，还有新的数据项引用，并且验证列表和数据项 if (!PyList_Check(op)) { PyErr_BadInternalCall(); return -1; } // 进行插入 return ins1((PyListObject *)op, where, newitem); } 移除元素 static PyObject * list_pop_impl(PyListObject *self, Py_ssize_t index) // 传入列表的引用，列表的弹出数据项索引位置 { PyObject *v; int status; // 如果是一个空列表，则抛出异常 if (Py_SIZE(self) == 0) { /* Special-case most common failure cause */ PyErr_SetString(PyExc_IndexError, \"pop from empty list\"); return NULL; } if (index ob_item[index]; // 如果弹出的数据项是列表中的最后一个 if (index == Py_SIZE(self) - 1) { // list_resize()内部只会做size - 1，而不会回收内存进行缩容 status = list_resize(self, Py_SIZE(self) - 1); if (status >= 0) return v; /* and v now owns the reference the list had */ else return NULL; } // 增加一次引用计数器 Py_INCREF(v); // 如果弹出的数据项不是列表中的最后一个，则需要进行位置调整 status = list_ass_slice(self, index, index+1, (PyObject *)NULL); if (status 清空元素 static int _list_clear(PyListObject *a) { Py_ssize_t i; PyObject **item = a->ob_item; if (item != NULL) { /* Because XDECREF can recursively invoke operations on this list, we make it empty first. */ i = Py_SIZE(a); // 重新设置大小为0 Py_SET_SIZE(a, 0); // 将列表中插槽引用的对象全部设置为None a->ob_item = NULL; // 重新设置容量为0 a->allocated = 0; // 循环列表中的数据项，令所有数据项的引用计数-1 while (--i >= 0) { Py_XDECREF(item[i]); } PyMem_Free(item); } /* Never fails; the return value can be ignored. Note that there is no guarantee that the list is actually empty at this point, because XDECREF may have populated it again! */ return 0; } 删除列表 static void list_dealloc(PyListObject *op) { Py_ssize_t i; // 内部会判断这个列表是否还有其他标识符引用，如果为0则代表没有其他标识符引用 // 可以通过内部GC机制将该列表所占据的内存空间进行释放 PyObject_GC_UnTrack(op); Py_TRASHCAN_BEGIN(op, list_dealloc) if (op->ob_item != NULL) { /* Do it backwards, for Christian Tismer. There's a simple test case where somehow this reduces thrashing when a *very* large list is created and immediately deleted. */ // 获取列表中已有数据项的个数（即大小） i = Py_SIZE(op); // 循环列表中的数据项，令所有数据项的引用计数-1 while (--i >= 0) { Py_XDECREF(op->ob_item[i]); } PyMem_Free(op->ob_item); } struct _Py_list_state *state = get_list_state(); #ifdef Py_DEBUG // list_dealloc() must not be called after _PyList_Fini() assert(state->numfree != -1); #endif // 判断free_list中的已缓存列表个数是否大于80，这里是没满 // 在free_list中添加空列表的引用即可 if (state->numfree free_list[state->numfree++] = op; } else { // 如果free_list的大小已达到容量限制 // 则直接在内存中销毁列表的结构体对象 Py_TYPE(op)->tp_free((PyObject *)op); } Py_TRASHCAN_END } Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-13 20:41:50 "},"Python/Python基础知识/元组类型.html":{"url":"Python/Python基础知识/元组类型.html","title":"元组类型","keywords":"","body":"元组 Python中的元组容器序列（tuple）与列表容器序列（list）具有极大的相似之处，因此也常被称为不可变的列表。 但是两者之间也有很多的差距，元组侧重于数据的展示，而列表侧重于数据的存储与操作。 它们非常相似，虽然都可以存储任意类型的数据，但是一个元组定义好之后就不能够再进行修改。 元组特性 元组特性如下： 元组属于线性容器序列 元组属于不可变类型，即对象本身的属性不会根据外部变化而变化 元组底层由顺序存储组成，而顺序存储是线性结构的一种 基本声明 以下是使用类实例化的形式进行对象声明： tpl = tuple((1, 2, 3, 4, 5)) print(\"value : %r\\ntype : %r\" % (tpl, type(tpl))) # value : (1, 2, 3, 4, 5) # type : 也可以选择使用更方便的字面量形式进行对象声明，使用逗号对数据项之间进行分割： tpl = 1, 2, 3, 4, 5 print(\"value : %r\\ntype : %r\" % (tpl, type(tpl))) # value : (1, 2, 3, 4, 5) # type : 为了美观，我们一般会在两侧加上()，但是要确定一点，元组定义是用逗号来分隔数据项，而并非是用()包裹数据项： tpl = (1, 2, 3, 4, 5) print(\"value : %r\\ntype : %r\" % (tpl, type(tpl))) # value : (1, 2, 3, 4, 5) # type : 多维元组 当一个元组中嵌套另一个元组，该元组就可以称为多维元组。 如下，定义一个2维元组： tpl = (1, 2, (\"三\", \"四\")) print(\"value : %r\\ntype : %r\" % (tpl , type(tpl))) # value : (1, 2, ('三', '四')) # type : 续行操作 在Python中，元组中的数据项如果过多，可能会导致整个元组太长，太长的元组是不符合PEP8规范的。 每行最大的字符数不可超过79，文档字符或者注释每行不可超过72 Python虽然提供了续行符\\，但是在元组中可以忽略续行符，如下所示： tpl = ( 1, 2, 3, 4, 5 ) print(\"value : %r\\ntype : %r\" % (tpl, type(tpl))) # value : (1, 2, 3, 4, 5) # type : 类型转换 元组支持与布尔型、字符串、列表、以及集合类型进行类型转换： tpl = (1, 2, 3) bTpl = bool(tpl) strTpl = str(tpl) lstTpl = list(tpl) setTpl = set(tpl) print(\"value : %r\\ntype : %r\" % (bTpl, type(bTpl))) print(\"value : %r\\ntype : %r\" % (strTpl, type(strTpl))) print(\"value : %r\\ntype : %r\" % (lstTpl, type(lstTpl))) print(\"value : %r\\ntype : %r\" % (setTpl, type(setTpl))) # value : True # type : # value : '(1, 2, 3)' # type : # value : [1, 2, 3] # type : # value : {1, 2, 3} # type : 如果一个2维元组遵循一定的规律，那么也可以将其转换为字典类型： tpl = ((\"k1\", \"v1\"), (\"k2\", \"v2\"), (\"k3\", \"v3\")) dictTuple = dict(tpl) print(\"value : %r\\ntype : %r\" % (dictTuple, type(dictTuple))) # value : {'k1': 'v1', 'k2': 'v2', 'k3': 'v3'} # type : 索引操作 元组由于是线性结构，故支持索引和切片操作 但只针对获取，不能对其内部数据项进行修改。 使用方法参照列表的索引切片一节。 绝对引用 元组拥有绝对引用的特性，无论是深拷贝还是浅拷贝，都不会获得其副本，而是直接对源对象进行引用。 但是列表没有绝对引用的特性，代码验证如下： >>> import copy >>> # 列表的深浅拷贝均创建新列表... >>> oldLi = [1, 2, 3] >>> id(oldLi) 4542649096 >>> li1 = copy.copy(oldLi) >>> id(li1) 4542648840 >>> li2 = copy.deepcopy(oldLi) >>> id(li2) 4542651208 >>> # 元组的深浅拷贝始终引用老元组 >>> oldTup = (1, 2, 3) >>> id(oldTup) 4542652920 >>> tup1 = copy.copy(oldTup) >>> id(tup1) 4542652920 >>> tup2 = copy.deepcopy(oldTup) >>> id(tup2) 4542652920 Python为何要这样设计？其实仔细想想不难发现，元组不能对其进行操作，仅能获取数据项。 那么也就没有生成多个副本提供给开发人员操作的必要了，因为你修改不了元组，索性直接使用绝对引用策略。 值得注意的一点：[:]也是浅拷贝，故对元组来说属于绝对引用范畴。 元组的陷阱 Leonardo Rochael在2013年的Python巴西会议提出了一个非常具有思考意义的问题。 我们先来看一下： >>> t = (1, 2, [30, 40]) >>> t[-1] += [50, 60] Traceback (most recent call last): File \"\", line 1, in TypeError: 'tuple' object does not support item assignment 现在，t到底会发生下面4种情况中的哪一种？ t 变成 (1, 2, [30, 40, 50, 60])。 因为 tuple 不支持对它的数据项赋值，所以会抛出 TypeError 异常。 以上两个都不是。 a 和 b 都是对的。 正确答案是4，t确实会变成 (1, 2, [30, 40, 50, 60])，但同时元组是不可变类型故会引发TypeError异常的出现。 >>> t (1, 2, [30, 40, 50, 60]) 如果是使用extend()对t[-1]的列表进行数据项的增加，则答案会变成1。 我当初在看了这个问题后，暗自告诉自己了1件事情： tuple中不要存放可变类型的数据，如list、set、dict等.. 元组更多的作用是展示数据，而不是操作数据。 举个例子，当用户根据某个操作获取到了众多数据项之后，你可以将这些数据项做出元组并返回。 用户对被返回的原对象只能看，不能修改，若想修改则必须创建新其他类型对象。 解构方法 元组的解构方法与列表使用相同。 使用方法参照列表的解构方法一节。 常用方法 方法一览 常用的tuple方法一览表： 方法名 返回值 描述 count() integer 返回数据项在T中出现的次数 index() integer 返回第一个数据项在T中出现位置的索引，若值不存在，则抛出ValueError 基础公用函数： 函数名 返回值 描述 len() integer 返回容器中的项目数 enumerate() iterator for index, value of iterable 返回一个可迭代对象，其中以小元组的形式包裹数据项与正向索引的对应关系 reversed() ... 详情参见函数章节 sorted() ... 详情参见函数章节 获取长度 使用len()方法来获取元组的长度。 返回int类型的值。 tpl = (\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\") print(len(tpl)) # 7 Python在对内置的数据类型使用len()方法时，实际上是会直接的从PyVarObject结构体中获取ob_size属性，这是一种非常高效的策略。 PyVarObject是表示内存中长度可变的内置对象的C语言结构体。 直接读取这个值比调用一个方法要快很多。 统计次数 使用count()方法统计数据项在该元组中出现的次数。 返回int： tpl = (\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\", \"A\") aInTupCount = tpl.count(\"A\") print(aInTupCount) # 2 查找位置 使用index()方法找到数据项在当前元组中首次出现的位置索引值，如数据项不存在则抛出异常。 返回int。 tpl = (\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\", \"A\") aInTupIndex = tpl.index(\"A\") print(aInTupIndex) # 0 底层探究 内存开辟 Python内部实现中，列表和元组还是有一定的差别的。 元组在创建对象申请内存的时候，内存空间大小便进行了固定，后续不可更改（如果是传入了一个可迭代对象，例如tupe(range(100))，这种情况会进行扩容与缩容，下面的章节将进行详细研究）。 而列表在创建对象申请内存的时候，内存空间大小不是固定的，如果后续对其新增或删除数据项，列表会进行扩容或者缩容机制。 元组创建 空元组 若创建一个空元组，会直接进行创建，然后将这个空元组丢到缓存free_list中。 元组的free_list最多能缓存 20 * 2000 个元组，这个在下面会进行讲解。 如图所示： 元组转元组 下面的代码会进行元组转元组： tup = tuple((1, 2, 3)) 首先内部的参数本身就是一个元组（1， 2， 3），所以会直接将内部的这个元组拿出来并返回引用，并不会再次创建。 代码验证： >>> oldTpl = (1, 2, 3) >>> id(oldTpl) 4384908128 >>> newTpl = tuple(oldTpl) >>> id(newTpl) 4384908128 >>> 列表转元组 列表转元组会将列表中的每一个数据项都拿出来，然后放入至元组中： tpl = tuple([1, 2, 3]) 所以你会发现，列表和元组中的数据项引用都是相同的： >>> lst = [\"A\", \"B\", \"C\"] >>> tpl = tuple(lst) >>> print(id(lst[0])) 4383760656 >>> print(id(tpl[0])) 4383760656 >>> 可迭代对象转元组 可迭代对象是没有长度这一概念的，如果是可迭代对象转换为元组，会先对可迭代对象的长度做一个猜想。 并且根据这个猜想，为元组开辟一片内存空间，用于存放可迭代对象的数据项。 然后内部会获取可迭代对象的迭代器，对其进行遍历操作，拿出数据项后放至元组中。 如果猜想的长度太小，会导致元组内部的内存不够存放下所有的迭代器数据项，此时该元组会进行内部的扩容机制，直至可迭代对象中的数据项全部被添加至元组中。 rangeObject = range(1, 101) tpl = tuple(rangeObject) // 假如猜想的是9 // 第一步：+ 10 // 第二步：+ (原长度+10) * 0.25 // 其实，就是增加【原长度*0.25 + 2.5】 // 即第一次新增4个槽位 如果猜想的长度太大，而实际上迭代器中的数据量偏少，则需要对该元组进行缩容。 切片取值 对元组进行切片取值的时候，会开辟一个新元组用于存放切片后得到的数据项。 tpl = (1, 2, 3) newSliceTpl = tpl[0:2] 当然，如果是[:]的操作，则参照绝对引用，直接返回被切片的元组引用。 代码验证： >>> id(tpl) 4384908416 >>> newSliceTpl = tpl[0:2] >>> id(newSliceTpl) 4384904392 缓存机制 free_list缓存 元组的缓存机制和列表的缓存机制不同。 元组的free_list会缓存0 - 19长度的共20种元组，其中每一种长度的元组通过单向链表横向扩展缓存至2000个，如下图所示： 当每一次del操作有数据项的元组时，都会将该元组数据项清空并挂载至free_list单向链表的头部的位置。 del (1, 2, 3) --> (None, None, None) \\ del (4, 5, 6) --> (None, None, None) -> free_list 长度3的元组 ... del (7, 8, 9) --> (None, None, None) / 如下图所示： 当要创建一个元组时，会通过创建元组的长度，从free_list单向链表的头部取出一个元组，然后将数据项存放进去。 前提是free_list单向链表中缓存的有该长度的元组。 tup = (1, 2, 3) # 长度为3，从free_list的长度为3的元组中取 空元组与非空元组的缓存 空元组的缓存是一经创建就缓存到free_list单向链表中。 而非空元组的缓存必须是del操作后才缓存到free_list单向链表中。 空元组的创建 第一次创建空元组后，空元组会缓存至free_list单向链表中。 以后的每一次空元组创建，返回的其实都是同一个引用，也就是说空元组在free_list单向链表中即使被引用了也不会被销毁。 >>> t1 = () >>> id(t1) 4511088712 >>> t2 = () >>> id(t2) 4511088712 非空元组的创建 创建非空元组时，先检查free_list，当free_list单向链表中有相同长度的元组时，会进行引用并删除。 这个在上图中已经示例过了，就是这个： 代码示例： $ python3 Python 3.6.8 (v3.6.8:3c6b436a57, Dec 24 2018, 02:04:31) [GCC 4.2.1 Compatible Apple LLVM 6.0 (clang-600.0.57)] on darwin Type \"help\", \"copyright\", \"credits\" or \"license\" for more information. >>> v1 = (None, None, None) >>> id(v1) 4384907696 >>> v2 = (None, None, None) >>> id(v2) 4384908056 >>> del v1 >>> del v2 # ❶ >>> v3 = (None, None, None) >>> id(v3) # ❷ 4384908056 >>> v4 = (None, None, None) >>> id(v4) # ❸ 4384907696 >>> ❶：free_list num_free=3 单向链表结构：v2 —> v1 ❷：创建了v3，拿出v2的空元组，填入v3数据项，故v2和v3的id值相等，证明引用同一个元组，此时free_list num_free=3 单向链表结构为：—> v1 ❸：创建了v4，拿出v1的空元组，填入v4数据项，故v1和v4的id值相等，证明引用同一个元组 tupleobject.c源码 官网参考：点我跳转 源码一览：点我跳转 以下是截取了一些关键性源代码，并且做上了中文注释，方便查阅。 每一个元组都有几个关键性的属性： Py_ssize_t ob_refcnt; // 引用计数器 Py_ssize_t ob_size; // 数据项个数，即元组大小 PyObject *ob_item[1]; // 存储元组中的数据项 [指针, ] 关于缓存free_list的属性： PyTuple_MAXSAVESIZE // 相当于图中的 free_num ，最大20，即纵向扩展的缓存元组长度 PyTuple_MAXFREELIST // 图中 free_list 的横向扩展缓存列表个数，最大2000 创建元组 空元组 PyObject * PyTuple_New(Py_ssize_t size) { PyTupleObject *op; // 缓存相关 Py_ssize_t i; // 元组的大小不能小于0 if (size 0 // 创建空元组，优先从缓存中获取 // size = 0 表示这是一个空元组，从free_list[0]中获取空元组 if (size == 0 && free_list[0]) { // op就是空元组 op = free_list[0]; // 新增空元组引用计数器 + 1 Py_INCREF(op); #ifdef COUNT_ALLOCS tuple_zero_allocs++; #endif // 返回空元组的指针 return (PyObject *) op; } // 如果创建的不是空元组，且这个创建的元组数据项个数小于20，并且free_list[size]不等于空，表示有缓存 // 则从缓存中去获取，不再重新开辟内存 if (size ob_item[0]; // num_free减1 numfree[size]--; #ifdef COUNT_ALLOCS fast_tuple_allocs++; #endif /* Inline PyObject_InitVar */ // 初始化，定义这个元组的长度为数据项个数 #ifdef Py_TRACE_REFS Py_SIZE(op) = size; // 定义类型为 tuple Py_TYPE(op) = &PyTuple_Type; #endif // 增加一次新的引用 _Py_NewReference((PyObject *)op); } // 如果是空元组 else #endif { // 检查内存情况，是否充足 /* Check for overflow */ if ((size_t)size > ((size_t)PY_SSIZE_T_MAX - sizeof(PyTupleObject) - sizeof(PyObject *)) / sizeof(PyObject *)) { return PyErr_NoMemory(); } // 开辟内存，并获得一个元组：op op = PyObject_GC_NewVar(PyTupleObject, &PyTuple_Type, size); if (op == NULL) return NULL; } // 空元组的每一个槽位都是NULL for (i=0; i ob_item[i] = NULL; #if PyTuple_MAXSAVESIZE > 0 // 缓存空元组 if (size == 0) { free_list[0] = op; ++numfree[0]; Py_INCREF(op); /* extra INCREF so that this is never freed */ } #endif #ifdef SHOW_TRACK_COUNT count_tracked++; #endif // 将元组加入到GC机制中，用于内存管理 _PyObject_GC_TRACK(op); return (PyObject *) op; } 可迭代对象转元组 这个不在tupleobject.c源码中，而是在abstract.c源码中。 官网参考：点我跳转 源码一览：点我跳转 PyObject * PySequence_Tuple(PyObject *v) { PyObject *it; /* iter(v) */ Py_ssize_t n; /* guess for result tuple size */ PyObject *result = NULL; Py_ssize_t j; if (v == NULL) { return null_error(); } /* Special-case the common tuple and list cases, for efficiency. */ // 如果是元组转换元组，如 tup = (1, 2, 3) 或者 tup = ((1, 2, 3))直接返回内存地址 if (PyTuple_CheckExact(v)) { Py_INCREF(v); return v; } // 如果是列表转换元组，则执行PyList_AsTuple()，将列表转换为元组 // 如 tup = ([1, 2, 3]) if (PyList_CheckExact(v)) return PyList_AsTuple(v); /* Get iterator. */ // 获取迭代器， tup = (range(1, 4).__iter__()) it = PyObject_GetIter(v); if (it == NULL) return NULL; /* Guess result size and allocate space. */ // 猜想迭代器长度，也就是猜一下有多少个数据项 n = PyObject_LengthHint(v, 10); if (n == -1) goto Fail; // 根据猜想的迭代器长度，进行元组的内存开辟 result = PyTuple_New(n); if (result == NULL) goto Fail; /* Fill the tuple. */ // 将迭代器中每个数据项添加至元组中 for (j = 0; ; ++j) { PyObject *item = PyIter_Next(it); if (item == NULL) { if (PyErr_Occurred()) goto Fail; break; } //如果迭代器中数据项比猜想的多，则证明开辟内存不足需要需要进行扩容 if (j >= n) { size_t newn = (size_t)n; /* The over-allocation strategy can grow a bit faster than for lists because unlike lists the over-allocation isn't permanent -- we reclaim the excess before the end of this routine. So, grow by ten and then add 25%. */ // 假如猜想的是9 // 第一步：+ 10 // 第二步：+ (原长度+10) * 0.25 // 其实，就是增加【原长度*0.25 + 2.5】 newn += 10u; newn += newn >> 2; // 判断是否超过了元组的数据项个数限制（sys.maxsize） if (newn > PY_SSIZE_T_MAX) { /* Check for overflow */ PyErr_NoMemory(); Py_DECREF(item); goto Fail; } n = (Py_ssize_t)newn; // 扩容机制 if (_PyTuple_Resize(&result, n) != 0) { Py_DECREF(item); goto Fail; } } // 将数据项放入元组之中 PyTuple_SET_ITEM(result, j, item); } /* Cut tuple back if guess was too large. */ // 如果猜想的数据项太多，而实际上迭代器中的数据量偏少 // 则需要对该元组进行缩容 if (j 列表转元组 这个不在tupleobject.c源码中，而是在listobject.c源码中。 官网参考：点我跳转 源码一览：点我跳转 PyObject * PyList_AsTuple(PyObject *v) { PyObject *w; PyObject **p, **q; Py_ssize_t n; // 例如：tup = ([1, 2, 3]) // 进行列表的验证 if (v == NULL || !PyList_Check(v)) { PyErr_BadInternalCall(); return NULL; } // 获取大小，即数据项个数 n = Py_SIZE(v); // 开辟内存 w = PyTuple_New(n); // 如果是空元组 if (w == NULL) return NULL; // 执行迁徙操作 p = ((PyTupleObject *)w)->ob_item; q = ((PyListObject *)v)->ob_item; // 将列表中数据项的引用，也给元组进行引用 // 这样列表中数据项和元组中的数据项都引用同1个对象 while (--n >= 0) { // 数据项引用计数 + 1 Py_INCREF(*q); *p = *q; p++; q++; } // 返回元组 return w; } 切片取值 PyObject * PyTuple_GetSlice(PyObject *op, Py_ssize_t i, Py_ssize_t j) // 切片会触发该方法 { // 如果对空元组进行切片，则会抛出异常 if (op == NULL || !PyTuple_Check(op)) { PyErr_BadInternalCall(); return NULL; } // 内部的具体实现方法 return tupleslice((PyTupleObject *)op, i, j); } static PyObject * tupleslice(PyTupleObject *a, Py_ssize_t ilow, Py_ssize_t ihigh) { PyTupleObject *np; PyObject **src, **dest; Py_ssize_t i; Py_ssize_t len; // 计算索引位置 if (ilow Py_SIZE(a)) ihigh = Py_SIZE(a); if (ihigh ob_item + ilow; dest = np->ob_item; // 对源元组中的数据项的引用计数+1 for (i = 0; i 缓存相关 static void tupledealloc(PyTupleObject *op) { Py_ssize_t i; Py_ssize_t len = Py_SIZE(op); PyObject_GC_UnTrack(op); Py_TRASHCAN_SAFE_BEGIN(op) // 如果元组的长度大于0，则不是一个非空元组 if (len > 0) { i = len; // 将内部的数据项引用计数都 - 1 while (--i >= 0) Py_XDECREF(op->ob_item[i]); #if PyTuple_MAXSAVESIZE > 0 // 准备缓存，判断num_free是否小于20，并且单向链表中的已缓存元组个数小于2000 if (len ob_item[0] = (PyObject *) free_list[len]; // 将num_free + 1 numfree[len]++; free_list[len] = op; goto done; /* return */ } #endif } // 内存中进行销毁 Py_TYPE(op)->tp_free((PyObject *)op); done: Py_TRASHCAN_SAFE_END(op) } Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-13 20:41:50 "},"Python/Python基础知识/字符串类型.html":{"url":"Python/Python基础知识/字符串类型.html","title":"字符串类型","keywords":"","body":"字符串 字符串（str）一般是指Unicode字符串，见名知意，字符串是由多个字符所构成的一个串。 它是Python中最常用的数据类型之一，因此十分重要。 字符串有一个最显著的特征，即不可变，也就是说你无法使用索引来改变字符串中的字符，仅限于获取。 字符串特性 字符串特性如下： 字符串属于线性扁平序列 字符串是不可变的，即对象本身的属性不会根据外部变化而变化 字符串底层是一段连续的内存空间 基本声明 以下是使用类实例化的形式进行对象声明： string = str(\"ABCDEFG\") print(\"value : %r\\ntype : %r\" % (string, type(string))) # value : 'ABCDEFG' # type : 也可以选择使用更方便的字面量形式进行对象声明，使用英文状态下的单引号、双引号、三单引号、三双引号将数据项进行包裹即可： string = \"ABCDEFG\" print(\"value : %r\\ntype : %r\" % (string, type(string))) # value : 'ABCDEFG' # type : 个人并不推荐常规的使用三单引号或三双引号进行字符串定义，因为除了字符串定义外它们还具有文档注释的功能。 续行操作 在Python中，如果一个字符串过长，可能会导致不符合PEP8规范的情况出现。 每行最大的字符数不可超过79，文档字符或者注释每行不可超过72 如果要定义这样的长字符串，推荐使用三单引号或者三双引号进行定义，这样即可进行换行（但会保留特殊字符，如\\n）: string = \"\"\" 江雪 柳宗元 千山鸟飞绝 万径人踪灭 孤舟蓑笠翁 独钓寒江雪 \"\"\" print(\"value : %r\\ntype : %r\" % (string, type(string))) # value : '\\n 江雪\\n 柳宗元\\n千山鸟飞绝\\n万径人踪灭\\n孤舟蓑笠翁\\n独钓寒江雪\\n' # type : 类型转换 字符串支持与布尔型、整形、以及浮点型进行转换，这是最常用的操作： string = \"100\" iStr = int(string) bStr = bool(string) fStr = float(string) print(\"value : %r\\ntype : %r\" % (iStr, type(iStr))) print(\"value : %r\\ntype : %r\" % (bStr, type(bStr))) print(\"value : %r\\ntype : %r\" % (fStr, type(fStr))) # value : 100 # type : # value : True # type : # value : 100.0 # type : 需要注意的是，如果一个字符串不是纯数字，那么将其转换为整形或浮点型时将会出现异常： string = \"Non-digital string: 100\" iStr = int(string) fStr = float(string) print(\"value : %r\\ntype : %r\" % (iStr, type(iStr))) print(\"value : %r\\ntype : %r\" % (fStr, type(fStr))) # ValueError: invalid literal for int() with base 10: 'Non-digital string: 100' 此外，字符串也支持转换为列表以及集合： string = \"①〇②④\" setStr = set(string) listStr = list(string) print(\"value : %r\\ntype : %r\" % (setStr, type(setStr))) print(\"value : %r\\ntype : %r\" % (listStr, type(listStr))) # value : {'①', '〇', '②', '④'} # type : # value : ['①', '〇', '②', '④'] # type : 特殊的\\ 在普通的声明字符串中，\\后面一般都会跟上一个特殊字符。 该字符具有特殊的意义，如\\n代表换行，\\t代表制表符等，这种具有特殊意义的\\char组合被称为转义字符。 转义字符 意义 ASCII码值（十进制） \\a 响铃(BEL) 007 \\b 退格(BS) ，将当前位置移到前一列 008 \\f 换页(FF)，将当前位置移到下页开头 012 \\n 换行(LF) ，将当前位置移到下一行开头 010 \\r 回车(CR) ，将当前位置移到本行开头 013 \\t 水平制表(HT) （跳到下一个TAB位置） 009 \\v 垂直制表(VT) 011 \\ 代表一个反斜线字符''' 092 \\' 代表一个单引号（撇号）字符 039 \\\" 代表一个双引号字符 034 ? 代表一个问号 063 \\0 空字符(NUL) 000 \\ddd 1到3位八进制数所代表的任意字符 三位八进制 \\xhh 十六进制所代表的任意字符 十六进制 如果你还是不能理解，那么可看下面这个示例： 我想打印 hello”world，并且我的字符串字面量声明采用 “ 进行包裹。 我们必须进行“的转义，让它变为一个普通字符，而非Python中字符串字面量语法表示符： print(\"hello\\\"world\") # hello\"world r字符串 如果在声明字符串的前面加上字符r，则代表该字符串中不会存在转义字符，所有字符将按照普通的方式进行解读。 r字符串也被称为原始字符串： s1 = r\"\\n\\t\\b\" print(s1) # \\n\\t\\b 字节串 字节串（bytes）是字符串的另一种表现形式。 它记录内存中的原始数据，你可以将它理解为2进制数据。 字节串可用于网络传输、多媒体持久化存储中，它和字符串拥有相同的特性，即不可变。 字节串仅在Python3中出现，Python2中不存在该类型。 基本声明 以下是使用类实例化的形式进行对象声明，必须传入一个字符串及指定该字符串的编码格式，如不传入字符串，则默认生成空的bytes对象： bitStr = bytes(\"ABCDEFG\".encode(\"u8\")) print(\"value : %r\\ntype : %r\" % (bitStr, type(bitStr))) # value : b'ABCDEFG' # type : 也可以选择使用更方便的字面量形式进行对象声明，使用英文状态下的小写b加上单引号、双引号、三单引号、三双引号将数据项进行包裹即可，注意数据项必须位于ASCII码表之内： bitStr = b\"ABCDEFG\" print(\"value : %r\\ntype : %r\" % (bitStr, type(bitStr))) # value : b'ABCDEFG' # type : 个人并不推荐常规的使用三单引号或三双引号进行字节串定义，它们还具有文档注释的功能。 编码解码 一个非ASCII标准字符串要变为字节串，必须通过encode()方法来做指定编码格式。 而一个字节串要想变为非ASCII标准字符串，也必须通过decode()方式做指定解码格式。 s = \"你好，世界，hello，world!\" bitStr = bytes(s.encode(encoding=\"u8\")) print(bitStr) string = str(bitStr.decode(encoding=\"u8\")) print(string) # b'\\xe4\\xbd\\xa0\\xe5\\xa5\\xbd\\xef\\xbc\\x8c\\xe4\\xb8\\x96\\xe7\\x95\\x8c\\xef\\xbc\\x8chello\\xef\\xbc\\x8cworld!' # 你好，世界，hello，world! 如果直接使用str.encode()则自动将str转变为bytes类型。 反之，如果直接使用bytes.decode()时bytes也会自动转为str类型。 因此我们可以省略bytes()和str()在外部的包裹： s = \"你好，世界，hello，world!\" bitStr = s.encode(encoding=\"u8\") print(bitStr) string = bitStr.decode(encoding=\"u8\") print(string) # b'\\xe4\\xbd\\xa0\\xe5\\xa5\\xbd\\xef\\xbc\\x8c\\xe4\\xb8\\x96\\xe7\\x95\\x8c\\xef\\xbc\\x8chello\\xef\\xbc\\x8cworld!' # 你好，世界，hello，world! 四则运算 基本操作 字符串支持与字符串进行加法运算，做到拼接的效果，由于字符串是不可变的，所以会生成一个新的字符串： s1 = \"string1\" s2 = \"string2\" print(s1 + s2) # string1string2 字符串支持与整形进行乘法运算，做到重复打印的效果，由于字符串是不可变的，所以会生成一个新的字符串： s1 = \"*\" print(s1 * 3) # *** “可变”的字符串 str可以使用+=操作，来使原本的字符串与新的字符串进行拼接。 +=是一种常见的操作，所以CPython内部为其做了优化。 一个str在初始化内存的时候，程序会为它留出额外的可扩展空间，因此进行增量操作的时候，并不会涉及复制原有字符串到新位置这类操作，而是在原有字符串位置的后面添加上新的字符串。 基于这个点，我们看一个有趣的问题： >>> a 'hello world !' >>> id(a) 140521043795728 >>> a+=\"d\" >>> id(a) 140521043795728 >>> a+=\"d\" >>> id(a) 140521043795728 >>> a 'hello world !dd' 乍看之下其实会发现字符串的+=操作并不会开辟额外的内存空间，但是事实并非如此。 CPython的字符串在底层依旧是不可变的，当这个字符串被+=新的字符串时，会产生一个新的字符串，恰好该字符串会复用之前字符串的id()值。 这个问题在stackoverflow上已经有人问过了，这里贴出原贴： 点我跳转 字符间隙 看一个有趣的例子： s1 = \"HELLO\" boolRET = \"\" in s1 print(boolRET) # True 下一个例子，使用count()方法计算该字符串中空白字符的数量： s1 = \"HELLO\" print(s1.count(\"\")) # 6 小问号你是否充满了很多朋友？ 实际上，Python内部进行str存储的时候会为每个字符之间留一个空隙，如下所示： 所以才会造成上述情况的发生。 intern机制 intern机制是Python解释器为了节省内存而做出的一种策略。 当第一次创建一个短字符串的时候，都会用一个全局的字典将该字符串进行存储，而短字符串的定义如下： 长度不超过20 不含空格 当再次创建这个短字符串，会先查看全局字典中是否存在该短字符串，如果存在则不创建而是直接进行引用。 这种策略也被称之为短字符串驻留机制。 下面这个示例字符串是符合短字符串的，因此会进行驻留： >>> s1 = \"Python\" >>> s2 = \"Python\" >>> s1 is s2 True 由于字符串中含有空格，故该字符串不会触发驻留机制： >>> s1 = \"Pytho n\" >>> s2 = \"Pytho n\" >>> s1 is s2 False 字符串长度超过20，也不会触发驻留机制： >>> s1 = \"Python\" * 10 >>> s2 = \"Python\" * 10 >>> s1 is s2 False 如果是空字符串，也会有驻留机制： >>> s1 = \"\" >>> s2 = \"\" >>> id(s1) 4360137392 >>> id(s2) 4360137392 绝对引用 字符串拥有绝对引用的特性，则无论是深拷贝还是浅拷贝，都不会获得其副本，而是直接对源对象进行引用： >>> import copy >>> oldStr = \"0\" * 100 >>> id(oldStr) 4373971144 >>> s1 = copy.copy(oldStr) >>> id(s1) 4373971144 >>> s2 = copy.deepcopy(oldStr) >>> id(s2) 4373971144 索引切片 字符串由于是线性结构，故支持索引和切片操作。 由于字符串是不可变类型，所以索引操作也仅支持获取数据项，不支持删改数据项。 使用方法参照列表的索引切片一节。 常用方法 方法一览 常用的str方法一览： 方法名 返回值 描述 strip() str 移除字符串两侧指定的字符，如不进行指定，则默认移除\\n、\\t以及空格。 split() list 按照指定字符进行从左到右的分割，以列表形式返回。可指定maxslipt限制切分次数 rsplit() list 按照指定字符进行从右到左的分割，以列表形式返回。可指定maxslipt限制切分次数 join() str 将一个列表中的数据项以指定字符拼接成新的字符串 replace() str 将字符串中的指定子串替换成另一个子串 count() integer 统计子串在父串中出现的次数 title() str 令字符串中的每一个单词首字母大写 capitalize() Str 令字符串中的句首单词首字母变为大写 find() integer 查找子串首次出现在父串中的索引值，若存在则返回索引，若不存在则返回-1，从左至右查找 rfind() integer 同上，从右至左查找 upper() str 令字符串中所有的小写字母转换为大写 lower() str 令字符串中所有的大写字母转换为小写 startswith() bool 判断字符串是否以特定子串开头 endswith() bool 判断字符串是否以特定子串结束 isdigit() bool 判断该字符串是否是一个数字串 基础公用函数： 函数名 返回值 描述 len() integer 返回容器中的项目数 enumerate() iterator for index, value of iterable 返回一个可迭代对象，其中以小元组的形式包裹数据项与正向索引的对应关系 reversed() ... 详情参见函数章节 sorted() ... 详情参见函数章节 获取长度 使用len()方法来进行字符串长度的获取。 返回int类型的值。 s1 = \"abcdefg\" print(len(s1)) # 7 Python在对内置的数据类型使用len()方法时，实际上是会直接的从PyVarObject结构体中获取ob_size属性，这是一种非常高效的策略。 PyVarObject是表示内存中长度可变的内置对象的C语言结构体。 直接读取这个值比调用一个方法要快很多。 移除空白 使用strip()方法移除字符串两侧指定的字符，如不进行指定，则默认移除\\n、\\t以及空格。 返回str类型的值。 s1 = \" abcdefg $$$\" res = s1.strip(\" $\") print(res) # abcdefg 拆分列表 使用split()方法按照指定字符进行从左到右的分割，以列表形式返回。可指定maxslipt限制切分次数。 返回list类型的值。 s1 = \"ab,cd,ef,gh\" res = s1.split(\",\",maxsplit=1) print(res) # ['ab', 'cd,ef,gh'] 使用rsplit()方法按照指定字符进行从右到左的分割，以列表形式返回。可指定maxslipt限制切分次数。 返回list类型的值。 s1 = \"ab,cd,ef,gh\" res = s1.rsplit(\",\",maxsplit=1) print(res) # ['ab,cd,ef', 'gh'] 列表合并 使用join()方法将一个列表中的数据项以指定字符拼接成新的字符串。 返回str类型的值。 l1 = [\"a\",\"b\",\"c\"] res = \"-\".join(l1) print(res) # a-b-c 替换操作 使用replace()方法将字符串中的指定子串替换成另一个子串。 返回str类型的值。 s1 = \"ABCDEFG\" res = s1.replace(\"BCD\",\"bcd\") print(res) # AbcdEFG 次数统计 使用count()方法统计子串在父串中出现的次数。 返回int类型的值。 s1 = \"HELLO\" res = s1.count(\"L\") print(res) # 2 词首大写 使用title()方法令字符串中的每一个单词首字母大写。 返回str类型的值。 s1 = \"hello world\" res = s1.title() print(res) # Hello World 句首大写 使用capitalize()方法令字符串中的句首单词变为大写。 返回str类型的值。 s1 = \"hello world\" res = s1.capitalize() print(res) # Hello world 索引位置 使用find()方法查找子串首次出现在父串中的索引值，若存在则返回索引，若不存在则返回-1，这是从左至右查找，rfind()则是从右至左查找。 返回int类型的值。 s1 = \"hello world\" res = s1.find(\"w\") print(res) # 6 小写转大写 使用upper()方法令字符串中所有的小写字母转换为大写。 返回str类型的值。 s1 = \"hello world\" res = s1.upper() print(res) # HELLO WORLD 大写转小写 使用lower()方法令字符串中所有的大写字母转换为小写。 返回str类型的值。 s1 = \"HELLO WORLD\" res = s1.lower() print(res) # hello world 指定开头 使用startswith()方法判断字符串是否以特定子串开头。 返回bool类型的值。 s1 = \"HELLO WORLD\" res = s1.startswith(\"HE\") print(res) # True 指定结尾 使用endswith()方法判断字符串是否以特定子串结束。 返回bool类型的值。 s1 = \"HELLO WORLD\" res = s1.endswith(\"LD\") print(res) # False 数字串 使用isdigit()方法判断该字符串是否是一个数字串。 返回bool类型的值。 s1 = \"100\" res = s1.isdigit() print(res) # True 其他方法 以下是一些其他不太常用的方法： 方法名 返回值 描述 index() integer 同find()，唯一区别找不到抛出异常，find()是返回-1，从左至右查找 rindex() integer 同上，从右至左查找 swapcase() str 字符串中大小进行翻转。大写转小写，小写转大写。 expandtabs() str 指定字符串中的tab长度，\\t代表制表符，默认长度为8 center() str 指定宽度，指定字符。若字符串的长度不够则将字符串放在中间，两侧使用指定字符填充 ljust() str 指定宽度，指定字符。若字符串的长度不够则将字符串放在左边，右侧使用指定字符填充 rjust() str 指定宽度，指定字符。若字符串的长度不够则将字符串放在右边，左侧使用指定字符填充 zfill() str 同rjust()，但是不可指定填充字符。按0进行填充 isdecimal() bool 判断字符串是否由数字组成。只支持unicode并且没有bytes的使用 isnumeric() bool 判断字符串是否由数字组成。只支持unicode，中文数字，罗马数字并且没有bytes的使用 isalnum() bool 判断字符串是否仅由数字和字母构成 isalpha() bool 判断字符串是否仅由字母构成 isspace() bool 判断字符串是否仅由空格构成 islower() bool 判断字符串是否纯小写 isupper() bool 判断字符串是否纯大写 istitle() bool 判断字符串中的单词是否首字母大写 index()与rindex()方法： s1 = \"Python\" s1.index(\"a\") s1.rindex(\"a\") # ValueError: substring not found 字符串翻转swapcase()方法： s1 = \"Python\" print(s1.swapcase()) # pYTHON 指定制表符长度的expandtabs()方法，默认制表符的长度为8，下面指定为4： s1 = \"P\\ty\\tt\\th\\to\\tn\" print(s1) print(s1.expandtabs(4)) # P y t h o n # P y t h o n 字符填充系列： s2 = \"H\" print(s2.center(20, \"+\")) print(s2.ljust(20, '+')) print(s2.rjust(20, '+')) print(s2.zfill(20)) # 0 填充，不可指定填充字符 # 其实总体来说就是将一个字符必须按照指定字符扩展为指定长度 # 区别在于源字符串的位置在指定填充符的中间、左侧、还是右侧 # +++++++++H++++++++++ # H+++++++++++++++++++ # +++++++++++++++++++H # 0000000000000000000H 字符串判断系列之数字串检测： s1 = b\"4\" # 字节数字串 s2 = u\"4\" # unicode数字串，默认Python3的str就是unicode编码，可以不用加u s3 = \"四\" # 中文数字串 s4 = \"Ⅳ\" # 罗马数字串 # isdigt()检测是否为数字串，只支持bytes和unicode print(s1.isdigit()) # True print(s2.isdigit()) # True print(s3.isdigit()) # False print(s4.isdigit()) # False # isdecimal()检测是否为数字串，只支持unicode字符串，如果是bytes字节串则抛出异常 print(s2.isdecimal()) # True print(s3.isdecimal()) # False print(s4.isdecimal()) # False # isnumeric()检测是否为数字串，不支持bytes字节串，支持unicode字符串、中文数字串、罗马数字串 print(s2.isnumeric()) # True print(s3.isnumeric()) # True print(s4.isnumeric()) # True 字符串判断之成员检测： s1 = \"Python3.6.8\" # isalnum() 判断字符串是否仅由数字和字母构成 print(s1.isalnum()) # False # isalpha() 判断字符串是否仅由字母构成 print(s1.isalpha()) # False # isspace() 判断字符串是否仅由空格构成 print(s1.isspace()) # False 字符串判断之大小写检测： s1 = \"Python3.6.8\" # islower() 判断字符串是否纯小写 print(s1.islower()) # False # isupper() 判断字符串是否纯大写 print(s1.isupper()) # False # istitle() 判断字符串中的单词是否首字母大写 print(s1.istitle()) # True 版本区别 数字与字符串对比 在Python2中是支持字符串与数字进行比较的，字符串永远比数字大： >>> \"0\" > 1 True 但是在Python3中，这种比较会抛出异常： >>> \"0\" > 1 Traceback (most recent call last): File \"\", line 1, in TypeError: '>' not supported between instances of 'str' and 'int' 表现形式 Python2的字符串表现形式为原始字节序列，也就是说Python2的str其实实际上是Python3的字节串，故仅支持在ASCII码表之内的字符： >>> s1 = \"你好，世界\" >>> s1 '\\xe4\\xbd\\xa0\\xe5\\xa5\\xbd\\xef\\xbc\\x8c\\xe4\\xb8\\x96\\xe7\\x95\\x8c' 但是在Python3中的字符串表现形式不是这样的，Python3中的字符串统一都为Unicode字符串： >>> s1 = \"你好，世界\" >>> s1 '你好，世界' 底层探究 扁平序列 这里引出一个新的概念，线性扁平序列。 扁平序列其实更加紧凑，但是它里面只能存放诸如字符、字节和数值这种基础类型 扁平序列里存放的是值而不是引用 扁平序列不支持多维的说法，仅有一个维度 字符串为什么要设计成不可变类型？这是由于字符串内部是采用连续存储的方式。 因为字符串是连续的一块内存存放（在c语言体现中其实是一个数组，以\\0结尾），被看做为一个整体，修改其中某一个数据项那么必定会导致后面的内存发生变化，链式反应滚起雪球需要处理的数据量很庞大，于是Python干脆不支持修改字符串。 strobject.c源码 官网参考：点我跳转 源码一览：点我跳转 关于字符串的源码阅读，感兴趣的朋友可以看一下，这里不再进行延伸阅读。 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-13 20:41:50 "},"Python/Python基础知识/字典类型.html":{"url":"Python/Python基础知识/字典类型.html","title":"字典类型","keywords":"","body":"字典 Python中的字典（dict）也被称为映射（mapping）或者散列（hash），是支持Python底层实现的重要数据结构。 同时，它也是应用最为广泛的数据结构，内部采用hash存储，存储方式为键值对。 字典本身属于可变容器类型，但键（key）必须为不可变类型，而值（value）可以是任意类型。。 字典的优点是单点查找速度极快，但不能够支持范围查找，此外也比较占用内存。 字典特性 字典特性如下： 字典是一个可变的容器类型 字典内部由散列表组成 字典的单点读写速度很快，但是不支持范围查找 字典的key必须是不可变的，只有不可变对象才能被hash 字典在3.6之后变得有序了，这样做提升了遍历效率 基本声明 以下是使用类实例化的形式进行对象声明： userInfo = dict(name=\"YunYa\", age=18, hobby=[\"football, music\"]) print(\"value : %r\\ntype : %r\" % (userInfo, type(userInfo))) # value : {'name': 'YunYa', 'age': 18, 'hobby': ['football, music']} # type : 也可以选择使用更方便的字面量形式进行对象声明，使用{}对键值对进行包裹，键值对采用k:v的形式分割，多个键值对之间使用逗号进行分割： userInfo = {\"name\": \"YunYa\", \"age\": 18, \"hobby\": [\"football, music\"]} print(\"value : %r\\ntype : %r\" % (userInfo, type(userInfo))) # value : {'name': 'YunYa', 'age': 18, 'hobby': ['football, music']} # type : 声明字典时，千万注意key只能是不可变类型。 如字符串（str），整形（int），浮点型（float），布尔型（bool），元组类型（tuple）等等均可设置为字典的key，但使用可变类型作为key时则会抛出异常。 续行操作 在Python中，字典中的键值对如果过多，可能会导致整个字典太长，太长的字典是不符合PEP8规范的。 每行最大的字符数不可超过79，文档字符或者注释每行不可超过72 Python虽然提供了续行符\\，但是在字典中可以忽略续行符，如下所示： userInfo = { \"name\": \"YunYa\", \"age\": 18, \"hobby\": [\"football, music\"]} print(\"value : %r\\ntype : %r\" % (userInfo, type(userInfo))) # value : {'name': 'YunYa', 'age': 18, 'hobby': ['football, music']} # type : 多维嵌套 字典中可以进行多维嵌套，如字典套字典，字典套元组，字典套列表等： dic = { \"k1\": [1, 2, 3], \"k2\": (1, 2, 3), \"k3\": { \"k3-1\": 1, \"k3-2\": 2, }, } 类型转换 字典可以与布尔类型和字符串进行转换，这是最常用的： dic = {\"k1\": \"v1\", \"k2\": \"v2\"} boolDict = bool(dic) strDict = str(dic) print(\"value : %r\\ntype : %r\" % (boolDict, type(boolDict))) print(\"value : %r\\ntype : %r\" % (strDict, type(strDict))) # value : True # type : # value : \"{'k1': 'v1', 'k2': 'v2'}\" # type : 如果要将字典转换为列表、元组、集合类型，直接转换只会拿到键，并不会拿到值。 尤其注意这一点，但是其实这样用的场景十分少见，记住就行了： dic = {\"k1\": \"v1\", \"k2\": \"v2\"} listDict = list(dic) tupleDict = tuple(dic) setDict = set(dic) print(\"value : %r\\ntype : %r\" % (listDict, type(listDict))) print(\"value : %r\\ntype : %r\" % (tupleDict, type(tupleDict))) print(\"value : %r\\ntype : %r\" % (setDict, type(setDict))) # value : ['k1', 'k2'] # type : # value : ('k1', 'k2') # type : # value : {'k1', 'k2'} # type : 重复key 一个字典中的key必须是唯一的，若不是唯一的则value可能面临被覆盖的危险： dic = {\"name\": \"云崖\", \"age\": 18, \"name\": \"Yunya\"} print(dic) # {'name': 'Yunya', 'age': 18} 同理，True和1，False和0也会彼此进行覆盖： dic = {True: \"云崖\", \"age\": 18, 1: \"Yunya\"} print(dic) # {True: 'Yunya', 'age': 18} []操作字典 由于字典并非线性结构，故不支持索引操作。 但是字典也提供了[]操作语法，它是根据key来操作value的。 增删改查 以下示例展示了如何使用[]对字典中的value进行操纵： dic = {\"k1\": \"v1\", \"k2\": \"v2\"} # 增 dic[\"k3\"] = \"v3\" print(dic) # {'k1': 'v1', 'k2': 'v2', 'k3': 'v3'} # 删，如果没有该key，则抛出keyError del dic[\"k2\"] print(dic) # {'k1': 'v1', 'k3': 'v3'} # 改，如果没有该key，则抛出keyError dic[\"k3\"] = \"VV3\" print(dic) # {'k1': 'v1', 'k3': 'VV3'} # 查，如果没有该key，则抛出keyError result = dic[\"k1\"] print(result) # v1 多维操作 字典套列表的多维操作如下，首先需要拿到该列表： dic = {\"k1\": [1, 2, 3, 4]} # 取出3 result = dic[\"k1\"][2] print(result) # 3 # k1的列表，添加数据项 \"A\" dic[\"k1\"].append(\"A\") print(dic) # {'k1': [1, 2, 3, 4, 'A']} 字典套字典的多维操作如下，首先需要拿到被操纵的字典： dic = { \"k1\":{ \"k1-1\":{ \"k1-2\":{ \"k1-3\":\"HELLO,WORLD\", } } } } # 拿到 k1-3 对应的value result = dic[\"k1\"][\"k1-1\"][\"k1-2\"][\"k1-3\"] print(result) # HELLO,WORLD 解构语法 **语法 **语法用于将字典中的k:v全部提取出来。 我们可以利用该语法的特性来对字典进行合并，将两个旧字典合并成一个新字典： dic_1 = {\"d1k1\": \"A\", \"d1k2\": \"B\"} dic_2 = {\"d2k1\": \"C\", \"d2k2\": \"D\"} result = {**dic_1, **dic_2} print(result) # {'d1k1': 'A', 'd1k2': 'B', 'd2k1': 'C', 'd2k2': 'D'} 解构赋值 字典支持平行变量赋值操作吗？当然可以！但是这样只会拿到字典的key： dic = {\"k1\": \"v1\", \"k2\": \"v2\"} first, last = dic print(first) print(last) # k1 # k2 有办法拿到value么？借助字典的values()方法即可做到，它的本质是将value全部提取出来，组成一个可迭代对象： dic = {\"k1\": \"v1\", \"k2\": \"v2\"} first, last = dic.values() print(first) print(last) # v1 # v2 你可以理解为，将value全部提取出来组成一个列表，类似于[“v1”, “v2”]，在Python2中的确是这样，但是到了Python3中做法改变了，目前按下不表。 对于一些不想要的数据项，你也可以按照列表的解构赋值操作来进行，这里不再举例。 常用方法 方法一览 常用的dict方法一览： 方法名 返回值 描述 get() v or None 取字典key对应的value，如果key不存在返回None setdefault() v 获取字典key对应的value，如该字典中不存在被获取的key则会进行新增k:v，并返回v update() None 对原有的字典进行更新 pop() v 删除该字典中的键值对，如果不填入参数key或者key不存在则抛出异常 keys() Iterable 返回一个可迭代对象，该可迭代对象中只存有字典的所有key values() Iterable 返回一个可迭代对象，该可迭代对象中只存有字典的所有value items() Iterable 返回一个可迭代对象，该可迭代对象中存有字典中所有的key与value，类似于列表套元组 clear() None 清空当前字典 基础公用函数： 函数名 返回值 描述 len() integer 返回容器中的项目数 获取长度 使用len()方法来进行字典长度的获取。 返回int类型的值。 dic = {\"name\": \"云崖\", \"age\": 18} print(len(dic)) # 2 一组键值对被视为一个数据项，故2组键值对长度为2 Python在对内置的数据类型使用len()方法时，实际上是会直接的从PyVarObject结构体中获取ob_size属性，这是一种非常高效的策略。 PyVarObject是表示内存中长度可变的内置对象的C语言结构体。 直接读取这个值比调用一个方法要快很多。 get() 使用get()方法获取字典key对应的value，相比于[]操作更加的人性化，因为[]一旦获取不存在的key则会抛出异常，而该方法则是返回None。 dic = {\"name\": \"云崖\", \"age\": 18} username = dic.get(\"name\") userhobby = dic.get(\"hobby\") print(\"用户姓名:\",username) print(\"用户爱好:\",userhobby) # 用户姓名: 云崖 # 用户爱好: None setdefault() 使用setdefault()方法来获取字典key对应的value，如该字典中不存在被获取的key则会进行新增k:v，并返回v。 返回字典原有的value或者新设置的k:v。 dic = {\"name\": \"云崖\", \"age\": 18} # 字典有name，则取字典里的name username = dic.setdefault(\"name\",\"云崖先生\") # 字典没有hobby，则设置hobby的value为足球与篮球并返回 userhobby = dic.setdefault(\"hobby\",\"足球与篮球\") print(\"用户姓名:\",username) print(\"用户爱好:\",userhobby) # 用户姓名: 云崖 # 用户爱好: 足球与篮球 update() 使用update()方法对原有的字典进行更新。 返回None。 dic = {\"name\": \"云崖\", \"age\": 18} dic.update( {\"hobby\": [\"篮球\", \"足球\"]} ) print(dic) # {'name': '云崖', 'age': 18, 'hobby': ['篮球', '足球']} pop() 使用pop()方法删除该字典中的键值对，如果不填入参数key或者key不存在则抛出异常。 返回被删除的value。 dic = {\"name\": \"云崖\", \"age\": 18} result = dic.pop(\"age\") print(result) print(dic) # 18 # {'name': '云崖'} keys() 返回一个可迭代对象，该可迭代对象中只存有字典的所有key。 Python2中返回的是列表，Python3中返回的是可迭代对象。 dic = {\"name\": \"云崖\", \"age\": 18} key_iter = dic.keys() print(key_iter) # dict_keys(['name', 'age']) Python3中返回的对象被称为字典视图。它们提供了字典条目的一个动态视图，这意味着当字典改变时，视图也会相应改变。 values() 返回一个可迭代对象，该可迭代对象中只存有字典的所有value。 Python2中返回的是列表，Python3中返回的是可迭代对象。 dic = {\"name\": \"云崖\", \"age\": 18} value_iter = dic.values() print(value_iter) # dict_values(['云崖', 18]) Python3中返回的对象被称为字典视图。它们提供了字典条目的一个动态视图，这意味着当字典改变时，视图也会相应改变。 items() 返回一个可迭代对象，该可迭代对象中存有字典中所有的key与value，类似于列表套元组。 Python2中返回的是二维列表，Python3中返回的是可迭代对象。 dic = {\"name\": \"云崖\", \"age\": 18} items_iter = dic.items() print(items_iter) # dict_items([('name', '云崖'), ('age', 18)]) Python3中返回的对象被称为字典视图。它们提供了字典条目的一个动态视图，这意味着当字典改变时，视图也会相应改变。 clear() 清空当前字典。 返回None。 dic = {\"name\": \"云崖\", \"age\": 18} dic.clear() print(dic) # {} 其他方法 方法 返回值 描述 popitem() (k, v) 随机删除一组键值对,并将删除的键值放到元组内返回 fromkeys(iter,value) dict 第一个参数是可迭代对象，其中每一个数据项都为新生成字典的key，第二个参数为同一的value值 示例演示： dic1 = dict(k1=\"v1\", k2=\"v2\", k3=\"v3\", k4=\"v4\") print(dic1.popitem()) # ('k4', 'v4') dic2 = dict.fromkeys([1, 2, 3, 4], None) print(dic2) # {1: None, 2: None, 3: None, 4: None} 底层探究 高效查找 为什么要有字典这种数据结构？ 如果对一个无序的列表查找其中某一个value（前提是不能对列表进行排序），必须经过一个一个的遍历，速度会很慢。 [3, 2, 8, 9, 11, 13] # 如果要获取数据项11，必须经过5次查找 有没有一种办法，能够让速度加快？ 为了不违背不能排序的前提，我们只能在列表存入value的时候做文章。 我们可以为每个value都造一个独一无二的身份标识，根据这个身份标识符计算出value需要插入到列表的索引位置。 在取的时候同理，通过身份标识符直接就可以拿到value所在列表的索引值，无疑速度会快很多。 一个小总结： 有一个身份标识，身份标识必须是唯一的 提供一个根据身份标识计算出插入位置的算法 回到字典的本质，字典的key就是value的身份标识，而根据key计算出插入位置的算法被封装在了hash()函数中，这个算法也被称之为hash算法。 为什么key必须是唯一的，参照下面这个示例： [\"k1\", \"k2\", \"k3\", \"k4\", \"k5\", \"k6\"] ↓ ↓ ↓ ↓ ↓ ↓ [ 3, 2, 8, 9, 11, 13] 假如k5变成了k6，那么就有2个k6对应2个不同的value 这么做的后果就是，使用k6获取value的时候，根本不知道你需要的value是哪一个 所以，干脆Python规定，key必须是不可变类型！如果有重复则新的覆盖旧的。 或者说，只有不可变对象才能被hash。 hash过程 如何通过hash()函数，确定value的插入位置？ 实际上每个键值对在存入字典之前，都会通过hash()函数对key计算出一个hash值（也被称为散列值）： >>> hash(\"k1\") 7036545863130266253 而字典的底层结构是由一个2维数组嵌套组成的，也被称为散列表、hash表。 如下所示，每次创建字典的时候，字典都会初始化生成一个固定长度且内容全是空的2维数组，Python内部生成的散列表长度为8（可参见dictobject.c结构体源码）： [ ① ② ③ [空, 空, 空], index: 0 [空, 空, 空], index: 1 [空, 空, 空], index: 2 [空, 空, 空], index: 3 [空, 空, 空], index: 4 [空, 空, 空], index: 5 [空, 空, 空], index: 6 [空, 空, 空] index: 7 ] ❶：存放根据key计算出的hash值 ❷：存放key的引用 ❸：存放value的引用 现在，我们要存储name:yunya的键值对，对name计算hash值： >>> hash(\"name\") 3181345887314224636 用计算出的hash值与散列表长度进行求余运算： >>> 3181345887314224636 % 8 4 得到结果是4，就在散列表4的索引位置插入： [ ① ② ③ [空, 空, 空], index: 0 [空, 空, 空], index: 1 [空, 空, 空], index: 2 [空, 空, 空], index: 3 [3181345887314224636, \"name\"的引用, \"yunya\"], index: 4 [空, 空, 空], index: 5 [空, 空, 空], index: 6 [空, 空, 空] index: 7 ] 再次插入age:18，并用计算出的hash值与散列表长度进行求余运算: >>> hash(\"age\") 7064862892218627464 >>> 7064862892218627464 % 8 0 得到的结果是0，就在散列表0的索引位置插入： [ ① ② ③ [7064862892218627464, \"age\"的引用, 18], index: 0 [空, 空, 空], index: 1 [空, 空, 空], index: 2 [空, 空, 空], index: 3 [3181345887314224636, \"name\"的引用, \"yunya\"], index: 4 [空, 空, 空], index: 5 [空, 空, 空], index: 6 [空, 空, 空] index: 7 ] 可以看见，这个2维数组不是按照顺序进行插入的，总有一些空的位置存在，因此该数组也被称为稀松数组。 由于数组是稀松的，所以dict不支持范围获取（能获取到空值），但单点存取的速度很快。 读取的时候也同理，但是Python的hash函数底层实现是否真的利用hash值对稀松数组长度进行简单的求余运算，这个还有待商榷。 因为hash算法的实现有很多种，长度求余只是最为简单的一种而已，这里用作举例，如果想具体了解其算法可以查看Python源码，dictobject.c中的perturb。 散列冲突 现在，我们的这个散列表中0和4的索引位置都已经存在数据了。 如果现在存入一个teacher:wang，那么结果会是怎么样？ >>> hash(\"teacher\") 4789346189807557228 >>> 4789346189807557228 % 8 4 可以发现，teacher的hash值求余算结果也是4，这个时候就会发生散列冲突。 最常见的做法是，向后挪！因为索引5的位置是空的，我们可以将这个键值对插入到索引5的位置： [ ① ② ③ [7064862892218627464, \"age\"的引用, 18], index: 0 [空, 空, 空], index: 1 [空, 空, 空], index: 2 [空, 空, 空], index: 3 [3181345887314224636, \"name\"的引用, \"yunya\"], index: 4 [4789346189807557228, \"teacher\"的引用, \"wang\"], index: 5 [空, 空, 空], index: 6 [空, 空, 空] index: 7 ] 这种查找空位的方法叫做开放定址法（openaddressing），向后查找也被称为线性探测（linearprobing）。 如果此时又插入一个数据项，最后key的插入索引位置也是4，则继续向后查找空位，如果查找到7还是没有空位，又从0开始找。 上述方法是解决散列冲突的基础方案，当然也还有更多的其他解决方案，这里再说就过头了，放在后面数构一章中再进行介绍吧。 扩容机制 Python的dict会对散列表的容量做出判定。 当容量超过三分之二时，即进行扩容（resize）机制。 如果散列表大小为8，在即将插入第5个键值对时进行扩容，扩容策略为已有散列表键值对个数 * 2。 即散列表大小扩展为18 (5 * 2 + 8)。 如果整个散列表已有键值对个数达到了50000，则扩容策略为已有散列表键值对个数 * 4。 此外，dict只会进行扩容，不会进行缩容，如果删除了1个键值对，其内存空间占用的位置并不会释放。 不同key的优化 整形是其本身 整形的hash值是其本身： >>> hash(1) 1 >>> hash(2) 2 >>> hash(3) 3 >>> hash(10000) 10000 加盐策略 在Python3.3开始，str、bytes、datetime等对象在计算散列值的时候会进行加盐处理。 这个盐引用内部的一个常量，该常量在每次CPython启动时会生成不同的盐值。 所以你会发现每次重启Python3.3以后的解释器，对相同字符串进行hash()求散列值得出的结果总是不一样的： $ python3 Python 3.6.8 (v3.6.8:3c6b436a57, Dec 24 2018, 02:04:31) [GCC 4.2.1 Compatible Apple LLVM 6.0 (clang-600.0.57)] on darwin Type \"help\", \"copyright\", \"credits\" or \"license\" for more information. >>> hash(\"k1\") 8214688532022610754 >>> exit() $ python3 Python 3.6.8 (v3.6.8:3c6b436a57, Dec 24 2018, 02:04:31) [GCC 4.2.1 Compatible Apple LLVM 6.0 (clang-600.0.57)] on darwin Type \"help\", \"copyright\", \"credits\" or \"license\" for more information. >>> hash(\"k1\") -7444020267993088839 >>> exit() 再看Python2.7，由于没有加盐策略，所以每次重启Python解释器后相同key得到的hash结果是相同的： $ python Python 2.7.10 (default, Feb 22 2019, 21:55:15) [GCC 4.2.1 Compatible Apple LLVM 10.0.1 (clang-1001.0.37.14)] on darwin Type \"help\", \"copyright\", \"credits\" or \"license\" for more information. >>> hash(\"k1\") 13696082283123634 >>> exit() $ python Python 2.7.10 (default, Feb 22 2019, 21:55:15) [GCC 4.2.1 Compatible Apple LLVM 10.0.1 (clang-1001.0.37.14)] on darwin Type \"help\", \"copyright\", \"credits\" or \"license\" for more information. >>> hash(\"k1\") 13696082283123634 >>> exit() 有序字典 字典无序的观念似乎已经深入人心，但那已经都是过去式了。 在Python3.6之后，字典变的有序了。 2012年12月10日星期一的时候，R. David Murray向Python官方发送了一封邮件，提出建议让Python的字典变的有序。 这样的做法能够让Python字典的空间占用量更小，迭代速度更快，以下是邮件内容： https://mail.python.org/pipermail/python-dev/2012-December/123028.html 我们先看看2.7中的字典： >>> {chr(i) : i for i in range(10)} {'\\x01': 1, '\\x00': 0, '\\x03': 3, '\\x02': 2, '\\x05': 5, '\\x04': 4, '\\x07': 7, '\\x06': 6, '\\t': 9, '\\x08': 8} 再来看3.6中的字典： >>> {chr(i) : i for i in range(10)} {'\\x00': 0, '\\x01': 1, '\\x02': 2, '\\x03': 3, '\\x04': 4, '\\x05': 5, '\\x06': 6, '\\x07': 7, '\\x08': 8, '\\t': 9} 果然！它确实变的有序了，关于具体细节，可以参照这封邮件，已经表述的很清楚了，下面做一个简单的示例。 首先，以前的散列表就是一个单纯的稀松二维数组： [ [空, 空, 空], index: 0 [空, 空, 空], index: 1 [空, 空, 空], index: 2 ... ] 键值对的读取顺序来源与填加顺序。 索引靠前的会被先遍历拿到，索引靠后只能后被遍历出来。 如果这个散列表长度为8，前7个都没有数据项存入，仅有8才有，那么遍历完整个散列表需要8次： [ [空, 空, 空], index: 0 [空, 空, 空], index: 1 [空, 空, 空], index: 2 ... [hash值, key的引用, value的引用], index: 7 ] 而Python3.6之后，又新增了一个顺序数组，该数组与散列表的长度相等，初始均为8，并且会跟随散列表的扩容而进行扩容，如下示例初始状态： [None, None, None, ...] [ [空, 空, 空], index: 0 [空, 空, 空], index: 1 [空, 空, 空], index: 2 ... ] 如果说第1个键值对，被插入到散列表索引1的位置，那么在顺序数组中，则在索引0处记录下该键值对被插入在散列表中的位置(1)，如下图所示： [1, None, None, ...] [ [空, 空, 空], index: 0 [hash值, key的引用, value的引用], index: 1 [空, 空, 空], index: 2 ... ] 如果第2个键值对，被插入到散列表索引0的位置，那么在顺序数组中，则在索引1处记录下该键值对被插入在散列表中的位置(0)，如下图所示： [1, 0, None, ...] [ [hash值, key的引用, value的引用], index: 0 [hash值, key的引用, value的引用], index: 1 [空, 空, 空], index: 2 ... ] 再插入一个键值对，该键值对被插到了索引7的位置，那么在顺序数组中，则在索引2处记录下该键值对被插入在散列表中的位置(7)，如下图所示： [1, 0, 7, None, None, None, None, None] [ [hash值, key的引用, value的引用], index: 0 [hash值, key的引用, value的引用], index: 1 [空, 空, 空], index: 2 ... [hash值, key的引用, value的引用], index: 7 ] 在遍历的时候，会遍历这个顺序数组，然后通过索引值拿到散列表中对应位置的数据项，如果遍历到的值为None就结束遍历，而不用遍历完整个散列表： 类似于： hashTableOrderArray = [1, 0, 7, None, None, None, None, None] hashTable = [ [\"hash\", \"k2\", \"v2\"], [\"hash\", \"k1\", \"v1\"], [None, None, None], [None, None, None], [None, None, None], [None, None, None], [None, None, None], [\"hash\", \"k3\", \"v3\"], ] n = 0 while n 这样只需遍历3次即可，而如果没有这个顺序数组，则要完整遍历整个散列表，即8次才能拿出所有的键值对。 dictobject.c源码 官网参考：点我跳转 源码一览：点我跳转 关于字典的源码阅读，感兴趣的朋友可以看一下，这里不再进行延伸阅读。 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-15 14:08:42 "},"Python/Python基础知识/集合类型.html":{"url":"Python/Python基础知识/集合类型.html","title":"集合类型","keywords":"","body":"集合 Python中的集合（set）内部存储也采用hash存储，所以说它也可以归类为映射容器类型之中。 集合与字典有很多类似之处，你可以将集合理解为没有value的字典（仅有key）。 集合本身是可变的数据类型，但是其内部数据项必须是不可变的，能被hash()的对象，这与字典的key特性相同。 集合特性 集合特性如下： 集合是一个可变的容器类型 集合中的数据项必须是不可变类型 集合更多的是用来操纵数据，而不是存储数据 嗯，再说一个冷门知识点，集合的速度比字典的存读速度更快！因为它的数据项仅有1部分，而字典的数据项拥有2部分，即key与value。 基本声明 以下是使用类实例化的形式进行对象声明： s = set((1, 2, 3, 4, 5)) print(\"value : %r\\ntype : %r\" % (s, type(s))) # value : {1, 2, 3, 4, 5} # type : 也可以选择使用更方便的字面量形式进行对象声明，使用{}对数据项进行包裹，每个数据项间用逗号进行分割： s = {1, 2, 3, 4, 5} print(\"value : %r\\ntype : %r\" % (s, type(s))) # value : {1, 2, 3, 4, 5} # type : 注意一个集合声明的陷阱，如果要声明一个空集合必须使用类实例的形式进行声明。 如果用一个空的{}进行字面量声明会生成一个字典。 声明集合时，千万注意数据项只能是不可变类型。 如字符串（str），整形（int），浮点型（float），布尔型（bool），元组类型（tuple）等等，使用可变类型作为数据项加入至集合中会抛出TypeError异常。 续行操作 在Python中，集合中的数据项如果过多，可能会导致整个集合太长，太长的集合是不符合PEP8规范的。 每行最大的字符数不可超过79，文档字符或者注释每行不可超过72 Python虽然提供了续行符\\，但是在集合中可以忽略续行符，如下所示： s = { 1, 2, 3, 4, 5 } print(\"value : %r\\ntype : %r\" % (s, type(s))) # value : {1, 2, 3, 4, 5} # type : 类型转换 集合可以和布尔型、列表、元组、字符串类型进行转换： s = {1, 2, 3, 4, 5} boolSet = bool(s) strSet = str(s) listSet = list(s) tupleSet = tuple(s) print(\"value : %r\\ntype : %r\" % (boolSet, type(boolSet))) print(\"value : %r\\ntype : %r\" % (strSet, type(strSet))) print(\"value : %r\\ntype : %r\" % (listSet, type(listSet))) print(\"value : %r\\ntype : %r\" % (tupleSet, type(tupleSet))) # value : True # type : # value : '{1, 2, 3, 4, 5}' # type : # value : [1, 2, 3, 4, 5] # type : # value : (1, 2, 3, 4, 5) # type : 无序特性 Python本身并未对集合新增顺序数组，因此集合不论是Python3还是Python2中都是无序的。 Python2.7.10示例： >>> {chr(i) for i in range(10)} set(['\\x01', '\\x00', '\\x03', '\\x02', '\\x05', '\\x04', '\\x07', '\\x06', '\\t', '\\x08']) Python3.6.8示例： >>> {chr(i) for i in range(10)} {'\\x07', '\\x06', '\\t', '\\x02', '\\x00', '\\x05', '\\x04', '\\x03', '\\x01', '\\x08'} 去重特性 得益于内部hash存储方式，集合具有去处重复的特性，我们可以让其与列表结合，将列表中重复的数据项剔除： repeatList = [1, 1, 2, 2, 3, 4, 5, 1, 2] newList = list(set(repeatList)) print(newList) # [1, 2, 3, 4, 5] 集合中的数据项怎么拿出来 集合虽然是容器类型，但是更多的作用是操作数据项，存储非它所长（存了就不好取了）。 集合没有提供[]语法： 它没有key，无法像字典一样通过key来操作value 也没有index，因为它不是顺序存储的线性结构。 虽然set中没有提供单拿数据项的方法，但是我们可以将其转换为list后再通过index将某个数据项拿出来。 或者是通过遍历。 常用方法 常用的set方法一览，set有一部分方法可以进行符号操作： 方法名 符号表示 返回值 描述 add() 无 None 为集合中新增数据项 pop() 无 Data item 弹出随机数据项 remove() 无 None 删除指定数据项，若不存在则抛出异常 discard() 无 None 同上、但不存在不会抛出异常 clear() 无 None 清空集合 copy() 无 set 对集合进行浅拷贝 update() 无 None 原地更新集合 intersection() & set 求a集合与b集合的交集 difference() - set 求a集合与b集合的差集 union() | set 求a集合与b集合的合集/并集 symmetric_difference() ^ set 求a集合与b集合的对称差集 issuperset() >或者>= bool 判定a集合是否为b集合的父级 issubset() bool 判断a集合是否为b集合的子集 isdisjoint() 无 bool 判断两个集合是否完全独立没有共同部分返回 intersection_update() 无 None 求出a集合与b集合的交集后并更新a集合 difference_update() 无 None 求出a集合与b集合的差集后并更新a集合 基础公用函数： 函数名 返回值 描述 len() integer 返回容器中的项目数 数据管理 示例演示： s1 = set() # 增加数据项 s1.add(1) print(s1) # {1} # 更新数据项 s1.update({2, 3, 4, 5}) print(s1) # {1, 2, 3, 4, 5} # 删除数据项， 不存在则抛出异常 s1.remove(2) print(s1) # {1, 3, 4, 5} # 删除数据项， 即使不存在也不会抛出异常 s1.discard(2) print(s1) # {1, 3, 4, 5} # 随机弹出数据项 print(s1.pop()) # 1 print(s1) # {3, 4, 5} # 浅拷贝 print(s1.copy()) # {3, 4, 5} # 清空数据项 s1.clear() print(s1) # set() 关系图解 集合关系图示： 关系获取 示例演示： s1 = {1, 2, 3, 4, 5} s2 = {4, 5, 6, 7, 8} # 交集 print(s1 & s2) print(set.intersection(s1, s2)) # {4, 5} # 差集 print(s1 - s2) print(set.difference(s1, s2)) # {1, 2, 3} # 合集、并集 print(s1 | s2) print(set.union(s1, s2)) # {1, 2, 3, 4, 5, 6, 7, 8} # 对称差集 print(s1 ^ s2) print(set.symmetric_difference(s1, s2)) # {1, 2, 3, 6, 7, 8} # 父子集 s3 = {1, 2, 3} s4 = {1,2} # 父级 print(s3 > s4) print(s3 >= s4) print(set.issuperset(s3, s4)) # True # 子集 print(s4 不可变的集合 frozenset()创建的集合拥有元组的特性，一旦集合创建完成后将不可以修改。 fs = frozenset((1, 2, 3)) print(fs) # frozenset({1, 2, 3}) 可以与普通的set集合进行关系获取，但是不能够进行数据项管理（可以copy，copy也是绝对引用）。 2.3以前怎么办 Python2.3的set和frozenset首次以模块的形式加入到Python中。 并且在Python2.6之后，提升为内置模块。 在Python2.3以前，我们常用字典来进行与集合相同的操作，因为字典的key也具有去重的特性嘛！ repeatList = [1, 1, 2, 2, 3, 4, 5, 1, 2] newList = list(dict.fromkeys(repeatList, None).keys()) print(newList) # [1, 2, 3, 4, 5] 如果是求交叉并集这种关系，则实现会更加复杂一点，这里不再举例。 dictobject.c源码 官网参考：点我跳转 源码一览：点我跳转 关于集合的源码阅读，感兴趣的朋友可以看一下，这里不再进行延伸阅读。 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-10-17 22:29:52 "},"Python/Python基础知识/布尔类型.html":{"url":"Python/Python基础知识/布尔类型.html","title":"布尔类型","keywords":"","body":"布尔类型 布尔类型的值被称为布尔值，常用于分支流程中，仅有2种表现形式： True：代表条件为真 False：代表条件为假 布尔属于不可变类型，同时也是基础的原子类型，即不可分割，不能容纳其他对象。 基本声明 以下是使用类实例化的形式进行对象声明： term = bool(True) print(\"value : %r\\ntype : %r\" % (term, type(term))) # value : True # type : 也可以选择使用更方便的字面量形式进行对象声明： term = True print(\"value : %r\\ntype : %r\" % (term, type(term))) # value : True # type : 类型转换 布尔值仅能转换为数字、字符串，使用对应的工厂函数即可： termTrue = True termFalse = False iTrue = int(termTrue) iFalse = int(termFalse) fTrue = float(termTrue) fFalse = float(termFalse) sTrue = str(termTrue) sFalse = str(termFalse) print(\"value : %r\\ntype : %r\" % (iTrue, type(iTrue))) print(\"value : %r\\ntype : %r\" % (iFalse, type(iFalse))) print(\"value : %r\\ntype : %r\" % (fTrue, type(fTrue))) print(\"value : %r\\ntype : %r\" % (fFalse, type(fFalse))) print(\"value : %r\\ntype : %r\" % (sTrue, type(sTrue))) print(\"value : %r\\ntype : %r\" % (sFalse, type(sFalse))) # value : 1 # type : # value : 0 # type : # value : 1.0 # type : # value : 0.0 # type : # value : 'True' # type : # value : 'False' # type : 除此之外，使用bool()将任意类型对象包裹均能获得其布尔值的表现形式。 以下举例Python内置数据类型在不同状态下的布尔值表示： 类型 True False int&float 不为0 为0 str&bytes 不为空串 为空串 list&tuple 不为空序列 为空序列 dict&set 不为空映射 为空映射 示例如下： >>> # --- int & float --- >>> bool(0) False >>> bool(1) True >>> bool(-1) True >>> bool(0.1) True >>> bool(-0.1) True >>> # --- str & bytes --- >>> bool(\"\") False >>> bool(b\"\") False >>> bool(\"string\") True >>> bool(b\"bytes\") True >>> # --- list & tuple --- >>> bool(list()) False >>> bool(tuple()) False >>> bool(list((1, 2, 3))) True >>> bool(tuple((1, 2, 3))) True >>> # --- dict & set --- >>> bool(dict()) False >>> bool(set()) False >>> bool(dict(k1=\"v1\", k2=\"v2\")) True >>> bool(set((\"ele1\", \"ele2\"))) True 布尔常量池 True和False是会被经常使用到的，因此在Python解释器启动时就会进行创建，我将他两归类为布尔常量池中（实际上并不存在）。 与小整数常量池中的数字类似，即使经历不同的实例化过程，但每次得到的True和False都来自同一引用： >>> id(True) 4495471488 >>> id(False) 4495471456 >>> id(bool(1)) 4495471488 >>> id(bool(0)) 4495471456 True&False与1&0 布尔值参与四则运算的时候，True等价于1，False等价于0： >>> True + 1 2 >>> False + 1 1 >>> True - False 1 实际上，True和False当采用运算时将会从小整数池中取出1和0，但是若使用id()方法查看True和1的地址号，会发现是不同的： >>> id(True) 4495471488 >>> id(1) 4495853616 为什么会出现这种情况？其实点开bool类型的源代码就可以发现，在Python3中bool类继承至int类： class bool(int): 当传入一个任意类型构建bool类的实例对象时，通过内部一系列判定都会返回True或者False这种形式。 若要将布尔类型直接参与运算（四则运算、hash运算），则会通过内部某种特殊的机制拿到1或者0。 id()方法返回的是对象的地址号，而bool的实例对象和int的实例对象必定在堆区内存中由不同的位置进行存储，故它们的结果不一样。 而运算时，布尔类型会去小整数池中拿到对应的整型值来参与运算，故True和1的hash运算的结果都是相同的。 如下图所示： 绝对引用 布尔类型拥有绝对引用的特性，则无论是深拷贝还是浅拷贝，都不会获得其副本，而是直接对源对象进行引用： >>> import copy >>> oldBool = True >>> id(oldBool) 4369122176 >>> b1 = copy.copy(oldBool) >>> id(b1) 4369122176 >>> b2 = copy.deepcopy(oldBool) >>> id(b2) 4369122176 boolobject.c源码 官网参考：点我跳转 源码一览：点我跳转 现有的名称 Py_False 和 Py_True 引用独一无二的布尔对象 False 和 True （之前，它们分别引用了值为 0 和 1 的静态整数对象，是众多整数之一）。 一个新的 API，即PyObject *PyBool_FromLong(long) ，会接收一个 C长整型参数，并返回对 Py_False （当参数为零时）或 Py_True （当非零时）的新引用。 要检查对象是否为布尔对象，可以使用宏PyBool_Check()。 布尔实例的类型是 PyBoolObject*。 布尔类型对象可作为PyBool_Type使用。 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-13 20:41:50 "},"Python/Python基础知识/单例None.html":{"url":"Python/Python基础知识/单例None.html","title":"单例None","keywords":"","body":"None None是Python中经常出现的一种类型，但其实关于它的描述并不是很多，因此None也经常被人忽略。 None是一种不可变类型，同时也是基础的原子类型，即不可分割，不能容纳其他对象。 它常用于初始化数据，并且是函数默认的返回值。 基本声明 None的声明方式仅有字面量声明： empty = None print(\"value : %r\\ntype : %r\" % (empty, type(empty))) # value : None # type : NoneType与单例 尽管可以看到None的实例化类为NoneType，但是你可能无法直接找到NoneType： print(NoneType) # NameError: name 'NoneType' is not defined NoneType实现了单例模式，我们虽然无法直接拿到NoneType这个类，但是可以通过 __class__属性拿到。 以下实例化多个None，查看id()是否相同： NoneType = None.__class__ none1 = NoneType() none2 = NoneType() print(id(none1)) print(id(none2)) # 4377856088 # 4377856088 绝对引用 None类型也是绝对引用，无论是深拷贝还是浅拷贝，都不会获得其副本，而是直接对源对象进行引用： >>> import copy >>> oldNone = None >>> id(oldNone) 4369221720 >>> no1 = copy.copy(oldNone) >>> id(no1) 4369221720 >>> no2 = copy.deepcopy(oldNone) >>> id(no2) 4369221720 None的使用 None一般用于对一个变量进行初始化，可能我们还没想好这个变量存什么内容时可以用None先代替进行存入。 这种变量可称之为临时变量，即只在一定的场景下进行使用，而并不会常驻使用： temp = None Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-13 20:41:50 "},"Python/Python基础知识/内存管理.html":{"url":"Python/Python基础知识/内存管理.html","title":"内存管理","keywords":"","body":"Gc简介 Gc（garbage collection）中文直译为垃圾回收，是一种回收内存空间避免内存泄漏的机制。 我们在程序的运行中会产生大量的对象用于保存数据，而有时候有些对象已经没有用了就需要被清理释放掉该对象所占据的内存空间。 在一些较为低级的语言中对于内存空间的释放是需要编程人员来手动进行的，这种与底层硬件直接打交道的操作是十分的危险与繁琐的，而基于C语言开发而来的Python为了解决掉这种顾虑则自带了一种垃圾回收机制，从而让开发人员不必过分担心内存的使用情况而可以全身心的投入到开发中去。 引用计数 最简单的Gc机制，引用计数。 首先将堆区内存中的对象与栈区内存中标识符的绑定数量做一个计数。 示例如下： >>> a = \"Python\" >>> b = \"Python\" >>> c = \"Python\" 我们的图示按照标识符的引用次数为准，并忽略临时引用，下图中Python这个str对象的引用计数目前为3： 每次标识符与对象取消绑定关系，则计数-1，当计数减到0的时候将自动清理该对象。 示例如下： >>> del a >>> del b >>> del c 标记清除 循环引用 引用计数能够解决百分之九十的问题，但是有一种特殊的情况是引用计数处理不了的，即循环引用（也被称为交叉引用）。 什么是循环引用，举一个简单的例子就是列表的互相嵌套，如下所示，l1和l2的引用计数都为2（标识符+1次引用，两个列表的[-1]索引处+1次引用）： >>> l1 = [1,2,3] >>> l2 = [1,2,3,l1] >>> l1.append(l2) >>> l1 [1, 2, 3, [1, 2, 3, [...]]] >>> l2 [1, 2, 3, [1, 2, 3, [...]]] 接着往下看，我们取消标识符与对象的绑定关系： >>> del l1 >>> del l2 现在，由于2个列表对象的计数都为1，故引用计数的策略显得不好使了。 因为2个列表对象的引用计数都未清0： 解决方案 为了解决循环引用带来的内存泄露问题，出现了标记清除法。 标记清除的意思在于当应用程序可用内存空间即将被耗尽时便开始遍历栈区所有的标识符，并且会顺着栈区标识符对其引用的在堆区中的对象做一个标记。 如果堆区内存中存在没有与栈区标识符进行绑定的对象，该对象则会认为是无用的对象，将会被清理。 分代回收 基于引用计数的垃圾回收机制每一次执行清理操作前都会将整个堆区对象的引用计数做一次遍历统计。 这样做是非常消耗时间的，所以Python垃圾回收机制为了效率的提升加入了分代回收的策略。 即： 当多次扫描后，若该对象的引用计数一直不为0，且也没有被标记清除法所清理掉，则证明 该对象会被经常使用，因此降低该对象的扫描频率，以提升效率。 优秀文章推荐 其实Python内部的内存管理机制远不如此。 所以这里推荐一个知乎博主写的系列文章，感兴趣的朋友可以跳转后继续深入阅读，该博主对Python底层内存机制剖析的极为透彻，是不可多得的好文章： 点我跳转 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-13 20:41:50 "},"Python/Python基础知识/深浅拷贝.html":{"url":"Python/Python基础知识/深浅拷贝.html","title":"深浅拷贝","keywords":"","body":"拷贝 copy即拷贝，意在将相同的数据进行复制，以便将复制出的副本应用于不同的操作上，而本体不会受到任何影响。 绝大多数语言中都有深浅拷贝的概念，故此篇文章也是属于通用性文章。 在Python中，除开手动导入copy模块并使用deepcopy()函数的拷贝是深拷贝，其他的所有的拷贝操作都是浅拷贝。 在开始之前，介绍几个基本概念： 不可变类型：int、float、str、bool、None、tuple、frozenset 可变类型：list、dict、set（均是容器） 绝对引用：所有的不可变类型，都具有绝对引用的特性，即深浅拷贝都不会获得其副本，而是直接对源对象进行引用 赋值 赋值就是引用，代码如下： #!/usr/bin/env python3 # -*- coding:utf-8 -*- oldLi = [\"A\", [1, ], (1,)] newLi = oldLi if id(oldLi) == id(newLi): print(\"外部大容器：可变类型：list来自同一个引用\") else: print(\"外部大容器：可变类型：list来自不同的引用\") if id(oldLi[0] == id(newLi[0])): print(\"内部第1个元素：不可变类型：str来自同一个引用\") else: print(\"内部第1个元素：不可变类型：str来自不同的引用\") if id(oldLi[1]) == id(newLi[1]): print(\"内部第1个大容器：可变类型：list来自同一个引用\") else: print(\"内部第1个大容器：可变类型：list来自不同的引用\") if id(oldLi[1][0]) == id(newLi[1][0]): print(\"内部第1个大容器的数据项：不可变类型：int ：%r来自同一个引用\" % oldLi[1][0]) else: print(\"内部第1个大容器的数据项：不可变类型：int ：%r来自不同的引用\" % oldLi[1][0]) if id(oldLi[2]) == id(newLi[2]): print(\"内部第2个大容器：不可变类型：tuple来自同一个引用\") else: print(\"内部第2个大容器：不可变类型：tuple来自不同的引用\") if id(oldLi[2][0]) == id(newLi[2][0]): print(\"内部第2个大容器的数据项：不可变类型：int ：%r来自同一个引用\" % oldLi[2][0]) else: print(\"内部第2个大容器的数据项：不可变类型：int ：%r来自不同的引用\" % oldLi[2][0]) # 外部大容器：可变类型：list来自同一个引用 # 内部第1个元素：不可变类型：str来自同一个引用 # 内部第1个大容器：可变类型：list来自同一个引用 # 内部第1个大容器的数据项：不可变类型：int ：1来自同一个引用 # 内部第2个大容器：不可变类型：tuple来自同一个引用 # 内部第2个大容器的数据项：不可变类型：int ：1来自同一个引用 如图所示： 所有引用都相同，这代表着oldLi中任意一个数据项改变后，newLi中的数据项也会跟着发生改变： oldLi[0] = \"B\" print(\"oldLi -> index0:type=str -> %r\" % oldLi[0]) print(\"newLi -> index0:type=str -> %r\" % newLi[0]) oldLi[1][0] = 10 print(\"oldLi -> index1:type=list --> index0:type=int -> %r\" % oldLi[1][0]) print(\"newLi -> index1:type=list --> index0:type=int -> %r\" % newLi[1][0]) # oldLi -> index0:type=str -> 'B' # newLi -> index0:type=str -> 'B' # oldLi -> index1:type=list --> index0:type=int -> 10 # newLi -> index1:type=list --> index0:type=int -> 10 图示如下： 浅拷贝 被浅拷贝的对象如果是可变类型，则创建副本，如果是不可变类型，则是引用，浅拷贝仅拷贝1层。 代码如下： #!/usr/bin/env python3 # -*- coding:utf-8 -*- import copy oldLi = [\"A\", [1, ], (1,)] newLi = copy.copy(oldLi) if id(oldLi) == id(newLi): print(\"外部大容器：可变类型：list来自同一个引用\") else: print(\"外部大容器：可变类型：list来自不同的引用\") if id(oldLi[0] == id(newLi[0])): print(\"内部第1个元素：不可变类型：str来自同一个引用\") else: print(\"内部第1个元素：不可变类型：str来自不同的引用\") if id(oldLi[1]) == id(newLi[1]): print(\"内部第1个大容器：可变类型：list来自同一个引用\") else: print(\"内部第1个大容器：可变类型：list来自不同的引用\") if id(oldLi[1][0]) == id(newLi[1][0]): print(\"内部第1个大容器的数据项：不可变类型：int ：%r来自同一个引用\" % oldLi[1][0]) else: print(\"内部第1个大容器的数据项：不可变类型：int ：%r来自不同的引用\" % oldLi[1][0]) if id(oldLi[2]) == id(newLi[2]): print(\"内部第2个大容器：不可变类型：tuple来自同一个引用\") else: print(\"内部第2个大容器：不可变类型：tuple来自不同的引用\") if id(oldLi[2][0]) == id(newLi[2][0]): print(\"内部第2个大容器的数据项：不可变类型：int ：%r来自同一个引用\" % oldLi[2][0]) else: print(\"内部第2个大容器的数据项：不可变类型：int ：%r来自不同的引用\" % oldLi[2][0]) # 外部大容器：可变类型：list来自不同的引用 # 内部第1个元素：不可变类型：str来自同一个引用 # 内部第1个大容器：可变类型：list来自同一个引用 # 内部第1个大容器的数据项：不可变类型：int ：1来自同一个引用 # 内部第2个大容器：不可变类型：tuple来自同一个引用 # 内部第2个大容器的数据项：不可变类型：int ：1来自同一个引用 如图所示，浅拷贝为什么浅，因为只拷贝了一层： 如果修改oldLi第1层的index指向，newLi并不会受到影响，而如果修改oldLi第2层的index指向，则newLi会受到影响，如下所示： oldLi[0] = \"B\" print(\"oldLi -> index0:type=str -> %r\" % oldLi[0]) print(\"newLi -> index0:type=str -> %r\" % newLi[0]) oldLi[1][0] = 10 print(\"oldLi -> index1:type=list --> index0:type=int -> %r\" % oldLi[1][0]) print(\"newLi -> index1:type=list --> index0:type=int -> %r\" % newLi[1][0]) # oldLi -> index0:type=str -> 'B' # newLi -> index0:type=str -> 'A' # oldLi -> index1:type=list --> index0:type=int -> 10 # newLi -> index1:type=list --> index0:type=int -> 10 图示如下： 深拷贝 深拷贝是递归的拷贝，即在浅拷贝的基础上也会递归的判定其子数据项是否能被拷贝。 如果是可变类型则拷贝，如果是不可变类型则不拷贝，代码如下： #!/usr/bin/env python3 # -*- coding:utf-8 -*- import copy oldLi = [\"A\", [1, ], (1,)] newLi = copy.deepcopy(oldLi) if id(oldLi) == id(newLi): print(\"外部大容器：可变类型：list来自同一个引用\") else: print(\"外部大容器：可变类型：list来自不同的引用\") if id(oldLi[0] == id(newLi[0])): print(\"内部第1个元素：不可变类型：str来自同一个引用\") else: print(\"内部第1个元素：不可变类型：str来自不同的引用\") if id(oldLi[1]) == id(newLi[1]): print(\"内部第1个大容器：可变类型：list来自同一个引用\") else: print(\"内部第1个大容器：可变类型：list来自不同的引用\") if id(oldLi[1][0]) == id(newLi[1][0]): print(\"内部第1个大容器的数据项：不可变类型：int ：%r来自同一个引用\" % oldLi[1][0]) else: print(\"内部第1个大容器的数据项：不可变类型：int ：%r来自不同的引用\" % oldLi[1][0]) if id(oldLi[2]) == id(newLi[2]): print(\"内部第2个大容器：不可变类型：tuple来自同一个引用\") else: print(\"内部第2个大容器：不可变类型：tuple来自不同的引用\") if id(oldLi[2][0]) == id(newLi[2][0]): print(\"内部第2个大容器的数据项：不可变类型：int ：%r来自同一个引用\" % oldLi[2][0]) else: print(\"内部第2个大容器的数据项：不可变类型：int ：%r来自不同的引用\" % oldLi[2][0]) # 外部大容器：可变类型：list来自不同的引用 # 内部第1个元素：不可变类型：str来自同一个引用 # 内部第1个大容器：可变类型：list来自不同的引用 # 内部第1个大容器的数据项：不可变类型：int ：1来自同一个引用 # 内部第2个大容器：不可变类型：tuple来自同一个引用 # 内部第2个大容器的数据项：不可变类型：int ：1来自同一个引用 如图所示，深拷贝把能拷贝的，不是绝对引用的都拷贝了： 无论怎么修改oldLi，newLi都不会受到影响： oldLi[0] = \"B\" print(\"oldLi -> index0:type=str -> %r\" % oldLi[0]) print(\"newLi -> index0:type=str -> %r\" % newLi[0]) oldLi[1][0] = 10 print(\"oldLi -> index1:type=list --> index0:type=int -> %r\" % oldLi[1][0]) print(\"newLi -> index1:type=list --> index0:type=int -> %r\" % newLi[1][0]) # oldLi -> index0:type=str -> 'B' # newLi -> index0:type=str -> 'A' # oldLi -> index1:type=list --> index0:type=int -> 10 # newLi -> index1:type=list --> index0:type=int -> 1 图示如下： Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-13 20:41:50 "},"Python/Python基础知识/输入与输出.html":{"url":"Python/Python基础知识/输入与输出.html","title":"输入与输出","keywords":"","body":"输入与输出 输入（output）让计算机能够听懂人类的指令，输入（input）能够告诉人类程序目前的状态。 标准输出 print() 在Python3中，print()函数默认会将对象的表现形式输出至屏幕上： print(\"hello world\") # hello world 而在Python2中，print后面不必加括号，直接加上对象即可： print \"hello world\" 除此之外，print()函数还可以接收3个参数，分别是：sep、end、file sep参数 该参数用来显示逗号间隔中的链接字符，默认为一个空格： # 不指定sep参数 print(\"hello\", \"world\") # hello world # 指定sep参数 print(\"hello\", \"world\", sep=\"☺\") # hello☺world end参数 该参数用于指定当print()完成后所在行尾指定的字符，默认为\\n即换行符。 print(\"hello\", end=\"\\t\") print(\"world\") # hello world file参数 该参数默认内部为标准输出，即输出至用户屏幕，我们可以通过该参数来指定print()的内容写入到某个指定的文件句柄中： with open(\"testFile.txt\", mode=\"wt\", encoding=\"utf8\") as f: print(\"this line written in file\", file=f) 格式化输出 如果我们想将一个字符串与一个对象的表现形式相结合，可使用格式化输出。 % %格式化的历史悠久，很多码龄较长的程序员都喜欢用它进行格式化输出。 我们来看一个例子： name = \"YunYaSir\" age = 19 s1 = \"name : %s\\nage : %d\" % (name, age) # ❶ print(s1) # name : YunYaSir # age : 19 ❶：字符串中的%s、%d等都是占位符，占位符要和对象匹配，在进行格式化时%char会被对象的表现形式所代替。 常见的占位符如下表所示： 占位符 描述 %s 接收任意类型的值，以字符串形式显示 %r 接收任意类型的值，以r字符串形式显示 %c 只接收单个字符 %b 接收int类型的值，二进制整数形式显示 %d 接收int类型的值，十进制整数形式显示 %i 接收int类型的值，十进制整数形式显示 %o 接收int类型的值，八进制整数形式显示 %x 接收int类型的值，十六进制整数形式显示 %e 接收float类型的值，指数形式显示 (基底写为e) %E 接收float类型的值，指数形式显示 (基底写为E) %f 接收float类型的值，浮点数形式显示 %F 接收float类型的值，浮点数形式显示 %g 接收float类型的值，指数(e)或浮点数 (根据显示长度) %G 接收float类型的值，指数(E)或浮点数 (根据显示长度) %% 即打印1个百分号 位置传参 一个占位符对应一个对象，当对象与占位符有多个时便需要将%后面的对象跟上括号做出一个元组，如若只有一个则不需要加上括号，%后元组中的对象数量必须与占位符的数量一致，且位置要一一对应： name = \"YunYaSir\" age = 19 s1 = \"name : %s\\nage : %d\" % (name, age) # ❶ print(s1) # name : YunYaSir # age : 19 如上所示：%s对应name、%d对应age。 优点：便于维护 缺点：对象与占位符必须一一对应，数量必须保持一致 关键字传参 使用关键字传参可以打破位置传参中占位符和标识符顺序以及数量必须统一的限制： name = \"YunYaSir\" age = 19 s1 = \"name : %(name)s\\nage : %(age)d\" % {\"age\": age, \"name\": name} # ❶ print(s1) # name : YunYaSir # age : 19 如上所示：%(name)s代表将dict中key为name的值转换为字符串形式显示，而%(age)d则代表将dict中key为age的值转换为字符串形式显示。 优点：使用灵活 缺点：如果被格式化的占位符过多，可能导致维护不便的情况发生 格式化百分号 如果想打印%占比，则可以使用下面的方式 %%代表一个% 。放在 %d后面的%则代表格式化出后的结果是3%: s1 = \"%d%%\"%3 print(s1) # 3% 格式化精度控制 如果要格式化一个小数，保留点后2位该怎么做？ 如下示例： PI = 3.1415926 print(\"pi = %.2f\" % PI) # pi = 3.14 format() %虽然能够满足基本需求。但在Python2.6中新增的format()方法，它更加强大且速度更快。 推荐今后使用format()的方法进行字符串格式化 。 注意:format()中的s只接受str类型的传值而不接受全部类型 如下所示，必须一个{}对应format()中的一个对象： name = \"YunYaSir\" age = 19 s1 = \"name : {}\\nage : {}\".format(name, age) # ❶ print(s1) # name : YunYaSir # age : 19 ❶：第1个{}对应format()中传入的第1个对象name，而第2个{}对应format()中传入的第2个对象age 或者也可以使用对象的方法调用形式： name = \"YunYaSir\" age = 19 s1 = str.format(\"name : {}\\nage : {}\", name, age) print(s1) # name : YunYaSir # age : 19 位置传参 基本使用，采用{}进行占位，需要注意的是format中的s不是接收全部类型的对象，只能接收str类型的对象： name = \"YunYaSir\" age = 19 s1 = \"name : {:s}\\nage : {:d}\".format(name, age) print(s1) # name : YunYaSir # age : 19 如果不指定类型，则{}中默认接收全部类型的对象： name = \"YunYaSir\" age = 19 s1 = \"name : {}\\nage : {}\".format(name, age) print(s1) # name : YunYaSir # age : 19 索引传参 索引传参是format()方法所独有的。 采用{}进行占位，并在其中传入format()中被格式化对象的位置信息，如下所示： name = \"YunYaSir\" age = 19 s1 = \"name : {0:s}\\nage : {1:d}\".format(name, age) print(s1) # name : YunYaSir # age : 19 需要注意，索引传参时必须为正向索引，不支持负向索引。 关键字传参 format()方法传参时使用键值对的方式进行传参： name = \"YunYaSir\" age = 19 s1 = \"name : {name:s}\\nage : {age:d}\".format(name=name, age=age) print(s1) # name : YunYaSir # age : 19 你也可以直接传入一个字典，通过**语法对字典解包： name = \"YunYaSir\" age = 19 s1 = \"name : {name:s}\\nage : {age:d}\".format(**{\"name\": name, \"age\": age}) print(s1) # name : YunYaSir # age : 19 字符填充功能 format()方法格式化时支持字符填充，如下表所示： 填充位置符号 描述 字符串居左、往右填充数据项 > 字符串居右、往左填充数据项 ^ 字符串居中、两侧填充数据项 示例如下： char = \"M\" # 右填充*，字符串长度为10时停止填充 rightFill = str.format(\"{0:*10}\", char) print(leftFill) # *********M # 两侧填充*，字符串长度为10时停止填充 midFill = str.format(\"{0:*^10}\", char) print(midFill) # ****M***** 格式化百分号 format()方法格式化百分号方法如下，它比%的格式化更加简单： s1 = str.format(\"{0}%\", 3) print(s1) # 3% 格式化{}大括号 如果使用format()方法，格式化时要输出“{char}“该怎么做？ 在外部套用2次大括号即可，如下所示： s1 = str.format(\"{{{0}}}\", \"☺\") print(s1) # {☺} 内部的{0}代表要格式化后面的☺，而外部的2个{}格式化完成后则表现为1个{}。 格式化精度控制 如果要使用format()方法格式化一个小数，保留点后2位该怎么做？ 如下示例： PI = 3.1415926 print(\"pi = {0:.2f}\".format(PI)) # pi = 3.14 其他的格式化 进制转换、如下所示： # 进制转换 sBit = str.format(\"{:b}\", 10) # 2进制 sOct = str.format(\"{:o}\", 10) # 8进制 sHex = str.format(\"{:x}\", 10) # 16进制 print(sBit) # 1010 print(sOct) # 12 print(sHex) # a 如果1代表百分之百，该怎么表示？如下所示： # .2%中的2代表保留2小数点后2位 s1 = str.format(\"{:.2%}\", 1) print(s1) s2 = str.format(\"{:.2%}\", 0.5) print(s2) # 100.00% # 50.00% 千分位表示，用逗号进行分割： s = str.format(\"{:,}\", 100000000) print(s) # 100,000,000 f 尽管format()已经非常方便了。但是如果传入的参数值太多依旧会看着十分混乱，于是Python3.6中新增了 f 格式字符串的操作。 这种方法的速度最快，但是却不推荐使用，因为程序还要考虑一个向下兼容性的问题。 name = \"YunYaSir\" age = 19 s1 = f\"name : {name}\\nage : {age}\" print(s1) # name : YunYaSir # age : 19 具体使用方法参照上面，与原始字符串r使用差不多，用f添加在字符串前面，并且使用{}进行占位，{}中放入对象即可。 关于其他的字符串填充、精度控制、格式化转换等功能均和format()使用相同，这里不再举例。 标准输入 input() Python2和Python3中均有input()函数来接收用户的输入。 需要注意的是，Python3中input()所得到的所有用户输入的数据，类型都是str，举个例子，用户输入小键盘数字1，程序得到的类型为str而不是int，所以我们可能需要额外的进行类型转换。 而在Python2中，则会自动转换类型为int，Python2会检测用户输入的内容是否符合Python语法，如不符合语法就会抛出异常，因此Python3中才摈弃了这种设定。 Python3中获得的所有输入结果类型均为str： username = input(\"Please type in your name:\") userage = input(\"Please enter age:\") print(\"value : %r\\ntype : %r\" % (username, type(username))) print(\"value : %r\\ntype : %r\" % (userage, type(userage))) # Please type in your name:YunYaSir # Please enter age:18 # value : 'YunYaSir' # type : # value : '18' # type : 用户年龄应当是int类型，所以我们需要对其做一次类型转换： username = input(\"Please type in your name:\") userage = int(input(\"Please enter age:\")) Python2中如果用户没有按照Python语法进行数据的录入，则会抛出异常： # coding:u8 username = input(\"Please type in your name:\") userage = input(\"Please enter age:\") print u\"value : %r\\ntype : %r\" % (username, type(username)) print u\"value : %r\\ntype : %r\" % (userage, type(userage)) # -- 输入了 yunya 会抛出 name 'yunya' is not defined # -- 而输入了 \"yunya\" 则会正常 raw_input() raw_input()是Python2中独有的，与Python3的input()效果相同。 这还是因为Python2中input()的缺点而导致raw_input()的诞生，用户必须熟知Python语法才能与程序进行交互，这是不现实的。 >>> name = input(\"Please type in your name:\") Please type in your name: yunya ❶ NameError: name 'yunya' is not defined >>> name = input(\"Please type in your name:\") Please type in your name: \"yunya\" ❷ >>> name 'yunya' ❶：这里没加引号，Python2的input()会认为这是一个变量，但该变量并未被定义，所以抛出 yunya 未定义的这么一个异常。 ❷：加了引号，表明这是一个字符串 更进一步了解输出 stdin&stdout&stderr 在Linux下，当一个用户进程被创建的时候，系统会自动为该进程创建三个数据流，分别是stdin、stdout、stderr。 stdin：标准输入、指向用户键盘 stdout：标准输出、指向用户屏幕 stderr：标准错误、指向用户屏幕 print()的指向 Python3的print()函数，内部则是引用了stdout，也就是说会默认的将数据显示在用户屏幕上。 我们可以从Python中print()函数签名中看到： def print(self, *args, sep=' ', end='\\n', file=None): # known special case of print \"\"\" print(value, ..., sep=' ', end='\\n', file=sys.stdout, flush=False) Prints the values to a stream, or to sys.stdout by default. Optional keyword arguments: file: a file-like object (stream); defaults to the current sys.stdout. sep: string inserted between values, default a space. end: string appended after the last value, default a newline. flush: whether to forcibly flush the stream. \"\"\" pass 而关于flush参数，则可以理解为刷新机制。 默认是False即代表是流式的输出，而改为True则会拥有类似于帧动画的特性，以下代码将进行验证，推荐使用Python IDLE查看效果： import time print(\"downloading\\t\", end=\"\") for i in range(100): time.sleep(0.1) if i == 99: print('#', flush=True, end=\"\\tdownload complate\\n\") break print('#', flush=True, end=\"\") Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-13 20:41:50 "},"Python/Python基础知识/运算符相关.html":{"url":"Python/Python基础知识/运算符相关.html","title":"运算符相关","keywords":"","body":"算数运算符 符号意义 以下是常用的算数运算符： 符号 意义 + 加法运算 - 减法运算 * 乘法运算 / 除法运算，精确除法（返回float） // 除法运算，地板除法（向下取整，生成int） ** 幂运算 % 求余运算 注意事项： float与int或者bool做运算，得到的结果均为float >>> 1 + 1.0 2.0 >>> 1 - 1.0 0.0 >>> 1 * 1.0 1.0 >>> 1 / 1.0 1.0 **幂运算仅支持int 、float、 bool 三种类型 >>> 2 ** 3 8 >>> 2.0 ** 3 8.0 >>> True ** 3 1 >>> %求余运算只支持 int 、float、 bool 三种类型，如果被求余数小于求余数，那么余数就为被求余数本身 >>> 6 % 8 6 示例演示 加法运算 print(1 + 1) print(1 + 1.1) print(1 + True) print([1, 2, 3] + [4, 5, 6]) print('OldStr ' + ' NewStr') # Change the reference value, generate new objects print((1, 2, 3) + (4, 5, 6)) # Change the reference value, generate new objects # 2 # 2.1 # 2 # OldStr NewStr # [1, 2, 3, 4, 5, 6] # (1, 2, 3, 4, 5, 6) 减法运算 print(1 - 1) print(1 - 1.1) print(1 - True) # 0 # -0.10000000000000009 # 0 乘法运算 s1 = '￥' l1 = [1, 2, 3] t1 = (1, 2, 3) print(1 * 2) print(1 * 2.0) print(1 * True) print(3 * l1) print(3 * s1) # Change the reference value to generate a new STR object print(3 * t1) # Change the reference value to generate a new Tuple object # 2 # 2.0 # 1 # [1, 2, 3, 1, 2, 3, 1, 2, 3] # ￥￥￥ # (1, 2, 3, 1, 2, 3, 1, 2, 3) 精确除法 print(10 / 2) print(10 / 2.0) print(10.1 / True) print(10.1 / True) print(10.1 / True) print(10.1 / True) print(False / 10) print(True / 2) print(True / 2.0) # 5.0 # 5.0 # 10.1 # 10.1 # 10.1 # 10.1 # 0.0 # 0.5 # 0.5 赋值运算符 符号意义 以下是常用的赋值运算符： 符号 意义 = 普通的赋值 += 增量加法赋值 -= 增量减法赋值 *= 增量乘法赋值 /= 增量精确除法赋值 //= 增量地板除法赋值 **= 增量幂运算赋值 %= 增量求余赋值 普通赋值 赋值运算符为=，切记一个=才是赋值： >>> x = 1 >>> x 1 增量赋值 在原本标识符所指向的对象基础上进行增量的运算后，再将运算结果赋值给原本的标识符。 增量赋值运算符就是将赋值符号和算术运算符结合起来达到简写的目的： 普通的先运算后赋值： >>> x = 1 >>> x = x + 10 >>> x 11 >>> x = x - 10 >>> x 1 >>> x = x * 10 >>> x 10 >>> x = x / 10 >>> x 1.0 >>> x = x // 10 >>> x 0.0 >>> x = x ** 10 >>> x 0.0 >>> x = x % 10 >>> x 0.0 简便的增量运算符： >>> x = 1 >>> x += 10 >>> x 11 >>> x -= 10 >>> x 1 >>> x *= 10 >>> x 10 >>> x /= 10 >>> x 1.0 >>> x //= 10 >>> x 0.0 >>> x **= 10 >>> x 0.0 >>> x %= 10 >>> x 0.0 平行赋值 平行赋值，一次为多个标识符进行赋值： >>> x, y, z = 1, 2, 3 >>> x 1 >>> y 2 >>> z 3 链式赋值 链式赋值，多个标识符引用同一个对象： >>> x = y = z = \"Object\" >>> x 'Object' >>> y 'Object' >>> z 'Object' 链式赋值也被称之为间接赋值。 交叉赋值 交叉赋值，将2个标识符所指向的对象进行互换： >>> x = \"Object001\" >>> y = \"Object002\" >>> x, y = y, x >>> x 'Object002' >>> y 'Object001' 解压赋值 解压赋值这里不再进行赘述了，前面在介绍内置数据类型的时候已经介绍过了。 比较运算符 符号意义 比较运算符的返回结果总是为True或者False，一般是用于比较2个相同类型的值的大小。 常用于条件分支结构中： 符号 意义 > 大于 小于 == 等于 != 不等于 >= 大于或者等于 小于或者等于 示例演示 比较运算符得到的结果必然是bool类型： >>> 1 >> 1 > 2 False >>> 1 == 1.0 True >>> 1 == True True 比较方式 字符串与字符串之间的比较会一位一位对照ASCII表来进行比对： >>> ord(\"y\") 121 >>> ord(\"k\") 107 >>> \"y\" > \"k\" True 如果是非ASCII字符，则会调用其他的比较机制，如调用locale模块下的strxfrm()函数对字符串进行本地化处理： print(\"中\" > \"美\") 如果是数字串，则会一位一位进行比较： >>> \"100\" > \"4\" False # 第一位比较：1 小于 4，后续不再比较 数字与数字之间的比较会之间比较整体： >>> 100 > 1000 False 元组、列表之间的比较会根据相同的索引值进行一位一位的比较： >>> (\"100\", ) > (\"45\", \"b\") False # 1比4小 逻辑运算符 逻辑词汇 不同于其他编程语言的&&和||，Python中使用单词代表与或非。 单词 意义 not 非，统一取反 and 与，一真一假取一假，两个为真才取真 or 或，一真一假取一真，两个为假才取假 优先级 优先级的意思是如下： not True and False or True # 第一个True是该给not还是and做运算呢？ 牢记：NOT>AND>OR 故上面的结果为： True 以下是推算流程： False and False or True False or True True 示例演示 使用not进行取反： >>> not 1 > 2 True 使用and进行多条件连接： >>> name = \"Yunya\" >>> age = 18 >>> name == \"Yunya\" and age == 18 True >>> 使用or进行或逻辑判断： >>> name = \"Yunya\" >>> age = 18 >>> name == \"Yunya\" or age == 100 True >>> 短路运算 如果一次逻辑运算中的逻辑运算符号全部为 and 或者 or 则会从左至右依次进行逻辑运算。 如果每一次都进行运算是很消耗时间的，所以这个时候出现了短路机制。 看图说话： 与或运算 如果不是对True或者False进行and or运算而是对数字进行and or运算呢？ 只需要牢记0是False非0是True即可： >>> 1 and 0 or 3 3 >>> 3 + 1 and 4 or 0 4 每次的结果，都取最后一个True值： >>> 1 and 2 2 >>> 2 and 1 1 >>> 1 or 0 1 >>> 0 or 1 1 成员运算符 in in用来判断容器类型的某一个数据项是否在其中，支持的类型有str、list、tuple、dict、set、frozenset，所有的判定严格区分大小写。 in：在其中 not in：不在其中 需要注意的是如果是对dict做in的成员判定，只会判定key是否在其中： >>> string = \"ABCDEFG\" >>> \"A\" in string True >>> \"a\" in string False >>> li1 = [1, 2, 3] >>> 1 in li1 True >>> 0 in li1 False >>> tup = (1, 2, 3) >>> 1 in tup True >>> 0 in tup False >>> dic = {\"k1\" : \"v1\", \"k2\" : \"v2\"} >>> \"k1\" in dic True >>> \"v1\" in dic False >>> s1 = {1, 2, 3} >>> 1 in s1 True >>> 0 in s1 False 身份运算符 is is判定对象是否来自同一引用，即是否是同一个对象，用来判断引用是否相等： >>> x = y = z = \"I love Python\" >>> x is y True >>> x is z True is&==的异同 ==仅判断对象的值是否相同，不关心是否引用自同一对象： >>> x = \"I love Python\" >>> y = \"I love Python\" >>> x == y True >>> x is y False 两者的区别在于使用is时相当于使用 id(obj) == id(obj)，即对象是否为同一引用： >>> x = \"I love Python\" >>> y = \"I love Python\" >>> id(x) 4305667952 >>> id(y) 4305668016 >>> id(x) == id(y) # is False 而==则不会判定id，仅判断2个对象的形式值是否相同： >>> x = \"I love Python\" >>> y = \"I love Python\" >>> id(x) 4305667952 >>> id(y) 4305668016 >>> x == y True 小结： is：引用判定，引用相等的对象则必然值相等 ==：值判定，值相等的对象引用不一定相等 is None 一般来说，我们对None做判断时都会使用is None而不是 == None，这是因为None本身就是一个单例对象。 所有的None对象其实内部都引用自同一对象，在PEP8规范中明确表示，对于None的判定应该使用is而不是==： r = None print(r is None) print(r == None) # True # True 虽然这么使用毫无问题，但是在PyCharm中会报出PEP8不规范的提示： 对象的增量与普通运算操作 记住一句话，增量是原地操作，不会开辟新的内存空间（字符串的+=除外）。 而普通的运算操作则会开辟新的内存空间，返回1个新对象。 我们以列表举例： >>> lst1 = [1, 2, 3] >>> lst2 = lst1 * 3 >>> lst1 is lst2 False >>> lst2 [1, 2, 3, 1, 2, 3, 1, 2, 3] >>> lst1 = [1, 2, 3] >>> id(li1) 4346207752 >>> lst1 *= 3 >>> id(li1) 4346207752 >>> lst1 [1, 2, 3, 1, 2, 3, 1, 2, 3] Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-10-22 14:23:22 "},"Python/Python基础知识/分支结构.html":{"url":"Python/Python基础知识/分支结构.html","title":"分支结构","keywords":"","body":"分支结构 分支结构能够让计算机像人一样进行思考，应对不同的场景做出不同的回应。 Python中不支持switch语法，目前仅支持if/else形式，但是在Python3.10的测试版本中，貌似支持了switch语法，这里不做例举。 if 多条if语句出现会逐行进行判断，条件为真则执行其下的代码块，条件为假则略过： if 条件判断： 逻辑代码... if 条件判断: 逻辑代码... if 条件判断: 逻辑代码... 示例演示： userAge = int(input(\"Please enter your age:\")) if userAge = 18 and userAge = 30 and userAge = 60 and userAge = 80: print(\"Can still meal\") if/else if代表如果怎样就怎样，else代表否则怎样就怎样。 一组if/else只会执行其中的一个。 以下是Python中if/else语法： if 条件判断： 逻辑代码... else： 逻辑代码... 示例演示： userinput = input(\"Enter any character, determine if it is a numeric string:\") if userinput.isdigit(): print(\"Is a digital string\") else: print(\"Not a digital string\") if/elif/else 多条if会按顺序依次执行，对每一条if语句都进行判定，而如果使用elif则只会从多条逻辑判定中取出最先为True的进行执行，后续的判定将不会被执行。 也就是说，if/elif/else三者只会执行一个。 语法使用如下： if 条件判断： 逻辑代码... elif 条件判断: 逻辑代码... elif 条件判断: 逻辑代码... else: 逻辑代码 示例演示： userAge = int(input(\"Please enter your age:\")) if userAge 三元表达式 三元表达式中有三个重要的元素： 条件是第一元素 　 条件成立返回的值是第二元素 　 条件不成立返回的值是第三元素 普通形式 如果只是一个简单if/else判定，我们可以将代码写在一行，语法如下： if else 示例演示： age = int(input(\"Please enter your age:\")) result = \"adult\" if age >= 18 else \"underage\" print(result) 其他形式 上面的三元表达式是最常见的一种，除此之外再介绍几种不常见的。 第二种，这种有一个BUG，不能区分0或者Fasle： and or 如下所示，如果1大于0就返回0，否则返回False，但是第二种的返回的结果永远是False： result = 1 > 0 and 0 or False print(result) # False 如果使用第一种，就不会有这样的问题： result = 0 if 1 > 0 else False print(result) # False 第三种，语法如下： (, )[condition] 示例如下： age = int(input(\"Please enter your age:\")) result = (\"underage\", \"adult\")[age >= 18] print(result) 第四种，语法如下： {True: , False: }[] 示例如下： age = int(input(\"Please enter your age:\")) result = {True: \"adult\", False: \"underage\"}[age >= 18] print(result) Python语法糖 链式比较 在Python中的判定支持一种链式比较，下面是常规的比较： age = 13 if age > 12 and age 通过链式比较进行简写： age = 13 if 12 12 and age 获得布尔值 判定用户输入的是否为数字串，如果为数字串result变量为True，否则为False。 很多情况下，初学者可能会写出下面这种代码： userInput = input(\"Please enter your age:\") result = None if userInput.isdigit(): result = True else: result = False print(result) 其实一行代码就可以搞定： userInput = input(\"Please enter your age:\") result = bool(userInput.isdigit()) print(result) 或者你也可以使用另一种方式： userInput = input(\"Please enter your age:\") result = userInput.isdigit() or False print(result) 实例练习 输入一个数字，判断该数字是奇数还是偶数： num = int(input(\"Enter a number: \")) if (num % 2) == 0: print(\"%s an even number\" % num) else: print(\"%s an odd number\" % num) 输入一个年份，判断该年份是否是闰年？ year = int(input(\"Enter a year: \")) if (year % 4) == 0: if (year % 100) == 0: if (year % 400) == 0: print(\"%s is a leap year\" % year) # 整百年能被400整除的是闰年 else: print(\"%s not is leap year\" % year) else: print(\"%s is a leap year\" % year) # 非整百年能被4整除的为闰年 else: print(\"%s not is leap year\" % year) 输入某年某月某日，判断这一天是这一年的第几天？ year = int(input('year:\\n')) month = int(input('month:\\n')) day = int(input('day:\\n')) sumInt = None months = (0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334) if 0 2): sum += 1 print('it is the %dth day.' % sum) Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-13 20:41:50 "},"Python/Python基础知识/流程控制.html":{"url":"Python/Python基础知识/流程控制.html","title":"流程控制","keywords":"","body":"流程控制 流程控制以循环为主，旨在让计算机重复的去做某一件事情。 在介绍流程控制一章节前，引入一个叫做遍历的概念： 遍历是指对一个可迭代对象类型（暂时理解为容器类型），进行数据项的依次访问行为 下面这个是遍历行为轨迹示意： # [1, 2, 3, 4, 5, 6] # ------------------> 重复的取值也在遍历范畴： # [1, 2, 3, 4, 5, 6] # -----> # # 条件循环 while while循环是基于条件的循环，while本身具有if判断的功能，当条件为真时开始重复执行子代码块中的内容直至条件为假后跳出循环。 tag = 10 while tag > 5: print(\"current tag value : %s\" % tag) tag -= 1 print(\"while cycle end tag of value : %s\" % tag) # current tag value : 10 # current tag value : 9 # current tag value : 8 # current tag value : 7 # current tag value : 6 # while cycle end tag of value : 5 条件退出 while只有在每一次的循环开始前才会检测条件是否为真，如果条件在子代码块内部发生改变则本次的循环并不会立即退出，如下所示： tag = 10 while tag != 5: print(\"current tag value : %s\" % tag) tag = 5 print(\"no stop continue to run\") print(\"while cycle end tag of value : %s\" % tag) # current tag value : 10 # no stop continue to run\" # while cycle end tag of value : 5 while/else while循环正常结束后，会执行else代码块中的代码： 正常结束的while循环是指不被强制break的while循环 tag = 3 while tag: print(tag) tag -= 1 else: print(\"else...\") # 3 # 2 # 1 # else... 死循环 当while的结果永远为真时，将引发死循环。 单纯的死循环不会引来性能损耗问题，但是如果做一些计算操作则必将会对CPU带来极大的性能压力，因为CPU没有一刻的休息时间。 tag = 1 while 1: tag += 10 取值循环 for for循环内部是基于while循环来完成的，for循环在对可迭代对象的取值上比while循环更加的方便，故也被称为取值循环。 for循环常用于遍历可迭代对象进行取值操作，以下是语法介绍： for 迭代变量 in 可迭代对象（暂时可理解为容器类型） 逻辑操作... 以下是使用while循环遍历可迭代对象进行取值，相当麻烦： lst = [1, 2, 3, 4, 5] index = 0 while 1: try: print(lst[index]) except IndexError: break index += 1 # 1 # 2 # 3 # 4 # 5 如果使用for循环，那么就变的简单许多： lst = [1, 2, 3, 4, 5] for i in lst: print(i) # 1 # 2 # 3 # 4 # 5 结束退出 for循环的正常退出是遍历完整个可迭代对象之后进行退出。 lst = [1, 2, 3, 4, 5] for i in lst: print(i) print(\"for cycle end\") # 1 # 2 # 3 # 4 # 5 # for cycle end for/else 当for循环正常退出结束后，会执行else下的代码块： 正常结束的for循环是指不被强制break的for循环 lst = [1, 2, 3, 4, 5] for i in lst: print(i) else: print(\"else..\") # 1 # 2 # 3 # 4 # 5 # else.. range() 我们有一个需求需要让计算机重复打印5次hello,world，你可能会这样做： count = 5 while count: print(\"hello,world\") count -= 1 也可以使用for循环来进行完成，但是这样会很麻烦，由于使用for循环必须遍历一个可迭代对象，所以要先创建一个可迭代对象： count = [0, 1, 2, 3, 4] for i in count: print(\"hello,world\") 如果你使用range()，这一切都会变得非常简单，range()会帮助你快速的创建一个可迭代对象，我们只需要指定它的次数即可： for i in range(5): print(\"hello,world\") 关于range()方法的其他讲解，会在下面进行。 容器遍历 字符串遍历 示例演示： string = \"hello world\" for i in string: print(\"index : %s, value : %s\"%(string.index(i), i)) # index : 0, value : h # index : 1, value : e # index : 2, value : l # index : 2, value : l # index : 4, value : o # index : 5, value : # index : 6, value : w # index : 4, value : o # index : 8, value : r # index : 2, value : l # index : 10, value : d 列表遍历 普通遍历： lst = [1, 2, 3, 4] for i in lst: print(i) 通过enumerate()函数来同时遍历2个相同长度的列表： lst1 = [\"A\", \"B\", \"C\", \"D\"] lst2 = [\"a\", \"b\", \"c\", \"d\"] for index, item in enumerate(lst1): lst1Message = str.format( \"lst1 index position {} is data item {}\", index, item) print(lst1Message) lst2Message = str.format( \"lst2 index position {} is data item {}\", index, lst2[index]) print(lst2Message) 通过[::-1]来反向遍历列表： lst = [\"A\", \"B\", \"C\", \"D\"] for i in lst[::-1]: print(i) 隔一个取一个的遍历列表： lst = [\"A\", \"B\", \"C\", \"D\"] for i in lst[::2]: print(i) 字典遍历 普通的遍历只会遍历出key，这样的操作等同于遍历dict.keys()： dic = { \"k1\": \"v1\", \"k2\": \"v2\", \"k3\": \"v3\", } for k in dic: print(k) # k1 # k2 # k3 如果你想取出value，则可以遍历dict.values()： dic = { \"k1\": \"v1\", \"k2\": \"v2\", \"k3\": \"v3\", } for v in dic.values(): print(v) # v1 # v2 # v3 如果你想同时取出key和value，则可以遍历dict.items(): dic = { \"k1\": \"v1\", \"k2\": \"v2\", \"k3\": \"v3\", } for k, v in dic.items(): print(k, v) # k1 v1 # k2 v2 # k3 v3 局部作用域 如果一个迭代变量的命名为i，那么这个迭代变量能在外部访问到吗？答案是能！ 其实在Python2和Python3中，普通的for循环语句是没有局部作用域这一个说法的，希望在未来版本能有所改进。 for i in range(10): pass print(i) # 9 循环控制 continue 在while/for中均可以使用continue跳过本次循环。 以下用for循环进行举例： for i in range(5): if i == 3: continue else: print(i) # 0 # 1 # 2 # 4 break 在while/for中均可以使用break结束本层循环。 以下用for循环进行举例： for i in range(5): if i == 3: break else: print(i) # 0 # 1 # 2 循环嵌套 while嵌套 while循环支持多层嵌套，在使用时注意下面的事项： 如果是使用基于条件退出那么所有的while循环都必须遵循同一个条件才能退出 break只针对当前的while循环体退出，对于非当前的while循环体不生效 continue只针对当前while循环体跳过，对于非当前的while循环体不生效。 如下示例： tag = True while tag: print(\"outer while cycle start, current tag value is : %s\" % tag) while tag: print(\"intermediate while cycle start, current tag value is : %s\" % tag) while tag: print(\"inner while cycle start, current tag value is : %s\" % tag) tag = False # outer while cycle start, current tag value is : True # intermediate while cycle start, current tag value is : True # inner while cycle start, current tag value is : True for嵌套 for循环同样支持嵌套。 外层执行1次，内层的for循环要全部循环完成才回到外层执行第2次。 for i in range(65, 68): print(\"outer for cycle, current cycle value is : %s\" % chr(i)) for j in range(97, 100): print(\"inner for cycle, current cycle value is : %s\" % chr(j)) print(\"\") # outer for cycle, current cycle value is : A # inner for cycle, current cycle value is : a # inner for cycle, current cycle value is : b # inner for cycle, current cycle value is : c # outer for cycle, current cycle value is : B # inner for cycle, current cycle value is : a # inner for cycle, current cycle value is : b # inner for cycle, current cycle value is : c # outer for cycle, current cycle value is : C # inner for cycle, current cycle value is : a # inner for cycle, current cycle value is : b # inner for cycle, current cycle value is : c 以下是使用for循环打印乘法表的例子： for i in range(1, 10): for j in range(1, i+1): print(\"%s * %s = %s\" % (i, j, i*j), end=\"\\t\") print(\"\") range()详解 range() range()方法在Python2中返回的是一个列表，而在Python3中返回的是一个可迭代对象（这种可迭代对象不会存值，而是惰性求值，类似于生成器）。 range()方法有三个参数，如下表所示： 参数介绍 描述 start 从几开始生成 stop 生成到几结束 step 步长间距 在使用range()进行生成时，需要注意顾头不顾尾。 如下所示： lst = list(range(1, 10, 2)) print(lst) # [1, 3, 5, 7, 9] xrange() Python2中的xrange()与Python3中的range()相同，均返回可迭代对象，而非列表。 关于为什么做，其实是为了节省内存空间。 列表中的具体值会存在内存中，而如果是一个通过计算可惰性求值的可迭代对象，则不会消耗太大的内存，以下是自定义range()的实现。 class Range: def __init__(self, stop, start=0, step=1): self.start = start self.stop = stop self.step = step self.current = None def __iter__(self): return Range_iterator(self.stop, self.start, self.step) class Range_iterator: def __init__(self, stop, start, step): self.start = start self.stop = stop self.step = step self.current = self.start def __next__(self): if self.current 实例练习 将列表内的元素,根据位数合并成字典，列表如下： lst = [1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 32769, 65536, 4294967296] 答案： lst = [1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 32769, 65536, 4294967296] dic = {} for i in lst: k = len(str(i)) # 如果不存在该键，这该键等同于一个空列表 dic.setdefault(k, []) dic[k].append(i) print(dic) 使用for循环打印三角形： for i in range(1, 6): for j in range(1, 6 - i): print(\" \", end=\"\") for k in range(1, i + 1): print(\"* \", end=\"\") print(\"\") # * # * * # * * * # * * * * # * * * * * 有四个数字：1、2、3、4，能组成多少个互不相同且无重复数字的三位数？各是多少？ count = 0 for i in range(5): for j in range(1, 5): for k in range(1, 5): if (i != k) and (i != j) and (j != k): count += 1 print(i, j, k) print(count) # 36 斐波拉契数列是这样的一个数列：0、1、1、2、3、5、8、13、21、34、…… 前2个值加起来的结果恰好等于第3个值，求一个长度为10的斐波拉契数列： n = 10 fibArray = [] a , b = 0, 1 for i in range(n): fibArray.append(a) a, b = b, a + b print(fibArray) # [0, 1, 1, 2, 3, 5, 8, 13, 21, 34] 输入2个数字，求2个数字的最小公倍数： x = int(input(\">>>\")) y = int(input(\">>>\")) minCommonMultiple = None if x > y: greater = y else: greater = x while 1: if ((greater % x == 0 ) and (greater % y == 0)): minCommonMultiple = greater break greater += 1 msg = str.format(\"{0}和{1}的最小公倍数为{2}\", x, y, minCommonMultiple) print(msg) 输入2个数字，求2个数字的最大公约数： x = int(input(\">>>\")) y = int(input(\">>>\")) maxCommonDivisor = None if x > y: smaller = y else: smaller = x for i in range(1, smaller + 1): if ((x % i == 0) and (y % i == 0)): maxCommonDivisor = i msg = str.format(\"{0}和{1}的最大公约数为{2}\", x, y, maxCommonDivisor) print(msg) Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-13 20:41:50 "},"Python/Python基础知识/推导式.html":{"url":"Python/Python基础知识/推导式.html","title":"推导式","keywords":"","body":"推导式 Python从Haskell语言中取得灵感，创建了一系列的Python推导式（comprehension）。 它可以在不丧失代码可读性的前提下创建一系列容器，是Python颇受好评的特性。 列表推导式 应用场景 有一个列表中存了一些人名和性别的元组数据项，我需要将性别为男性（male）的数据项提取至一个新的列表中。 如下所示，在没有学习列表推导式之前， 你可能会这样做： oldList = [ (\"Tom\", \"Male\"), (\"Jack\", \"Male\"), (\"Mary\", \"Female\"), (\"Laura\", \"Female\") ] newList = [] for tpl in oldList: if tpl[-1].lower() == \"male\": newList.append(tpl) print(newList) # [['Tom', 'Male'], ['Jack', 'Male']] 如果有列表推导式的帮助，它就会简单许多，语法如下： newList = [ 被添加/操作的数据项 for 迭代变量 in 可迭代对象 if 条件] 列表推导式操作如下所示： oldList = [ (\"Tom\", \"Male\"), (\"Jack\", \"Male\"), (\"Mary\", \"Female\"), (\"Laura\", \"Female\") ] newList = [tpl for tpl in oldList if tpl[-1].lower() == \"male\"] # ❶ print(newList) # [['Tom', 'Male'], ['Jack', 'Male']] ❶：当数据项的判断为True时将自动添加至newList中，不能指定else条件 快速创建列表 使用列表推导式可以快速的创建一个列表。 如下所示，推导出数据项从1-10的列表： newLi = [i for i in range(1, 11)] print(newLi) # [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] 下面的示例中，我们可以快速的使用双层循环推导出了一副扑克牌的列表： newLi = [ i + str(j) for i in [\"❤\", \"♧\", \"♤\", \"♢\"] for j in range(1, 14)] newLi.append(\"bigKing\") newLi.append(\"smallKing\") print(newLi) 结果如下： ['❤1', '❤2', '❤3', '❤4', '❤5', '❤6', '❤7', '❤8', '❤9', '❤10', '❤11', '❤12', '❤13', '♧1', '♧2', '♧3', '♧4', '♧5', '♧6', '♧7', '♧8', '♧9', '♧10', '♧11', '♧12', '♧13', '♤1', '♤2', '♤3', '♤4', '♤5', '♤6', '♤7', '♤8', '♤9', '♤10', '♤11', '♤12', '♤13', '♢1', '♢2', '♢3', '♢4', '♢5', '♢6', '♢7', '♢8', '♢9', '♢10', '♢11', '♢12', '♢13', 'bigKing', 'smallKing'] 元素的处理 数据项在添加至列表之前，可以为其进行一些操作。 比如在上面扑克牌的示例中，我们将int对象转换为了str对象，同理也可以做一些别的操作。 如下示例，我们将推导出一个含有26字母的列表： newLi = [chr(i) for i in range(65, 91)] print(newLi) # ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'] 迭代变量 需要注意的是，迭代变量与条件成立后添加的数据项没有任何关系，如下所示，一行代码创建10个A： newLi = [\"A\" for i in range(10)] print(newLi) # ['A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A'] 对于这个题目，有一种更简便的解法： newLi = [\"A\"] * 10 字典推导式 使用示例 字典推导式和列表推导式大体差不多，但是外部是用花括号包裹，并且要有:进行key和value的区分。 如下所示，快速的推导出标准ASCII码表的对照关系： asciiDict = {i: chr(i) for i in range(0, 128)} print(asciiDict) 结果如下： {0: '\\x00', 1: '\\x01', 2: '\\x02', 3: '\\x03', 4: '\\x04', 5: '\\x05', 6: '\\x06', 7: '\\x07', 8: '\\x08', 9: '\\t', 10: '\\n', 11: '\\x0b', 12: '\\x0c', 13: '\\r', 14: '\\x0e', 15: '\\x0f', 16: '\\x10', 17: '\\x11', 18: '\\x12', 19: '\\x13', 20: '\\x14', 21: '\\x15', 22: '\\x16', 23: '\\x17', 24: '\\x18', 25: '\\x19', 26: '\\x1a', 27: '\\x1b', 28: '\\x1c', 29: '\\x1d', 30: '\\x1e', 31: '\\x1f', 32: ' ', 33: '!', 34: '\"', 35: '#', 36: '$', 37: '%', 38: '&', 39: \"'\", 40: '(', 41: ')', 42: '*', 43: '+', 44: ',', 45: '-', 46: '.', 47: '/', 48: '0', 49: '1', 50: '2', 51: '3', 52: '4', 53: '5', 54: '6', 55: '7', 56: '8', 57: '9', 58: ':', 59: ';', 60: '', 63: '?', 64: '@', 65: 'A', 66: 'B', 67: 'C', 68: 'D', 69: 'E', 70: 'F', 71: 'G', 72: 'H', 73: 'I', 74: 'J', 75: 'K', 76: 'L', 77: 'M', 78: 'N', 79: 'O', 80: 'P', 81: 'Q', 82: 'R', 83: 'S', 84: 'T', 85: 'U', 86: 'V', 87: 'W', 88: 'X', 89: 'Y', 90: 'Z', 91: '[', 92: '\\\\', 93: ']', 94: '^', 95: '_', 96: '`', 97: 'a', 98: 'b', 99: 'c', 100: 'd', 101: 'e', 102: 'f', 103: 'g', 104: 'h', 105: 'i', 106: 'j', 107: 'k', 108: 'l', 109: 'm', 110: 'n', 111: 'o', 112: 'p', 113: 'q', 114: 'r', 115: 's', 116: 't', 117: 'u', 118: 'v', 119: 'w', 120: 'x', 121: 'y', 122: 'z', 123: '{', 124: '|', 125: '}', 126: '~', 127: '\\x7f'} 第2个例子，对于迭代一些特殊格式的容器，可以直接生成出一个字典： userMessage = [(\"name\", \"Yunya\"), (\"age\", 18), (\"gender\", \"male\")] newDict = {k: v for k, v in userMessage} print(newDict) # {'name': 'Yunya', 'age': 18, 'gender': 'male'} 集合推导式 使用示例 集合推导式只需要将列表推导式的[]改为{}即可。 以下是示例演示，很显然，由于是集合推导式，故下面的双层循环并不会产生重复元素： newSet = {j for i in range(10) for j in range(10)} print(newSet) # {0, 1, 2, 3, 4, 5, 6, 7, 8, 9} 局部作用域 之前聊过普通的for循环中是不存在局部作用域的，那么在推导式当中是否存在局部作用域呢？ 以列表举例： newList = [i for i in range(10)] print(i) # NameError: name 'i' is not defined 可以看见，在推导式中的局部作用域是存在的。 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-13 20:41:50 "},"Python/Python基础知识/字符编码.html":{"url":"Python/Python基础知识/字符编码.html","title":"字符编码","keywords":"","body":"存储编码 一般来说，我们用什么方式进行文件存储，就用什么编码方式对其进行打开，一般使用UTF8进行存储和打开文件即可。 执行编码 Python3中在执行代码时，解释器都会按照UTF8编码格式将脚本文件中的代码加载至内存中，所以一般不会出现问题。 但是在Python2里解释器则是使用ASCII的编码格式进行脚本文件内容的解码。 所以你可能会遇上下面的情况： SyntaxError:Non-ASCII character .... in file ... 解决这个办法，可以利用头文件代码，让Python解释器在解码脚本文件内容时，以UTF8格式进行解码： # --*-- coding:UTF8 --*-- # 开始书写你的代码 可以使用sys的getdefaultencoding()方法来查看Python解释器默认采用的执行编码格式： >>> # Python2 >>> import sys >>> sys.getdefaultencoding() 'ascii' >>> # Python3 >>> import sys >>> sys.getdefaultencoding() 'utf-8' Unicode字符串 Python2中的str类型，本质是Python3中的bytes，所以仅支持ASCII码表中的字符。 如果想将其转换为Unicode字符串，则必须在前面加上u： print u\"这是Unicode字符串\" Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-13 20:41:50 "},"Python/Python基础知识/文件操作.html":{"url":"Python/Python基础知识/文件操作.html","title":"文件操作","keywords":"","body":"open() Python中提供了open()方法用于对文件进行操作，该方法会返回一个文件对象。 由于被读取的文件内容本身全部属于str类型，故使用open()方法对其进行操作必然涉及字符编码的问题。 以下是open()方法的函数签名： def open(file: Union[str, bytes, int, _PathLike[Any]], mode: str = ..., buffering: int = ..., encoding: Optional[str] = ..., errors: Optional[str] = ..., newline: Optional[str] = ..., closefd: bool = ..., opener: Optional[Callable[[str, int], int]] = ...) -> IO[Any]: 下面是对常用参数的解释： 参数名 描述 file 必需，文件路径（相对或者绝对路径） mode 可选，文件内容读取与操作模式，*t模式以为文本内容读取模式打开文件。需要填入encoding，b模式为二进制模式读取文件内容，默认该参数为*t 。*代表操作模式 encoding 可选（Python2没有该参数），当mode为 *t 时指定编码或解码格式。一般设置为 utf-8。如不指定Windows平台默认为GBK，Mac和Linux平台为utf-8 buffering 设置缓冲 errors 报错级别 newline 是否区分换行符，默认为True closefd 传入的file参数类型 以下是在Python3中进行读取文件的简单示例： f = open(file=\"test.txt\", mode=\"rt\", encoding=\"utf-8\") print(f.read()) # ❶ f.close() # ❷ ❶：read()读取所有内容 ❷：关闭文件句柄 with语句 在open()后要切记关闭文件句柄，释放系统资源，这是一项非常重要但很容易被人忽视的细节点。 故推荐使用with语句进行文件操作，它将在with子代码块结束后自动关闭文件句柄。 with open(file=\"test.txt\", mode=\"rt\", encoding=\"utf-8\") as f: print(f.read()) 使用with语句还可以同时打开多个文件，示例如下，\\可进行换行： with open(file=\"test.txt\",mode=\"rt\",encoding=\"utf-8\") as f1,\\ open(file=\"test2.txt\",mode=\"rt\",encoding=\"utf-8\") as f2: data1 = f1.read() print (data1) data2 = f2.read() print (data2) 读写内容模式 t模式 当打开一个文件时，默认以*t模式打开。 t代表以文本方式读取文件内容，读取的都是字符。 with open(file=\"test.txt\", mode=\"rt\", encoding=\"utf-8\") as f: result = f.read(3) # ❶ print(result) ❶：指定读取的字符数量 b模式 如果以b模式打开文件，则读取到的都是字节。 若使用字节模式打开文件，则不存在字符编码的问题 with open(file=\"test.txt\", mode=\"rb\") as f: result = f.read(3) # ❶ print(result) # b'\\xe6\\xb5\\x8b' hans = result.decode(\"utf-8\") print(hans) # ❷ ❶：指定读取的字节数量 ❷：解码 读写操作模式 r模式 r代表只读，使用r模式打开文件时文件的指针将跑到最开始。 如果文件不存在将会抛出异常，并且只能使用读取相关的方法。 with open(file=\"test.txt\", mode=\"rb\") as f: print(f.readlines()) w模式 w模式代表只写，使用w模式打开文件时就相当于新建一个文件。 如果文件已存在将清空原本文件中所有的内容，如果文件不存在则创建新文件，并且只能使用写入相关的方法。 with open(file=\"test.txt\", mode=\"wb\") as f: data = \"你好世界\" f.write(data.encode(\"utf-8\")) a模式 a模式为追写模式，当文件不存在时创建新文件，只能执行写相关的操作。 当文件存在时则打开文件，文件指针放到最后，所以被称为追写模式。 强调 w 模式与 a模式的异同： 相同点：在打开的文件不关闭的情况下，连续的写入，新写的内容总会跟在前写的内容之后 不同点：以 a 模式重新打开文件，不会清空原文件内容，会将文件指针直接移动到文件末尾，新写的内容永远写在最后 with open(file=\"test.txt\", mode=\"ab\") as f: f.write(b'\\nnew line...') x模式 x模式与w模式都相同。 唯一不同的地方在于如果需要打开的文件已存在，x模式会抛出异常。 而w模式会新建一个同名文件并且删除掉旧文件。 with open(file=\"test.txt\", mode=\"xb\") as f: f.write(b'\\nnew line...') # FileExistsError: [Errno 17] File exists: 'test.txt' +模式 +这里是对 r w a 的一种扩展。 代表可读可写，但是打开文件后文件指针的位置还是依照 r w a 原本的位置，应该尽量少用+方法。 with open(file=\"test.txt\", mode=\"r+b\") as f: data = f.read() print(data) f.seek(0, 2) f.write(b\"A new line again\\n\") 文件指针 使用seek()函数可以对文件指针进行操作。 以下是seek()函数的签名： def seek(self, offset: int, whence: int = 0) -> int 注意，使用文件指针应该在*b模式下进行使用，它的移动将会按照字节进行移动。 如果是*t模式下，按照字符移动可能会出现某些错误。 参数 描述 offset 偏移量，负数代表向前移动指针，正数代表向后移动指针 whence 偏移位置，0代表起始位置，1代表当前位置，2代表结束位置 示例如下： with open(file=\"test.txt\", mode=\"rb\") as f: # ❶ print(f.tell()) # ❷ f.seek(2, 0) f.seek(10, 0) f.seek(20, 0) print(f.tell()) # ❸ f.seek(-2, 1) f.seek(-3, 1) f.seek(-4, 1) print(f.tell()) # ❹ # 0 # 20 # 11 ❶：注意，文件指针除了（0，0）和（0，2）外，其他都应该用b模式进行。 ❷：打印当前文件指针的位置 0 ❸：打印当前文件指针的位置 20 ❹：由于是相对定位，故可以累加。 20 - 9 ，文件指针在 11 循环读取 for循环 如果直接使用f.read()，当文件内容过于庞大时，这些内容全部会存放于Python程序的内存空间中。 会给内存带来极大的压力，故在文件较小时才使用f.read()，太大的话将使用其他解决方案，如下面的for循环进行读取： data = b\"\" with open(\"test.txt\", mode=\"rb\") as f: for line in f: # ❶ data += line print(data.decode(\"utf-8\")) ❶：直接读取f代表每次读一行，以\\n为单位 while循环 如果一个文件只有一行，如压缩版的前端代码。 在读取时则可使用while循环进行读取，示例如下： data = b\"\" with open(\"test.txt\", mode=\"rb\") as f: while 1: temp = f.read(512) data += temp if not len(temp): break print(data.decode(\"utf-8\")) 文件写入 内存写入 文本编辑器的原理是在打开一个文本文件时其中所有的内容都会加载并存放至内存中。 对该文本内容的修改实际上全部都是在修改内存中的数据，当修改完成后点击保存时才会将内存的数据重新写入至硬盘中。 你应该深有体会，打开一个特别大的文本文件时速度很慢，哪怕没做任何修改保存时速度也还是很慢，实际上就是这个原因导致的。 以下是模拟内存写入，打开文件后将“计算机”替换为“电脑”： data = \"\" # ❶ with open(file=\"BigFileTest.txt\", mode=\"rt\", encoding=\"utf-8\") as f: # ❷ while 1: temp = f.read(512) data += temp # ❸ print(data) # ❹ if not len(temp): # ❺ break print(\"读取完毕..\") data = data.replace(\"计算机\", \"电脑\") # ❻ with open(file=\"BigFileTest.txt\", mode=\"wt\", encoding=\"utf-8\") as f: # ❼ f.write(data) print(\"写入完毕..\") ❶：用于存放数据 ❷：r模式的指针默认放在0位置 ❸：代表每次读取512个字符 ❹：这里可以做其他操作 ❺：代表没有新的内容。 len(temp) == 0 ❻：模拟手动修改文件内容。将计算机修改为电脑，注意此时修改的是内存中的数据 ❼：读取后将Python应用程序中维护的data变量中的数据全部写入该文件。w模式会清空源文件的内容 硬盘时刷 文本编辑器的做法是在内部维护了一个变量，用于提供给用户修改内容。 这么做的好处就是用户可以在修改文件内容时能够查看到所有的文件内容，但是坏处是占用内存空间太大。 这里再介绍一种减少内存压力的方式。 注意：两种方式没有优劣之分，只有使用场景不同的区别，还是和上面一样的操作，将“计算机”替换为“电脑”。 import os with open(file=\"BigFileTest.txt\", mode=\"rt\", encoding=\"utf-8\") as f1, \\ open(file=\".BigFileTest.txt.swap\", mode=\"wt\", encoding=\"utf-8\") as f2: # ❶ for line in f1: line = line.replace(\"计算机\", \"电脑\") # ❷ f2.write(line) # ❸ print(\"操作完成..\") os.remove(\"BigFileTest.txt\") # ❹ os.rename(\".BigFileTest.txt.swap\", \"BigFileTest.txt\") # ❺ 这么做的坏处是没办法随时的修改内存中的变量数据，因为内存中根本没存文本文件内容。 只能按照设定好的程序走一遍，但是极大的节省了内存空间的占用。 ❶：以. 开头的文件代表隐藏文件。以swap结尾的文件代表交换文件（可以理解为临时文件） ❷：每次拿到和修改的只有line ❸：写入交换文件中 ❹：删除源文件 ❺：修改临时文件的名字。与源文件保持一致 操作方法 以下是文件操作中常用的方法： 方法 描述 read() 读取某个文件(全部内容)。也可指定大小，t模式的大小为字符单位，b模式为字节单位 readline() 读取一行文件内容 readlines() 读取所有文件内容并返回一个列表，以行割开 write() 写入一行数据，默认不会\\n需要手动换行 writelines() 写入一行数据，通过列表的方式写到文件里面 tell() 显示当前文件光标的位置 seek() 移动当前文件光标的位置(字节为单位，建议在b模式下使用) readable() 文件是否可读 writable() 文件是否可写 closed 文件是否关闭 encoding 如果文件打开模式是b,则没有该属性 flush() 立刻将文件内容从内存刷到硬盘（测试模式下使用） Python2-open() 由于Python2中不能使用encoding参数指定编解码的方式。所以我们看看在Python2中open()应该怎样使用： #!/usr/bin/env python2 # coding:utf-8 # import sys # reload(sys) # sys.setdefaultencoding('utf-8') # 设置默认的解码方式为 utf-8。如果这样操作就不用设置decode()了。 f = open(file=\"test.txt\",mode=\"rt\",) data = unicode(f.read().decode(\"utf-8\")) # unicode()将读取出的字符转为unicode字符存储于内存中。 print data f.close() Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-13 20:41:50 "},"Python/Python函数相关/summary.html":{"url":"Python/Python函数相关/summary.html","title":"Python函数相关","keywords":"","body":" 初识函数 使用函数 参数详解 命名空间 高阶函数 递归函数 匿名函数 内置函数 装饰器 迭代器 生成器 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-13 20:41:50 "},"Python/Python函数相关/初识函数.html":{"url":"Python/Python函数相关/初识函数.html","title":"初识函数","keywords":"","body":"函数 在编程语言中的函数不同于数学中的函数（function）。 不管是数学上的函数还是编程语言中的函数都是为了完成特定的某一功能而诞生的，他们的区别在于： 数学中的函数当输入的值是固定的情况下那么输出的值也一定是固定的。 它内部不允许原本输入的值状态发生改变。 编程语言中的函数则可以允许传入的值进行修改的。 如果按照数学函数的定义来做编程语言的函数，那么这种函数则被称为纯函数（pure function） 分类 在Python中，函数主要有两类： 内置函数（Built-in function） 自定义函数（Custom function） 如，id()、type()、print()等均属于内置函数，内置函数又被称为工厂函数。 内置函数的实现初衷是将一些经常使用的功能进行封装，并且同Python解释器一起提供给开发者，开发者开箱即用，不必关心底层的算法实现。 而自定义函数是指在内置函数无法完成需求的情况下，由开发人员去自己创作的为了满足特定的某一项功能的可重复使用的具体代码集合。 函数的特点 函数主要解决流式代码的2大问题： 代码冗余度高，程序的组织结构不清晰，可读性差 可维护性以及可扩展性差 函数的特点如下： 提供封装性，用户在外部不用关心内部如何实现 提供可重复调用，开发人员最大限度的减少了重复代码的实现 提升程序可读性，对特定的功能进行分类，使后期维护变的简单 举一个简单的例子，如果没有定义函数，要打印100次“hello world”则需要写一百行下面的代码： print(\"hello world\") print(\"hello world\") print(\"hello world\") print(\"hello world\") ... 而如果使用了函数，则只需调用100次函数即可： def func(): print(\"hello world\") func() func() func() ... 函数与方法 函数（function）与方法（method）都是一个具体功能的实现，它们本质都是一个东西。 区别在于函数允许大多数类型进行调用，而方法只允许特定类型进行调用。 如： id()：允许所有类型进行调用，因此被称为 “函数” format()：只允许str类型进行调用，因此被称为 “方法” 可调用性 函数和方法都是可调用的，如何判断一个对象是否可调用？ 可以使用内置函数callable()进行判断，如下所示，只需在callable()中传入函数名即可： >>> callable(print) True >>> callable(input) True Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-13 20:41:50 "},"Python/Python函数相关/使用函数.html":{"url":"Python/Python函数相关/使用函数.html","title":"使用函数","keywords":"","body":"函数使用 内置函数 内置函数是被内部定义好的一些函数，直接调用即可。 但是要严格传入函数所需要的参数，为此，你可以查看Python内置函数源代码，获得函数签名： def bin(*args, **kwargs): # real signature unknown; NOTE: unreliably restored from __doc__ \"\"\" Return the binary representation of an integer. >>> bin(2796202) '0b1010101010101010101010' \"\"\" pass 自定义函数 对于自定义函数来说，与对象声明相同，必须先定义后使用。 以下是语法格式： def 函数标识符(参数1, 参数2): # ❶ \"\"\"功能描述文档\"\"\" # ❷ 逻辑体代码块 # ❸ return 返回值 # ❹ ❶：def为关键字，用于定义一个函数。函数名即函数标识符，参照变量标识符的命名规则。参数是可选的，可以没有 ❷：功能描述文档可有可无，这是提供给用户的帮助信息，可以使用help()函数通过传入函数标识符获得该功能描述文档 ❸：函数的逻辑体代码块，用于具体实现某一功能 ❹：用于返回给用户需要的结果，如果不返回默认返回None 如何使用 函数标识符指向的是函数对象在内存空间的引用，也就是函数体代码块： >>> print 当加上括号后，将自动调用该函数，此时则根据函数签名需求传入对应参数即可： >>> print(\"hello world\") hello world 也就是说，函数标识符不加括号不会调用，只是拿到函数的引用，而加括号后才会执行函数内部的逻辑代码。 定义函数 无参函数 无参函数大多数情况下只是希望该函数单纯的做一点什么事情而并不需要该函数给返回一个结果。 常用于一段特定功能的重复调用，如我想在某种特定的情况下打印出WARNING信息，此时就可以定义一个无参函数： import sys import datetime def warning(): message = str.format( \"WARNING time: file:[{1}] - line:[{2}]\", datetime.datetime.now(), # ❶ sys._getframe().f_code.co_filename, # ❷ sys._getframe().f_back.f_lineno # ❸ ) print(message) warning() print(datetime.datetime.now()) # WARNING time: file:[/Users/Project/demo.py] - line:[13] ❶：获取当前时间 ❷：获取被调用函数所在模块文件名 ❸：获取被调用函数在被调用时所处代码行数 有参函数 函数的参数用于接收用户传入的对象，可以认为传入的对象是指“待加工原材料”。 当函数执行完成后，通过加工“原材料”将会返回一个加工后的“产品”。 以下示例中将计算2个值的相加结果： def add(x, y): res = x + y return res # ❶ result = add(1, 2) print(result) # 3 ❶：返回加工完成后的“产品”，该产品被外部使用result标识符进行接收 空函数 只定义函数名并未做具体实现的函数叫做空函数，空函数在逻辑构思中常被用到。 关键词：pass或者Ellipsis对象。 如下所示： def add(x, y): pass # ❶ def sub(x, y): ... # ❷ ❶：代表省略 ❷：Ellipsis对象，代表省略，仅在Python3中适用 函数调用 语句形式 在函数标识符后加上括号进行调用即可： >>> print(\"hello world\") hello world 表达式形式 表达式形式可以将函数返回的对象赋值给一个标识符，如下所示： def add(x, y): res = x + y return res result = add(1, 2) print(result) # 3 也可以直接对这个函数返回的对象进行操作，如下所示： def add(x, y): res = x + y return res result = add(1, 2) * 10 print(result) # 30 参数调用形式 函数可以作为参数传递给其他函数： def add(x, y): res = x + y return res result = add(add(1, 2), 3) # ❶ print(result) # 6 ❶：相当于add(3, 3) 函数返回值 默认返回值 Python中的函数一定具有返回值。 如果没有显式的使用return关键字指定返回值，则默认会返回None。 def add(x, y): ... result = add(1, 2) print(result) # None return返回值 return有2个作用： 返回函数的执行结果，可以返回1个，也可以返回多个，若返回多个则以元组形式返回 跳出所有的循环体（如果在多层的循环中使用return，将直接跳出所有循环，并且将结果进行返回） 如下示例， 获得指定范围区间的累加结果： def accumulate(start, stop): res = 0 for i in range(start, stop + 1): res += i return res result = accumulate(1, 100) print(result) # 5050 返回多个值时，将以元组形式进行返回，如下示例中输入一个ASCII码表的字符，返回其ASCII码表中对应的大小写编号（a - z具有2个编号，符号只有1个编号）： def getAscii(char): asciiTable = {chr(i) : i for i in range(0, 128)} lowerKey = char.lower() capitalKey = char.upper() return asciiTable[lowerKey], asciiTable[capitalKey] lowInt, capitalInt = getAscii(\"a\") print(lowInt, capitalInt) # 98 66 函数执行 函数必须先定义后使用，否则无法执行： func() def func(): print(\"run ...\") # NameError: name 'func' is not defined 嵌套调用 Python是解释性语言，解释一行执行一行。 当碰见def关键字开头的语句，内部会检测一下该代码块的语法，如果没有出现问题则代表该函数定义好了。 只有碰到函数名加括号的情况下才会去执行该函数。 所以，函数也可以进行嵌套调用，不过我个人不太喜欢这种调用方法，我更倾向于传参调用，在代码维护时更加的方便： def func1(): print(\"run ... func1\") def func2(): print(\"run ... func2\") func1() print(\"run stop\") func2() # run ... func2 # run ... func1 # run stop 内部逻辑 当定义一个函数时，会发生3件事情： 申请内存空间，保存函数体代码 将内存地址编号绑定给函数标识符（函数名） 定义函数并不会执行函数体内部代码，但是会检测函数体的语法 当调用一个函数时，也会发生3件事情： 通过函数标识符找到函数在内存中存在的位置 加上括号是一种语法格式，代表执行函数体内部的代码 调用系统调用栈，创建一个函数的栈帧片段并压入栈中 我们以函数嵌套的例子来分析它的定义和执行流程： def func1(): print(\"run ... func1\") def func2(): print(\"run ... func2\") func1() print(\"run stop\") func2() 定义函数 在Python解释器解释到到第1行、第3行的时候，会加载函数体代码，检查函数体语法，若无误则将其编译为字节码： 随后会加载函数标识符，func1与func2，并且会在内存中将函数体代码进行保存，让函数标识符与在内存中保存的函数体代码进行绑定： 如上图所示，现在还未开始执行函数，内存中已有func1，func2了。 执行函数 开始分析第9行的执行函数func2()，当Python解释器发现函数标识符加了一个括号后，知道这是要调用函数，会顺着函数名找到在内存中的函数体代码： 当开始真正执行func2()函数体代码后，系统调用栈会创建出一个独一无二的函数栈帧，函数栈帧会将函数的字节码、谁调用的它、以及函数内部定义的变量（如参数）等关键信息进行保存。 在第6行，发现又执行func1()，这个func1()是在func2()内部执行的所以Python解释器会在func2()栈帧的基础上运行func1()的代码，同理也会创建func1()函数的栈帧： 当func1()执行完毕后，发现没有返回值，则加载常量None并做为默认的返回结果，此时会一并弹出func1()的栈帧，常量None将返回给func1()的调用处： 然后func2()也执行完毕，发现没有返回值，加载常量None并做为默认的返回结果，此时会一并弹出func2()的栈帧，常量None将返回给func2()的调用处： Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-13 20:41:50 "},"Python/Python函数相关/参数详解.html":{"url":"Python/Python函数相关/参数详解.html","title":"参数详解","keywords":"","body":"形参与实参 什么是传参 将需要被处理的对象传递给函数的行为，被称为传参。 形参介绍 在定义函数时，函数需要使用1个或者多个标识符来接收到外部传递进的对象。 这个标识符就是形参： def func(x, y, z): \"\"\" :param x: 形参x :param y: 形参y :param z: 形参z :return: None \"\"\" ... 可以理解为形参是函数（工厂）的预留位置，你将“原材料”放在这些位置上才能被工厂所接收到。 实参介绍 在调用函数时，外部向函数传入的对象则被称为实参。 def func(x, y, z): \"\"\" :param x: 形参x :param y: 形参y :param z: 形参z :return: None \"\"\" ... # 传入实参1，2，3 func(1, 2, 3) 可以理解为实参是待加工的“原材料”， 需要将这些“原材料”放到指定的工厂预留位置上（形参）才能被工厂所接收。 两者关系 由于Python中一切皆引用，故实参传递给形参的也就是同一个对象，这种传参被称为引用传参。 2者总结关系有3点： 在函数调用时，实参将对象传递给形参后，对象的引用计数会+1 在函数内部，可以通过形参访问到该对象 形参与对象的绑定关系在函数调用结束后就会被取消掉 下面示例将验证形参和实参引用的都是同1个对象： x = 1 def func(x): print(id(x)) func(x) print(id(x)) # 4518684720 # 4518684720 形参定义 位置参数 函数定义时从左至右依次排列的没有特殊意义的形参被称为位置形参，位置形参必须被对象传入，多一个少一个都不行。 如果传入的不够、或者传入的过多，将会抛出异常： def func(x, y, z): ... 传少了： func(1) # TypeError: func() missing 2 required positional arguments: 'y' and 'z' 传多了： func(1, 2, 3, 4) # TypeError: func() takes 3 positional arguments but 4 were given 默认参数 默认形参是指可以不用被传递对象的形参，它拥有1个默认的对象。 如果调用函数时没有传入对象，则使用该默认的对象 如果调用函数时传入了1个对象，则使用接收到的对象 需要注意在定义默认形参时必须放在位置形参后面，否则会抛出异常。 def func(x, y, z=3): print(x, y, z) func(1, 2) func(\"A\", \"B\", \"C\") # 1 2 3 # A B C 传参方式 位置传参 如果是位置形参，则实参传入对象时必须严格按照形参的位置顺序、形参的总体数量进行传入。 如果传入的不够、或者传入的过多，将会抛出异常： def func(x, y, z): ... 传少了： func(1) # TypeError: func() missing 2 required positional arguments: 'y' and 'z' 传多了： func(1, 2, 3, 4) # TypeError: func() takes 3 positional arguments but 4 were given 关键字传参 使用位置传参时，我们要牢记形参的位置，这样比较麻烦。 可以直接通过 key = value 的形式进行传入，避免了需要记住形参位置的繁琐步骤，但是关键字传参必须放置在位置传参后面，也是个人比较推崇的一种传参方式： def func(x, y, z=3): print(x, y, z) func(y=2, x=1, z=3) func(1, z=3, y=2) # 1 2 3 # 1 2 3 *与**语法使用 *的形参接收 *语法用在形参上，代表该形参可以接收任意数量的位置传参对象。 该形参将会变成一个元组形式，接收所有的位置传参对象，这种形参必须定义在位置形参与默认形参的后面： def func(x, y=2, *args): print(x, y, args) func(1, 2, 3, 4, 5, 6, 7, 8, 9) # 1 2 (3, 4, 5, 6, 7, 8, 9) **的形参接收 **语法用在形参上，代表该形参可以接收任意数量的关键字传参对象。 该形参将会变成一个字典形式，接收所有的关键字传参对象，这种形参必须定义在位置形参与默认形参以及*形参的后面： def func(x, y=2, *args,**kwargs): print(x, y, args, kwargs) func(1, 2, 3, 4, 5, 6, 7, 8, 9, a=ord(\"a\"), b=ord(\"b\"), c=ord(\"c\")) # 1 2 (3, 4, 5, 6, 7, 8, 9) {'a': 97, 'b': 98, 'c': 99} *的实参传入 通过*语法，我们可以将1个容器序列根据位置传参的方式把其中的数据项对象传递给形参，如下所示： def func(x, y, z): print(x, y, z) func(*(1, 2, 3)) # 1 2 3 **的实参传入 通过**语法，我们也可以将1个字典根据关键字传参的方式把字典中的value对象传递给形参，如下所示： def func(x, y, z): print(x, y, z) func(**{\"x\": 1, \"y\": 2, \"z\": 3}) # 1 2 3 *args与**kwargs *形参通常命名为*args，这是一种约定的俗称。 同理，**形参则被命名为**kwargs。 指定传入方式 形参中，如果存在一个*名字的特殊标识，则该标识不用传递对象。 该标识是规定了哪些形参必须是接收位置传入的对象、哪些形参是必须接收关键字传入的对象，如下所示： def func(a, b=2, *, c=3, d): # ❶ print(a, b, c, d) func(1, d=4) ❶：在 *左边的都是位置传入，在*右边的都是关键字传入，在*右边的参数也被称为命名关键字参数 a：位置传入，不是默认参数，则必须通过位置传参的方式传入对象 b：位置传入，是默认参数，可以不用通过位置传参的方式传入对象 c：关键字传入，不是默认参数，则必须通过关键字传参的方式传入对象 d：关键字传入，是默认参数，可以不用通过关键字传参的方式传入对象 形参的定义顺序 形参的定义顺序如下所示： 位置形参 -> 默认形参 -> *args -> **kwargs 示例演示： def func(a, b, c=\"c\", *args, **kwargs): print(\"\"\" position params: {} {} default params: {} * params:{} ** params:{} \"\"\".format(a, b, c, args, kwargs)) func(\"A\", \"B\", \"C\", 1, 2, 3, 4, 5, k1=\"v1\", k2=\"v2\") # position params: A B # default params: C # * params:(1, 2, 3, 4, 5) # ** params:{'k1': 'v1', 'k2': 'v2'} 实参的传入顺序 实参的传入顺序牢记位置传参在前，关键字传参在后即可。 或者统一使用关键字传参，示例如下： def func(a, b, c, d, e, f): pass func(\"A\", *[\"B\", \"C\"], d=\"D\", **{\"e\": \"E\", \"f\": \"F\"}) # eq： # func(\"A\", \"B\", \"C\", d=\"D\", e=\"E\", f=\"F\") 嵌套调用中*与** 当函数2作为函数1的一层外包装，我们想调用函数2的时候实际上是调用的函数1，并且参数也要完整的传递过去，该怎么做呢？ Ps：这其实是装饰器的一个前瞻知识点 def func(x, y, z): print(x, y, z) def wrapper(*args, **kwargs): func(*args, **kwargs) # ❶ ❷ wrapper(1, y=\"v1\", z=\"v2\") # 1 v1 v2 ❶：实参用 * 和 ** 拆分开， * 是位置传参，**是关键字传参 ❷：args = (1)，kwargs = {\"y\":\"v1\",\"z\":\"v2”}，然后再通过解构进行传递给func函数，func相当于接收了 func(1, y=“v1”, z=“v2”) 函数标注 Python3.5之后新增了函数标注（function annotation），即类型提示功能如下所示，仅做提示，并不会限制传递参数时的类型： def add(x: int or float, y: int or float) -> int or float: # ❶ print(x) print(y) return x + y ❶：->代表返回值，返回int或者float类型 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-07-01 16:08:38 "},"Python/Python函数相关/命名空间.html":{"url":"Python/Python函数相关/命名空间.html","title":"命名空间","keywords":"","body":"Python之禅 传奇的Python核心开发者，Tim Peters为我们总结了Python核心思想点，收录在了内置模块this中： >>> import this The Zen of Python, by Tim Peters Beautiful is better than ugly. Explicit is better than implicit. Simple is better than complex. Complex is better than complicated. Flat is better than nested. Sparse is better than dense. Readability counts. Special cases aren't special enough to break the rules. Although practicality beats purity. Errors should never pass silently. Unless explicitly silenced. In the face of ambiguity, refuse the temptation to guess. There should be one-- and preferably only one --obvious way to do it. Although that way may not be obvious at first unless you're Dutch. Now is better than never. Although never is often better than *right* now. If the implementation is hard to explain, it's a bad idea. If the implementation is easy to explain, it may be a good idea. Namespaces are one honking great idea -- let's do more of those! Python之禅 by Tim Peters 优美胜于丑陋（Python 以编写优美的代码为目标） 明了胜于晦涩（优美的代码应当是明了的，命名规范，风格相似） 简洁胜于复杂（优美的代码应当是简洁的，不要有复杂的内部实现） 复杂胜于凌乱（如果复杂不可避免，那代码间也不能有难懂的关系，要保持接口简洁） 扁平胜于嵌套（优美的代码应当是扁平的，不能有太多的嵌套） 间隔胜于紧凑（优美的代码有适当的间隔，不要奢望一行代码解决问题） 可读性很重要（优美的代码是可读的） 即便假借特例的实用性之名，也不可违背这些规则（这些规则至高无上） 不要包容所有错误，除非你确定需要这样做（精准地捕获异常，不写 except:pass 风格的代码） 当存在多种可能，不要尝试去猜测 而是尽量找一种，最好是唯一一种明显的解决方案（如果不确定，就用穷举法） 虽然这并不容易，因为你不是 Python 之父（这里的 Dutch 是指 Guido ） 做也许好过不做，但不假思索就动手还不如不做（动手之前要细思量） 如果你无法向人描述你的方案，那肯定不是一个好方案；反之亦然（方案测评标准） 命名空间是一种绝妙的理念，我们应当多加利用（倡导与号召） 而今天我们主要探索的内容就是这最后一句，命名空间。 以下内容将围绕Python之禅最后一句话来进行逐一解惑。 Tim Peters是一位高产的Python开发者，在Python1.0版本之前就已经贡献出大量的代码，如li.sort()的排序算法TimSort就是Tim Peters所贡献，并且最终在Python2.x版本中进行使用 NameSpaces 命名空间即存储所有标识符（变量名、函数名、类名）的地方。 它本身是一种虚拟的概念，实际上并不存在。 命名空间分为3大类： 内置命名空间（Builtin NameSpaces） 全局命名空间（Global NameSpaces） 局部命名空间（Local NameSpaces） 不同的命名空间，存储的标识符范畴也不同，如下所示： 内置命名空间：存储Python解释器自带的标识符 全局命名空间：存储未在类、函数、方法中定义的标识符 局部命名空间：在调用类、函数、方法时产生的标识符 我们以一个代码和一幅图来举例： name = \"Jack\" age = 18 gender = \"male\" def add(x , y): res = x + y return res def sub(x, y): res = x - y return res Builtin NameSpaces 内置命名空间： 存放的标识符：Python解释器自带的函数标识符、变量标识符、类标识符等，如print、input、open等... 生命周期：Python解释器启动时产生，关闭时销毁 允许的数量：至多1个 示例演示： >>> print >>> input >>> open Global NameSpaces 全局命名空间： 存放的标识符：未在类、函数、方法中定义的标识符 生命周期：Python脚本文件执行时产生，执行完毕时销毁 允许的数量：至多1个 示例演示： name = \"Jack\" age = 18 gender = \"male\" def mathFunctionSet(method, x, y): def add(x, y): res = x + y return res def sub(x, y): res = x - y return res methodNameMapping = { \"add\":add, \"sub\":sub } return methodNameMapping[method](x,y) 上述示例中共有1个全局命名空间，存储的标识符有： name age gender # 变量标识符 mathFunctionSet # 函数标识符 Local NameSpaces 局部命名空间： 存放的标识符：在调用类、函数、方法时产生的标识符 生命周期：对于函数的局部命名空间来说，函数调用时存活，调用完毕则销毁 允许的数量：可以有多个局部命名空间，取决于内存大小 示例演示： name = \"Jack\" age = 18 gender = \"male\" def mathFunctionSet(method, x, y): def add(x, y): res = x + y return res def sub(x, y): res = x - y return res methodNameMapping = { \"add\":add, \"sub\":sub } return methodNameMapping[method](x,y) 上述示例中共有3个局部命名空间，如下所示： mathFunctionSet的局部命名空间存储的标识符： method x y add sub methodNameMapping add局部命名空间存储的标识符： x y res sub局部命名空间存储的标识符: x y res 顺序相关 加载和销毁顺序 加载顺序：内置命名空间 -> 全局命名空间 -> 局部命名空间 销毁顺序：局部命名空间 -> 全局命名空间 -> 内置命名空间 命名空间封闭性 在全局命名空间中无法访问局部命名空间定义的标识符，但是局部命名空间中可以访问全局命名空间的标识符，如下所示： globalName = \"global\" def function(): localName = \"function\" print(localName) function() print(localName) # function # NameError: name 'localName' is not defined 当然，内置命名空间是在哪里都可以进行访问。 标识符查找顺序 先在自己的命名空间中找，找不到就往定义自己的命名空间中找，最后查找内置命名空间。 如下代码示例： name = \"global\" def outer(): name = \"outer\" inner() # ❷ def inner(): print(name) # ❸ outer() # ❶ 首先我们是在全局命名空间中定义了outer()函数的标识符、inner()函数的标识符以及name变量标识符。 ❶：运行outer()函数 ❷：运行inner()函数 ❸：inner()中查找name，inner()的局部命名空间中没有name标识符，往定义自己的命名空间找，即到全局命名空间，最终找到name标识符 标识符的覆盖特性 如果全局/局部命名空间与内置命名空间中的标识符发生冲突，则最先查找到全局/局部命名空间中的标识符。 这也是为什么在第一章的时候就说到标识符的命名应该避免关键字，示例如下： print(callable(input)) # ❶ input = \"..\" print(callable(input)) # ❷ # True # False ❶：input此时引用的是内置命名空间的input()函数，所以可调用 ❷：全局命名空间中已经定义了input，此时的input引用的是全局命名空间中的字符串“..”，所以不可调用 预先检测的标识符 我们来看一个有趣的例子： x = 1 def function(x): print(x) x = 1 function(x) # 1 将这个代码稍微改动： x = 1 def function(): print(x) x = 1 function() # UnboundLocalError: local variable 'x' referenced before assignment 按理说，例子2中的x会引用全局命名空间中的x，那么为何会抛出异常呢？ 我们说过，在初始化函数时，会预先检测其中的语法是否出现错误： 例子1中的x最早出现在形参中，也就是说第3行的形参中定义了x，所以下面再使用x时是没有任何问题的 例子2中的x是定义在第5行，但是在第4行里就进行了使用，违反了对象必须先声明后使用的原则，故抛出异常 方法介绍 global引入 一个例子 先看一个简单的例子吧： x = 1 # ❶ def function(): x = 3 # ❸ print(x) # ❹ function() # ❷ print(x) # ❺ # 3 # 1 图示如下： ❶：全局命名空间定义了变量x，指向内存中的1 ❷：开始调用函数function() ❸：函数function()的局部命名空间中也声明了x，并且指向内存中的3 ❹：打印x，打印语句在函数内部，所以先从function()的局部命名空间中找x，这个x指向的3 ❺：打印x，打印语句在函数外部，所以在全局命名空间中找x，这个x指向的1 所以最后的结果是：3、1 方法使用 gloabl关键词可以在函数中使用，该关键词后面出现的标识符在函数内部也可以进行使用，但是该标识符的对象会指向全局命名空间中的对象。 我们对上面例子加上一句代码，结果就变的不同了： x = 1 # ❶ def function(): global x # ❷ x = 3 # ❸、❹ print(x) # ❺ function() print(x) # ❻ # 3 # 3 如下图所示： ❶：全局命名空间定义了变量x，指向内存中的1 ❷：在函数function()执行时，引入了外部的x，指向内存中的1 ❸、❹：将x重新指向3 ❺：打印x，打印语句在函数内部，所以先从function()的局部命名空间中找x，这个x就是外部的x，指向1 ❻：打印x，打印语句在函数外部，所以在全局命名空间中找x，这个x当然也指向的1 nonlocal引入 一个例子 先看一个简单的例子吧： x = 1 def outer(): x = 2 def inner(): x = 3 print(x) inner() print(x) outer() print(x) # 3 # 2 # 1 这个参照上面的global引入图示。 第1个print()是在inner()函数的局部命名空间中打印x，所以打印了3 第2个print()是在outer()函数的局部命名空间中打印x，所以打印了2 第3个print()是在全局命名空间中打印x，所以打印了3 方法使用 nonlocal关键字与global使用相同，不同的是gloabl引用的是全局命名空间中的标识符对象，而nonlocal则是引用上层局部命名空间中的标识符对象。 将代码稍微改动，于是你便发现结果又变了： x = 1 def outer(): x = 2 def inner(): nonlocal x print(x) inner() print(x) outer() print(x) # 2 # 2 # 1 第1个print()是在inner()函数的局部命名空间中打印x，该x指向的是上层局部命名空间中的x，所以打印了2 第2个print()是在outer()函数的局部命名空间中打印x，所以打印了2 第3个print()是在全局命名空间中打印x，所以打印了3 LEGB 我们在nonlocal例子中看见了一共有4个命名空间，分别如下： 内置命名空间 全局命名空间 函数outer的局部命名空间 函数inner的局部命名空间 这样划分会显得有些杂乱，所以可以将它用新的命名方式来表示，总计划分为4层： B-Builtin(Python)：Python解释器的内置命名空间，用B来表示 G-Global(module)；函数定义所在模块（文件）的命名空间，即全局命名空间，用G来表示 E-Enclosing function locals：外部嵌套函数的命名空间，即outer的局部命名空间，用E来表示，因为它是封闭的 L-Local(function)：被嵌套的函数命名空间，即inner的局部命名空间，用L来表示，即代码执行最里层的本地空间 作用域 在很多其他的教程中，可能会有作用域的划分，将3个命名空间分为了2个作用域： 全局作用域：包含内置命名空间与局部命名空间 局部作用域：即局部命名空间 这是一种比较粗暴直白的划分，并没有命名空间的划分来的详细，本质都是1个东西，这里不再举例。 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-13 20:41:50 "},"Python/Python函数相关/高阶函数.html":{"url":"Python/Python函数相关/高阶函数.html","title":"高阶函数","keywords":"","body":"高阶函数 在Python中函数是一等公民，它与普通的数据项对象并没有什么区别，唯一的区别可能在于函数是能被调用的吧。 这意味着，Python中的函数可以做下面的事情： 可以赋值 可以将一个函数对象传递给另一个函数对象的形参 一个函数中可以返回另一个函数 可以将函数当做容器类型中的一个数据项元素 赋值 函数标识符本来仅是一个贴纸，指向了函数体代码在内存中的位置。 那么我们可以再加上一个贴纸标识符，让它与函数标识符指向内存中相同的位置，如下所示： def function(): print(\"function ...\") func = function func() # function ... 传参 可以将一个函数对象传递给另一个函数对象的形参，如下所示： def outer(func): print(\"start\") func() print(\"stop\") def inner(): print(\"inner ..\") outer(inner) # start # inner .. # stop 返回值 一个函数中可以返回另一个函数，这样的做法常用于嵌套定义函数。 Ps：嵌套定义函数和嵌套调用函数还是有所不同的，嵌套定义的2个函数不在同一命名空间中进行声明，而是具有包含关系，而嵌套调用的函数大部分情况在同一命名空间中进行定义声明。 def outer(): def inner(): print(\"inner\") return inner func = outer() func() # inner 因为函数具有封装线，故外部无法访问内部，但是如果E层函数主动返回L层函数，那么外部就可以拿到L层的函数进行调用。 数据项 函数可以作为容器对象中的数据项： def f1(): print(\"f1\") def f2(): print(\"f2\") def f3(): print(\"f3\") li1 = [f1, f2, f3] for func in li1: func() # f1 # f2 # f3 应用实例 函数的嵌套调用 函数的嵌套调用会很常见。 如果有2个函数，我们可以将2个函数的功能进行分类： 函数1主要负责为外部使用者提供入口，而不负责逻辑关系的处理 函数2主要负责内部逻辑关系的处理，对于外部调用者而言它是隐藏的 如下所示，我们使用2个函数来实现从1个容器类型中拿出最大数据项的功能： def getMaxValue(*args): \"\"\"interface\"\"\" currentMaxItem = args[0] for item in args[1:]: currentMaxItem = computeMaxValue(item, currentMaxItem) return currentMaxItem def computeMaxValue(x, y): \"\"\"logic\"\"\" return x if x > y else y result = getMaxValue(*[8, 1, 2, 3, 5, 4]) print(result) # 8 基于函数的封装 我们只需要在函数内部定义函数，将1堆类似功能的函数封装在1个抽象函数中即可。 如下我们定义了1个数学工具类函数，它将包含了求长方形、长发体的面积： def mathFormula(select, length, width, height=None): \"\"\"长方形，求面积输入长宽，求体积输入长宽高\"\"\" def area(length, width): \"\"\"长方形面积\"\"\" return length * width def bulk(length, width, height): \"\"\"长方体体积\"\"\" return length * width * height if select == 1: return area(length, width) elif select == 2: return bulk(length, width, height) else: print(\"输入有误\") res = mathFormula(select=1, length=20, width=20) print(res) # 400 基于函数的字典 修改学生信息的一个小例子，如下所示： studentMessage = { \"1\": {\"name\": \"Tom\", \"gender\": \"male\", \"age\": 18, \"height\": 192, \"weight\": 140}, \"2\": {\"name\": \"Jack\", \"gender\": \"male\", \"age\": 17, \"height\": 172, \"weight\": 120}, \"3\": {\"name\": \"Kelly\", \"gender\": \"female\", \"age\": 20, \"height\": 168, \"weight\": 130}, } def check(): \"\"\"查\"\"\" for item in studentMessage: print(\"学生编号:{0}\".format(item)) for key, value in studentMessage[item].items(): print(\"{0: >10} | {1: Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-13 20:41:50 "},"Python/Python函数相关/递归函数.html":{"url":"Python/Python函数相关/递归函数.html","title":"递归函数","keywords":"","body":"递归函数 递归的特性 递归（recursion）是一种函数的调用方式，简而言之就是自己调用自己。 递归可以将一个大规模的问题分解成更小的相同问题，经过持续分解到最后问题规模小到可以用非常简单直接的方式来解决，或者将一个问题拆分成不同的各个部分，达到分而解决分而治之的目的。 一个递归函数必须要满足3要素： 必须有一个基本结束条件 必须能改变问题规模 必须调用自身 如下所示，这就是一个标准的递归函数： def function(count): if count: print(count) function(count=count - 1) return function(5) # 5 # 4 # 3 # 2 # 1 回溯与递推 函数递归必然经历2个阶段，一个是回溯阶段，一个是递推阶段： 回溯：函数不断递归调用自身时的阶段被称为回溯阶段 递推：当函数退出递归调用时的阶段被称为递推阶段 下面是一个问姓名的问题，可以非常直白的阐述回溯和递推的2个概念。 首先，你问A多少岁，A会回答你他比B大10岁，然后你又问B多少岁，B会回答你它比C大10岁... 这样直至E，E说他的年龄是18岁，最后问A多少岁？ 如上图所示，当你问A年龄的时候，回溯阶段开始。 而当你得知E的年龄后，递推阶段开始，根据E反推出A年龄的过程即递推的过程。 代码表现形式如下： def getAge(n): if n == 1: return 18 return getAge(n - 1) + 10 a = getAge(5) print(a) # 58 实例练习 数据项提取 有1个不知道维度的列表，现在要将它转换为1维列表，并且按照升序进行排序： oldList = [10, 1.2, [3, 345, 2.2, [15, [88.6, [78, [89.3, 99, [50]]]]]]] newList = [] def listSort(li): for i in li: if isinstance(i, list): listSort(i) else: newList.append(i) newList.sort() listSort(oldList) print(newList) # [1.2, 2.2, 3, 10, 15, 50, 78, 88.6, 89.3, 99, 345] 爬楼梯问题 有1个n阶的楼梯，每次可以爬1个台阶或者2个台阶，求解有多少种方法爬完整个楼梯。 def climbTheStairs(n): if n == 1: return 1 # ❶ if n == 2: return 2 # ❷ return climbTheStairs(n - 1) + climbTheStairs(n - 2) # ❸ print(climbTheStairs(3)) # 3 ❶：只有1个台阶，就只有1种走法，一次走1步 ❷：只有2个台阶，就只有2中走法，一次走1步或者一次走2步 ❸：将1次走1步的算出来，将1次走2步的算出来进行相加 递归与while 递归与while循环有一些类似之处，比如都要设置结束条件，但是两者不可一概而论。 如果一个问题规模不被确定，使用递归是最好的方案。 而如果一个问题的规模已被确定，则可以使用while循环进行解决。 但是递归要比while循环的效率更加的低下，因为递归的过程中会进行函数的调用，而函数调用则必定会对内存造成更大的压力，这来源于系统调用栈的栈帧会跟随每一次递归而不断的生成。 递归的深度 系统调用栈栈帧的生成不能毫无限制，所以Python对递归的深度进行了最大1000层的限定。 你可以随时修改这个层次，但是如果问题规模过大导致递归层次过多，则可能发生爆内存的情况，因为每一次的栈帧都会保存在内存中，以下是修改递归最大深度限制的方法： >>> import sys >>> sys.setrecursionlimit(100000) # ❶ >>> sys.getrecursionlimit() # ❷ 100000 ❶：修改最大默认递归层次为10000层 ❷：获取当前最大的递归层次 尾递归优化 递归函数中，每一次的栈帧生成都是相同的。 每一个递归函数的栈帧都拥有相同的调用方（自身）、拥有相同的字节码（相同的函数）、用于相同的命名空间（标识符）。 由于栈帧在系统调用栈中会占用大量的内存，对于某些语言如Java而言，会针对递归函数做一些优化，具体是指如果1个函数是进行递归调用，则只生成1个栈帧。 这种优化策略能够极大的减少内存空间的占用，也被称之为尾递归优化。 遗憾的是，Python并未实现尾递归优化。 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-13 20:41:50 "},"Python/Python函数相关/匿名函数.html":{"url":"Python/Python函数相关/匿名函数.html","title":"匿名函数","keywords":"","body":"匿名函数 匿名函数即没有名字的函数，最早出现在LISP语言中，Python对其进行了引用。 匿名函数的作用就是在不丧失代码可读性的前提下为精简代码提供的一种方式，以下是定义匿名函数的语法，通过lambda关键字进行定义。 注意！函数不管有名没名，都必须先定义后使用 语法如下： lambda 形参1, 形参2 ... : 返回值 # ❶ ❷ ❶：形参可以有多个，也可以没有 ❷：返回值不用跟return，直接写逻辑语句即可，将会自动的把逻辑语句的结果进行返回 定义和使用匿名函数的实际示例，求2个数的和： res = (lambda x, y : x + y)(1, 2) print(res) 匿名函数常用于定义一些非常简单的逻辑，不支持多行，因此要尽量写的简洁易懂。 使用方式 为匿名函数取名 匿名函数也可以通过一个标识符进行命名，但是一般都不会这样做： add = lambda x, y : x + y res = add(1, 2) print(res) # 3 自执行和自销毁 自执行函数即定义了匿名函数之后就立刻加括号调用，这种函数只会运行一次。 并且由于没有标识符的引用绑定关系，故使用完成后就会被GC机制所立即回收掉： res = (lambda x, y : x + y)(1, 2) # ❶ print(res) # 3 ❶：自执行的匿名函数必须在括号中进行定义 内置函数搭配使用 匿名函数常用于与内置函数进行搭配使用，如下将使用内置函数max()搭配匿名函数求得下列薪资最高的人员名字： salaries = { 'Ken': 3000, 'Tom': 7000, 'Jack': 2000 } name = max(salaries, key=lambda k: salaries[k]) # ❶ print(name) ❶：max()函数的key参数可指定1个函数，此时函数的返回结果就是本次求最大值的对比条件，这个例子就是指定薪资作为对比条件 常用搭配函数 lambda表达式与一些函数配合，才能发挥出最大的威力。 Python中出名的诸如map()、filter()、reduce()函数等均来自Lisp语言的设计，它们实在是太方便了，其实说到底一门优秀的语言必定大量借鉴了其他语言的优秀特性。 max()与min() max()函数用于从1个可迭代对象中返回最大的数据项，而min()是返回最小的，其他都一样。 max()函数签名如下： def max(*args, key=None): pass 参数详解： args：一个可迭代对象，拥有1个形参 key：传入1个可调用对象（通常是指函数），指定本次的大小对比方式，默认是根据数据项值本身对比 默认比对是比对的值本身，如果是字典则拿key的值进行比对，以下示例中，由于C的ASCII码比A大，所以返回了C： dic = {\"A\": 100, \"B\": 50, \"C\": 20} res = max(dic) print(res) # C 传入参数key，修改对比方式为字典的value，那么最后A的value最大，故返回A： dic = {\"A\": 100, \"B\": 50, \"C\": 20} res = max(dic, key=lambda k:dic[k]) print(res) # A 手动实现max()函数： from collections.abc import Iterable def customizeMax(*args, key=None): def default(args): \"\"\"默认对比规则\"\"\" it = iter(args) if not isinstance(args[0], Iterable) else iter(args[0]) currentMaxItem = next(it) for item in it: if currentMaxItem map() map()函数会从一个可迭代对象中依次取出1个数据项，并且会按照指定函数对数据项进行处理，处理完成后生成新的map可迭代对象并返回该map可迭代对象。 map()函数签名如下： def __init__(self, func, *iterables): pass 参数详解： func：一个可调用对象（通常是指函数），拥有1个形参，对iterables的数据项进行遍历并将返回值加入至新的map容器中，迭代完成后返回新的map容器 iterables：一个可迭代对象 其实map()能做的推导式都能做，如将整个可迭代对象中的数据项+100，并返回新的可迭代对象： newMapObject = map(lambda x:x+100, range(10)) print(list(newMapObject)) newList = [(lambda x:x+100)(i) for i in range(10)] print(newList) # [100, 101, 102, 103, 104, 105, 106, 107, 108, 109] # [100, 101, 102, 103, 104, 105, 106, 107, 108, 109] 手动实现map()函数： from collections.abc import Iterable def customizeMap(func, *iterables): it = iter(iterables) if not isinstance(iterables[0], Iterable) else iter(iterables[0]) for item in it: yield func(item) print(list(customizeMap(lambda x:x + 100, range(10)))) # [100, 101, 102, 103, 104, 105, 106, 107, 108, 109] filter() filter()函数会从一个可迭代对象中依次取出1个数据项，并且会按照指定函数对数据项进行筛选，符合条件的数据项加入新的filter对象中，不符合条件的数据项会直接丢弃，当遍历完整个可迭代对象后会返回新的filter对象。 filter()函数签名如下： def __init__(self, function_or_None, iterable): pass 参数详解： function_or_None：一个可调用对象（通常是指函数），拥有1个形参，指筛选条件，如果是None则筛选条件，此时会按照数据项本身的布尔值进行筛选 iterable：一个可迭代对象 其实filter()能做的推导式都能做，如遍历整个容器对象，将是偶数的数据项筛选出来： newFilterObject = filter(lambda x: x % 2 == 0, range(10)) print(list(newFilterObject)) newList = [i for i in range(10) if i % 2 == 0] print(newList) # [0, 2, 4, 6, 8] # [0, 2, 4, 6, 8] 手动实现filter()函数： def customizeFilter(function_or_None, iterable): it = iter(iterable) if function_or_None is None: for item in it: # 若没有指定筛选函数，则按照数据项本身的布尔值进行筛选 if item: yield item for item in it: res = function_or_None(item) if res: yield item print(list(customizeFilter(lambda x: x % 2 == 0, range(10)))) # [0, 2, 4, 6, 8] reduce() reduce()函数有1个初始值，你可以指定该初始值或者不指定。 每次对可迭代对象数据项进行迭代后，都会调用函数处理该数据项，并且将该数据项与初始值进行操作。 常用于累积运算，如累加，累乘等。 虽然该函数在Python3中已经被移除至内置函数的范畴，但是其强大的功能却很少被人熟练应用。 reduce()函数签名如下： def reduce(function, sequence, initial=None): pass 参数详解： function：一个可调用对象（通常是指函数），拥有2个形参，接收来自可迭代对象的2个数据项 sequence：一个可迭代对象 initial：一个初始值，它会随着可调用对象传入的参数进行运算而不断的改变，最终返回 简单的使用示例，求1 - 100的累加总和： from functools import reduce seqSum = reduce(lambda x,y:x+y, range(1, 101)) print(seqSum) # 5050 使用reduce()能够快速的完成寻求最大最小值的操作： from functools import reduce seqMax = reduce(lambda x, y: x if x > y else y, [1, 5, 10, 100, 399, 29]) print(seqMax) # 399 如果指定了初始值，那么则在初始值的基础上进行操作，如下所示初始值是English，每次的x，y进行相加后会再与初始值进行相加，最后会返回初始值： from functools import reduce seqSumStr = reduce(lambda x, y: x + y, [chr(i) for i in range(65, 65 + 26)], \"English:\") print(seqSumStr) # English:ABCDEFGHIJKLMNOPQRSTUVWXYZ 手动实现reduce()函数，了解底层实现原理： def customizeReduce(function, sequence, initial=None): it = iter(sequence) if initial: value = initial else: value = next(it) for item in it: value = function(value, item) return value seqSum = customizeReduce(lambda x, y: x + y, range(1, 101)) print(seqSum) seqMax = customizeReduce(lambda x, y: x if x > y else y, [1, 5, 10, 100, 399, 29]) print(seqMax) seqSumStr = customizeReduce(lambda x, y: x + y, [chr(i) for i in range(65, 65 + 26)], \"English:\") print(seqSumStr) # 5050 # 399 # English:ABCDEFGHIJKLMNOPQRSTUVWXYZ sorted() sorted()函数可以将一个可迭代对象传入，返回一个经过排序的列表，默认是升序排序。 第一参数：可迭代对象 第二参数，关键字key：一个可调用对象（通常是指函数），拥有1个形参，返回结果即为排序的对比规则，如不指定则按照Python默认排序对比规则进行排序对比 第三参数，关键字reverse：一个布尔值，当排序完成后是否对新列表进行翻转，默认是False即不翻转整个列表，如果是True则进行翻转，相当于对可迭代对象进行降序排序 sorted()函数与li.sort()方法的区别在于它会返回一个新的排好序的列表，而li.sort()则是原地排序。 此外sorted()函数支持对字典排序，这样做会返回1个包含字典key的列表，而li.sort()方法仅支持对列表排序。 使用如下，按照哈希值进行排序，并且翻转整个新的排序列表： newList = sorted([chr(i) for i in range(65, 65 + 26)], key=lambda item: hash(item), reverse=True) print(newList) # ['X', 'J', 'R', 'L', 'Q', 'C', 'U', 'T', 'M', 'O', 'I', 'Y', 'A', 'V', 'S', 'N', 'D', 'E', 'G', 'K', 'W', 'F', 'H', 'Z', 'B', 'P'] reversed() reversed()函数不可与lambda表达式进行搭配，放到这里的主要原因是因为它与sorted()的reverse参数、li.sort()的reverse参数作用相同，用于生成一个被翻转过后的新列表，如下所示，返回的结果是一个reversed可迭代对象，必须将它转换为list或者tuple后才能查看其中数据项： print( tuple(reversed([i for i in range(10)])) ) # (9, 8, 7, 6, 5, 4, 3, 2, 1, 0) 注意：该方法是生成新的对象，而不是原地翻转。 版本区别 Python2中的reduce()是内置模块，直接使用即可。 并且Python2中的map()、filter()的返回结果均为列表，而不是map对象和filter对象。 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-13 20:41:50 "},"Python/Python函数相关/内置函数.html":{"url":"Python/Python函数相关/内置函数.html","title":"内置函数","keywords":"","body":"查看方式 Python3中常用的内置函数可通过导入builtins模块查看： print(builtins.__dict__) 下面将挑选常用的且以前很少使用的内置函数进行示例。 基础 常用函数： 函数 返回值 描述 关注度 help() None 打印对象下的doc文档注释信息 5 hash() int 返回不可变对象的hash表现形式 5 id() int 返回对象在内存中的标识，即地址空间编号 5 print() None 向终端输入一则信息 5 input() str 获得用户在终端中输入的内容 5 open() fileObject 打开一个文件，获得文件句柄 5 exit() None 关闭并退出当前的Python解释器 3 quit() None 与exit()相同 3 help()获得帮助文档： >>> help(int) Help on class int in module builtins: class int(object) | int(x=0) -> integer | int(x, base=10) -> integer ... exit()和quit()都是退出解释器，结束脚本的继续执行。 类型转换 常用函数： 函数 返回值 描述 关注度 bool() bool 返回对象的布尔值 5 int() int 返回整形 5 float() float 返回浮点型 5 str() str 返回字符串 5 bytes() bytes 返回字节串 5 list() list 返回列表 5 tuple() tuple 返回元组 5 dict() dict 返回字典 5 set() set 返回集合 5 frozenset() frozenset 返回不可变集合 5 数学 常用函数： 函数 返回值 描述 关注度 hex() str 传入整形，返回其16进制表现形式 5 oct() str 传入整形，返回其8进制表现形式 5 bin() str 传入整形，返回其2进制表现形式 5 divmod() tuple 返回x与y的整除结果与求余结果 5 pow() int 返回x的y次乘阶 3 round() int 对数字的小数位数进行四舍五入 2 abs() int 返回参数的绝对值 2 divmod()返回x与y的整除结果与求余结果： >>> divmod(10, 3) (3, 1) 相当于10 // 3，10 % 3。 pow()返回x的y次乘阶，相当于x ** y： >>> pow(3, 3) 27 round()对数字的小数位数进行四舍五入： >>> round(3.4) 3 >>> round(3.5) 4 abs()返回参数的绝对值： >>> abs(-1) 1 字符串 常用函数： 函数 返回值 描述 关注度 chr() str 传入整形，将其转换为Unicode的16进制编码表现形式 5 ord() int 传入单个Unicode字符，将其转换为整形 5 ascii() str 返回对象的纯ASCII表示形式 1 format() str 获得对象内部双下format()方法的结果 1 repr() str 返回对象的规范字符串表示形式 2 eval() any 执行一个字符串形式的Python语句，并且返回执行结果 3 exec() any 执行一个字符串形式的Python语句，不会返回执行结果 3 repr()返回对象的规范字符串表示形式，相当于%r： >>> repr(1) '1' >>> 1 1 eval()执行一个字符串形式的Python语句，并且返回执行结果： >>> string = \"1 + 2\" >>> res = eval(string) >>> res 3 exec()执行一个字符串形式的Python语句，不会返回执行结果： >>> string = \"print('hello world')\" >>> exec(string) hello world 容器 常用函数： 函数 返回值 描述 关注度 len() int 返回容器中的项目数 5 slice() sliceObject 返回索引切片对象 2 iter() iterator 调用对象的双下iter()方法，获得专属迭代器 4 next() Item 从迭代器返回下一个数据项 4 range() rangeObject 返回range可迭代对象 5 enumerate() enumerateObject 返回可迭代对象的枚举类型 5 zip() zipObject 接收2个可迭代对象，将其合并为1个可迭代对象并返回，拉链函数 3 max() item 返回容器中最大的数据项 4 min() item 返回容器中最小的数据项 4 sum() int or float 迭代一个可迭代对象，并对其中数据项进行累加，返回求和结果 4 map() mapObject 对一个可迭代对象进行遍历，并对其中数据项挨个做操作，处理完成后返回map对象 5 filter() filterObject 对一个可迭代对象进行遍历，将符合条件的数据项返回至新的filter对象中 5 sorted() list 对一个容器进行排序，返回新的容器 5 reversed() reversedObject 对一个容器进行翻转，返回新的reversed对象 5 all() bool 如果容器中的数据项均为真，则返回True，否则返回False，若是空容器返回True 3 any() bool 如果容器中的数据项有1个为真，则返回True，否则返回False，若是空容器返回False 3 iter()和next()在迭代器一章节中会详细介绍。 zip()接收2个可迭代对象，将其合并为1个可迭代对象并返回，拉链函数： >>> li1 = [\"k1\", \"k2\", \"k3\"] >>> li2 = [\"v1\", \"v2\", \"v3\"] >>> list(zip(li1, li2)) [('k1', 'v1'), ('k2', 'v2'), ('k3', 'v3')] 可以用它快速将2个列表合成1个字典： >>> dict(zip(li1, li2)) {'k1': 'v1', 'k2': 'v2', 'k3': 'v3'} sum()迭代一个可迭代对象，并对其中数据项进行累加，返回求和结果： >>> sum(range(1, 101)) 5050 all()如果容器中的数据项均为真，则返回True，否则返回False，若是空容器返回True： >>> all([1,None,0]) False >>> all([(),{},[],None,0]) False >>> all([]) True any()如果容器中的数据项有1个为真，则返回True，否则返回False，若是空容器返回False： >>> any([1,None,0]) True >>> any([(),{},[],None,0]) False >>> any([]) False 面向对象 常用函数： 函数 返回值 描述 关注度 type() str 获得对象的类型 4 callable() bool 返回对象是否可调用 4 dir() list 返回对象的所有类实现方法，以及类属性 5 vars() dict 当不传入对象时相当于locals()方法，传入对象后相当于调用对象底层的双下字典 1 hasattr() bool 判断一个对象下某一个属性或者方法是否存在 5 getattr() attr 获取一个对象下某一个属性或者方法 5 setattr() None 新增或者设置一个对象的属性或者方法 5 delattr() None 删除一个对象下某一个属性或者方法 5 isinstance() bool 返回对象是类的实例还是子类的实例 5 issubclass() bool 判断一个类是否是另一个类的子类 5 super() method 调用父类的同名方法 5 type()函数已经见过了，其他函数将放在面向对象一栏中详细介绍。 作用域 常用函数： 函数 返回值 描述 关注度 globals() dict 返回全局命名空间的字典 2 locals() dict 返回当前代码执行的局部命名空间的字典 2 没什么用，完全可以不在意。 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-13 20:41:50 "},"Python/Python函数相关/装饰器.html":{"url":"Python/Python函数相关/装饰器.html","title":"装饰器","keywords":"","body":"装饰器 开闭原则 根据设计模式中的6大设计原则中的开闭原则来说，一个良好的项目应该具有以下2个特性： 对扩展开放：项目应当具有良好的扩展性 对修改关闭：当项目需要做功能变更时，不应该修改源代码，而应该增添新的功能，达到热插拔的效果 装饰器 装饰器（decorator）的功能就是在不违背开闭原则的前提下为一个原有功能增加上一些新的功能。 但是原有功能的调用、源代码都不会被修改，类似于一种在外部打补丁的方式。 装饰器有函数装饰器，类装饰器等分别，这里介绍函数装饰器，其实它们的运行原理都是相同的。 功能需求 我们有2个函数，upload()和download()，现在有1个需求，分别求出2个函数的运行时间。 同时还有3点限制： 不能修改源函数内部代码 不能改变源函数的调用方式 要以最精简的代码量完成需求 源代码如下： import time import random def download(fileName): time.sleep(random.randint(1, 3)) return \"下载文件{}完成\".format(fileName) def upload(fileName): time.sleep(random.randint(1, 3)) return \"下载文件{}完成\".format(fileName) downResult = download(\"testDownload.text\") upResult = upload(\"testUpload.text\") 解决过程 外部代码 最简单的方式是添加外部代码，来看一下效果： import time import random def download(fileName): time.sleep(random.randint(1, 3)) return \"下载文件{}完成\".format(fileName) def upload(fileName): time.sleep(random.randint(1, 3)) return \"下载文件{}完成\".format(fileName) downStartTime = time.time() downResult = download(\"testDownload.text\") downEndTime = time.time() downTotalTime = downEndTime - downStartTime print(\"函数:{} 运行共花费时长:{}\".format(download.__name__, downTotalTime)) upStartTime = time.time() upResult = upload(\"testUpload.text\") upEndTime = time.time() upTotalTime = upEndTime - upStartTime print(\"函数:{} 运行共花费时长:{}\".format(upload.__name__, downTotalTime)) # 函数:download 运行共花费时长:2.002652883529663 # 函数:upload 运行共花费时长:2.002652883529663 优点： 没有改变源函数的调用方式 没有修改源函数内部代码 缺点： 代码冗余量过大，每一次函数执行都至少要添加4行代码（开始时间，结束时间，总计时间，打印语句） 传参方式 对上述代码进行优化，再来看看效果： import time import random def showTotalRunTime(func, *args, **kwargs): startTime = time.time() res = func(*args, **kwargs) endTime = time.time() totalTime = endTime - startTime print(\"函数:{} 运行共花费时长:{}\".format(func.__name__, totalTime)) return res def download(fileName): time.sleep(random.randint(1, 3)) return \"下载文件{}完成\".format(fileName) def upload(fileName): time.sleep(random.randint(1, 3)) return \"下载文件{}完成\".format(fileName) downResult = showTotalRunTime(download, \"testDownload.text\") upResult = showTotalRunTime(upload, \"testUpload.text\") print(downResult) print(upResult) 优点： 极大的减少了代码冗余量 没有修改源函数内部代码 缺点： 改变了源函数的调用方式，若想在使用原本功能的前提下获得统计时长的功能，则必须运行showTotalRunTime()函数 闭包函数 闭包函数介绍 闭包函数是装饰器的核心知识点。 闭函数通常是指L层的函数，即被嵌套定义在另一个函数中的函数 包函数通常是指E层的函数，即该函数的内部嵌套定义了另一个函数 它的基本概念在于： 标识符的查找顺序以定义阶段为标准。当前命名空间没找到名字时则往定义自己的命名空间中查找标识符。 如下所示，这就是一个完整的闭包函数： def outer(): # ❶ def inner(): # ❷ pass return inner ❶：outer()函数是包函数 ❷：inner()函数是闭函数 闭包方案 在闭包函数中，E层的包函数命名空间里所有的标识符对象都不会被销毁（即使包函数已经进行了return），在L层的闭函数中，可以通过命名空间标识符向上查找的特性拿到E层包函数的命名空间标识符。 故我们可以使用闭包函数来进行问题的解决，下面的warpper()函数其实就是装饰器函数： import time import random def warpper(func): def inner(*args, **kwargs): startTime = time.time() res = func(*args, **kwargs) # ❹ endTime = time.time() totalTime = endTime - startTime print(\"函数:{} 运行共花费时长:{}\".format(func.__name__, totalTime)) return res return inner def download(fileName): time.sleep(random.randint(1, 3)) return \"下载文件{}完成\".format(fileName) def upload(fileName): time.sleep(random.randint(1, 3)) return \"下载文件{}完成\".format(fileName) download = warpper(download) # ❶ upload = warpper(upload) # ❷ downResult = download(\"testDownload.text\") # ❸ print(downResult) upResult = upload(\"testUpload.text\") print(upResult) ❶：调用warpper()函数，func形参存储的对象为download()函数，并返回inner()函数，此时外部的download标识符指向了inner()函数 ❷：调用warpper()函数，func形参存储的对象为upload()函数，并返回inner()函数，此时外部的upload标识符指向了inner()函数 ❸：调用download标识符所指向的inner()函数，并且传入了参数”testDownload.text”，开始执行inner()函数 ❹：在L层命名空间找func标识符，找不到，向上找到E层的命名空间，找到了func标识符形参，指向了download()函数，执行download()函数 ... 可以看到，通过闭包函数完美的完成了需求。 优点： 极大的减少了代码冗余量 没有修改源函数内部代码 在没有改变了源函数的调用方式前提下，新增了计时的功能 缺点： 我们必须对源函数做1个包装，将它的标识符由指向源函数改为指向为包函数的返回值，即闭函数，每一个需要增加统计时长功能的函数都要添加这样的一行代码，即❶，❷处。 整个过程图示，注意查看全局命名空间的标识符指向改变： @语法糖 无参装饰器 针对闭包方案的缺点，我们可以使用@语法糖的形式来进行进一步改进。 @语法糖内部会做2件事情： 自动加括号执行@后面的函数名，并且将@下面的被装饰函数当做第1个参数传入（注意，这个自动调用仅调用一次，当嵌套层数过多时则不会自动调用） 自动将@下面的被装饰函数的标识符重新指向内层返回的闭函数 如下所示： import time import random def warpper(func): def inner(*args, **kwargs): startTime = time.time() res = func(*args, **kwargs) endTime = time.time() totalTime = endTime - startTime print(\"函数:{} 运行共花费时长:{}\".format(func.__name__, totalTime)) return res return inner @warpper # ❶ def download(fileName): time.sleep(random.randint(1, 3)) return \"下载文件{}完成\".format(fileName) @warpper def upload(fileName): time.sleep(random.randint(1, 3)) return \"下载文件{}完成\".format(fileName) downResult = download(\"testDownload.text\") # ❷ print(downResult) upResult = upload(\"testUpload.text\") print(upResult) ❶：Python解释器检查语法，发现函数头上有个@装饰器函数，开始做2件事情: 自动调用warpper()函数，并且将@下面被装饰函数download()当做参数传递给func参数 自动将@下面的被装饰函数的标识符download重新指向内层返回的闭函数inner ❷：此时执行的download()函数其实是inner()函数，inner()函数执行时发现要找func，L层命名空间没有func，则往定义自己的warpper()函数的E层命名空间找func，找到了func指向的是download()函数，然后执行并返回 为了验证上面的例子，我们可以打印一下download的__name__属性进行查看： @warpper def download(fileName): time.sleep(random.randint(1, 3)) return \"下载文件{}完成\".format(fileName) print(download.__name__) # inner 如果不加装饰器呢？ def download(fileName): time.sleep(random.randint(1, 3)) return \"下载文件{}完成\".format(fileName) print(download.__name__) # download @手动传参 @如果手动加括号会怎么样？它会将执行结果对象返回给被装饰器函数的标识符。 如下示例，首先是打印了int类型的帮助信息，然后返回了一个None，func指向了None，如果func加上括号进行调用，则会抛出异常： @help(int) def func(): print(\"func...\") # Help on class int in module builtins: # # class int(object) # | int(x=0) -> integer # | int(x, base=10) -> integer func() # TypeError: 'NoneType' object is not callable 有参装饰器 一个新的需求： 下载或时候如果用户是普通用户，则享用10M带宽，如果是VIP用户，则享用100M带宽 如果用@语法糖来解决这个问题，则需要在外部再嵌套一层函数： import time import random def outer(genre): def warpper(func): def inner(*args, **kwargs): if genre == \"VIP\": print(\"欢迎您，尊贵的VIP用户，您的下载速度是100M/s\") else: print(\"欢迎您，亲爱的普通用户，您的下载速度是10M/s\") startTime = time.time() res = func(*args, **kwargs) endTime = time.time() totalTime = endTime - startTime print(\"函数:{} 运行共花费时长:{}\".format(func.__name__, totalTime)) return res return inner return warpper @outer(genre=\"VIP\" if random.randint(1, 2) == 1 else \"common\") def download(fileName): time.sleep(random.randint(1, 3)) return \"下载文件{}完成\".format(fileName) downResult = download(\"testDownload.text\") print(downResult) 执行流程如下： 手动调用一次outer()函数，并且为genre传入参数，返回了warpper()函数。 此时会变成这个样子，由于手动在装饰器函数后面加了括号，所以本次的返回值会依然当做装饰器添加在头上，并不会改变download()： @warpper def download(fileName): pass 自动调用一次（仅一次）warpper()函数，并且将@下面被装饰函数download()当做参数传递给func参数 自动将@下面的被装饰函数的标识符download重新指向内层的inner()函数 此时执行的download()函数其实是inner()函数，然后根据命名空间查找特性，找到genre形参变量标识符与func形参函数标识符 @自动执行 Python中的@语法糖对闭包函数只会自动的执行1次，如下所示： def warpper(x): print(\"执行第1次，返回f1\") def f1(x): print(\"执行第2次，返回f2\") def f2(x): print(\"执行第3次，返回None\") return f2 return f1 @warpper def func(): ... # 执行第1次，返回f1 而我们手动的对@后的函数进行调用，则在1层自动执行的基础上又加上了1次手动执行： def warpper(x): print(\"执行第1次，返回f1\") def f1(x): print(\"执行第2次，返回f2\") def f2(x): print(\"执行第3次，返回None\") return f2 return f1 @warpper(\"x\") def func(): ... # 执行第1次，返回f1 这是手动执行的1次 # 执行第2次，返回f2 这是自动执行的1次 也就是说Python的@语法最大仅能支持3层嵌套定义的闭包函数，如果太深则里面的就拿不到了，因为你不能手动调用2次，这样会抛出语法错误： @warpper(\"x\")(\"c\") def func(): ... # SyntaxError: invalid syntax 多个装饰器 多个装饰器叠放的场景你今后肯定会遇见，只需要记住一句话即可： 定义顺序自下而上，执行顺序自上而下 如下所示： def f1(func): print(\"定义f1装饰器\") def inner(*args, **kwargs): print(\"执行f1装饰器\") func() return inner def f2(func): print(\"定义f2装饰器\") def inner(*args, **kwargs): print(\"执行f2装饰器\") func() return inner @f1 @f2 def func(): ... func() # 定义f2装饰器 # 定义f1装饰器 # 执行f1装饰器 # 执行f2装饰器 流程分析： # Python解释器执行到 @f1 时，想自动运行一下，发现下面被装饰的不是一个函数，就不自动运行了 # Python解释器执行到 @f2 时，想自动运行一下，发现下面被装饰的是一个函数，于是开始自动运行 # print(\"定义f2装饰器\") # 然后返回了 inner 函数，现在 func -> inner 函数，变成了这个样子 # # @f1 # def func(): # ... # # 然后，Python解释器发现 @f1 下面是一个函数了，于是开始自动运行 # print(\"定义f1装饰器\") # 然后又返回 inner 函数，现在 func -> 新的 inner 函数 # # Python解释器继续向下走，发现 func() # 由于 func -> 新的 inner 函数 故开始运行 f1的 inner 函数： # print(\"执行f1装饰器\") # 打印完成后又要执行 func() # 那么这里的 func 是旧的 inner 函数，故开始运行f2的 inner 函数： # print(\"执行f2装饰器\") @wraps分析 @wraps其实是functiontools中自带的一款有参装饰器，它能够做到很好的隐藏功能。 如，普通装饰器的标识符被改变指向为L层函数后，通过查看__name__还是会看到原本L层函数的名字： def warpper(func): def inner(*args, **kwargs): result = func() return result return inner @warpper def func(): ... print(func.__name__) # inner 如果对内层L函数加上@wraps后，就会将内层函数的大部分属性变为原本标识符所指向的被装饰函数，如下所示： from functools import wraps def warpper(func): @wraps(func) def inner(*args, **kwargs): result = func() return result return inner @warpper def func(): ... print(func.__name__) # func 这个仅是换了1个属性，实际上内存地址还是inner的，通过以下示例进行验证： from functools import wraps def warpper(func): @wraps(func) def inner(*args, **kwargs): result = func() return result print(\"内部打印 inner() 函数的内存地址\", id(inner)) return inner @warpper def func(): ... print(\"内部打印 func 所指向函数的内存地址\", id(func)) # 内部打印 inner() 函数的内存地址 4451701896 # 内部打印 func 所指向函数的内存地址 4451701896 装饰器模板 无参装饰器 from functools import wraps def warpper(func): @wraps(func) def inner(*args, **kwargs): # 开始前的逻辑 result = func() # 结束后的逻辑 return result return inner @warpper def func(): ... func() 有参装饰器 from functools import wraps def warpper(*args, **kwargs): def outer(func): @wraps(func) def inner(*args, **kwargs): # 参数的使用 # 开始前的逻辑 result = func() # 结束后的逻辑 return result return inner return outer @warpper(k1=\"v1\") def func(): ... func() Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-13 20:41:50 "},"Python/Python函数相关/迭代器.html":{"url":"Python/Python函数相关/迭代器.html","title":"迭代器","keywords":"","body":"迭代器 迭代是什么 迭代指的是一个重复的过程，每次重复都必须基于上一次的结果而继续，单纯的重复并不是迭代，如Python中的for循环就是一个非常好的迭代例子。 for item in range(10): print(item) 迭代必须向前推进，不能后退，如下所示： # [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] # ------------------------------> 下面这种方式就不属于迭代： # [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] # --------> # 迭代器协议 在学习迭代器的整个知识点中，迭代器协议占据了非常重要的位置。 迭代器协议中包含了2个最基本的概念，分别是可迭代对象和迭代器对象。 可迭代对象（Iterable）：内部实现了__iter__()方法的对象则被称为可迭代对象 迭代器对象（Iterator）：内部实现了__iter__()以及_next\\_()方法的对象则被称之为迭代器对象 两者之间的关系： 在Python中，迭代器对象一定属于可迭代对象范畴，也就说迭代器对象必须具有__iter__()方法以及__next__()方法 在Python中，可迭代对象不一定属于迭代器对象范畴，也就是说可迭代对象只需要实现__iter__()方法即可 介绍2个函数： iter(Object)函数，它底层会执行Object.__iter__()方法 next(Object)函数，它底层会执行Object.__next__()方法 内置类型 通过collections.abc下的Iterable类和Iterator类进行判定，可快速的判定出所有内置类型是否是一个可迭代对象或者迭代器对象： >>> from collections.abc import Iterable >>> from collections.abc import Iterator >>> isinstance(list(), Iterable) True >>> isinstance(list(), Iterator) False 经过测试，所有的容器类型（list、tuple、str、dict、set、frozenset）均属于可迭代对象，但不属于迭代器对象 原子类型（bool、int、float、None）等均不属于可迭代对象，更不属于迭代器对象。 也可以通过另一种方式进行验证，通过hasattr()函数，检查类中是否定义了某一个方法： >>> hasattr(list,\"__iter__\") True >>> hasattr(list,\"__next__\") False 迭代原理 当可迭代对象被for循环进行调用后，底层执行流程如下所示： 将自动的执行iter()方法，该方法内部会查找可迭代对象的__iter__()方法，如果具有该方法，则返回一个该可迭代对象的专属迭代器对象，如果没有该方法，则抛出TypeError object is not iterable的异常。 Ps：每次的for循环都会返回一个全新的迭代器对象 不断的调用迭代器对象的__next__()方法，并且返回迭代器对象中下一个数据项，当遍历完成整个迭代器后，引发Stopiteration异常终止迭代 Ps：迭代器本身并不存储任何数据项，存储的只是一个指针，该指针指向可迭代对象中真正存储的数据项，它指向当前被遍历到的数据项索引位置，下一次遍历则向后推进这个位置 for循环自动的捕捉Stopiteration异常，并且停止迭代 Ps:for循环底层就是while循环实现的，只不过多加了3个步骤： 第一步：执行可迭代对象的__iter()__方法并保存返回的专属迭代器 第二步：不断的执行迭代器的__next()__方法 第三步：捕获Stopiteration异常 我们手动的实现一个for循环： li1 = list(range(10)) iteratorObject = iter(li1) # ❶ while 1: try: print(next(iteratorObject)) # ❷ except StopIteration as e: # ❸ break ❶：执行可迭代对象的__iter__()方法并保存返回的专属迭代器 ❷：不断的执行迭代器的__next__()方法 ❸：捕获Stopiteration异常 线性可迭代对象与迭代器的实现 如果是一个线性容器的可迭代对象，那么它一定具有索引值，我们可以让它的__iter__()方法返回一个专属的迭代器对象。 然后专属迭代器对象中记录本次迭代遍历的索引值，根据这个索引值返回可迭代对象中的数据项，当索引值达到可迭代对象中数据项总个数-1的时候，抛出异常，本次迭代结束： class LinearTypeContainer: def __init__(self, array): if isinstance(array, list) or isinstance(array, tuple): self.array = array else: raise TypeError(\"argument array must is linear container\") def __iter__(self): return LinearContainer_iterator(self.array) # ❶ class LinearContainer_iterator: def __init__(self, array): self.index = 0 self.array = array self.len = len(self.array) def __next__(self): if self.index ❶：Python中的一切传参均为引用传递 故LinearTypeContainer中的self.array和LinearContainer_iterator的self.array都是一个对象，并不会额外开辟内存空间 这也就是为什么可迭代对象创建的专属迭代器不会消耗太多的内存空间原因了。 ❷：迭代器对象一定属于可迭代对象范畴，所以在这里我们为迭代器对象LinearContaineriterator类也新增了\\_iter__()方法 这样做的好处在于如果单独的拎出了这个迭代器对象，则它也会支持for循环的遍历： def __iter__(self): return self containerIterator = LinearTypeContainer([i for i in range(10)]).__iter__() for item in containerIterator: print(item) # 0 # 1 # 2 # 3 # 4 # 5 # 6 # 7 # 8 # 9 如果取消了linearContaineriterator类的这个\\_iter__()方法，则不支持for循环的遍历： # def __iter__(self): # return self containerIterator = LinearTypeContainer([i for i in range(10)]).__iter__() for item in containerIterator: print(item) # TypeError: 'LinearContainer_iterator' object is not iterable 非线性可迭代对象与迭代器实现 如果是一个非线性容器的可迭代对象，可以先判断它的类型，如果传入的容器是一个字典，则将迭代的数据项集合转换为元组，里面存储的全部是字典的key即可。 如果传入的容器是一个集合，则将迭代的数据项集合转换为元组，再参照线性可迭代对象与迭代器的实现。 具体实现： class MappingTypeContainer: def __init__(self, mapping): self.mapping = mapping if not ( isinstance(self.mapping, dict) or isinstance(self.mapping, set) or isinstance(self.mapping, frozenset) ): raise TypeError(\"argument mapping must is mapping container\") def __getattr__(self, name: str): try: return dict.__getattribute__(self.mapping, name) except AttributeError: return set.__getattribute__(self.mapping, name) def __str__(self): return str(self.mapping) def __iter__(self): return MappingContainer_iterator(tuple(self.mapping)) class MappingContainer_iterator: def __init__(self, array): self.index = 0 self.array = array self.len = len(self.array) def __next__(self): if self.index 迭代器对象的特性 每一次for循环创建出的可迭代对象的专属迭代器都是一次性的，用完后就没用了： ... # ❶ containerIterator = LinearTypeContainer([i for i in range(3)]).__iter__() for item in containerIterator: print(item) # 0 # 1 # 2 for item in containerIterator: print(item) # ❷ print(\"?\") ❶：直接拿出一个迭代器对象 ❷：在第2次循环中，迭代器对象中存储的索引值已经最大了，每次调用iter()都会抛出异常返回出来再被for处理，所以print()函数根本不会运行 迭代器对象并不存储可迭代对象中的真正迭代数据，而是仅存储长度和索引，所以内存的占用并不多： class LinearContainer_iterator: def __init__(self, array): self.index = 0 # ❶ self.array = array # ❷ self.len = len(self.array) # ❸ ... ❶：占用额外的内存空间 ❷：引用对象，并不开辟内存 ❸：占用额外的内存空间 惰性求值与及早求值 迭代器对象中对于返回的数据项，是进行实时演算的，这种实时演算的特性求值方式被称为惰性求值，即你需要的时候我算出来后再给你： def __next__(self): if self.index 除开惰性求值，还有一种及早求值的方案，即使你要1个，我也把所有的都给你。 如Python2中的range()、map()、filter()、dict.items()、dict.keys()、dict.values()，它们均返回的是一个纯粹的列表，这样的设计是不合理的，参见要命的问题③。 因为返回的列表会占用很大的内存空间，而Python3中则统一优化为惰性求值方案，即返回一个可迭代对象。 要命的问题 一个非常有趣的问题： Python中的所有自带容器类型为何不自己设置成迭代器？ 而是在for循环时实例出一个专属的迭代器？ 直接在这些自带类型的底层实现__next__()方法不好吗？ 这样岂不是更加减少了内存的消耗，少定义了类和实例化了类吗？ 答：这真是一个要命的问题，这个问题我也想过很久，最后是在stackoverflow提问并且获得了满意的答案才记录下来的。 因为它确实是可以实现的，如下所示，只需要在加上❶处代码即可： class LinearTypeContainer: def __init__(self, array): if isinstance(array, list) or isinstance(array, tuple): self.array = array else: raise TypeError(\"argument array must is Linear container\") self.index = 0 self.len = len(self.array) def __iter__(self): return self def __next__(self): if self.index 但是这样做在某种特殊情况下会出现问题： container = LinearTypeContainer(list(range(5))) for item in container: print(item) if container.index == 3: break print(\"*\"*20) for item in container: print(item) # 0 # 1 # 2 # ******************** # 3 # 4 你会发现如果第一次for循环到了1半的时候退出，第二次for循环会接着根据第一次for循环进行继续。 能够解决一下吗？只需要加上一个标志位即可： class LinearTypeContainer: def __init__(self, array): if isinstance(array, list) or isinstance(array, tuple): self.array = array else: raise TypeError(\"argument array must is Linear container\") self.index = 0 self.len = len(self.array) self.iter = False # ❶ def __iter__(self): if self.iter: # ❷ self.index = 0 self.iter = True return self def __next__(self): if self.index ❶：判断是不是一次新的调用 ❷：如果是新的调用，则将index重新置为0即可 那么为何Python不这样设计呢？我们应该更多的考虑多线程的情况下，多个for循环使用同一个迭代器它是否是线程安全的，上面的示例中这个共享迭代器并不是线程安全的，此外它也不支持嵌套循环，如下所示，这样会造成无限循环： container = LinearTypeContainer(list(range(5))) for item in container: print(item) for j in container: print(j) 综上各个方面的考虑，Python将内置的数据类型，都设置了在for循环时返回专属迭代器的做法，这是非常好的设计，但是对于有些内置的对象，则是将它本身做成了迭代器，如文件对象。 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-07-07 16:36:18 "},"Python/Python函数相关/生成器.html":{"url":"Python/Python函数相关/生成器.html","title":"生成器","keywords":"","body":"生成器 生成器（generator）是迭代器的一种特殊实现方式，有2种方式可以创建，一种是通过生成器函数创建，另一种是生成器表达式进行创建。 生成器继承了迭代器的一切优点，简而言之是迭代器的一种升级版本。 在前面的迭代器一章节中介绍过，如果要想获取一个迭代器，必须要先创建一个可迭代对象，然后调用其下的__iter__()方法才能拿到一个迭代器，这样做会产生一些问题，如下所示： 我们只想要一个迭代器，并不需要可迭代对象的前提下该怎么办 可迭代对象中的数据项会占据大量内存空间，如果要想获取1个含有1000万个数据项的列表迭代器，则必须先创建1个列表对象，再获取其专属的迭代器，虽然迭代器不耗费内存，但是可迭代对象必然耗费内存 而生成器则是简化了这种操作，只需要创建生成器函数就可以拿到一个单纯的迭代器。 如果要判断一个对象是否属于生成器，推荐使用collections.abc下的Generator进行判定： >>> from collections.abc import Generator >>> isinstance(list,Generator) False 生成器函数 如果一个函数中出现yield关键字，则它就是一个生成器函数，当一个生成器函数加括号进行调用时，并不会立即运行逻辑体代码，而是返回一个生成器对象。 当对这个生成器对象调用next()方法时，将启动该生成器对象，生成器对象开始执行函数逻辑体代码。 而在执行函数逻辑体代码时如果碰见yield则会发生2件事情： 返回yield后面的值，类似于return函数 挂起当前生成器函数的运行状态，而不是结束生成器函数的运行，也就是说这个生成器对象不会被销毁 再次对生成器对象调用next()方法时恢复暂停状态，继续上述流程进行运行。 一个简单的例子： def generatorFunction(): n = 3 while n: yield n n-=1 # return None ❶ # ❷ generatorObject = generatorFunction() print(generatorObject) # ❸ print(next(generatorObject)) print(next(generatorObject)) print(next(generatorObject)) # ❹ print(next(generatorObject)) # # 3 # 2 # 1 # StopIteration ❶：默认的函数返回值即为None，在Python3之前的较低版本中，return关键字和yield关键字不可以同时出现在一个函数中，但是目前已经取消了这种设定 ❷：生成器函数加括号，返回生成器对象 ❸：生成器对象调用next()方法，开始执行函数体代码 ❹：由next()方法抛出的StopIteration异常，并不是生成器对象抛出的 斐波拉契数列 下面的示例中将使用生成器函数获取斐波拉契数列中指定位数之前所有的数据项。 仅获取数据项，并不产生存储，因此使用生成器函数极为方便： def getFibPositionValue(n): count, currentValue, nextValue = 0, 0, 1 while count 而如果是要对斐波拉契数列本身进行存储，使用普通函数则更好一点： def createFibArray(n): fibArray = [] count, currentValue, nextValue = 0, 0, 1 while count 生成器表达式 生成器表达式类（generator expression）似于列表推导式，用于快速的创建一个生成器对象，使用()对表达式进行包裹： genObject = (i for i in range(3)) print(genObject) # at 0x10bed0db0> 如果外部已经拥有一个括号，则可以忽略这大括号，如将生成器对象转换为元组的完整写法如下： tup = tuple((i for i in range(3))) print(tup) # (0, 1, 2) 忽略括号： tup = tuple(i for i in range(3)) print(tup) # (0, 1, 2) send() close() 生成器的特性不仅如此，它还能够实现一种双向的生成器外部调用代码与生成器内部逻辑代码的信息交互功能。 因为yield不仅可以返回值，还可以接收值。 如下示例，外部通过send()方法发送的信息将被yield所接收，当整个生成器对象迭代完毕后，可以调用close()方法关闭这个生成器对象： def generatorFunction(): print(\"generator object run ...\") firstRecvExternal = yield 1 # ① print(firstRecvExternal) # 打印A secondRecvExternal = yield 2 # ② print(secondRecvExternal) # 打印B lastRecvExternal = yield 3 # ③ print(lastRecvExternal) # 打印C genObject = generatorFunction() # ❶：启动生成器对象，执行函数，运行至①处返回 1，并暂停 genStartResult = genObject.send(None) print(genStartResult) # 打印1 # ❷：继续运行生成器对象，发送了字符串A，被生成器①处的firstRecvExternal所接收到，并进行了一次打印 A # 直至运行至②处，返回结果2 genSecondSend = genObject.send(\"A\") print(genSecondSend) # 打印2 # ❸：继续运行生成器对象，发送了字符串B，被生成器②处的secondRecvExternal所接收到，并且进行了一次打印 B # 直至运行至③处，返回了结果3 genThirdSend = genObject.send(\"B\") print(genThirdSend) # 打印3 try: # 继续运行生成器函数，发送了字符串C，被生成器③处的lastRecvExternal所接收到，并且进行了一次打印 C # 然后再往下运行发现 return None，于是 __next__()函数抛出了 StopIteration 的异常，但是被这里处理了 genLastSend = genObject.send(\"C\") # StopIteration except StopIteration: # 处理异常，关闭生成器对象 genObject.close() # generator object run ... # 1 # A # 2 # B # 3 # C yield form 生成器函数加括号不会执行函数体内部代码，而是返回生成器对象，生成器对象的启动必须通过next()或者send(None)。 for循环底层会调用生成器对象的__next__()方法进行启动和向下运行，因此通过for循环来操纵生成器是十分方便的： def genFunction(): count = 0 while 1: if count ❶：首先将生成器函数转换为生成器对象，然后通过for不断的进行调用 如果是2个嵌套调用的生成器函数，外部嵌套生成器函数需要时刻yield子调用生成器函数的值，似乎用for循环来完成这个需求是最好的选择： def outer(): yield \"run outer...\" for item in inner(): # ❶ yield item def inner(): yield \"run inner 1 ...\" yield \"run innner 2 ...\" yield \"run inner 3 ...\" for item in outer(): print(item) # run outer... # run inner 1 ... # run innner 2 ... # run inner 3 ... ❶：首先将生成器函数转换为生成器对象，然后通过for不断的进行调用 在Python3.3版本之后，你有了新的选择，使用yield from关键字，yield from关键字必须定义在一个生成器函数之中，它将会自动的在底层运行for循环进行调用另一个生成器函数，并将另一个生成器函数的结果进行返回： def outer(): yield \"run outer...\" yield from inner() # ❶ def inner(): yield \"run inner 1 ...\" yield \"run innner 2 ...\" yield \"run inner 3 ...\" for item in outer(): print(item) # run outer... # run inner 1 ... # run innner 2 ... # run inner 3 ... ❶：yield from关键字底层就是for循环，所以这里的代码会更加的精简 yield from关键字后面必须跟上一个可迭代对象，如迭代器、生成器： def outer(): yield \"run outer...\" yield from range(3) for item in outer(): print(item) # run outer... # 0 # 1 # 2 生成器函数栈帧 生成器函数为什么能够挂起当前状态？普通函数为什么不可以？其实根本原因还是在栈帧上。 普通的函数栈帧组成图： 生成器函数栈帧组成图： 函数栈帧结构体 一个函数其实完整的栈帧是由很多部分组成的，参见CPython源码，感兴趣的可以研究一下： typedef struct _frame { PyObject_VAR_HEAD struct _frame *f_back; /* previous frame, or NULL */ PyCodeObject *f_code; /* code segment */ PyObject *f_builtins; /* builtin symbol table (PyDictObject) */ PyObject *f_globals; /* global symbol table (PyDictObject) */ PyObject *f_locals; /* local symbol table (any mapping) */ PyObject **f_valuestack; /* points after the last local */ /* Next free slot in f_valuestack. Frame creation sets to f_valuestack. Frame evaluation usually NULLs it, but a frame that yields sets it to the current stack top. */ PyObject **f_stacktop; PyObject *f_trace; /* Trace function */ char f_trace_lines; /* Emit per-line trace events? */ char f_trace_opcodes; /* Emit per-opcode trace events? */ /* Borrowed reference to a generator, or NULL */ PyObject *f_gen; int f_lasti; /* Last instruction if called */ /* Call PyFrame_GetLineNumber() instead of reading this field directly. As of 2.3 f_lineno is only valid when tracing is active (i.e. when f_trace is set). At other times we use PyCode_Addr2Line to calculate the line from the current bytecode index. */ int f_lineno; /* Current line number */ int f_iblock; /* index in f_blockstack */ char f_executing; /* whether the frame is still executing */ PyTryBlock f_blockstack[CO_MAXBLOCKS]; /* for try and loop blocks */ PyObject *f_localsplus[1]; /* locals+stack, dynamically sized */ } PyFrameObject; 本章总结 这一章可以说及其重要，Python的协程编程中本章知识是绝对的核心基础，只有理解了生成器才用可能理解协程。 还是以问答形式进行记录吧： ①：生成器和迭代器有什么不同？ 答：生成器就是迭代器的另一种实现，普通的迭代器必须通过iter()函数进行创建，也就是说普通的迭代器必须依赖可迭代对象才能够创建出来，但是可迭代对象会占用大量内存，所以产生了生成器，即不通过可迭代对象就能拿到的迭代器。 ②：yield form的作用？ 答：yield form只能定义在一个生成器函数中，该生成器函数内部如果嵌套调用了另一个生成器函数时就可以使用yield form进行另一个生成器函数的调用，它底层会自动经过for循环对另一个生成器对象进行操纵，且将值返回给最外部。 ③：生成器函数和普通函数有什么不同？ 答：生成器函数加括号得到生成器对象，生成器对象调用其下__next__()方法才会执行函数体代码。而普通函数加括号直接执行函数体代码。 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-13 20:41:50 "},"Python/Python模块与包/summary.html":{"url":"Python/Python模块与包/summary.html","title":"Python模块与包","keywords":"","body":" 目录规范 Python模块 Python包 内置模块：time 内置模块：datetime 内置模块：random 内置模块：os 内置模块：sys 内置模块：json&pickle&shelve 内置模块：hashlib 内置模块：configparser 内置模块：subprocess 内置模块：logging 内置模块：re 内置模块：importlib 内置模块：collections 内置模块：itertools 内置模块：functools 模块包库框架的区别 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-13 20:41:50 "},"Python/Python模块与包/目录规范.html":{"url":"Python/Python模块与包/目录规范.html","title":"目录规范","keywords":"","body":"目录规范 为了提高程序的可读性与可维护性，我们应该为软件设计良好的目录结构，这与规范的编码风格同等重要。 软件的目录规范并无硬性标准，只要清晰可读即可。 但是有一些规范还是十分合理的，我们应当予以遵守： 目录层次不超过5层 目录尽量以复数形式命名，如imgs而不是img 目录命名尽量清晰易懂 目录说明 bin 目录级别：一级目录 目录作用：通常用于存放项目启动脚本 其他命名：暂无 注意事项：如果拥有此目录，则启动脚本需要考虑模块导入路径的问题 core 目录级别：一级目录 目录作用：存放主程序、业务逻辑源代码 其他命名：src 注意事项：可根据不同的子业务继续划分二级目录 api 目录级别：一级目录 目录作用：通常用于存放项目接口文件，使得项目能够在启动后和外部通信 其他命名：interface 注意事项：可根据不同的子业务需要继续划分二级目录 db 目录级别：一级目录 目录作用：存放操作数据库相关文件，主要用于与数据库交互 其他命名：暂无 注意事项：暂无 lib 目录级别：一级目录 目录作用：存放程序中常用的自定义模块 其他命名：暂无 注意事项：暂无 conf 目录级别：一级目录 目录作用：存放项目所需要的配置文件 其他命名：config 注意事项：暂无 logs 目录级别：一级目录 目录作用：存放项目运行时所产生的日志文件 其他命名：暂无 注意事项：暂无 docs 目录级别：一级目录 目录作用：存放项目的详细说明文档 其他命名：暂无 注意事项：暂无 plugins 目录级别：一级目录 目录作用：存放项目中所需要的第三方插件 其他命名：utils、tools、helpers 注意事项：暂无 common 目录级别：一级目录 目录作用：存放项目中大部分需求都能使用到的功能，相当于公共插件 其他命名：暂无 注意事项：暂无 test 目录级别：一级目录 目录作用：存放项目测试代码 其他命名：暂无 注意事项：暂无 static 目录级别：一级目录 目录作用：存放项目中所需要的静态文件 其他命名：暂无 注意事项：暂无 views 目录级别：一级目录 目录作用：存放项目中所需要的模板文件，MVC模型中的视图 其他命名：templates 注意事项：暂无 controller 目录级别：一级目录 目录作用：存放项目中的主流算法，MVC模型中的控制 其他命名：暂无 注意事项：暂无 models 目录级别：一级目录 目录作用：存放项目中与数据库打交道的脚本，MVC模型中的模型 其他命名：暂无 注意事项：暂无 文件说明 run.py 文件位置：项目根目录下，或者bin目录下 文件作用：项目的启动脚本 其他命名：start.py 注意事项：如果启动脚本是在bin目录下，则需要考虑sys.path setup.py 文件位置：项目根目录下 文件作用：安装、部署、打包的脚本，一键安装所需要的所有依赖环境 其他命名：暂无 注意事项：暂无 一般来说，用setup.py来管理代码的打包、安装、部署问题。业界标准的写法是用Python流行的打包工具setuptools来管理这些事情，这种方式普遍应用于开源项目中。 不过这里的核心思想不是用标准化的工具来解决这些问题，而是说，一个项目一定要有一个安装部署工具，能快速便捷的在一台新机器上将环境装好、代码部署好和将程序运行起来。 settings.py 文件位置：conf文件夹下 文件作用：项目配置文件 其他命名：有的是py脚本，后缀就是.py，而有的是.ini 、.conf、.yaml等 注意事项：暂无 requirements.txt 文件位置：项目根目录下 文件作用：存放所有项目第三方依赖库、模块的名字及版本 其他命名：暂无 注意事项：这个一般都是用第三方模块生成的 　requirements.txt文件的存在是为了方便开发者维护软件的依赖库。我们需要将开发过程中依赖库的信息添加进该文件中，避免在 setup.py安装依赖时漏掉软件包，同时也方便了使用者明确项目引用了哪些Python包。 README.md 文件位置：项目根目录下 文件作用：项目整体描述信息，设计思路，设计目标等 其他命名：暂无 注意事项：暂无 关于README.me的内容，这个应该是每个项目都应该有的一个文件，目的是能简要描述该项目的信息，让读者快速了解这个项目。它需要说明以下几个事项: 软件定位，软件的基本功能； 运行代码的方法: 安装环境、启动命令等； 简要的使用说明； 代码目录结构说明，更详细点可以说明软件的基本原理； 常见问题说明。 其他文件 CHANGELOG.md ：描述项目每个版本的更新信息，说明版本号、更新内容、修复了哪些问题等 humans.txt ：保存网站信息和网站建设者信息 ，格式规范参考官网http://humanstxt.org/ LICENSE.txt：项目基于的许可协议 robots.txt：规定爬虫程序能够获取本网站的那些信息 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-13 20:41:50 "},"Python/Python模块与包/Python模块.html":{"url":"Python/Python模块与包/Python模块.html","title":"Python模块","keywords":"","body":"Python模块 Python中的模块是一系列功能的集合体，总计可分为3大类： 内置模块：Python自带的一些内置库，开箱即用 第三方模块：通过pip命令下载到的模块，无需自己定义，Python拥有海量的第三方模块 自定义模块：一个.py文件就是一个模块，所以自己编写的.py文件也可以当做模块使用，例如文件名为m.py的文件就是一个名为m的自定义模块 自定义模块 自定义模块即自己写的模块，好处如下： 将相同功能的代码进行分类 降低代码耦合度，减少代码冗余 使整个程序组织结构更清晰，便于后期维护 结构分类 由于一个.py文件即为一个模块，故我们可以创建2个.py文件，一个当做程序入口文件，一个当做功能模块文件，以下是结构图： . ├── m1.py # 功能模块文件 └── run.py # 程序入口文件 首先在m1.py中写一个基本的函数： # m1.py print(\"this is module m1\") def add(x, y): return x + y 其次是在run.py中写上一个打印语句： # run.py print(\"run ..\") import简单使用 如果run.py中想要使用到m1.py中的add()函数，该怎么做？ 只需要在run.py中导入m1.py里定义的add()函数即可，注意在使用时也必须按m1开头才行： # run.py import m1 # ❶ print(\"run ..\") result = m1.add(1, 2) # ❷ print(result) # this is module m1 # run .. # 3 ❶：当解释器发现import m1时，会查找m1.py文件，并且会执行m1.py中的所有代码，所以下面会打印出 this is module m1的字样 ❷：使用了m1中的add()函数 针对❶，提出一个问题，如果导入多次这个m1文件，是否也会执行多次其中的代码呢？ 结果是否，也就是说只有第一次导入模块时，才会执行模块中的代码，多次导入只执行一次，其根本原因参照Python模块查找一节。 # run.py import m1 import m1 import m1 print(\"run ..\") result = m1.add(1, 2) print(result) # this is module m1 ❶ # run .. # 3 模块命名空间 现在我们有2个模块文件： . ├── m1.py ├── m2.py └── run.py 且2个模块文件中的代码都大部分相似： # m1.py print(\"this is module m1\") def add(x, y): return x + y # m2.py print(\"this is module m2\") def add(x, y): return x + y 在run中导入2个模块，且分别使用其下的add()函数时，内部发生了什么事情？ # run.py import m1 import m2 print(\"run ..\") resultM1 = m1.add(1, 2) resultM2 = m2.add(1, 2) print(resultM1) print(resultM2) # this is module m1 # this is module m2 # run .. # 3 # 3 run.py执行时，会按照import的顺序执行m1.py和m2.py文件中的代码 当m1，m2执行完成之后，会产生一个模块的命名空间 run.py的全局命名空间中将产生2个标识符，分别指向了m1.py和m2.py的模块命名空间 模块命名空间如下所示： 当要使用m1.add()时，则run.py通过全局命名空间中的标识符m1，去m1模块的命名空间中查找函数标识符add。 当要使用m2.add()时，则run.py通过全局命名空间中的标识符m2，去m2模块的命名空间中查找函数标识符add。 __name__与__main__ 当一个模块编写完成后，将要对其进行测试工作，确保代码无误才能投入使用。 如下，m1的测试代码写上： # m1.py print(\"this is module m1\") def add(x, y): return x + y # test print(add(1, 2)) 测试没问题后，run.py中对其进行功能引用： # run.py import m1 import m2 print(\"run ..\") resultM1 = m1.add(1, 2) resultM2 = m2.add(1, 2) print(resultM1) print(resultM2) # this is module m1 # 3 ❶ # this is module m2 # run .. # 3 当运行run.py后，会发现1处多打印了个3，这是因为在执行m1模块时，也将测试代码给执行了。 如何避免这种问题？我们可以在m1.py中加上一个判断语句： # m1.py print(\"this is module m1\") def add(x, y): return x + y # test if __name__ == \"__main__\": # ❶ print(add(1, 2)) ❶：__name__：如果该.py文件当做脚本被执行，则该变量为__main__，如果该.py文件当做模块导入被执行，则该变量为.py文件的名字，如m1.py就是m1 所以说，加入这条测试语句的目的在于，.py文件在不同的方式使用时可以执行不同的代码： 当做脚本被执行时，会运行测试代码 当做模块被导入时，不会运行测试代码 模块导入 import .. import语句的使用方式： import 模块名 导入的最小单元是模块 使用import导入模块的优缺点： 优点：不会和当前的全局命名空间标识符产生冲突 缺点：在使用模块功能时必须加上import右边的标识符前缀 如下所示，2个不同模块的相同标识符函数并不会产生冲突： import time import datetime print(time.time()) print(datetime.time()) # 1621665686.779634 # 00:00:00 也可以一行导入多个模块，使用逗号进行分割： import time, datetime from .. import .. from语句的使用方式： from 模块名 import 标识符 导入的最小单元是具体功能 使用from语句导入模块的优缺点： 优点：在使用模块功能时必须加上import右边的标识符前缀，如果直接导入了一个具体功能，则不用加前缀 缺点：容易和当前的全局命名空间标识符产生冲突 如下示例，由于datetime模块后导入，所以它的time函数标识符替代了time模块的time函数标识符： from time import time from datetime import time print(time()) print(time()) # 00:00:00 # 00:00:00 也可以在一行导入同一模块下的多个功能，以逗号进行分割： from time import time, sleep, ctime 别名的使用 使用as语句来为冲突的标识符取一个别名： from time import time as ttime from datetime import time as dtime print(ttime()) print(dtime()) # 1621665953.605452 # 00:00:00 *与__all__ 使用from 模块名 import *的方式，可以导入该模块下的所有标识符。 如果你是该模块的开发者，则可以通过__all__属性规定这种导入方式允许哪些标识符被导入。 在__all__中的标识符，可以被from 模块名 import *的方式进行导入 未在__all__中的标识符，不会被from 模块名 import *的方式进行导入 如果未定义__all__属性，则所有的标识符都会from 模块名 import *的方式进行导入 如下，在m1.py模块文件中，定义了1个getMax()的接口暴露函数，此外还有1个内部处理函数computeMax()以及模块说明变量desc： # m1.py def getMax(iterable): currentMax = None for index, item in enumerate(iterable): if index == 0: currentMax = computeMax(item, iterable[index + 1]) elif currentMax != item: currentMax = computeMax(currentMax, item) return currentMax def computeMax(x, y): return x if x > y else y desc = \"this is module m1\" __all__ = (\"getMax\", \"desc\") # ❶ ❶：__all__的格式必须是Tuple(str, str) 现在run.py中如果使用from m1 import *，则会将__all__中的所有标识符进行导入，下面示例中由于使用了未在__all__中定义的标识符，则抛出NameError的异常： # run.py from m1 import * print(getMax) print(desc) print(computeMax) # # this is module m1 # NameError: name 'computeMax' is not defined 循环导入问题 模块a中导入模块b，模块b中又导入了模块a，且导入语句都在首行，此时将引发循环导入的问题。 示例如下： # run.py import m1 print(m1.desc) # m1.py import m2 desc = \"this is module m1\" print(m2.desc) # m2.py import m1 desc = \"this is module m2\" print(m1.desc) 运行run.py，结果如下： AttributeError: module 'm2' has no attribute 'desc' 异常原因在于： run.py首行导入了m1，m1首行导入了m2，m2首行又导入了m1，导致m1.desc未能成功进行对象声明，故抛出异常。 执行步骤： run.py：import m1 (将m1加载至内存中) m1.py：import m2 (将m2加载至内存中) m2.py：import m1 (m1已经执行了，不重复执行了) m2.py：desc = \"this is module m2” m2.py：print(m1.desc)）(m1.desc没有进行对象声明，抛出异常) 解决办法： 将m1导入m2的语句放在行尾 将m1导入m2的语句放入函数中，并在行尾执行函数 办法1： # m1.py desc = \"this is module m1\" import m2 print(m2.desc) 办法2： desc = \"this is module m1\" def importFunction(): import m2 print(m2.desc) importFunction() 模块查找 查找优先级 无论是from .. import ..语句还是import语句，在导入模块时都会涉及到模块位置查找的问题。 模块查找优先级如下： 先查找内存 后查找硬盘 当一个模块被导入过一次后，就会加载至内存中，重复导入便可直接从内存中拿到该模块，而存在于内存中的模块代码是不会被执行的。 sys.modules sys.modules用于查看存在于内存中的模块，如果要导入的模块存在于这里面，就直接进行导入，而不执行其中的代码： >>> import sys >>> sys.modules ... 当一个存在于硬盘之上的模块被导入时，则会将该模块加载至内存中，只要是存在于内存中的模块，重复导入时就不会执行其中的代码了。 如下示例，第一次导入存在于硬盘之上的m1模块后，它被加载至了内存中： >>> tuple(sys.modules.items())[-1] ('rlcompleter', ) >>> import m1 >>> tuple(sys.modules.items())[-1] (('m1', )) Ps：其实当Python解释器启动时，会自动的运行一遍所有的内置模块并加载至内存中，因为这些内置模块也是存放在磁盘下的，你可以在Python解释器安装根目录的lib目录下找到它们。 sys.path 当内存中没有模块路径时，将按照sys.path的路径顺序依次在磁盘中查找。 如果在PyCharm下打印sys.path，它会做一些优化处理，比原生的REPL环境多出一些查找路径，下面使用#号进行标注： [ # '/Users/yunya/PycharmProjects/Project', # '/Users/yunya/PycharmProjects/Project', # '/Applications/PyCharm.app/Contents/plugins/python/helpers/pycharm_display', '/Library/Frameworks/Python.framework/Versions/3.6/lib/python36.zip', '/Library/Frameworks/Python.framework/Versions/3.6/lib/python3.6', '/Library/Frameworks/Python.framework/Versions/3.6/lib/python3.6/lib-dynload', '/Users/yunya/Library/Python/3.6/lib/python/site-packages', '/Library/Frameworks/Python.framework/Versions/3.6/lib/python3.6/site-packages', # '/Applications/PyCharm.app/Contents/plugins/python/helpers/pycharm_matplotlib_backend' ] 原生的REPL环境打印： >>> import sys >>> sys.path [ '', '/Library/Frameworks/Python.framework/Versions/3.6/lib/python36.zip', '/Library/Frameworks/Python.framework/Versions/3.6/lib/python3.6', '/Library/Frameworks/Python.framework/Versions/3.6/lib/python3.6/lib-dynload', '/Users/yunya/Library/Python/3.6/lib/python/site-packages', '/Library/Frameworks/Python.framework/Versions/3.6/lib/python3.6/site-packages' ] >>> 模块导入规范 导入模块时要遵循的一些规范： 导入顺序：内置模块在最上面，第三方模块在中间，自定义模块在下面 自定义模块名风格：蛇形式命名 Ps：Python2中有些模块是驼峰式命名，但是在Python3中都更改为蛇形式命名了，如PyMySQL，更名为pymysql 此外，模块也是一等公民，运行被赋值、传参等等。 模块编写规范 如果要编写自定义模块，也需要遵循一些规范： 首行添加模块文档描述，让别人知道你的模块是干嘛的 减少全局变量的使用，这样在第一次导入模块时会加快导入速度 模块中的类、函数等都需要写好注释 使用 if __name__ == “__main__”:的语句写好测试案例 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-13 20:41:50 "},"Python/Python模块与包/Python包.html":{"url":"Python/Python模块与包/Python包.html","title":"Python包","keywords":"","body":"Python包 包是一个含有__init__.py的文件夹（Python2中必须拥有，Python3中可以省略）。 包的基础单元是模块，当然一个包中也可以包含其他的包，是一组模块的集合。 包的导入 当导入一个包时，将会先执行包下__init__.py文件，于此同时会产生一个包的命名空间。 而在__init__中定义的标识符都会丢入到这个命名空间中。 现在，我们定义了一个包： ├── package # 顶级包 │ ├── __init__.py │ ├── sub1 # 子级包 │ │ ├── __init__.py │ │ └── m1.py # 含有add()函数 │ └── sub2 # 子级包 │ ├── __init__.py │ └── m2.py # 含有multiplication()函数 └── run.py # 启动文件 产生2个问题： 作为包的使用者而言，run.py如何调用到包中的某一个功能呢？ 作为包的开发者而言，包中任意一个模块，如何调用到另一个模块中的功能？ 外部导入 外部导入时，只能通过绝对路径来进行导入，如： # run.py from package.sub1.m1 import add 但如果package的__init__文件中，定义了add的路径，如： # package/__init__.py from package.sub1.m1 import add 则在外部可以省略绝对导入，直接通过package拿到add()函数： # run.py from package import add 这是因为顶级包package的命名空间中，已经有了add()函数的具体指向，所以外部的导入可以简写。 内部导入 内部导入分为绝对导入和相对导入两种。 绝对导入，必须以顶级包作为起始，如我想在m2.py文件中调用m1.py文件中的功能： # package/sub2/m2.py from package.sub1.m1 import add 相对导入是通过1个点和2个点来进行区分，1个点代指当前目录，2个点代指上层目录，如果在m2.py用相对导入调用m1.py文件中的功能，则代码如下所示： # package/sub2/m2.py from ..sub1.m1 import add 导入的约束 外部导入时，如果顶级包__init__.py文件中没有定义某一个功能的具体指向，你只能通过绝对导入的方式。 内部导入时，可以使用绝对导入和相对导入2种方式，个人更喜欢相对导入。 其次，在导包时一定要注意，不论是import还是from语法，.点的左边只能是一个包或者子模块（相对导入除外，.点的左边可以为空），如下所示： # run.py from package.sub1.m1 import add 顶级包 子级包 子模块 使用时没有这种限制，只需要记住使用时必须带上import语句后所有的标识符即可： # 导入时 from package import sub1 # 使用时 sub1.m1.add(1, 2) # 导入时 from package.sub1 import m1 # 使用时 m1.add(1, 2) 包的开发者 做为一名包的开发者，你需要尽可能的方便包的使用者。 多在__init__.py文件中写入子模块、功能的指向。 写好注释，测试用例。 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-13 20:41:50 "},"Python/Python模块与包/time.html":{"url":"Python/Python模块与包/time.html","title":"内置模块：time","keywords":"","body":"time简介 time模块是Python自带的模块，提供了时间的访问和转换功能。 官方文档 time模块中，对时间的表示包含3个概念： 时间戳形式：从1970.1.1 08:00:00（Unix纪元）开始到现在所经历的毫秒数，它int类型 结构化形式：以元组包裹的形式进行时间的展示，它tuple类型 字符串形式：以字符串的形式进行时间的展示，它是str类型 3种表示时间的方式之间可以互相转换，如下图所示： 时间获取 获取时间的方法： 方法 描述 表现形式 time.time() 获取时间戳形式的时间 时间戳 time.localtime() 获取结构化的本地时间 结构化 time.gmtime() 获取结构化的世界时间 结构化 time.asctime() 获取字符串形式的本地时间 字符串 time.ctime() 获取字符串形式的世界时间 字符串 time.strftime() 获取自定义格式的本地时间 字符串 Ps：本地时间在中国以东八区，上海时间时间为准，和世界时间（UTC）差了8小时 示例演示： >>> import time >>> time.time() 1621693706.0193129 >>> time.localtime() time.struct_time(tm_year=2021, tm_mon=5, tm_mday=22, tm_hour=22, tm_min=28, tm_sec=43, tm_wday=5, tm_yday=142, tm_isdst=0) >>> time.gmtime() time.struct_time(tm_year=2021, tm_mon=5, tm_mday=22, tm_hour=14, tm_min=29, tm_sec=0, tm_wday=5, tm_yday=142, tm_isdst=0) >>> time.asctime() 'Sat May 22 22:29:05 2021' >>> time.ctime() 'Sat May 22 22:29:09 2021' >>> time.strftime(\"%Y-%m-%d %H:%M:%S\") '2021-05-22 22:29:45' 结构化时间说明 在time.localtime()和time.gmtime()中，可以看到元组中有很多看不懂的数据项属性组成，它们的释义如下： 属性 描述 tm_year 年 tm_mon 月 tm_mday 日 tm_ hour 时 tm_min 分 tm_sec 秒 tm_wday 星期几，从0开始计算，一周就是0-6 tm_yday 该年份的第几天 tm_isdst 夏令营时间 这些属性都可以单独的提取出来，如获取这一年的年、月、日： >>> time.localtime().tm_year 2021 >>> time.localtime().tm_mon 5 >>> time.localtime().tm_mday 22 time.strftime() 放入一段字符串，将时间格式化出来，如下所示： >>> time.strftime(\"%Y-%m-%d %H:%M:%S\") '2021-05-22 22:29:45' %Y-%m%d这些都代表格式化时间的占位符，分别代表年月日等信息。 如下表所示： 符号 描述 %Y 格式化年份 %m 格式化月份 %d 格式化天数 %H 格式化小时 %M 格式化分钟 %S 格式化秒数 %X 等同于 “%H:%M:%S” 如想了解更多，参照官网示例截图： %accordion%点我查看%accordion% %/accordion% 时间转换 转换方法 以下是时间表现形式互相转换的方法： 方法 描述 time.mktime() 放入结构化时间，转换为时间戳时间 time.strftime() 放入结构化时间，转换为字符串时间 time.strptime() 放入字符串时间，转换为结构化时间 time.localtime() 放入时间戳时间，转换为结构化的本地时间 time.gmtime() 放入时间戳时间，转换为结构化的世界时间 示例演示： >>> time.mktime(time.localtime()) 1621694964.0 >>> time.strftime(\"%Y-%m-%d %X\", time.gmtime()) '2021-05-22 14:50:01' >>> time.strptime(time.ctime()) time.struct_time(tm_year=2021, tm_mon=5, tm_mday=22, tm_hour=22, tm_min=50, tm_sec=15, tm_wday=5, tm_yday=142, tm_isdst=-1) >>> time.localtime(time.time()) time.struct_time(tm_year=2021, tm_mon=5, tm_mday=22, tm_hour=22, tm_min=50, tm_sec=33, tm_wday=5, tm_yday=142, tm_isdst=0) >>> time.gmtime(time.time()) time.struct_time(tm_year=2021, tm_mon=5, tm_mday=22, tm_hour=14, tm_min=51, tm_sec=4, tm_wday=5, tm_yday=142, tm_isdst=0) 常用操作 将时间戳转换为固定的UTC时间字符串格式： >>> time.ctime(00) 'Thu Jan 1 08:00:00 1970' 将时间戳转换为本地时间的字符串表现形式： >>> t = 1293495903 # 有一个时间戳 >>> stuct = time.localtime(t) # 先将其转为本地的结构化时间 >>> stringTime = time.strftime(\"%Y-%m-%d %X\", stuct) # 再将其转换为字符串时间 >>> stringTime '2010-12-28 08:25:03' 将时间戳转换为世界时间的字符串表现形式： >>> t = 1293495903 # 有一个时间戳 >>> stuct = time.gmtime(t) # 先将其转为世界的结构化时间 >>> stringTime = time.strftime(\"%Y-%m-%d %X\", stuct) # 再将其转换为字符串时间 >>> stringTime '2010-12-28 00:25:03' 将一个字符串时间转换为时间戳： >>> stringTime = \"1998-01-26 00:00:10\" # 有一个字符串时间 >>> stuct = time.strptime(stringTime, \"%Y-%m-%d %X\") # 先将其转换为结构化时间 >>> stamp = time.mktime(stuct) # 再将其转换为时间戳 >>> stamp 885744010.0 线程睡眠 通过time.sleep()方法，可指定主线程睡眠多少秒，如下所示，第2个print()将在2秒后运行： import time print(\"start\") time.sleep(2) print(\"end\") 其他操作 日期判断 根据时间戳，获取7天后的时间： >>> currentTime = time.time() >>> sum7dayTime = currentTime + 7 * 86400 >>> time.strftime(\"%Y-%m-%d\", time.localtime(sum7dayTime)) '2021-05-29' 根据时间戳，获取3天前的时间： >>> currentTime = time.time() >>> sub3dayTime = currentTime - 3 * 86400 >>> time.strftime(\"%Y-%m-%d\", time.localtime(sub3dayTime)) '2021-05-19' 如果是时间戳操作，谨记1天是86400秒即可。 定时任务 脚本启动后，每隔一分钟，向屏幕打印一次hello world： import time currentSec = time.localtime().tm_sec while 1: if time.localtime().tm_sec == currentSec: print(\"hello world\") time.sleep(1) 延时任务 脚本启动后的一分钟时，打印一次hello world： import time currentTime = time.time() runTime = currentTime + 60 while 1: if time.time() == runTime: print(\"hello world\") break print(\"任务执行完毕\") Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-13 20:41:50 "},"Python/Python模块与包/datetime.html":{"url":"Python/Python模块与包/datetime.html","title":"内置模块：datetime","keywords":"","body":"datetime简介 datetime模块是Python内置模块，相比于time模块能够更加方便的操纵时间。 官方文档 以下举例部分常用方法： 方法 描述 datetime.datetime() 实例化返回一个datetime的对象 datetime.datetime.now() 获取本地时间，返回一个datetime的对象 datetime.datetime.utcnow() 获取世界时间，返回一个datetime的对象 datetime.datetime.fromtimestamp() 放入时间戳时间，直接转换为本地的datetime对象时间 datetime.datetime.utcfromtimestamp() 放入时间戳时间，直接转换为世界的的datetime对象时间 datetime.timedelta() 在一个datetime对象时间的基础上进行加减，返回一个新的datetime的对象 datetime.datetime.weekday() 放入一个datetime对象，获取该对象是那一周的第几天，从0开始计算，一周就是0-6 对象获取 datetime.datetime.now()和datetime.datetime.utcnow()都可以获取一个表示当前时间的datetime对象。 >>> import datetime >>> datetime.datetime.now() datetime.datetime(2021, 5, 22, 23, 31, 43, 468077) >>> datetime.datetime.utcnow() datetime.datetime(2021, 5, 22, 15, 31, 52, 841214) 为datetime.datetime.fromtimestamp()放入一个时间戳可直接获取到表示本地时间的datetime的对象： >>> datetime.datetime.fromtimestamp(11111) datetime.date(1970, 1, 1) >>> datetime.datetime.utcfromtimestamp(11111) datetime.datetime(1970, 1, 1, 3, 5, 11) datetime对象是str类型的更高一级封装，你可以将datetime对象转换为str类型： >>> str(datetime.datetime.now()) '2021-05-23 00:06:03.271989' 对象属性 一个datetime对象拥有很多时间属性，如下表所示： 属性 描述 year 年份（int） month 月份（int） day 天数（int） hour 时数（int） minute 分数（int） second 秒数（int） microsecond 毫秒数（int） 你可以快速的获取它们： >>> currentTime = datetime.datetime.now() >>> currentTime.year 2021 >>> currentTime.month 5 >>> currentTime.day 22 >>> currentTime.hour 23 >>> currentTime.minute 48 >>> currentTime.second 52 >>> currentTime.microsecond 527012 对象方法 一个datetime对象拥有很多方法，如下表所示： 方法 描述 datetimeObject.timestamp() 返回一个时间戳，不同于time模块的时间戳，该方法返回的是一个float类型 datetimeObject.timetuple() 返回与time.localtime()兼容的本地时间元组 datetimeObject.utctimetuple() 返回与time.gmtime()兼容的UTC时间元组 datetimeObject.ctime() 返回ctime()样式字符串 datetimeObject.isoformat() 根据ISO格式返回时间字符串 datetimeObject.strptime() 类似于time.strptime() datetimeObject.tzname() 返回时区名字 datetimeObject.replace() 替换一个字符串格式的时间中某部分，返回一个新的datetime的对象 由于这些方法使用的时候并不多，所以只举例一个时间替换。 将当前时间的年份替换为1998年： >>> currentTime = datetime.datetime.now() >>> currentTime.replace(year=1998) datetime.datetime(1998, 5, 23, 0, 22, 24, 698922) 时间加减 datetime对象允许通过和datetime.timedelta()进行加减，以便进行时间的计算。 时间加减中不支持年份的计算，可以用365天代替 当前时间加3天： >>> sum3dayTime = datetime.timedelta(+3) + currentTime >>> sum3dayTime datetime.datetime(2021, 5, 26, 0, 15, 15, 405378) 当前时间-3天： >>> sub3dayTime = datetime.timedelta(-3) + currentTime >>> sub3dayTime datetime.datetime(2021, 5, 20, 0, 15, 15, 405378) 当前时间加3小时： >>> sum3hours = datetime.timedelta(hours=+3) + currentTime >>> sum3hours datetime.datetime(2021, 5, 23, 3, 15, 15, 405378) 当前时间减3小时： >>> sub3hours = datetime.timedelta(hours=-3) + currentTime >>> sub3hours datetime.datetime(2021, 5, 22, 21, 15, 15, 405378) Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-13 20:41:50 "},"Python/Python模块与包/random.html":{"url":"Python/Python模块与包/random.html","title":"内置模块：random","keywords":"","body":"random简介 random模块是Python自带的模块，该模块实现了各种分布的伪随机数生成器。 官方文档 以下举例部分常用方法： 方法 描述 random.randint(1, 3) 从1-3之间随机生成一个整数 random.randrange(1, 3) 从1-2之间随机生成一个整数 random.random() 生成大于0且小于1的浮点数 random.uniform(1, 3) 生成大于1且小于3的浮点数 random.choice(seq) 从序列中随机取出1个数据项 random.sample(seq, 2) 从序列中随机取出指定个数据项，这里是2，以列表形式返回 random.shuffle(seq) 将传入的拥有索引的序列进行打乱，原地打乱，不返回新序列 整数生成 random.randint()是顾头顾尾的生成随机整数： >>> import random >>> random.randint(1, 3) 1 >>> random.randint(1, 3) 2 >>> random.randint(1, 3) 3 random.randrange()是顾头不顾尾的生成随机整数： >>> random.randrange(1, 3) 1 >>> random.randrange(1, 3) 2 浮点数生成 random.random()生成浮点数的范围总是介于0和1之间： >>> random.random() 0.818462343335113 random.uniform()可指定生成浮点数的范围： >>> random.uniform(1, 3) 2.810443694822667 数据项抽取 random.choice()可以从一个序列中随机抽取出一个数据项： >>> random.choice(range(10)) 1 random.sample()可以从一个序列中随机抽取出多个数据项： >>> random.sample(range(10), 2) [1, 0] 它们貌似均不支持字典的随机抽取。 生成乱序列 random.shuffle()可以传入一个线性结构的序列，并将其中的数据项进行随机的打乱： >>> li1 = [i for i in range(10)] >>> random.shuffle(li1) >>> li1 [1, 5, 6, 3, 7, 2, 9, 8, 4, 0] >>> random.shuffle(li1) >>> li1 [1, 5, 4, 3, 7, 0, 9, 6, 8, 2 生成验证码 验证码总是随机的，因此可以通过random模块进行实现生成： import random def getVerificationCode(bitNumber): code = \"\" for i in range(bitNumber): code += random.choice( [ str(random.randint(1, 9)), chr(random.randint(65, 91)) # ❶ ] ) return code code = getVerificationCode(6) print(code) ❶：65-90是大写的A-Z的ASCII码表示范围 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-13 20:41:50 "},"Python/Python模块与包/os.html":{"url":"Python/Python模块与包/os.html","title":"内置模块：os","keywords":"","body":"os简介 os模块是Python内置模块，提供了各种使用Python对操作系统提供操纵的接口。 官方文档 以下举例部分常用方法和属性： 方法/属性 描述 os.curdir 总是返回一个字符串，“.”，代指当前目录 os.pardir 总是返回一个字符串，“..”，代指当前父级目录 os.sep 返回当前平台下的路径分隔符，Windows下为“\\”，Unix下为“/” os.linesep 返回当前平台下的行终止符，Windows下为“\\r\\n”，Unix下为“\\n” os.pathsep 返回当前平台下的用于分割文件的分隔符，Windows下为“;”，Unix下为“:” os.name 返回当前平台的信息，Windows下为“nt”，Unix下为“posix” os.environ 获取系统环境变量 os.system(“command”) 运行shell命令 os.listdir(“dirName”) 获取指定目录下的所有项目，相当于ls命令，以列表方式返回结果 os.getcwd() 获取当前脚本的工作目录，相当于pwd命令 os.chdir(“dirName”) 改变当前脚本的工作目录，相当于cd命令 os.makedir(“dirName”) 生成单级的空目录，相当于mkdir命令 os.makedirs(“dirName1/dirName2”) 生成多层递归目录，相当于mkdir -p命令 os.rmdir(“dirName”) 删除单级的空目录 os.removedirs(“dirName”) 删除多层递归目录，前提是该目录必须为空 os.remove(“fileName”) 删除一个文件 os.rename(“oldName”, “newName”) 重命名文件/目录 os.path.abspath(“path”) 返回当前path的绝对路径 os.path.split(“path”) 将path分为2部分，返回元组，索引0是路径，索引1是文件 os.path.dirname(“path”) 返回path的路径部分，相当于上面方法的索引0 os.path.basename(“path”) 返回path的路径部分，相当于上面方法的索引1，如果path是以“/”或者“\\”结尾，则返回None os.path.join(“path1”, “path2”) 将多个path进行组合，相当于os.path.split()的反操作 os.path.exists(“path”) 判断path是否存在，返回布尔值 os.path.isabs(“path”) 判断path是否是绝对路径，返回布尔值 os.path.isfile(“path”) 判断path是否是一个文件路径，返回布尔值 os.path.isdir(“path”) 判断path是否是一个目录路径，返回布尔值 os.stat(“path”) 获取path所指文件/目录的相关信息 os.path.getatime(“path”) 获取path所指文件/目录的最后存取时间 os.path.getmtime(“path”) 获取path所指文件/目录的最后修改时间 os.path.getsize(“path”) 获取path所指文件/目录的大小 平台信息 根据以下一些属性，可获取平台信息： 属性 描述 os.curdir 总是返回一个字符串，“.”，代指当前目录 os.pardir 总是返回一个字符串，“..”，代指当前父级目录 os.sep 返回当前平台下的路径分隔符，Windows下为“\\”，Unix下为“/” os.linesep 返回当前平台下的行终止符，Windows下为“\\t\\n”，Unix下为“\\n” os.pathsep 返回当前平台下的用于分割文件的分隔符，Windows下为“;”，Unix下为“:” os.name 返回当前平台的信息，Windows下为“nt”，Unix下为“posix” os.environ 获取系统环境变量 os.environ是一个全局字典，你可以将它当做普通字典进行操作。 >>> os.environ ... >>> os.environ[\"k1\"] = \"v1\" >>> os.environ.get(\"k1\") 'v1' 此外，它是全局的，这意味着同一个项目之中任何地方都能随时获取到它，因此可以用它来存储一些较为私密的信息，如数据库链接IP+PORT+USER+PASSWORLD。 使用该字典时需要注意key必须是str类型，若是其他类型则会抛出异常。 目录操作 使用以下一些方法，可对目录做出操作： 方法 描述 os.system(“command”) 运行shell命令 os.listdir(“dirName”) 获取指定目录下的所有项目，相当于ls命令，以列表方式返回结果 os.getcwd() 获取当前脚本的工作目录，相当于pwd命令 os.chdir(“dirName”) 改变当前脚本的工作目录，相当于cd命令 os.makedir(“dirName”) 生成单级的空目录，相当于mkdir命令 os.makedirs(“dirName1/dirName2”) 生成多层递归目录，相当于mkdir -p命令 os.rmdir(“dirName”) 删除单级的空目录 os.removedirs(“dirName”) 删除多层递归目录，前提是该目录必须为空 os.remove(“fileName”) 删除一个文件 os.rename(“oldName”, “newName”) 重命名文件/目录 os.system()应该是一个比较常用的方法，它可以运行任何的shell命令： >>> os.system(\"tree .\") >>> os.system(\"ifconfig\") 但是os.system()如果在Windows环境下的PyCharm中进行使用，则会抛出异常。 因为Windows平台执行命令的返回结果是采用GBK编码，而PyCharm中使用UTF8对结果进行解码就会产生乱码问题。 路径操作 路径操作应该是os模块中比较常用的： 方法 描述 os.path.abspath(“path”) 返回当前path的绝对路径 os.path.split(“path”) 将path分为2部分，返回元组，索引0是路径，索引1是文件 os.path.dirname(“path”) 返回path的路径部分，相当于上面方法的索引0 os.path.basename(“path”) 返回path的路径部分，相当于上面方法的索引1，如果path是以“/”或者“\\”结尾，则返回None os.path.join(“path1”, “path2”) 将多个path进行组合，相当于os.path.split()的反操作 os.path.exists(“path”) 判断path是否存在，返回布尔值 os.path.isabs(“path”) 判断path是否是绝对路径，返回布尔值 os.path.isfile(“path”) 判断path是否是一个文件路径，返回布尔值 os.path.isdir(“path”) 判断path是否是一个目录路径，返回布尔值 示例演示os.path.join()和os.path.split()： >>> dirName, fileName = os.path.split(\"/Users/yunya/document/os模块.md\") >>> dirName '/Users/yunya/document' >>> fileName 'os模块.md' >>> newPath = os.path.join(\"/\", \"Users\", \"yunya\", \"document\", \"os模块.md\") >>> newPath '/Users/yunya/document/os模块.md' >>> 信息获取 信息获取也有时候会用到： 方法 描述 os.stat(“path”) 获取path所指文件/目录的相关信息 os.path.getatime(“path”) 获取path所指文件/目录的最后存取时间 os.path.getmtime(“path”) 获取path所指文件/目录的最后修改时间 os.path.getsize(“path”) 获取path所指文件/目录的大小 项目模块查找 项目启动不了? 在之前介绍Python模块一章节中说到PyCharm和原生解释器在查找模块时的sys.path会有所不同。 PyCharm会自动的新增几行模块查找路径，而原生解释器则不会进行新增。 这样会产生一个问题，即项目上线后通过原生解释器进行启动项目时会发现找不到模块。 如，我们有一个下面结构的项目： Project │ ├── bin │ └── run.py # 入口文件 └── view ├── __init__.py └── views.py # 视图层 定义了main()函数 当run.py进行执行后，Python工作目录就被定义在了Project/bin/run.py一层。 from view.views import main if __name__ == '__main__': main() 如果在PyCharm中执行run.py，则不会抛出异常，它能顺利的找到view模块，这是因为PyCharm将工作目录的上层、上上层也加入到了sys.path即模块查找路径中： [ '/Users/yunya/PycharmProjects/Project/bin', '/Users/yunya/PycharmProjects/Project', '...' ] 这样查找模块范围就会大很多： Project # 上上层能找到 │ ├── bin # 上层找不到 │ └── run.py # 本层找不到 └── view ├── __init__.py └── views.py 但是如果在Python原生解释器环境下，调用执行run.py脚本，则会提示找不到view模块，因为view模块仅能在上上层被找到： Project # 这里才能找到 │ ├── bin │ └── run.py # 找不到 └── view ├── __init__.py └── views.py 如何解决这个问题？只需要在run.py脚本中将上上层路径加入至sys.path即可： import sys import os sys.path.append(os.path.abspath(os.path.dirname(os.path.dirname(__file__)))) from view.views import main if __name__ == '__main__': main() 这样再次使用Python原生解释器通过run.py脚本启动项目，就不会发生任何问题了。 OpenStack对路径的处理 在OpenStack中，对这种项目模块查找路径的处理采用了截然不同的方式： import os import os, sys print(os.path.abspath(__file__)) possible_topdir = os.path.normpath(os.path.join( # ❶ __file__, os.pardir, # 上一级，相当于手动输入\"..\" os.pardir, )) print(possible_topdir) ❶：os.path.normpath()可以将一个不规范的路径变为规范路径 这样也能够达到相同的效果。 Django3.x对路径的处理 Django3以前，对项目模块查找路径的处理采用了和我们相同的方式： BASE_DIR = os.path.dirname(os.path.dirname(__file__)) print(BASE_DIR) 在Django3之后，则使用pathlib模块代替了os模块，其实本质都是一样的： from pathlib import Path root = Path(__file__) res = root.parent.parent # ❶ print(res) ❶：取上层的上层 补充一点pathlib的知识，对于pathlib的路径拼接直接使用 / 符号即可，符号左边为Path对象，右边为str类型。 与os.path.join()拥有相同的效果。 print(Path(\"User/YunYa\") / r\"a/b/c\") # User\\YunYa\\a\\b\\c 无论是os.path.join()还是pathlib的/进行路径拼接，都会选择出适合当前平台的路径分隔符。 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-13 20:41:50 "},"Python/Python模块与包/sys.html":{"url":"Python/Python模块与包/sys.html","title":"内置模块：sys","keywords":"","body":"sys简介 sys模块是Python内置模块，提供了各种系统相关的参数和函数。 官方文档 以下举例部分常用方法和属性： 方法/属性 描述 sys.platform 返回操作系统平台名称 sys.version 获取Python解释程序的版本信息 sys.builtin_module_names 获取内置的所有模块名，元组形式返回 sys.modules 返回以加载至内存之中的模块及路径 sys.path 返回模块在硬盘中的搜索路径 sys.stdin Python标准输入通道，input()函数的底层实现 sys.stdout Python标准输出通道，print()函数的底层实现 sys.stderr Python标准输入错误通道 sys.getrecursionlimit() 获取当前Python中最大递归层级 sys.setrecursionlimit() 设置当前Python中最大递归层级 sys._getframe(0).f_code.co_name 获取被调用函数的名称 sys._getframe(1).f_code.co_name 获取被调用函数是被哪一个函数所嵌套调用的，若不是被嵌套调用则返回module sys._getframe().f_back.f_lineno 获取被调用函数在被调用时所处代码行数 sys._getframe().f_code.co_filename 获取被调用函数所在模块文件名 sys.getrefcount() 获取对象的引用计数 sys.argv 获取通过脚本调用式传递的数据 修改递归层级 修改递归层级已经介绍过一次了，默认Python的最大递归层级是1000层，我们可以对其进行修改： >>> sys >>> sys.getrecursionlimit() 1000 >>> sys.setrecursionlimit(10000) >>> sys.getrecursionlimit() 10000 函数栈帧信息 sys._getframe()能够获取到函数的栈帧对象，我们知道函数的栈帧对象中封存了一些函数运行时的信息。 那么通过下面这些属性就能拿到函数里栈帧的某些数据： sys._getframe(0).f_code.co_name：获取被调用函数的名称 sys._getframe(1).f_code.co_name：获取被调用函数是被哪一个函数所嵌套调用的，若不是被嵌套调用则返回module sys._getframe().f_back.f_lineno：获取被调用函数在被调用时所处代码行数 sys._getframe().f_code.co_filename：获取被调用函数所在模块文件名 import sys def func(): print(sys._getframe(0).f_code.co_name) print(sys._getframe(1).f_code.co_name) print(sys._getframe().f_back.f_lineno) print(sys._getframe().f_code.co_filename) func() 脚本传入参数 我们都知道Python解释器可以通过以下方式进行.py文件的调用： $ python3 demo.py 但是你可能不知道通过sys.argv属性可以获取通过脚本调用式传递的数据，如下启动.py脚本时传入了1、2、3： $ python3 demo.py 1 2 3 那么现在sys.argv就会接受到这3个数据，变成下面的格式： sys.argv = [\"scriptPath\", \"1\", \"2\", \"3\"] 基于这个特性，我们来做一个下载模拟器： import random import sys import time def download(): scale = 40 print(\"开始下载文件:{0}\".format(sys.argv[2]).center(scale + 10, '-')) totalSize = random.randint(1000, 2000) currentSize = totalSize / scale for i in range(scale + 1): a = '█' * i b = '_' * (scale - i) c = (i / scale) * 100 print('''\\r{0:^3.2f}% | {1}{2} | {3:.2f}/{4:.2f}(MB)'''.format(c, a, b, currentSize * i, totalSize), end=\"\") time.sleep(0.1) print(\"\\n\" + \"执行结束\".center(scale + 10, '-')) def main(): try: runFunc = eval(sys.argv[1]) except Exception: print(\"输入有误！\", file=sys.stderr) exit() else: runFunc() if __name__ == '__main__': main() 启动时输入参数： python3 ./bin/run.py download test.text Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-13 20:41:50 "},"Python/Python模块与包/json&pickle&shelve.html":{"url":"Python/Python模块与包/json&pickle&shelve.html","title":"内置模块：json&pickle&shelve","keywords":"","body":"序列化 序列化是指将在内存中的数据变成为可存储或者可传输的数据。 Python中称序列化为pickling，而其他编程语言中则称之为serialization、marshalling、flattening等等，都是一个意思。 序列化最重要的目的是数据持久化保存，以及数据跨平台传输： 持久化保存：数据无法在内存中长期驻留，因此可以将其转变为某种格式并写入到磁盘之中 跨平台传输：不同的编程语言中对于数据的表示都是不同的，如Python中的set在很多语言中就不具备，故可以将数据进行序列化，变为一种大家都认识的格式 json JSON格式最早来源于JavaScript语言，现在已经成为跨平台语言传输的通用格式。 它的操纵及其简单，以下是JSON与Python中数据类型的对应关系： Python数据类型 JSON格式表示 dict {} list [] str string int or float int or float True or False true or false None Null JSON优点是操纵简单、跨语言传输十分方便，因为它采用字符串进行存储。 JSON缺点是仅支持Python基本数据类型，像函数、类这种都不被支持。 Python中进行JSON格式化，可以选择内置的json模块： 官方文档 常用方法一览： 方法 描述 json.dumps() 将Python中的基本数据类型序列化为JSON格式的字符串 json.loads() 将JSON格式字符串反序列化为Python中的基本数据类型 json.dump() 同json.dumps()，不过写入文件更方便 json.load() 同json.loads()，不过读取文件更方便 序列化 使用json.dumps()可以将Python中的基本数据类型序列化为JSON格式的字符串： >>> import json >>> userMessage = {\"name\" : \"yunya\", \"age\" : \"18\", \"gender\" : True, \"hobby\" : [\"read\", \"playGame\"]} >>> json.dumps(userMessage) '{\"name\": \"yunya\", \"age\": \"18\", \"gender\": true, \"hobby\": [\"read\", \"playGame\"]}' 如果想将序列化的结果进行持久化保存，可以使用json.dump()方法，它可以指定输出对象为文件句柄，如下示例： >>> import json >>> userMessage = {\"name\" : \"yunya\", \"age\" : \"18\", \"gender\" : True, \"hobby\" : [\"read\", \"playGame\"]} >>> with open(file=\"test.json\", mode=\"wt\", encoding=\"utf8\") as f: json.dump(userMessage,fp=f) 反序列化 使用json.loads()可以将JSON格式字符串反序列化为Python中的基本数据类型： >>> userJsonStr = '{\"name\": \"yunya\", \"age\": \"18\", \"gender\": true, \"hobby\": [\"read\", \"playGame\"]}' >>> json.loads(userJsonStr) {'name': 'yunya', 'age': '18', 'gender': True, 'hobby': ['read', 'playGame']} 如果想从文件中读取JSON字符串并进行反序列化，可以使用json.load()方法，它可以指定读取对象为文件句柄，如下所示： >>> import json >>> with open(file=\"test.json\", mode=\"rt\", encoding=\"utf8\") as f: userMessage = json.load(fp=f) >>> userMessage {'name': 'yunya', 'age': '18', 'gender': True, 'hobby': ['read', 'playGame']} 序列化的过程 Python的基本数据类型转换为JSON字符串时，经历了什么？ 总计可分为2步： 修改str的单引号为双引号 根据JSON与Python中数据类型的对应关系，将数据进行包装转换为JSON表现形式 示例、修改str的单引号为双引号： >>> pyStr = 'string' >>> jsonStr = json.dumps(pyStr) >>> jsonStr '\"string\" 示例、根据JSON与Python中数据类型的对应关系，将数据进行包装转换为JSON表现形式： >>> pyType = None >>> jsonType = json.dumps(pyType) >>> jsonType 'null' 中文显示 如果JSON序列化的字符串中带有中文，则将其转变为Unicode的16进制表现形式： >>> pyStr = \"云崖先生\" >>> json.dumps(pyStr) '\"\\\\u4e91\\\\u5d16\\\\u5148\\\\u751f\"' 你可以指定序json.dumps()中的关键字参数ensure_ascii为False，此时不会对中文字符进行转换： >>> json.dumps(pyStr, ensure_ascii=False) '\"云崖先生\"' 猴子补丁介绍 Monkey Patch是指用一个补丁偷偷的将一个原本的功能进行替换，使用者并不知道目前使用的功能是已经替换后的功能。 第三方模块ujson相比于json来说性能更加的高效，你可以将它作为猴子补丁偷偷的替换掉json，只需要在项目运行时的入口加入并运行一个替换函数： import json import ujson def monkeyPatchJson(): json.__name__ = \"ujson\" json.dumps = ujson.dumps json.loads = ujson.loads monkeyPatchJson() 修改完毕后，重启项目，后面的代码甚至不需要任何修改，就能使用性能更高的ujson了。 采用猴子补丁之后，如果发现ujson不符合预期，那也可以快速撤掉补丁，删除掉函数的执行语句即可。 序列化非基本数据类型 datetime类型并非是Python基本的数据类型，所以JSON不支持对它的序列化。 import datetime import json now = datetime.datetime.now() strNow = json.dumps(now, ensure_ascii=False) print(strNow) # TypeError: Object of type 'datetime' is not JSON serializable 此时我们可以手动的扩展json.dumps()的功能，让其支持datetime的序列化。 具体思路是将非Python基本数据类型转换为基本数据类型后再使用json.dumps()对其进行序列化，实现步骤如下所示： import datetime import json from json.encoder import JSONEncoder class JsonRealize(JSONEncoder): \"\"\" 该类是自定义序列化非Python基本数据类型的逻辑实现类 主要作用是继承并覆写父类JSONEncoder的default() \"\"\" def default(self, serializeObject): # 发现序列化对象是datetime类型的话，就将其转换为str类型 if isinstance(serializeObject, datetime.datetime): return str(serializeObject) # 如果是其他类型，则交由JSONEncoder的default()进行处理 return JSONEncoder.default(self, serializeObject) if __name__ == '__main__': now = datetime.datetime.now() strNow = json.dumps(now, cls=JsonRealize, ensure_ascii=False) print(strNow) # \"2021-05-23 20:40:49.446823\" json模块使用注意事项 Python3.6以及Python2.7之前均不支持反序列化bytes类型。 也就是说json.loads()一个bytes类型会抛出异常。 pickle 　pickle模块是Python自带的模块，它和json模块的方法全部一致，区别在于pickle序列化后的类型是bytes类型，而json序列化后的类型是字符串类型。 由于要考虑到多语言的兼容性问题，json模块并不支持Python除基本数据类型之外的类型。如：函数类型，类等等。 但是pickle由于只支持Python使用，所以有了更强的对Python序列化对象的支持。 pickle可以序列化函数，类等等，但是并不推荐这么做，因为保存的只有一个内存地址。 另外，由于pickle的局限性太强所以更推荐使用JSON进行序列化操作。 由于很少使用，以及与json模块的方法一致，这里不再进行演示了。 官方文档 shelve shelves是Python自带的模块，它能够更加方便的将Python数据进行持久化保存。 官方文档 它将整个文件看做一个大的字典，将字典中的key看做Python中的标识符，将value看做存储的对象，因此操作起来十分方便。 只需要记住2个方法即可： shelve.open()：打开一个文件，这个文件是可读可写的 shelve.close()：关闭文件 示例演示： >>> import shelve >>> with shelve.open(\"test.txt\") as f: f[\"name\"] = \"Yunya\" f[\"age\"] = 18 f[\"hobby\"] = [\"readBook\", \"playGame\"] >>> with shelve.open(\"test.txt\") as f: name = f.get(\"name\") >>> name 'Yunya' Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-28 21:05:24 "},"Python/Python模块与包/hashlib.html":{"url":"Python/Python模块与包/hashlib.html","title":"内置模块：hashlib","keywords":"","body":"hashlib简介 密码学是一个庞大的领域，总体来说可将该领域中的加密方式分为2大类： 对称加密：可通过加密值反解出内容 非对称加密：不可通过加密值反解出内容 而今天介绍的hashlib模块是Python3中所独有的，提供了一系列的非对称加密算法：hash算法。 在Python2中hashlib模块被拆分成了md5模块和sha模块，它们提供的功能和Python3的hashlib模块相同。 官方文档 以下是该模块提供的部分常用方法及属性： 属性/方法 描述 hashlib.algorithms_guaranteed 以集合方式，列出所有平台所支持的hash算法 hashlib.algorithms_available 以集合方式，列出当前所运行的Python解释器所支持的hash算法 hash.digest_size 以字节表示结果hash对象的大小 hash.block_size 以字节表示的hash算法的内部块大小 hash.name 返回hash对象的规范名称 hash.copy() 返回hash对象的拷贝副本 hash.update() 在已有基础上对hash对象的内容进行更新 hash.hexdigest() 返回16进制的字符串hash值 hash.digest() 返回2进制的字节串hash值 hash特性 Python的字典在键值对数据存储和读取时，就用到了hash算法。 比如：\"k1\" : \"v1\"的键值对在存储过程中，\"k1\"会通过hash()函数得出1个hash值，该hash值与v1一一对应，后续通过dict.get()方法通过\"k1\"找\"v1\"时，内部也是利用的这个hash值来进行查找。 通过字典的种种特性，我们可以顺势推导出hash的一些特性： 相同的内容求hash值，得到的hash结果也必然相同 不能通过hash值反解出内容（或者说反解的代价大到不可能实现，但也不是绝对的） 如果采用相同的hash算法，无论需要校验的内容由多大，得到的hash值长度总是固定的 我们使用内置的hash()函数来验证这3点结论： 1）相同的内容求hash值，得到的hash结果也必然相同： >>> hash(\"hello world\") -484803057 >>> hash(\"HELLO WORLD\") 264022494 >>> hash(\"hello world\") -484803057 2）不能通过hash值反解出内容： >>> hash(\"k1\") -714364401 >>> hash(\"-714364401\") 1936952577 3）如果采用相同的hash算法，无论需要校验的内容有多大，得到的hash值长度总是固定的： >>> hash(\"hello\") 313408759 >>> hash(\"hello, Python3\") -1705693388 算法区别 由于hash算法的特性，它常被用于一致性校验、密码存储等领域。 其中最著名的hash算法就是MD5，它被称为永不可破的hash算法，但随着技术的发展MD5已经不那么可靠了，它可以用撞库的方式对其进行反解。 而SHA256作为MD5的加强版，是目前的主流方案。 关于MD5和SHA家族的区别在于使用的加密算法不一样，以及它们生成的hash值长度不同： MD5较SHA家族的hash值要短一些，因此生成速度更快一点 对暴力破解来说，SHA家族的hash值比MD5的hash值更安全，更值得信赖 MD5：128位 SHA1：160位 SHA256：256位 如果你的项目安全等级较高，可采用SHA256作为加密方式，其他情况下使用MD5即可。 模块使用 hashlib模块的使用非常简单，总体来说先要生成一个hash对象，然后再填入字节串即可。 首先是普通的使用，以MD5举例： >>> import hashlib >>> m = hashlib.md5(\"hello world\".encode(\"u8\")) >>> m.digest() b'^\\xb6;\\xbb\\xe0\\x1e\\xee\\xd0\\x93\\xcb\"\\xbb\\x8fZ\\xcd\\xc3' 如果对一个大字符串生成hash值，可使用update()方法在原有hash对象基础上进行内容更新： >>> m = hashlib.md5() >>> m.update(\"line1\".encode(\"u8\")) >>> m.update(\"line2\".encode(\"u8\")) >>> m.update(\"line3\".encode(\"u8\")) >>> m.digest() b'\\xcc\\x0c\\x81\\xcdsha256的加密方式与md5的加密使用相同，如下所示： >>> m = hashlib.sha256(\"hello world\".encode(\"u8\")) >>> m.digest() b\"\\xb9M'\\xb9\\x93M>\\x08\\xa5.R\\xd7\\xda}\\xab\\xfa\\xc4\\x84\\xef\\xe3zS\\x80\\xee\\x90\\x88\\xf7\\xac\\xe2\\xef\\xcd\\xe9\" 基本使用就介绍完毕了，是不是非常简单呢？ 撞库介绍 在密码破解领域，有一个百试不爽的方法就是撞库破解。 撞库是指通过一个庞大的数据库来记录未加密字符串与加密后的值的一种映射关系，理论上来说只要这个数据库无限大，那么生成的hash值都能在这里找到其对应的生成字符串。 举个例子： 我现在有1个字符串，I LOVE YOU。 对他进行hash加密得到的结果假设为3242。 现在将这个对应关系放到数据库中，及3242这个hash值对应的字符串为I LOVE YOU。 如果有人要对3242进行反解，通过查询数据库即可知道结果。 这个思路非常的简单粗暴，但个人是不可能进行数据库的完善和搭建。 在Google上如果搜索MD5反解，应该能找到一些撞库网站，但大多数都是付费的，如果感兴趣可以试一试。 加盐验证 为了防止你的加密内容被撞库反解，我们可以使用加盐的策略来对已加密的内容进行二次加密。 整体思路如下，我们以一个普通的用户登陆作为案例： Server端有一个固定的字符串，被称之为盐 用户第一次注册后，要将用户名和密码写入到数据库中，此时数据库中的密码应当密文存储，且不可被反解，做到仅有用户知道自己的密码，连开发人员都不得而知的状态是最完美的 存储密码的时候，对明文密码进行hash加密，并在其中掺盐，得到密文hash密码进行存储 用户登陆的时候，将用户登陆时发送的明文密码也进行hash加密和掺盐，并且通过登陆的用户名获取到存储在数据库中的密文hash密码，两者进行比对，若一致则登陆成功，若不一致则登陆失败 当数据库被黑客攻破后，只要保证盐不泄露，那么他就没有任何办法破解出用户的密码 理论很复杂，实操很简单。如下所示： >>> salt = \"slat\".encode(\"u8\") >>> userPwd = \"123456\".encode(\"u8\") >>> hashObject = hashlib.md5(salt) # ❶ >>> hashObject.update(userPwd) # ❷ >>> savePwd = hashObject.digest() # ❶ >>> savePwd b'ELr\\x05\\x14$z=\\x1d\\x19(^4L>n' >>> >>> >>> reLoginPwd = \"123456\".encode(\"u8\") >>> hashObject = hashlib.md5(salt) # ❶ >>> hashObject.update(reLoginPwd)　 # ❷ >>> getPwd = hashObject.digest() # ❸ >>> getPwd == savePwd # ❹ True ❶：加盐 ❷：加入用户内容 ❸：获得存储密码 ❹：对比用户重登陆的密码hash值是否和以存储的密码hash值一致 文件校验 在Server端对Client端发送文件的过程中，该文件可能被黑客截取做出一些篡改，如下所示： server端 ---------> client端 | | 可能被黑客窃取，修改下载文件 此时就需要使用文件校验来确保安全性了： 在发送文件的时候要让用户知道我们文件本身的hash校验值 用户下载完成后将得出的结果与我们的hash校验值做对比 如果一致则文件没有被篡改过 如果不一致则文件已被篡改过 我们有2种方式，来进行文件校验的实现。 下面将采用模拟Server端生成文件校验hash值的整个过程。 首先是方式1，将文件所有内容hash校验一遍，安全系数最高，速度最慢。 res = \"\" m = hashlib.sha256() f = open(file=\"test.txt\",mode=\"rb\") while 1: temp = f.read(1024) # ❶ m.update(temp) # ❷ if not len(temp): f.close() hash_res = m.hexdigest() # ❸ break print(hash_res) # 48dd13d8629b4a15f791dec773cab271895187a11683a3d19d4877a8c256cb70 ❶：更新hash值 ❷：由于打开文件的模式是rb，故temp本身就是bytes类型，所以不用encode() ❸：当所有内容读取完毕后，生成文件的校验hash值 其次是方式2，文件指定指针点来更新hash值，安全系数小幅度降低，但速度大幅度提升。 迅雷等下载软件均采用此种方式，前提是要让用户知道我们seek()的文件指针点在哪里: m = hashlib.sha256() f = open(file=\"1.txt\",mode=\"rb\") # ❶ f.seek(20,0) temp = f.read(10) m.update(temp) # ❷ f.seek(20,1) temp = f.read(10) m.update(temp) # ❸ f.seek(-20,2) temp = f.read(10) m.update(temp) # ❹ hash_res = m.hexdigest() print(hash_res) # daffa21b2be95802d2beeb1f66ce5feb61195e31074120a605421563f775e360 ❶：在文件的开始位置，读取10个bytes，用作生成hash值的源内容部分 ❷：在文件的中间位置，读取10个bytes，用作生成hash值的源内容部分 ❸：在文件的末尾位置，读取10个bytes，用作生成hash值的源内容部分 ❹：生成文件校验的hash值，该hash值共由30个bytes组成，分别来自文件的开始、中间、末尾位置。Ps：指针点越多，安全性越高，但是速度越慢 hmac模块 hmac模块的使用与hashlib大同小异。但是在某些方面会比hashlib更优秀： 它也是一个内置模块，以下是简单的使用： >>> import hmac >>> hmacObject = hmac.new(\"hello world\".encode(\"u8\"), digestmod=\"md5\") >>> hmacObject.update(\"salt\".encode(\"u8\")) >>> hashValue = hmacObject.digest() >>> hashValue b'\\xf3Q\\xff\\xb2V{\\x88\\xfe\\x0e\\x9aX\\x19\\xbf\\x12\\xf3>> 另外，还有一个compare_digest()方法，放入2个bytes类型，用于判断他们的值是否一致。 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-28 21:51:24 "},"Python/Python模块与包/configparser.html":{"url":"Python/Python模块与包/configparser.html","title":"内置模块：configparser","keywords":"","body":"configparser简介 configparser模块是Python的内置模块，提供了配置文件创建、解析、修改等功能。 官方文档 值得注意的是，在Python2中，它的命名是驼峰式的，为ConfigParser。 认识配置文件 配置文件常以.ini或者.cfg作为后缀，注释方式有2种。 #注释与;注释，一个配置项是以键值对方式进行存储，通过:或者=分割。 [regulator] user_name : Yunya age = 21 sex = male is_admin = true salary = 20 [path] RUN_LOG_FILE = log/run.log $true ERROR_LOG_FILE = log/error.log $true 如果某一个配置项后面加上了$true，则$true在解析的时候将被替换为BASE_DIR，也就说该$true会被替换为完整的路径。 我个人喜欢将一个配置文件分成3部分，尽管下面的叫法并不是非常的正确： 配置项分类（classify）：以[]包裹的数据项，或者称为block 配置项的键（key）：:或者=左边的数据项 配置项的值（value）：:或者=右边的数据项 字典一样操作 configparser模块能够让配置文件像字典一样进行操作。 下面介绍3个该模块提供的基本方法： 方法 描述 ConfigParser() 创建文档对象 documentObject.read(filenames, encoding=None) 读取配置文件 documentObject.write(fp) 将文档对象写入磁盘 如下示例，对配置文件进行读取： import configparser # 创建文档对象，并且读取配置文件 documentObject = configparser.ConfigParser() documentObject.read(filenames=\"./config.ini\", encoding=\"u8\") # 获取所有classify classifyAllTuple = tuple(documentObject.items()) # 获取所有的key和value for classify in documentObject.values(): print(dict(classify.items())) # 获取指定classify下的指定key的value # 需要自己做类型转换 userAge = documentObject[\"regulator\"][\"age\"] print(int(userAge)) 新增一个配置文件，先创建一个空的文档对象，然后加入一些子字典，将他看做嵌套字典，最后进行写入磁盘即可： import configparser # 先创建一些classify以及kev-value配置项 defaultClassify = { \"ip\": \"0.0.0.0\", \"port\": 65535, } serverClassify = { \"ip\": \"192.168.0.120\", \"port\": 65536, } loginClassify = { \"user\": \"root\", \"password\": \"123456\", \"db\": 1, \"verify\": False, } # 创建一个空文档对象 noneDocumentObject = configparser.ConfigParser() # 为这个空文档对象，添加classify，将它看成字典操作即可 noneDocumentObject[\"DEFAULT\"] = defaultClassify noneDocumentObject[\"SERVER\"] = serverClassify noneDocumentObject[\"LOGIN\"] = loginClassify # 将文档对象写入到磁盘 with open(file=\"./newConfig.ini\", mode=\"wt\", encoding=\"utf8\") as f: noneDocumentObject.write(fp=f) 修改一个配置项，对字典中的value进行更新。最后将文档对象写入到磁盘： import configparser # 创建文档对象，并且读取配置文件 documentObject = configparser.ConfigParser() documentObject.read(filenames=\"./config.ini\", encoding=\"u8\") # 修改regulator下的age为30岁，注意这里必须为str类型 documentObject[\"regulator\"][\"age\"] = \"30\" # 写入磁盘 with open(\"./config.ini\", mode=\"wt\", encoding=\"utf8\") as f: documentObject.write(fp=f) 读取配置文件 configparser模块此外也为文档对象提供了一些专用的方法，来操作配置文件。 如下所示： 方法 描述 sections(self) 拿到所有的classify options(self, section) 指定一个classify，拿到其下所有的key items(self, section=_UNSET, raw=False, vars=None) 指定一个classify，拿到其下所有的key和value get(self, section, option) 指定classify和key，拿到具体的value，并将其转换为Python中的str类型 getint(self, section, option) 指定classify和key，拿到具体的value，并将其转换为Python中的int类型 getfloat(self, section, option) 指定classify和key，拿到具体的value，并将其转换为Python中的float类型，保留1位小数 getboolean(self, section, option) 指定classify和key，拿到具体的value，并将其转换为Python中的bool类型 示例演示： import configparser # 初始化文档对象，并且读取配置文件 documentObject = configparser.ConfigParser() documentObject.read(filenames=\"./config.ini\", encoding=\"utf8\") # 获取配置文件中所有的classify allClassify = documentObject.sections() print(allClassify) # ['regulator', 'path'] # 获取classify（regulator）下所有的key regulatorKeys = documentObject.options(section=allClassify[0]) print(regulatorKeys) # ['user_name', 'age', 'sex', 'is_admin', 'salary'] # 获取classify(regulator)下所有的键值对 regulatorItems = documentObject.items(section=allClassify[0]) print(regulatorItems) #　[('user_name', 'Yunya'), ('age', '21'), ('sex', 'male'), ('is_admin', 'true'),('salary', '20')] # 获取classify(regulator)下的key(user_name)对应的value # get()会自动将value转换为str类型 name = documentObject.get(section=allClassify[0], option=\"user_name\") print(name) # Yunya # 获取classify(regulator)下的key(age)对应的value # getint()会自动将value转换为int类型 age = documentObject.getint(section=allClassify[0], option=\"age\") print(age) # 21 # 获取classify(regulator)下的key(is_admin)对应的value # getboolean()会自动将value转换为bool类型 isAdimin = documentObject.getboolean(section=allClassify[0], option=\"is_admin\") print(isAdimin) # True # 获取classify(regulator)下的key(salary)对应的value # getfloat()会自动将value转换为float类型，并保留一位小数 salary = documentObject.getfloat(section=allClassify[0], option=\"salary\") print(salary) # 20.0 修改配置文件 configparser模块也提供了一些修改配置文件的方法。 如下表所示，但我很少会使用到，所以不再进行案例书写了： 方法 描述 add_section(self, section) 向文档对象中增加一个classify set(self, section, option, value=None) 设置或添加文档对象的键值对 remove_section(self, section) 删除文档对象中的的一个classify remove_options(self, section, option) 删除文档对象中的一组键值对 has_section(self, section) 判断文档对象中的一个classify是否存在 has_options(self, section, option) 判断文档对象中的一个key是否存在 个人更加倾向于通过字典的方式操纵文档对象。 特殊的DEFAULT 配置文件中有1个名为DEFAULT的classify，它提供了一些默认设置。 如果你的配置文件中没有显式的配置DEFAULT这个classify，则通过字典操作任然会获取到到它。但是若通过方法进行操作，该classify则不会出现。 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-13 20:41:50 "},"Python/Python模块与包/subprocess.html":{"url":"Python/Python模块与包/subprocess.html","title":"内置模块：subprocess","keywords":"","body":"subprocess简介 subprocess模块最早在Python2.4中引入，它会生成一个子进程，该子进程可以执行shell命令，并且会监听系统的标准输入管道、标准输出管道、标准错误管道，在命令执行完毕后，将结果进行返回到对应的管道中。 官方文档 如下图所示： 它的功能虽然看上去十分单一，但是应用是非常广泛的。 试想，你是一名运维人员，编写了1个脚本，每天定时定点的在100台机器上获得它们的状态信息，就可以用到该模块。 让脚本在宿主机上通过该模块执行命令，并且拿到命令的返回结果，再通过网络返回结果并对其进行分析，依此判定各个宿主机的工作状态。 简单的使用 对于简单的使用，记住这4个方法即可，如下表所示： 方法 描述 subprocess.Popen(...) 执行系统命令，并将执行结果放入对应的管道中，返回一个Popen对象 PopenObject.stdout.read() 从标准输出管道中获取执行结果 PopenObject.stderr.read() 从标准错误管道中获取执行结果 PopenObject.stdin.write() 通过标准输入管道与系统进行交互 subprocess.Popen()的可指定参数比较多，下面是它的签名： def __init__(self, args, bufsize=-1, executable=None, stdin=None, stdout=None, stderr=None, preexec_fn=None, close_fds=_PLATFORM_DEFAULT_CLOSE_FDS, shell=False, cwd=None, env=None, universal_newlines=False, startupinfo=None, creationflags=0, restore_signals=True, start_new_session=False, pass_fds=(), *, encoding=None, errors=None): 常用参数的释义如下： args：将要执行的命令，可以是str类型或者list、tuple类型 bufsize：指定缓冲大小，0是没有，1是默认 executable：要执行的替换程序 stdin/stdout/stderr：标准输入、输出、错误管道的句柄 preexec_fn：仅在Unix平台下有效。指定一个可调用对象，通常是指函数，它将在fork出的子程序运行之前调用 close_sds：在Windows平台下，如果该参数指定为True，则fork出的子程序将不会继承父程序的标准输入、输出、错误管道中传输的内容，一般设置默认即可 shell：如果为True，则通过shell执行命令 cwd：设置子进程执行时的工作目录 env：用于指定子进程的环境变量，如果为None，子进程将继承父进程的环境变了 Universal_newlines：如果为True，则不区分平台，统一将换行符定义为\\n 简单的执行命令并获取返回结果： import subprocess popenObject = subprocess.Popen( args=\"ping www.baidu.com\", shell=True, stdin=subprocess.PIPE, stderr=subprocess.PIPE, stdout=subprocess.PIPE, ) successMessage, errorMessage = popenObject.stdout.read(), popenObject.stderr.read() print(successMessage.decode(\"gbk\")) print(errorMessage.decode(\"gbk\")) popenObject.stdout.close() popenObject.stderr.close() 注意事项： 如果你的测试环境是Windows，则对执行结果的解码方式需要使用GBK，因为Windows的终端字符编码方式就是GBK。而如果是Unix平台只需要使用UTF8即可。 通过stdin与与宿主机进行交互： import subprocess # 执行的语句 stdInCommand = \"\"\"print (\\\"Hello, world\\\")\"\"\" # 通过subprocess在测试机上启动1个新的Python REPT交互式环境 popenObject = subprocess.Popen( args=\"python\", shell=True, stdin=subprocess.PIPE, stderr=subprocess.PIPE, stdout=subprocess.PIPE, ) # 写入内容，进行交互，注意每次交互完毕后都要立即关闭管道 popenObject.stdin.write(stdInCommand.encode(\"utf8\")) popenObject.stdin.close() # 获取并打印结果 successMessage, errorMessage = popenObject.stdout.read(), popenObject.stderr.read() print(successMessage.decode(\"gbk\")) print(errorMessage.decode(\"gbk\")) popenObject.stdout.close() popenObject.stderr.close() 更多的操作 以下方法了解即可，其实用的并不多： 方法 描述 subprocess.run() 执行命令，不返回结果，拥有timeout参数，可设定超时时间 subprocess.call() 执行命令，并且返回执行状态（bool类型，0成功，1失败） subprocess.check_call() 执行命令，并且返回执行结果和执行状态，如果命令执行失败则抛出异常， subprocess.getstatusoutput() 执行命令，返回1个tuple，[0]是执行状态，[1]是执行结果 subprocess.getoutput() 执行命令，返回执行结果（str类型） subprocess.check_output() 执行命令，返回执行结果（bytes类型） 这里就不再进行演示了，感兴趣的可以参见官方文档。 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-13 20:41:50 "},"Python/Python模块与包/logging.html":{"url":"Python/Python模块与包/logging.html","title":"内置模块：logging","keywords":"","body":"logging简介 Python内置模块logging提供了日志记录相关功能，是一款非常强大且常用的模块。 官方文档 它的使用如果刨根问底可能比较复杂，所以里仅介绍1种最方便的使用方式，其他的使用方式日常开发中基本不会用到，故不进行介绍。 简单了解 logging模块中规定日志拥有6个级别，每个级别都有单词、数字2种表现形式，如下表所示： level number 描述 logging.critical 50 致命错误 logging.error 40 常规错误 logging.warning 30 警告信息 logging.info 20 普通信息 logging.debug 10 调试信息 logging.NOSET 0 ... logging.NOSET一般不会进行使用，所以你也可以认为logging的日志级别只有5个。 等级越低，越能看到更多的日志信息，它会根据等级依次向上推进，如下图所示： 默认的等级是30，也就是warning级别，仅能看到critical、error、warning这个级别的日志，而info和debug则看不见。 如下所示： import logging logging.debug(\"debug\") logging.info(\"info..\") logging.warning(\"warning..\") logging.error(\"error..\") logging.critical(\"critical..\") # ❶ ❷ # WARNING:root:warning.. # ERROR:root:error.. # CRITICAL:root:critical.. ❶：root指的是记录日志的用户，默认就是root ❷：默认的日志输出位置是向屏幕，也可以将日志输出至文件 配置文件 如果想快速的使用logging模块进行日志记录。 可以使用配置文件的形式，一般来说该配置文件会存放至settings.py中： import os # 定义2种日志记录格式 # 标准的：standard_format # 简单的：simple_format standard_format = \"[%(asctime)s][%(threadName)s:%(thread)d][username:%(name)s][%(filename)s:%(lineno)d]\" \\ \"[%(levelname)s][%(message)s]\" simple_format = \"[%(levelname)s][%(asctime)s][%(filename)s:%(lineno)d]%(message)s\" # 定义日志存放路径 LOG_DIR = os.path.dirname(os.path.abspath(__file__)) if not os.path.isdir(os.path.join(LOG_DIR, \"log\")): os.mkdir(os.path.join(LOG_DIR, \"log\")) LOG_PATH = os.path.join(LOG_DIR, \"log\", \"run.log\") # LOGGING的应用配置字典，无需太大改动，开箱即用 LOGGING_SETTING = { \"version\": 1, \"disable_existing_loggers\": False, # 添加2种日志记录格式 \"formatters\": { \"standard\": { \"format\": standard_format }, \"simple\": { \"format\": simple_format }, }, # 控制流相关配置 \"handlers\": { # 输出到终端(logging.StreamHandler)，采用简单的日志记录格式 \"screen\": { \"level\": \"DEBUG\", \"class\": \"logging.StreamHandler\", \"formatter\": \"simple\" }, # 输出到文件(logging.handlers.RotatingFileHandler)，采用标准的日志记录格式 \"file\": { \"level\": \"DEBUG\", \"class\": \"logging.handlers.RotatingFileHandler\", \"formatter\": \"standard\", # 日志文件位置及名称，若不指定则默认在当前目录下 \"filename\": LOG_PATH, # 每个日志文件最大5M，当存在5个日志文件后开启日志轮转 \"maxBytes\": 1024*1024*5, \"backupCount\": 5, \"encoding\": \"utf-8\", }, }, # 定义不同用户采用的控制流 \"loggers\": { # 如果不指定用户，或指定用户未在loggers字典中，则采用该配置 \"\": { \"handlers\": [\"screen\", \"file\"], # 以控制流相关配置中过滤级别为准，这里是1次过滤，控制流中是2次过滤 \"level\": \"DEBUG\", # 关闭日志冒泡，切勿手动更改 \"propagate\": False, }, # 若指定用户为testUser，则采用该配置 \"testUser\": { \"handlers\": [\"screen\"], \"level\": \"DEBUG\", \"propagate\": False, } } } 项目应用 如何使用该配置文件？我们假设项目目录如下： Project/ |-- bin/ | |-- run.py # 启动脚本 | |-- view/ | |-- main.py # 主程序 | |-- common.py # 公用模块 |-- settings.py # logging配置文件 首先是启动脚本： # bin/run.py import os import sys sys.path.append( os.path.dirname(os.path.dirname(__file__)) ) from view.main import main if __name__ == \"__main__\": main() 其次是主程序： # view/main.py from common import logger def main(): logger.debug(\"debug\") logger.info(\"info..\") logger.warning(\"warning..\") logger.error(\"error..\") logger.critical(\"critical..\") 最后是公用模块： # common.py from logging import config from logging import getLogger from settings import LOGGING_SETTING config.dictConfig(LOGGING_SETTING) logger = getLogger(\"adminstartion\") 可以看到在公用模块中导入了配置字典，并且将它应用进了logging模块。 然后获取了一个日志对象logger，在以后使用时都使用这个logger进行日志记录即可，这里getLogger()的用户名是adminstartion，未定义在LOGGIN_SETTING的loggers中，故会采用第一个配置，也就是下面这个： \"loggers\": { # 如果不指定用户，或指定用户未在loggers字典中，则采用该配置 \"\": { \"handlers\": [\"screen\", \"file\"], \"level\": \"DEBUG\", \"propagate\": False, }, ... } Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-13 20:41:50 "},"Python/Python模块与包/re.html":{"url":"Python/Python模块与包/re.html","title":"内置模块：re","keywords":"","body":"re简介 正则表达式其本身就是一种小型的，高度专业化的编程语言。 在Python中，它被内嵌在了re模块里面，正则表达式模式被编译成一系列的字节码，然后由用C编写的匹配引擎执行。 官方文档 本文仅针对可能用到的方法进行描述，对不常用的方法等进行了筛选。 方法一览 符号大全 以下是正则表达式的符号大全： 符号 中文名称 释义 . 通配符 匹配除\\n之外的任意字符，如果想匹配\\n可更换匹配模式为re.S或re.DOTALL ^ 开始符 匹配以特定字符开始的字符串，在检测时只会检测开头第一个字符并立即返回结果 $ 结束符 匹配以特定字符结尾的字符串，在检测时只会检测结尾最后一个字符并立即返回结果 * 可有重复符 代表可以取0-∞位*号前面的字符（默认贪婪取值，可通过?取消贪婪模式） + 必有重复符 代表可以取1-∞位+号前面的字符（默认贪婪取值，可通过?取消贪婪模式） ? 单一重复符 代表可以取1-∞位?号前面的字符（默认贪婪取值，可通过?取消贪婪模式） {n,m} 范围重复符 代表可以取到n-m位{n,m}前面的字符（默认贪婪取值，可通过?取消贪婪模式） {n} 精确重复符 代表可以精确取到n位{n}前面的字符 [] 字符集 在[]中多个字符仅能匹配到1个，并且字符集中所有符号失去特殊意义，仅有- ^ \\ 这3个符号在字符集中具有特殊意义 [-] 区间符 字符集中的-号代表可以取从多少到多少区间的值，按照ASCII码排序，比如[a-z0-9A-Z]代表这1位取全部的英文字母和数字 排除符 字符集中的^号代表非的作用，比如[^0-9]代表这1位并非是数字 [\\] 转义符 转义符如果在字符集中使用，可以为特定的字符赋予特殊的意义 \\ 转义符 转义符如果在字符集外使用，可以为特定的字符赋予特殊的意义，并且还可以让特定的字符失去特殊的意义，但是如果未用r原始字符串进行正则匹配，则可能会导致令人意外的情况发生 \\d ... 匹配任何十进制数，它相当于在字符集中使用[0-9] \\D ... 匹配任何非十进制数，它相当于在字符集中使用[^0-9] \\s ... 匹配任何空白字符，它相当于在字符集中使用[\\t\\n\\r\\f\\v] \\S ... 匹配任何非空白字符，它相当于在字符集中使用[^\\t\\n\\r\\f\\v] \\w ... 匹配任何字母数字下划线字符,它相当于在字符集中使用[a-z A-Z 0-9] \\W ... 匹配任何非字母数字下划线字符,它相当于在字符集中使用[a-z A-Z 0-9] \\b ... 匹配一个特殊字符边界，比如空格,&.#等(不常用) 管道符 相当于或，注意与字符集里的区别，管道符将前后分为2段，左右看做1个整体，而字符集中的或仅仅代表从众多选项中拿出1个 () 分组符 将多个元素字符看做一个整体，也就是将它们当做一个元素字符进行匹配，若整个匹配规则中无子分组，则默认的匹配结果为一组 (?=exp) 零宽先行断言 匹配后面为exp的内容 (? 零宽后行断言 匹配前面为exp的内容 (?!exp) 零宽负向先行断言 匹配后面不能是exp的内容 (? 零宽负向后行断言 匹配前面不能是exp的内容 匹配方法 以下是re模块提供的正则匹配方法： 方法 描述 findall() 将所有的匹配结果返回至1个列表中 finditer() 将所有的匹配结果返回至1个迭代器中 search() 将首次匹配的结果返回至search对象中，可通过group()进行取值 match() 在search()基础上添加了^，使之只能在开头匹配 group() 通过该方法对search对象进行取值操作，返回一个或者多个匹配的子组 groups() 通过该方法对search对象进行取值操作，返回一个元组，包含所有匹配的子组 groupdict() 通过该方法对search对象进行取值操作，返回一个字典，包含了所有的具名子组 split() 对字符串进行分割，其算法可能导致令人意外的情况发生 sub() 对字符串进行替换，最少需要3个参数，返回一个新的字符串 subn() 对字符串进行替换，最少需要3个参数，返回一个元祖，其中包含了替换成功了几次 complie() 可以将一个标示符赋予指定的规则，达到简化重复操作的目的 匹配模式 以下是re模块提供的正则匹配模式： 模式简写 模式全写 描述 re.I re.IGNORECASE 不分大小写字母的匹配模式 re.M re.MULTILINE 视为多行的匹配模式，以\\n作为行分割符 re.S re.DOTALL 视为单行的匹配模式，即通配符可以匹配\\n re.U re.UNICODE 宽字符匹配模式，即支持匹配占4个字符的UTF-16匹配模式 创建正则 re.findall() 在测试阶段，我们大部分示例都会使用re.findall()方法进行测试。 它的函数签名如下： def findall(pattern, string, flags=0): 参数释义： pattern：匹配规则 string：被匹配字符串 flags：匹配模式 一次简单的使用，匹配以hello开头且以exp结尾的子串，采用多行匹配模式： import re string = \"hello world\\nhello regexp\\nhello python\\n\" resultList = re.findall( pattern=r\"^hello.*exp$\", string=string, flags=re.M ) print(resultList) # ['hello regexp'] 基础符号 . 通配符 .通配符会匹配除\\n之外的任意字符，如果想匹配\\n可更换匹配模式为re.S或re.DOTALL。 如下示例，匹配11个除开\\n之外的任意字符组成的子串： import re rule = \".\" * 11 string = \"hello world\\n123456abcdeABCDE\" resultList = re.findall(pattern=rule, string=string) print(resultList) # ['hello world', '123456abcde'] ^ 开始符 ^开始符会匹配以特定字符开始的字符串，在检测时只会检测开头第一个字符并立即返回结果。 如下示例，匹配以P开头且后面必须是ython加上7个除开\\n的任意字符的子串： import re rule = \"^Python.......\" string = \"Python regexp module\" resultList = re.findall(pattern=rule, string=string) print(resultList) # ['Python regexp'] $ 结束符 $结束符会匹配以特定字符结尾的字符串，在检测时只会检测结尾最后一个字符并立即返回结果。 如下所示，匹配以p结束，且前面2个字符必须是E与x的子串，区分大小写： import re rule = \"Exp$\" string = \"Python regexp regExp RegExp\" resultList = re.findall(pattern=rule, string=string) print(resultList) # ['Exp'] 重复符 * 可有重复 *代表可以取0-∞位*号前面的字符（默认贪婪取值，可通过?取消贪婪模式） 如下示例，匹配必须是以h开头，后面可以有0个也可以有多个除了\\n外的任意字符，紧接着\\n后继续匹配0个或者n个除了\\n外的任意字符，最后必须以p进行结尾的子串： import re rule = \"^h.*\\n.*p$\" string = \"hello Python\\nregexp\" resultList = re.findall(pattern=rule, string=string) print(resultList) # ['hello Python\\nregexp'] 上面这个示例，有3个条件是必须的。 h开头 中间必须有\\n p结束 所以下面这个字符串也会被匹配到： string = \"h\\np\" + 必有重复 +代表可以取1-∞位+号前面的字符（默认贪婪取值，可通过?取消贪婪模式） 如下示例，匹配必须是以h开头，后面可以有1个也可以有多个除了\\n外的任意字符，紧接着\\n后继续匹配1个或者n个除了\\n外的任意字符，最后必须以p进行结尾的子串： import re rule = \"^h.+\\n.+p$\" string = \"hello Python\\nregexp\" resultList = re.findall(pattern=rule, string=string) print(resultList) # ['hello Python\\nregexp'] 上面这个示例，有5个条件是必须的： h开头 h后面必须至少有1个任意字符 中间必须有\\n \\n后面必须至少有1个任意字符 p结束 所以下面这个字符串不会被匹配到： string = \"h\\np\" ? 单一重复 ?代表可以取1-∞位?号前面的字符（默认贪婪取值，可通过?取消贪婪模式） 如下示例，匹配可以是1开头，也可以不是1开头且后面是2345678且以9结尾的字符串： import re rule = \"^1?23456789$\" string = \"123456789\" resultList = re.findall(pattern=rule, string=string) print(resultList) # ['123456789'] 上面这个示例，有2个条件是必须的： 字符串的开头如果不是1，则必须是2 后面必须跟上345678，且以9结尾 所以下面这个字符串也会被匹配到： string = \"23456789\" {n,m} 区间重复 {n,m}代表可以取到n-m位{n,m}前面的字符，（默认贪婪取值，可通过?取消贪婪模式） 如下示例，匹配包含4个或者3个连续是1的子串： import re rule = \"1{3,4}\" string = \"1111111\" resultList = re.findall(pattern=rule, string=string) print(resultList) # ['1111', '111'] {n} 精确重复 {n}代表可以精确取到n位{n}前面的字符。 如下示例，匹配包含3个连续的1的子串： import re rule = \"1{3}\" string = \"1111111\" resultList = re.findall(pattern=rule, string=string) print(resultList) # ['111', '111'] 取消贪婪匹配 默认的*，+，?，{n,m}都是贪婪取值。 即有多个就取多个，没有多个才少取。 在它们后面加上?即可取消贪婪匹配，如下示例： import re ruleList = [ # 取0个或者多个a，取消贪婪后取0个 \"a*?\", # 取1个或者多个a，取消贪婪后取1个 \"a+?\", # 取0个或者1个a，取消贪婪后取0个 \"a??\", # 取3个或者4个a，取消贪婪后取3个 \"a{3,4}\" ] string = \"a\" * 7 for rule in ruleList: resultList = re.findall(pattern=rule, string=string) print(resultList) # ['', '', '', '', '', '', '', ''] # ['a', 'a', 'a', 'a', 'a', 'a', 'a'] # ['', '', '', '', '', '', '', ''] # ['aaaa', 'aaa'] 字符集 [] 字符集 在[]中多个字符仅能匹配到1个，并且字符集中所有符号失去特殊意义，仅有- ^ \\ 这3个符号在字符集中具有特殊意义。 如下示例，匹配包含1a或者2a或者3a的子串： import re rule = \"[123]a\" string = \"1a2a3a1b2b3b\" resultList = re.findall(pattern=rule, string=string) print(resultList) # ['1a', '2a', '3a'] [-]区间符 字符集中的-号代表可以取从多少到多少区间的值，按照ASCII码排序，比如[a-z0-9A-Z]代表这1位取全部的英文字母和数字。 如下示例，匹配所有由连续的字母或者数字组成的子串： import re rule = \"[0-9A-Za-z]+\" string = \"1b23c4d\\n2342bbc\" resultList = re.findall(pattern=rule, string=string) print(resultList) # ['1b23c4d', '2342bbc'] [^] 排除符 字符集中的^号代表非的作用，比如[^0-9]代表这1位并非是数字。 如下所示，匹配结尾不为数字的子串，匹配模式为多行匹配： import re rule = \".+[^0-9]$\" string = \"abc\\n12x\\n345\" resultList = re.findall(pattern=rule, string=string, flags=re.M) print(resultList) # ['abc', '12x'] [\\]转义符 转义符如果在字符集中使用，可以为特定的字符赋予特殊的意义。 如下所示，\\w是具有特殊意义的字符，作用是匹配字母数字下划线字符。 它可以在字符集中使用： import re rule = \"[\\w]+\" string = \"abc\\n12x\\n345\" resultList = re.findall(pattern=rule, string=string, flags=re.M) print(resultList) # ['abc', '12x', '345'] 转义字符 \\ 转义符 转义符如果在字符集外使用，可以为特定的字符赋予特殊的意义，并且还可以让特定的字符失去特殊的意义，但是如果未用r原始字符串进行正则匹配，则可能会导致令人意外的情况发生。 如，失去特殊意义： .本来是通配符，如果是\\.就是普通的.，再也没有任何意义了。 如下示例，匹配一个url： import re rule = \"w{3}\\.\\w+\\.com\" string = \"www.google.com www.biying.com\" resultList = re.findall(pattern=rule, string=string) print(resultList) # ['www.google.com', 'www.biying.com'] 以下是常用加上\\后就拥有特殊意义的字符： 符号 中文名称 释义 \\d ... 匹配任何十进制数，它相当于在字符集中使用[0-9] \\D ... 匹配任何非十进制数，它相当于在字符集中使用[^0-9] \\s ... 匹配任何空白字符，它相当于在字符集中使用[\\t\\n\\r\\f\\v] \\S ... 匹配任何非空白字符，它相当于在字符集中使用[^\\t\\n\\r\\f\\v] \\w ... 匹配任何字母数字下划线字符,它相当于在字符集中使用[a-z A-Z 0-9] \\W ... 匹配任何非字母数字下划线字符,它相当于在字符集中使用[a-z A-Z 0-9] \\b ... 匹配一个特殊字符边界，比如空格,&.#等(不常用) \\d和\\D \\d可以匹配任何十进制数，它相当于在字符集中使用[0-9]： import re rule = \"\\d+\" string = \"123 abc 1a2b3c\" resultList = re.findall(pattern=rule, string=string) print(resultList) # ['123', '1', '2', '3'] \\D可以匹配任何非十进制数，它相当于在字符集中使用[^0-9]： import re rule = \"\\D+\" string = \"123 abc 1a2b3c\" resultList = re.findall(pattern=rule, string=string) print(resultList) # [' abc ', 'a', 'b', 'c'] \\s和\\S \\s可以匹配任何空白字符，它相当于在字符集中使用[\\t\\n\\r\\f\\v]： import re rule = \"\\s\" string = \"123 abc 1a2b3c\" resultList = re.findall(pattern=rule, string=string) print(resultList) # [' ', ' '] \\S匹配任何非空白字符，它相当于在字符集中使用[^\\t\\n\\r\\f\\v]： import re rule = \"\\S\" string = \"123 abc 1a2b3c\" resultList = re.findall(pattern=rule, string=string) print(resultList) # ['1', '2', '3', 'a', 'b', 'c', '1', 'a', '2', 'b', '3', 'c'] \\w和\\W \\w可以匹配任何字母数字下划线字符,它相当于在字符集中使用[a-z A-Z 0-9]： import re rule = \"\\w+\" string = \"user_name123 \\t\\n\\f\" resultList = re.findall(pattern=rule, string=string) print(resultList) # ['user_name123'] \\W可以匹配任何非字母数字下划线字符,它相当于在字符集中使用[a-z A-Z 0-9]： import re rule = \"\\W+\" string = \"user_name123 \\t\\n\\f\" resultList = re.findall(pattern=rule, string=string) print(resultList) # [' \\t\\n\\x0c'] 原始字符串 下面这种情况，可能导致re匹配的结果和预料的结果不符。 我想匹配1个\\或者\\d： import re rule = \"[\\\\d]\" string = \"123\\\\456\\\\\" resultList = re.findall(pattern=rule, string=string) print(resultList) # ['1', '2', '3', '4', '5', '6'] 是什么原因导致了这样的情况？由于re模块建立在Python解释器之上，所以\\\\d会被分解成\\d，故会出现这样的情况。如下图所示： 如何解决这个问题呢？你可能想使用这个匹配规则： rule = \"[\\\\\\\\d]\" 但是这样的匹配结果是： ['\\\\', '\\\\'] d被当成了单独的普通匹配字符了。 其实最有效的办法是对rule采用原始字符串处理： import re rule = r\"[\\\\\\d]\" string = \"123\\\\456\\\\\" resultList = re.findall(pattern=rule, string=string) print(resultList) # ['1', '2', '3', '\\\\', '4', '5', '6', '\\\\'] 所以无论今后在什么场合下，对于rule都使用原始字符串定义就ok了。 管道 | 管道符 |管道符相当于或，注意与字符集里的区别，管道符将前后分为2段，左右看做1个整体，而字符集中的或仅仅代表从众多选项中拿出1个。 如下所示，匹配abc123或者456xyz的子串： import re rule = r\"abc123|456xyz\" string = \"abcdefgabc123xyzqud456xyz\" resultList = re.findall(pattern=rule, string=string) print(resultList) # ['abc123', '456xyz'] 分组 推荐在分组时，使用re.search()或者re.match()进行操作。 () 分组符 ()分组符将多个元素字符看做一个整体，也就是将它们当做一个元素字符进行匹配。若整个匹配规则中无子分组，则默认的匹配结果为一组： 如下，没有定义子分组，则默认的匹配结果为1组。 因此可通过group(0)方法获取整组内容： import re rule = r\".*\" string = \"hello world\" searchObject = re.search(pattern=rule, string=string) print(searchObject.group(0)) # hello world 匿名分组 匿名分组即没有名字的分组，单纯的用括号包裹即可。 如果定义了子分组，则可以通过groups()方法来查看所有的子分组。 如下所示，定义了3个匿名分组，分别是拿到标签名字，标签内容，标签结束 import re rule = r\"(.*)\" string = \"hello world\" searchObject = re.search(pattern=rule, string=string) print(searchObject.groups()) # ('div', 'hello world', 'div') 具名分组 具名分组的意思是为每一个子分组取一个别名。 语法是(?P\\regexp)，对于具名分组来说，可以使用方法groupdict()来查看分组的名字和分组匹配到的内容。 如下所示，定义了3个具名分组，分别是拿到标签名字，标签内容，标签结束： import re rule = r\"\\w+)>(?P.*)\\1)>\" string = \"hello world\" searchObject = re.search(pattern=rule, string=string) print(searchObject.groupdict()) # {'tagName': 'div', 'tagContext': 'hello world', 'tagEnd': 'div'} 分组引用 没有定义子分组时，整个匹配结果就是1个分组，编号为0. 而定义了子分组后，子分组的编号从1开始，向后排列，如下图所示： 我们可以利用这个索引编号在后面引用前面分组匹配的内容作为后面的匹配规则，语法格式如下： \\编号 示例如下所示： import re rule = r\"(.*)\" string = \"hello world\" searchObject = re.search(pattern=rule, string=string) print(searchObject.groups()) # ('div', 'hello world', 'div') 分组1匹配到什么，后面的\\1的匹配规则就是什么。 如果字符串变成了这个样子就会抛出异常，匹配不到。 因为分组1匹配到的内容是div，所以\\1也只能匹配div： string = \"hello world\" 如果前面分组是1个具名分组，后面也可以通过名字进行引用，语法格式如下： (?P=分组名) 示例如下所示： import re rule = r\"\\w+)>(?P.*)(?P=tagName))>\" string = \"hello world\" searchObject = re.search(pattern=rule, string=string) print(searchObject.groupdict()) # {'tagName': 'div', 'tagContext': 'hello world', 'tagEnd': 'div'} 取消记录 每一个子分组都具有编号，如果想取消某个子分组的编号，则可以使用(?:)来进行分组，若这样做则该子分组不可被后面引用，也不可被获取到，如下示例： import re rule = r\"(.*)\" string = \"hello world\" searchObject = re.search(pattern=rule, string=string) print(searchObject.groups()) # ('hello world',) 可以看见，只有1个子分组。 断言匹配 断言匹配虽然都有1个括号，但它们并不是子分组。 故括号中的内容也不会当做结果进行保持，可以将它们理解为匹配时的条件。 (?=exp) 零宽先行断言匹配后面为exp的内容。 如下示例，匹配后面是world的内容： import re rule = r\".+(?=world)\" string = \"hello world\" searchObject = re.search(pattern=rule, string=string) print(searchObject.group(0)) # hello (? 零宽后行断言，匹配前面为exp的内容。 如下示例，匹配前面是hello的内容： import re rule = r\"(?(?!exp) 零宽负向先行断言，匹配后面不能是exp的内容。 如下示例，匹配hello后面不能是Java的内容： import re rule = r\"hello (?!Java).*\" string = \"hello Java hello Golang hello Python\" searchObject = re.search(pattern=rule, string=string) print(searchObject.group(0)) # hello Golang hello Python (? (? 如下示例，匹配hello前面不能是Golang的内容： import re rule = r\"(?re方法 findall() 将所有的匹配结果返回至1个列表中。 其实说实话这种方法在日常开发中也很少用到，由于直接返回的是1个列表，所以比较占用内存。 import re rule = r\"\\d+\" string = \"123A567\" resultList = re.findall(pattern=rule, string=string) print(resultList) # ['123', '567'] finditer() 将所有的匹配结果返回至1个迭代器中。 finditer()比findall()更节省内存，因此推荐使用。 import re rule = r\"\\d+\" string = \"123A567\" resultIter = re.finditer(pattern=rule, string=string) print(resultIter) # search() 将首次匹配的结果返回至search对象中，可通过group()进行取值。 这个方法是最常用的方法，推荐使用，但是只能返回首次的匹配结果： import re rule = r\"\\d+\" string = \"123A567\" searchObject = re.search(pattern=rule, string=string) print(searchObject) # match() 在search()基础上添加了^，使之只能在开头匹配。 这个方法用到的场景也不多吧，简单介绍一下： import re rule = r\"\\d+\" string = \"123A567\" searchObject = re.match(pattern=rule, string=string) print(searchObject) # group() 通过该方法对search对象进行取值操作，返回一个或者多个匹配的子组。 可以取值的情况： 当没有分组时默认取大组，直接使用group()方法或指定编号0 能对匿名的子组进行取值，输入子组编号即可，子组编号从1开始 能对具名的子组进行取值，输入子组别名即可 我们上面介绍过，默认最大的组就是所有匹配结果，编号为0. 子组编号从1开始向后排列，通过该方法可以取出任意一个分组。 如，没有子组，可以使用group(0)或者直接使用group()取出最大的默认组： import re rule = r\".+\" string = \"123A567\" searchObject = re.search(pattern=rule, string=string) print(searchObject.group()) # 123A567 如果有多分组，则可以指定1个或者多个子组的编号，将它们取出来： import re rule = r\"(\\d+)([A-Z])(\\d+)\" string = \"123A567\" searchObject = re.search(pattern=rule, string=string) print(searchObject.group(0, 1, 2, 3)) # ('123A567', '123', 'A', '567') 如果有具名分组，则可以指定分组名将它们取出来： import re rule = r\"(?P\\d+)(?P[A-Z])(?P\\d+)\" string = \"123A567\" searchObject = re.search(pattern=rule, string=string) print(searchObject.group(0, \"first\", \"second\", \"last\")) # ('123A567', '123', 'A', '567') groups() 通过该方法对search对象进行取值操作，返回一个元组，包含所有匹配的子组。 注意事项： 它不能返回最大组，仅能以元组的方式返回所有的子组 能返回匿名子组、具名子组 示例如下，groups()不能像group()那样指定组的编号进行取值，它直接返回的就是1个元组： import re rule = r\"(?P\\d+)(?P[A-Z])(?P\\d+)\" string = \"123A567\" searchObject = re.search(pattern=rule, string=string) print(searchObject.groups()) # ('123A567', '123', 'A', '567') groupdict() 通过该方法对search对象进行取值操作，返回一个字典，包含了所有的具名子组 注意事项： 它不能返回最大组，仅能以字典的方式返回所有的具名子组 不能返回匿名子组 示例如下： import re rule = r\"(?P\\d+)(?P[A-Z])(?P\\d+)\" string = \"123A567\" searchObject = re.search(pattern=rule, string=string) print(searchObject.groupdict()) # {'first': '123', 'second': 'A', 'last': '567'} split() 对字符串进行分割，其算法可能导致令人意外的情况发生。 函数签名如下： def split(pattern, string, maxsplit=0, flags=0): 参数释义： pattern：匹配规则 string：被切分的字符串 maxsplit：最大切分的次数 flags：匹配模式 普通的3个小示例： import re # 按空格切分 print(re.split(r\" \", \"hello abc def\")) # ['hello', 'abc', 'def'] # 按空格或 | 分 print(re.split(r\" |\\|\",\"hello abc|def\")) # ['hello', 'abc', 'def'] # 按空格或 | 分 print(re.split(r\"[ |]\",\"hello abc|def\")) # ['hello', 'abc', 'def'] 意外的情况示例： import re # 先按照a切分，后按照b切分 print(re.split(r\"[ab]\",\"asdabcd\")) # 第一次按a来分：['', 'sd', 'bcd'] # 第二次按b来分: ['', 'sd', '', 'cd'] # 按b的分法由于是空。故前进一位 # 结果 # ['', 'sd', '', 'cd'] sub() 对字符串进行替换，最少需要3个参数，返回一个新的字符串。 函数签名如下： def sub(pattern, repl, string, count=0, flags=0): 参数释义： pattern：匹配规则 repl：新的字符 string：被替换的字符串 count：替换次数 flags：匹配模式 示例如下： import re print(re.sub(r\"a|b\", \"N\", \"123a456b\")) # 123N456N subn() 对字符串进行替换，最少需要3个参数，返回一个元祖，其中包含了替换成功了几次。 函数签名如下： def subn(pattern, repl, string, count=0, flags=0): 参数释义： pattern：匹配规则 repl：新的字符 string：被替换的字符串 count：替换次数 flags：匹配模式 示例如下： import re print(re.subn(r\"a|b\", \"N\", \"123a456b\")) # ('123N456N', 2) complie() complie()可以将一个标示符赋予指定的规则，达到简化重复操作的目的。 函数签名如下： def compile(pattern, flags=0): 参数释义： pattern：匹配规则 flags：匹配模式 示例演示，我有一个HTML文档。现在，我要匹配每个a标签的链接、a标签的内容： import re #　step01：指定匹配规则 rule = re.compile(r\"(.*)\", flags=re.I) # step02: 书写HTML文档 htmlDocument = \"\"\" 百度搜索 谷歌搜索 必应搜索 \"\"\" # step03:开始匹配 resultList = rule.findall(htmlDocument) print(resultList) # [('www.baidu.com', '百度搜索'), ('www.google.com', '谷歌搜索'), ('www.biying.com', '必应搜索')] re模式 re.I I模式下不区分大小写，此模式下[a-z]等同于[a-zA-Z]： import re rule = \"[a-z]+\" string = \"ABC1abc\" resultList = re.findall(pattern=rule, string=string, flags=re.I) print(resultList) # ['ABC', 'abc'] re.M M模式下会将每一行单独匹配，主要是对^和$的修饰。 如下示例，匹配必须以j开头且为p结尾的子串： import re rule = \"^J.+t$\" string = \"Python\\nJavaScript\\nGolang\" resultList = re.findall(pattern=rule, string=string, flags=re.M) print(resultList) # ['JavaScript'] re.S S模式下会将多行视为单行，这意味着.通配符可以匹配\\n了。 import re rule = \".+\" string = \"\\n\\n\\n\\n\\n\" resultList = re.findall(pattern=rule, string=string, flags=re.S) print(resultList) # ['\\n\\n\\n\\n\\n'] re.U U模式使用的不多，主要针对占4个Bytes的字符进行匹配支持，尽在Python2中适用，因为Python3里的字符都是Unicode字符了。 import re rule = \"𝒳𝒴\" string = \"𝒳𝒴𝒳𝒴𝒳𝒴\" resultList = re.findall(pattern=rule, string=string, flags=re.U) print(resultList) # ['𝒳𝒴', '𝒳𝒴', '𝒳𝒴'] 通用正则表达式大全 原文转载至：Java后端 原文地址：点我跳转 数字校验 数字：^[0-9]*$ n位的数字：^\\d{n}$ 至少n位的数字：^\\d{n,}$ m-n位的数字：^\\d{m,n}$ 零和非零开头的数字：^(0|[1-9][0-9]*)$ 非零开头的最多带两位小数的数字：^([1-9][0-9]*)+(.[0-9]{1,2})?$ 带1-2位小数的正数或负数：^(\\-)?\\d+(\\.\\d{1,2})?$ 正数、负数、和小数：^(\\-|\\+)?\\d+(\\.\\d+)?$ 有两位小数的正实数：^[0-9]+(.[0-9]{2})?$ 有1~3位小数的正实数：^[0-9]+(.[0-9]{1,3})?$ 非零的正整数：^[1-9]\\d*$ 或 ^([1-9][0-9]*){1,3}$ 或 ^\\+?[1-9][0-9]*$ 非零的负整数：^\\-[1-9][]0-9\"*$ 或 ^-[1-9]\\d*$ 非负整数：^\\d+$ 或 ^[1-9]\\d*|0$ 非正整数：^-[1-9]\\d*|0$ 或 ^((-\\d+)|(0+))$ 非负浮点数：^\\d+(\\.\\d+)?$ 或 ^[1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*|0?\\.0+|0$ 非正浮点数：^((-\\d+(\\.\\d+)?)|(0+(\\.0+)?))$ 或 ^(-([1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*))|0?\\.0+|0$ 正浮点数：^[1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*$ 或 ^(([0-9]+\\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\\.[0-9]+)|([0-9]*[1-9][0-9]*))$ 负浮点数：^-([1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*)$ 或 ^(-(([0-9]+\\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\\.[0-9]+)|([0-9]*[1-9][0-9]*)))$ 浮点数：^(-?\\d+)(\\.\\d+)?$ 或 ^-?([1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*|0?\\.0+|0)$ 字符校验 汉字：^[\\u4e00-\\u9fa5]{0,}$ 英文和数字：^[A-Za-z0-9]+$ 或 ^[A-Za-z0-9]{4,40}$ 长度为3-20的所有字符：^.{3,20}$ 由26个英文字母组成的字符串：^[A-Za-z]+$ 由26个大写英文字母组成的字符串：^[A-Z]+$ 由26个小写英文字母组成的字符串：^[a-z]+$ 由数字和26个英文字母组成的字符串：^[A-Za-z0-9]+$ 由数字、26个英文字母或者下划线组成的字符串：^\\w+$ 或 ^\\w{3,20} 中文、英文、数字包括下划线：^[\\u4E00-\\u9FA5A-Za-z0-9_]+$ 中文、英文、数字但不包括下划线等符号：^[\\u4E00-\\u9FA5A-Za-z0-9]+$ 或 ^[\\u4E00-\\u9FA5A-Za-z0-9]{2,20}$ 可以输入含有^%&',;=?$\\\"等字符：[^%&',;=?$\\x22]+ 禁止输入含有~的字符[^~\\x22]+ 其他校验 .*匹配除 \\n 以外的任何字符。 /[\\u4E00-\\u9FA5]/ 汉字 /[\\uFF00-\\uFFFF]/ 全角符号 /[\\u0000-\\u00FF]/ 半角符号 钱币校验 1.有四种钱的表示形式我们可以接受:\"10000.00\" 和 \"10,000.00\", 和没有 \"分\" 的 \"10000\" 和 \"10,000\"：^[1-9][0-9]*$ 2.这表示任意一个不以0开头的数字,但是,这也意味着一个字符\"0\"不通过,所以我们采用下面的形式：^(0|[1-9][0-9]*)$ 3.一个0或者一个不以0开头的数字.我们还可以允许开头有一个负号：^(0|-?[1-9][0-9]*)$ 4.这表示一个0或者一个可能为负的开头不为0的数字.让用户以0开头好了.把负号的也去掉,因为钱总不能是负的吧.下面我们要加的是说明可能的小数部分：^[0-9]+(.[0-9]+)?$ 5.必须说明的是,小数点后面至少应该有1位数,所以\"10.\"是不通过的,但是 \"10\" 和 \"10.2\" 是通过的：^[0-9]+(.[0-9]{2})?$ 6.这样我们规定小数点后面必须有两位,如果你认为太苛刻了,可以这样：^[0-9]+(.[0-9]{1,2})?$ 7.这样就允许用户只写一位小数.下面我们该考虑数字中的逗号了,我们可以这样：^[0-9]{1,3}(,[0-9]{3})*(.[0-9]{1,2})?$ 8.1到3个数字,后面跟着任意个 逗号+3个数字,逗号成为可选,而不是必须：^([0-9]+|[0-9]{1,3}(,[0-9]{3})*)(.[0-9]{1,2})?$ 生活需求 Email地址：^\\w+([-+.]\\w+)*@\\w+([-.]\\w+)*\\.\\w+([-.]\\w+)*$ 域名：[a-zA-Z0-9][-a-zA-Z0-9]{0,62}(/.[a-zA-Z0-9][-a-zA-Z0-9]{0,62})+/.? InternetURL：[a-zA-z]+://[^\\s]* 或 ^http://([\\w-]+\\.)+[\\w-]+(/[\\w-./?%&=]*)?$ 手机号码：^(13[0-9]|14[5|7]|15[0|1|2|3|5|6|7|8|9]|18[0|1|2|3|5|6|7|8|9])\\d{8}$ 电话号码(\"XXX-XXXXXXX\"、\"XXXX-XXXXXXXX\"、\"XXX-XXXXXXX\"、\"XXX-XXXXXXXX\"、\"XXXXXXX\"和\"XXXXXXXX)：^(\\(\\d{3,4}-)|\\d{3.4}-)?\\d{7,8}$ 国内电话号码(0511-4405222、021-87888822)：\\d{3}-\\d{8}|\\d{4}-\\d{7} 身份证号(15位、18位数字)：^\\d{15}|\\d{18}$ 短身份证号码(数字、字母x结尾)：^([0-9]){7,18}(x|X)?$ 或 ^\\d{8,18}|[0-9x]{8,18}|[0-9X]{8,18}?$ 帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：^[a-zA-Z][a-zA-Z0-9_]{4,15}$ 密码(以字母开头，长度在6~18之间，只能包含字母、数字和下划线)：^[a-zA-Z]\\w{5,17}$ 强密码(必须包含大小写字母和数字的组合，不能使用特殊字符，长度在8-10之间)：^(?=.*\\d)(?=.*[a-z])(?=.*[A-Z]).{8,10}$ 日期格式：^\\d{4}-\\d{1,2}-\\d{1,2} 一年的12个月(01～09和1～12)：^(0?[1-9]|1[0-2])$ 一个月的31天(01～09和1～31)：^((0?[1-9])|((1|2)[0-9])|30|31)$ xml文件：^([a-zA-Z]+-?)+[a-zA-Z0-9]+\\\\.[x|X][m|M][l|L]$ 中文字符的正则表达式：[\\u4e00-\\u9fa5] 双字节字符：[^\\x00-\\xff] (包括汉字在内，可以用来计算字符串的长度(一个双字节字符长度计2，ASCII字符计1)) 空白行的正则表达式：\\n\\s*\\r (可以用来删除空白行) HTML标记的正则表达式：]*>.*?| (网上流传的版本太糟糕，上面这个也仅仅能部分，对于复杂的嵌套标记依旧无能为力) 首尾空白字符的正则表达式：^\\s*|\\s*$或(^\\s*)|(\\s*$) (可以用来删除行首行尾的空白字符(包括空格、制表符、换页符等等)，非常有用的表达式) 腾讯QQ号：[1-9][0-9]{4,} (腾讯QQ号从10000开始) 中国邮政编码：[1-9]\\d{5}(?!\\d) (中国邮政编码为6位数字) IP地址：\\d+\\.\\d+\\.\\d+\\.\\d+ (提取IP地址时有用) IP地址：((?:(?:25[0-5]|2[0-4]\\\\d|[01]?\\\\d?\\\\d)\\\\.){3}(?:25[0-5]|2[0-4]\\\\d|[01]?\\\\d?\\\\d)) IP-v4地址：\\\\b(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\\\b (提取IP地址时有用) 校验IP-v6地址:(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])) 子网掩码：((?:(?:25[0-5]|2[0-4]\\\\d|[01]?\\\\d?\\\\d)\\\\.){3}(?:25[0-5]|2[0-4]\\\\d|[01]?\\\\d?\\\\d)) 校验日期:^(?:(?!0000)[0-9]{4}-(?:(?:0[1-9]|1[0-2])-(?:0[1-9]|1[0-9]|2[0-8])|(?:0[13-9]|1[0-2])-(?:29|30)|(?:0[13578]|1[02])-31)|(?:[0-9]{2}(?:0[48]|[2468][048]|[13579][26])|(?:0[48]|[2468][048]|[13579][26])00)-02-29)$(“yyyy-mm-dd“ 格式的日期校验，已考虑平闰年。) 抽取注释： 查找CSS属性:^\\\\s*[a-zA-Z\\\\-]+\\\\s*[:]{1}\\\\s[a-zA-Z0-9\\\\s.#]+[;]{1} 提取页面超链接:(]*)(href=\"https?:\\\\/\\\\/)((?!(?:(?:www\\\\.)?'.implode('|(?:www\\\\.)?', $follow_list).'))[^\" rel=\"external nofollow\" ]+)\"((?!.*\\\\brel=)[^>]*)(?:[^>]*)> 提取网页图片:\\\\]*[src] *= *[\\\\\"\\\\']{0,1}([^\\\\\"\\\\'\\\\ >]*) 提取网页颜色代码:^#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$ 文件扩展名效验:^([a-zA-Z]\\\\:|\\\\\\\\)\\\\\\\\([^\\\\\\\\]+\\\\\\\\)*[^\\\\/:*?\"<>|]+\\\\.txt(l)?$ 判断IE版本：^.*MSIE [5-8](?:\\\\.[0-9]+)?(?!.*Trident\\\\/[5-9]\\\\.0).*$ Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-07-31 13:48:14 "},"Python/Python模块与包/importlib.html":{"url":"Python/Python模块与包/importlib.html","title":"内置模块：importlib","keywords":"","body":"importlib简介 importlib模块作为Python内置模块，提供了更多导入模块的方式。 官方文档 常用方法： importlib.import_module(str)：根据字符串导入1个模块，该字符串以.为路径分割，如\"package.module\" 项目示例 假设我的项目之中包含了多个中间件，并且这些中间件会在项目正式启动之前先行启动。 我该如何集中式的管理这些中间件，让它们在需要的时候能够快速加上，不需要的时候能够快速去除呢？ 使用importlib模块是最明智的选择，整个项目目录如下： PYTHONPROJECT │ ├─bin │ | run.py │ ├─middleware │ │ first_middle.py │ │ init.py │ │ second_middle.py │ │ __init__.py │ ├─view │ │ main.py │ │ settings.py 首先先查看一下run.py，它主要处理项目模块路径、中间件初始化以及主程序的运行： #　run.py import os import sys BASE_DIR = os.path.dirname(os.path.dirname(__file__)) sys.path.append(BASE_DIR) from middleware.init import init from view.main import main if __name__ == \"__main__\": # init middleware init() # run main main() 再来看一下中间件的启动，它会从配置文件中拿到被集中化管理的需要启动的中间件，然后利用importlib模块对其进行导入后执行其下的某一个方法： # middleware/init.py import importlib import settings def init(): for stringPath in settings.LOAD_MIDDLEWARE: modulePath, funcName = stringPath.rsplit(\".\", maxsplit=1) # 利用importlib模块根据字符串路径导入模块 module = importlib.import_module(modulePath) # 模块也是对象，所以利用反射拿到函数对象并执行 funcObject = getattr(module, funcName) funcObject() 被集中管理的需要加载的中间件被定义在了settings.py的1个列表中。 其中每条数据项代表1个需要被加载的中间件，以BASE_DIR为准，用.进行分割，确定了中间件的导入路径与运行函数： # settings.py LOAD_MIDDLEWARE = [ \"middleware.first_middle.m1\", \"middleware.second_middle.m2\" ] 当后续需要新增中间件，只需要在middleware包中添加好.py文件并且在settings.py中按照格式把路径和运行函数填入即可。 如果要取消某个中间件的加载，直接在列表中对它进行注释即可。 总结2点： 如何规定模块导入的格式，参见LOAD_MIDDLEWARE列表 如何使用importlib快速导入模块且执行模块下的某一个函数，参见init.py文件 把其他代码也补上吧，中间件的启动函数： # middleware/first_middle.py def m1(): print(\"middleware 1 run..\") # middleware/second_middle.py def m2(): print(\"middleware 2 run..\") 主程序函数： # view/main.py def main(): print(\"view main run...\") 运行结果： middleware 1 run.. middleware 2 run.. view main run... Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-13 20:41:50 "},"Python/Python模块与包/collections.html":{"url":"Python/Python模块与包/collections.html","title":"内置模块：collections","keywords":"","body":"collections简介 collections模块提供了许多容器的数据类型，是Python内置数据类型的一种升级。 官方文档 collections模块所提供的内置容器或者基类如下所示： 容器/基类 描述 namedtuple() 创建命名元组子类的工厂函数 deque 类似列表(list)的容器，实现了在两端快速添加(append)和弹出(pop) ChainMap 类似字典(dict)的容器类，将多个映射集合到一个视图里面 Counter 字典的子类，提供了可哈希对象的计数功能 OrderedDict 字典的子类，保存了他们被添加的顺序 defaultdict 字典的子类，提供了一个工厂函数，为字典查询提供一个默认值 UserDict 封装了字典对象，简化了字典子类化 UserList 封装了列表对象，简化了列表子类化 UserString 封装了列表对象，简化了字符串子类化 ChainMap ChainMap能够让多个字典链接起来，返回类似于字典视图的功能，可以直接将多个互相分离的字典当做1个大的整体字典来用，ChainMap支持所有字典方法，如get()，pop()等。 可能有的朋友会想，那为什么不新创建1个字典然后update()旧的字典呢？ 这是因为ChainMap和字典视图很相似，所以oldDict的数据如果发生更新，则ChainMap也会同步进行更新。 但使用dict.update()创建的newDict就没有这种特性了，它不会随着oldDict的数据改变而发生改变。 如下图所示： 快速使用 如下示例，将链接2个字典，组成英文字母大小写对照ASCII码表： from collections import ChainMap uppercaseAlphabet = {chr(i): i for i in range(65, 91)} lowercaseAlphabet = {chr(i): i for i in range(97, 123)} letterTable = ChainMap(uppercaseAlphabet, lowercaseAlphabet) print(letterTable) 生成的对象如下所示： ChainMap({'A': 65, 'B': 66, 'C': 67, 'D': 68, 'E': 69, 'F': 70, 'G': 71, 'H': 72, 'I': 73, 'J': 74, 'K': 75, 'L': 76, 'M': 77, 'N': 78, 'O': 79, 'P': 80, 'Q': 81, 'R': 82, 'S': 83, 'T': 84, 'U': 85, 'V': 86, 'W': 87, 'X': 88, 'Y': 89, 'Z': 90}, {'a': 97, 'b': 98, 'c': 99, 'd': 100, 'e': 101, 'f': 102, 'g': 103, 'h': 104, 'i': 105, 'j': 106, 'k': 107, 'l': 108, 'm': 109, 'n': 110, 'o': 111, 'p': 112, 'q': 113, 'r': 114, 's': 115, 't': 116, 'u': 117, 'v': 118, 'w': 119, 'x': 120, 'y': 121, 'z': 122}) maps ChainMap的底层其实是用了1个列表，来存放了oldDict的引用。 格式如下： [ {oldDict1..}, {oldDict2..}, ... ] 在查询时，如果oldDict1和oldDict2具有重复的key，则会查出oldDict1，因为它是挨个字典的向后进行查找，其他的操作也是同理： 如下示例，oldDict1和oldDict2都有为a的key，那么操纵ChainMap的a时必定先拿到oldDict1的a： from collections import ChainMap oldDict1 = {\"a\": 1, \"b\": 2, \"c\": 3} oldDict2 = {\"a\": 10, \"b\": 20, \"c\": 30} newMap = ChainMap(oldDict1, oldDict2) print(newMap.get(\"a\")) # 1 如果直接想操作oldDict2的a，则可以通过ChainMap.maps拿到存储字典映射的列表，指定索引值来操作第2个字典也就是oldDict2，示例如下： from collections import ChainMap oldDict1 = {\"a\": 1, \"b\": 2, \"c\": 3} oldDict2 = {\"a\": 10, \"b\": 20, \"c\": 30} newMap = ChainMap(oldDict1, oldDict2) print(newMap.maps[1].get(\"a\")) # 10 new_child(m=None) 该方法会在旧的ChainMap上生成1个新的ChainMap，并且新增1个空字典在最前面。 如下图所示： 代码示例： from collections import ChainMap oldDict1 = {\"a\": 1, \"b\": 2, \"c\": 3} oldDict2 = {\"a\": 10, \"b\": 20, \"c\": 30} oldMap = ChainMap(oldDict1, oldDict2) newMap = oldMap.new_child() print(newMap) # ChainMap({}, {'a': 1, 'b': 2, 'c': 3}, {'a': 10, 'b': 20, 'c': 30}) 你也可以选择，在使用该方法的时候传入1个新的字典，让它填补第1个位置： ... newMap = oldMap.new_child({\"new\": None}) print(newMap) # ChainMap({'new': None}, {'a': 1, 'b': 2, 'c': 3}, {'a': 10, 'b': 20, 'c': 30}) parents 返回ChainMap的父ChainMap，相较于子ChainMap来说，父ChainMap永远没有子ChainMap的第1个oldDict。 如下图所示： 示例如下： from collections import ChainMap oldDict1 = {\"a\": 1, \"b\": 2, \"c\": 3} oldDict2 = {\"a\": 10, \"b\": 20, \"c\": 30} oldMap = ChainMap(oldDict1, oldDict2) print(oldMap.parents) # ChainMap({'a': 10, 'b': 20, 'c': 30}) 使用场景 在官方文档中举例了一个非常好的使用场景。 有1个简单的脚本，它拥有一些默认的参数变量。 当启动该脚本时，会有以下3种情况发生： 如果在命令行启动脚本时，指定了参数，则使用命令行指定的参数 如果没有在命令行启动脚本时指定参数，则会查找os的环境变量试图获取该参数 如果os的环境变量中也没有该参数，则使用默认的参数 这里它就是用了ChainMap来实现的，具体代码如下，避免了大量的if和else，非常方便： import os import argparse from collections import ChainMap defaults = {'color': 'red', 'user': 'guest'} parser = argparse.ArgumentParser() parser.add_argument('-u', '--user') parser.add_argument('-c', '--color') namespace = parser.parse_args() command_line_args = {k: v for k, v in vars(namespace).items() if v} combined = ChainMap(command_line_args, os.environ, defaults) print(combined['color']) print(combined['user']) 测试1，命令行传入了参数： python3 demo.py -c Black -u Yunya Black Yunya 测试2，命令行和os的环境变量中都没有参数，则用默认的参数： python3 demo.py red guest Counter Counter能够快速的获取一个可迭代对象中每一个数据项所出现的次数。 因此可以用来做词频统计，排行榜等一类的工具。 Counter是Dict的派生类，故支持大部分的字典方法，如get()，pop()等。 序列记数 直接为Counter()传入1个可迭代对象，返回一个dict，包含数据项和出现次数，按照降序排列，如下所示： from collections import Counter seq = [\"A\", \"A\", \"B\", \"C\", \"C\", \"D\"] c = Counter(seq) print(c) # Counter({'A': 2, 'C': 2, 'B': 1, 'D': 1}) 计数获取 如果你想获取1个数据项的出现次数，可通过[]的操作或者get()方法来完成，像操纵字典一样操纵Counter即可。 值得一提的是，当Counter通过[item]来获取数据项出现次数的话，如果这个数据项不存在则会返回0，而不是抛出KeyError。 from collections import Counter seq = [\"A\", \"A\", \"B\", \"C\", \"C\", \"D\"] c = Counter(seq) print(c.get(\"A\")) print(c.get(\"Z\")) print(c[\"Z\"]) # 2 # None # 0 排行获取 Counter.most_common()会返回1一个列表，按照Counter的排列顺序从大到小进行返回，如下所示，返回出现次数最多的3个数据项： from collections import Counter seq = [\"A\", \"A\", \"B\", \"C\", \"C\", \"D\"] c = Counter(seq) print(sorted(c.most_common(3))) # [('A', 2), ('C', 2), ('B', 1)] 如果想返回出现次数最少的3个数据项该怎么办呢？ 如下所示： from collections import Counter seq = [\"A\", \"A\", \"B\", \"C\", \"C\", \"D\"] c = Counter(seq) print(sorted(c.items(), key=lambda li:li[1])[:3]) # [('B', 1), ('D', 1), ('A', 2)] 词频统计 打开一个文件，做词频统计： from collections import Counter result = Counter() with open(\"./data/input.txt\",\"r\") as f: while True: lines = f.read(1024).splitlines() if lines==[]: break lines = [lines[i].split(\" \") for i in range(len(lines))] words = [] for line in lines: words.extend(line) tmp = Counter(words) result+=tmp print (result.most_common(10)) deque deque是collections模块提供的一大杀器，名为双端队列。 虽然普通的list也能够在队列2端进行数据项操作，但诸如insert(0, item)， pop(0)等方法都会引起数据项在内存中的挪动，从而使这2个方法的时间复杂度降低到O(n)。 而deque针对insert(0, item)和pop(0)做出了优化，让它们的时间复杂度都降到了O(1)。 如果仅在队首、队尾做操作，那么使用双端队列是最合适的。 如果要在队列中部做操作，还是推荐使用list。 方法一览 下面是deque所提供的方法和属性： 方法/属性 描述 deque(iterable, maxlen) 返回新的双端队列，可指定该队列的最大容量，如果不指定最大容量，则内部会根据数据项个数进行自动扩容 append(item) 添加数据项至队尾 appendleft(item) 添加数据项至队首 clear() 清空队列中的数据项 copy() 创建一份浅拷贝 count(item) 返回item在队列中出现的次数 extend(iterable) 通过附加来自可迭代对象的数据项来扩展队列，数据项添加至队尾 extendleft(iterable) 通过附加来自可迭代对象的数据项来扩展队列，数据项添加至队首 index(item, start, stop) 返回第一个数据项在队列中出现位置的索引，若值不存在，则抛出ValueError，可指定start和stop的索引区间 insert(index, item) 在索引之前插入数据项 pop() 删除并弹出队尾的数据项，若队列为空则抛出IndexError popleft() 删除并弹出队首的数据项，若队列为空则抛出IndexError remove(item) 删除队列中第一次出现的数据项。如果不存在该数据项，则引发ValueError reverse() 翻转整个队列，返回None，即原地翻转 rotate(n=1) 如果为正数，将队尾n个数据项移动至队首，如果是负数，将队首n个数据项移至队尾 maxlen 返回队列的最大容量 除了以上方法和属性之外，deque还支持迭代，枚举，len(d), reversed(d), copy.copy(d), copy.deepcopy(d), 成员测试 in 操作符，和下标引用 d[-1]，但是不支持切片[::] 。 注意！len()和maxlen是不同的： len()取的是队列中以有多少个数据项 maxlen取的是队列中最多可容纳多少数据项 如下所示： from collections import deque q = deque(range(3), maxlen=10) print(q.maxlen) print(len(q)) # 10 # 3 此外，rotate()方法可以在队列中进行数据项的位置迁移，如下所示。 n为正数，将队尾n个数据项移动至队首： from collections import deque q = deque(range(5), maxlen=10) print(q) q.rotate(2) print(q) # deque([0, 1, 2, 3, 4], maxlen=10) # deque([3, 4, 0, 1, 2], maxlen=10) n为负数，将队首n个数据项移至队尾： from collections import deque q = deque(range(5), maxlen=10) print(q) q.rotate(-2) print(q) # deque([0, 1, 2, 3, 4], maxlen=10) # deque([2, 3, 4, 0, 1], maxlen=10) defaultdict defaultdict本身是一个字典，继承了dict类并覆写了__missing__()方法。 在实例化defaultdict对象时我们可以为字典设置1个默认值，当使用[key]获取value时，若[key]不存在将会返回默认值而不是直接抛出keyError。 快速使用 如下所示，在使用了defaultdict后，用[key]操作获取value时若key不存在则会返回设定的默认值： from collections import defaultdict dic = defaultdict(lambda : None) #　❶ dic[\"k1\"] = \"v1\" print(dic[\"k1\"]) print(dic[\"k2\"]) # v1 # None ❶：设定默认值，必须是1个可调用对象，将其返回值作为defaultdict的默认值 计数统计 统计数据项在列表中出现的次数，如果是普通的dict你可能需要这么做： li1 = [\"A\", \"A\", \"B\", \"C\", \"C\", \"D\"] dic = {} for item in li1: dic.setdefault(item, 0) dic[item] += 1 print(dic) # {'A': 2, 'B': 1, 'C': 2, 'D': 1} 如果是defaultdict，则可以让代码更精简一点： from collections import defaultdict li1 = [\"A\", \"A\", \"B\", \"C\", \"C\", \"D\"] dic = defaultdict(lambda: 0) for item in li1: dic[item] += 1 print(dic) # defaultdict( at 0x0127B6A8>, {'A': 2, 'B': 1, 'C': 2, 'D': 1}) namedtuple namedtuple翻译过来就是具名元组，因为元组的主要功能是数据的展示，如果能够将1个元组中每个数据项的意思也表达出来就更好了。 如下所示，一个普通的元组： (\"Jack\", 18, \"male\", \"123456\") 乍一看前3个你可能都能看懂是什么意思，那么最后1个呢？是不是一脸懵逼？ 而通过具名元组，你就能知道最后1个的意思了，如下所示： (name='Jack', age=18, gender='male', password='123456') 可能这里有的同学会说，那我为什么不用dict？而偏要这么麻烦的用collections中的namedtuple？ 别搞忘了，dict是可变类型，namedtuple则是继承了tuple的特性，是不可变的，数据仅作展示时使用具名元组是最好的选择。 此外，具名元组是元组的子类，所以可以使用所有元组的方法，除此之外它还新增了一些方法和属性。 对象创建 使用namedtuple()方法来初始化一个类。 函数签名如下： def namedtuple(typename, field_names, *, verbose=False, rename=False, module=None): pass 参数释义： typename：将要实例化出的类的名称 field_names：具名元组中每个字段的名称 ... 示例演示： from collections import namedtuple UserMessage = namedtuple(\"userMessage\", [\"name\", \"age\" ,\"gender\", \"password\"]) u = UserMessage(\"Jack\", 18, \"male\", \"123456\") print(u) # userMessage(name='Jack', age=18, gender='male', password='123456') _make() 若1个序列的数据项个数与具名元组类的字段个数相同，通过该方法可直接将这个序列传入并生成新的具名元组对象。 如下所示，u的数据项个数与具名元组类的字段个数相同，直接根据u创建1个具名元组对象： from collections import namedtuple UserMessage = namedtuple(\"userMessage\", [\"name\", \"age\" ,\"gender\", \"password\"]) u = (\"Jack\", 18, \"male\", \"123456\") print(UserMessage._make(u)) # userMessage(name='Jack', age=18, gender='male', password='123456') _asdict() 将具名元组对象转换为有序字典（注：不是dict，而是Orderdict）： from collections import namedtuple UserMessage = namedtuple(\"userMessage\", [\"name\", \"age\" ,\"gender\", \"password\"]) u = UserMessage(\"Jack\", 18, \"male\", \"123456\") print(u._asdict()) # OrderedDict([('name', 'Jack'), ('age', 18), ('gender', 'male'), ('password', '123456')]) _replace() 由于具名元组不可改变，所以通过该方法会生成1个新的具名元组，用于替换旧的具名元组中的某一个数据项值： from collections import namedtuple UserMessage = namedtuple(\"userMessage\", [\"name\", \"age\" ,\"gender\", \"password\"]) oldUser = UserMessage(\"Jack\", 18, \"male\", \"123456\") newUser = oldUser._replace(name=\"Tom\", password=\"abcdef\") print(newUser) # userMessage(name='Tom', age=18, gender='male', password='abcdef') _fields 返回具名元组的字段列表： from collections import namedtuple UserMessage = namedtuple(\"userMessage\", [\"name\", \"age\" ,\"gender\", \"password\"]) u = UserMessage(\"Jack\", 18, \"male\", \"123456\") print(u._fields) # ('name', 'age', 'gender', 'password') 字典转换 若想将具名元组转换为普通字典，可通过如下方法： from collections import namedtuple UserMessage = namedtuple(\"userMessage\", [\"name\", \"age\" ,\"gender\", \"password\"]) u = UserMessage(\"Jack\", 18, \"male\", \"123456\") print( dict(zip(u._fields, u[:])) ) # {'name': 'Jack', 'age': 18, 'gender': 'male', 'password': '123456'} 若想将普通字典转换为具名元组，可通过如下方法： from collections import namedtuple userDict = {'name': 'Jack', 'age': 18, 'gender': 'male', 'password': '123456'} UserMessage = namedtuple(\"userMessage\", [\"name\", \"age\" ,\"gender\", \"password\"]) print(UserMessage(**userDict)) # userMessage(name='Jack', age=18, gender='male', password='123456') OrderDict OrderDict见字生意，即有序字典。 但是Python3.6之后字典已经变的有序了，所以这里不再举例它的用法。 感兴趣可以参照collections的官方文档进行查阅。 继承基类 collections中提供了3个基类，分别是UserList，UserDict，UserString。 它们并没有什么实质性的功能，只是针对list、dict、string的C语言实现用Python重写了一遍。 如果你对这些数据类型的实现比较感兴趣，可翻阅一下它们的源码。 此外，如果在自定义序列时，也建议继承这3个类，而不是继承内置的3个类。 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-13 20:41:50 "},"Python/Python模块与包/itertools.html":{"url":"Python/Python模块与包/itertools.html","title":"内置模块：itertools","keywords":"","body":"itertools简介 itertools是Python内置模块，提供了大量为高效循环而创建的迭代器函数，当你有以下一些特殊需求时就可以使用它们，而不必再自己动手造轮子。 官方文档 由于提供的迭代器众多，故不可能每个都记得，这里放上摘自官网的迭代器一览表。 首先是无穷迭代器如下表所示，即能够无限被迭代的迭代器： 迭代器 实参 结果 示例 count() start, [step] start, start+step, start+2*step, … count(10) --> 10 11 12 13 14 ... cycle() p p0, p1, … plast, p0, p1, … cycle('ABCD') --> A B C D A B C D ... repeat() elem [,n] elem, elem, elem, … 重复无限次或n次 repeat(10, 3) --> 10 10 10 其次是可停止的迭代器： 迭代器 实参 结果 示例 accumulate() p [,func] p0, p0+p1, p0+p1+p2, … accumulate([1,2,3,4,5]) --> 1 3 6 10 15 chain() p, q, … p0, p1, … plast, q0, q1, … chain('ABC', 'DEF') --> A B C D E F chain.from_iterable() iterable – 可迭代对象 p0, p1, … plast, q0, q1, … chain.from_iterable(['ABC', 'DEF']) --> A B C D E F compress() data, selectors (d[0] if s[0]), (d[1] if s[1]), … compress('ABCDEF', [1,0,1,0,1,1]) --> A C E F dropwhile() pred, seq seq[n], seq[n+1], … 从pred首次真值测试失败开始 dropwhile(lambda x: x 6 4 1 filterfalse() pred, seq seq中pred(x)为假值的元素，x是seq中的元素。 filterfalse(lambda x: x%2, range(10)) --> 0 2 4 6 8 groupby() iterable[, key] 根据key(v)值分组的迭代器 islice() seq, [start,] stop [, step] seq[start:stop:step]中的元素 islice('ABCDEFG', 2, None) --> C D E F G starmap() func, seq func(seq[0]), func(seq[1]), … starmap(pow, [(2,5), (3,2), (10,3)]) --> 32 9 1000 takewhile() pred, seq seq[0], seq[1], …, 直到pred真值测试失败 takewhile(lambda x: x 1 4 tee() it, n it1, it2, … itn 将一个迭代器拆分为n个迭代器 zip_longest() p, q, … (p[0], q[0]), (p[1], q[1]), … zip_longest('ABCD', 'xy', fillvalue='-') --> Ax By C- D- 然后是排列组合迭代器： 迭代器 实参 结果 product() p, q, … [repeat=1] 笛卡尔积，相当于嵌套的for循环 permutations() p[, r] 长度r元组，所有可能的排列，无重复元素 combinations() p, r 长度r元组，有序，无重复元素 combinations_with_replacement() p, r 长度r元组，有序，元素可重复 product('ABCD', repeat=2) AA AB AC AD BA BB BC BD CA CB CC CD DA DB DC DD permutations('ABCD', 2) AB AC AD BA BC BD CA CB CD DA DB DC combinations('ABCD', 2) AB AC AD BC BD CD combinations_with_replacement('ABCD', 2) AA AB AC AD BB BC BD CC CD DD 自认为比较重要的方法有：chain()，zip_longset()，permutations()。 除此之外的方法局限性太强，不适合所有场景。 无穷迭代器 count() 创建1个迭代器，初始值是start，步长是step，结束是无限。 函数签名如下： itertools.count(start=0, step=1) 官方文档的实现： def count(start=0, step=1): # count(10) --> 10 11 12 13 14 ... # count(2.5, 0.5) -> 2.5 3.0 3.5 ... n = start while True: yield n n += step 注意，可以生成浮点数，这是range所不支持的。 cycle() 创建1个迭代器，对传入的可迭代对象元素进行无限复制。 函数签名如下： itertools.cycle(iterable) 官方文档的实现： def cycle(iterable): # cycle('ABCD') --> A B C D A B C D A B C D ... saved = [] for element in iterable: yield element saved.append(element) while saved: for element in saved: yield element repeat() 创建1个迭代器，对传入的可迭代对象进行无限复制，或通过times参数指定复制的次数： 函数签名如下： itertools.repeat(object[, times]) 官方文档的实现： def repeat(object, times=None): # repeat(10, 3) --> 10 10 10 if times is None: while True: yield object else: for i in range(times): yield object 可停止的迭代器 accumulate() 该函数可接收2个参数，1个可迭代对象和1个具有2参数的可调用对象，返回1个迭代器。 该迭代器的值生成基于可调用对象对传入数据项的处理。 函数签名如下： itertools.accumulate(iterable[, func]) 官方文档实现： def accumulate(iterable, func=operator.add): 'Return running totals' # accumulate([1,2,3,4,5]) --> 1 3 6 10 15 # accumulate([1,2,3,4,5], operator.mul) --> 1 2 6 24 120 it = iter(iterable) try: total = next(it) except StopIteration: return yield total for element in it: total = func(total, element) yield total 示例演示： import itertools print(list(itertools.accumulate(range(5), lambda x,y:x+y))) # [0, 1, 3, 6, 10] 过程解析： # range(5) lambda x,y : x+y # [0, 1, 2, 3, 4] # 第一次：返回0 -> [0] # 第二次：0 + 1 = 1 -> [0, 1] # 第三次：1 + 2 = 3 -> [0, 1, 3] # 第四次：3 + 3 = 6 -> [0, 1, 3, 6] # 第五次：4 + 6 = 10 -> [0, 1, 3, 6, 10] # 结果： # [0, 1, 3, 6, 10] chain() 该函数可接收无限多的可迭代对象，并将它们进行合并成1个迭代器进行返回。 函数签名如下： itertools.chain(*iterables) 官方文档实现： def chain(*iterables): # chain('ABC', 'DEF') --> A B C D E F for it in iterables: for element in it: yield element from_iterable() 该函数可接收一个多维度的可迭代对象，并将多维展开合并成1个平面迭代器进行返回。 函数签名如下： itertools.chain.from_iterable(iterable) 官方文档实现： def from_iterable(iterables): # chain.from_iterable(['ABC', 'DEF']) --> A B C D E F for it in iterables: for element in it: yield element compress 创建一个迭代器，它返回data中经selectors真值测试为True的元素。迭代器在两者较短的长度处停止。 函数签名如下： itertools.compress(data, selectors) 官方文档实现： def compress(data, selectors): # compress('ABCDEF', [1,0,1,0,1,1]) --> A C E F return (d for d, s in zip(data, selectors) if s) dropwhile() 创建一个迭代器，如果predicate为true，迭代器丢弃这些元素，然后返回其他元素。 注意，迭代器在predicate首次为false之前不会产生任何输出，所以可能需要一定长度的启动时间。 函数签名如下： itertools.dropwhile(predicate, iterable) 官方文档实现： def dropwhile(predicate, iterable): # dropwhile(lambda x: x 6 4 1 iterable = iter(iterable) for x in iterable: if not predicate(x): yield x break for x in iterable: yield x filterfalse() 创建一个迭代器，只返回iterable中predicate为False 的元素。如果predicate是None，返回真值测试为false的元素。 其实说白了就相当于filter()的反函数。 函数签名如下： itertools.filterfalse(predicate, iterable) 官方文档实现： def filterfalse(predicate, iterable): # filterfalse(lambda x: x%2, range(10)) --> 0 2 4 6 8 if predicate is None: predicate = bool for x in iterable: if not predicate(x): yield x islice() 创建一个迭代器，该函数接收3个参数，总体效果和切片取子序列类似，能指定开始位置、结束位置、步长等。 函数签名如下： itertools.islice(iterable, start, stop[, step] 官方文档实现： def islice(iterable, *args): # islice('ABCDEFG', 2) --> A B # islice('ABCDEFG', 2, 4) --> C D # islice('ABCDEFG', 2, None) --> C D E F G # islice('ABCDEFG', 0, None, 2) --> A C E G s = slice(*args) start, stop, step = s.start or 0, s.stop or sys.maxsize, s.step or 1 it = iter(range(start, stop, step)) try: nexti = next(it) except StopIteration: # Consume *iterable* up to the *start* position. for i, element in zip(range(start), iterable): pass return try: for i, element in enumerate(iterable): if i == nexti: yield element nexti = next(it) except StopIteration: # Consume to *stop*. for i, element in zip(range(i + 1, stop), iterable): pass starmap() 创建一个迭代器，使用从可迭代对象中获取的参数来计算该函数。当参数对应的形参已从一个单独可迭代对象组合为元组时（数据已被“预组对”）可用此函数代替 map()。map()与starmap()之间的区别可以类比 function(a,b)与function(*c)的区别。 函数签名如下： itertools.starmap(function, iterable) 官方文档实现： def starmap(function, iterable): # starmap(pow, [(2,5), (3,2), (10,3)]) --> 32 9 1000 for args in iterable: yield function(*args) 注意，function必须接收2个参数，而传入的Iterable也必须符合上述格式。 takewhile() 相当于filter()，创建一个迭代器，只要predicate为真就从可迭代对象中返回元素。 函数签名如下： itertools.takewhile(predicate, iterable) 官方文档实现： def takewhile(predicate, iterable): # takewhile(lambda x: x 1 4 for x in iterable: if predicate(x): yield x else: break zip_longset() 创建一个迭代器，从每个可迭代对象中收集元素。如果可迭代对象的长度未对齐，将根据fillvalue填充缺失值。迭代持续到耗光最长的可迭代对象。 函数签名如下： itertools.zip_longest(*iterables, fillvalue=None) 官方文档实现： class ZipExhausted(Exception): pass def zip_longest(*args, **kwds): # zip_longest('ABCD', 'xy', fillvalue='-') --> Ax By C- D- fillvalue = kwds.get('fillvalue') counter = len(args) - 1 def sentinel(): nonlocal counter if not counter: raise ZipExhausted counter -= 1 yield fillvalue fillers = repeat(fillvalue) iterators = [chain(it, sentinel(), fillers) for it in args] try: while iterators: yield tuple(map(next, iterators)) except ZipExhausted: pass 其他的迭代器 这里省略了2个迭代器，tee()和groupby()，因为我实在想不通在怎样的场景下会去使用它们.. 排序组合迭代器 product() 返回可迭代对象输入的笛卡儿积，存在重复元素。 函数签名如下： itertools.product(*iterables, repeat=1) 官方文档实现： def product(*args, repeat=1): # product('ABCD', 'xy') --> Ax Ay Bx By Cx Cy Dx Dy # product(range(2), repeat=3) --> 000 001 010 011 100 101 110 111 pools = [tuple(pool) for pool in args] * repeat result = [[]] for pool in pools: result = [x+[y] for x in result for y in pool] for prod in result: yield tuple(prod) permutations() 连续返回由iterable元素生成长度为r的排列。 如果r未指定或为None ，r默认设置为iterable的长度，这种情况下，生成所有全长排列。 排列依字典序发出。因此，如果iterable是已排序的，排列元组将有序地产出。 即使元素的值相同，不同位置的元素也被认为是不同的。如果元素值都不同，每个排列中的元素值不会重复。 函数签名如下： itertools.permutations(iterable, r=None 官方文档实现： def permutations(iterable, r=None): # permutations('ABCD', 2) --> AB AC AD BA BC BD CA CB CD DA DB DC # permutations(range(3)) --> 012 021 102 120 201 210 pool = tuple(iterable) n = len(pool) r = n if r is None else r if r > n: return indices = list(range(n)) cycles = list(range(n, n-r, -1)) yield tuple(pool[i] for i in indices[:r]) while n: for i in reversed(range(r)): cycles[i] -= 1 if cycles[i] == 0: indices[i:] = indices[i+1:] + indices[i:i+1] cycles[i] = n - i else: j = cycles[i] indices[i], indices[-j] = indices[-j], indices[i] yield tuple(pool[i] for i in indices[:r]) break else: return combinations() 返回由输入iterable中元素组成长度为 r 的子序列。 组合按照字典序返回。所以如果输入iterable是有序的，生成的组合元组也是有序的。 即使元素的值相同，不同位置的元素也被认为是不同的。如果元素各自不同，那么每个组合中没有重复元素。 函数签名如下： itertools.combinations(iterable, r) 官方文档实现： def combinations(iterable, r): # combinations('ABCD', 2) --> AB AC AD BC BD CD # combinations(range(4), 3) --> 012 013 023 123 pool = tuple(iterable) n = len(pool) if r > n: return indices = list(range(r)) yield tuple(pool[i] for i in indices) while True: for i in reversed(range(r)): if indices[i] != i + n - r: break else: return indices[i] += 1 for j in range(i+1, r): indices[j] = indices[j-1] + 1 yield tuple(pool[i] for i in indices) combinations_with_replacement() 返回由输入iterable中元素组成的长度为r的子序列，允许每个元素可重复出现。 组合按照字典序返回。所以如果输入iterable是有序的，生成的组合元组也是有序的。 不同位置的元素是不同的，即使它们的值相同。因此如果输入中的元素都是不同的话，返回的组合中元素也都会不同。 函数签名如下： itertools.combinations_with_replacement(iterable, r) 官方文档实现： def combinations_with_replacement(iterable, r): # combinations_with_replacement('ABC', 2) --> AA AB AC BB BC CC pool = tuple(iterable) n = len(pool) if not n and r: return indices = [0] * r yield tuple(pool[i] for i in indices) while True: for i in reversed(range(r)): if indices[i] != n - 1: break else: return indices[i:] = [indices[i] + 1] * (r - i) yield tuple(pool[i] for i in indices) Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-13 20:41:50 "},"Python/Python模块与包/functools.html":{"url":"Python/Python模块与包/functools.html","title":"内置模块：functools","keywords":"","body":"functools简介 functools是非常强大的内置模块，它提供了许多装饰器与函数，适用于对所有可调用对象的应用。 官方文档 这里主要着重介绍2种常用的函数与装饰器，它们适用于绝大部分的场景。 函数/装饰器 描述 partial() 冻结可调用对象的某些参数，因此该函数也被称为偏函数 @lru_cache 为函数提供缓存功能，当某一函数的两次调用参数均一致，则直接返回前一次调用的结果 在该模块中，我们之前也已经接触过它所提供的redue()与@warps装饰器，所以这里不再进行举例。 partial() 传入1个可调用对象和它的某一个或多个调用参数，返回1个新的可调用对象，并且该对象中的某些参数是被固定的。 函数签名如下： functools.partial(func, *args, **keywords) 官方文档实现： def partial(func, *args, **keywords): def newfunc(*fargs, **fkeywords): newkeywords = keywords.copy() newkeywords.update(fkeywords) return func(*args, *fargs, **newkeywords) newfunc.func = func newfunc.args = args newfunc.keywords = keywords return newfunc 示例演示： import functools def add(x, y): return x + y # newFunc = add(1, 2) newFunc = functools.partial(add, 1, 2) print(newFunc()) # 3 再来一个2进制转10进制的函数： import functools binToDecimal = functools.partial(int, base=2) print(binToDecimal(\"110\")) # 6 @lru_cache 一个为函数提供缓存功能的装饰器，缓存maxsize组传入参数，在下次以相同参数调用时直接返回上一次的结果。用以节约高开销或I/O函数的调用时间。 由于使用了字典存储缓存，所以被装饰的函数固定参数和关键字参数必须是可哈希的。 函数签名如下： @functools.lru_cache(maxsize=128, typed=False) 参数释义： 如果maxsize设置为None，LRU功能将被禁用且缓存数量无上限。maxsize设置为2的幂时可获得最佳性能。 如果typed设置为true，不同类型的函数参数将被分别缓存。例如，f(3)和f(3.0)将被视为不同而分别缓存。 一个简单的例子： 第一次运行函数，传入参数1和2，计算结果为3，缓存这2个参数和结果 第二次运行函数，传入参数1和2，查询缓存，缓存有就直接获得结果，根本不运行函数，所以没有看到print()的打印效果 第三次运行函数，传入参数1.0和2，查询缓存，由于typed为True，故严格区分浮点型和整形，再次运行函数，结果计算为3.0 如下示例： import functools @functools.lru_cache(maxsize=128, typed=True) def add(x, y): print(\"add run...\") return x+y print(add(1, 2)) print(add(1, 2)) print(add(1.0, 2)) # add run... # 3 # 3 # add run... # 3.0 乍一看之下好像没什么作用，不就是缓存了一下嘛，实际上，在对递归函数上加上该装饰器，性能将会得到质的提升。 如下示例了加上该装饰器函数求解上楼梯问题和不加该装饰器函数求解上楼梯问题的总计运行时间。 对35阶梯楼梯的计算，加了该装饰器的运行几乎是瞬间完成，而不加该装饰器大概需要耗费十秒左右： import functools import time @functools.lru_cache(maxsize=256, typed=False) def haveCache(n): if n == 1: return 1 if n == 2: return 2 return haveCache(n - 1) + haveCache(n - 2) def dontHaveCache(n): if n == 1: return 1 if n == 2: return 2 return dontHaveCache(n - 1) + dontHaveCache(n - 2) s = time.time() haveCache(35) print(\"HaveCache - >\", time.time() - s) s = time.time() dontHaveCache(35) print(\"dontHaveCache - >\", time.time() - s) # HaveCache - > 0.0 # dontHaveCache - > 11.06638216972351 如果最大缓存设为2，则运行时间会慢一点，但是32阶的上楼梯问题也是在短短0.2秒之内得到解决了： @functools.lru_cache(maxsize=2, typed=False) ... # HaveCache - > 0.23421168327331543 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-28 21:52:42 "},"Python/Python模块与包/模块包库框架的区别.html":{"url":"Python/Python模块与包/模块包库框架的区别.html","title":"模块包库框架的区别","keywords":"","body":"模块 Python中1个.py文件就是一个模块。 模块是指为了解决某一单独功能而专门诞生的。 如用户登录注册功能中包含验证码发送，针对这一个小功能可以单独拎出来做一个模块。 verification_code.py 包 包其实就是一个包含有__init__.py的文件夹。 一个包中可以包含另一个包，包的基础单元是由模块构成。 包将一些近似功能的模块组合到一起，如登录注册这2个大功能可以形成一个顶级包，可分为登录包、注册包、功能包3个子包： login_register/ # 顶级包：登录组成 ├── __init__.py │ ├── features # 子级包：功能类 │ └── verification_code.py # 发送验证码 │ │ ├── login # 子级包：登录类 │ ├── __init__.py │ ├── email.py # 邮箱登录 │ ├── phone.py # 手机登录 │ ├── qq.py # QQ登录 │ └── weichat.py # 微信登录 │ │ └── register # 子级包：注册类 ├── __init__.py ├── other.py # 其他注册 ├── email.py # 邮箱注册 └── phone.py # 手机注册 库 库更像是针对某个功能的解决工具包，一般来说由一个或多个包组成。 如想获取时间相关功能的操作，有内置库time进行提供。 如想获取日志相关功能的操作，有内置库logging进行提供。 再比如想获取网络功能的操作，有第三方库requests进行提供。 在Python中，很多人通常将一些内置库称为内置模块，严格意义上来说并不准确，应该叫做Python内置库更好一点。 框架 框架是一套通用的解决方案，通常由多个库组成。 使用框架能够提供一整套的服务，它将所有可能用到的资源进行了整合。 如想搭建一个网站，有Django框架可以快速完成需求。 如想进行数据分析，有Numpy框架可以助你锦上添花。 再比如想开始网络爬虫，有Scrapy框架可以让你进行花式爬取。 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-13 20:41:50 "},"Python/Python面向对象/summary.html":{"url":"Python/Python面向对象/summary.html","title":"Python面向对象","keywords":"","body":" 编程范式 类与对象 类的方法 属性代理 封装 继承 多态 抽象基类 自省反射 双下大全 描述符类 元类编程 异常处理 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-13 20:41:50 "},"Python/Python面向对象/编程范式.html":{"url":"Python/Python面向对象/编程范式.html","title":"编程范式","keywords":"","body":"编程范式 编程范式只是一种程序设计思维，本身并无优劣之分。 与任何语言都无关，不要觉得面向对象就一定比面向过程好，实际上恰恰相反。 面向过程才是所有代码在内存中最终的状态。 面向过程 面向过程（OPP）编程思想的重点是将注意力放在事物本身上，更多的是关心下一步操作该怎么做，以正在发生为目的。 将1个大的问题逐步拆解成多个小问题，一旦问题解决后代码上线将很少有改动的场景。 特性：模块化、流程化 优点：代码可读性高，并且性能高 缺点：不利于维护与扩展 著名的以面向过程思想为指导的设计产品有Linux内核，git等软件。 可以说如果一个项目是按照面向过程思维进行开发，它应该是从小的细节一步一步实现，最终变为一个整体。 面向对象 面向对象（OOP）编程思想是目前主流的编程思想，它在对业务的分析上更加侧重于应当由谁来完成这份工作，将注意力放在了人的上面，而并非事物本身。 特性：抽象、封装、继承、多态 优点：易于维护、易于扩展 缺点：继承使得代码耦合度提高，并且性能较于面向过程来说略有损失 面向对象的本质就是整合，将具有某一共同特性的不同功能整合到一起进行分类。 如果一个项目是按照面向对象思维进行开发，它应该是先构建整体大局观，然后进行细节的丰富，而细节的丰富又最终回到了面向过程的思维上，因此面向对象和面向过程是不可分离的。 面向切面 面向切面（AOP）编程思想是面向对象的一种衍生。它旨在与将主逻辑业务和副逻辑业务进行切分，让彼此之间最大限度的降低耦合度。 此外，面向切面也能够在不损失已有功能的前提下，植入一个新的功能。 如Python装饰器函数，就是面向切面编程思想的最好体现。 特性：分离，低耦合，高内聚 优点：对扩展及其友好，因为各部都是分离的所以新功能添加上不会有太多的问题产生 缺点：如果设计过于混乱，则会让代码可读性降低，如一味使用装饰器来进行缝补，还不如重构整个项目 面向接口 面向接口（PO）编程思想是近些年来逐渐火热起来的一种编程思想，它将抽象与实现互相抽离，先定义接口规范，后进行逻辑实现。 面向接口与面向对象相结合，能够让项目更加健壮，并且可读性扩展性都会得到一定程度的提升。 特性：现实与抽象分离，抽象定义规范，现实指定逻辑 优点：具有良好的扩展性，增强代码可读性，便与后期维护 缺点：大幅度增加代码量 函数式编程 函数式编程是与数学函数高度结合的编程方式，纯粹的函数式编程语言没有变量只有常量，代码重复率较低，且功能一旦完善就不会出错。 在函数中没有for循环，所有的for循环用递归实现，函数式编程的一个特点就是允许把函数本身作为参数传入另一个参数，还允许返回一个函数。 此外，Python中的lambda以及filter，map，reduce等等都是从一些函数式编程语言如haskell中提取出来的一些优秀且符合Python核心思想的好案例。 特性：无变量，无for循环 优点：代码重复率低 缺点：程序易读性差 Python特性 Python本身是一门纯粹的面向对象语言，除此之外它也支持： 面向切面：装饰器就是最好的面向切面实现 面向接口：严格意义上来说Python并未提供真正完全的面向接口语法，但仍然可以实现 函数式编程：lambda、filter、map等都是Python中拥有的函数式编程实现 一门优秀的语言总是融百家之长，Python当然也不例外。 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-13 20:41:50 "},"Python/Python面向对象/类与对象.html":{"url":"Python/Python面向对象/类与对象.html","title":"类与对象","keywords":"","body":"类和对象 类是一个抽象的概念，而对象是一个实体的存在。 对象由类创造而出，每个对象之间互相独立互不影响，一个对象只能由一个类创建，但是一个类可以创建出多个对象，而实例化就是指通过某个类创建出对象的过程。 类与对象的关系类似于模具与产品，必须先有模具，然后才能根据这个模具制作出各式各样的产品。 基础介绍 定义类 Python中定义类，使用class关键字，具体语法如下: class 类标示符(继承类): # ❶ \"\"\" 类的描述文档 # ❷ \"\"\" 标示符 = 对象 # ❸ def __init__(self): # ❹ self.标示符 = 对象 def 实例方法(self): # ❺ pass ❶：类标识符以大驼峰命名 ❷：类的描述文档，用于介绍该类的作用 ❸：类属性，用于存放所有实例对象都可能用到的变量 ❹：初始化方法，用于初始化实例对象独有属性变量 ❺：实例化方法，用于提供给实例对象调用的函数 当一个类被定义时，将会发生以下的事情： 申请内存空间，保存类体代码 将内存空间的地址绑定给类的标示符 创建类的局部命名空间（注意与函数命名空间区分，函数是加括号调用执行后才创建） 执行类体代码（注意与函数的执行时机区分，函数是加括号调用后才会执行函数体代码） 下面将定义一个人类： class Person: \"\"\" Person：人类 class attr：眼耳口鼻 每个人都具有共同特性，可定义为类属性 instance attr: 姓名性别年龄 每个人不同的特征，可定义为实例属性 instance method: 吃饭 每个人都具有共同行为，可定义为实例方法 \"\"\" eye = 2 ear = 2 mouth = 2 nose = 1 def __init__(self, name, age, gender) -> None: self.name = name self.age = age self.gender = gender def eat(self, food): return \"%s eating %s\"%(self.name, food) def getInfo(self): return \"name : %s\\nage : %s\\ngender : %s\\n\"%(self.name, self.age, self.gender) 实例化 如何通过类创建出一个具体的对象？只需要在类标示符后加上括号即可，如下所示： if __name__ == \"__main__\": jack = Person(name=\"Jack\", age=18, gender=\"male\") print(jack.eat(\"fish\")) print(jack.getInfo()) # Jack eating fish # name : Jack # age : 18 # gender : male 类实例化的过程中会做很多事情，大概可分为下面3个步骤： 调用类下的__new__()方法构建一个空的实例对象 调用类下的__init__()方法对空实例对象进行初始化 于此同时，创建实例的专属命名空间 如何验证这一过程呢？我们可通过自定义__new__()方法进行证明： class A: def __new__(cls, *args, **kwargs) -> object: print(\"Run ... new\") instanceObject = super(A, cls).__new__(cls) return instanceObject def __init__(self, attr): print(\"Run ... init\") self.instanceAttr = attr if __name__ == \"__main__\": instanceA = A(\"a\") # Run ... new # Run ... init self、__new()__、__init__() __new__()方法是类实例化过程中运行的方法，作用是构建空的实例化对象，因此该方法也被称之为构造方法。 __init__()方法也是类实例化过程中运行的方法，作用是为空的实例化对象增添实例属性，因此该方法也被称之为对象的初始化方法，注意该方法必须返回None。 self其实就是指实例化对象本身，在实例化操作开始后实例化对象会由__new__()方法经过__init__()方法进行创建并返回。 所以你会看见下面3个标示符都是指向同1个对象： class A: def __new__(cls, *args, **kwargs) -> object: print(\"Run ... new\") instanceObject = super(A, cls).__new__(cls) print(id(instanceObject)) return instanceObject def __init__(self) -> None: print(\"Run ... init\") print(id(self)) def getInstanceId(self): print(\"Run ... instance method\") print(id(self)) if __name__ == \"__main__\": print(\"instance start\") instanceA = A() print(\"instance end\") print(id(instanceA)) instanceA.getInstanceId() # instance start # Run ... new # 29435600 # Run ... init # 29435600 # instance end # 29435600 # Run ... instance method # 29435600 __dict__ 类和实例对象都有一个__dict__，它是一个字典，包含类和对象的一些特征属性。 对于类的__dict__来说，它包含类属性、类方法、实例方法等一系列东西。 而对实例的__dict__来说，它仅包含实例属性。 如下所示： class A: name = \"class\" def __init__(self) -> None: self.name = \"instance\" def instanceMethod(self): pass if __name__ == \"__main__\": instanceA = A() print(A.__dict__) print(instanceA.__dict__) 结果展示，类的__dict__，包含的东西非常多： {'__module__': '__main__', 'name': 'class', '__init__': , 'instanceMethod': , '__dict__': , '__weakref__': , '__doc__': None} 而实例对象的__dict__只包含自身的实例属性，甚至连实例方法都在类的__dict__中： {'name': 'instance'} 属性与方法 类属性 如果要在类的外部获取类属性，可通过下面两种方式： 类.属性 类.__dict__[\"属性\"] 更加推荐第一种方式，它更加的直白，让人一眼就能看到这是在获取属性，而不是操纵字典： class A: name = \"class\" def __init__(self) -> None: self.name = \"instance\" def instanceMethod(self): pass if __name__ == \"__main__\": print(A.name) print(A.__dict__[\"name\"]) print(A.__dict__.get(\"name\")) # class # class # class 其他的类属性增删改查，也都是通过这两种方式进行操作，这里不再举例。 实例属性 外部获取实例属性与类属性一样，都是通过下面2种方式： 实例.属性 实例.__dict__[\"属性\"] 如下所示： class A: name = \"class\" def __init__(self) -> None: self.name = \"instance\" def instanceMethod(self): pass if __name__ == \"__main__\": instanceA = A() print(instanceA.name) print(instanceA.__dict__[\"name\"]) print(instanceA.__dict__.get(\"name\")) # instance # instance # instance 其他的操作诸如增删改等，都比较少用到，故不再进行举例。 实例方法 实例方法其实就是函数，我们可以看一下下面这个方法： class A: name = \"class\" def __init__(self) -> None: self.name = \"instance\" def instanceMethod(self, params): print(params) 如何调用它呢？ 方式1，通过实例对象调用它，会自动的将对象本身传递给self： if __name__ == \"__main__\": instanceA = A() instanceA.instanceMethod(\"hello world\") # hello world 方式2，通过类来调用它，但是需要你手动的为self传递参数： class A: name = \"class\" def __init__(self) -> None: self.name = \"instance\" def instanceMethod(self, params): print(params) if __name__ == \"__main__\": instanceA = A() A.instanceMethod(instanceA, \"hello world\") 方式2可能比较少见，但我们之前已经用过了，比如str.format()。 def format(self, *args: object, **kwargs: object) -> str 相同的结果，不同的调用方式，如下所示，self就是字符串\"hello {}\"： classRunFormatMethod = str.format(\"hello {}\", \"world\") instanceRunFormatMethod = \"hello {}\".format(\"world\") print(classRunFormatMethod) print(instanceRunFormatMethod) # hello world # hello world 内部获取 类属性可以在实例方法中进行获取，获取方式有2种： 类.属性 self.属性 # 前提是self.__dict__中没有同名属性 推荐使用第一种，指名道姓的说我要获取类属性： class A: name = \"class\" def __init__(self) -> None: self.name = \"instance\" def instanceMethod(self): print(A.name) print(self.name) if __name__ == \"__main__\": instanceA = A() A.instanceMethod(instanceA) # class # instance 实例属性在实例方法中获取直接通过下面的方式即可： self.属性 如下所示： class A: name = \"class\" def __init__(self) -> None: self.name = \"instance\" def instanceMethod(self): print(self.name) if __name__ == \"__main__\": instanceA = A() A.instanceMethod(instanceA) # instance 实例方法中可以嵌套调用另一个方法，也可以调用外部的函数，如下所示： class A: name = \"class\" def __init__(self) -> None: self.name = \"instance\" def func1(self): print(\"func1\") self.func2() globalFunc() def func2(self): print(\"func2\") def globalFunc(): print(\"globalFunc\") if __name__ == \"__main__\": instanceA = A() instanceA.func1() # func1 # func2 # globalFunc 命名空间 类和实例的命名空间 类和实例的命名空间说白了就是__dict__字典。 一个类拥有多个实例，一个实例仅来自于一个类。 因此我们可以画出下面这幅图： 首先，类的命名空间是无法访问实例的命名空间的。 但是实例命名空间可以访问类的命名空间，类似于函数嵌套LEGB的关系。 标示符查找顺序 如果一个实例要查找某一个属性，自身存在就获取自身的，若自身不存在则取拿类的。 查看实例自身的__dict__，若没有 则查看类的__dict__，若没有 则抛出异常 我们来看一下下面这个例子： class A: name = \"ClassAttr:A\" if __name__ == \"__main__\": instanceOne = A() instanceTwo = A() instanceThree = A() print(instanceOne.name) print(instanceTwo.name) print(instanceThree.name) A.name = \"ClassAttr:B\" print(instanceOne.name) print(instanceTwo.name) print(instanceThree.name) instanceOne.name = \"InstanceAttr:a\" print(instanceOne.name) print(instanceTwo.name) print(instanceThree.name) # ClassAttr:A # ClassAttr:A # ClassAttr:A # ClassAttr:B # ClassAttr:B # ClassAttr:B # InstanceAttr:a # ClassAttr:B # ClassAttr:B 采用图解的方式来进行代码注释。 第一种情况，三个实例的__dict__中都没有name，所以会去类的__dict__中查找： 第二种情况，类__dict__中的name被修改，三个实例再次访问name，自身的__dict__没有故到类的__dict__中找，会获取到修改后的name： 第三种情况，第一个实例对象One的__dict__中具有实例属性name，故它会拿到自己的，其他2个实例对象都没有，依然会去拿类的： Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-13 20:41:50 "},"Python/Python面向对象/类的方法.html":{"url":"Python/Python面向对象/类的方法.html","title":"类的方法","keywords":"","body":"实例方法 实例方法是存储在类的__dict__字典中，实例方法都有一个固定的参数名为self，位于第一个位置。 实例方法通常会通过实例对象调用，当实例对象调用实例方法时，会自动的将自身传递给self。 如下所示： class Student: def __init__(self, name): self.name = name def show(self): return \"my name is %s\"%self.name if __name__ == \"__main__\": instanceOne = Student(\"Jack\") instanceTwo = Student(\"Tom\") print(instanceOne.show()) # self = instanceOne print(instanceTwo.show()) # self = instanceTwo # my name is Jack # my name is Tom 它的底层是怎么做的呢？ 其实还是要从属性查找顺序开始剖析，如下所示： 第一步：查找实例自身的__dict__试图获取实例方法，但实例方法都存于与类的__dict__中，故找不到 第二步：查找类的__dict__成功获取实例方法 第三步：根据类的__dict__中所定义的实例方法，自动的为self参数传递进调用者，生成一个新的方法 所以你会看见下面这样的场景，3个方法，3个存储空间： class Student: def __init__(self, name): self.name = name def show(self): return \"my name is %s\"%self.name if __name__ == \"__main__\": instanceOne = Student(\"Jack\") instanceTwo = Student(\"Tom\") print(instanceOne.show) print(instanceTwo.show) print(Student.show) # > # > # 类的方法 类方法是指头部带有@classmethod装饰器的方法，类方法都有一个固定的参数名为cls，位于第一个位置。 类方法通常由类进行调用，同时会自动的将类传递进方法cls参数中，如下所示： class Student: def __init__(self, name): self.name = name def show(self): return \"my name is %s\"%self.name @classmethod def learn(cls): print(cls.__name__) return \"students must learn\" if __name__ == \"__main__\": print(Student.learn()) # cls = Student # Student # students must learn 当然也可以通过实例对象调用类方法，cls接收的对象不是实例本身而是类，但是不建议这么做： class Student: def __init__(self, name): self.name = name def show(self): return \"my name is %s\"%self.name @classmethod def learn(cls): print(cls.__name__) return \"students must learn\" if __name__ == \"__main__\": instanceObject = Student(\"Jack\") print(instanceObject.learn()) # cls = Student # Student # students must learn 静态方法 静态方法是指头部带有@staticmethod装饰器的方法。 常作为类的工具箱出现，类和实例都可以随意的对其调用，没有自动传入的参数self或者cls，就是一个类中的普通函数： class MathTools: @staticmethod def getMax(x, y): return x if x > y else y if __name__ == \"__main__\": print(MathTools.getMax(1, 2)) instanceObject = MathTools() print(instanceObject.getMax(1, 2)) # 2 # 2 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-13 20:41:50 "},"Python/Python面向对象/属性代理.html":{"url":"Python/Python面向对象/属性代理.html","title":"属性代理","keywords":"","body":"属性代理 属性代理是指通过@property描述符装饰器来规定用户对类或者实例中某一属性的操作做出行为限制的方式。 类似于JavaScript中的代理器，Vue中的计算属性等，Python中则称之为描述符。 计算获取 　BMI指数是用来衡量一个人的体重与身高对健康影响的一个指标，计算公式为： BMI指数计算公式: BMI = 体重(kg) / (身高m**2) BMI正常值在20至25之间，超过25为超重，30以上则属肥胖 身高或体重是不断变化的，因而每次想查看BMI值都需要通过计算才能得到，但很明显BMI听起来更像是一个特征而非功能。 为此Python专门提供了一个装饰器@property，可以将类中的方法伪装成属性，对象在访问该特殊属性时会触发功能的执行，然后将返回值作为本次访问的结果，例如： class Person: def __init__(self, name, height, weight): self.name = name self.height = height self.weight = weight @property def bmi(self): v = self.weight / (self.height ** 2) if 20 25: return \"overweight\" return \"obesity\" if __name__ == \"__main__\": instanceObject = Person(\"ken\", height=1.76, weight=77) # autoRun instanceObjectMethod => bmi(self=instanceObject) print(instanceObject.bmi) #　normal 行为控制 你也可以使用其他的形式，来控制属性的删改查等行为，如下所示： class Person: def __init__(self): self.__attr = None @property def name(self): \"\"\"获取name时自动触发该方法，只有当__attr不为None才能被获取到\"\"\" if not self.__attr is None: return self.__attr else: raise AttributeError(\"name is not set\") @name.setter def name(self, params): \"\"\"设置name时自动触发该方法，只有当params为 'Jack' 时才能成功为__attr赋值\"\"\" if params != \"Jack\": raise AttributeError(\"name must setting is string 'Jack', but you set is %s\"%params) else: self.__attr = params @name.deleter def name(self): \"\"\"删除name时自动触发该方法，不允许删除name\"\"\" raise AttributeError(\"name not should delete\") if __name__ == \"__main__\": instanceObject = Person() instanceObject.name = \"Jack\" print(instanceObject.name) del instanceObject.name # Jack # AttributeError: name not should delete 行为控制 行为控制还有另外一种形式，它是固定的用法，如下所示，效果和上面一样： class Person: def __init__(self): self.__attr = None def nameGet(self): \"\"\"获取name时自动触发该方法，只有当__attr不为None才能被获取到\"\"\" if not self.__attr is None: return self.__attr else: raise AttributeError(\"name is not set\") def nameSet(self, params): \"\"\"设置name时自动触发该方法，只有当params为 'Jack' 时才能成功为__attr赋值\"\"\" if params != \"Jack\": raise AttributeError(\"name must setting is string 'Jack', but you set is %s\"%params) else: self.__attr = params def nameDelete(self): \"\"\"删除name时自动触发该方法，不允许删除name\"\"\" raise AttributeError(\"name not should delete\") name = property(fget=nameGet, fset=nameSet, fdel=nameDelete) if __name__ == \"__main__\": instanceObject = Person() instanceObject.name = \"Jack\" print(instanceObject.name) del instanceObject.name # Jack # AttributeError: name not should delete Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-13 20:41:50 "},"Python/Python面向对象/封装.html":{"url":"Python/Python面向对象/封装.html","title":"封装","keywords":"","body":"oop封装 封装是oop思想中最重要的一个，也是所有面向对象程序设计中始终绕不开的话题，说白了就是将数据和功能整合到一起。 类本身就属于封装，如定义一个类，该类中的属性以及方法只有该类或者其实例化对象才能调用，这就是类封装的体现。 除此之外，oop封装中还有2个十分重要的名词，即： 私有属性 公有属性 私有属性 类的私有属性是指在类中以_下划线开头，或者以__下划线开头命名的标示符。 它们都是指将该标示符属性隐藏，仅用于类的内部调用，不希望甚至不支持在类的外部访问这些属性。 单下封装 单下封装是指在类中以_下划线开头的标示符，它意味着使用者不应该在类的外部访问该属性，但实际上外部仍然可以访问。 如下示例，对于女孩子来说，年龄是一项比较私密的属性，因此可以使用单下命名法将该属性隐藏。 即告诉别人，我不想要你知道我的年龄，但是你要强求也是可以得到的： class Person: def __init__(self, name, age, gender) -> None: self.name = name self.gender = gender if self.gender == \"male\": self.age = age elif self.gender == \"female\": self._age = age def getInfo(self): message = \"name : %s\\ngender : %s\\n\"%(self.name, self.gender) if self.gender == \"male\": message += \"age : %d\"%self.age elif self.gender == \"female\": if 18 > self._age: # ❶ message += \"age : underage\" elif 18 ❶：对于单下命名的属性，应当在类的内部进行调用 ❷：虽然能够在外部获取到Mary的年龄，但是不建议这样使用，正确的做法应该是调用getInfo()方法获取信息 双下封装 双下封装是指在类中以__下划线开头的标示符，它意味着使用者应当禁止在类的外部访问该属性，但通过特殊的手段也是能访问到的。 如下示例，对于女孩子来说，体重是一项绝对私密的属性，因此可以使用双下命名法将该属性隐藏。 即告诉别人，你不可以通过常规手段获得我的体重： class Person: def __init__(self, name, gender, weight) -> None: self.name = name self.gender = gender if self.gender == \"male\": self.weight = weight elif self.gender == \"female\": self.__weight = weight def getInfo(self): message = \"name : %s\\ngender : %s\\n\" % (self.name, self.gender) if self.gender == \"male\": message += \"weight : %s(kg)\" % self.weight elif self.gender == \"female\": if 45 > self.__weight: # ❶ message += \"weight : thin\" elif 45 55: message += \"weight : normal\" else: message += \"weight : fat\" return message if __name__ == \"__main__\": jack = Person(name=\"Jack\", gender=\"male\", weight=60) print(jack.getInfo()) print(jack.weight) mary = Person(name=\"Mary\", gender=\"female\", weight=50) print(mary.getInfo()) print(mary.__weight) # ❷ # name : Jack # gender : male # weight : 60(kg) # 60 # name : Mary # gender : female # weight : fat # AttributeError: 'Person' object has no attribute '__weight' ❶：对于双下命名的属性，应当在类的内部进行调用 ❷：外部调用该属性直接抛出异常，找不到，所以应当使用getInfo()方法获取信息 双下重命名 其实双下封装法只是将属性重命名了，通过实例对象的__dict__可以查看到： if __name__ == \"__main__\": mary = Person(name=\"Mary\", gender=\"female\", weight=50) print(mary.__dict__) # {'name': 'Mary', 'gender': 'female', '_Person__weight': 50} 命名规则是： _类名__属性 所以，双下封装的属性其实在外部也能获取到，但是不推荐这么做，有悖于规范，如下所示： if __name__ == \"__main__\": mary = Person(name=\"Mary\", gender=\"female\", weight=50) print(mary._Person__weight) # 50 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-13 20:41:50 "},"Python/Python面向对象/继承.html":{"url":"Python/Python面向对象/继承.html","title":"继承","keywords":"","body":"oop继承 继承介绍 继承作为oop三大特性之一，可以说是最难的一章知识点，但是用的非常多。 继承是指创建类的一种方式，极大程度上规避了类与类之间代码的重复问题。 在Python中，是支持多继承的，即一个类可以继承多个类，这是其他大多数语言中所不支持的。 被继承的类可以称为父类，超类或者基类 继承的类可以称为子类或者派生类 派生类可以使用父类所有的属性及方法，但是父类是不能使用派生类的属性或方法的。 以下是语法格式： class 类标示符(父类1, 父类2): ... 举一个简单的例子，下面定义了一个狼（Wolf）类和狗（Dog）类，它们都具有相同的方法咬人（bite）、跑步（run）等，由于继承的存在故不用将该方法书写两次，直接使用狗类继承狼类即可： class Wolf: def __init__(self, name) -> None: self.name = name def bite(self, personName): return \"%s biting %s\" % (self.name, personName) def run(self): return \"%s runing...\" % self.name class Dog(Wolf): pass if __name__ == \"__main__\": wolfInstance = Wolf(\"King Kong\") print(wolfInstance.bite(\"Tom\")) print(wolfInstance.run()) print(\"=\" * 10) dogInstance = Dog(\"Small Black\") print(dogInstance.bite(\"Jack\")) print(dogInstance.run()) # King Kong biting Tom # King Kong runing... # ========== # Small Black biting Jack # Small Black runing... 方法覆写 如果派生类中拥有和父类同名的方法或者属性，则派生类或者其实例对象在查找这些属性或方法时只会拿自己的。 如下所示，在Dog类中重写了bite，让它不再咬人： class Wolf: def __init__(self, name) -> None: self.name = name def bite(self, personName): return \"%s biting %s\" % (self.name, personName) def run(self): return \"%s runing...\" % self.name class Dog(Wolf): def bite(self, personName): return \"%s not biting, %s escaped \" % (self.name, personName) if __name__ == \"__main__\": wolfInstance = Wolf(\"King Kong\") print(wolfInstance.bite(\"Tom\")) print(wolfInstance.run()) print(\"=\" * 10) dogInstance = Dog(\"Small Black\") print(dogInstance.bite(\"Jack\")) print(dogInstance.run()) # King Kong biting Tom # King Kong runing... # ========== # Small Black not biting, Jack escaped # Small Black runing... Python3 新式类 Python3中默认的所有类都继承了object类，这样的类被称为新式类： class A: # eq class A(object) pass if __name__ == \"__main__\": print(A.__bases__) # (,) 单继承 新式类单继承查找公有属性、方法时，每轮按照一条线的向上查找次序，如下图所示： 代码示例： class A: def show(self): print(\"--- A.show run ---\") self.info() def info(self): print(\"--- A.info run ---\") def __getattribute__(self, name: str): print(\"find A.%s\" % name) return super().__getattribute__(name) class B(A): def info(self): print(\"--- B.info run ---\") def __getattribute__(self, name: str): print(\"find B.%s\" % name) return super().__getattribute__(name) class C(B): def info(self): print(\"--- C.info run---\") def __getattribute__(self, name: str): print(\"find C.%s\" % name) return super().__getattribute__(name) if __name__ == \"__main__\": instanceC = C() instanceC.show() # find C.show # find B.show # find A.show # --- A.show run --- # find C.info # find B.info # find A.info # --- C.info run--- 而新式类如果是单继承查找私有属性、方法则结果又不一样，如下图所示： 代码示例： class A: def show(self): print(\"--- A.show run ---\") self.__info() def __info(self): print(\"--- A.__info run ---\") def __getattribute__(self, name: str): print(\"find A.%s\" % name) return super().__getattribute__(name) class B(A): def __info(self): print(\"--- B.__info run ---\") def __getattribute__(self, name: str): print(\"find B.%s\" % name) return super().__getattribute__(name) class C(B): def __info(self): print(\"--- C.__info run---\") def __getattribute__(self, name: str): print(\"find C.%s\" % name) return super().__getattribute__(name) if __name__ == \"__main__\": instanceC = C() instanceC.show() # find C.show # find B.show # find A.show # --- A.show run --- # find C._A__info # find B._A__info # find A._A__info # --- A.__info run --- 普通多继承 Python3中的新式类普通多继承，会按照深度优先的查找策略查找整个继承树。 深度优先：从左至右查找，每条分支查到最顶部，最后查找object类 如下图所示： 代码示例： class A: def __getattribute__(self, name: str): print(\"find A.%s\" % name) return super().__getattribute__(name) class B(A): def __getattribute__(self, name: str): print(\"find B.%s\" % name) return super().__getattribute__(name) class C(B): def show(self): print(\"--- C.show run ---\") def __getattribute__(self, name: str): print(\"find C.%s\" % name) return super().__getattribute__(name) class D: def __getattribute__(self, name: str): print(\"find D.%s\" % name) return super().__getattribute__(name) class E(D): def __getattribute__(self, name: str): print(\"find E.%s\" % name) return super().__getattribute__(name) class F: def __getattribute__(self, name: str): print(\"find F.%s\" % name) return super().__getattribute__(name) class G(C, E, F): def __getattribute__(self, name: str): print(\"find G.%s\" % name) return super().__getattribute__(name) if __name__ == \"__main__\": instanceG = G() instanceG.show() # find G.show # find C.show # find B.show # find A.show # find E.show # find D.show # find F.show # --- C.show run --- 钻石多继承 钻石多继承也被称为死亡菱形继承，继承关系如下所示： Python3中的新式类钻石多继承，会按照广度优先的查找策略查找整个继承树。 广度优先：从左至右查找，每条分支查到顶部第二个类超类，也就是不查钻石基类，如果都没有才查找钻石基类，最后查找object类 如下图所示： 代码示例： class A: def show(self): print(\"--- A.show run ---\") def __getattribute__(self, name: str): print(\"find A.%s\" % name) return super().__getattribute__(name) class B(A): def __getattribute__(self, name: str): print(\"find B.%s\" % name) return super().__getattribute__(name) class C(A): def __getattribute__(self, name: str): print(\"find C.%s\" % name) return super().__getattribute__(name) class D(A): def __getattribute__(self, name: str): print(\"find D.%s\" % name) return super().__getattribute__(name) class E(B): def __getattribute__(self, name: str): print(\"find E.%s\" % name) return super().__getattribute__(name) class F(C): def __getattribute__(self, name: str): print(\"find F.%s\" % name) return super().__getattribute__(name) class G(D): def __getattribute__(self, name: str): print(\"find G.%s\" % name) return super().__getattribute__(name) class H(E): def __getattribute__(self, name: str): print(\"find H.%s\" % name) return super().__getattribute__(name) class I(H, F, G): def __getattribute__(self, name: str): print(\"find I.%s\" % name) return super().__getattribute__(name) if __name__ == \"__main__\": instanceI = I() instanceI.show() # find I.show # find H.show # find E.show # find B.show # find F.show # find C.show # find G.show # find D.show # find A.show # --- A.show run --- Python2 经典类 Python2中如果一个类没有继承object类，这种类被称为经典类。 反之，如果继承了object类，则被称为新式类。 如下所示： # Python2中的经典类，也就是Python3中的新式类 class A: pass # Python2中的新式类 class A(object): pass 换而言之，Python2的类有新式类和经典类2种，Python3中仅有新式类，取消了经典类的设定。 不论是Python2的新式类还是Python3的新式类，它们的查找过程都是相同的，故下面只会例举经典类的查找顺序。 单继承 经典类在单继承的情况下，和新式类的查找顺序一致。 普通多继承 不管是新式类还是经典类，在普通多继承的查找下都是深度优先策略： 深度优先：从左至右查找，每条分支查到最顶部 由于不能使用__getattribute__()方法来查看整个查找过程，故这里就不再进行代码示例了。 感兴趣的朋友可以自行测试一下。 钻石多继承 钻石多继承中，经典类采用的是深度优先策略，而新式类则采用的广度优先策略。 深度优先：从左至右查找，每条分支查到最顶部，也就是说钻石基类在第一轮就会被查到 图示如下： 由于不能使用__getattribute__()方法来查看整个查找过程，故这里就不再进行代码示例了。 感兴趣的朋友可以自行测试一下。 双下属性 __class__ instanceObject.__class__属性可以查看实例对象所属的类： class A: pass if __name__ == \"__main__\": instanceObject = A() print(instanceObject.__class__) # __main__.A __base__ className.__base__属性可查看到类的父类，仅Python3有效，返回类对象： class A: pass class B(A): pass class C(B): pass if __name__ == \"__main__\": print(C.__base__) # __bases__ className.__bases__属性可查看到类的父类，仅Python3有效，返回元组，索引0处是其父类： class A: pass class B(A): pass class C(B): pass if __name__ == \"__main__\": print(C.__bases__) # (,) __mro__ 类的属性查找顺序在类定义时底层会根据C3算法生成，使用className.__mro__可调用出该查找顺序。 返回一个列表，列表中嵌套各种父类、超类，也就是说这是一个属性查找顺序列表。 注意，仅在Python3中生效。 下面是新式类普通多继承属性查找顺序，和上面测试的结果一致： class A: pass class B(A): pass class C(B): pass class D: pass class E(D): pass class F: pass class G(C, E, F): pass if __name__ == \"__main__\": print(G.__mro__) # (, , , , , , , ) 下面是新式类钻石多继承属性查找顺序，和上面测试的结果一致： class A: pass class B(A): pass class C(A): pass class D(A): pass class E(B): pass class F(C): pass class G(D): pass class H(E): pass class I(H, F, G): pass if __name__ == \"__main__\": print(I.__mro__) # (, , , , , , , , , ) 方法借用 class.attr 如果一个类和另一个类没有任何关系，但是要借用运行其下方法时，可以选择指名道姓的通过类来调用其下方法。 必须手动传入所有参数，如下所示： class A: def func(self): print(\"run A instance method\") class B: def func(self): print(\"run B instance method\") A.func(self=self) if __name__ == \"__main__\": B().func() # run B instance method # run A instance method super() 如果一个类和另一个类有继承关系，则可以通过super()方法自动向后查找其父类中需要借用的方法并执行。 它本质上会做两件事： 调用__mro__，拿到属性查找顺序列表 确定当前类在列表中的位置，并且拿到其父类，再自动使用class.attr的方式指名道姓的运行父类方法 所以，使用super()方法进行方法借用时，也需要手动传入所有参数，但是传入的参数与class.attr的方式有所不同。 具体的函数签名如下： super(__class__, ) 使用案例： class A: def func(self): print(\"run A instance method\") class B(A): def func(self): print(\"run B instance method\") super(__class__, self).func() # ❶ ❷ if __name__ == \"__main__\": B().func() # run B instance method # run A instance method ❶：传入__class__，用于确认该类在__mro__所返回的属性查找顺序列表中的位置，以便确定后面的父类查找 ❷：传入self，它将自动把self传递给A.func()的第一个参数 注意事项： Python3的super()方法中参数可以不传递，它会自动进行补充 Python2的经典类如果想使用super()方法，则必须在文件顶部添加一句代码 ： __metaclass__ = type，否则无法使用 Python2的super()方法中参数必须传递，不可进行省略 Mixins机制 Python由于支持多继承的关系，故在某些情况下可能导致代码逻辑不通顺的问题出现，如下所示： 为了能让基类的作用更加强大，符合一切交通工具的特性，你可能会在交通工具基类里面定义下面的方法： 飞行方法 抛锚方法 刹车方法 那么这个时候就已经产生了逻辑问题： 轮船不会飞，也不会刹车，但作为交通工具基类的派生类，它也能调用这些方法 汽车不会飞，也不会抛锚，但作为交通工具基类的派生类，它也能调用这些方法 飞机不会刹车，也不会抛锚，但作为交通工具基类的派生类，它也能调用这些方法 代码示例： class Transportation: def __init__(self, name) -> None: self.name = name def fly(self): \"\"\" 飞 \"\"\" print(\"%s flying\" % self.name) def brake(self): \"\"\" 刹车 \"\"\" print(\"%s braking\" % self.name) def anchor(self): \"\"\" 抛锚 \"\"\" print(\"%s anchor\" % self.name) class Aircraft(Transportation): pass class Car(Transportation): pass class Ship(Transportation): pass if __name__ == \"__main__\": aircraft = Aircraft(\"Boeing 747\") car = Car(\"BMW\") ship = Ship(\"Titanic\") # Serious Problem aircraft.brake() aircraft.anchor() car.fly() car.anchor() ship.fly() ship.brake() # Boeing 747 braking # Boeing 747 anchor # BMW flying # BMW anchor # Titanic flying # Titanic braking 如何解决这个问题呢？我们可以使用Mixins机制，将刹车、抛锚、飞行这3个不同的功能单独的封装到下面3个类中： 汽车功能类：刹车 飞机功能类：飞行 轮船功能类：抛锚 子类只需要继承交通工具基类和对应的功能类即可，如下图所示： 代码示例如下： class Transportation: def __init__(self, name) -> None: self.name = name class AircraftMixin: def fly(self): \"\"\" 飞 \"\"\" print(\"%s flying\" % self.name) class CarMixin: def brake(self): \"\"\" 刹车 \"\"\" print(\"%s braking\" % self.name) class ShipMixin: def anchor(self): \"\"\" 抛锚 \"\"\" print(\"%s anchor\" % self.name) class Aircraft(Transportation, AircraftMixin): pass class Car(Transportation, CarMixin): pass class Ship(Transportation, ShipMixin): pass if __name__ == \"__main__\": aircraft = Aircraft(\"Boeing 747\") car = Car(\"BMW\") ship = Ship(\"Titanic\") aircraft.fly() car.brake() ship.anchor() # Boeing 747 flying # BMW braking # Titanic anchor Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-13 20:41:50 "},"Python/Python面向对象/多态.html":{"url":"Python/Python面向对象/多态.html","title":"多态","keywords":"","body":"oop多态 多态更多的是指的一种思想，而非具体技术。 因为继承的存在，从而引发了多态，举个例子，所有的生物都是由一个单细胞生物不断演化而来，迄今为止它们的差异越来越大，这就是多态的体现。 多态的定义其实更准确的说法是：在不同类中实例化得到的不同对象调用一个相同方法时，它们的实现过程并不一样。 Python本身就实现了多态，其中len()方法就是最好的多态体现，2个不同类的实例化对象调用相同方法，该方法内部的处理是完全不同的： lst = [i for i in range(10)] tpl = tuple(i for i in range(10)) print(len(lst)) print(len(tpl)) # 10 # 10 多态实现 为了能够更好的理解多态，我们可以用下面这段代码来阐述。 首先，有一个犬科（Canine）的类，实现了吼叫（howl）的方法。 然后，狼（Wolf）和狗（Dog）类均继承自该类，它们都有一个吼叫的方法，但是由于狼和狗还是有很大差距的，所以该方法的内部实现过程并不一样，这就是多态的体现。 即：犬科具有吼叫方法，但同属犬科的狼和狗的吼叫是不同的。 class Canine: def howl(self): pass class Wolf(Canine): def howl(self): return \"wolf howling : ao~ ao~ ao~\" class Dog(Canine): def howl(self): return \"dog howling : wang~ wang~ wang~\" if __name__ == \"__main__\": wolfInstance = Wolf() dogInstance = Dog() print(wolfInstance.howl()) print(\"=\" * 10) print(dogInstance.howl()) # wolf howling : ao~ ao~ ao~ # ========== # dog howling : wang~ wang~ wang~ duke type 鸭子类型（duke type）是一个很有趣的词汇。 它指的是我不管你是不是鸭子，只要你具备了某些鸭子的特性，如会嘎嘎嘎，走路会摇摇晃晃等我就认为你是鸭子。 那它到底有什么好处呢？其实这样做是为了方便使用者进行方法调用。 如tuple和list，它们何其相似，如果你知道list.index()这个方法，你肯定也会尝试tuple.index()方法，结果发现居然还真的有。 鸭子类型与继承毫无关系，它强调的也是一种抽象的分类，如list和tuple同属线性结构，应该都能使用index()方法，也应当都能使用len()方法。 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-13 20:41:50 "},"Python/Python面向对象/抽象基类.html":{"url":"Python/Python面向对象/抽象基类.html","title":"抽象基类","keywords":"","body":"抽象基类 接口（interface）和抽象基类（abstract base class）是非常相似的，Python中并未提供真正意义上的接口，但是提供了抽象基类的使用。 抽象基类的作用在于： 约束子类实现，子类必须实现抽象基类中的所有抽象方法才能被实例化，否则将不可被实例化 举个例子，羊（Sheep）和狼（Wolf）都属于哺乳类（Breastfeeding），那么它们都至少具有1个方法名为哺乳（feeding），如果没有该方法，则该类不能被实例化。 其实说白了，抽象基类的作用就是规范子类实现，所以： 抽象基类仅用于被继承，不必对其进行实例化 抽象基类内部方法不必实现 而接口则是为了规范类的实现，它规定了一系列方法和属性，只有实现了这些方法和属性的类才能被算作这一个接口的实现类。 接口是针对所有类的实现的 接口规定了类的用途，举个例子，如果你这个类提供了支付方法和退款方法，那么就可以将其视为一个支付接口类，该类可用作支付功能，否则该类将不能用于支付功能 而抽象基类只是针对子类的实现的 抽象基类规定了子类的形状，你想继承我，就必须拥有我的一些特点，否则就不能算我的子类 说起来可能有点晕，抽象基类和接口并不是面向对象语言所必须的，但他们的出现却能让代码的编写变的更有逻辑。 abc Python中用abc模块定义抽象基类，只需要将抽象基类的metaclass=abc.ABCMeta即可。 除此之外，它还提供了3个装饰器： abc.abstractclassmethod：抽象类方法 abc.abstractstaticmethod：抽象静态方法 abc.abstractmethod：抽象实例方法 代码示例如下： import abc class Breastfeeding(metaclass=abc.ABCMeta): @abc.abstractmethod def feeding(self): pass class Sheep(Breastfeeding): def feeding(self): return \"sheep feeding\" class Wolf(Breastfeeding): pass if __name__ == \"__main__\": sheepInstance = Sheep() print(\"sheep class instance success!\") wolfInstance = Wolf() # sheep class instance success! # TypeError: Can't instantiate abstract class Wolf with abstract methods feeding 这个例子中，羊实现了哺乳的方法，所以实例化成功了，而狼则没有实现哺乳方法，故实例化失败了。 如果有1个狗（Dog）类继承了狼类，那么狗类能否受到抽象基类的影响呢？ 答案是不能，抽象基类只能影响其下一代继承类的实现，不能影响其孙系类。 如下所示： import abc class Breastfeeding(metaclass=abc.ABCMeta): @abc.abstractmethod def feeding(self): pass class Sheep(Breastfeeding): def feeding(self): return \"sheep feeding\" class Wolf(Breastfeeding): def feeding(self): return \"wolf fedding\" class Dog(Wolf): pass if __name__ == \"__main__\": sheepInstance = Sheep() print(\"sheep class instance success!\") wolfInstance = Wolf() print(\"wolf class instance success!\") dogInstance = Dog() print(\"dog class instance success!\") # sheep class instance success! # wolf class instance success! # dog class instance success! 继承约束 通过继承，也能进行子类的行为约束，但是常规手段不能禁止其实例化。 如下所示，狼类没有实现哺乳方法，依然实例化成功了，但是不能调用哺乳方法： class Breastfeeding: def feeding(self): raise AssertionError(\"%s must implement method feeding\" % (self.__class__.__name__)) class Sheep(Breastfeeding): def feeding(self): return \"sheep feeding\" class Wolf(Breastfeeding): pass if __name__ == \"__main__\": sheepInstance = Sheep() print(\"sheep class instance success!\") print(sheepInstance.feeding()) wolfInstance = Wolf() print(\"wolf class instance success!\") print(wolfInstance.feeding()) # sheep class instance success! # sheep feeding # wolf class instance success! # AssertionError: Wolf must implement method feeding 上面这种方式在很多框架中也被经常使用到，但如果你想实现和ABCMeta同样的效果，可以覆写基类的__new__()方法，如下所示： class Breastfeeding: def __new__(cls) -> object: for attr in Breastfeeding.__dict__: if attr.startswith(\"__\"): continue if attr not in cls.__dict__: raise TypeError(\"Can't instantiate abstract class %s with abstract methods %s\" % (cls.__name__, attr)) return super(Breastfeeding, cls).__new__(cls) def feeding(self): pass class Sheep(Breastfeeding): def feeding(self): return \"sheep feeding\" class Wolf(Breastfeeding): pass if __name__ == \"__main__\": sheepInstance = Sheep() print(\"sheep class instance success!\") print(sheepInstance.feeding()) wolfInstance = Wolf() print(\"wolf class instance success!\") print(wolfInstance.feeding()) # sheep class instance success! # sheep feeding # TypeError: Can't instantiate abstract class Wolf with abstract methods feeding Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-08-24 13:19:12 "},"Python/Python面向对象/自省反射.html":{"url":"Python/Python面向对象/自省反射.html","title":"自省反射","keywords":"","body":"自省反射 自省和反射是两个比较专业化的术语，释义如下： 自省是指获取对象的能力 反射是指操纵对象的能力 由于Python是一门强类型的动态解释型语言，所以它的自省和反射使用非常简单。 我们在某些时候并不知道对象中具有的属性与方法，尤其是接手别人的项目时这种情况更加明显。 在这种情况下，我们不能直接通过Object.__dict__来获取其对象的属性与方法（因为这样获取不到继承的属性），而应当先使用自省来获取对象信息后，再使用反射来操纵对象，故自省和反射的学习显得尤为重要。 以下举例常见自省与反射的函数： 函数 返回值 描述 help(object) None 获取对象文档帮助信息 dir(object) list 获取对象下所有能被.操纵的属性与方法 hasattr(object, str) bool 返回对象是否具有给定名称的属性或方法 getattr(object, str, default) attr 获取对象中指定的属性或方法，若该属性或方法不存在，则抛出AttributeError异常，若设置默认值，则在属性或方法不存在时返回默认值 setattr(object, str, any) None 设置对象中某一属性或方法的值 delattr(object, str) None 删除对象中某一指定属性或方法 issubclass(subClass, parentClass) bool 判定一个类是否是另一个类的子类 isinstance(instance, class) bool 判定一个对象是否是另一个类的实例 callable(object) bool 判定该对象是否可调用 示例演示 help(object)能够获取对象文档帮助信息。 返回None： >>> help(int) Help on class int in module builtins: class int(object) | int(x=0) -> integer | int(x, base=10) -> integer | | Convert a number or string to an integer, or return 0 if no arguments | are given. If x is a number, return x.__int__(). For floating point | numbers, this truncates towards zero. | | If x is not a number or if base is given, then x must be a string, | bytes, or bytearray instance representing an integer literal in the | given base. The literal can be preceded by '+' or '-' and be surrounded ... dir(object)能够获取对象下所有能被.操纵的属性与方法。 返回list： >>> dir(list) ['__add__', '__class__', '__contains__', '__delattr__', '__delitem__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__getitem__', '__gt__', '__hash__', '__iadd__', '__imul__', '__init__', '__init_subclass__', '__iter__', '__le__', '__len__', '__lt__', '__mul__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__reversed__', '__rmul__', '__setattr__', '__setitem__', '__sizeof__', '__str__', '__subclasshook__', 'append', 'clear', 'copy', 'count', 'extend', 'index', 'insert', 'pop', 'remove', 'reverse', 'sort'] hasattr(object, str)能够返回对象是否具有给定名称的属性或方法。 返回bool： >>> hasattr(list, \"index\") True >>> hasattr(list, \"items\") False getattr(object, str, default)能够获取对象中指定的属性或方法，若该属性或方法不存在，则抛出AttributeError异常，若设置默认值，则在属性或方法不存在时返回默认值： >>> method = getattr(list, \"index\") >>> method >>> method([1, 2, 3], 2) 1 setattr(object, str, any)能够设置对象中某一属性或方法的值。 返回None： >>> class A: ... pass ... >>> A.__doc__ None >>> setattr(A, \"__doc__\", \"help message\") >>> A.__doc__ help message delattr(object, str)能够删除对象中某一指定属性或方法。 返回None： >>> class A: ... classAttr = \"attr\" ... >>> A.classAttr 'attr' >>> delattr(A, \"classAttr\") >>> A.classAttr AttributeError: type object 'A' has no attribute 'classAttr' issubclass(subClass, parentClass)可以判定一个类是否是另一个类的子类。 返回bool： >>> issubclass(bool, int) True isinstance(instance, class)可以判定一个对象是否是另一个类的实例。 返回bool： >>> isinstance(1, bool) False >>> isinstance(True, bool) True 常用操作 当不确定对象中是否具有某一属性或方法时，可以使用hasattr()，getattr()以及callable()进行组合使用。 如下所示： import sys class YunPan: \"\"\" this is YunPan. You can specify start-up parameters on the command line. If the specified parameter is attribute, this property will be displayed. If the specified parameter is called, the method is performed The parameters you can specify now are: Help: Get help information The method you can specify is: Download: Test Download Features, Parameters -> Str UPLOAD: Test Upload Energy, Parameters -> Str Raises: TypeError: If there is no such method or attribute in the class, it will throw an exception. \"\"\" help = __doc__ def __init__(self) -> None: self.attrOrMethod = sys.argv[1] self.fileName = sys.argv[2] if len(sys.argv) > 2 else None self.choices() def download(self): print(\"downloading file : %s\"%self.fileName) def upload(self): print(\"uploading file : %s\"%self.fileName) def choices(self): if not hasattr(self, self.attrOrMethod): raise TypeError(\"%s not implement method or attributes:%s\"%(self.__class__.__name__, self.attrOrMethod)) attrOrMethod = getattr(self, self.attrOrMethod) if callable(attrOrMethod): return attrOrMethod() print(attrOrMethod) if __name__ == \"__main__\": YunPan() 测试结果： $ python3 .\\demo.py help this is YunPan. You can specify start-up parameters on the command line. If the specified parameter is attribute, this property will be displayed. If the specified parameter is called, the method is performed The parameters you can specify now are: Help: Get help information The method you can specify is: Download: Test Download Features, Parameters -> Str UPLOAD: Test Upload Energy, Parameters -> Str Raises: TypeError: If there is no such method or attribute in the class, it will throw an exception. $ python3 .\\demo.py download TestFile downloading file : TestFile $ python3 .\\demo.py upload TestFile uploading file : TestFile $ python3 .\\demo.py func .. TypeError: YunPan not implement method or attributes:func Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-13 20:41:50 "},"Python/Python面向对象/双下大全.html":{"url":"Python/Python面向对象/双下大全.html","title":"双下大全","keywords":"","body":"特殊的双下 在Python中有很多特殊的方法函数，如__init__()、__new__()等。 除此之外，也有很多特殊的属性变量，如__base__，__class__等。 这些属性变量或者方法函数经常被人称其为“魔法方法”，个人并不是很喜欢这种叫法。 我更喜欢称呼他们为双下方法或者双下属性，因为“魔法”一词总是带有玄幻的色彩，但在计算机领域中如果你觉得一个知识点过于玄幻，说明你并未真正的理解它。 言归正传，那么它们具体有什么作用呢？如下所示： 双下方法：在满足某一特定的条件下进行自动调用 双下属性：本身就含有一定的意义 本章节我们将先探讨双下方法，而后探讨双下属性。 双下方法 对象相关 __new__() 对象的构造方法，用于构建实例对象。 在类加括号时自动调用，创建并返回一个空的实例对象。 参数释义： cls：被实例化的类本身 args： 实例化类时传入的位置参数 kwargs： 实例化类时传入的关键字参数 返回值： object：实例化对象 应用场景： 实现单例模式，函数二次封装等 如下所示： class Category: def __new__(cls, *args, **kwargs) -> object: print(cls) print(args) print(kwargs) instanceObject = super(__class__, cls).__new__(cls) return instanceObject if __name__== \"__main__\": instance = Category(\"positionParams\", k=\"keyWordParams\") # # ('positionParams',) # {'k': 'keyWordParams'} __init__() 对象的初始化方法，用于构建实例对象，可以理解为为实例对象的__dict__填充内容。 在类加括号时自动调用，返回None： 参数释义： self：实例本身，也就是由__new__()创建出的空对象 返回值： None：该方法必须返回None 应用场景： 基本上适用于所有定义类的场景 如下所示： class Category: def __init__(self, params) -> None: self.k = params if __name__== \"__main__\": instance = Category(\"v\") print(instance.__dict__) # {'k': 'v'} __call__() 对象的调用方法，当对象后面加上括号时自动触发。 参数释义： self：实例本身，也就是由__new__()创建出的空对象 返回值： Any：任意值 应用场景： 它是内置函数callable()的判断依据，当callable(object)时，会判断object内部是否实现了该方法从而返回True或者False 如下所示，经过该方法实现，现在普通实例对象加括号会打印出其属性查找顺序： class Category: x = 1 def __call__(self): findList = list(self.__class__.__mro__) findList.insert(0, self) return tuple(findList) if __name__== \"__main__\": instance = Category() print(instance()) # (, , ) __del__() 对象的析构方法，当手动 del object 删除对象，或者在程序运行结束后自动触发。 参数释义： self：实例本身，也就是由__new__()创建出的空对象 返回值： None 应用场景： 用于关闭一些占据系统资源的操作，如文件资源，网络资源 如下所示： class Category: x = 1 def __del__(self): print(\"run ... __del__()\") if __name__== \"__main__\": instance = Category() del instance # run ... __del__() 示例，自定义文件操作类，可用于自动关闭文件： class OpenFile: def __init__(self, *args, **kwargs) -> None: self.__file = open(*args, **kwargs) def __getattr__(self, name:str): return getattr(self.__file, name) def __del__(self): print(\"auto file close\") self.__file.close() if __name__== \"__main__\": fileObject = OpenFile(file=\"./test.txt\", mode=\"rt\", encoding=\"utf8\") print(fileObject.read(32)) 属性操作 __getattribute__() 当要查找某一个属性或者方法时，都会触发该方法。 如要查找的属性或者方法存在，则返回该属性或方法。 否则抛出AttributeError的异常。 参数释义： self：实例本身，也就是 . 前面的对象 name：要查找的属性或方法 返回值： Any：要查找的方法或者属性 应用场景：自定义容器的方法查找，内置函数getattr()的底层其实就是该方法 如下所示： from typing import Any class Category: def __getattribute__(self, name: str) -> Any: print(\"run ..\") try: return super(__class__, self).__getattribute__(name) except AttributeError as e: return \"don't have attribute %s\" % name if __name__== \"__main__\": instance = Category() print(instance.x) # run .. # don't have attribute x __getattr__() 在对对象进行 . 操作试图获取对象下的某一属性或方法时而恰好该属性或方法不存在时自动触发。 若__getattribute__()与__getattr__()同时出现，则只会调用__getattribute__()。 参数释义： self：实例本身，也就是 . 前面的对象 name：要查找的属性或方法 返回值： Any：任意给定的值 应用场景：自定义类的方法借用，或者代理类 示例1，只定义了__getattr__()，它会在获取对象下的某一属性或方法不存在时触发： from typing import Any class Category: x = 1 def __getattr__(self, name: str) -> Any: print(\"run ..\") return \"%s not existing\" % name if __name__== \"__main__\": instance = Category() print(\"Find the existing properties and not call __getattr__()\") print(instance.x) print(\"Find the property that does not exist will call __getattr__()\") print(instance.y) # Find the existing properties and not call __getattr__() # 1 # Find the property that does not exist will call __getattr__() # run .. # y not existing 示例2，如果同时定义了__getattr__()和__getattribute__()则无论什么情况都不会触发__getattr__()： from typing import Any class Category: x = 1 def __getattribute__(self, name: str) -> Any: print(\"run __getattribute__()\") try: return super(Category, self).__getattribute__(name) except AttributeError as e: return \"don't have attribute %s\" % name def __getattr__(self, name: str) -> Any: print(\"run __getattr__()\") return \"%s not existing\" % name if __name__== \"__main__\": instance = Category() print(instance.x) print(instance.y) # run __getattribute__() # 1 # run __getattribute__() # don't have attribute y __setattr__() 在对对象进行 . 操作试图修改对象下的某一属性或方法时自动触发。 参数释义： self：实例本身，也就是 . 前面的对象 name：要设置的属性或方法 value：要为属性和方法设置的新值 返回值： None 应用场景：自定义代理类，内置函数setattr()的底层其实就是该方法 如下所示： from typing import Any class Category: x = 1 def __setattr__(self, name: str, value: Any) -> None: print(\"run .. __setattr__()\") self.__dict__[name] = value if __name__== \"__main__\": instance = Category() instance.y = \"newAttribute\" # run .. __setattr__() 一个容易被人忽视的地方，如果__setattr__()中设置成这样，则会引发无限递归，无数次调用自身： def __setattr__(self, name: str, value: Any) -> None: self.name = value __delattr__() 在对对象进行 . 操作试图删除对象下的某一属性或方法时自动触发。 参数释义： self：实例本身，也就是 . 前面的对象 name：要删除的属性或方法 返回值： None 应用场景：自定义不可变容器，内置函数delattr()的底层其实就是该方法 如下所示： class Category: x = 1 def __delattr__(self, name: str) -> None: print(\"run .. __delattr__()\") del self.__dict__[name] if __name__== \"__main__\": instance = Category() instance.attr = \"newAttr\" del instance.attr # run .. __delattr__() __getitem__() 在对对象进行 [] 操作试图获取对象下的某一对象属性或方法时自动触发。 除此之外，它也能代替__iter__()方法创建专属迭代器。 参数释义： self：实例本身，也就是 [] 前面的对象 name：要获取的属性或方法 返回值： None 应用场景：自定义映射容器，实现类似字典的操作 dict[k] 如下所示： from typing import Any class Category: x = 1 def __getitem__(self, name: str) -> Any: print(\"run .. __getitem__()\") return self.__dict__[name] if __name__== \"__main__\": instance = Category() instance.attr = \"newAttr\" print(instance[\"attr\"]) # run .. __getitem__() # newAttr 此外，如果类中实现了该方法，则该类的实例化对象就是可迭代对象： from typing import Any class Category: x = 1 def __getitem__(self, name: str) -> Any: print(\"run .. __getitem__()\") return self.__dict__[name] if __name__== \"__main__\": instance = Category() print(iter(instance)) # ❶ # ❶：即使该类没实现__iter__()，但是仍然可以创建专属迭代器 __setitem__() 在对对象进行 [] 操作试图修改对象下的某一对象属性或方法时自动触发。 参数释义： self：实例本身，也就是 [] 前面的对象 name：要设置的属性或方法 value：要为属性和方法设置的新值 返回值： None 应用场景：自定义映射容器，实现类似字典的操作 dict[k] = v 如下所示： from typing import Any class Category: x = 1 def __setitem__(self, name: str, value: Any) -> None: print(\"run .. __setitem__()\") self.__dict__[name] = value if __name__== \"__main__\": instance = Category() instance[\"y\"] = \"newAttr\" # run .. __setitem__() __delitem__() 在对对象进行 [] 操作试图删除对象下的某一对象属性或方法时自动触发。 参数释义： self：实例本身，也就是 [] 前面的对象 name：要删除的属性或方法 返回值： None 应用场景：自定义映射容器，实现类似字典的操作 del dict[k] 如下所示： class Category: x = 1 def __delitem__(self, name: str) -> None: print(\"run .. __delitem__()\") del self.__dict__[name] if __name__== \"__main__\": instance = Category() instance.attr = \"newAttr\" del instance[\"attr\"] # run .. __delitem__() 输出相关 __str__() print(object)时自动触发该方法。 参数释义： self：实例本身，也就是 . 前面的对象 返回值： 必须是str类型 应用场景：非常常用，如Django框架admin，models类中都会定义该方法进行数据项展示 如下所示： class Category: x = 1 def __str__(self) -> str: return \"it is class %s instance object\" % self.__class__.__name__ if __name__== \"__main__\": instance = Category() print(instance) # it is class Category instance object __repr__() 交互式环境下输入对象标识符，print(object)时自动触发该方法。 参数释义： self：实例本身，也就是 . 前面的对象 返回值： 必须是str类型 应用场景：与__str__()应用场景相当，但是比它要强大一点。 如果没有实现__str__()方法，则会在print(object)时使用该方法。 如下所示： class Category: x = 1 def __repr__(self) -> str: return \"it is class %s instance object\" % self.__class__.__name__ if __name__== \"__main__\": instance = Category() print(instance) # it is class Category instance object __format__() format(object)时自动触发该方法。 参数释义： self：实例本身，也就是 . 前面的对象 format_spec：模板{:}中:后面的值 返回值： 必须是str类型 应用场景：自定义时间类，格式化打印相关 如下所示： class Date: formatStyle = { \"ymd\": \"{0.year}:{0.month}:{0.day}\", \"dmy\": \"{0.day}/{0.month}/{0.year}\", \"mdy\": \"{0.month}-{0.day}-{0.year}\", } def __init__(self, year, month, day) -> None: self.year = year self.month = month self.day = day def __format__(self, format_spec: str) -> str: if format_spec is None or format_spec not in __class__.formatStyle: format_spec = \"ymd\" return __class__.formatStyle[format_spec].format(self) if __name__== \"__main__\": instance = Date(2011, 1, 23) print(format(instance)) print(\"{:mdy}\".format(instance)) # 2011:1:23 # 1-23-2011 组合套餐 __enter__()与__exit__() __enter__()与__exit__()方法可实现上下文管理协议。 使用with语句将自动触发__enter__()方法的执行。 with语句代码块执行完毕后或者with语句代码块执行过程中抛出异常都会自动触发__exit__()方法的执行。 上下文管理作用如下： 使用with语句的目的就是把代码块放入with中执行，with结束后，自动完成清理工作，无须手动干预 在需要管理一些资源比如文件，网络连接和锁的编程环境中，可以在__exit__()中定制自动释放资源的机制，你无须再去关心这个问题，这将大有用处 函数签名如下： def __enter__(self) -> object: pass def __exit__(self, exc_type, exc_val, exc_tab) -> bool: pass __enter__()方法说明： 参数释义： self：实例本身，也就是 . 前面的对象 返回值： 返回的对象会被as语句当做句柄接收 __exit__()方法说明： 参数释义： self：实例本身，也就是 . 前面的对象 exc_type：异常类型 exc_val：异常值 exc_tab：异常回溯信息 返回值： 如果返回False则代表立即抛出异常，如果返回True则代表捕获本次异常 示例演示，通过__new__()方法和上下文管理协议，实现文件类封装： class OpenFile: fileObject = None __doc__= open.__doc__ def __new__(cls, *args, **kwargs) -> object: cls.fileObject = open(*args, **kwargs) return cls.fileObject def __enter__(self): return __class__.fileObject def __exit__(exc_type, exc_val, exc_tab): __class__.fileObject.close() return False def __del__(self): __class__.fileObject.close() def __getattr__(self, name: str): return getattr(__class__.fileObject, name) if __name__== \"__main__\": with OpenFile(\"./test.txt\", mode=\"rt\", encoding=\"utf8\") as f: print(f.read()) print(help(OpenFile)) __iter__()与__next__() __iter__()与__next__()可实现迭代器协议。 具体参照迭代器一章节，这里不再具体演示。 容器相关 __len__() 当使用len(object)时将会自动执行该方法。 该方法应当返回int类型。 示例如下： class Category: x = 1 def __len__(self): return 100 if __name__== \"__main__\": instance = Category() print(len(instance)) # 100 __contains__() 当使用 item in object 时将会自动执行该方法。 该方法应当返回bool类型。 示例如下： class Category: x = 1 def __contains__(self, item): return True if __name__== \"__main__\": instance = Category() print(\"a\" in instance) # True 双下方法一览表 以上介绍的均是常见的双下方法，足以应付大部分使用场景。 下面是双下方法大全表： __new__(cls[, …]) ： 是在一个对象实例化的时候所调用的第一个方法，它的第一个参数是这个类，其他的参数是用来直接传递给 __init__方法。决定是否要使用该 __init__方法，因为 __new__可以调用其他类的构造方法或者直接返回别的实例对象来作为本类的实例，如果 __new__没有返回实例对象，则 __init__不会被调用。 __new__主要是用于继承一个不可变的类型比如一个 tuple 或者 string。 __init__(self[, …])： 构造器，当一个实例被创建的时候调用的初始化方法 __del__(self)： 析构器，当一个实例被销毁的时候调用的方法 __call__(self[, args…])： 允许一个类的实例像函数一样被调用：x(a, b) 调用 x.__call__(a, b) __len__(self)： 定义当被 len() 调用时的行为 __repr__(self)： 定义当被 repr() 调用时的行为 __str__(self)： 定义当被 str() 调用时的行为 __bytes__(self)： 定义当被 bytes() 调用时的行为 __hash__(self)： 定义当被 hash() 调用时的行为 __bool__(self)： 定义当被 bool() 调用时的行为，应该返回 True 或 False __format__(self, format_spec)： 定义当被 format() 调用时的行为 有关属性 __getattr__(self, name)： 定义当用户试图获取一个不存在的属性时的行为 __getattribute__(self, name)： 定义当该类的属性被访问时的行为 __setattr__(self, name, value)： 定义当一个属性被设置时的行为 __delattr__(self, name)： 定义当一个属性被删除时的行为 __dir__(self)： 定义当 dir() 被调用时的行为 __get__(self, instance, owner)： 定义当描述符的值被取得时的行为 __set__(self, instance, value)： 定义当描述符的值被改变时的行为 __delete__(self, instance)： 定义当描述符的值被删除时的行为 比较操作符 __lt__(self, other)： 定义小于号的行为：x y 调用 x.gt(y) __ge__(self, other) ： 定义大于等于号的行为：x >= y 调用 x.ge(y) 算数运算符 __add__(self, other)： 定义加法的行为：+ __sub__(self, other)： 定义减法的行为：- __mul__(self, other)： 定义乘法的行为：* __truediv__(self, other)： 定义真除法的行为：/ __floordiv__(self, other)： 定义整数除法的行为：// __mod__(self, other)： 定义取模算法的行为：% __divmod__(self, other)： 定义当被 divmod() 调用时的行为 __pow__(self, other[, modulo])： 定义当被 power() 调用或 ** 运算时的行为 __lshift__(self, other)： 定义按位左移位的行为：> __and__(self, other)： 定义按位与操作的行为：& __xor__(self, other)： 定义按位异或操作的行为：^ __or__(self, other)： 定义按位或操作的行为：| 反运算 __radd__(self, other)： （与上方相同，当左操作数不支持相应的操作时被调用） __rsub__(self, other) ： （与上方相同，当左操作数不支持相应的操作时被调用） __rmul__(self, other) ： （与上方相同，当左操作数不支持相应的操作时被调用） __rtruediv__(self, other)： （与上方相同，当左操作数不支持相应的操作时被调用） __rfloordiv__(self, other)： （与上方相同，当左操作数不支加粗样式持相应的操作时被调用） __rmod__(self, other)： （与上方相同，当左操作数不支持相应的操作时被调用） __rdivmod__(self, other)： （与上方相同，当左操作数不支持相应的操作时被调用） __rpow__(self, other)： （与上方相同，当左操作数不支持相应的操作时被调用） __rlshift__(self, other)： （与上方相同，当左操作数不支持相应的操作时被调用） __rrshift__(self, other)： （与上方相同，当左操作数不支持相应的操作时被调用） __rand__(self, other)： （与上方相同，当左操作数不支持相应的操作时被调用） __rxor__(self, other)： （与上方相同，当左操作数不支持相应的操作时被调用） __ror__(self, other)： （与上方相同，当左操作数不支持相应的操作时被调用） 增量赋值运算 __iadd__(self, other)： 定义赋值加法的行为：+= __isub__(self, other)： 定义赋值减法的行为：-= __imul__(self, other)： 定义赋值乘法的行为：*= __itruediv__(self, other)： 定义赋值真除法的行为：/= __ifloordiv__(self, other)： 定义赋值整数除法的行为：//= __imod__(self, other)： 定义赋值取模算法的行为：%= __ipow__(self, other[, modulo])： 定义赋值幂运算的行为：**= __ilshift__(self, other)： 定义赋值按位左移位的行为：>= __iand__(self, other)： 定义赋值按位与操作的行为：&= __ixor__(self, other)： 定义赋值按位异或操作的行为：^= __ior__(self, other)： 定义赋值按位或操作的行为：|= 一元操作符 __pos__(self)： 定义正号的行为：+x __neg__(self)： 定义负号的行为：-x __abs__(self)： 定义当被 abs() 调用时的行为 __invert__(self)： 定义按位求反的行为：~x 类型转换 __complex__(self)： 定义当被 complex() 调用时的行为（需要返回恰当的值） __int__(self)： 定义当被 int() 调用时的行为（需要返回恰当的值） __float__(self)： 定义当被 float() 调用时的行为（需要返回恰当的值） __round__(self[, n])： 定义当被 round() 调用时的行为（需要返回恰当的值） __index__(self)： 当对象是被应用在切片表达式中时，实现整形强制转换，若定义了一个可能在切片时用到的定制的数值型,应该定义 __index__，若 __index__被定义，则 __int__也需要被定义，且返回相同的值 上下文管理（with 语句） __enter__(self)： 定义当使用 with 语句时的初始化行为，返回值被 with 语句的目标或者 as 后的名字绑定 __exit__(self, exc_type, exc_value, traceback)： 定义当一个代码块被执行或者终止后上下文管理器应该做什么，一般被用来处理异常，清除工作或者做一些代码块执行完毕之后的日常工作 容器类型 __len__(self)： 定义当被 len() 调用时的行为（返回容器中元素的个数） __getitem__(self, key)： 定义获取容器中指定元素的行为，相当于 self[key] __setitem__(self, key, value)： 定义设置容器中指定元素的行为，相当于 self[key] = value __delitem__(self, key)： 定义删除容器中指定元素的行为，相当于 del self[key] __iter__(self)： 定义当迭代容器中的元素的行为 __reversed__(self)： 定义当被 reversed() 调用时的行为 __contains__(self, item)： 定义当使用成员测试运算符（in 或 not in）时的行为 双下属性 类的属性 __doc__ 类的帮助信息，使用help(class or instanceObject)时，将获得该信息。 class Category: __doc__ = \"hello magic attribute\" if __name__== \"__main__\": help(Category) # class Category(builtins.object) # | hello magic attribute # | # | Data descriptors defined here: # ... __dict__ 类或者实例对象的底层字典。 详情参见类与对象一章。 __slots__ __slots__可以代替__dict__作为类或者实例的属性存储容器。 它还能限制实例对象属性的增加，如下只允许实例对象具有name和age属性，当添加gender属性时抛出异常： class Category: __slots__ = (\"name\", \"age\") if __name__== \"__main__\": instance = Category() instance.name = \"Jack\" print(instance.name) instance.age = 18 print(instance.age) instance.gender = \"male\" # Jack # 18 # AttributeError: 'Category' object has no attribute 'gender' __class__ 在类中调用__class__获得类本身。 通过self.__class__获得实例化出self的类。 推荐使用它来获取类属性，在类中使用__class__.attr而不是className.attr，这样更加灵活。 __base__ 通过className.__base__可获得类的父类，返回父类对象。 详情参见继承一章。 __bases__ 通过className.__bases__可获得类的父类，返回父类对象元组。 详情参见继承一章。 __mro__ 通过className.__mro__可获得该类的属性查找顺序列表。 详情参见继承一章。 全局属性 __file__ 获取当前脚本文件路径： print( __file__ ) # /Users/yunya/PythonProject/demo.py __name__ 如果使用__class__.name，则获取当前类的名称，而不是返回类对象： print( None.__class__ ) print( None.__class__.__name__ ) # # NoneType 如果在全局使用__name__则会判断执行方式是脚本“main”还是模块“module”。 详情参见模块一章。 __all__ 定义模块中允许被import *导入的标识符。 详情参见模块一章。 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-13 20:41:50 "},"Python/Python面向对象/描述符类.html":{"url":"Python/Python面向对象/描述符类.html","title":"描述符类","keywords":"","body":"描述符类 我们在之前接触了代理属性@property装饰器，它其实就是一个描述符，本质上而言是一个新式类。 如果想自定义一个描述符类，则必须实现以下三种双下方法的任意一个或多个： __get__()：获取描述符类实例时，触发该方法 __set__()：设置描述符类实例时，触发该方法 __delete__()：删除描述符类实例时，触发该方法 于此同时还需要注意在定义描述符类时的2点细节： 描述符类本身应该定义成新式类，被代理的类也应该是新式类 必须把描述符实例定义成这个类的类属性，不能定义到__init__()中成为实例属性 简单的属性代理示例，如下所示： 当访问Category.name时，会触发Proxy.__get__()方法 当设置Category.name时，会触发Proxy.__set__()方法 当删除Category.name时，会触发Proxy.__delete__()方法： class Proxy: proxyName = None def __get__(self, instance, owner): # ❶ print(\"run ... Proxy.__get__()\") return __class__.proxyName def __set__(self, instance, value): # ❷ print(\"run ... Proxy.__set__()\") __class__.proxyName = value def __delete__(self, instance): # ❸ print(\"run ... Proxy.__delete__()\") del __class__.proxyName class Category: name = Proxy() if __name__== \"__main__\": ins = Category() ins.name = \"King Kong\" print(ins.name) del ins.name # run ... Proxy.__set__() # run ... Proxy.__get__() # King Kong # run ... Proxy.__delete__() ❶：instance即实例对象本身，就是外部的ins标识符指向的对象，owner即实例对象拥有者，就是Category类 ❷：instance即实例对象本身，就是外部的ins标识符指向的对象，value是新设置的值，即23行的King Kong ❸：instance即实例对象本身，就是外部的ins标识符指向的对象 描述符类的种类 描述符类可分为数据描述符类和非数据描述符类，如下所示： 数据描述符类：至少实现了__get__()和__set__()方法的类 非数据描述符类：只实现了__get__()方法的类 数据描述符类和非数据描述符类对实例对象属性查找极其重要，所以这里特别指出。 如下，定义一个数据描述符类： class Proxy: def __get__(self, instance, owner): print(\"run ... Proxy.__get__()\") return __class__.proxyName def __set__(self, instance, value): print(\"run ... Proxy.__set__()\") __class__.proxyName = value 如下，定义一个非数据描述符类： class Proxy: def __get__(self, instance, owner): print(\"run ... Proxy.__get__()\") return __class__.proxyName 代理属性设置优先级 现在有1个类（Category），它的类属性（name）被代理了，并且代理类（Proxy）中设置了__set__()方法，于此同时被代理类（Category）中也设置了__setattr__()方法。 当对Category的实例对象进行. 操作试图修改name时，会执行哪一个方法？ Category.__setattr__()的优先级是高于Proxy.__set__()的，故会执行Category.__setattr__()方法。 如下所示： class Proxy: proxyName = None def __get__(self, instance, owner): print(\"run ... Proxy.__get__()\") return __class__.proxyName def __set__(self, instance, value): print(\"run ... Proxy.__set__()\") __class__.proxyName = value def __delete__(self, instance): print(\"run ... Proxy.__delete__()\") del __class__.proxyName class Category: name = Proxy() def __setattr__(self, name, value): print(\"run ... Category.__setattr__()\") self.__dict__[name] = value if __name__ == \"__main__\": ins = Category() ins.name = \"King Kong\" # run ... Category.__setattr__() 如果被代理类（Category）没有实现__setattr__()方法，则修改被代理属性name时，会触发Proxy.__set__()方法的执行： class Proxy: proxyName = None def __get__(self, instance, owner): print(\"run ... Proxy.__get__()\") return __class__.proxyName def __set__(self, instance, value): print(\"run ... Proxy.__set__()\") __class__.proxyName = value def __delete__(self, instance): print(\"run ... Proxy.__delete__()\") del __class__.proxyName class Category: name = Proxy() if __name__ == \"__main__\": ins = Category() ins.name = \"King Kong\" # run ... Proxy.__set__() 代理属性查找优先级 当具有描述符类存在时，属性查找顺序不再是一味的从实例开始查找到类及其超类。 而是按照以下流程： object.__getattribute__() 数据描述符 实例对象__dict__ 非数据描述符 类即超类__dict__ 类即超类__getattr__() 整个流程如图下所示： 1）数据描述符的查找优先于实例属性 class Proxy: proxyName = None def __get__(self, instance, owner): print(\"run ... Proxy.__get__()\") return __class__.proxyName def __set__(self, instance, value): print(\"run ... Proxy.__set__()\") __class__.proxyName = value def __delete__(self, instance): print(\"run ... Proxy.__delete__()\") del __class__.proxyName class Category: name = Proxy() def __init__(self) -> None: self.name = \"Proxy.proxyName\" if __name__ == \"__main__\": ins = Category() print(ins.__dict__) print(ins.name) # run ... Proxy.__set__() # {} # run ... Proxy.__get__() # Proxy.proxyName ❶：self.name的时候，由于name本身是一个被数据描述符类代理的属性，且Category未实现__setattr__()故会执行Proxy.__set__()方法，现在Proxy.proxyName = “Proxy.proxyName” ❷：由于self.name操作触发了Proxy代理类的__set__()方法执行，故instance.__dict__中并未拥有任何实例属性 ❷：28行print()操作试图获取这个被数据描述符类代理的属性，故会执行Proxy.__get__()方法获取并返回Proxy.proxyName 2）实例属性的查找优先于非数据描述符 class Proxy: proxyName = None def __get__(self, instance, owner): print(\"run ... Proxy.__get__()\") return __class__.proxyName class Category: name = Proxy() def __init__(self) -> None: self.name = \"instance name\" # ❶ if __name__ == \"__main__\": ins = Category() print(ins.__dict__) print(ins.name) # {'name': 'instance name'} # instance name ❶：self.name的时候，由于name不是一个被数据描述符类代理的属性，故底层会执行object.__setattr__()方法，将name变更为实例属性存储至instance.__dict__中 3）实例属性的查找优先于类属性 class Category: name = \"class name\" def __init__(self) -> None: self.name = \"instance name\" if __name__ == \"__main__\": ins = Category() print(ins.__dict__) print(ins.name) # {'name': 'instance name'} # instance name 描述符类简单应用 众所周知，Python是动态语言，即参数的赋值没有类型限制，下面我们通过描述符机制来实现类型限制功能。 注意点：如果对传入值进行参数设置，其被描述符代理属性的类千万不要设置 __setattr__()，因为__setattr__()方法的优先级高于描述符的__get__()方法。 class Proxy: def __init__(self, key, expectedType) -> None: self.key = key self.expectedType = expectedType def __get__(self, instance, owner): if instance is None: # ❶ return self return instance.__dict__[self.key] def __set__(self, instance, value): if not isinstance(value, self.expectedType): raise TypeError(\"parameter type error, expected %s type %s, but you give type is %s\" % ( self.key, self.expectedType, type(value))) instance.__dict__[self.key] = value def __delete__(self, instance): del instance.__dict__[self.key] class Category: name = Proxy(\"name\", str) age = Proxy(\"age\", int) def __init__(self, name: str, age: int) -> None: self.name = name self.age = age if __name__ == \"__main__\": ins = Category(\"Jack\", 18) print(ins.name, type(ins.name)) print(ins.age, type(ins.age)) # Jack # 18 ❶：这个判断条件是针对使用Category.被代理属性，如果是这样直接返回Proxy实例即可 类装饰器 装饰器可以给类装饰 装饰器的本质就是将@decorator下面的可调用对象当做参数自动传入到装饰器中，类本身是可调用的，因此我们也可以给类的上面套一个装饰器。 类的无参装饰器： def warpper(object): object.attr = \"newAttr\" return object @warpper class Category: pass if __name__ == \"__main__\": print(Category.attr) # newAttr 类的有参装饰器： def warpper(**kwargs): def inner(object): for k, v in kwargs.items(): setattr(object, k, v) return object return inner @warpper(name=\"Category\", type=\"class\") class Category: pass if __name__ == \"__main__\": for k,v in Category.__dict__.items(): if not k.startswith(\"__\"): print(k, v) # name Category # type class 类也可以作为装饰器 一定要理解，装饰器的本质只是将@decorator下对象的引用传入至形参中，所以我们也可以将类作为装饰器： class Warpper: def __new__(cls, instanceClass) -> object: instanceClassObject = instanceClass(\"Jack\", 18, \"male\") return instanceClassObject @Warpper class Category: def __init__(self, name, age, gender) -> None: self.name = name self.age = age self.gender = gender if __name__ == \"__main__\": print(Category) print(Category.name) print(Category.age) print(Category.gender) # # Jack # 18 # male 在这个例子中，Category其实是Category的instance对象。 描述符与类装饰器应用 属性类型限制 我们在学习了类的装饰器后，已经可以将其与描述符类相结合，完成以下功能了。 1）通过给类添加有参装饰器实现动态添加类属性： def addClassAttribute(**kwargs): def inner(cls): for k, v in kwargs.items(): setattr(cls, k, v) return cls return inner @addClassAttribute(name=\"Jack\", age=18, gender=\"male\") class Person: pass if __name__ == \"__main__\": for k, v in Person.__dict__.items(): if not k.startswith(\"__\"): print(k, v) # name Jack # age 18 # gender male 2）通过给类添加有参装饰器以及配合数据描述符实现实例属性类型检测： class Proxy: def __init__(self, key, expectedType) -> None: self.key = key self.expectedType = expectedType def __get__(self, instance, owner): if instance is None: # ❶ return self return instance.__dict__[self.key] def __set__(self, instance, value): if not isinstance(value, self.expectedType): raise TypeError(\"parameter type error, expected %s type %s, but you give type is %s\" % ( self.key, self.expectedType, type(value))) instance.__dict__[self.key] = value def __delete__(self, instance): del instance.__dict__[self.key] def addClassAttribute(**kwargs): def inner(cls): for k, v in kwargs.items(): setattr(cls, k, Proxy(key=k, expectedType=v)) return cls return inner @addClassAttribute(name=str, age=int, gender=str) class Person: def __init__(self, name: str, age: int, gender: str) -> None: self.name = name self.age = age self.gender = gender if __name__ == \"__main__\": for k, v in Person.__dict__.items(): if not k.startswith(\"__\"): print(k, v) ins = Person(name=\"Jack\", age=\"19\", gender=1) # name # age # gender # TypeError: parameter type error, expected type , but you give type is ❶：这个判断条件是针对使用Person.被代理属性，如果是这样直接返回Proxy实例即可 自定义property @property本身是通过描述符类实现的，因此我们也可以自己实现: class Property: def __init__(self, method) -> None: self.method = method def __get__(self, instance, owner): if instance is None: # ❶ return self else: v = self.method(instance) # ❷ # instance.__dict__[self.method.__name__] = v # ❸ return v class Person: def __init__(self, name, height, weight): self.name = name self.height = height self.weight = weight @Property def bmi(self): v = self.weight / (self.height ** 2) if 20 25: return \"overweight\" return \"obesity\" if __name__ == \"__main__\": instanceObject = Person(\"ken\", height=1.76, weight=77) print(instanceObject.bmi) #　normal ❶：这个判断条件是针对使用Person.被代理属性的操作，如果是这样直接返回Proxy实例即可 ❷：手动的为self传递参数为instance ❸：这里是做一个缓存功能，将第一次求值结果存放至实例字典中。 如果要做缓存功能，则需要注意自定义的这个描述符种类必须是非数据描述符，因为数据描述符属性的查找顺序是在实例之前。 此外，如果添加上缓存功能，后续该实例的身高体重一旦发生改变，则会导致二次求值结果不准确，因此一般不做这个缓存 自定义classmethod @classmethod本身是通过描述符类实现的，因此我们也可以自己实现: class ClassMethod: def __init__(self, method) -> None: self.clsMethod = method def __get__(self, instance, owner): def inner(*args, **kwargs): return self.clsMethod(owner, *args, **kwargs) return inner class Person: desc = \"This is person class\" @ClassMethod def show(cls, x, y, z): print(x, y, z) print(cls.desc) if __name__ == \"__main__\": Person.show(1, 2, 3) # 1 2 3 # This is person class 自定义staticmethod @staticmethod本身是通过描述符类实现的，因此我们也可以自己实现： class StaticMethod: def __init__(self, method) -> None: self.staticMethod = method def __get__(self, instance, owner): def inner(*args, **kwargs): return self.staticMethod(*args, **kwargs) return inner class Person: @StaticMethod def show(x, y, z): print(x, y, z) if __name__ == \"__main__\": Person.show(1, 2, 3) # 1 2 3 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-07-06 11:47:50 "},"Python/Python面向对象/元类编程.html":{"url":"Python/Python面向对象/元类编程.html","title":"元类编程","keywords":"","body":"一切皆对象 函数是对象 Python中一切皆对象，故函数也是一个实例对象。 通过function.__class__，可以拿到创建出函数这个实例对象的类： >>> func = lambda : 1 >>> print(func.__class__) 我们还可以为函数实例对象增添实例属性，虽然没人会这样做： >>> func.attr = \"intance attribute\" >>> func.attr 'intance attribute' 类也是对象 由于一切皆对象的缘故，故类也是一个实例对象。 而创建出类这个实例对象的类，被称为元类（metaclass），Python中只有1个内置元类，为type。 如下示例，使用class.__class__即可拿到元类type： >>> int.__class__ >>> list.__class__ >>> class Category: pass >>> Category.__class__ 什么是元类 经过上面的例子，我们可以看见所有类都是由元类type类进行实例化而得到的。 故元类即为创造类的类，它的作用主要有2个： 用于生产出类对象 用于生产出类对象的实例对象 class定义内部机制 当我们使用class关键字定义一个类之后，底层的创建步骤大体可分为4步： 拿到类标识符 拿到类的基类 执行类体代码，创建类的命名空间 调用元类，默认为type类，得到实例化出的类对象 创建类不一定非要使用class关键字，也可以有其他形式，下面这个示例将重现上面4大步骤： # first step : get class name className = \"Person\" # second step : get class parent class and super class and bases classes classBasesClass = (object, ) # third step 1 : definition class __dict__ ， Now this is empty classDict = {} # third step 2 : get class body code , It is interpreted by Python is a string classBody = \"\"\" def __init__(self, name, age, gender): self.name = name self.age = age self.gender = gender def show(self): return \"name : %s age : %s gender : %s\"%(self.name, self.age, self.gender) \"\"\" # first param : class body code # second param : global name space # last param : class __dict__ , is class local name space exec(classBody, {}, classDict) # Now, class __dict__ have content, class initing end print(classDict) # last step # class name give global identifier Person Person = type(className, classBasesClass, classDict) if __name__ == \"__main__\": ins = Person(name=\"Jack\", age=18, gender=\"male\") print(ins.show()) 自定义元类 如何自定义元类 如果一个类继承了type类，那么他就是一个元类： class MetaClass(type): pass print(type(MetaClass)) # 元类如何生产出类对象 元类如何生成出一个类呢？实际上class ClassName后执行脚本时这一系列过程都是自动的。 在元类中会经历2大步骤： 调用元类自己的__new__()方法，构建出1个空的类对象 调用元类自己的__init__()方法，为空的类对象增添属性 详细的整体过程如图所示： 如下示例，我们如果要指定1个类的元类，则必须在其继承括号中添加上 metaclass = className 的字样： class MetaClass(type): def __new__(cls, *args, **kwargs) -> object: \"\"\" cls : meta class args : (class name, (class bases, ), { class __dict__ }) kwargs : empty dict Returns: object: meta class instance object \"\"\" # must transfer all params return super(__class__, cls).__new__(cls, *args, **kwargs) def __init__(self, *args, **kwargs) -> None: \"\"\" self : meta class instance object args : (class name, (class bases, ), { class __dict__ }) kwargs : empty dict Returns: None \"\"\" super(__class__, self).__init__(*args, **kwargs) class Person(object, metaclass=MetaClass): pass if __name__ == \"__main__\": pass 当解释器执行到25行时，会自动调用元类__new__()方法开始构造类对象。 元类如何生产出类的实例对象 一个普通的类如果创建实例对象，必定会使用className()的形式。 那么他底层会做什么事情呢？如下所示： 当className()时， 类自动调用元类下的_call\\_()方法 元类下的__call__()方法会自动调用类的__new__()方法，创建出一个空的实例化对象 元类下的__call__()方法会自动调用类的__init__()方法，为这个空实例化对象增添实例属性 元类下的__call__()方法将返回造好的这个实例化对象 如下所示： class MetaClass(type): # create cls object method : __new__() 、 __init__() def __new__(cls, *args, **kwargs) -> object: return super(__class__, cls).__new__(cls, *args, **kwargs) def __init__(self, *args, **kwargs) -> None: super(__class__, self).__init__(*args, **kwargs) # create cls instance obj method : __call__() def __call__(cls, *args, **kwargs) -> object: \"\"\" cls : meta class instance object args : cls instance position params kwargs : cls instance keyword params Returns : cls instance object \"\"\" clsInstanceObject = cls.__new__(cls, *args, **kwargs) cls.__init__(clsInstanceObject, *args, **kwargs) return clsInstanceObject class Person(object, metaclass=MetaClass): def __new__(cls, *args, **kwargs) -> object: return super(__class__, cls).__new__(cls) def __init__(self, name, age, gender) -> None: self.name = name self.age = age self.gender = gender if __name__ == \"__main__\": ins = Person(name=\"Jack\", age=18, gender=\"male\") 过程图示如下： 实例对象与类对象的属性查找 查找的区别 我们如果对ins加上括号，会不会调用元类的__call()__方法呢？ 答案是不会，实例对象和类对象的属性查找是不一样的，验证如下所示： class MetaClass(type): # create cls object method : __new__() 、 __init__() def __new__(cls, *args, **kwargs) -> object: return super(__class__, cls).__new__(cls, *args, **kwargs) def __init__(self, *args, **kwargs) -> None: super(__class__, self).__init__(*args, **kwargs) # create cls instance obj method : __call__() def __call__(cls, *args, **kwargs) -> object: clsInstanceObject = cls.__new__(cls, *args, **kwargs) cls.__init__(clsInstanceObject, *args, **kwargs) return clsInstanceObject class Person(object, metaclass=MetaClass): def __new__(cls, *args, **kwargs) -> object: return super(__class__, cls).__new__(cls) def __init__(self, name, age, gender) -> None: self.name = name self.age = age self.gender = gender if __name__ == \"__main__\": ins = Person(name=\"Jack\", age=18, gender=\"male\") ins() # TypeError: 'Person' object is not callable 类对象的属性查找顺序 类对象如果要进行属性查找，它会去父类、超类、object基类以及type元类中查找。 如图所示： 示例如下： class MetaClass(type): findAttr = \"MetaClass.attr\" class A: # findAttr = \"A.attr\" pass class B(A): # findAttr = \"B.attr\" pass class C(B, metaclass=MetaClass): # findAttr = \"C.attr\" pass if __name__ == \"__main__\": print(C.findAttr) 实例对象的属性查找顺序 类的实例对象如果要进行属性查找，它会去父类、超类、object基类中查找，不会去元类层。 如图所示： 示例如下： class MetaClass(type): findAttr = \"MetaClass.attr\" class A: findAttr = \"A.attr\" pass class B(A): # findAttr = \"B.attr\" pass class C(B, metaclass=MetaClass): # findAttr = \"C.attr\" pass if __name__ == \"__main__\": ins = C() print(ins.findAttr) 实例练习 类的命名规则检测 有了自定义元类，我们可以将自定义类的命名规定为必须大驼峰，否则抛出异常： class MetaClass(type): def __new__(cls, *args, **kwargs): if not args[0].istitle(): raise NameError(\"class %s name must upper\" % args[0]) super(__class__, cls).__new__(cls, *args, **kwargs) class category(metaclass=MetaClass): pass # NameError: class name must upper 类的文档信息检测 有了自定义元类，我们可以规定类必须书写文档信息，即__doc__，否则抛出异常： class MetaClass(type): def __new__(cls, *args, **kwargs): if \"__doc__\" not in args[-1] : raise SyntaxError(\"class %s must have help doc\" % args[0]) super(__class__, cls).__new__(cls, *args, **kwargs) class Category(metaclass=MetaClass): pass # SyntaxError: class Category must have help doc Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-13 20:41:50 "},"Python/Python面向对象/异常处理.html":{"url":"Python/Python面向对象/异常处理.html","title":"异常处理","keywords":"","body":"异常介绍 异常分类 　　程序中难免出现错误，总共可分为两种。 　　1.逻辑错误 　　2.语法错误 　　对于刚接触编程的人来说，这两个错误都会经常去犯，但是随着经验慢慢的积累，语法错误的情况会越来越少反而逻辑错误的情况会越来越多（因为工程量巨大）。 不论多么老道的程序员都不可避免出现这两种错误。 异常信息 　异常其实就是程序运行时发生错误的信号，我们写代码的过程中不可避免也最害怕的就是出现异常，然而当程序抛出异常时实际上会分为三部分，即三大信息。 常见异常 在Python中一切皆对象，异常本身也是由一个类生成的，NameError其实本身就是一个异常类，其他诸如此类的异常类还有很多，如下表所示。 异常类 描述 AttributeError 属性错误，被查找属性不存在 IOError IO错误，文件无法打开 ImportError 导包错误，导入模块或包时给定了错误的路径或导入了没有的功能 IndentaionError 缩进错误，代码没有正确对齐 KeyError 键错误，获取字典中不存在的键 NameError 标识符错误，试图使用一个未被赋值的标识符 SyntaxError 语法错误，代码写错了 TypeError 类型错误，传入对象的类型和预期不符 ValueError 值错误，传入一个调用者不期望的值，即使值的类型是正确的 AssertionError 断言异常 异常处理 我们可以来用某些方法进行异常捕捉，当出现异常时我们希望代码以另一种逻辑运行，使得我们的程序更加健壮，这个就叫做异常处理。 异常处理是非常重要的，本身也并不复杂，千万不可马虎大意，但是切记不可滥用异常处理，这会使得你的代码可读性变差。 if else处理异常 if和else本身就具有处理异常的功能，他们更多的是在我们能预测到可能出现异常的范围内进行规避异常，对于我们不能预测的异常来说就显得不是那么的好用。 如下所示，我们仅期待用户输入数字，如果是输入其他内容则会被其他逻辑所处理： while 1: choice = input(\"Please enter a digital string:\") if choice.isdigit(): print(\"success!!\") break else: print(\"You input not is a digital string!!\") try/except try和except是最常用的一种异常处理方式。 try：代表要检测可能出现异常的代码块 except：当特定异常出现后的处理情况 执行流程如下： try中检测的代码块 如果有异常 执行except代码块 执行正常逻辑 执行完毕 try中检测的代码块 如果无异常 执行完try中代码快 执行正常逻辑 执行完毕 如图所示： 示例如下，try中未抛出异常： lst = [i for i in range(3)] try: print(\"run try\") print(lst[2]) except IndexError as e: print(\"run except\") print(\"normal code\") # run try # 2 # normal code 示例如下，try中抛出异常： lst = [i for i in range(3)] try: print(\"run try\") print(lst[3]) except IndexError as e: print(\"run except\") print(\"normal code\") # run try # run except # normal code 多段except捕捉多异常 使用1个try和多个except来捕捉多种可能出现的异常： lst = [i for i in range(3)] dic = dict.fromkeys((chr(i) for i in range(65, 68)), None) try: print(lst[2]) print(dic[\"D\"]) except IndexError as e: print(\"index error %s \" % e) except KeyError as e: print(\"key error %s\" % e) print(\"normal code\") # 2 # key error 'D' # normal code 元组捕获多异常 使用多段except处理多异常会显得麻烦，可以使用except (error1, error2)来处理多个异常。 但是多个异常只有1个处理结果，故处理逻辑可能会写的比较麻烦： lst = [i for i in range(3)] dic = dict.fromkeys((chr(i) for i in range(65, 68)), None) try: print(lst[2]) print(dic[\"D\"]) except (IndexError, KeyError) as e: if isinstance(e, IndexError): print(\"index error %s\" % e) elif isinstance(e, KeyError): print(\"key error %s\" % e) print(\"normal code\") # 2 # key error 'D' # normal code except捕获万能异常 使用except Exception来捕捉所有可能出现的异常，Exception是所有异常的基类。 Exception类的父类则是BaseException类，而BaseException的父类则是object类 lst = [i for i in range(3)] dic = dict.fromkeys((chr(i) for i in range(65, 68)), None) try: print(lst[2]) print(dic[\"D\"]) except Exception as e: if isinstance(e, IndexError): print(\"index error %s\" % e) elif isinstance(e, KeyError): print(\"key error %s\" % e) print(\"normal code\") # 2 # key error 'D' # normal code try/except/esle else代表没有异常发生的情况下执行的代码，如下图所示： 如下示例： lst = [i for i in range(3)] dic = dict.fromkeys((chr(i) for i in range(65, 68)), None) try: print(lst[2]) print(dic[\"A\"]) except Exception as e: if isinstance(e, IndexError): print(\"index error %s\" % e) elif isinstance(e, KeyError): print(\"key error %s\" % e) else: print(\"don't have throw an exception\") print(\"normal code\") # 2 # None # don't have throw an exception # normal code try/except/else/finally finally代表不论抛异常与否都会执行，因此常被用作关闭系统资源的操作。 如下图所示： 如下示例： lst = [i for i in range(3)] dic = dict.fromkeys((chr(i) for i in range(65, 68)), None) try: print(lst[2]) print(dic[\"A\"]) except Exception as e: if isinstance(e, IndexError): print(\"index error %s\" % e) elif isinstance(e, KeyError): print(\"key error %s\" % e) else: print(\"don't have throw an exception\") finally: print(\"last run this\") print(\"normal code\") # 2 # None # don't have throw an exception # last run this # normal code 主动抛出异常 在某些时候我们可能需要主动的去阻止程序的运行，主动的抛出一个异常。 以防止逻辑越错越远。 raise raise可以主动的抛出一个异常，如下所示： lst = [i for i in range(3)] l = input(\"please input %s length >>>\" % lst) if not l.isdigit(): raise TypeError(\"you must input number\") if int(l) != len(lst): raise ValueError(\"your length input error, he length is not %s\" % l) if int(l) == len(lst): print(\"success!!\") assert 断言内部会进行if判断，如果判断结果为False则抛出AssertionError异常，如果为True就不抛出AssertionError异常。 如下所示： lst = [i for i in range(3)] l = input(\"please input %s length >>>\" % lst) assert l.isdigit(), \"you must input number\" assert int(l) == len(lst), \"your length input error, he length is not %s\" % l print(\"success!!\") 自定义异常 前面已经说过一切皆对象，异常也来自一个对象，所以我们可以自定义一个异常，只需要继承BaseException类即可。 如下示例，内置异常没有InputTypeError，我们来自己定义一个： class InputTypeError(BaseException): pass lst = [i for i in range(3)] l = input(\"please input %s length >>>\" % lst) if not l.isdigit(): raise InputTypeError(\"you must input number\") if int(l) != len(lst): raise ValueError(\"your length input error, he length is not %s\" % l) if int(l) == len(lst): print(\"success!!\") Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-13 20:41:50 "},"Python/Python数算基础/summary.html":{"url":"Python/Python数算基础/summary.html","title":"Python数算基础","keywords":"","body":" 算法与数构 list和dict性能 数构之线构篇 数构之哈希篇 数构之链表篇 算法之递归篇 算法之搜索篇 算法之排序篇 数构之树相关 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-22 16:35:16 "},"Python/Python数算基础/算法与数构.html":{"url":"Python/Python数算基础/算法与数构.html","title":"算法与数构","keywords":"","body":"为什么要学习数算 随着应用程序变的越来越复杂，我们最常思考的问题无非下面2个： 如何存储海量数据？ 如何从海量数据中操纵所需要的数据？ 为了解决上述问题，我们需要有合理的机制来规划如何存储数据，那么如何存储数据即为数据的结构。 同时，我们还需要制定一系列方案，来思考如何从海量数据中进行增、删、改、查，这一方案的实现即程序的算法。 尼克劳斯·埃米尔·维尔特（n.writh）说过一句很著名的话： 程序 = 算法 + 数据结构 因此，一个良好的健硕的程序，必然根据其业务场景采用了合适的数据存储方案，并且指定了一系列相关的数据操纵方案。 什么是算法 算法的定义 算法（Algorithm）是指解题方案的准确而完整的描述，是一系列解决问题的清晰指令，算法代表着用系统的方法描述解决问题的策略机制。 也就是说，能够对一定规范的输入，在有限时间内获得所要求的输出。 如果一个算法有缺陷，或不适合于某个问题，执行这个算法将不会解决这个问题。 不同的算法可能用不同的时间、空间或效率来完成同样的任务。 一个算法的优劣可以用空间复杂度与时间复杂度来衡量。 算法与语言本身无关，仅是一种解决思路，用于解决一些实际的问题 通过知名算法的学习，可以提高编程思维，优化程序代码。 算法的特征 一个算法应该具有以下五个重要的特征： 有穷性（Finiteness） 算法的有穷性是指算法必须能在执行有限个步骤之后终止； 确切（Definiteness） 算法的每一步骤必须有确切的定义； 输入项（Input） 一个算法有0个或多个输入，以刻画运算对象的初始情况，所谓0个输入是指算法本身定出了初始条件； 输出项（Output） 一个算法有一个或多个输出，以反映对输入数据加工后的结果。没有输出的算法是毫无意义的； 可行性（Effectiveness） 算法中执行的任何计算步骤都是可以被分解为基本的可执行的操作步骤，即每个计算步骤都可以在有限时间内完成（也称之为有效性）。 算法的评定 同一问题可用不同算法解决，而一个算法的质量优劣将影响到算法乃至程序的效率。 算法分析的目的在于选择合适算法和改进算法。 一个算法的评价主要从时间复杂度和空间复杂度来考虑。 除此之外，评定规则还有以下3个： 正确性 算法的正确性是评价一个算法优劣的最重要的标准 可读性 算法的可读性是指一个算法可供人们阅读的容易程度 鲁棒性 鲁棒性是指一个算法对不合理数据输入的反应能力和处理能力，也称为容错性 时间复杂度 时间复杂度是指算法的大概运行时间，是判定算法优劣的重要评定规则，使用大O进行表示。 对一个算法的时间复杂度而言，对其影响最大因素就是需要解决的问题规模。 问题规模越大，解决时间也就越久，如下图所示： 时间复杂度更多是表示一个模糊的大概时间，而并非一个具体的准确的数字。 如： 抽一支烟，这个行为大概会占用几分钟的时间 睡一觉，这个行为大概会占用几个小时的时间 当然，这只是大概，并不用进行精确的求值，因为个体差异，客观环境因素等原因都会导致这个时间度不同，没有人敢确切的说自己在任何情况下抽一支烟只花费3分钟，也没有人敢确切的说自己在任何情况下睡一觉只花费8个小时。 时间复杂度可依照基础语句对其进行判断，基础语句操作的时间复杂度记为1 除此之外还有循环次数n，和循环嵌套层数n²或者n³、至于四层循环就很少了，不再举例。 当有多种判定时，取最大的即可： 1）仅一次基础操作，时间复杂度就直接等于1： x = 1 # O(1) # 取O(1) 2）根据问题规模而变化，单次循环，时间复杂度等于循环次数n： for i in range(n): # O(n) x = i # O(1) # 取O(n) 3）一个更加复杂的问题规模，双层循环，时间复杂度等于循环次数n加上循环嵌套层数： for i in range(n): # O(n²) for j in range(n): x = i + j # O(1) # 取O(n²) 4）目前来说相当复杂的问题规模，三层循环，时间复杂度等于循环次数n加上循环嵌套层数： for i in range(n): # O(n³) for j in range(n): for k in range(n): x = i + j + k # O(1) # 取 O(n³) 当然，不要陷入逻辑误区，像下面这条语句的时间复杂度也是O(1)，因为1次基础操作和3次基础操作的速度没有本质区别，它没有一个可以改变问题规模的n，所以归类为O(1)而不是O(3)。 一定记住一句话，时间复杂度是一个模糊的估算值，并不是确切值： x = 1 x = 2 x = 3 继续判断，将下面代码看为4部分，依照取最大的原则： a = 5 # O(1) b = 6 c = 10 for i in range(n): # O(n²) for j in range(n): x = i * i y = j * j z = i * j for k in range(n): # O(n) w = a * k + 45 v = b * b d = 33 # O(1) # 取O(n²) 同时，如果双层循环中，内层循环有多个，时间复杂度也记为O(n²)，因为循环只嵌套了2层，如下所示： for i in range(n): for j in range(n): pass for k in range(n): pass # 层数是2，所以取O(n²) 还有一个常见的时间复杂度，O(logn)。 如下所示，每一次运行，问题规模减少一半，其实全部表示法是O(log2n)，简写为了O(logn)，这种时间复杂度在递归中很容易看到。 n = 64 # O(1) while n > 1: # O(log2n) print(n) # O(1) n = n // 2 以下方法可快速判断算法的时间复杂度： 确定问题规模O(n) 有没有循环减半的过程O(logn) 有几层循环O(nn) 空间复杂度 空间复杂度是用来评估算法内存占用大小的式子。 空间复杂度和时间复杂度是一种相对应的关系，一句很流行的话叫做空间换时间，也是现在的主流，如分布式等架构就是典型的空间换时间。 表示方式与时间复杂度完全一样，都采用大O表示法： 算法使用了几个变量：O(1) 算法使用了长度为n的一维列表：O(n) 算法使用了n行n列的二维列表：O(nn) 一般来说，时间复杂度的判定比空间复杂度的判定更为重要。 什么是数据结构 数据结构的定义 数据结构是计算机存储、组织数据的方式。 数据结构是指相互之间存在一种或多种特定关系的数据元素的集合。 通常情况下，精心选择的数据结构可以带来更高的运行或者存储效率。 数据结构往往同高效的检索算法和索引技术有关。 常见数据结构 线性结构：数据结构中的元素存在一对一的相互关系 树形结构：数据结构中的元素存在一对多的相互关系 图形结构：数据结构中的元素存在多对多的相互关系 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-13 21:41:58 "},"Python/Python数算基础/list和dict性能.html":{"url":"Python/Python数算基础/list和dict性能.html","title":"list和dict性能","keywords":"","body":"2种常用类型 在Python中，最常用的2种数据类型为list和dict。 你是否了解过它们的各种方法，时间复杂度到底如何？在那种策略下用那种方法更省时？ 两种数据类型都拥有很多方法，常用的亦或是不常用的，因此在Python设计之初定下了一个原则： 让最常用的操作性能最好，牺牲不太常用的操作 在实际使用中，80%的功能其使用率往往只有20%，因此将剩下的20%的功能时间复杂度降低，而将不常用的80%功能时间复杂度增加，做到一种均衡的策略。 其实在Python官网上，已经贴出了每种数据类型方法的时间复杂度，点我跳转 dict 官方展示 The Average Case assumes parameters generated uniformly at random. Internally, a list is represented as an array; the largest costs come from growing beyond the current allocation size (because everything must move), or from inserting or deleting somewhere near the beginning (because everything after that must move). If you need to add/remove at both ends, consider using a collections.deque instead. Operation Average Case Amortized Worst Case Copy O(n) O(n) Append[1] O(1) O(1) Pop last O(1) O(1) Pop intermediate[2] O(n) O(n) Insert O(n) O(n) Get Item O(1) O(1) Set Item O(1) O(1) Delete Item O(n) O(n) Iteration O(n) O(n) Get Slice O(k) O(k) Del Slice O(n) O(n) Set Slice O(k+n) O(k+n) Extend[1] O(k) O(k) Sort O(n log n) O(n log n) Multiply O(nk) O(nk) x in s O(n) min(s), max(s) O(n) Get Length O(1) O(1) pop()和inster() pop()和inster()通常来说有2种情况： 如果都是操纵list[-1]，也就是最后一个数据项，它们的时间复杂度均为O(1) 如果操纵的是其他数据项，则时间复杂度均为O(n) 由于list底层是顺序存储，故任何一个非index-1的数据项的添加或删除都会引起整个列表的调整。 例如，从中部移除数据项的话，要把被移除数据项后面的全部数据项向前挪一个槽位。 虽然看起来有点笨拙，但这种实现方法能够保证列表按索引取值和赋值的操作很快，能够达到O(1)的良好情况。 这也算是一种对常用和不常用操作的折衷方案吧。 dict 官方展示 The Average Case times listed for dict objects assume that the hash function for the objects is sufficiently robust to make collisions uncommon. The Average Case assumes the keys used in parameters are selected uniformly at random from the set of all keys. Note that there is a fast-path for dicts that (in practice) only deal with str keys; this doesn't affect the algorithmic complexity, but it can significantly affect the constant factors: how quickly a typical program finishes. Operation Average Case Amortized Worst Case k in d O(1) O(n) Copy[3] O(n) O(n) Get Item O(1) O(n) Set Item[1] O(1) O(n) Delete Item O(1) O(n) Iteration[3] O(n) O(n) 为什么字典这么快 dict内部采用hash存储，所以单点查找非常迅速，但不能使用范围查找。 这也是所有hash存储的特性，是属于一种典型的空间换时间的方案。 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-14 17:04:26 "},"Python/Python数算基础/数构之线构篇.html":{"url":"Python/Python数算基础/数构之线构篇.html","title":"数构之线构篇","keywords":"","body":"Linear Structure 认识线性结构 线性结构是一种有序的数据项集合结构，线性结构中除开第一个后最后一个数据项，其他每一个数据项都有前驱和后继，如图所示： 当新的数据项加入到数据集中时，只会加入到原有某个数据项之前或之后。 具有这种性质的数据集，就称为线性结构。 如Python中的list、tuple等数据类型都属于线性结构。 特点介绍 线性结构总有2端，在不同情况下，2端的称呼也不同。 如称呼为：(前端、后端)，（左端、右端）、（首端、尾端）： 还有称呼为：（上端、下端）、（顶端、底端）： 两端的称呼并不是关键，不同线性结构的关键区别在于数据项增减的方式。 有的线性结构只允许数据项从一端添加或删除，而有的线性结构则允许数据项从两端添加或删除，或者从任意位置添加或删除： 栈（Stack） 栈的特点 栈是一种数据项进出有序的线性结构，在栈中，所有数据项的加入和移除都只能发生在栈顶（stack top），而栈底（stack base）则不能有其他操作。 栈中的数据项总是按照后进先出（LIFO）的特性进行出入栈，如下图所示： 栈有一个特性，即进栈和出栈的次序正好相反。 这种访问次序反转的特性，我们在某些计算机操作上也经常碰到过，如浏览器的“后退back”按钮，最先back的是最近访问的网页，再比如Word的“Undo”按钮，最先撤销的是最近操作。 ADT Stack 如果要使用Python来定义栈这种数据结构，则应当提供以下方法： 方法名 描述 ADTStack() 一个类，用于构建一个空栈 push() 将值加入到栈顶，无返回值 pop() 将栈顶数据项移除，并返回被移除的数据项，栈会被修改 peek() “窥视”栈顶数据项，返回栈顶的数据项但不移除，栈不被修改 isEmpty() 返回栈是否为空栈 size() 返回栈中有多少个数据项 接下来我们基于Python内置的数据类型list，来实现一个栈。 其实实现非常简单，唯一需要考虑的就是栈顶是index-1处还是index0处。 推荐将index-1处作为栈顶，这样在进行出栈操作时list.pop()和list.append()方法时间复杂度为O(1)，而如果将index0处作为栈顶，则list.pop(0)和list.insert(0, item)方法的时间复杂度为O(n)： 以下是代码实现： #!/usr/bin/env python3 # -*- coding:utf-8 -*- class ADTStack: def __init__(self) -> None: self.stack = [] def push(self, item): self.stack.append(item) def pop(self): return self.stack.pop() def peek(self): return self.stack[-1] def isEmpty(self): return not bool(self.stack) def size(self): return len(self.stack) 符号匹配 我们可以利用栈的特性实现一个符号匹配，一组括号必须成对出现，如下所示： { { ( [ ] [ ] ) } ( ) } [ [ { { ( ( ) ) } } ] ] [ ] [ ] [ ] ( ) { } 如果不是成对出现的，像下面这样，就匹配失败： ( [ ) ] ( ( ( ) ] ) ) [ { ( ) ] 代码如下： from linear_structure import ADTStack def SymbolMatch(symbolString): s = ADTStack() leftSymbolString = \"([{\" rightSymbolString = \")]}\" for char in symbolString: # 如果被循环的字符是左符号 if char in leftSymbolString: s.push(char) # 如果被循环的字符不是左符号，也不是右符号，则抛出异常 elif not char in rightSymbolString: raise ValueError(\"character:% s does not support matching\" % char) # 开始循环右符号 else: # 1. 如果是空栈，代表左右符号个数不一，直接返回False # 2. 如果不是空栈，则判定左右符号是否匹配，如果不匹配直接返回False if s.isEmpty() or leftSymbolString.index(s.pop()) != rightSymbolString.index(char): return False # 循环完毕，判定所有左符号是否匹配完毕 return True if s.isEmpty() else False if __name__ == \"__main__\": print(SymbolMatch(\"{{([][])}()}\")) print(SymbolMatch(\"[{()]\")) 进制转换 使用栈的特性，我们可以快速实现2、8、16进制转换为10进制的函数。 思路图示，10进制转换2、8、16进制都可采用求余法，下图以2进制举例： 代码如下： from linear_structure import ADTStack def baseConversion(decimalNumber, base): s = ADTStack() digits = \"0123456789ABCDEF\" while decimalNumber > 0: quotient, residue = divmod(decimalNumber, base) decimalNumber = quotient s.push(residue) newString = \"\" while not s.isEmpty(): newString += digits[s.pop()] return newString if __name__ == \"__main__\": print(baseConversion(101, 2)) print(baseConversion(101, 8)) print(baseConversion(101, 16)) # 1100101 # 145 # 65 队列（Queue） 队列的特点 队列是一种数据项进出有序的线性结构，在队列中，数据项的添加总发生在其中一端（通常称为尾“tail”端），而数据项的移除总发生在另一端（通常称为首“head”端） 队列中的数据项总是按照先进后出（FILO）的特性进行出入栈，如下图所示： 队列仅有一个入口和一个出口，不允许数据项直接插入队中，也不允许从中间移除数据项。 队列其实在生活中随处可见，如排队、必须等到前一个人出队后，后一个人才能接着出队，当然新来的成员也不能进行插队，要想入队只能从队尾开始排列。 ADT Queue 如果要使用Python来定义一个队列这种数据类型，则应当提供以下方法： 方法名 描述 ADTQueue() 一个类，用于构建一个空队列 enqueue() 将值加入到队尾，无返回值 dequeue() 将队首数据项移除，并返回被移除的数据项，队列会被修改 isEmpty() 返回队列是否为空 size() 返回队列中有多少个数据项 接下来我们基于Python内置的数据类型list，来实现一个队列。 如果将list的index0处作为队列尾端，list的index-1处作为队列首端，则enqueue()复杂度为O(n)，而dequeue()复杂度为O(1) 如果将list的index0处作为队列首端，list的index-1处作为队列尾端，则enqueue()复杂度为O(1)，而dequeue()复杂度为O(n) 以下是代码实现，采用第2种方案，将list的index0处作为队列首端： #!/usr/bin/env python3 # -*- coding:utf-8 -*- class ADTQueue: def __init__(self) -> None: self.queue = [] def enqueue(self, item): self.queue.append(item) def dequeue(self): return self.queue.pop(0) def isEmpty(self): return not bool(self.queue) def size(self): return len(self.queue) 约瑟夫环 传说犹太人反叛罗马人，落到困境，约瑟夫和40人决定殉难，坐成一圈儿，报数1～7，报到7的人由旁边杀死，结果约瑟夫给自己安排了个位置，最后活了下来...... 现在，使用队列模拟解决约瑟夫环问题，队首始终是要被杀死的人，因此从第一轮开始由队首的人开始出队，每数到7，在队首的人就不必再入队了，依次循环往复： from linear_structure import ADTQueue def Joseph(nameList, num): q = ADTQueue() # 所有人加入游戏 for name in nameList: q.enqueue(name) # 只要剩下的人数大于1，游戏就继续 while q.size() > 1: # 前6个都没事 for i in range(num - 1): q.enqueue(q.dequeue()) # 第7个死掉 q.dequeue() return q.dequeue() if __name__ == \"__main__\": nameList = (\"position:%s\" % i for i in range(1, 42)) survivor = Joseph(nameList, 7) print(survivor) 双端队列（Deque） 双端队列的特点 双端队列是一种数据项进出有序的线性结构，跟队列相似，其两端可以称作“首”“尾”端或者“左”“右”端，但双端队列中数据项既可以从队首加入，也可以从队尾加入，数据项也可以从两端移除。 某种意义上说，双端队列集成了栈和队列的能力： 双端队列并不具有内在的LIFO或者FIFO特性，如果用双端队列来模拟栈或队列需要由使用者自行维护操作的一致性。 ADT Deque 如果要使用Python来定义一个双端队列这种数据类型，则应当提供以下方法： 方法名 描述 ADTDeque() 一个类，用于构建一个空的双端队列 appendLeft() 将值加入到队首，无返回值 appendRight() 将值加入到队尾，无返回值 popLeft() 将队首数据项移除，并返回被移除的数据项，队列会被修改 popRight() 将队尾数据项移除，并返回被移除的数据项，队列会被修改 isEmpty() 返回队列是否为空 size() 返回队列中有多少个数据项 接下来我们基于Python内置的数据类型list，来实现一个双端队列。 如果将list的index0处作为双端队列尾端，list的index-1处作为双端队列首端，则appendLeft()和popLeft()时间复杂度为O(1)，而appendRight()和popRight()时间复杂度为O(n) 如果将list的index0处作为双端队列首端，list的index-1处作为双端队列尾端，则appendLeft()和popLeft()时间复杂度为O(n)，而appendRight()和popRight()时间复杂度为O(1) 以下是代码实现，采用第2种方案，将list的index0处作为队列首端： #!/usr/bin/env python3 # -*- coding:utf-8 -*- class ADTDeque: def __init__(self) -> None: self.dequeue = [] def appendLeft(self, item): self.dequeue.insert(0, item) def appendRight(self, item): self.dequeue.append(item) def popLeft(self): return self.dequeue.pop(0) def popRight(self): return self.dequeue.pop() def isEmpty(self): return not bool(self.dequeue) def size(self): return len(self.dequeue) 回文词判定 我们可以利用双端队列的特性，进行回文词判定，如radar、madam、toot。 再比如中文短句“上海自来水来自海上”“山东落花生花落东山”等。 实现思路也非常简单，先将需要判定的词从队尾加入deque再从两端同时移除字符判定是否相同，直到deque中剩下0个或1个字符，代码如下： from linear_structure import ADTDeque def termJudgment(string): dq = ADTDeque() for ch in string: dq.appendLeft(ch) while dq.size() > 1: first = dq.popLeft() last = dq.popRight() if first != last: return False return True if __name__ == \"__main__\": print(termJudgment(\"radar\")) print(termJudgment(\"radarr\")) Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-18 13:30:26 "},"Python/Python数算基础/数构之哈希篇.html":{"url":"Python/Python数算基础/数构之哈希篇.html","title":"数构之哈希篇","keywords":"","body":"Hash Table 散列表（hash table）也被称为哈希表，它是一种根据键（key）来存储值（value）的特殊线性结构。 常用于迅速的无序单点查找，其查找速度可达到常数级别的O(1)。 散列表数据存储的具体思路如下： 每个value在放入数组存储之前会先对key进行计算 根据key计算出一个重复率极低的指纹 根据这个指纹将value放入到数组的相应槽位中 同时查找的时候也将经历同样的步骤，以便能快速的通过key查出想要的value。 这一存储、查找的过程也被称为hash存储、hash查找。 如图所示： 我们注意观察，其实散列表中的每一个槽位不一定都会被占据，它是一种稀疏的数组结构，即有许多的空位，并不像list那种顺序存放的结构一样必须密不可分，这就导致了散列表无法通过index来进行value的操作。 散列表在Python中应用非常广泛，如dict底层就是散列表实现，而dict也是经历了上述步骤才将key-value进行存入的，后面会进行介绍。 名词释义 在学习Hash篇之前，介绍几个基本的相关名词： 散列表（hash table）：本身是一个普通的数组，初始状态全是空的 槽位（slot、bucket）：散列表中value的存储位置，用来保存被存入value的地方，每一个槽位都有唯一的编号 哈希函数（hash function）：如图所示，它会根据key计算应当将被存入的value放入那一个槽位 哈希值（hash value）：哈希函数的返回值，也就是对数据项存放位置的结算结果 还有2个比较专业性的词汇： 散列冲突：打个比方，k1经过hash函数的计算，将v1存在了1号槽位上，而k22也经过了hash函数的计算，发现v2也应该存在1号槽位上。 现在这种情况就发生了散列冲突，v2会顶替v1的位置进行存放，原本1号槽位的存放数据项会变为v2。 负载因子：说白了就说这个散列表存放了多少数据项，如11个槽位的一个散列表，存放了6个数据项，那么该散列表的负载因子就是6/11 哈希函数 如何通过key计算出value所需要插入的槽位这就是哈希函数所需要思考的问题。 求余哈希法 如果我们的key是一串电话号码，或者身份证号，如436-555-4601： 取出数字，并将它们分成2位数（43，65，55，46，01） 对它们进行相加，得到结果为210 假设散列表共有11个槽位，现在使用210对11求余数，结果为1 那么这个key所对应的value就应当插入散列表中的1号槽位 平方取中法 平方取中法如下，现在我们的key是96： 先计算它的平方值：96^2 平方值为9216 取出中间的数字：21 假设散列表共有11个槽位，现在使用21对11求余数，结果为10 那么这个key所对应的value就应当插入散列表中的10号槽位 字符串求值 上面举例的key都是int类型，如果是str类型该怎么做？ 我们可以遍历这个str类型的key，并且通过内置函数ord()来将它字符转换为int类型： >>> k = \"hello\" >>> i = 0 >>> for char in k: i += ord(char) >>> i 532 然后再将其对散列表长度求余，假设散列表共有11个槽位，现在使用532对11求余数，结果为4 那么这个key所对应的value就应当插入散列表中的4号槽位。 字符串问题 如果单纯的按照上面的方式去做，那么一个字符完全相同但字符位置不同的key计算的hash结果将和上面key的hash结果一致，如下所示： >>> k = \"ollhe\" >>> i = 0 >>> for char in k: i += ord(char) >>> i 532 如何解决这个问题呢？我们可以使用字符的位置作为权重进行解决： 代码设计如下： def getHash(string): idx = 0 hashValue = 0 while idx 完美散列函数 为了应对散列冲突现象的发生，我们必须严格定制hash函数根据key生产hash值的这一过程，尽量做到每一个不同key产生的hash值都是不重复的，能做到这一点的hash函数被称为完美散列函数。 如何设计完美散列函数？主要看该散列函数产生的散列值是否有以下特性： 压缩性：任意长度的数据，得到的“指纹”长度是固定的 易计算性：从原数据计算“指纹”很容易 抗修改性：对原数据的微小变动，都会引起“指纹”的大改变 抗冲突性：已知原数据和“指纹”，要找到相同指纹的数据（伪造）是非常困难的 介绍2种产生散列函数的方案，MD5和SHA系列函数。 MD5（MessageDigest）将任何长度的数据变换为固定长为128位（16字节 ）的“摘要” SHA（SecureHashAlgorithm）是另一组散列函数 SHA-0/SHA-1输出散列值160位（20字节） SHA-256/SHA-224分别输出256位、224位 SHA-512/SHA-384分别输出512位和384位 128位二进制已经是一个极为巨大的数字空间：据说是地球沙粒的数量，MD5能达到这种效果。 160位二进制相当于10的48次方，地球上水分子数量估计是47次方，SHA-0能达到这种效果。 256位二进制相当于10的77方， 已知宇宙所有基本粒子大约是72～87次方，SHA-256能达到这种效果。 所以一般来说，MD5函数作为散列函数是非常合适的，而在Python中使用它们也非常简单： #! /usr/local/bin/python3 # -*- coding:utf-8 -*- import hashlib m = hashlib.md5(\"salt\".encode(\"utf8\")) m.update(\"HELLO\".encode(\"utf8\")) print(m.hexdigest()) # ad24f795146b59b78c145fbd6b7f4d1f 像这种方案，通常还被应用到一致性校验中，如文件下载、网盘分享等。 只要改变任意一个字节，都会导致散列值发生巨大的变化。 散列冲突 如果两个不同的key被散列映射到同一个槽位，则需要一个系统化的方法在散列表中保存第2个value。 这个过程称为“解决冲突”，除了可以使用完美散列函数进行解决之外，以下也会介绍一些常见的解决办法。 开放定址法 所谓的开放定址法就是一旦发生了冲突，就去寻找下一个空的散列地址，只要散列表足够大，空的散列地址总能找到，并将记录存入。 从冲突的槽开始往后扫描，直到碰到一个空槽如果到散列表尾部还未找到，则从首部接着扫描： 这种寻找空槽的技术称为“开放定址openaddressing” 逐个向后寻找空槽的方法则是开放定址技术中的“线性探测linearprobing” 如下图所示： 它有一个缺点，就是会造成数据项扎堆形成聚集（clustering）的趋势，这会影响到其他数据项的插入。 比如上图中4号和5号槽位都被占据了，下次的v3本来是要插入到5号槽位的，但是5号槽位被v1占据了，它就只能再次向后查找： 针对这个缺点，可以做一个优化措施，即线性探测的范围从1变为3，每次向后查找3个槽位。 或者让线性探测的范围不固定，而是按照线性的趋势进行增长，如第一次跳3个，第二次跳5个，第三次跳7个等等，也是较好的解决方案。 如果采用跳跃式探测方案，则需要注意： 跳跃步数的取值不能被散列表大小整除，否则会产生周期性跳跃，从而造成很多空槽永远无法被探测到 这里提供一个技巧，把散列表的大小设为素数，如11个槽位大小的散列表就永远不会产生跳跃式探测方案的插槽浪费。 再哈希法 再哈希法又叫双哈希法，有多个不同的hash函数，当发生冲突时，使用第二个，第三个，等哈希函数计算槽位，直到出现空槽位后再插入value。 虽然不易发生聚集，但是增加了计算时间。 链地址法 每个哈希表节点都有一个next指针，多个哈希表节点可以用next指针构成一个单向链表，被分配到同一个索引上的多个节点可以用这个单向链表向后排列。 如下图所示： 公共溢出区 将哈希表分为基本表和溢出表两部分，凡是和基本表发生冲突的元素，一律填入溢出表。 当要根据key查找value时，先查找基本表，再查找溢出表。 ADT Map 思路解析 Python的dict是以一种key-value的键值对形式进行保存，也被称之为映射。 我们如何使用Python的list来实现一个类似的数据结构呢？参照dict，有2大因素： key必须具有唯一性，不可变 通过key可以唯一的确定一个value 在做ADT Map之前，思考一下它应该具有哪些方法： 方法 描述 ADTMap() 创建一个空的映射，返回空映射对象 set() 将key-val加入映射中，如果key已存在，将val替换旧关联值 get() 给定key，返回关联的数据值，如不存在，则返回None pop() 给定key，删除键值对，返回value，如果key不存在，则抛出KeyError，不进行缩容进制 len() 返回映射中key-val关联的数目 keys() 返回map的视图，类似于dict.keys() values() 返回map的视图，类似于dict.values() items() 返回map的视图，类似于dict.items() clear() 清空所有的key-val，触发缩容机制 in 通过key in map的语句形式，返回key是否存在于关联中，布尔值 [] 支持[]操作，与内置dict一致 for 支持for循环，与内置dict一致 我们都知道，Python3.6之后的dict是有序的，所以ADT Map也应该实现有序，减少遍历次数。 Ps：详情参见Python基础dict一章 另外还需要思考： 散列表应该是什么结构？ 采用怎样的哈希函数？ 如何解决可能出现的hash冲突？ 如何做到动态扩容？ 首先第一个问题，我们的散列表采用二维数组方式进行存储，具体结果如下，初始散列表长度为8，内容全为None，与Python内置的dict初始容量保持一致： [ [hash值, key, value], [hash值, key, value], [hash值, key, value], ... ] 第二个问题，这里采用字符串求值的哈希函数，也就是说key支持str类型 第三个问题，解决hash冲突采用开放定址+定性的线性探测 第四个问题，动态扩容也按照Python底层实现，即当容量超过三分之二时，进行扩容，扩容策略为已有散列表键值对个数 * 2，而在pop()时不进行缩容，但是在clear()会进行缩容，将散列表恢复初始状态。 map实现 下面是按照Python的dict底层实现的动态扩容map： #!/usr/bin/env python3 # -*- coding:utf-8 -*- class ADTMap: def __init__(self) -> None: # 初始容量为8 self.cap = 8 # 已有键值对个数为0 self.size = 0 # 初始map self.map = [[None] * 3] * self.cap # map顺序表 self.order = [None] * self.cap def set(self, key, value): # 求hash值 hashValue = self.__getHash(key) # 求插入或者更新槽位 slotIdx = self.__getSlot(hashValue) # 检查是否需要扩容, 当容量超过三分之二时，即进行扩容（resize）机制 if (self.size + 1 > round(self.cap * (2 / 3))): self.__resize() # 添加键值对 self.map[slotIdx] = [hashValue, key, value] self.size += 1 # 添加顺序表，如果是更新value，则不用添加 for i in range(len(self.order)): if self.order[i] is None or slotIdx == self.order[i]: self.order[i] = slotIdx break def get(self, key): # 求hash值 hashValue = self.__getHash(key) # 求key所在槽位 slotIdx = self.__getSlot(hashValue) return self.map[slotIdx][2] def pop(self, key): # 求hash值 hashValue = self.__getHash(key) # 求key所在槽位 slotIdx = self.__getSlot(hashValue) if self.map[slotIdx][2] == None: raise KeyError(\"%s\" % key) # 移除key self.size -= 1 retValue = self.map[slotIdx][2] self.map[slotIdx] = [None] * 3 for idx in range(len(self.order)): if self.order[idx] == slotIdx: # 删除 del self.order[idx] # 在最后添加空的，确保前面都是有序的不会出现None self.order.append([None] * 3) break return retValue def keys(self): for idx in self.order: if idx is not None: yield self.map[idx][1] else: break def values(self): for idx in self.order: if idx is not None: yield self.map[idx][2] else: break def items(self): for idx in self.order: if idx is not None: yield self.map[idx][1], self.map[idx][2] else: break def clear(self): self.cap = 8 self.size = 0 self.map = [[None] * 3] * self.cap self.order = [None] * self.cap def __setitem__(self, name, value): self.set(key=name, value=value) def __getitem__(self, name): return self.get(key=name) def __delitem__(self, name): # del map[\"k1\"] 无返回值 self.pop(key=name) def __contains__(self, item): keyList = self.keys() for key in keyList: if key == item: return True return False def __iter__(self): # 直接迭代map则返回keys列表 return self.keys() def __getHash(self, key): # int类型的keyhash值是其本身 if isinstance(key, int): return key # str类型需要使用ord()进行转换，并添加位权 if isinstance(key, str): idx = 0 v = 0 while idx str: retStr = \"\" for idx in self.order: if idx is not None: retStr += \" \" % (self.map[idx][1], self.map[idx][2]) else: break retStr = \"[\" + retStr + \"]\" return retStr Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-15 17:04:24 "},"Python/Python数算基础/数构之链表篇.html":{"url":"Python/Python数算基础/数构之链表篇.html","title":"数构之链表篇","keywords":"","body":"线性表(linear list) 顺序表(order list) Python中list和tuple的实现都是基于一种叫顺序表的东西。 顾名思义，所有的数据项都是有序的并且在一片连续的内存空间中存放，在使用顺序表进行存储时，需预先申请一整块足够大的存储空间，然后将数据按照次序逐一存储，数据项之间紧密贴合，不留一丝空隙： 当pop()掉任意一个非尾部数据项时，会导致pop()后的所有数据项前推，如下图所示： 同理，当insert()一个数据项时，如果insert()的数据项未在顺序表尾部，也会导致所有insert()后的数据项后移，如下图所示： 顺序表的优秀在于其查找性能，由于是顺序存储，故可以通过index直接获取到数据项本身，时间复杂度为O(1)，但缺点也很明显，诸如pop()、insert()、remove()等操作都会造成数据项前推或后移，时间复杂度是O(n)。 链表(linked list) 链表（Linked list），也是一种线性结构的数据类型，存储方式与顺序表截然相反，什么时候存储数据，什么时候才申请存储空间，数据之间的逻辑关系依靠每个数据项携带的指针维持： 链表的优秀在于其扩展性上，链表中数据项元素之间的逻辑关系靠的是节点之间的指针维持。 当需要在链表中某处插入或删除节点时，只需改变相应节点的指针指向即可，无需大量移动数据项，时间复杂度为O(1)。 而缺点在于其查找性能上，在链表中访问数据项，需要从链首依次遍历，直到找到指定节点，花费的时间复杂度为 O(n)。 下表中对顺序表和链表进行总结： 插入、删除、移动 查询 内存申请 链表 O(1) 需要从链首开始查找，所以是O(n) 按需申请 顺序表 由操作数据项的位置决定，最差情况是O(n) 顺序表中可直接使用index进行查询，所以是O(1) 一次申请 单向链表 认识单向链表 单向链表（Unidirectional Linked List）顾名思义，每个链表节点之间只有next指针，没有prev指针。 如下图所示： 如果需要让你来实现一个抽象的单向链表，你会如何设计呢？ 1）需要有一个LinkedListNode类，作为链表中的各个节点，主要包含以下属性和方法： self.nextNode：下一个节点指向，tail节点该属性总是为None self.dataItem：当前节点数据项 getData(self)：获取当前节点数据项 setData(self, item)：设置当前节点数据项 getNext(self)：获取当前节点的下一个节点 setNext(self, node)：设置当前节点的下一个节点 __str__(self) -> str：返回当前节点对象的显示 2）还需要有一个LinkedList类，来进行管理其中的各个节点，它主要包含以下属性和方法： self.head：当前链表中第一个节点 self.tail：当前链表中最后一个节点 self.size：当前链表的节点数量 add(self, item)：为当前链表增加一个新节点 search(self, item)：搜索并返回当前链表中某一个节点，若链表为空或被搜索节点不存在，使用该方法则抛出异常 remove(self, item)：删除并返回当前链表中某一个节点，若链表为空或被删除节点不存在，使用该方法则抛出异常 __str__(self) -> str：返回当前链表对象的显示 __len__(self) -> int：返回当前链表的长度 增加节点 增加节点的add()方法应当考虑将newNode插入到哪里性能最高？这个时候又分2种情况： 你的链表是无序链表 你的链表是有序链表 如果是无序链表，则可以直接插入在self.head节点前，或者也可以选择直接插入在self.tail节点后，它们的时间复杂度均为O(1)，这里需要注意2个点： 直接插入在self.head节点之前，列表总是以 直接插入在self.tail节点之后，列表总是以 -> 的方向新增节点 如下图所示： 如果是有序链表，则在插入前需要进行节点搜索并判断节点数据项的大小，由于此时的插入受到插入节点数据项大小与整体链表长度的因素影响，故插入性能是O(n)，如下图所示： 除了插入位置的考虑外，我们还需要考虑怎么添加新节点，单向链表比较简单，总体来说分为2步： 将newNode链接到currentSearchNextNode上 将currentSearchNode链接到newNode上 我们以单向有序链表举例，如下图所示： 这个顺序十分重要，如果将步骤互换，则会导致链表断开，currentSearchNextNode就找不到了： 当然也有解其他决方案，你可以用一个临时变量来存储currentSearchNextNode，但是并不推荐这样做。 搜索节点 如果是无序单向链表的查找，则需要从链首查到链尾，对比所有节点值与被查找的数据项是否一致，返回被查找的节点或者None，时间复杂度为O(n)。 如果是有序单向链表的查找，则只需要从链首查到大于被查找数据项的节点即可，也是返回被查找的节点或者None，时间复杂度为O(n)。 删除节点 节点的删除和节点查询的方法相差无几，唯一需要注意的是如果找到被删除的节点，则需要记录该节点的前一个节点，以便于删除currentSearchNode后让currentSearchPrevNode和currentSearchNextNode进行链接。 那么整体的顺序也是让currentSearchPrevNode指向currentSearchNextNode后，再将currentSearchNode的next指向清除。 如下图所示： 单向无序链表实现 下面是单向无序链表的实现代码： #!/usr/bin/env python3 # -*- coding:utf-8 -*- class UnidirectionalDisorderLinkedListNode: def __init__(self, dataItem) -> None: self.nextNode = None self.dataItem = dataItem def getData(self): return self.dataItem def setData(self, item): self.dataItem = item def getNext(self): return self.nextNode def setNext(self, node): self.nextNode = node def __str__(self) -> str: return str(\"\" % self.dataItem) class ADTUnidirectionalDisorderLinkedList: def __init__(self) -> None: self.head = None self.tail = None self.size = 0 def add(self, item): newNode = UnidirectionalDisorderLinkedListNode(dataItem=item) # 第一次插入 if self.head is None: self.head = newNode self.tail = newNode # 其他的插入 else: self.tail.setNext(newNode) self.tail = newNode self.size += 1 def search(self, item): if not self.size: raise ValueError(\"empty linked list not support search\") # 开始查找数据项 currentSearchNode = self.head # 遍历整个链表 while currentSearchNode is not None: if currentSearchNode.getData() == item: return currentSearchNode else: currentSearchNode = currentSearchNode.getNext() # 没找到，抛出异常 raise ValueError(\"%s does not exist\" % item) def remove(self, item): if not self.size: raise ValueError(\"empty linked list not support remove\") # 开始查找数据项 currentSearchNode = self.head currentSearchPrevNode = None # 遍历整个链表 while currentSearchNode is not None: # 符合条件 if currentSearchNode.getData() == item: # 被删除节点是链首 if currentSearchNode is self.head: self.head = currentSearchNode.getNext() # 被删除节点是链尾 elif currentSearchNode is self.tail: self.tail = currentSearchPrevNode self.tail.setNext(None) else: currentSearchPrevNode.setNext(currentSearchNode.getNext()) self.size -= 1 return currentSearchNode # 不符合条件，继续向下找 else: currentSearchPrevNode = currentSearchNode currentSearchNode = currentSearchNode.getNext() # 没找到，抛出异常 raise ValueError(\"%s does not exist\" % item) def __str__(self) -> str: if not self.size: return \"{}\" currentSearchNode = self.head retStr = \"{ \" while currentSearchNode.getNext() is not None: retStr += \"[%r] -> \" % currentSearchNode.getData() currentSearchNode = currentSearchNode.getNext() retStr += \"[%r] node-size:%r }\" % ( currentSearchNode.getData(), self.size) return retStr def __len__(self) -> int: return self.size 单向有序链表实现 下面是单向有序链表的实现代码： #!/usr/bin/env python3 # -*- coding:utf-8 -*- class UnidirectionalOrderLinkedListNode: def __init__(self, dataItem) -> None: self.nextNode = None self.dataItem = dataItem def getData(self): return self.dataItem def setData(self, item): self.dataItem = item def getNext(self): return self.nextNode def setNext(self, node): self.nextNode = node def __str__(self) -> str: return str(\"\" % self.dataItem) class ADTUnidirectionalOrderLinkedList: def __init__(self) -> None: self.head = None self.tail = None self.size = 0 def add(self, item): newNode = UnidirectionalOrderLinkedListNode(dataItem=item) # 第一次插入 if self.head is None: self.head = newNode self.tail = newNode # 其他的插入 else: currentSearchNode = self.head currentSearchPrevNode = None # 寻找插入位置 while currentSearchNode is not None and currentSearchNode.getData() str: if not self.size: return \"{}\" currentSearchNode = self.head retStr = \"{ \" while currentSearchNode.getNext() is not None: retStr += \"[%r] -> \" % currentSearchNode.getData() currentSearchNode = currentSearchNode.getNext() retStr += \"[%r] node-size:%r }\" % ( currentSearchNode.getData(), self.size) return retStr def __len__(self) -> int: return self.size 其他链表 双向链表 双向链表（double linked list）即每个节点除了拥有next指针外还有一个prev指针，如下图所示： 单向循环链表 单向循环链表是指tail节点会将next指针指向head节点，如下图所示： 双向循环链表 双向循环链表是指head节点的prev指针会指向tali节点，而tail节点的next指针会指向head节点，如下图所示： 跳跃表 普通的有序链表查找速度均为O(n)，总是按照一条线向后进行查找。 我们可以为链表中关键节点建立层级索引，如下图所示，这样就构成了跳跃表： 当要查询时，则从层级索引开始往下找，查找速度为O(logn)，但是空间复杂度会增加为O(n)，是典型的空间换时间的查询方式： Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-17 17:16:58 "},"Python/Python数算基础/算法之递归篇.html":{"url":"Python/Python数算基础/算法之递归篇.html","title":"算法之递归篇","keywords":"","body":"递归前言 递归（Recursion）相信各位都非常了解了，所以这里就不再详细阐述，具体可参照Python函数章节中的递归函数。 递归三大定律如下： 递归算法必须有一个基本结束条件 递归算法必须能改变问题规模 递归算法必须调用自身 分治策略 分治策略是指将一个大规模的问题分解成更小的相同问题，经过持续分解到最后问题规模小到可以用非常简单直接的方式来解决，或者将一个问题拆分成不同的各个部分，分而解决分而治之。 分治策略一般会经历三个步骤： 划分：此步骤涉及将问题分解为更小的子问题。子问题应该代表原始问题的一部分。这一步通常采用递归方法来划分问题，直到没有子问题可以进一步划分。在这个阶段，子问题本质上变成了原子，但仍然代表了实际问题的一部分 解决：这一步需要解决很多较小的子问题。通常，在此级别上，问题被视为自行“解决”。 合并：当较小的子问题得到解决时，这个阶段会开始递归地组合它们，直到它们合并成出原始问题的解决方案。 进制转换 前面的线性结构（栈）我们实现了一次10进制转换2、8、16进制，如果利用递归函数则整个实现过程又会变的非常简单。 如下所示： def baseConversion(n, base): digits = \"0123456789ABCDEF\" if n 汉诺塔 汉诺塔问题是由法国数学家爱德华·卢卡斯在 1883 年提出的。 他的灵感来自一个传说，有一个印度教寺庙，将谜题交给年轻的牧师，在开始的时候，牧师被给予三根杆和一堆 64 个金碟，每个盘比它下面一个小一点。 牧师的任务是将所有 64 个盘子从三个杆中一个转移到另一个。 有两个重要的约束： 一次只能移动一个盘子 不能在较小的盘子顶部上放置更大的盘子。 牧师日夜不停每秒钟移动一块盘子，传说，当他完成工作时，寺庙会变成灰尘，世界将消失。 游戏规则如下图所示： 如何用递归法求解呢？我们先对汉诺塔本身的游戏规则进行分析。 在上图中可以看到，s和m型号的圆盘，必须通过C号杆子再坐落到B号杆子上，我们可以将任意数量的非最大号的圆盘看为一整组，而最大号圆盘单独分为一组，总共将圆盘分为2组，并且在移动时按照组来进行划分： 算法如下，如此只要分三步即可： 把n-1个圆盘从柱子A经过C移动到B，但是省略掉到C的步骤，直接到B即可 把第n圆盘（最大的圆盘）从A移动到C 把n-1个圆盘从B经过A移动到C，但是省略掉到A的步骤，直接到C即可 代码如下，先按照3个圆盘求解： def hanoi(n, a, b, c): if n: # 从a经过c到b hanoi(n - 1, a, c, b) # 从a到c print(\"moving from %s to %s\" % (a, c)) # 从b经过a到c hanoi(n - 1, b, a, c) if __name__ == \"__main__\": hanoi(3, \"A\", \"B\", \"C\") # moving from A to C # moving from A to B # moving from C to B # moving from A to C # moving from B to A # moving from B to C # moving from A to C 贪心策略 贪心算法（又称贪婪算法）是指，在对问题求解时，总是做出在当前看来是最好的选择。 也就是说，不从整体最优上加以考虑，算法得到的是在某种意义上的局部最优解 。 贪心算法不是对所有问题都能得到整体最优解，关键是贪心策略的选择 。 找硬币问题 假设你为一家自动售货机厂家编程序，自动售货机要每次找给顾客最少数量硬币； 假设某次顾客投进$1(美元)纸币，买了ȼ37(美分)的东西，要找ȼ63，那么最少数量就是：2个quarter（ȼ25）、1个dime（ȼ10）和3个penny（ȼ1），一共6个。 人们会采用各种策略来解决这些问题，例如最直观的“贪心策略”，一般我们这么做： 从最大面值的硬币开始找起，用尽量少的硬币找尽量多的余额，直至最大的找不开 再到下一个最大面值的硬币，直至到penny（ȼ1）为止。 因为我们每次都试图解决问题的最大部分，对应到兑换硬币问题上就是每次以最多数量的最大面值硬币来迅速减少找零面值，这就是贪心策略，代码如下，你可以尝试将它改写成递归实现的： def findCoins(coinValueList, change): \"\"\" :param coinValueList: 传入硬币体系 :param change: 传入需要找回的硬币 :return: 返回的信息，找回多少 \"\"\" minCoins = \"\" for coin in coinValueList[::-1]: # 如果需要找的钱大于最大的面值，则算法开始 if change >= coin: # 最多找几枚最大面值的硬币? n = int(change // coin) # 最多能找多少钱? amount = n * coin # 还差多少钱没找？准备开始下一轮 change -= amount # 本次找了多少枚硬币，硬币是多少元 minCoins += \"%s枚%s元硬币\\n\" % (n, coin) return minCoins if __name__ == '__main__': print(findCoins([1, 5, 10, 25], 63)) # 2枚25元硬币 # 1枚10元硬币 # 3枚1元硬币 递归实现如下： def findCoins(coinValueList, change): minCoins = \"\" coin = coinValueList[-1] if change >= coin: n = int(change // coin) amount = n * coin change -= amount minCoins += \"%s枚%s元硬币\\n\" % (n, coin) if change == 0: return minCoins return findCoins(coinValueList[:-1], change=change) + minCoins if __name__ == '__main__': print(findCoins([1, 5, 10, 25], 63)) # 3枚1元硬币 # 1枚10元硬币 # 2枚25元硬币 动态规划 动态规划方法类似于分治法，将问题分解为更小的可能的子问题，但与分而治之不同的是，这些子问题不是独立解决的，相反，这些较小子问题的结果会被记住并用于相似或重叠的子问题。 在我们遇到问题的地方使用动态规划，可以将这些问题划分为类似的子问题，以便可以重复使用它们的结果。 大多数情况下，该算法往往用于优化。在解决现有子问题之前，动态算法将尝试检查先前解决的子问题的结果。将子问题的解决方案组合起来以获得最佳解决方案。 所以我们可以说： 问题应该能够分成更小的重叠子问题 最优解可以通过使用较小子问题的最优解来实现 动态算法使用记忆化 Elbonia奇怪的硬币体系 ”贪心策略”解决找零兑换问题，在美元或其他货币的硬币体系下表现尚好，但如果你的老板决定把自动售货机出口到Elbonia，事情就会有点复杂。 Elbonia是系列漫画Dilbert里杜撰的国家 这个古怪的国家除了上面3种面值之外，还有一种【ȼ21】的硬币！ 按照“贪心策略”，在Elbonia，ȼ63还是原来的6个硬币： ȼ63 =ȼ25*2+ȼ10*1+ȼ1*3 但实际上最优解是3个面值ȼ21的硬币！ ȼ63 =ȼ21*3 所以...贪心策略失效了。 常规解决 我们来找一种肯定能找到最优解的方法，放弃掉贪心策略的方案。 因为，贪心策略是否有效依赖于具体的硬币体系，如在Elbonia的货币体系中贪心策略就失效了。 首先是确定基本结束条件，兑换硬币这个问题最简单直接的情况就是，需要兑换的找零，其面值正好等于某种硬币，如找零25分，答案就是1个硬币！ 其次是减小问题的规模，我们要对每种硬币尝试1次，例如美元硬币体系： 找零减去1分(penny)后，求兑换硬币最少数量（递归调用自身） 找零减去5分(nikel)后，求兑换硬币最少数量 找零减去10分(dime)后，求兑换硬币最少数量 找零减去25分(quarter)后，求兑换硬币最少数量 上述4项中选择最小的一个 代码实现如下： #! /usr/local/bin/python3 # -*- coding:utf-8 -*- def recMC(coinValueList, change): minCoins = change if change in coinValueList: return 1 else: for i in [c for c in coinValueList if c 对63分的兑换硬币问题，需要进行67,716,925次递归调用。 这个实现方案我足足跑了40多秒，因为其中存在大量的子递归重复计算。 例如找零15分的，出现了3次！而它最终解决还要52次递归调用，下图中只是递归一角： 优化方案 对这个递归解法进行改进的关键就在于消除重复计算，我们可以用一个表将计算过的中间结果保存起来，在计算之前查表看看是否已经计算过，如果计算过就不运行函数，故也不会生成函数栈帧，极大减少了运行时长，这就是动态规划。 虽然这个做法会增大空间复杂度，但是会极大的减少时间复杂度，即让每个子问题只求解一次。 在递归调用之前，先查找表中是否已有部分找零的最优解如果有，直接返回最优解而不进行递归调用如果没有，才进行递归调用。 代码实现如下： #! /usr/local/bin/python3 # -*- coding:utf-8 -*- def recDC(coinValueList,change,knownResults): \"\"\" :param coinValueList: :param change: :param knownResults: 存表的结果（对应设计模式中，备忘录模式），因为我们要对63找零，所以这里设置为宽度为64的列表即可 \"\"\" minCoins = change # 递归结束基本条件 if change in coinValueList: # 记录最优解 knownResults[change] = 1 return 1 elif knownResults[change] > 0: # 查表成功，直接使用最优解 return knownResults[change] else: for i in [c for c in coinValueList if c 现在再次调用，则仅需要零点几秒就可以获得结果了。 Python内置库functools的@lrc_chace也实现了这种缓存功能，但该装饰器使用了字典存储缓存，所以被装饰函数的固定参数和关键字参数必须是可哈希的。 如下所示，不用自己写动态规划，直接调用该装饰器，只需要将货币体系传入由列表改为元组即可： #! /usr/local/bin/python3 # -*- coding:utf-8 -*- import functools @functools.lru_cache(maxsize=63) def recMC(coinValueList, change): minCoins = change if change in coinValueList: return 1 else: for i in [c for c in coinValueList if c 递归可视化 turtle module 这是一个Python内置的模块，随时可以进行调用，以LOGO语言的创意为基础模拟一只海龟在沙滩上爬行而留下的足迹。 以下是一些基本方法： 方法 描述 turtle.Turtle() 实例化对象 hideturtle() 使乌龟本身不可见，仅留下足迹 forward() 乌龟向前移动（头朝东） backward() 乌龟向后移动（头朝西） left() 乌龟向左边转向 right() 乌龟向右边转向 penup() 抬起画笔 pendown() 放下画笔 pensize() 笔的宽度 pencolor() 笔的颜色 turtle.done() 画完后不关闭 画一个三角形： import turtle import time def triangle(): t = turtle.Turtle() t.forward(200) t.right(60) t.backward(200) t.left(120) t.backward(200) if __name__ == '__main__': triangle() time.sleep(5) 自相似递归图形 分形Fractal，是1975年由Mandelbrot开创的新学科。 它的概念是：“一个粗糙或零碎的几何形状，可以分成数个部分，且每一部分都（至少近似地）是整体缩小后的形状”，即具有自相似的性质。 在大自然中的自相似递归图形有很多，比如雪花、树枝等等： 分形树 我们可以使用递归来画一颗二叉分形树，将树分解为3个部分：：树干、左边的小树、右边的小树。 分解后，正好符合递归的定义：对自身的调用。 代码如下： import turtle def tree(branch_len: int, t: turtle.Turtle) -> None: # 递归结束条件，树干不能太短 if branch_len > 5: # 画树干 t.forward(branch_len) # 右倾斜20度 t.right(20) # 递归，画右边小数，树干 - 15 tree(branch_len - 15, t) # 左倾斜40度，即回正后向左倾斜20度 t.left(40) # 递归，画左边小数，树干 - 15 tree(branch_len - 15, t) # 右倾斜20度，即回正 t.right(20) # 海龟退回原来的位置 t.backward(branch_len) if __name__ == '__main__': t = turtle.Turtle() # 转头，向正北 t.left(90) # 抬笔 t.penup() # 向上抬100个px t.backward(100) # 落笔 t.pendown() # 笔宽：2，颜色：绿色 t.pencolor(\"green\") t.pensize(2) # 开始画长度为75的树干 tree(75, t) # 使乌龟不可见 t.hideturtle() # 退出时不关闭 turtle.done() 效果演示： 谢尔宾斯三角形 谢尔宾斯三角形Sierpinski是一种分型构造。 创建一个三角形，然后每次都将这个三角形分成三份，无限制的挖下去最终这个三角形的面积会变为0，而周长变为无穷，是介于一维和二维之间的分数维（约1.585维）构造。 据自相似特性，谢尔宾斯基三角形是由3个尺寸减半的谢尔宾斯基三角形按照品字形拼叠而成。 由于我们无法真正做出谢尔宾斯基三角形（degree->∞），只能做degree有限的近似图形。 在degree有限的情况下，degree=n的三角形 ，是由3个degree=n-1的三角形按照品字形拼叠而成同时，这3个degree=n-1的三角形边长均为degree=n的三角形的一半（规模减小）。 当degree=0，则就是一个等边三角形，这是递归基本结束条件。 代码如下，感兴趣的可以仔细研究一下： import turtle def drawTriangle(points, color, myTurtle): myTurtle.fillcolor(color) myTurtle.up() myTurtle.goto(points[0][0], points[0][1]) myTurtle.down() myTurtle.begin_fill() myTurtle.goto(points[1][0], points[1][1]) myTurtle.goto(points[2][0], points[2][1]) myTurtle.goto(points[0][0], points[0][1]) myTurtle.end_fill() def getMid(p1, p2): return ((p1[0] + p2[0]) / 2, (p1[1] + p2[1]) / 2) def sierpinski(points, degree, myTurtle): colormap = ['blue', 'red', 'green', 'white', 'yellow', 'violet', 'orange'] drawTriangle(points, colormap[degree], myTurtle) if degree > 0: sierpinski([points[0], getMid(points[0], points[1]), getMid(points[0], points[2])], degree - 1, myTurtle) sierpinski([points[1], getMid(points[0], points[1]), getMid(points[1], points[2])], degree - 1, myTurtle) sierpinski([points[2], getMid(points[2], points[1]), getMid(points[0], points[2])], degree - 1, myTurtle) def main(): myTurtle = turtle.Turtle() myWin = turtle.Screen() myPoints = [[-100, -50], [0, 100], [100, -50]] sierpinski(myPoints, 3, myTurtle) myWin.exitonclick() if __name__ == '__main__': main() 效果演示： 绘制步骤： Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-18 15:20:58 "},"Python/Python数算基础/算法之搜索篇.html":{"url":"Python/Python数算基础/算法之搜索篇.html","title":"算法之搜索篇","keywords":"","body":"线性搜索 顺序查找也被称之为线性查找，因在Python中list的底层为顺序表存储，故我们可以使用index来循环遍历整个列表获得所需要查找的数据项。 它的时间复杂度为O(n)，如果刚好被搜索的数据项排列在最后一个，那么整个查找是非常耗费时间的： 如下所示，如果查找数据项50，将会查找11次： def seqLinerSearch(seq, findItem): idx = 0 count = 0 seqLenght = len(seq) while idx 有序的必要性 现在，让我们观察上面的代码是否有什么可以优化的地方。 我们的查找在数据项不存在的情况下总是会遍历完整个列表，导致这个问题的主要原因还是因为传入的列表是无序的。 如上述代码，我们查找数据项53，它总是一遍一遍的进行对比，直至对比完成整个列表发现都没有符合条件的数据项后才会返回，时间复杂度总是为O(n)，所以要针对这个情况进行简单的优化。 如果我们将列表排为有序的状态，当查找到71后，也就发现了没有必要往后查找，故至此直接返回即可。 优化策略： 列表要有序 如果正在遍历的数据项大于被查找的数据项，则代表此列表中没有该数据项 代码实现如下，虽然整体的时间复杂度还是O(n)，但是已经做了很大的优化了： def seqLinerSearch(seq, findItem): idx = 0 count = 0 seqLenght = len(seq) while idx 注意：排序本身就花费时间，复杂度为O(n log n) 二分搜索 通过上面的2个例子，可以得出一个结论： 对查找来说，保持数据项的有序是十分必要的 那么现在基于这个先决条件，介绍一种查找效率更高的算法，二分查找法。 二分查找的实现理念：每次只查找列表中间元素的值，判定这个中间元素与被查找元素的关系，通过关系将列表进行折半后，继续查找，时间复杂度是O(logn)，如下所示二分查找法与顺序查找的对比图： 实现二分查找，查找数据项50仅需要3次： #! /usr/local/bin/python3 # -*- coding:utf-8 -*- def binarySearch(seq, findItem): count = 0 l_idx = 0 r_idx = len(seq) - 1 while l_idx seq[m_idx]: l_idx = m_idx + 1 # 如果查找的元素小于当前列表中部索引的元素，则重新定义右侧索引 else: r_idx = m_idx - 1 else: return None, count if __name__ == '__main__': result, count = binarySearch([2, 8, 18, 22, 34, 37, 50, 71, 82, 91, 92], 50) print(result, count) # 50 3 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-18 16:17:44 "},"Python/Python数算基础/算法之排序篇.html":{"url":"Python/Python数算基础/算法之排序篇.html","title":"算法之排序篇","keywords":"","body":"排序简介 常见的十大排序算法如下所示，本章节会例举6种常见且易于掌握的排序算法： 算法名称 平均时间复杂度 最好情况 最坏情况 空间复杂度 排序方式 稳定性 冒泡排序 O(n²) O(n) O(n²) O(1) in-place 稳定 选择排序 O(n²) O(n²) O(n²) O(1) in-place 不稳定 插入排序 O(n²) O(n) O(n²) O(1) in-place 稳定 希尔排序 O(n log n) O(n log n) O(n log² n) O(1) in-plcae 不稳定 归并排序 O(n log n) O(n log n) O(n log n) O(n) out-place 稳定 快速排序 O(n log n) O(n log n) O(n²) O(log n) in-plcae 不稳定 堆排序 O(n log n) O(n log n) O(n log n) O(1) in-plcae 不稳定 计数排序 O(n + k) O(n + k) O(n + k) O(k) out-place 稳定 桶排序 O(n + k) O(n + k) O(n²) O(n + k) out-place 稳定 基数排序 O(n + k) O(n + k) O(n + k) O(n + k) out-place 稳定 关于排序算法的3大基础知识： 稳定性：示例，排序前红色3在蓝色3前面，如果排序完成后位置没有发生改变则该排序算法是稳定的： 稳定：1，2，3，3，5 不稳定：1，2，3，3，5 有序区和无序区：在排序算法中，会将一个序列分为2大区，如下所示： [1, 2, 3, | 28, 11, 43] ---------- ---------- 有序区 无序区 原地排序：原地排序是指在原序列中进行数据项排列，不用开辟额外内存空间 非原地排序则需要生成新的序列，来存储排列好的数据项，空间复杂度会增加 冒泡排序 冒泡排序（Bubble Sort）是一种简单的排序算法。 这种排序算法是基于比较的算法，每次比较2个相邻数据项并进行交换。 该算法不适合大型数据集，因为其平均和最坏情况复杂度为 Ο(n²)，其中n是项目数。 代码及注释如下： def bubbleSort(seq): # ❶ for i in range(len(seq) - 1): # ❷ tag = False # ❸ for j in range(len(seq) - (i + 1)): if seq[j] > seq[j + 1]: seq[j], seq[j + 1] = seq[j + 1], seq[j] tag = True if not tag: break if __name__ == \"__main__\": lst = [2, 1, 3, 4, 5, 6, 7, 8, 9] bubbleSort(lst) print(lst) ❶：我们认为最后1个数据项不用排序，故循环次数是 len(seq) - 1，每一次外层循环都会令有序区数据项 + 1 ❷：一个标志位，用于判定是否还需要继续进行排序 ❸：内层循环只会遍历无序区数据项，i 是外层循环次数， + 1代指seq最后1个数据项，即不用排序的数据项 如果不加该标志位，则会产生许多重复的且无用的排序，因此该标志位算是一种优化手段。 选择排序 选择排序（Selection Sort）会将序列分为2部分，有序区和无序区。 它的工作原理：首先在无序区中找到最小（大）数据项，存放到有序区的起始位置，然后，再从剩余无序区中继续寻找最小（大）数据项，然后放到有序区的末尾。 以此类推，直到所有数据项均排序完毕。 该算法不适合大型数据集，因为其平均和最坏情况复杂度为 Ο(n²)，其中n是项目数。 代码及注释如下： def selectionSort(seq): # ❶ for i in range(len(seq) - 1): # ❷ minIndex = i # ❸ for j in range(i + 1, len(seq)): # ❹ if seq[minIndex] > seq[j]: minIndex = j # ❺ if minIndex != i: seq[i], seq[minIndex] = seq[minIndex], seq[i] if __name__ == '__main__': lst = [4, 1, 0, 2, 3] selectionSort(lst) print(lst) ❶：我们认为最后1个数据项不用排序，故循环次数是 len(seq) - 1，每一次外层循环都会令有序区数据项 + 1 ❷：将当前被外层循环遍历的数据项当做最小值，并记录其索引位置 ❸：循环所有无序区数据项 ❹：判断当前被遍历的无序区数据项是否小于以设定的最小值数据项，如果是则更新 ❺：交换最小值数据项与外层循环被遍历数据项的位置 插入排序 插入排序（Inster Sort）类似于打扑克牌，先会构建出一个有序区，再遍历无序区数据项并将其插入到有序区中合适的位置。 该算法不适合大型数据集，因为其平均和最坏情况复杂度为 Ο(n²)，其中n是项目数。 代码及注释如下： def insertSort(seq): # ❶ for i in range(1, len(seq)): # ❷ currentItem = seq[i] # ❸ prevItemIndex = i - 1 # ❹ while prevItemIndex >= 0 and seq[prevItemIndex] > currentItem: # ❺ seq[prevItemIndex + 1] = seq[prevItemIndex] prevItemIndex -= 1 seq[prevItemIndex + 1] = currentItem if __name__ == \"__main__\": lst = [1, 4, 2, 3, 0] insertSort(lst) print(lst) ❶：外层循环从索引1处开始向后遍历，即我们认为有序区默认有1个数据项 ❷：拿到当前的数据项，即有序区最后一个数据项 ❸：拿到有序区前一个数据项的索引，这里就是插入位置，当无序区被遍历数据项小于有序区最后一个数据项，就插入到这里 ❹：条件1：如序列为[1, 2, 3 | 0, 9, 8, 10]，0如果想要插入1前面，索引就变成了-1，而-1位置是序列中最后位置，这样就会插入失败，故该条件确保不会出现负向索引 条件2：规定什么时候进行插入，当然是被遍历的无序区数据项小于有序区最后一个数据项时才进行插入 ❺：寻找插入位置 希尔排序 希尔排序（Shell Sort）是插入排序的一种，它是针对直接插入排序算法的改进。 希尔排序又称缩小增量排序，因 DL.Shell 于 1959 年提出而得名。 它通过比较相距一定间隔的数据项来进行，各趟比较所用的距离随着算法的进行而减小，直到只比较相邻数据项的最后一趟排序为止，是首次突破O(n²)的排序算法。 该算法对于中等规模的数据集非常有效，因为该算法的平均和最坏情况复杂度取决于间隙序列，最著名的是 Ο(n)，其中 n 是项目的数量。最坏情况下的空间复杂度是 O(n)。 首先，我们有一个长度为8的序列，我们需要对其 // 2，得到一个值是4，这个值叫做gap值。 现在，我们将整个序列分为4组，如下图所示，35和14为一组，中间的间隔是4，33和19是一组，中间的间隔也是4，依次类推： 然后我们对这4组中的元素进行插入排序，非常简单，下图是排序完成后的样子： 上次得到的gap值是4，我们再将它 // 2，得到新的gap值，为2。 老规矩，将整个序列分为2组，如下图所示： 然后，再将这2组中的元素进行插入排序，下图是排序完成之后的样子： 上次的gap值是2，我们再将它 // 2，得到结果是1，继续对这1组进行插入排序，如下图所示： 代码及注释如下： def shellSort(seq): # ❶ currentGap = len(seq) // 2 # ❷ while currentGap >= 1: # ❸ for startPosition in range(currentGap): gapInsertSort(seq, startPosition, currentGap) print(\"after increments of size %s, the sequence is %s\" % (currentGap, seq)) # ❹ currentGap //= 2 def gapInsertSort(seq, start, gap): # ❺ for i in range(start + gap, len(seq), gap): currentItem = seq[i] position = i while position >= gap and seq[position - gap] > currentItem: seq[position] = seq[position - gap] position = position - gap seq[position] = currentItem if __name__ == \"__main__\": lst = [35, 33, 42, 10, 14, 19, 27, 44] shellSort(lst) print(lst) ❶：获取gap值，后续会根据gap值进行分组 ❷：死循环，直至所有组都排序完毕 ❸：循环，开始进行插入排序 ❹：插入排序完毕后，重新进行分组，更新gap值 ❺：start + gap是当前需要插排的分组，len(seq)是整体序列长度， gap是跳过的步数，也就是不同的分组，至此开始每一轮的插入排序 归并排序 归并排序（Merge Sort）是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。 归并排序会不断的将序列 // 2，直至每个序列仅包含1个数据项，然后再将小序列排序并合并成大序列。 归并排序是一种基于分治技术的排序技术，最坏情况的时间复杂度为 Ο(n log n)，它是最受尊敬的算法之一。 首先，下面是一个未经历排序的长度为8的序列： 我们不断的将它拆分，直至每个序列中仅有1个数据项： 然后开始进行子序列合并，通过不断的对比每个子序列中的数据项，最终将它们合并成1个大的序列： 代码及注释如下： def mergeSort(seq): # ❶ if len(seq) > 1: mid = len(seq) // 2 leftSeq, rightSeq = seq[:mid], seq[mid:] mergeSort(leftSeq) mergeSort(rightSeq) # ❷ i = j = k = 0 while i ❶：不断的对序列进行拆分，直至每个序列中仅有1个数据项 ❷：开始进行排序、对比、合并，i 是左侧序列索引值，j是右侧序列索引值，k是整个大序列索引值 ❸：如果左序列被遍历数据项小于右序列被遍历数据项，则整体大序列中左序列数据项排列在前面 如：leftSeq = [0]， rightSeq = [1]， 则大的seq = [0 , 1] ❹：如果右序列被遍历数据项小于左序列被遍历数据项，则整体大序列中右序列数据项排列在前面 如：leftSeq = [1]， rightSeq = [0]， 则大的seq = [0 , 0] ❺：针对❹的情况，要将大seq的[0, 0]变为[0, 1]，因为❹的时候 i 没有 + 1，总之最后要保证：i = 1, j = 1, k = 2 ❻：针对❸的情况，因为❸的时候 j 没有 + 1，总之最后要保证：i = 1, j = 1, k = 2 快速排序 快速排序（Quick Sort）最大的特点就是快，使用分治法进行实现。 它的算法步骤是在一个序列中选定任意一个值，作为基准（pivot），然后使用2个指针，从序列的左侧与右侧一起进行数据项检测，每检测1步2个指针距离更进一步。 左侧指针用于将比基准值小的数据项排在左侧 右侧指针用于将比基准值大的数据项排在右侧 当2个指针重合时代表一趟排序完成，如此排列一轮整个序列就分为了2组，左侧比基准小（左侧各个序列数据项之间也大概率无序），右侧比基准大（右侧各个序列数据项之间也大概率无序）。 再次重复以上的步骤，对左侧或者右侧的列表重新定义基准值，再次进行挑选，直至最后划分为无数个长度为1的小序列时，排序完成。 该算法对于大型数据集非常有效，因为其平均复杂度和最坏情况复杂度分别为O(n log n) 和 O(n² )。 可能动图演示太快了，我们使用图解的形式： 第一趟的基准值是6（随机的）： 接下来继续第2倘，重新定义基准值为3（随机的），重复上面的步骤。 代码及注释如下： def quickSort(seq): def innerQuickSort(seq, left, right): if left left and seq[right] >= pivot: right -= 1 seq[left] = seq[right] # ❸ while left ❶：定义基准值，pivot ❷：右侧指针与左侧指针没有重合，且右侧指针数据项大于基准值则右侧指针左移一位 ❸：左侧指针与右侧指针没有重合，且左侧指针数据项小于基准值则左侧指针右移一位 ❹：重新定义基准值，本倘遍历完成 此时还可能会出现一个最坏情况： 由于pivot我们总是选择在了首位，如果出现传入一个已经有序（升序）的列表，就会发生最坏情况。 反之，如果pivot总是选择在末位，如果出现传入一个已经有序（降序）的列表，也会发生最坏的情况。 最坏情况下，时间复杂度将退化O(n²)，加上递归的开销可能比冒泡排序还要慢一点，解决方案是将pivot选择为一个随机位置，如中间。 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-20 19:37:28 "},"Python/Python数算基础/数构之树相关.html":{"url":"Python/Python数算基础/数构之树相关.html","title":"数构之树相关","keywords":"","body":"树的知识 什么是树 树是一种基本的非线性数据结构，在操作系统、图形学、数据库系统、计算机网络等领域被广泛使用。 跟自然界中的树一样，数据结构树也分为：根、枝、叶三个部分，一般数据结构的图示会把根放在上方，叶放在下方，就像一颗倒置的树，如下示例： 相关术语 节点(node) 节点是组成树的基本部分，每个节点具有不同的名称或“键值”属性。 除此之外，节点还可以保存额外数据项，数据项根据不同的应用而变化。 边(edge) 边是组成树的另一个基本部分，每条边恰好连接两个节点，表示节点之间具有关联。 除此之外，边还具有出入方向： 每个节点（除根节点）恰好有一条来自另一节点的入边。 每个节点可以有多条连到其它节点的出边。 根(root) 根是树中唯一一个没有入边的节点，即最顶端的节点。 路径(path) 路径是由边依次连接在一起的节点组成的有序列表，如：HTML->BODY->UL->LI就是一条路径。 子节点(children) 入边均来自于同一个节点的若干节点，称为这个节点的子节点。 父节点(parent) 一个节点是其所有出边所连接节点的父节点。 兄弟节点(sibling) 具有同一个父节点的节点之间称为兄弟节点. 子树(subtree) 子树是一个节点和其所有子孙节点，以及相关边的集合。 一个树中有多个子树，每个子树是独立的一颗树。 叶子节点(leaf) 没有子节点的节点称为叶节点。 层级(level) 根节点开始到达一个节点的路径，所包含的边的数量，称为这个节点的层级。 Root从0开始计数，也可以从1开始计数： 高度(height) 树中所有节点的最大层级称为树的高度。 如下图树的高度为2： 度(degree) 一个枝的度代表它有几条出边，而一颗树的度则取决于树中节点的最大度。 如，一颗树中最大的度为2，这可树可被称为二叉树，除此之外还有三叉、四叉树等结构。 如下图，这是一颗三叉树： 认识二叉树 普通二叉树 普通的二叉树没什么要求，树的最大度为2即可。 完全二叉树 在完全二叉树中，枝节点必须全部是满的，叶子节点可以不满。 但是新的节点添加时必须从左至右依次添加，不能先添加右边后添加左边。 平衡二叉树 树的左右子树高度差不超过1的树被称为平衡二叉树，空树也是平衡二叉树的一种。 满二叉树 满二叉树的意思就是无论是枝节点还是叶子节点，必须全部都是满的。 二叉树表示 列表表示法 在Python中，我们可以使用多维的列表来表示一颗不确定度的多叉树。 这样的做法有一个好处，每一个列表都是一颗子树，索引值1是左子树，索引值2是右子树。 同时，如果要增加某个节点的度，则向其添加一个空列表即可。 如上述这幅图的二叉树，则可以向下面这样进行表示： 第1个元素为根节点的值 第2个元素是左子树（所以也是一个列表） 第3个元素是右子树（所以也是一个列表） [root, [left], [right]] ----------------------- 0 1 2 如下所示： myTree = \\ [ \"a\", [\"b\", [\"d\", [], []], [\"e\", [], []] ], [\"c\", [\"f\"] ] ] 拿到第二层的叶子节点f： print(myTree[2][1]) 节点表示法 使用节点表示法，能够更加清晰的管理树，这比列表表示法通常更加省力。 如下图所示： 以下是代码实现上图中二叉树的表现： class BinaryTree: def __init__(self, root): self.key = root self.leftChild = None self.rightChild = None self.height = 0 def insertLeft(self, newNode): tree = BinaryTree(newNode) if not self.leftChild: self.leftChild = tree else: # 如果插入位置已有节点，则整体向下挪 # 新的子节点与旧的子节点链接，旧的父节点与新的子节点链接 tree.leftChild = self.leftChild self.leftChild = tree self.height += 1 def insertRight(self, newNode): tree = BinaryTree(newNode) if not self.rightChild: self.rightChild = tree else: tree.rightChild = self.rightChild self.rightChild = tree self.height += 1 def getRightChild(self): return self.rightChild def getLeftChild(self): return self.leftChild def setRootVal(self, obj): self.key = obj def getRootVal(self): return self.key if __name__ == '__main__': binaryTree = BinaryTree(\"a\") binaryTree.insertLeft(\"b\") binaryTree.insertRight(\"c\") binaryTree.leftChild.insertLeft(\"d\") binaryTree.leftChild.insertRight(\"e\") binaryTree.rightChild.insertLeft(\"f\") 二叉树遍历 将一颗二叉树依次排开，如下所示： 根节点在中间 左节点在左边 右节点在右边 那么就会有不同的4种遍历规则。 前序遍历（preorder） 中序遍历（inorder） 后序遍历（postorder） 层级遍历（levelorder） 我们可以在BinaryTree中新增几个实例方法，用来书写不同的遍历代码： class BinaryTree: ... def preOrder(self): pass def inOrder(self): pass def postOrder(self): pass def levelOrder(self): pass 前序遍历(pre order) 前序遍历规则如下： 首先访问根节点 前序访问左子树 前序访问右子树 一句话总结：中左右 遍历顺序： 代码实现： def preOrder(self): def inner(tree): if tree: print(tree.getRootVal()) inner(tree.getLeftChild()) inner(tree.getRightChild()) inner(self) 中序遍历(in order) 中序遍历规则如下： 中序访问左子树 然后访问根节点 中序访问右子树 一句话总结：左中右 遍历顺序： 代码实现： def inOrder(self): def inner(tree): if tree: inner(tree.getLeftChild()) print(tree.getRootVal()) inner(tree.getRightChild()) inner(self) 后序遍历(post order) 后序遍历规则如下： 后序访问左子树 后序访问右子树 最后访问根节点 一句话总结：左右中 遍历顺序： 代码实现： def postOrder(self): def inner(tree): if tree: inner(tree.getLeftChild()) inner(tree.getRightChild()) print(tree.getRootVal()) inner(self) 层级遍历(level order) 层级遍历没什么好说的，按层访问： 第0层、根 第1层、左、右 …第n层、左、右 遍历顺序： 代码实现，需要借助一个双端队列或者列表： def levelOrder(self): def inner(tree): treeLst = [] treeLst.append(tree) while len(treeLst) > 0: node = treeLst.pop(0) print(node.getRootVal()) if node.leftChild: treeLst.append(node.getLeftChild()) if node.rightChild: treeLst.append(node.getRightChild()) inner(self) 根据遍历画出树 如果给出你2个遍历结果，并且指明这棵树是二叉树，如何画出这棵树的结构？ 前序遍历顺序是 A B C D E F G 中序遍历顺序是 C B D A F E G 首先，前序遍历是中左右，中序遍历是左中右，按照下面的结构开始进行结构划分： 前序： [A] [B C D] [E F G] 中序： [C B D] [A] [F E G] 划分完成之后就可以出图了： 二叉堆 什么是二叉堆 二叉堆是二叉树的一种特殊结构，二叉堆必须是完全二叉树或者近似完全二叉树，可分为大根堆和小根堆。 小根堆（小顶堆）：任意一个节点都比其孩子节点小 大根堆（大顶堆）：任意一个节点都比其孩子节点大 图示如下： 二叉堆的表示 使用列表来表示二叉堆的时候，不需要利用多维列表，单纯的一维列表足以。 因为二叉堆必须是完全二叉树或者近似完全二叉树，所以整个树是平衡的，可以用列表来进行表示。 [1, 2, 3, 4, 5, 6, 7] 如果要查找任意节点的左子节点与右子节点，可以使用 2p 与 2p+1 来查找，如果想查找其父节点，可以使用 n // 2 的方式。 如上述列表表示了一个小根堆，我们要寻找3的左子节点与右子节点及父节点，流程如下： Node 3 Position: 3 # 不要按照索引计算，正确计算是索引值+1 Left Child Node Position: 3 * 2 = 6 Right Child Node Position: 3 * 2 + 1 = 7 Parent Node Position: 3 // 2 = 1 堆排序(Heap Sort) 由于堆只有大根堆和小根堆，为了满足其中的特性，我们必须将一些节点进行值的比对然后上浮或者下沉。 如下图所示，展示了一个大根堆的排序过程： 时间复杂度为O(n log n)，空间复杂度为O(1)。 实现思路： 构造初始堆，将给定无序序列构造成一个大根堆（排序时一般大根堆为升序，小根堆为降序） 将堆顶元素与末尾元素进行交换，使末尾元素最大。然后继续调整堆，再将堆顶元素与末尾元素交换，得到第二大元素； 重新调整结构，使其满足堆定义，然后继续交换堆顶元素与当前末尾元素； 如此反复进行交换、重建、交换，直到整个序列有序。 代码实现如下，这是一个大根堆： def build(seq, root, end): while True: # 左子节点的位置 child = 2 * root + 1 # 若左子节点超过了最后一个节点，则终止循环 if child > end: break # 若右子节点在最后一个节点之前，并且右子节点比左子节点大，则我们的孩子指针移到右子节点上 if (child + 1 seq[child]): child += 1 # 若最大的孩子节点大于根节点，则交换两者顺序，并且将根节点指针，移到这个孩子节点上 if seq[child] > seq[root]: seq[child], seq[root] = seq[root], seq[child] root = child else: break def heapSort(seq): n = len(seq) # 确认最深最后的那个根节点的位置 first_root = n // 2 - 1 # 由后向前遍历所有的根节点，建堆并进行调整 for root in range(first_root, -1, -1): build(seq, root, n - 1) # 调整完成后，将堆顶的根节点与堆内最后一个元素调换位置，此时为数组中最大的元素，然后重新调整堆，将最大的元素冒到堆顶。依次重复上述操作 for end in range(n - 1, 0, -1): seq[0], seq[end] = seq[end], seq[0] build(seq, 0, end - 1) if __name__ == '__main__': lst = [7, 3, 2, 4, 1, 5] heapSort(lst) print(lst) ADT BinHeap 如果要使用Python来进行二叉堆实现，同时应当提供以下方法。 这样做的好处是所有的入堆出堆操作时间复杂度均为O(n log n)，我们可以用二叉堆来模拟实现类似优先级队列的数据结构。 方法名 描述 BinaryHeap() 一个类，用于构建一个空的二叉堆对象 insert() 将新key加入到堆中 findMin() 返回堆中的最小项，最小项仍保留在堆中，堆本身不会改变 delMin() 返回堆中的最小项，同时从堆中删除，堆本身会改变 isEmpty() 返回堆是否为空 size() 返回堆中key的个数 buildHeap() 从一个key列表创建新堆 现在准备实现一个小根堆，用一个列表来保存堆数据，其中列首下标为0的项无用，但是节点的左右子节点查找是根据 2p 与 2p+1 来计算的，因此我们可以用这个0来做一个占位，使索引与p相同，而不是从0开始计数，所以选择保留它： class BinHeap: def __init__(self): self.heapList = [0] self.currentSize = 0 insert()方法的实现，一定要满足完全二叉树的性质，因此我们可以将新的key添加到列表末尾，同时使用堆排序来将该key上浮或者到合适的位置，实现有序的特性。 def percUp(self, i): # 判断父节点是否存在，由于现在新添加的元素 # 索引+1了，直接进行整除即可 while i // 2 > 0: # 如果新元素小于父节点，则上浮，交换位置 if self.heapList[i] delMin()方法的实现要移走整个堆中最小的key，由于我们实现的是小根堆，所以最小的元素都在堆顶。 如果直接简单粗暴的移走堆顶root，用那个元素来顶替好呢？ 实际上，我们可以采用将堆底，即列表最后一个元素放到堆顶再向下沉的策略来进行该方法的构建。 def percDown(self, i): # 如果没有左子节点，则代表整个列表就1个元素，不是一个堆 # 就不向下执行 while (i * 2) self.heapList[mc]: # 临时保留root节点的元素信息 temp = self.heapList[i] self.heapList[i] = self.heapList[mc] self.heapList[mc] = temp i = mc def minChild(self, i): # 先判断右子节点，是否大于当前的堆顶元素 if i * 2 + 1 > self.currentSize: return i * 2 # 不大于 else: # 判断左子节点，是否小于右子节点 if self.heapList[i * 2] 其他方法的实现： def buildHeap(self, li): # 一颗树的总长度+1整除2，会得到该树的root节点+枝节点 # 忽略掉了叶子节点 i = len(li) // 2 # 重新定义长度 self.currentSize = len(li) # 重新赋值 self.heapList = [0] + li # 从最后一个元素开始，进行排序 while i > 0: self.percDown(i) i -= 1 def findMin(self): return self.heapList[1] def isEmpty(self): return not self.heapList def size(self): return self.__len__() def __len__(self): return len(self.heapList) - 1 def __str__(self): return str(self.heapList[1:]) def __contains__(self, item): return item in self.heapList 完整代码： class BinHeap: def __init__(self): self.heapList = [0] self.currentSize = 0 def percUp(self, i): # 判断父节点是否存在，由于现在新添加的元素 # 索引+1了，直接进行整除即可 while i // 2 > 0: # 如果新元素小于父节点，则上浮，交换位置 if self.heapList[i] self.heapList[mc]: # 临时保留root节点的元素信息 temp = self.heapList[i] self.heapList[i] = self.heapList[mc] self.heapList[mc] = temp i = mc def minChild(self, i): # 先判断右子节点，是否大于当前的堆顶元素 if i * 2 + 1 > self.currentSize: return i * 2 # 不大于 else: # 判断左子节点，是否小于右子节点 if self.heapList[i * 2] 0: self.percDown(i) i -= 1 def findMin(self): return self.heapList[1] def isEmpty(self): return not self.heapList def size(self): return self.__len__() def __len__(self): return len(self.heapList) - 1 def __str__(self): return str(self.heapList[1:]) def __contains__(self, item): return item in self.heapList if __name__ == '__main__': bHeap = BinHeap() for i in range(5, 12): bHeap.insert(i) bHeap.insert(4) print(bHeap) bHeap.delMin() print(bHeap) print(bHeap.isEmpty()) print(bHeap.size()) 二叉查找树 在前面的章节中，我们已经介绍了基于线性数据结构+二分查找法的查找方式，以及使用HashMap做定点查找的方式。 现在，将介绍一种基于二叉树的查找方式，名为二叉查找树或二叉搜索树Binary Search Tree。 BinarySearchTree有一个性质，即比父节点小的key都出现在左子树，比父节点大的key都出现在右子树。 在插入时，也一样会经过上浮下沉的步骤，如果按照70,31,93,94,14,23,73的顺序插入： 首先插入的70成为树根 31比70小，放到左子节点 93比70大，放到右子节点 94比93大，放到右子节点 14比31小，放到左子节点 23比14大，放到右子节点 73比93小，放到左子节点 若插入顺序如果不同，则生成的BinarySearchTree也会不同。 Python实现BinarySearch树 如果要使用Python来进行二叉查找树的实现，同时应当提供以下方法： 方法名 描述 BinarySearchTree() 一个类，用于构建一个空的二叉查找树对象 put() 将key-val关联对加入至BinarySearchTree中，如果key已存在，则将val进行更新 get() 指定key，返回val，如val不存在，则返回None del 通过 del BinarySearchTree[key]的语句形式删除一组键值对 len() 返回BinarySearchTree中键值对的数量 in 支持成员运算符的应用 为了实现二叉查找树，我们可以用2个类，BinarySearchTree以及TreeNode。 一个用来构建树的结构，一个用来生成树的节点。 BinarySearchTree类的root成员引用根节点的TreeNode，以下是基本方法： class BinarySearchTree: def __init__(self): self.root = None self.size = 0 def length(self): return self.size def __len__(self): return self.size 下面是节点类的基本方法： class TreeNode: def __init__(self, key, val, left=None, right=None, parent=None): self.key = key self.payload = val self.leftChild = left self.rightChild = right self.parent = parent def getLeftChild(self): \"\"\"返回左子节点\"\"\" return self.leftChild def getRightChild(self): \"\"\"返回右子节点\"\"\" return self.rightChild def isLeftChild(self): \"\"\"判断当前节点是否是左节点\"\"\" return self.parent and \\ self.parent.leftChild == self def isRightChild(self): \"\"\"判断当前节点是否是右节点\"\"\" return self.parent and \\ self.parent.rightChild == self def isRoot(self): \"\"\"判断当前节点是否是根节点，根节点无父节点\"\"\" return not self.parent def isLeaf(self): \"\"\"判断当前节点是否是叶子节点\"\"\" return not (self.rightChild or self.leftChild) def hasAnyChildren(self): \"\"\"判断当前节点是否含有任意的子节点\"\"\" return self.rightChild or self.leftChild def hasBothChildren(self): \"\"\"判断当前节点是否含有左子节点和右子节点\"\"\" return self.rightChild and self.leftChild def replaceNodeDate(self, key, value, lc, rc): \"\"\"替换当前节点\"\"\" self.key = key self.payload = value self.leftChild = lc self.rightChild = rc if self.getLeftChild(): self.leftChild.parent = self if self.getRightChild(): self.rightChild.parent = self 当所有的基本方法都齐全后，开始构建put()方法。 put() put()方法是BinarySearchTree的一个实例方法，该方法将检测树是否已有根，若没有根那么put()方法将创建一个新的TreeNode实例并将其作为BinarySearchTree的根，如果根节点已就位，则put()方法将调用私有的递归辅助函数_put()方法，它将根据以下算法进行树的搜索： 从树的根开始，搜索二叉树，将新键与当前节点中的键进行比较。如果新键小于当前节点，则搜索左子树。如果新键大于当前节点，则搜索右子树。 当没有左（或右）孩子要搜索时，我们在树中找到应该建立新节点的位置。 以下是代码实现： def put(self, key, val): # 如果存在root节点，则下沉开始寻找插入位置 if self.root: self._put(key, val, self.root) else: self.root = TreeNode(key, val) self.size += 1 def _put(self, key, val, currentNode): # 如果新key小于root，则准备在左子树中寻找插入位置 if key 顺带将索引赋值也做上： def __setitem__(self, key, value): self.put(key,value) get() put()方法构建完毕后，让我们接着构建get()方法。 gut()方法是BinarySearchTree的一个实例方法，它与put()方法类似，同样也有一个私有的递归辅助函数_get()方法来进行递归检测，大体流程如下： 首先判断该树有没有根，若没有根则直接返回None 如果有根，则判断要查找的key是否等于root，如果相等直接返回，如果小于则往左子树递归查找，反之则往右子树递归查找，若都找不到则返回None 以下是代码实现： def get(self, key): if self.root: res = self._get(key, self.root) if res: return res.payload else: return None else: return None def _get(self, key, currentNode): # 查找到叶子节点都没找到，返回None if not currentNode: return None # 判断是否等于当前Node的key elif currentNode.key == key: return currentNode # 如果小于，递归遍历左子树 elif key 顺带着，由于实现了get()方法，我们也可以将BinarySearchTree的掌管成员运算符in的\\_contains__()一起实现，代码如下： def __contains__(self, key): if self._get(key, self.root): return True else: return False __iter__() 当get()方法构建完毕后，下一步要构建迭代器了，只需要实现__iter__()方法即可。 将BinarySearchTree中的__iter__()调用至TreeNode中的__iter__()方法即可： # BinarySearchTree def __iter__(self): return self.root.__iter__() # TreeNode def __iter__(self): \"\"\"采用中序遍历\"\"\" if self: if self.getLeftChild(): for ele in self.leftChild: yield ele yield self.key if self.getRightChild(): for ele in self.rightChild: yield ele delete() 现在简单的方法都构建完毕了，最难的就属delete()方法，它包含2层，1层是找节点、2层是删节点。 为了使程序更加解耦，我们用delete()作为2个方法的代理，负责调度_get()方法来找节点与remove()方法来删节点，当然remove()方法暂时还没有实现。 在delete()方法中，大体思路如下： 如果这个树的长度大于1，则说明有节点，调用_get()方法开始从root节点向后查找，找得到就将其设置为None，找不得则抛出异常 如果这个树的长度为1，则说明只有一个root节点，此时判定root节点是否是我们需要找的节点，找得到就将root节点设为None，找不得就删除 代码实现如下： def delete(self,key): if self.size > 1: nodeToRemove = self._get(key,self.root) if nodeToRemove: self.remove(nodeToRemove) self.size -= 1 else: raise KeyError(\"Error, key not in tree\") elif self.size == 1 and self.root.key == key: self.root = None self.size -= 1 else: raise KeyError(\"Error, key not in tree\") def __delitem__(self, key): self.delete(key) 如果找到了节点，就需要执行remove()方法对其进行删除，但是remove()方法还未实现，我们需要提前对其做一些规划。为了保持整颗二叉查找树的性质，删节点时要对以下3种情形做出分别不同的处理： 将要被删除的节点是一个叶子节点（没有任何子节点） 将要被删除的节点有1个子节点 将要被删除的节点有2个子节点 没有子节点的第1种情况最好办，直接删除即可： def remove(self, currentNode): # 第一种情况：如果被删除节点是叶子节点 if currentNode.isLeaf(): # 判断是左叶子还是右叶子，将其置为None if currentNode == currentNode.parent.leftChild: currentNode.parent.leftChild = None else: currentNode.parent.rightChild = None 第2种情况稍微复杂，被删节点有1个子节点，我们需要将这个唯一的子节点上移，替换掉被删节点的位置。 但是在替换操作的时候，又要区分几种情况，如下所示： 被删节点的子节点是左？还是右子节点？ 被删节点本身是其父节点的左？还是右子节点？ 被删节点本身就是根节点？ 解决策略如下： 如果当前被删节点是左子节点，则我们只需要更新左子节点的父引用以指向当前节点的父节点，然后更新父节点的左子节点引用以指向当前节点的左子节点 如果当前被删节点是右子节点，则我们只需要更新左子节点的父引用以指向当前节点的父节点，然后更新父节点的右子节点引用以指向当前节点的左子节点 如果当前被删节点没有父级，则它是根。在这种情况下，我们将通过在根上调用replaceNodeData() 方法来替换 key，payload，leftChild和rightChild的数据。 说了这么多，还不如看代码实际，先写个else，来处理第二种情况，因为我们无法保证该节点只有1个子节点，所以将这个情况放在第三种情形下面即可，（将要被删除的节点有2个子节点）： def remove(self, currentNode): # 第一种情况：如果被删除节点是叶子节点 if currentNode.isLeaf(): # 判断是左叶子还是右叶子，将其置为None if currentNode == currentNode.parent.leftChild: currentNode.parent.leftChild = None else: currentNode.parent.rightChild = None # 第三种情况：如果被删除节点有2个子节点 elif currentNode.hasBothChildren(): pass # 第二种情况：如果被删除的节点有1个子节点 else: # 如果被删除的节点的1个子节点是左子节点 if currentNode.getLeftChild(): # 如果被删除的节点本身是左节点 if currentNode.isLeftChild(): # 爸爸死了，让左儿子的爷爷做左儿子的监护人 currentNode.leftChild.parent = currentNode.parent # 爷爷的左儿子死了，爷爷让左孙子顶替左儿子的位置 currentNode.parent.leftChild = currentNode.leftChild # 如果被删除的节点本身是右节点 elif currentNode.isRightChild(): # 爸爸死了，让左儿子的爷爷做左儿子的监护人 currentNode.leftChild.parent = currentNode.parent # 爷爷的右儿子死了，爷爷让左孙子顶替右儿子的位置 currentNode.parent.rightChild = currentNode.leftChild # 如果被删除的节点本身是根节点 else: # 爸爸死了儿子顶上 currentNode.replaceNodeData(currentNode.leftChild.key, currentNode.leftChild.payload, currentNode.leftChild.leftChild, currentNode.leftChild.rightChild) # 如果被删除的节点的1个子节点是右子节点 else: # 如果被删除的节点本身是左节点 if currentNode.isLeftChild(): # 爸爸死了，让右儿子的爷爷做右儿子的监护人 currentNode.rightChild.parent = currentNode.parent # 爷爷的左儿子死了，爷爷让右孙子顶替左儿子的位置 currentNode.parent.leftChild = currentNode.rightChild # 如果被删除的节点本身是右节点 elif currentNode.isRightChild(): # 爸爸死了，让右儿子的爷爷做右儿子的监护人 currentNode.rightChild.parent = currentNode.parent # 爷爷的右儿子死了，爷爷让右孙子顶替右儿子的位置 currentNode.parent.rightChild = currentNode.rightChild # 如果被删除的节点本身是根节点 else: # 爸爸死了儿子顶上 currentNode.replaceNodeData(currentNode.rightChild.key, currentNode.rightChild.payload, currentNode.rightChild.leftChild, currentNode.rightChild.rightChild) 第3种情形最复杂，即被删节点有2个子节点。 这时无法简单地将某个子节点上移替换被删节点但可以找到另一个合适的节点来替换被删节点，这个合适节点就是被删节点的下一个key值节点，即被删节点右子树中最小的那个，称为后继。 可以肯定这个后继节点最多只有1个子节点（本身是叶节点，或仅有右子树）将这个后继节点摘出来，替换掉被删节点。 继续补全remove()中第二个条件的代码，我们可以发现下面有一个寻找后继的函数findSuccessor()与进行切分的函数spliceOut()。 # 第三种情况：如果被删除节点有2个子节点 elif currentNode.hasBothChildren(): succ = currentNode.findSuccessor() succ.spliceOut() # 使用后继节点替换掉当前节点信息 currentNode.key = succ.key currentNode.payload = succ.payload 这三个方法要书写到TreeNode类中： def findSuccessor(self): \"\"\" 寻找后继 self:将要被删除的节点 \"\"\" succ = None if self.getRightChild(): succ = self.rightChild.findMin() else: if self.parent: if self.isLeftChild(): succ = self.parent else: self.parent.rightChild = None succ = self.parent.findSuccessor() self.parent.rightChild = self return succ def spliceOut(self): if self.isLeaf(): if self.isLeftChild(): self.parent.leftChild = None else: self.parent.rightChild = None elif self.hasAnyChildren(): if self.getLeftChild(): if self.isLeftChild(): self.parent.leftChild = self.leftChild else: self.parent.rightChild = self.leftChild self.leftChild.parent = self.parent else: if self.isLeftChild(): self.parent.leftChild = self.rightChild else: self.parent.rightChild = self.rightChild self.rightChild.parent = self.parent def findMin(self): \"\"\"寻找最小值，self是当前将要被删除节点的右子节点\"\"\" current = self # 判断当前节点是否有左子节点，有就一直往下找 while current.getLeftChild(): current = current.leftChild # 直到找到将要被删除节点的右子节点下的最左侧节点 return current 完整代码 完整及测试代码如下： #! /usr/local/bin/python3 # -*- coding:utf-8 -*- class BinarySearchTree: def __init__(self): self.root = None self.size = 0 def length(self): return self.size def __len__(self): return self.size def __iter__(self): return self.root.__iter__() def put(self, key, val): if self.root: self._put(key, val, self.root) else: self.root = TreeNode(key, val) self.size += 1 def _put(self, key, val, currentNode): # 如果新key小于root，则准备在左子树中寻找插入位置 if key 1: nodeToRemove = self._get(key, self.root) if nodeToRemove: self.remove(nodeToRemove) self.size -= 1 else: raise KeyError(\"Error, key not in tree\") elif self.size == 1 and self.root.key == key: self.root = None self.size -= 1 else: raise KeyError(\"Error, key not in tree\") def __delitem__(self, key): self.delete(key) def remove(self, currentNode): # 第一种情况：如果被删除节点是叶子节点 if currentNode.isLeaf(): # 判断是左叶子还是右叶子，将其置为None if currentNode == currentNode.parent.leftChild: currentNode.parent.leftChild = None else: currentNode.parent.rightChild = None # 第三种情况：如果被删除节点有2个子节点 elif currentNode.hasBothChildren(): succ = currentNode.findSuccessor() succ.spliceOut() # 使用后继节点替换掉当前节点信息 currentNode.key = succ.key currentNode.payload = succ.payload # 第二种情况：如果被删除的节点有1个子节点 else: # 如果被删除的节点的1个子节点是左子节点 if currentNode.getLeftChild(): # 如果被删除的节点本身是左节点 if currentNode.isLeftChild(): # 爸爸死了，让左儿子的爷爷做左儿子的监护人 currentNode.leftChild.parent = currentNode.parent # 爷爷的左儿子死了，爷爷让左孙子顶替左儿子的位置 currentNode.parent.leftChild = currentNode.leftChild # 如果被删除的节点本身是右节点 elif currentNode.isRightChild(): # 爸爸死了，让左儿子的爷爷做左儿子的监护人 currentNode.leftChild.parent = currentNode.parent # 爷爷的右儿子死了，爷爷让左孙子顶替右儿子的位置 currentNode.parent.rightChild = currentNode.leftChild # 如果被删除的节点本身是根节点 else: # 爸爸死了儿子顶上 currentNode.replaceNodeData(currentNode.leftChild.key, currentNode.leftChild.payload, currentNode.leftChild.leftChild, currentNode.leftChild.rightChild) # 如果被删除的节点的1个子节点是右子节点 else: # 如果被删除的节点本身是左节点 if currentNode.isLeftChild(): # 爸爸死了，让右儿子的爷爷做右儿子的监护人 currentNode.rightChild.parent = currentNode.parent # 爷爷的左儿子死了，爷爷让右孙子顶替左儿子的位置 currentNode.parent.leftChild = currentNode.rightChild # 如果被删除的节点本身是右节点 elif currentNode.isRightChild(): # 爸爸死了，让右儿子的爷爷做右儿子的监护人 currentNode.rightChild.parent = currentNode.parent # 爷爷的右儿子死了，爷爷让右孙子顶替右儿子的位置 currentNode.parent.rightChild = currentNode.rightChild # 如果被删除的节点本身是根节点 else: # 爸爸死了儿子顶上 currentNode.replaceNodeData(currentNode.rightChild.key, currentNode.rightChild.payload, currentNode.rightChild.leftChild, currentNode.rightChild.rightChild) class TreeNode: def __init__(self, key, val, left=None, right=None, parent=None): self.key = key self.payload = val self.leftChild = left self.rightChild = right self.parent = parent def getLeftChild(self): \"\"\"返回左子节点\"\"\" return self.leftChild def getRightChild(self): \"\"\"返回右子节点\"\"\" return self.rightChild def isLeftChild(self): \"\"\"判断当前节点是否是左节点\"\"\" return self.parent and \\ self.parent.leftChild == self def isRightChild(self): \"\"\"判断当前节点是否是右节点\"\"\" return self.parent and \\ self.parent.rightChild == self def isRoot(self): \"\"\"判断当前节点是否是根节点，根节点无父节点\"\"\" return not self.parent def isLeaf(self): \"\"\"判断当前节点是否是叶子节点\"\"\" return not (self.rightChild or self.leftChild) def hasAnyChildren(self): \"\"\"判断当前节点是否含有任意的子节点\"\"\" return self.rightChild or self.leftChild def hasBothChildren(self): \"\"\"判断当前节点是否含有左子节点和右子节点\"\"\" return self.rightChild and self.leftChild def replaceNodeDate(self, key, value, lc, rc): \"\"\"替换当前节点\"\"\" self.key = key self.payload = value self.leftChild = lc self.rightChild = rc if self.getLeftChild(): self.leftChild.parent = self if self.getRightChild(): self.rightChild.parent = self def __iter__(self): \"\"\"采用中序遍历\"\"\" if self: if self.getLeftChild(): for ele in self.leftChild: yield ele yield self.key if self.getRightChild(): for ele in self.rightChild: yield ele def findSuccessor(self): \"\"\" 寻找后继 self:将要被删除的节点 \"\"\" succ = None if self.getRightChild(): succ = self.rightChild.findMin() else: if self.parent: if self.isLeftChild(): succ = self.parent else: self.parent.rightChild = None succ = self.parent.findSuccessor() self.parent.rightChild = self return succ def spliceOut(self): if self.isLeaf(): if self.isLeftChild(): self.parent.leftChild = None else: self.parent.rightChild = None elif self.hasAnyChildren(): if self.getLeftChild(): if self.isLeftChild(): self.parent.leftChild = self.leftChild else: self.parent.rightChild = self.leftChild self.leftChild.parent = self.parent else: if self.isLeftChild(): self.parent.leftChild = self.rightChild else: self.parent.rightChild = self.rightChild self.rightChild.parent = self.parent def findMin(self): \"\"\"寻找最小值，self是当前将要被删除节点的右子节点\"\"\" current = self # 判断当前节点是否有左子节点，有就一直往下找 while current.getLeftChild(): current = current.leftChild # 直到找到将要被删除节点的右子节点下的最左侧节点 return current if __name__ == '__main__': mytree = BinarySearchTree() mytree[3] = \"red\" mytree[4] = \"blue\" mytree[6] = \"yellow\" mytree[2] = \"at\" del mytree[2] for i in mytree: print(i) 性能分析 上述的二叉搜索树，性能影响最大的是其高度，而其高度又受数据项key插入顺序的影响。 如果key的列表是随机分布的话，那么大于和小于根节点key的键值大致相等。 这样的树就是平衡树，put()方法最差性能为O(log2n)。 如果key的插入的顺序十分极端，如下图所示，那么put()方法的性能就变为了O(n)，其他方法也类似： 如何改进二叉搜索树，让其不受到key插入顺序的影响呢？ 这就涉及到下面要介绍的平衡二叉查找树的知识了。 平衡二叉查找树 AVL树即为平衡二叉树，它能够保证性能不受到key插入顺序的影响。 AVL是发明者的名字缩写：G.M. Adelson-Velskii and E.M. Landis AVL树的实现与基础的BinarySearcTree的实现基本相同，唯一不同之处在于二叉树的生成与维护过程。 平衡因子 AVL树的实现中，需要对每个节点跟踪“平衡因子balancefactor”参数，平衡因子是根据节点的左右子树的高度来定义的，确切地说，是左右子树高度差。 balanceFactor = height(leftSubTree) − height(rightSubTree) 如果平衡因子大于0，称为“左重left-heavy”，小于零称为“右重right-heavy”平衡因子等于0，则称作平衡。 如果一个二叉查找树中每个节点的平衡因子都在-1，0，1之间，则把这个二叉搜索树称为平衡树。 在平衡树操作过程中，有节点的平衡因子超出此范围，则需要一个重新平衡的过程。 也就是说，左子树和右子树的高度差不能超过1，在AVL树实现中只要确保该点即可。 树的自旋 我们只需要在上面的BinarySearchTree中做改进便可完成实现，首先，如果向AVL树插入一个新key，如何才能保持AVL树的平衡性质。 作为BinarySearchTree，新key必定以叶节点形式插入到AVL树中，叶节点的平衡因子是0，其本身无需重新平衡。 但这样做会影响其父节点的平衡因子： 作为左子节点插入，则父节点平衡因子会增加1 作为右子节点插入，则父节点平衡因子会减少1 这种影响可能随着其父节点到根节点的路径一直传递上去，直到传递到根节点为止。 或者某个父节点平衡因子被调整到0，不再影响上层节点的平衡因子为止。 无论从-1或者1调整到0，都不会改变子树高度，如下图所示，左侧的父节点本身平衡因子是1，但是因为加入了新的节点，父节点的平衡因子变为了0，此时不会再往上传递。 AVL树中如何将不平衡因子转为平衡？最主要的手段就是通过旋转，左旋、右旋、先左旋后右旋、先右旋后左旋4种策略。 根据当前树是左重，还是右重来进行不同方向的旋转，同时还需要更新相关父节点的引用，更新旋转后被影响节点的平衡因子。 左旋(LL) 示例1，新插入了C在B的右侧： 叶子节点C的平衡因子为0 从B的角度看这课树，平衡因子是-1，符合AVL树的性质 从A的角度看这课树，平衡因子是-2，已经不符合AVL树的性质，需要进行左旋调整 右旋(RR) 示例2，新插入了A在B的左侧： 叶子节点A的平衡因子为0 从B的角度看这棵树，平衡因子是1，符合AVL树的性质 从A的角度看这棵树，平衡因子是2，已经不符合AVL树的性质，需要进行右旋调整 两次旋转是已经解释过的旋转形式的稍微复杂的版本。为了更好地理解它们，我们应注意旋转时执行的每个动作。让我们首先检查如何执行左右旋转。左右旋转是左旋转与右旋转的组合。 先左后右旋(LR) 一个节点已插入到左子树的右子树中。这使C成为不平衡节点。这种情况下使AVL树执行左右旋转： 我们首先在C的左子树上执行左旋转。这使A成为B的左子树： 节点C仍然不平衡： 现在，我们将树右旋转，使B成为该子树的新根节点。C现在成为其自己的左子树的右子树。 目前，树已平衡： 先右旋后左旋(RL) 一个节点已插入到右子树的左子树中。这使C成为不平衡节点。这种情况下使AVL树执行右左旋转： 首先，我们沿C节点执行右旋转，使C成为其自己的左子树B的右子树。现在，B成为A的右子树。 节点A仍然由于其右子树的右子树而处于不平衡状态，并且需要向左旋转。 通过使B成为子树的新根节点，可以执行向左旋转。A成为其右子树B的左子树。 目前，树已平衡： 代码实现 只需要在BinarySearchTree的代码中做如下修改即可，如下添加了左旋代码，右旋和双向旋转没有添加，感兴趣的朋友可以自行实现： # __init__中新增节点的平衡因子属性： rotRoot.balanceFactor = rotRoot.balanceFactor + 1 - min(0,newRoot.balanceFactor) def _put(self, key, val, currentNode): # 如果新key小于root，则准备在左子树中寻找插入位置 if key 1 or node.balanceFactor 0: self.rotateRight(node.rightChild) self.rotateLeft(node) else: self.rotateLeft(node) elif node.balanceFactor > 0: if node.leftChild.balanceFactor Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-11-11 14:38:18 "},"Python/Python设计模式/summary.html":{"url":"Python/Python设计模式/summary.html","title":"Python设计模式","keywords":"","body":" 设计模式 普通工厂模式 抽象工厂模式 建造者模式 单例模式 原型模式 适配器模式 桥接模式 组合模式 外观模式 代理模式 装饰器模式 享元模式 责任链模式 解释器模式 迭代器模式 观察者模式 中介者模式 访问者模式 备忘录模式 命令模式 状态模式 策略模式 模板模式 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-25 18:00:38 "},"Python/Python设计模式/设计模式.html":{"url":"Python/Python设计模式/设计模式.html","title":"设计模式","keywords":"","body":"设计模式 设计模式与语言无关，是一种通用的解决思路。 是早期的先辈们在实践中总结出的精华，是考虑了封装性、复用性、效率性、可修改性、可一致性等各种因素的高度总结思想。 一个良好的设计模式对整个系统的影响极其重要，能大幅度提升可读性，利于团队项目的继承和扩展。 反之，如果设计的不好，不光是维护麻烦，项目交接等工作也变的难以展开。 GOF 1994 年，由 Erich Gamma、Richard Helm、Ralph Johnson 和 John Vlissides 四人合著出版了一本名为 Design Patterns - Elements of Reusable Object-Oriented Software（中文译名：设计模式 - 可复用的面向对象软件元素）的书，该书首次提到了软件开发中设计模式的概念。 四位作者合称 GOF（四人帮，全拼 Gang of Four）。 他们所提出的设计模式主要是基于以下的面向对象设计原则。 对接口编程而不是对实现编程 优先使用对象组合而不是继承 六大原则 开闭原则(Open Close Principle) 开闭原则的意思是：对扩展开放，对修改关闭。 在程序需要进行拓展的时候，不能去修改原有的代码，必须实现一个热插拔的效果。 简而言之，它是为了使程序的扩展性更好，更易于维护和升级而提出的一种原则。 想要达到这样的效果，我们需要使用接口和抽象基类对实现类进行约束。 一句话表示：不要修改源代码进行扩展，而是在设计之初就做好扩展的打算 里氏代换原则(Liskov Substitution Principle) 里氏代换原则是面向对象设计的基本原则之一。 里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。 LSP 是继承复用的基石，只有当派生类可以替换掉基类，且软件单位的功能不受到影响时，基类才算真正被复用，而派生类也能够在基类的基础上增加新的行为。 里氏代换原则是对开闭原则的补充。实现开闭原则的关键步骤就是抽象化，而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。 一句话表示：一个功能被父类能调用，则子类也必定能被调用，如动物类能够调用吃东西这个功能，则其子类狼、狗、猫等都能够调用吃东西这个功能 依赖倒转原则(Dependence Inversion Principle) 这个原则是开闭原则的基础，具体内容：针对接口编程，依赖于抽象而不依赖于具体。 一句话表示：多使用接口、抽象基类等规范子类行为，使整个项目逻辑仅看接口便能知道它是如何运作的。 接口隔离原则(Interface Segregation Principle) 这个原则的意思是：使用多个隔离的接口，比使用单个接口要好。 它还有另外一个意思是：降低类之间的耦合度。 由此可见，其实设计模式就是从大型软件架构出发、便于升级和维护的软件设计思想，它强调降低依赖，降低耦合。 一句话表示：将各个不同功能之间的接口耦合度降低，尽可能防止链式崩塌，即一个接口出了问题其他接口跟着完蛋 迪米特法则(Demeter Principle) 又称最少知道原则，它是指：一个实体应当尽量少地与其他实体之间发生相互作用，使得系统功能模块相对独立。 一句话表示：一个对象尽量只负责自己的一些行为，而不要涉及其他对象的行为 合成复用原则(Composite Reuse Principle) 合成复用原则是指：尽量使用合成/聚合/组合的方式书写代码，而不是使用继承。 一句话表示：继承是增加耦合性、减少代码量的一种方式，不要随意滥用。 相关分类 常说的设计模式有23种，可分为3大类，其类别分别是： 创建型模式5种 结构型模式7种 行为性模式11种 来源于Design Patterns - Elements of Reusable Object-Oriented Software一书。 而另外有8种设计模式，被分为J2EE模式，更加注重表示层，由Sun Java Center进行鉴定，这里不再进行演示。 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-25 17:31:30 "},"Python/Python设计模式/普通工厂模式.html":{"url":"Python/Python设计模式/普通工厂模式.html","title":"普通工厂模式","keywords":"","body":"普通工厂模式 工厂模式（Factory Pattern）是非常常用的一种模式，主要分为2大部分： 简单工厂模式 工厂方法模式 两者同属普通工厂模式，只是在理念上有一些细微的差异。 该模式属于创建型模式。 简单工厂模式 基本介绍 用户只需关注自身需要一个什么样的产品，而不用将注意力放在如何构建这个产品上。 只要用户构思好了，直接从工厂类的一个指定接口中去拿产品即可。、 特点：对外隐藏，只暴露一个接口，但这个接口可以创建出非常多的用户所需要的产品 案例图示 假如一个用户要买手机，他只需要考虑手机的品牌，型号，颜色等信息，而并不需要关心去那里买的问题，因为在手机城里各式各样的手机都应有尽有。 优缺点 优点： 隐藏对象创建的细节 客户端不需要修改代码 缺点： 违反单一职责原则，将创建逻辑集中到了一个工厂类里 当添加新的产品时，需要修改工厂类的代码，违反了开闭原则 代码实现 用Python实现简单工厂模式： # 定义手机厂商 class BasePhone: def __init__(self, model, color) -> None: self.model = model self.color = color def getInfo(self): return \"A %s mobile phone, the brand is %s, the model is %s\" % (self.color, self.brand, self.model) class SamSung(BasePhone): def __init__(self, model, color) -> None: self.brand = __class__.__name__ super(__class__, self).__init__(model, color) class Apple(BasePhone): def __init__(self, model, color) -> None: self.brand = __class__.__name__ super(__class__, self).__init__(model, color) class HuaWei(BasePhone): def __init__(self, model, color) -> None: self.brand = __class__.__name__ super(__class__, self).__init__(model, color) # 定义工厂 class MobleCity: def shopPhone(self, brand, model, color): brandDict = { \"SamSung\": SamSung, \"Apple\": Apple, \"HuaWei\": HuaWei } cls = brandDict.get(brand) if cls: instance = cls(model, color) return instance raise TypeError(\"no brand : %s\" % brand) if __name__ == \"__main__\": store = MobleCity() iphone_x = store.shopPhone(brand=\"Apple\", model=\"X\", color=\"black\") sumsung_note7 = store.shopPhone( brand=\"SamSung\", model=\"Note 7\", color=\"blue\") huawei_p10 = store.shopPhone(brand=\"HuaWei\", model=\"P10\", color=\"white\") print(iphone_x.getInfo()) print(sumsung_note7.getInfo()) print(huawei_p10.getInfo()) # A black mobile phone, the brand is Apple, the model is X # A blue mobile phone, the brand is SamSung, the model is Note 7 # A white mobile phone, the brand is HuaWei, the model is P10 工厂方法模式 基本介绍 简单工厂模式是将所有产品都放在1个工厂中，而工厂方法模式是每个不同种类的产品都放在一个单独的工厂中。 相较于简单工厂模式来说，设计更加简单一些。 特点：对外隐藏，每个工厂指定暴露一个接口，用于让用户取出该工厂的产品 案例图示 假如一个用户要买手机，他只需要考虑手机的品牌，型号，颜色等信息，并不需要关心手机是怎么造出来的，充分对外隐藏内部实现细节。 只要用户构思好了，就直接到每个手机品牌专卖店去买即可： 乍一看和简单工厂很相似，但是这个是每个手机品牌都有一个自己的专卖店，也就是说代码耦合度降低了。 优缺点 优点： 每个具体产品都对应一个具体的工厂类，当新增产品时不需要修改工厂类代码 隐藏了对象创建的细节 缺点： 每增加一个具体产品类，就必须增加一个相应的具体工厂类 代码实现 用Python实现工厂方法模式： # 定义手机厂商 class BasePhone: def __init__(self, model, color) -> None: self.model = model self.color = color def getInfo(self): return \"A %s mobile phone, the brand is %s, the model is %s\" % (self.color, self.brand, self.model) class SamSung(BasePhone): def __init__(self, model, color) -> None: self.brand = __class__.__name__ super(__class__, self).__init__(model, color) class Apple(BasePhone): def __init__(self, model, color) -> None: self.brand = __class__.__name__ super(__class__, self).__init__(model, color) class HuaWei(BasePhone): def __init__(self, model, color) -> None: self.brand = __class__.__name__ super(__class__, self).__init__(model, color) # 定义工厂 class SamSungStore: def shopPhone(self, model, color): return SamSung(model, color) class AppleStore: def shopPhone(self, model, color): return Apple(model, color) class HuaWeiStore: def shopPhone(self, model, color): return HuaWei(model, color) if __name__ == \"__main__\": samsungStore = SamSungStore() appleStore = AppleStore() huaweiStore = HuaWeiStore() iphone_x = appleStore.shopPhone(model=\"X\", color=\"black\") sumsung_note7 = samsungStore.shopPhone(model=\"Note 7\", color=\"blue\") huawei_p10 = huaweiStore.shopPhone(model=\"P10\", color=\"white\") print(iphone_x.getInfo()) print(sumsung_note7.getInfo()) print(huawei_p10.getInfo()) # A black mobile phone, the brand is Apple, the model is X # A blue mobile phone, the brand is SamSung, the model is Note 7 # A white mobile phone, the brand is HuaWei, the model is P10 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-24 19:35:12 "},"Python/Python设计模式/抽象工厂模式.html":{"url":"Python/Python设计模式/抽象工厂模式.html","title":"抽象工厂模式","keywords":"","body":"基本介绍 抽象工厂模式（Abstract Factory Pattern）在其他普通工厂模式的2个分支基础上，能够控制产品的类型。 该设计模式主要围绕一个超级工厂创建其他工厂。 该超级工厂又称为其他工厂的工厂。 特定：对外隐藏，可搭配普通工厂模式或者工厂方法模式来指定接口，但在此基础上管控了生成产品的零部件来源 该模式属于创建型模式。 案例图示 在普通工厂模式中，造一辆车时如果不对其零部件来源加以控制，可能发现装上了一个不属于该车范畴的配件。 但是在抽象工厂模式下，购车造车时专卖店必须负责车辆配件的来源，如发生假冒伪劣产品必须承担责任，如下图所示： 优缺点 优点： 将客户端与类的具体实现相分离 每个工厂创建了一个完整的产品系列，使得易于交换产品系列 有利于产品的一致性 缺点： 难以支持新种类的抽象产品，扩展困难 代码实现 用Python实现抽象工厂模式： # 零部件厂商 # 生产奔驰轮胎的厂商 class BenzTiresManufacturer: def getInfo(self): return \"Benz make\" # 生产奔驰底盘的厂商 class BenzChassisManufacturer: def getInfo(self): return \"Benz make\" # 生产奔驰其他零部件的厂商 class BenzOtherManufacturer: def getInfo(self): return \"Benz make\" # 品牌厂商 class Benz: def __init__(self, color): self.brandMsg = self.__class__.__name__ self.colorMsg = color self.tiresMsg = None self.chassisMsg = None self.otherMsg = None def build_car(self, tiresManufacturer, chassisManufacturer, otherManufacturer): # 由厂家内部根据指定零件厂商，开始制造零件 self.makeTires(tiresManufacturer) self.makeChassis(chassisManufacturer) self.makeOther(otherManufacturer) def getCar(self): return self def makeTires(self, tiresManufacturer): tires = tiresManufacturer() self.tiresMsg = tires.getInfo() def makeChassis(self, chassisManufacturer): chassis = chassisManufacturer() self.chassisMsg = chassis.getInfo() def makeOther(self, otherManufacturer): other = otherManufacturer() self.otherMsg = other.getInfo() def getInfo(self): return \"brand:%s\\ncolor:%s\\ntires:%s\\nchassis:%s\\nother:%s\\n\" % (self.brandMsg, self.colorMsg, self.tiresMsg, self.chassisMsg, self.otherMsg) # 品牌厂商专卖店 class BenzStore: def buyCar(self, color): # step03：告诉奔驰厂家该车的颜色 self.brand = Benz(color=color) # step04：通知厂家开始造车，专卖店必须要对零部件负责，故此在这里指定 # 轮胎、底盘、其他零件均为奔驰制造 self.brand.build_car( tiresManufacturer=BenzTiresManufacturer, chassisManufacturer=BenzChassisManufacturer, otherManufacturer=BenzChassisManufacturer ) # step05：获取造出来的汽车并返回给用户 return self.brand.getCar() if __name__ == \"__main__\": # step01：实例化出奔驰专卖店 benzStore = BenzStore() # step02：去专卖店买车 benzCar = benzStore.buyCar(\"black\") print(benzCar.getInfo()) # brand:Benz # color:black # tires:Benz make # chassis:Benz make # other:Benz make Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-24 19:34:22 "},"Python/Python设计模式/建造者模式.html":{"url":"Python/Python设计模式/建造者模式.html","title":"建造者模式","keywords":"","body":"基本介绍 建造者模式（Builder Pattern）使用多个简单的对象一步一步构建成一个复杂的对象。 具体内容是将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。 特点：灵活，耦合度低，可自由组合，提供暴露接口使用户不必关心底层的实现，直接调用即可 建造者模式与抽象工厂模式相似，也用来创建复杂的对象。 主要的区别是建造者模式着重一步步构造一个复杂且灵活的对象，而抽象工厂模式着重于同时提供多个系列的产品对象。 该模式属于创建型模式。 案例图示 去肯德基，汉堡、可乐、薯条、炸鸡翅等是不变的，而其组合是经常变化的，生成出所谓的”套餐\"： 优缺点 优点： 隐藏了一个产品的内部结构和装配过程 将构造代码与表示代码分开 可以对构造过程进行更加精细的控制 缺点： 产品必须有共同点，范围有限制 如果内部变化复杂，会有很多的建造类 代码实现 用Python实现建造者模式： # 最终产品 class Product: def __init__(self) -> None: self.hamburger = None self.coke = None def __str__(self) -> str: return \"Product\".center(20, \"=\") + \\ \"\\n\" + (\"hamburger : %s\" % self.hamburger).center(20, \" \") + \\ \"\\n\" + (\"coke : %s\" % self.coke).center(20, \" \") + \\ \"\\n\" + \"=\" * 20 # 套餐组合 # 套餐1（肥牛组合）：牛肉汉堡、可口可乐 class BeefPackage: def __init__(self) -> None: self.product = Product() def buildHamburger(self): self.product.hamburger = \"Beaf Hamburger\" def buildCoke(self): self.product.coke = \"Coca Cola\" # 套餐2(炸鸡套餐) ： 鸡肉汉堡、百事可乐 class ChickenPackage: def __init__(self) -> None: self.product = Product() def buildHamburger(self): self.product.hamburger = \"Chicken Hamburger\" def buildCoke(self): self.product.coke = \"Pepsi Cola\" # 建造者类 class KfcStore: def getProduct(self): package = None choice = input( \"Please Choice Your Package\\na.Beef Package\\nb.Chicken Package\\n>>> \") if choice == \"a\": package = BeefPackage() elif choice == \"b\": package = ChickenPackage() else: raise ValueError(\"don't have package choice %r\" % choice) # 根据选择套餐方案开始建造产品 package.buildHamburger() package.buildCoke() return package.product if __name__ == \"__main__\": kfc = KfcStore() product = kfc.getProduct() print(product) # Please Choice Your Package # a.Beef Package # b.Chicken Package # >>> b # ======Product======= # hamburger : Chicken Hamburger # coke : Pepsi Cola # ==================== Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-24 19:35:06 "},"Python/Python设计模式/单例模式.html":{"url":"Python/Python设计模式/单例模式.html","title":"单例模式","keywords":"","body":"基本介绍 单例模式（Singleton Pattern）即一个类只能拥有一个实例对象，实例化多次的结果都会指向同一个对象。 特点：全局唯一，允许更改 该模式属于创建型模式，同时也是创建型模式中应用最为广泛的一种。 案例图示 从配置文件中读取配置来进行实例化，在配置相同的情况下，就没必要重复产生对象浪费内存了，只有在配置不同的情况下才会生成新的实例。 文件内容如下： # settings.py文件内容如下 HOST = \"localhost\" PORT = 3306 案例图示： 优缺点 优点： 避免对资源的多重占用，如写入文件操作 节省内存 防止命名空间被污染 缺点： 没有接口，不能继承，与单一职责原则冲突，一个类应该只关心内部逻辑，而不关心外面怎么样来实例化 代码实现 Python实现单例模式手段较多，这里例举5种比较常见的。 继承实现 基础代码如下： class Singleton: def __new__(cls, *args, **kwargs) -> object: \"\"\" cls : class Category \"\"\" if not hasattr(cls, \"ins\"): singletonInsObject = super(__class__, cls).__new__(cls, *args, **kwargs) setattr(cls, \"ins\", singletonInsObject) return getattr(cls, \"ins\") class Category(Singleton): pass if __name__ == \"__main__\": ins = Category() print(id(ins)) ins = Category() print(id(ins)) 元类实现 基础代码如下： class MetaClass(type): def __call__(self, *args, **kwargs): \"\"\" self : class Category \"\"\" if not hasattr(self, \"ins\"): singletonInsObject = super(__class__, self).__call__(*args, **kwargs) setattr(self, \"ins\", singletonInsObject) return getattr(self, \"ins\") class Category(object, metaclass=MetaClass): pass if __name__ == \"__main__\": ins = Category() print(id(ins)) ins = Category() print(id(ins)) 装饰器实现 基础代码如下： def warpper(clsObject): def inner(*args, **kwargs): if not hasattr(clsObject, \"ins\"): singletonInsObject = clsObject(*args, **kwargs) setattr(clsObject, \"ins\", singletonInsObject) return getattr(clsObject, \"ins\") return inner @warpper class Category: pass if __name__ == \"__main__\": ins = Category() print(id(ins)) ins = Category() print(id(ins)) 模块实现 基础代码如下： - foo.py --> ins = Category() - bar.py --> from foo import ins @classmethod实现 基础代码如下： class Category: @classmethod def getSingletonInstanceObject(cls, *args, **kwargs): if not hasattr(cls, \"ins\"): singletonInsObject = cls(*args, **kwargs) setattr(cls, \"ins\", singletonInsObject) return getattr(cls, \"ins\") if __name__ == \"__main__\": ins = Category.getSingletonInstanceObject() print(id(ins)) ins = Category.getSingletonInstanceObject() print(id(ins)) 案例实现 案例实现采用元类实现、装饰器实现以及@classmethod实现. 1）元类实现： import settings class MetaClass(type): \"\"\" self : class MySQL \"\"\" def __call__(self, *args, **kwargs): # 常规实例化 if args or kwargs: insObject = object.__new__(self) self.__init__(insObject, *args, **kwargs) return insObject # 采用默认配置实例化，生成单例对象 if not hasattr(self, \"ins\"): singletonInsObject = object.__new__(self) self.__init__(singletonInsObject, settings.HOST, settings.PORT) setattr(self, \"ins\", singletonInsObject) return getattr(self, \"ins\") class MySQL(object, metaclass=MetaClass): def __init__(self, host, port) -> None: self.host = host self.port = port if __name__ == \"__main__\": ins1 = MySQL(\"192.168.0.1\", 3306) ins2 = MySQL(\"192.168.0.1\", 3307) print(ins1 is ins2) ins3 = MySQL() ins4 = MySQL() print(ins3 is ins4) # False # True 2）装饰器实现： import settings def warpper(cls): singletonInsObject = cls(settings.HOST, settings.PORT) def inner(*args, **kwargs): # 常规实例化 if args or kwargs: insObject = cls(*args, **kwargs) return insObject # 采用默认配置实例化，生成单例对象 return singletonInsObject return inner @warpper class MySQL: def __init__(self, host, port) -> None: self.host = host self.port = port if __name__ == \"__main__\": ins1 = MySQL(\"192.168.0.1\", 3306) ins2 = MySQL(\"192.168.0.1\", 3307) print(ins1 is ins2) ins3 = MySQL() ins4 = MySQL() print(ins3 is ins4) # False # True 3）@classmethod实现： import settings class MySQL: singletonInsObject = None # 常规实例化 def __init__(self, host, port) -> None: self.host = host self.port = port # 采用默认配置实例化，生成单例对象 @classmethod def getSingletonInstanceObject(cls): if not cls.singletonInsObject: cls.singletonInsObject = cls(settings.HOST, settings.PORT) return cls.singletonInsObject if __name__ == \"__main__\": ins1 = MySQL(\"192.168.0.1\", 3306) ins2 = MySQL(\"192.168.0.1\", 3307) print(ins1 is ins2) ins3 = MySQL.getSingletonInstanceObject() ins4 = MySQL.getSingletonInstanceObject() print(ins3 is ins4) # False # True Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-24 19:34:42 "},"Python/Python设计模式/原型模式.html":{"url":"Python/Python设计模式/原型模式.html","title":"原型模式","keywords":"","body":"基本介绍 原型模式（Prototype Pattern）是用于创建重复的对象，同时又能保证性能。 这种模式是实现了一个原型接口，该接口用于创建当前对象的克隆。 当直接创建对象的代价比较大时，则采用这种模式。 特点：仅存在一份，后面如果要用类似的就进行克隆拷贝，拷贝方式分2种，深拷和浅拷，原型允许个体中的属性存在差异 原型模式更适用于创建一个通用的模板，后续要使用时在此模板的基础上对实例属性进行一定范围内的变更。 该模式属于创建型模式。 案例图示 每台计算机的构成都是类似的，如果要同时组装多台计算机，可采用原型模式进行设计。 只实例化一次，减少实例化的消耗，后续个体都通过拷贝原型并修改其中属性实现差异化： 优缺点 优点： 性能提高，减少实例化时的内存消耗 节省内存 简化对象创建，同时避免了构造函数的约束，不受构造函数的限制直接复制对象，是优点，也有隐患，这一点还是需要多留意一些 缺点： 深拷贝和浅拷贝的使用需要事先考虑周到 某些编程语言中，拷贝会影响到静态变量和静态函数的使用 代码实现 用Python实现原型模式： import copy # 计算机原型 class ComputerPrototype: def __init__(self) -> None: self.cpu = None self.gpu = None self.ram = None def getInfo(self): return \"cpu : %s\\ngpu : %s\\nram : %s\" % (self.cpu, self.gpu, self.ram) # 原型建造类 class Prototype: def __init__(self) -> None: self.prototype = ComputerPrototype() def getComputer(self, cpu, gpu, ram): computer = copy.deepcopy(self.prototype) computer.__dict__.update({\"cpu\": cpu, \"gpu\": gpu, \"ram\": ram}) return computer if __name__ == \"__main__\": pro = Prototype() computerOne = pro.getComputer(cpu=\"Intel\", gpu=\"Nvidia\", ram=\"Samsung\") computerSecond = pro.getComputer(cpu=\"AMD\", gpu=\"AMD\", ram=\"Kingston\") print(computerOne.getInfo()) print(computerOne.getInfo()) # cpu : Intel # gpu : Nvidia # ram : Samsung # cpu : Intel # gpu : Nvidia # ram : Samsung Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-24 19:35:52 "},"Python/Python设计模式/适配器模式.html":{"url":"Python/Python设计模式/适配器模式.html","title":"适配器模式","keywords":"","body":"基本介绍 适配器模式（Adapter Pattern）是作为两个不兼容的接口之间的桥梁。 这种模式涉及到一个单一的类，该类负责加入独立的或不兼容的接口功能。 特点：兼容不同功能接口的2个类，让这2个类都能用相同的方式进行功能调用 该模式属于结构型模式。 案例图示 现在有2种支付方案，AliPay和WechatPay，它们调用支付的方法都不相同： AliPay调用的是aliPayAPI()进行支付 WechatPay调用的是wechatPayAPI()进行支付 现在我想实现的是不管是AliPay还是WechatPay都调用payAPI来进行支付，不再有各种区分。 并且如果后期加入了AppalePay支付的话，也是调用payAPI进行支付。 有这种需求的话就可以使用适配器模式来对接口进行适配，进行统一管理，如下图所示： 优缺点 优点： 可以让任何两个没有关联的类一起运行 提高了类的复用 增加了类的透明度 灵活性好 缺点： 过多地使用适配器，会让系统非常零乱，不易整体进行把握。比如，明明看到调用的是 A 接口，其实内部被适配成了 B 接口的实现 代码实现 用Python实现适配器模式，有2种实现方案，1是多继承，2是组合，下面是使用组合的方式实现： # 被适配类和接口 class AliPay: def aliPayAPI(self, sum): print(\"ali pay $%s\" % sum) class WeichatPay: def weichatPayAPI(self, sum): print(\"weichat pay $%s\" % sum) # 适配器类 class PayAdapter: def __init__(self, payMode, payMethod) -> None: self.payMode = payMode() self.payMethod = payMethod self.checkPay() def checkPay(self): if not hasattr(self.payMode, self.payMethod): raise AttributeError( \"Unsupported payment method：%s\" % self.payMethod) def payAPI(self, sum): method = getattr(self.payMode, self.payMethod) return method(sum) if __name__ == \"__main__\": # 对支付方案套上适配器 aliPayInstance = PayAdapter(AliPay, \"aliPayAPI\") weichatPayInstance = PayAdapter(WeichatPay, \"weichatPayAPI\") # 使用适配器接口付款 aliPayInstance.payAPI(100) weichatPayInstance.payAPI(100) # ali pay $100 # weichat pay $100 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-24 19:35:20 "},"Python/Python设计模式/桥接模式.html":{"url":"Python/Python设计模式/桥接模式.html","title":"桥接模式","keywords":"","body":"基本介绍 桥接模式（Bridge）将一个事物一分为二，把抽象的部分和实现的部分进行抽离，达到解耦的作用。 同时，被拆分的2个部分也都可以进行独立的变化。 特点：一分为二、独立扩展 桥接模式属于结构型模式。 案例图示 拿一支笔来举例，它拥有钢笔、毛笔等类型（实体）。 同时，不同的实体类型有不同的作用，如钢笔就写硬笔字（抽象），毛笔就写软笔字（抽象）。 优缺点 优点： 实现抽象和现实分离，便于维护 桥接模式拥有优秀的可扩展能力 实现细节对用户透明 缺点： 增加理解和设计难度 代码实现 用Python实现桥接模式： # 实现 class Pen: def __init__(self, use) -> None: self.name = \"pen\" self.use = use def getUse(self): return \"%s can write %s\" % (self.name, self.use.desc) class Brush: def __init__(self, use) -> None: self.name = \"brush\" self.use = use def getUse(self): return \"%s can write %s\" % (self.name, self.use.desc) # 抽象 class HardPenWords: @property def desc(self): return \"hard pen words\" class SoftPenWords: @property def desc(self): return \"soft pen words\" if __name__ == \"__main__\": pen = Pen(use=HardPenWords()) brush = Brush(use=SoftPenWords()) print(pen.getUse()) print(brush.getUse()) # pen can write hard pen words # brush can write soft pen words Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-24 11:55:10 "},"Python/Python设计模式/组合模式.html":{"url":"Python/Python设计模式/组合模式.html","title":"组合模式","keywords":"","body":"基本介绍 组合模式（Composite Pattern），又叫部分整体模式，是用于把一组相似的对象当作一个单一的对象。 组合模式依据树形结构来组合对象，用来表示部分以及整体层次。 特点：多个小的构成一个大的，根据不同粒度可以无限制的进行组合 该模式属于结构型模式，它创建了对象组的树形结构。 案例图示 一台计算机由粗看之下由以下配件组成： 机箱（chassis） 显示器（monitor） 核心处理器（CPU） 显卡（GPU） 内存（memory） 硬盘（disk） 电源（mains） 主板（motherboard） 我们可以使用组合模式将这些配件组装到一起，得到一台计算机。 优缺点 优点： 高层模块调用简单 节点自由增加 缺点： 在使用组合模式时，其叶子和树枝的声明都是实现类，而不是接口，违反了依赖倒置原则 代码实现 用Python实现组合模式，需要注意硬盘内存和显示器可能有多个，因此内部需要用列表来进行维护： # 机箱 class Chassis: def __init__(self, brand, model) -> None: self.brand = brand self.model = model # 主板 class Motherboard: def __init__(self, brand, model) -> None: self.brand = brand self.model = model # CPU class CPU: def __init__(self, brand, model) -> None: self.brand = brand self.model = model # GPU class GPU: def __init__(self, brand, model) -> None: self.brand = brand self.model = model # 内存 class Memory: def __init__(self, brand, size) -> None: self.brand = brand self.size = size # 硬盘 class Disk: def __init__(self, brand, size, type) -> None: self.brand = brand self.size = size self.type = type # 电源 class Mains: def __init__(self, brand, power) -> None: self.brand = brand self.power = power # 显示器 class Monitor: def __init__(self, brand, size, resolution) -> None: self.brand = brand self.size = size self.resolution = resolution # 电脑 class Computer: def __init__(self) -> None: self.chassis = None self.monitor = [] self.cpu = None self.gpu = None self.memory = [] self.disk = [] self.mains = None self.motherboard = None def add(self, name, obj): if hasattr(self, name): oldObject = getattr(self, name) if isinstance(oldObject, list): oldObject.append(obj) else: setattr(self, name, obj) else: raise TypeError(\"invalid accessories\") def remove(self, name): if hasattr(self, name): oldObject = getattr(self, name) if isinstance(oldObject, list): oldObject.pop() else: setattr(self, name, None) def getInfo(self): compileMessage = f\"\"\" ---- compile message ---- Chassis : {self.chassis.brand} {self.chassis.model} Monitor : {list(map(lambda obj:obj.brand + \" \" + obj.size + \" \" + obj.resolution, self.monitor))} * {len(self.monitor)} CPU : {self.cpu.brand} {self.cpu.model} GPU : {self.gpu.brand} {self.gpu.model} Memory : {list(map(lambda obj:obj.brand + \" \" + obj.size, self.memory))} * {len(self.memory)} Disk : {list(map(lambda obj:obj.brand + \" \" + obj.size, self.disk))} * {len(self.disk)} Mains: {self.mains.brand} {self.mains.power} Motherboard : {self.motherboard.brand} {self.motherboard.model} \"\"\" return compileMessage if __name__ == \"__main__\": chassis = Chassis(brand=\"ROG\", model=\"MINI-ITX\") monitor = Monitor(brand=\"SamSung\", size=\"72\", resolution=\"244hz\") cpu = CPU(brand=\"Intel\", model=\"core i9-10980XE\") gpu = GPU(brand=\"Nvidia\", model=\"RTX3090\") memory = Memory(brand=\"SamSung\", size=\"32GB\") disk = Disk(brand=\"SamSung\", size=\"2TB\", type=\"SSD\") mains = Mains(brand=\"Huntkey\", power=\"700W\") motherboard = Motherboard(brand=\"ROG\", model=\"Strix X299-E Gaming II\") compile = Computer() compile.add(\"chassis\", chassis) compile.add(\"monitor\", monitor) compile.add(\"cpu\", cpu) compile.add(\"gpu\", gpu) compile.add(\"memory\", memory) compile.add(\"memory\", memory) compile.add(\"disk\", disk) compile.add(\"mains\", mains) compile.add(\"motherboard\", motherboard) print(compile.getInfo()) # ---- compile message ---- # Chassis : ROG MINI-ITX # Monitor : ['SamSung 72 244hz'] * 1 # CPU : Intel core i9-10980XE # GPU : Nvidia RTX3090 # Memory : ['SamSung 32GB', 'SamSung 32GB'] * 2 # Disk : ['SamSung 2TB'] * 1 # Mains: Huntkey 700W # Motherboard : ROG Strix X299-E Gaming II Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-24 19:36:00 "},"Python/Python设计模式/外观模式.html":{"url":"Python/Python设计模式/外观模式.html","title":"外观模式","keywords":"","body":"基本介绍 外观模式（Facade Pattern）隐藏系统的复杂性，并向客户端提供了一个客户端可以访问系统的接口。 这种模式涉及到一个单一的类，该类提供了客户端请求的简化方法和对现有系统类方法的委托调用。 特点：为子系统中的一组接口提供一个一致的界面，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用 该模式属于结构型模式，它向现有的系统添加一个接口，来隐藏系统的复杂性。 案例图示 去医院看病，可能要去挂号、门诊、划价、取药，让患者或患者家属觉得很复杂，如果有提供接待人员，只让接待人员来处理，就很方便，当然现实中这是不可能存在的： 优缺点 优点： 减少系统相互依赖 提高灵活性 提高了安全性 缺点： 不符合开闭原则，如果要改东西很麻烦，继承重写都不合适 代码实现 用Python实现外观模式： # 行为类 class Hospital: def registered(self, name): print(\"patient : %s go to registered\" % name) def diagnosis(self, name): print(\"patient : %s go to diagnosis\" % name) def price(self, name): print(\"patient : %s go to calculating price\" % name) def getMedicine(self, name): print(\"patient : %s go to get medicine\" % name) # 外观类 class Admit: def __init__(self, name) -> None: self.name = name self.hospital = Hospital() def see_a_doctors(self): print(\"receptionist ..\") # 挂号 self.hospital.registered(self.name) # 诊断 self.hospital.diagnosis(self.name) # 计算价格 self.hospital.price(self.name) # 取药 self.hospital.getMedicine(self.name) if __name__ == \"__main__\": man = \"Ken\" hospital = Admit(man) hospital.see_a_doctors() # receptionist .. # patient : Ken go to registered # patient : Ken go to diagnosis # patient : Ken go to calculating price # patient : Ken go to get medicine Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-24 19:35:28 "},"Python/Python设计模式/代理模式.html":{"url":"Python/Python设计模式/代理模式.html","title":"代理模式","keywords":"","body":"基本介绍 在代理模式（Proxy Pattern）中，一个类代表另一个类的功能。 和适配器模式的区别：适配器模式主要改变所考虑对象的接口，而代理模式不能改变所代理类的接口。 和装饰器模式的区别：装饰器模式为了增强功能，而代理模式是为了加以控制。 特点：为其他对象提供一种代理以控制对这个对象的访问 代理模式属于结构型模式。 案例图示 买火车票不一定要去火车站买，也可以在网上买，省去了排队的环节： 优缺点 优点： 职责清晰 高扩展性 智能化 缺点： 由于在客户端和真实主题之间增加了代理对象，因此有些类型的代理模式可能会造成请求的处理速度变慢 实现代理模式需要额外的工作，有些代理模式的实现非常复杂 代码实现 用Python实现代理模式： class TrainStation: def buy_tickets(self): return \"Train ticket\" def line_up(self): print(\"Users are waiting in line ...\") class Proxy: def __init__(self): # 与火车站建立联系 self.train_station = TrainStation() def buy_tickets(self): self.__request() return self.train_station.buy_tickets() def __request(self): print(\"I am launching a ticket request to the train station ...\") if __name__ == '__main__': get_tickets = Proxy() tickets = get_tickets.buy_tickets() print(tickets) # I am launching a ticket request to the train station ... # Train ticket Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-24 12:22:52 "},"Python/Python设计模式/装饰器模式.html":{"url":"Python/Python设计模式/装饰器模式.html","title":"装饰器模式","keywords":"","body":"基本介绍 装饰器模式（Decorator Pattern）允许向一个现有的对象添加新的功能，同时又不改变其结构。 这种模式创建了一个装饰类，用来包装原有的类，并在保持类方法签名完整性的前提下，提供了额外的功能。 常用于扩展一个类的功能，同时这个新增的功能与原本的类没有任何关联，可以动态的进行撤销。 特点：动态地给一个对象添加一些额外的职责 装饰器模式属于结构型模式。 案例图示 在蜘蛛侠被蜘蛛咬之前，他只是一个普通人，但是被蜘蛛咬了之后，他具有了一些超能力。 同时，如果超能力在未来某一天没有了，他依然还是一个普通人： 优缺点 优点： 装饰类和被装饰类可以独立发展，不会相互耦合，装饰模式是继承的一个替代模式，装饰模式可以动态扩展一个实现类的功能 缺点： 多层装饰比较复杂 代码实现 用Python实现装饰器模式： # 超人（装饰类） class Superman: def __init__(self, person) -> None: self.person = person def fly(self): print(\"%s are flying\" % self.person.name) # 普通人（被装饰类） class Person: def __init__(self, name): self.name = name def eat(self): print(\"%s are eating\" % self.name) # 装饰器类 class Decorator: def __init__(self, person, superman) -> None: self.person = person self.superman = superman(self.person) def __getattr__(self,attr): try: return getattr(self.person, attr) except AttributeError: return getattr(self.superman, attr) if __name__ == \"__main__\": ken = Person(\"ken\") ken.eat() # ken.fly() parker = Decorator(Person(\"Parker\"), Superman) parker.eat() parker.fly() # ken are eating # Parker are eating # Parker are flying Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-24 13:05:34 "},"Python/Python设计模式/享元模式.html":{"url":"Python/Python设计模式/享元模式.html","title":"享元模式","keywords":"","body":"基本介绍 享元模式（Flyweight Pattern）主要用于减少创建对象的数量，以减少内存占用和提高性能。 享元模式尝试重用现有的同类对象，如果未找到匹配的对象，则创建新对象。 特点：运用共享技术有效地支持大量细粒度的对象，用HashMap存储这些对象 该模式属于结构型模式，它提供了减少对象数量从而改善应用所需的对象结构的方式。 案例图示 当大多数请求都是同一个结果，为每个请求生成一个实例的代价太高。 故只要请求的是同一个结果，我们就将已存在的实例进行返回。 举个例子，我们有一个报表系统，当第一次请求2016年度报表时会生成并存储该报表，以后再次请求2016年度报表时都不会重复生成该报表而是通过查询直接返回。 优缺点 优点： 大大减少对象的创建 降低系统的内存 缺点： 提高了系统的复杂度，需要分离出外部状态和内部状态，而且外部状态具有固有化的性质，不应该随着内部状态的变化而变化，否则会造成系统的混乱 代码实现 用Python实现享元模式： # 报表系统 class Report: def __init__(self, year) -> None: self.year = year self.desc = \"%s report\" % year # 请求报表（享元） class RequestReport: def __init__(self) -> None: self.savaMap = {} def getReport(self, year): if not self.savaMap.get(year): print(\"generated report\") newReport = Report(year) self.savaMap[year] = newReport return self.savaMap[year] if __name__ == \"__main__\": client = RequestReport() report = client.getReport(2016) print(report.desc) # 仅生成一次 report = client.getReport(2016) print(report.desc) # generated report # 2016 report # 2016 report Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-24 19:35:38 "},"Python/Python设计模式/责任链模式.html":{"url":"Python/Python设计模式/责任链模式.html","title":"责任链模式","keywords":"","body":"基本介绍 责任链模式（Chain of Responsibility Pattern）为请求创建了一个接收者对象的链。 在这种模式中，通常每个接收者都包含对另一个接收者的引用。如果一个对象不能处理该请求，那么它会把相同的请求传给下一个接收者，依此类推（亦可反之，一个处理了给下一个，直到处理完毕或其中一个不再进行处理）。 特点：避免请求发送者与接收者耦合在一起，让多个对象都有可能接收请求，将这些对象连接成一条链，并且沿着这条链传递请求，直到有对象处理它为止 该模式属于行为型模式。 案例图示 这里有3种等级的日志，info、warning、error。 它们的优先级是：info info日志只处理info级别的，如果碰见warning或者error级别日志则向上传递，如果碰见info级别的则直接处理并返回，不再向上传递。 整个记录过程是一个链式的顺序，如图所示： 优缺点 优点： 降低耦合度，一个请求将被分为接收者和发送者 简化了对象，使得对象不需要知道链的结构 增强给对象指派职责的灵活性。通过改变链内的成员或者调动它们的次序，允许动态地新增或者删除责任 增加新的请求处理类很方便 缺点： 不能保证请求一定被接收 系统性能将受到一定影响，而且在进行代码调试时不太方便，可能会造成循环调用 可能不容易观察运行时的特征，有碍于除错 代码实现 用Python实现责任链模式： import datetime class LevelBase: def write(self, logName, message): print(\"%s:[%s]:[%s] -- %s\" % (logName, datetime.datetime.now(), self.__class__.__name__.upper(), message)) class Error(LevelBase): pass class Warning(LevelBase): pass class Info(LevelBase): pass class Logger: # 建立等级关系 logLevel = (Info(), Warning(), Error()) def __init__(self, logName) -> None: self.logName = logName def write(self, level, message): for ins in __class__.logLevel: if level.upper() == ins.__class__.__name__.upper(): ins.write(self.logName, message) break else: raise ValueError(\"don't have level %s\" % level) if __name__ == \"__main__\": log = Logger(\"Yunya\") log.write(\"error\", \"this is error message\") log.write(\"info\", \"this is info message\") # Yunya:[2021-06-24 19:59:52.958078]:[ERROR] -- this is error message # Yunya:[2021-06-24 19:59:52.958136]:[INFO] -- this is info message Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-24 20:01:18 "},"Python/Python设计模式/解释器模式.html":{"url":"Python/Python设计模式/解释器模式.html","title":"解释器模式","keywords":"","body":"基本介绍 解释器模式（Interpreter Pattern）提供了评估语言的语法或表达式的方式。 这种模式实现了一个表达式接口，该接口解释一个特定的上下文，常被用在 SQL 解析、符号处理引擎等。 特点：给定一个语言，定义它的文法表示，并定义一个解释器，这个解释器使用对应文法来解释语言中的语句 该模式属于行为型模式。 案例图示 使用解释器模式，创建一门新的语言，例如 A是B，B是C，C是D… 可用于加密的工程上： 优缺点 优点： 可扩展性比较好，灵活 增加了新的解释表达式的方式 易于实现简单文法 缺点： 可利用场景比较少 对于复杂的文法比较难维护 代码实现 用Python实现解释器模式： # 密文 class Code: def __init__(self, content) -> None: self.content = content # 解释器 class Interpreter: # 定义文法 grammar = { \"a\" : \"b\", \"b\" : \"c\", \"c\" : \"d\" } def run(self, document): content = document.content result = \"\" for ch in content: result += __class__.grammar[ch] return result if __name__ == \"__main__\": document = Code(\"abc\") result = Interpreter().run(document) print(result) # bcd Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-24 20:13:36 "},"Python/Python设计模式/迭代器模式.html":{"url":"Python/Python设计模式/迭代器模式.html","title":"迭代器模式","keywords":"","body":"基本介绍 迭代器模式（Iterator Pattern）是 Java 和 .Net 编程环境中非常常用的设计模式。 这种模式用于顺序访问集合对象的元素，而不需要知道集合对象的底层表示。 特点：提供一种方法顺序访问一个聚合对象中各个元素，而又无须暴露该对象的内部表示 迭代器模式属于行为型模式。 案例图示 一个对象内部的数据存储结构并不能被直接获取到，而是通过迭代器进行获取。 Python本身已经实现了迭代器模式，只需要重写对象中的__iter__()方法和__next__()方法即可。 优缺点 优点： 支持以不同的方式遍历一个聚合对象 迭代器简化了聚合类 在同一个聚合上可以有多个遍历 缺点： 由于迭代器模式将存储数据和遍历数据的职责分离，增加新的聚合类需要对应增加新的迭代器类，类的个数成对增加，这在一定程度上增加了系统的复杂性 代码实现 用Python实现迭代器模式，迭代一个二叉树对象： # 可迭代对象 class BinaryTree: def __init__(self, root): self.key = root self.leftChild = None self.rightChild = None self.height = 0 def insertLeft(self, newNode): tree = BinaryTree(newNode) if not self.leftChild: self.leftChild = tree else: # 如果插入位置已有节点，则整体向下挪 # 新的子节点与旧的子节点链接，旧的父节点与新的子节点链接 tree.leftChild = self.leftChild self.leftChild = tree self.height += 1 def insertRight(self, newNode): tree = BinaryTree(newNode) if not self.rightChild: self.rightChild = tree else: tree.rightChild = self.rightChild self.rightChild = tree self.height += 1 def getRightChild(self): return self.rightChild def getLeftChild(self): return self.leftChild def setRootVal(self, obj): self.key = obj def getRootVal(self): return self.key def __iter__(self): return TreeIterator(tree=self) def __str__(self): return \"\"%self.getRootVal() # 迭代器 class TreeIterator: def __init__(self, tree) -> None: self.tree = tree self.treeLst = [self.tree] def __iter__(self): return self def __next__(self): # 采用层级遍历 while len(self.treeLst) > 0: node = self.treeLst.pop(0) if node.leftChild: self.treeLst.append(node.getLeftChild()) if node.rightChild: self.treeLst.append(node.getRightChild()) return node raise StopIteration(\"Tree iter end\") if __name__ == '__main__': binaryTree = BinaryTree(\"a\") binaryTree.insertLeft(\"b\") binaryTree.insertRight(\"c\") binaryTree.leftChild.insertLeft(\"d\") binaryTree.leftChild.insertRight(\"e\") binaryTree.rightChild.insertLeft(\"f\") for node in binaryTree: print(node) # # # # # # Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-25 14:12:44 "},"Python/Python设计模式/观察者模式.html":{"url":"Python/Python设计模式/观察者模式.html","title":"观察者模式","keywords":"","body":"基本介绍 观察者模式（Observer Pattern）常用于一对多关系依赖中，当某个对象发生改变后，其他对象也会做出相应的调整策略。 特点：定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新 观察者模式也被称为发布订阅模式，属于行为型模式的一种。 案例图示 当客户减少到阀值时，销售通知工厂减少生产、人力资源开始裁人，反之则增加： 优缺点 优点： 观察者和被观察者是抽象耦合的 建立一套触发机制 缺点： 如果一个被观察者对象有很多的直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间 如果在观察者和观察目标之间有循环依赖的话，观察目标会触发它们之间进行循环调用，可能导致系统崩溃 观察者模式没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的，而仅仅只是知道观察目标发生了变化 代码实现 用Python实现观察者模式： # 观察者：销售部门 # 被观察者：客户资源（SalesInstanceObject._customer） # 通知对象：工厂、人事部门 class Sales: \"\"\"销售部门\"\"\" def __init__(self): # 被观察对象 self._customer = None self._department = [] @property def customer(self): return self._customer @customer.setter def customer(self, value): self._customer = value print('当前客户数量:{}'.format(self._customer)) for obj in self._department: obj.change(value) print('------------------') def notice(self, department): \"\"\"相关部门\"\"\" self._department.append(department) class Hr: \"\"\"人事部门\"\"\" def change(self, value): if value 20: print(\"人事变动：扩员\") else: print(\"人事不受影响\") class Factory: \"\"\"工厂类\"\"\" def change(self, value): if value 25: print(\"生产计划变动：增产\") else: print(\"生产计划保持不变\") if __name__ == '__main__': sales = Sales() hr = Hr() factory = Factory() # 部门关联 sales.notice(hr) sales.notice(factory) # 客户变动 sales.customer = 10 sales.customer = 15 sales.customer = 20 sales.customer = 25 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-25 14:26:08 "},"Python/Python设计模式/中介者模式.html":{"url":"Python/Python设计模式/中介者模式.html","title":"中介者模式","keywords":"","body":"基本介绍 中介者模式（Mediator Pattern）是用来降低多个对象和类之间的通信复杂性。 这种模式提供了一个中介类，中介类来处理不同类之间的通信，并支持松耦合，使代码易于维护。 也就是说，消费者和生产者不直接接触，而是通过中介者来建立联系。 比如MVC 框架中C（控制器）就是 M（模型）和 V（视图）的中介者。 特点：用一个中介对象来封装一系列的对象交互，中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互 中介者模式属于行为型模式。 案例图示 生产者生成各类产品，中介者购买生产者的产品再转卖给消费者，生产者和消费者不直接进行接触： 优缺点 优点： 降低了类的复杂度，将一对多转化成了一对一 各个类之间的解耦 符合迪米特原则 缺点： 中介者会随着业务不断增长而变的庞大，这样的后果是中介者代码复杂且难以维护 代码实现 用Python实现中介者模式： class Consumer: \"\"\"消费者类\"\"\" def __init__(self, product, price): self.name = \"消费者\" self.product = product self.price = price def shopping(self, name): \"\"\"买东西\"\"\" print(\"向{} 购买 {}价格内的 {}产品\".format(name, self.price, self.product)) class Producer: \"\"\"生产者类\"\"\" def __init__(self, product, price): self.name = \"生产者\" self.product = product self.price = price def sale(self, name): \"\"\"卖东西\"\"\" print(\"向{} 销售 {}价格的 {}产品\".format(name, self.price, self.product)) class Mediator: \"\"\"中介者类\"\"\" def __init__(self): self.name = \"中介者\" self.consumer = None self.producer = None def sale(self): \"\"\"进货\"\"\" self.consumer.shopping(self.producer.name) def shopping(self): \"\"\"出货\"\"\" self.producer.sale(self.consumer.name) def profit(self): \"\"\"利润\"\"\" print('中介净赚：{}'.format((self.consumer.price - self.producer.price))) def complete(self): self.sale() self.shopping() self.profit() if __name__ == '__main__': consumer = Consumer('手机', 3000) producer = Producer(\"手机\", 2500) mediator = Mediator() mediator.consumer = consumer mediator.producer = producer mediator.complete() # 向生产者 购买 3000价格内的 手机产品 # 向消费者 销售 2500价格的 手机产品 # 中介净赚：500 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-25 14:33:04 "},"Python/Python设计模式/访问者模式.html":{"url":"Python/Python设计模式/访问者模式.html","title":"访问者模式","keywords":"","body":"基本介绍 访问者模式（Visitor Pattern）可以让多个处理对象对同一个数据对象做出不同的反应，但并不会改变被访问的数据对象。 特点：主要将数据结构与数据操作分离 访问者模式应该是所有模式中最抽象、最难以理解的一个。 该模式属于行为型模式。 案例图示 上市公司的原始财务数据，对于会计来说需要制作各种报表，对于财务总监来说需要分析公司业绩，对于战略顾问来说需要分析行业变化。 它们总是对同一份数据进行访问，但是获得的结果都是不同的： 优缺点 优点： 符合单一职责原则 优秀的扩展性 灵活性 缺点： 具体元素对访问者公布细节，违反了迪米特原则 具体元素变更比较困难 违反了依赖倒置原则，依赖了具体类，没有依赖抽象 代码实现 用Python实现访问者模式： class Finance: \"\"\"财务数据结构类\"\"\" def __init__(self): # 销售额 self.salesvolume = None # 成本 self.cost = None # 历史销售额 self.history_salesvolume = None # 历史成本 self.history_cost = None def set_salesvolume(self, value): self.salesvolume = value def set_cost(self, value): self.cost = value def set_history_salesvolume(self, value): self.history_salesvolume = value def set_history_cost(self, value): self.history_cost = value def accept(self, visitor): pass class Finance_year(Finance): \"\"\"2018年财务数据类\"\"\" def __init__(self, year): Finance.__init__(self) self.work = [] # 安排工作人员列表 self.year = year def add_work(self, work): self.work.append(work) def accept(self): for obj in self.work: obj.visit(self) class Accounting: \"\"\"会计类\"\"\" def __init__(self): self.ID = \"会计\" self.Duty = \"计算报表\" def visit(self, table): print('会计年度： {}'.format(table.year)) print(\"我的身份是： {} 职责： {}\".format(self.ID, self.Duty)) print('本年度纯利润： {}'.format(table.salesvolume - table.cost)) print('------------------') class Audit: \"\"\"财务总监类\"\"\" def __init__(self): self.ID = \"财务总监\" self.Duty = \"分析业绩\" def visit(self, table): print('会计总监年度： {}'.format(table.year)) print(\"我的身份是： {} 职责： {}\".format(self.ID, self.Duty)) if table.salesvolume - table.cost > table.history_salesvolume - table.history_cost: msg = \"较同期上涨\" else: msg = \"较同期下跌\" print('本年度公司业绩： {}'.format(msg)) print('------------------') class Adviser: \"\"\"战略顾问\"\"\" def __init__(self): self.ID = \"战略顾问\" self.Duty = \"制定明年战略\" def visit(self, table): print('战略顾问年度： {}'.format(table.year)) print(\"我的身份是： {} 职责： {}\".format(self.ID, self.Duty)) if table.salesvolume > table.history_salesvolume: msg = \"行业上行，扩大生产规模\" else: msg = \"行业下行，减小生产规模\" print('本年度公司业绩： {}'.format(msg)) print('------------------') class Work: \"\"\"工作类\"\"\" def __init__(self): self.works = [] # 需要处理的年度数据列表 def add_work(self, obj): self.works.append(obj) def remove_work(self, obj): self.works.remove(obj) def visit(self): for obj in self.works: obj.accept() if __name__ == '__main__': work = Work() # 计划安排财务、总监、顾问对2018年数据处理 # 实例化2018年数据结构 finance_2018 = Finance_year(2018) finance_2018.set_salesvolume(200) finance_2018.set_cost(100) finance_2018.set_history_salesvolume(180) finance_2018.set_history_cost(90) # 实例化会计 accounting = Accounting() # 实例化总监 audit = Audit() # 实例化总监 adviser = Adviser() # 会计安排到2018分析日程中 finance_2018.add_work(accounting) finance_2018.add_work(audit) # 顾问安排到2018分析日程中 finance_2018.add_work(adviser) # 添加2018年财务工作安排 work.add_work(finance_2018) work.visit() # 会计年度： 2018 # 我的身份是： 会计 职责： 计算报表 # 本年度纯利润： 100 # ------------------ # 会计总监年度： 2018 # 我的身份是： 财务总监 职责： 分析业绩 # 本年度公司业绩： 较同期上涨 # ------------------ # 战略顾问年度： 2018 # 我的身份是： 战略顾问 职责： 制定明年战略 # 本年度公司业绩： 行业上行，扩大生产规模 # ------------------ Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-25 16:40:22 "},"Python/Python设计模式/备忘录模式.html":{"url":"Python/Python设计模式/备忘录模式.html","title":"备忘录模式","keywords":"","body":"基本介绍 备忘录模式（Memento Pattern）用于保存一个对象的某个状态，以便在适当的时候恢复对象。 特点：不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态 备忘录模式属于行为型模式。 案例图示 游戏有存档和删档的功能，当我们进行到某一关时便可对游戏进行存档，下次进入游戏后按照上次的存档位置继续游戏： 优缺点 优点： 给用户提供了一种可以恢复状态的机制，可以使用户能够比较方便地回到某个历史的状态 实现了信息的封装，使得用户不需要关心状态的保存细节 缺点： 消耗资源。如果类的成员变量过多，势必会占用比较大的资源，而且每一次保存都会消耗一定的内存 代码实现 用Python实现备忘录模式： import copy class AddNumber: def __init__(self): self.start = 0 def add(self, number): self.start = number class Memento: \"\"\"备忘录\"\"\" def backups(self, obj=None): \"\"\" 设置备份方法 :param obj: :return: \"\"\" self.obj_dict = copy.deepcopy(obj.__dict__) print(\"备份数据:{}\".format(self.obj_dict)) def recovery(self, obj): \"\"\" 恢复备份方法 :param obj: :return: \"\"\" obj.__dict__.clear() obj.__dict__.update(self.obj_dict) print(\"恢复数据:{}\".format(self.obj_dict)) return obj if __name__ == '__main__': test = AddNumber() memento = Memento() for i in [1, 2, 3, 4, 5]: if i == 2: memento.backups(test) test.add(i) print(\"当前数据:{}\".format(test.start)) memento.recovery(test) print(test.start) # 备份数据:{'start': 1} # 当前数据:5 # 恢复数据:{'start': 1} # 1 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-25 16:52:34 "},"Python/Python设计模式/命令模式.html":{"url":"Python/Python设计模式/命令模式.html","title":"命令模式","keywords":"","body":"基本介绍 命令模式（Command Pattern）是一种数据驱动的设计模式，它将请求以命令的形式包裹在对象中，并传给调用对象。 调用对象寻找可以处理该命令的合适的对象，并把该命令传给相应的对象，该对象执行命令。 特点：将一个请求封装成一个对象，从而使您可以用不同的请求对客户进行参数化 该模式属于行为型模式。 案例图示 命令模式应该有一下几个角色： 1）Command： 定义命令的接口，声明执行的方法，可以理解为一个基类。 2）ConcreteCommand： 命令接口实现对象，通常会持有接收者，并调用接收者的功能来完成命令要执行的操作。 3）Receiver： 接收者，真正执行命令的对象。任何类都可能成为一个接收者，只要它能够实现命令要求实现的相应功能。 4）Invoker： 要求命令对象执行请求，通常会持有命令对象，可以持有很多的命令对象，相当于使用命令对象的入口。 5）Client： 创建具体的命令对象，组装命令对象和接收者，或许，把这个Client称为装配者会更好理解，因为真正使用命令的客户端是从Invoker来触发执行。 优缺点 优点： 降低了系统耦合度 新的命令可以很容易添加到系统中去 缺点： 使用命令模式可能会导致某些系统有过多的具体命令类 代码实现 用Python实现命令模式： class Command: \"\"\"声明命令模式接口\"\"\" def __init__(self, obj): self.obj = obj def execute(self): pass class ConcreteCommand(Command): \"\"\"实现命令模式接口\"\"\" def execute(self): self.obj.run() class Invoker: \"\"\"接受命令并执行命令的接口\"\"\" def __init__(self): self._commands = [] def add_command(self, cmd): self._commands.append(cmd) def remove_command(self, cmd): self._commands.remove(cmd) def run_command(self): for cmd in self._commands: cmd.execute() class Receiver: \"\"\"具体动作\"\"\" def __init__(self, word): self.word = word def run(self): print(self.word) def client(): \"\"\"装配者\"\"\" test = Invoker() cmd1 = ConcreteCommand(Receiver('命令一')) test.add_command(cmd1) cmd2 = ConcreteCommand(Receiver('命令二')) test.add_command(cmd2) cmd3 = ConcreteCommand(Receiver('命令三')) test.add_command(cmd3) test.run_command() if __name__ == '__main__': client() # 命令一 # 命令二 # 命令三 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-25 16:55:48 "},"Python/Python设计模式/状态模式.html":{"url":"Python/Python设计模式/状态模式.html","title":"状态模式","keywords":"","body":"基本介绍 状态模式（State Pattern）是指当对象的内部状态改变的时候，允许对象执行不同的流程，这样看起来就像改写了一个对象。 核心的方法是把复杂状态变化情况下的流程抽象出来，简化复杂情况状态的判断。 特点：允许对象在内部状态发生改变时改变它的行为，对象看起来好像修改了它的类 案例图示 定义一个运维脚本，用于监控CPU使用率状态，在不同状态下的自动化运维脚本执行不同的操作： 优缺点 优点： 封装了转换规则 枚举可能的状态，在枚举状态之前需要确定状态种类 将所有与某个状态有关的行为放到一个类中，并且可以方便地增加新的状态，只需要改变对象状态即可改变对象的行为 允许状态转换逻辑与状态对象合成一体，而不是某一个巨大的条件语句块 可以让多个环境对象共享一个状态对象，从而减少系统中对象的个数 缺点： 状态模式的使用必然会增加系统类和对象的个数 状态模式的结构与实现都较为复杂，如果使用不当将导致程序结构和代码的混乱 状态模式对\"开闭原则\"的支持并不太好，对于可以切换状态的状态模式，增加新的状态类需要修改那些负责状态转换的源代码，否则无法切换到新增状态，而且修改某个状态类的行为也需修改对应类的源代码 代码实现 用Python实现状态模式： class Base: def executor(self, value): self.run(value) class Low(Base): def __init__(self): self.name = \"较低占用率状态\" def run(self, value): print(\"当前：{} 值:{}\".format(self.name, value)) print(\"无应急情况执行\") class Large(Base): def __init__(self): self.name = \"较高占用率状态\" def run(self, value): print(\"当前：{} 值：{}\".format(self.name, value)) print(\"发送警报邮件\") class Status: def __init__(self): self.value = 0.1 self.low = Low() self.large = Large() self.status = None def monitor(self): if self.value Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-25 17:00:58 "},"Python/Python设计模式/策略模式.html":{"url":"Python/Python设计模式/策略模式.html","title":"策略模式","keywords":"","body":"基本介绍 策略模式（Strategy Pattern）中，一个类的行为或其算法可以在运行时更改。 也就是说该类在不同的环境下，能够调用不同的策略算法。 特点：定义一系列的算法，把它们一个个封装起来, 并且使它们可相互替换 该模式属于行为型模式。 案例图示 如一个人旅游时，当他身在不同的国家中便要说不同的语言： 优缺点 优点： 算法可以自由切换 避免使用多重条件判断 扩展性良好 缺点： 策略类会增多 所有策略类都需要对外暴露 代码实现 用Python实现策略模式： # 人 class People(object): def __init__(self): self.strategy = {} def get_strategy(self, location): strategy = self.strategy.get(location) if strategy: return strategy() else: raise AttributeError(\"不会这个位置的语言\") def register_strategy(self, location, strategy): self.strategy[location] = strategy # 策略类 class Strategy(object): @staticmethod def speak_english(): return \"说英文\" @staticmethod def speak_chinese(): return \"说中文\" # 位置 class Location(object): def __init__(self, location): self.location = location if __name__ == '__main__': person = People() location = Location(\"美国\") # 注册地理位置的策略 person.register_strategy(location.location, Strategy.speak_english) # 获取在美国的策略 print(person.get_strategy(\"美国\")) location = Location(\"中国\") # 注册地理位置的策略 person.register_strategy(location.location, Strategy.speak_chinese) # 获取在中国的策略 print(person.get_strategy(\"中国\")) # 说英文 # 说中文 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-25 17:07:48 "},"Python/Python设计模式/模板模式.html":{"url":"Python/Python设计模式/模板模式.html","title":"模板模式","keywords":"","body":"基本介绍 在模板模式（Template Pattern）中，一个抽象类公开定义了执行它方法的模板。 它的子类可以按需要重写方法实现，但调用将以抽象类中定义的方式进行。 特点：在有一些通用方法都需要使用时，可将其定义为模板 该模式属于行为型模式。 案例图示 如图所示，为同一个模板传入不同的参数会得到不同的结果： 优缺点 优点： 封装不变部分，扩展可变部分 提取公共代码，便于维护 行为由父类控制，子类实现 缺点： 每一个不同的实现都需要一个子类来实现，导致类的个数增加，使得系统更加庞大 代码实现 用Python实现模板模式，实现一个客户点单后的处理流程流程： class User: def __init__(self, name, shop, times, number): self.name = name self.shop = shop self.times = times self.number = number class Handle: def __init__(self, user=None): self.user = user def Invoicen(self): \"\"\"打印小票\"\"\" string = \"打印小票\\n\" \\ \"客户：{} \" \\ \"商品：{} \" \\ \"数量：{} \" \\ \"时间：{} \".format(self.user.name, self.user.shop, self.user.number, self.user.times) print(string) def Make(self): \"\"\"开始制作\"\"\" print(\"制作完成：{} 数量：{}\".format(self.user.shop, self.user.number)) def run(self): self.Invoicen() self.Make() if __name__ == '__main__': test = Handle() xiaoming = User(\"小明\", \"汉堡\", \"17:50\", \"5\") test.user = xiaoming test.run() # 打印小票 # 客户：小明 商品：汉堡 数量：5 时间：17:50 # 制作完成：汉堡 数量：5 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-25 17:16:10 "},"Python/Python网络编程/summary.html":{"url":"Python/Python网络编程/summary.html","title":"Python网络编程","keywords":"","body":" socket编程 TCP粘包 socketserver使用 socketserver源码 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-29 20:56:50 "},"Python/Python网络编程/socket编程.html":{"url":"Python/Python网络编程/socket编程.html","title":"socket编程","keywords":"","body":"前瞻知识 C/S架构 C/S架构是一种由服务端（Server）和客户端（Client）组成的双层架构。 互联网中处处充满了C/S架构（Client/Server），比如我们需要玩英雄联盟，就必须连接至英雄联盟的服务器上，那么对于我们玩家来说它的英雄联盟服务器就是Server端，而我们必须要下载一个英雄联盟Client端才能够去和英雄联盟Server端进行数据交互。 五层协议 互联网的协议实际上就是为了让计算机之间互相进行通信而产生的，本身并没有层级之分。 为了便于理解，我们可以按照功能将它们划分成5层或者7层，如下表所示： 层级 功能 相关协议 应用层 用于规定应用数据的格式，提供给各个应用程序以便于彼此之间进行通信 HTTP、FTP 传输层 用于区分该系统上的唯一一个网络应用程序 TCP、UDP 网络层 用于区分广播域，防止网络风暴的发生 IP 数据链路层 用于划分电信号以及提供IP地址和MAC地址相互转换的功能 以太网协议、ARP协议 物理层 用于传输电信号，它是网络传输数据的基石 socket抽象层 计算机网络的核心就是一堆协议，想开发基于网络通信的软件就必须遵守这些协议。 但是由于学习协议的代价巨大，故我们需要一种高度抽象的中间层来承上启下便于我们进行快速开发。 此时，socket产生了，socket位于应用层和传输层之间，它向下封装了各种协议，用户只需要通过socket提供的接口就能快速的开发出基于网络通信的软件，而并不需要深入的去研究某些底层协议，如TCP、UDP等。 为什么要学习socket呢？因为它是各种与网络沾边的应用框架的底层实现，如Django、requests等只要与网络有关系的框架或模块都离不开socket。 TCP协议简述 流式传输 TCP协议是一种基于字节流的形式，什么叫流呢？因为数据的传输就像是水龙头一样打开哗啦啦的没有确切的边界，如下图所示： 三次握手 Client端和Server端若想正常进行数据交互，必须先经历一次三次握手的过程，用于确定二者关系并建立双向链接通道： 状态释义，可通过netstat命令查看： SYN_SENT：Client端发送一次建立链接请求后会立刻进入该状态，并且在没有收到Server端的回应之前都会保持该状态，通常来说该状态持续时间非常短，几乎不可测 ESTABLISHED：当某一方进入该状态后，则代表可以向另一方发送数据了 LISTEN：Server端在等待Client端建立三次握手时的状态，即监听Client端的请求 SYN_RCVD：Server端进入该状态代表已收到Client端的三次握手链接请求 信息释义： SYN：用于建立链接的标志位 ACK：确认请求的标志位 seq：可以理解为一段暗号，用于确认该信息未被修改 补充，SYN泛洪攻击： 当Server端长期进入SYN_RCVD状态时就要当心是否遭受了SYN洪水攻击。 因为TCP三次握手对于Server端来讲会无限的回复Client端发来的SYN请求，收到一条就回一条。 如果有黑客模拟成千上万台Client端对Server端发起SYN请求，在发送第一次握手后就溜溜球了那么服务器还傻乎乎的等待第三次的握手回信，这么做会让Server端的压力很大。所以TCP协议也被称为好人协议... 补充，半链接池backlog： Server端如果不能一时之间全部处理完成所有的请求时会将后到的请求放入半链接池中进行排队 防止SYN 洪水攻击的有效策略其中一点就是：增大backlog链接池的最大数量，但是一般不会采用该策略 另一个策略是缩小Server端对每个请求的返回次数（如果Server端发现Client端没理自己，就会不断的回应上次的信息。初始值为5s，过5s发一次，然后变成3s，再过3s发一次，变成1s，再发一次...直到不想发了就不会理睬这个请求了） 平常打开一个网页打不开的时候，有一种可能性就是人家的backlog满了，你就只能排在外边儿等 双向链接通道 当Client端和Server端三次握手完成后，TCP协议会创建一个双向链接通道，用于Client端和Server端之间的数据交互，如图所示： 可靠传输 TCP协议也被称为可靠传输协议，即发送方向接收方发送了数据后，接收方必须回应发送方一个收到了的信息的ACK确认，若发送方没收到该ACK确认，则会重新发送一次数据，如下图所示。 注意：三次握手时的数据交互并不是走双向链接通道，而对于下图的数据传输来说则是走的双向链接通道了 四次挥手 当Client端要断开与Server端的链接时，必须要经历一个四次挥手的过程。 为什么创建链接仅需要三次，而断开链接则需要四次呢？ 可以看到，三次握手之前是没有数据传输的，并且其中第二次是一次性发送了一个请求和一个确认。所以减少了一次操作。 而四次挥手涉及到数据的传输，所以不可能简化成三次挥手。 此外，四次挥手也是不同于三次握手，四次挥手也是建立在双向链接通道的基础之上的，而三次握手的时候该双向通道还未建立成功： 状态释义： FIN_WAIT_1：代表主动发起断开链接请求 FIN_WAIT_2：代表此时的Client端不会再主动向Server端发送数据 TIME_WAIT：代表Client端还要回复最后一条确认消息，回复完毕后双向链接正式关闭 CLOSE_WAIT：代表关闭等待 LAST_ACK：代表持续的确认（即只要Client端没有回复第4条信息，Server端就不断尝试发送断开链接的FIN请求） 另外，在实际生活场景中，服务端主动断开链接的情况比较多，因为它涉及到了和很多客户端的通信，还有的客户端还在排队，所以不可能对一个客户端浪费太多时间。 这句话你可以理解为： 服务器是个渣男 ，很多女孩子（Client端）都喜欢他，都给他写情书，他回复完了一个女孩子的情书后立马会拆开下一封情书，并不会只留恋于一封。 UDP协议简述 数据报传输 UDP协议是一种基于数据报的格式（也被称为基于消息的传输），不同于TCP的字节流格式。UDP的数据报格式是有头有尾的，这一点很重要。 如图所示： 不可靠传输 UDP协议在数据传输时并不需要建立双向链接通道。 且UDP发消息与TCP不太一样，发送发只管发送消息，不管接收方有没有收到消息都不会再发，所以这也是UDP协议被称为不可靠传输协议的由来。 因为UDP协议没有这种ACK确认的机制，虽然对于数据可靠性来说下降了不少但是对于数据传输性上则有了明显的提示。 故DHCP服务以及DNS域名解析服务都是使用UDP协议，因为它速度更快，此外早起的QQ也是使用的UDP协议进行通信。 套接字发展史 套接字起源 套接字起源于20世纪70年代加利福尼亚大学伯克利分校版本的Unix，它最初的设计是为了让同一台主机上的多个应用程序之间进行通信，也就是进程通信或者被称为IPC，套接字有两种： 基于文件的套接字 基于网络的套接字 同机的不同进程之间本身是不允许通信的，但是可以通过套接字来进行数据交互。 此外，套接字也允许应用程序将I/O（input / output）插入到网络中，并与网络中的其他应用程序进行通信，基于网络的套接字就是IP地址加端口的组合。 故socket也被称为：IP+PORT。 基于文件的套接字家族 名称：AF_UNIX 作用：Unix一切皆文件，基于文件的套接字调用的就是底层的文件系统来存取数据，两个套接字进程运行在同一台机器上，可以通过访问同一个文件系统间接完成通信。 基于网络的套接字家族 名称：AF_INET 作用：IPV4协议套接字，有了IP + PORT我们可以与互联网上的任何应用程序进行通信。 除此之外还有一个叫AF_INET6的套接字，也就是基于IPV6的套接字。 套接字工作流程 基于TCP协议的套接字工作流程 由于TCP协议本身比较复杂，故使用基于TCP协议的套接字编写程序整体流程也较为复杂： 基于UDP协议的套接字工作流程 基于UDP协议的套接字工作流程相比于基于TCP协议的套接字工作流程来说简单一些，因为不用建立双向链接通道： TCP/Socket简单通信 基础实现 由于TCP协议需要建立双向链接通道，故必须先开启Server端后再开启Client端，否则会发生异常。 Server端代码如下： from socket import * # 1. 实例化socket对象，并添加端口复用 # AF_INET：IPV4 # SOCK_STREAM：TCP协议 server = socket(family=AF_INET, type=SOCK_STREAM) server.setsockopt(SOL_SOCKET, SO_REUSEADDR, 1) # 2.绑定IP地址与端口号 # localhost：仅允许本机使用 # 127.0.0.1：仅允许本机使用 # 0.0.0.0：允许任意client链接 server.bind((\"localhost\", 8888)) # 3.设置半链接池大小 server.listen(5) # 4.阻塞等待三次握手请求 # conn：双向链接通道 # clientAddr：客户端链接信息 conn, clientAddr = server.accept() # 5.接收client发送的信息，单位：字节 data = conn.recv(1024) # 6.给client发送信息 conn.send(data.upper()) # 7.关闭双向链接通道，释放底层端口占用的系统资源 conn.close() # 8.关闭服务器，释放Python应用程序所占据的内存资源 server.close() Client端代码如下： from socket import * # 1. 实例化socket对象 # AF_INET：IPV4 # SOCK_STREAM：TCP协议 client = socket(family=AF_INET, type=SOCK_STREAM) # 2.向服务端发送请求 # 开始进行三次握手并创建双向链接通道 client.connect((\"localhost\", 8888)) # 3.通信开始，发送消息 client.send(\"hello world\".encode(\"u8\")) # 4.接收server端的消息 msg = client.recv(1024) print(msg.decode(\"u8\")) # 5.关闭客户端 client.close() 双层循环 上面的例子中，Server端会接受Client端的信息，并将其进行upper()后返回。 也就是说Server端和Client端的交互仅有一次，这显然不符合常理。 所以我们需要为Server端的代码做一些小小的改动，让其能够不断的处理Client端的请求，而非只处理一次。 具体逻辑是： 增加链接循环，接收不同Client端的三次握手请求 增加通信循环，让Client端和Server端能够长时间通信 Server端代码如下所示： from socket import * server = socket(family=AF_INET, type=SOCK_STREAM) server.setsockopt(SOL_SOCKET, SO_REUSEADDR, 1) server.bind((\"localhost\", 8888)) server.listen(5) while 1: # 不断接受新请求， 即服务端永不停止运（链接循环） conn, clientAddr = server.accept() print(\"%s connect server\" % clientAddr[0]) # 服务端能一直保持和客户端的通信，当客户端输入exit后将停止对当前客户端的服务（通信循环） while 1: data = conn.recv(1024) if data.decode(\"u8\") == \"exit\": break conn.send(data.upper()) print(\"%s close connect\" % clientAddr[0]) conn.close() Client端代码如下所示： from socket import * client = socket(family=AF_INET, type=SOCK_STREAM) client.connect((\"localhost\", 8888)) # 不断的与服务器进行交互 while 1: sendMsg = input(\">>>\") client.send(sendMsg.encode(\"u8\")) # 如果发送的是exit，则断开链接 if sendMsg == \"exit\": break recvMsg = client.recv(1024) print(recvMsg.decode(\"u8\")) print(\"client close\") client.close() Client端发送空信息导致的异常 现在Server端已经全部做好了，但是Client端还有一个问题。 当Client端出现 >>> 时直接敲击回车后会Server端会卡住，只有重启Server端才能解决该问题。 若进行代码调试，可观察到此时Client端处于recv()状态，而Server端也处于recv()状态，这代表Client端发送的回车“空消息”根本没有被Server端所接收到。 为什么会出现这样的情况？还需要从底层原理说起。 其实不管是send()还是recv()都是socket应用程序对操作系统发出的一次系统调用，再此期间CPU工作状态会从用户态转变至内核态。 而用户态的内存数据是不能直接与内核态的内存数据发生交互的，所以只能靠一种映射关系（可以理解为拷贝，但是并不准确）来映射出需要发送的内容。 如果Client端输入一个回车，且发送给了Server端后，Server端是接收不到该信息的，因为recv()的映射是读取不到“空消息”的： Client端将自己的回车“空消息”进行发送 Server端的recv()由于读取不到“空消息”，故会直接卡住 如下图所示： 如果要解决这个问题，我们只需对Client端发送的消息做出限制，让其不为空即可： from socket import * client = socket(family=AF_INET, type=SOCK_STREAM) client.connect((\"localhost\", 8888)) # 不断的与服务器进行交互 while 1: sendMsg = input(\">>>\") # 不让客户端发送空消息 if not sendMsg: continue client.send(sendMsg.encode(\"u8\")) recvMsg = client.recv(1024) print(recvMsg.decode(\"u8\")) # 如果发送的是exit，则断开链接 if sendMsg == \"exit\": break print(\"client close\") client.close() 强行关闭Client端导致的异常 当Server端正在与Client端链接时，如果此时强行关闭Client端，将会导致Server端出现异常。 Windows平台下Server端会直接抛出ConnectionResetError异常 Unix平台下Server端的recv()会无限制收到空信息 如下所示： ConnectionResetError: [WinError 10054] 远程主机强迫关闭了一个现有的连接。 为什么会出现这种原因呢？因为Server端和Client端的链接是双向的，一旦一方关闭链接通道后这个链接通道就会崩塌，从而导致Server端发生此异常。 如何解决该异常？需要用到try和except以及if判断，如下所示： from socket import * server = socket(family=AF_INET, type=SOCK_STREAM) server.setsockopt(SOL_SOCKET, SO_REUSEADDR, 1) server.bind((\"localhost\", 8888)) server.listen(5) while 1: conn, clientAddr = server.accept() print(\"%s connect server\" % clientAddr[0]) while 1: # try： 针对Windows环境 try: data = conn.recv(1024) # if：针对Unix环境 if not data: break conn.send(data.upper()) except ConnectionResetError as e: break print(\"%s close connect\" % clientAddr[0]) conn.close() 最终代码 最终代码如下。 Server端： from socket import * server = socket(family=AF_INET, type=SOCK_STREAM) server.setsockopt(SOL_SOCKET, SO_REUSEADDR, 1) server.bind((\"localhost\", 8888)) server.listen(5) while 1: conn, clientAddr = server.accept() print(\"%s connect server\" % clientAddr[0]) while 1: # try： 针对Windows环境 try: data = conn.recv(1024) # if：针对Unix环境 if not data: break conn.send(data.upper()) except ConnectionResetError as e: break print(\"%s close connect\" % clientAddr[0]) conn.close() Client端： from socket import * client = socket(family=AF_INET, type=SOCK_STREAM) client.connect((\"localhost\", 8888)) # 不断的与服务器进行交互 while 1: sendMsg = input(\">>>\") # 不让客户端发送空消息 if not sendMsg: continue # 如果发送的是exit，则断开链接 if sendMsg == \"exit\": break client.send(sendMsg.encode(\"u8\")) recvMsg = client.recv(1024) print(recvMsg.decode(\"u8\")) print(\"client close\") client.close() UDP/Socket简单通信 基础实现 下面是基于UDP协议的socket通信。由于UDP协议是没有双向链接通道的，故首先启动任意一端都不会报错。 Server端代码如下： from socket import * # 1. 实例化socket对象，并添加端口复用 # AF_INET：IPV4 # SOCK_DGRAM：UDP协议 server = socket(family=AF_INET, type=SOCK_DGRAM) server.setsockopt(SOL_SOCKET, SO_REUSEADDR, 1) # 2.绑定IP地址与端口号 # localhost：仅允许本机使用 # 127.0.0.1：仅允许本机使用 # 0.0.0.0：允许任意client链接 server.bind((\"localhost\", 8888)) # 3.接收client端的数据 data, clientAddr = server.recvfrom(1024) # 4.回复client的信息 server.sendto(data.upper(), clientAddr) # 5.关闭服务器，释放Python应用程序所占据的内存资源 server.close() Client端代码如下： from socket import * # 1. 实例化socket对象 # AF_INET：IPV4 # SOCK_DGRAM：UDP协议 client = socket(family=AF_INET, type=SOCK_DGRAM) # 2.向服务端发送数据 client.sendto(\"hello world\".encode(\"u8\"), (\"localhost\", 8888)) # 3.接收服务端的数据 msg, serverAddr = client.recvfrom(1024) print(msg.decode(\"u8\")) # 4.关闭客户端 client.close() 增加单层循环 由于基于UDP协议通信不会建立双向链接通道，所以我们只需要增加一个“通信循环”即可。 Server端改进代码如下所示： from socket import * server = socket(family=AF_INET, type=SOCK_DGRAM) server.setsockopt(SOL_SOCKET, SO_REUSEADDR, 1) server.bind((\"localhost\", 8888)) while 1: data, clientAddr = server.recvfrom(1024) server.sendto(data.upper(), clientAddr) Client端改进代码如下所示： from socket import * client = socket(family=AF_INET, type=SOCK_DGRAM) while 1: sendMsg = input(\">>>\") if sendMsg == \"exit\": break client.sendto(sendMsg.encode(\"u8\"), (\"localhost\", 8888)) msg, serverAddr = client.recvfrom(1024) print(msg.decode(\"u8\")) client.close() Bug测试 我们对该两段代码进行BUG测试均未发现异常。 1）强制停止Client端是否会导致Server端异常崩溃？ 没有导致，原因是因为UDP协议的通信不基于双向链接通道 2）客户端发送回车或者任意空消息是否会导致recvfrom()卡住？ 没有导致，这个还是要从UDP的数据格式说起，因为UDP是数据报格式的发送，所以即便消息体是空，也还有一个消息头在里面 所以UDP的整段数据是不可能为空的，也就不会导致内核缓冲区读不到数据而卡住 解决端口占用问题 在进行socket编程中肯定会遇到端口被占用的情况，实际上就是服务器再向客户端发送最后一条ACK回应，也就是四次挥手中的第四步。 此时服务器的状态应该处于：TIME_WAIT（等待一段时间确保双向链接通道中的信息全部读取完毕）。这是属于正常情况，请勿惊慌。 解决方式如下： 1）加入一条socket配置，重用ip和端口： # 这条代码放在bind的前面 server = socket(family=AF_INET, type=SOCK_STREAM) server.setsockopt(SOL_SOCKET, SO_REUSEADDR, 1) # * server.bind((\"localhost\", 8888)) 2）针对Linux平台： 发现系统存在大量TIME_WAIT状态的连接，通过调整linux内核参数解决， vi / etc / sysctl.conf 编辑文件，加入以下内容： net.ipv4.tcp_syncookies = 1 net.ipv4.tcp_tw_reuse = 1 net.ipv4.tcp_tw_recycle = 1 net.ipv4.tcp_fin_timeout = 30 然后执行 / sbin / sysctl - p 让参数生效。 net.ipv4.tcp_syncookies = 1 表示开启SYN Cookies。当出现SYN等待队列溢出时，启用cookies来处理，可防范少量SYN攻击，默认为0，表示关闭； net.ipv4.tcp_tw_reuse = 1 表示开启重用。允许将TIME - WAIT sockets重新用于新的TCP连接，默认为0，表示关闭； net.ipv4.tcp_tw_recycle = 1 表示开启TCP连接中TIME - WAIT sockets的快速回收，默认为0，表示关闭。 net.ipv4.tcp_fin_timeout 修改系統默认的 TIMEOUT 时间 验证链接合法性 在很多时候，我们的TCP服务端为了防止网络泛洪可以设置一个客户端链接的验证机制。 这个验证机制的实现其实也是非常简单，思路在于进入通信循环之前，客户端和服务端先走一次链接认证，只有通过认证的客户端才能够继续和服务端进行链接，核心点在于Server端和Client端都必须具有1个相同的验证对比盐值。 实现如图所示： Server端代码如下： from socket import * import json import os import hmac class TcpServer: def __init__(self, ip_port=(\"localhost\", 8888), backlog=5, bufsize=1024) -> None: self.salt = b\"SOCKET SERVER\" self.verificationString = None self.bufsize = bufsize self.backlog = backlog self.ip_port = ip_port self.socket = None self.conn = None self.clientAddr = None def run(self): self.initialization() while 1: self.requestHandler() if not self.verification(): print(\"verification fail\") continue while 1: try: self.communicateHandler() except ConnectionResetError as e: self.conn.close() break def initialization(self): \"\"\"初始化数据\"\"\" self.socket = socket(family=AF_INET, type=SOCK_STREAM) self.socket.setsockopt(SOL_SOCKET, SO_REUSEADDR, 1) self.socket.bind(self.ip_port) self.socket.listen(5) self.socket.listen(self.backlog) def requestHandler(self): \"\"\"处理链接请求\"\"\" self.conn, self.clientAddr = self.socket.accept() def verification(self): \"\"\"验证链接合法性\"\"\" # 生成32位bytes类型的随机值 self.verificationString = os.urandom(32) # 将随机值发送给client端 self.conn.send(self.verificationString) # 接收client端的信息 recvMsg = self.conn.recv(self.bufsize) # 将随机值和盐进行hash加密，与recvMsg进行对比，如果一样则验证通过 # 否则认证失败，关闭双向通道 h = hmac.new(self.salt, self.verificationString) digest = h.digest() print(digest, \"\\n\", recvMsg) return hmac.compare_digest(digest, recvMsg) def communicateHandler(self): \"\"\"处理通信请求\"\"\" data = self.conn.recv(self.bufsize) if not data: raise ConnectionResetError( \"client %s close\" % str(self.clientAddr)) data = json.loads(data.decode(\"u8\")) self.conn.send( json.dumps(data).encode(\"u8\") ) if __name__ == \"__main__\": server = TcpServer() server.run() Client端代码如下： import json import hmac from socket import * class TcpClient: def __init__(self, server_ip_port=(\"localhost\", 8888), backlog=5, bufsize=1024) -> None: self.salt = b\"SOCKET SERVER\" self.bufsize = bufsize self.backlog = backlog self.server_ip_port = server_ip_port self.socket = None def run(self): \"\"\"初始化数据\"\"\" self.socket = socket() self.socket.connect(self.server_ip_port) self.verification() self.communicateHandler() def verification(self): \"\"\"验证链接合法性\"\"\" # 获取server端发送的验证字符串 recvVerificationString = self.socket.recv(self.bufsize) # 将验证字符串与本地的盐进行混合，得到新的结果 h = hmac.new(self.salt, recvVerificationString) digest = h.digest() # 将新结果发送给server端做比对 self.socket.send(digest) def communicateHandler(self): \"\"\"处理通信请求\"\"\" while 1: sendMsg = input(\">>>\") # 不让客户端发送空消息 if not sendMsg: continue # 如果发送的是exit，则断开链接 if sendMsg == \"exit\": break self.socket.send( json.dumps(sendMsg).encode(\"u8\") ) recvMsg = json.loads( self.socket.recv(1024).decode(\"u8\") ) print(recvMsg) self.socket.close() if __name__ == \"__main__\": client = TcpClient() client.run() socket模块方法大全 以下是socket模块所提供的方法： 方法 描述 s.bind() 绑定地址（host, port）到套接字， 在AF_INET下,以元组（host, port）的形式表示地址 s.listen() 开始TCP监听。backlog指定在拒绝连接之前，操作系统可以挂起的最大连接数量。该值至少为1，大部分应用程序设为5就可以了 s.accept() 被动接受TCP客户端连接，(阻塞式)等待连接的到来 s.connect() 主动初始化TCP服务器连接。一般address的格式为元组（hostname, port），如果链接出错会抛出socket.error异常 s.connect_ex() connect()函数的扩展版本，出错时返回出错码，而不是抛出异常 s.recv() 接收TCP数据，数据以字符串形式返回，bufsize指定要接收的最大数据量。flag提供有关消息的其他信息，通常可以忽略 s.send() 发送TCP数据，将string中的数据发送到连接的套接字。返回值是要发送的字节数量，该数量可能小于string的字节大小 s.sendall() 完整发送TCP数据，将string中的数据发送到连接的套接字，但在返回之前会尝试发送所有数据。成功返回None，失败则抛出异常 s.recvfrom() 接收UDP数据，与recv()类似，但返回值是（data, address）。其中data是包含接收数据的字符串，address是发送数据的套接字地址 s.sendto() 发送UDP数据，将数据发送到套接字，address是形式为（ipaddr，port）的元组，指定接收方的ip地址和端口号。返回值是发送的字节数 s.close() 关闭套接字 s.getpeername() 返回连接套接字的远程地址。返回值通常是元组（ipaddr, port） s.getsockname() 返回套接字自己的地址。通常是一个元组(ipaddr, port) s.setsockopt(level,optname,value) 设置给定套接字选项的值 s.getsockopt(level,optname[.buflen]) 返回套接字选项的值 s.settimeout(timeout) 设置链接超时时间，默认为None，即永不超时 s.gettimeout() 返回当前超时期的值，单位是秒，如果没有设置超时期，则返回None s.fileno() 返回套接字的文件描述符 s.setblocking(flag) 如果flag为0，则将套接字设为非阻塞模式，否则将套接字设为阻塞模式（默认值）。非阻塞模式下，如果调用recv()没有发现任何数据，或send()调用无法立即发送数据，那么将引起socket.error异常 s.makefile() 创建一个与该套接字相关连的文件 更多方法，参考官方文档：点我跳转 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-28 22:31:16 "},"Python/Python网络编程/TCP粘包.html":{"url":"Python/Python网络编程/TCP粘包.html","title":"TCP粘包","keywords":"","body":"TCP/Socket与subprocess 我们准备做一个可以在Client端远程执行Server端的shell命令并拿到其执行结果的程序，而涉及到网络通信就必然会使用到socket模块，此外还需要subprocess模块拿到命令执行结果。 关于传输层协议的选择我们采用TCP协议，因为它是可靠传输协议且一次传输的数据量要比UDP协议更大。 以下是Server端的代码实现： import subprocess from socket import * # 默认直接实例化socket是IPV4 + TCP协议 server = socket() server.setsockopt(SOL_SOCKET, SO_REUSEADDR, 1) server.bind((\"localhost\", 8888)) server.listen(5) while 1: conn, clientAddr = server.accept() print(\"%s connect server\" % clientAddr[0]) while 1: try: command = conn.recv(1024) if not command: break result = subprocess.Popen( args=command.decode(\"u8\"), shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE ) # get success result successOut = result.stdout.read() # get error result errorOut = result.stderr.read() # type == bytes dataBody = successOut or errorOut conn.send(dataBody) except ConnectionResetError as e: break print(\"%s close connect\" % clientAddr[0]) conn.close() 以下是Client端代码的实现： from socket import * client = socket() client.connect((\"localhost\", 8888)) while 1: command = input(\">>>\").strip() if not command: continue if command == \"exit\": break client.send(command.encode(\"u8\")) dataBody = client.recv(1024) # windows server : decode(\"gbk\") # unix server : decode(\"u8\") print(dataBody.decode(\"u8\")) print(\"client close\") client.close() 使用测试，Client端输入命令： >>>ls __pycache__ socketClient.py socketServer.py >>>pwd /Users/yunya/PythonProject >>>cal 六月 2021 日 一 二 三 四 五 六 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 >>> 粘包现象 上面的测试看起来一切都非常完美，但如果Client端输入一条结果很长的命令时会出现一次性读取不完的Bug，如下所示： >>>info vim File: *manpages*, Node: vim, Up: (dir) VIM(1) VIM(1) NAME vim - Vi IMproved, a programmer's text editor SYNOPSIS vim [options] [file ..] vim [options] - vim [options] -t tag vim [options] -q [errorfile] ex view gvim gview evim eview rvim rview rgvim rgview DESCRIPTION Vim is a text editor that is upwards compatible to Vi. It can be used to edit all kinds of plain text. It is especially useful for editing programs. There are a lot of enhancements above Vi: multi level undo, multi win- dows and buffers, syntax highlighting, command line editing, filename completion, on-line help, visual selection, etc.. See \":help vi_diff.txt\" for a summary of the differences between Vim and Vi. While running Vim a lot of help can be obtained from the on-line help system, with the \":help\" command. See the ON- >>>ls LINE HELP section below. Most often Vim is started to edit a single file with the command vim file More generally Vim is started with: vim [options] [filelist] If the filelist is missing, the editor will start with an empty buffer. Otherwise exactly one out of the following four may be used to choose one or more files to be edited. file .. A list of filenames. The first one will be the current file and read into the buffer. The cursor will be posi- tioned on the first line of the buffer. You can get to the other files with the \":next\" command. To edit a file that starts with a dash, precede the filelist with \"--\". - The file to edit is read from stdin. Commands are read from stderr, which should be a tty. -t {tag} The file to edit and the initial cursor position depends on a >>> 可以看到，第一次命令是info vim，第二次命令是ls，但是ls显示的依旧是info vim命令的执行结果。 这种现象就被称之为粘包现象。 产生原因 为什么会产生粘包现象呢？其实这与TCP底层传输有关，我们知道TCP是流式传输协议，故消息没有确切的边界。 上述代码中每次的recv()仅读取1024个字节，当消息超过1024字节后就会发生一次性读取不完整个内核缓冲区的情况，此时第二次recv()的读取会接着上次读取的位置继续进行读取，如下图所示： 由于我们的recv()只是按照固定的1024去读取数据，那么一旦整体内核缓冲区中所存储的数据量大于1024个字节，就会产生粘包现象。 产生粘包现象的原因主要还是因为接收方不知道消息之间的界限，不知道一次性读取多少字节的数据所造成的。 Nagle算法 基于TCP协议的socket通信有一个特点： 即一方的send()与另一方的recv()可以没有任何关系 比如一方send()三次，另一方recv()一次就可以将数据全部取出来。 TCP协议的发送方有一个特征，他会采用了Nagle算法来对数据进行组包，如果一次发送的数据量很小，比如第一次发送10个字节，第二次发送2个字节，第三次发送3个字节，他可能会将这15个字节的数据凑到一块发送出去。 这么做有一个弊端就是接收方想要将这个大的数据包按照发送方的发送次数精确无误的接收拆分成10 2 3必须要有发送方提供的拆包机制才行。 Server端代码如下所示： from socket import * ip_port = (\"localhost\", 8000) back_log = 5 server = socket(AF_INET, SOCK_STREAM) server.setsockopt(SOL_SOCKET, SO_REUSEADDR, 1) server.bind(ip_port) server.listen(back_log) conn, addr = server.accept() conn.send(\"ABCDEFGHJK\".encode(\"utf-8\")) # 第一次发送是10Bytes的数据 conn.send(\"LM\".encode(\"utf-8\")) # 第二次也是2Bytes的数据 conn.send(\"NOP\".encode(\"utf-8\")) # 第三次是3Bytes的数据 Client端代码如下所示： from socket import * ip_port = (\"localhost\", 8000) buffer_size = 1024 client = socket(AF_INET, SOCK_STREAM) client.connect(ip_port) data_1 = client.recv(buffer_size) print(\"first send of data:\", data_1.decode(\"utf-8\")) data_2 = client.recv(buffer_size) print(\"second send of data:\", data_2.decode(\"utf-8\")) data_3 = client.recv(buffer_size) print(\"last send of data:\", data_3.decode(\"utf-8\")) 最终接受结果： first send of data: ABCDEFGHJK second send of data: LMNOP last send of data: 可以看见发送方Server分三次发送了15bytes的数据，而接收方Client仅用两个recv()就接收完毕了所有的数据。 由Nagle算法产生的组包，会有极大可能导致粘包现象的发生，故我们需要思考如何让接收方知道发送方每一次发送的数据大小并准确进行拆分。 手动拆分 如果我们手动拆分接收方的recv()读取大小呢？是否还会发生粘包现象？ 改进的Client端代码如下所示： from socket import * ip_port = (\"localhost\", 8000) buffer_size = 1024 client = socket(AF_INET, SOCK_STREAM) client.connect(ip_port) # 由于预先知道对面第一次发送的数据包大小为10bytes，故这里也用10bytes进行读取 data_1 = client.recv(10) print(\"first send of data:\", data_1.decode(\"utf-8\")) # 由于预先知道对面第一次发送的数据包大小为2bytes，故这里也用2bytes进行读取 data_2 = client.recv(2) print(\"second send of data:\", data_2.decode(\"utf-8\")) # 由于预先知道对面第一次发送的数据包大小为3bytes，故这里也用3bytes进行读取 data_3 = client.recv(3) print(\"last send of data:\", data_3.decode(\"utf-8\")) 最终接收结果： first send of data: ABCDEFGHJK second send of data: LM last send of data: NOP 粘包被我们手动的计算字节数来精确的分割数据接受量的大小给解决了，但是这样做是不现实的，我们不可能知道对方发送的数据到底是怎么样的，更不用说手动计算。 所以有没有更好的解决方案呢？ 预先发送消息长度 好了，其实上面关于解决粘包的思路已经出来了。 我们需要做的就是让接收方知道本次需要接收内容的大小才能够精确的将所有数据全部提取出来不产生遗漏。 实现方式很简单，可以尝试以下思路： 发送方发送一个此次数据固定的长度 接收方接收到该数据长度并且回应 发送方收到回应并且发送真正的数据 接收方不断的用默认的buffer_size值接收新的数据并存储起来直到超出整个数据的长度，代表此次数据全部接收完毕 实现代码如下，Server端： import subprocess from socket import * # 默认直接实例化socket是IPV4 + TCP协议 server = socket() server.setsockopt(SOL_SOCKET, SO_REUSEADDR, 1) server.bind((\"localhost\", 8888)) server.listen(5) while 1: conn, clientAddr = server.accept() print(\"%s connect server\" % clientAddr[0]) while 1: try: command = conn.recv(1024) if not command: break result = subprocess.Popen( args=command.decode(\"u8\"), shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE ) # get success result successOut = result.stdout.read() # get error result errorOut = result.stderr.read() # type == bytes dataBody = successOut or errorOut # this is message head # tell client next receive of buffsize how many dataHead = len(dataBody) conn.send(str(dataHead).encode(\"u8\")) # server receive result is ready # representative client it is already possible to receive real data body if conn.recv(1024) == b\"ready\": conn.send(dataBody) except ConnectionResetError as e: break print(\"%s close connect\" % clientAddr[0]) conn.close() Client端： from socket import * client = socket() client.connect((\"localhost\", 8888)) while 1: command = input(\">>>\").strip() if not command: continue if command == \"exit\": break client.send(command.encode(\"u8\")) dataHead = client.recv(1024) dataBodyLength = int(dataHead.decode(\"u8\")) currentRecvDataBodyLength = 0 dataBody = b\"\" # Can receive data body client.send(b\"ready\") while currentRecvDataBodyLength 经过实测后发现输入任何命令都不会发生粘包了。 json+struct增加消息头 上面的解决方案还是有一些弊端，因为Server端是发送了2次send()，第1次发送数据整体长度，第2次发送数据内容主体，这样是不太好的（Server端可能同时处理多个链接，所以send()次数越少越好）。 而且如果Server端传的是一个文件的话那么局限性就太强了。因为我们只能将整体的消息长度发送过去而诸如文件名，文件大小之内的信息就发送不过去。 所以我们需要一个更加完美的解决方案，即Server端发送一次send()就将本次的数据整体长度发送过去（还可以包括文件姓名，文件大小等信息）。 那么这里就要使用到一个内置模块，struct。 struct模块可以将其某一种数据格式序列化为固定长度的bytes类型，其中最重要的两个方法就是pack()、unpack()。 pcak(fmt, *args)：根据格式将数据转换为固定长度的bytes类型 unpack(fmt, string)：根据格式将bytes类型转换为原本的数据 以下是常用fmt格式类型： 格式 C语言类型 Python类型 字节数大小 x 填充字节 没有值 c char 字节长度为1 1 b signed char 整数 1 B unsigned char 整数 1 ? _Bool bool 1 h short 整数 2 H unsigned short 整数 2 i int 整数 4 I unsigned int 整数 4 l long 整数 4 L unsigned long 整数 4 q long long 整数 8 Q unsigned long long 整数 8 n ssize_t 整数 N size_t 整数 f float 浮点数 4 d double 浮点数 8 s char[] 字节 p char[] 字节 P void * 整数 简单的使用示例，将数值转换为固定长度的bytes： >>> import struct >>> binInt = struct.pack(\"i\", len(\"this is message\")) >>> binInt b'\\x0f\\x00\\x00\\x00' >>> struct.unpack(\"i\", binInt) (15,) >>> 现在利用该struct模块 + json模块，我们就可以完美的解决粘包现象。 Server端代码如下： import subprocess import json import struct from socket import * # 默认直接实例化socket是IPV4 + TCP协议 server = socket() server.setsockopt(SOL_SOCKET, SO_REUSEADDR, 1) server.bind((\"localhost\", 8888)) server.listen(5) while 1: conn, clientAddr = server.accept() print(\"%s connect server\" % clientAddr[0]) while 1: try: command = conn.recv(1024) if not command: break result = subprocess.Popen( args=command.decode(\"u8\"), shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE ) # get success result successOut = result.stdout.read() # get error result errorOut = result.stderr.read() # type == bytes dataBody = successOut or errorOut # 如果请求的是文件，还可以添加诸如 fileName fileSize # 等属性 dataHeadDict = { \"dataBodyLength\": len(dataBody), \"dataBodyType\": str(type(dataBody)), } # 将字典序列化为字节 dataHead = json.dumps(dataHeadDict).encode(\"u8\") dataHeadLength = struct.pack(\"i\", len(dataHead)) # 发送数据头长度（固定为4字节）， 数据头字典，数据体信息 conn.send( dataHeadLength + \\ dataHead + \\ dataBody ) except ConnectionResetError as e: break print(\"%s close connect\" % clientAddr[0]) conn.close() Client端代码如下： import json import struct from socket import * client = socket() client.connect((\"localhost\", 8888)) while 1: command = input(\">>>\").strip() if not command: continue if command == \"exit\": break client.send(command.encode(\"u8\")) # step01：接收数据头长度，也就是数据头字典的bufsize dataHeadLength = struct.unpack(\"i\", client.recv(4))[0] # step02：提取数据头字典 dataHeadDict = json.loads(client.recv(dataHeadLength)) # step03：提取数据体长度和数据体类型 dataBodyLength, dataBodyType = dataHeadDict.values() # step04：提取数据体 dataBody = b\"\" currentRecvDataBodyLength = 0 while currentRecvDataBodyLength Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-28 17:49:56 "},"Python/Python网络编程/socketserver使用.html":{"url":"Python/Python网络编程/socketserver使用.html","title":"socketserver使用","keywords":"","body":"socketserver简介 在之前我们使用socket模块来构建服务器，但是使用该模块所编写的服务器处理请求都是串行的，即来一个处理一个，无疑这样的处理效率是十分低下的。 那么本篇文章将介绍socketserver模块的使用，它是对socket模块的更高级别封装，内部支持I/O多路复用机制，能够在最短的时间内处理更多的请求。 官方文档：点我跳转 TCP/socketserver 下面是使用socketserver模块构建TCP服务器的基本格式： import socketserver class Server(socketserver.BaseRequestHandler): def handle(self) -> None: # self.request == conn ❶ # self.client_address = clientAddr ❷ print(\"%s connect server\" % self.client_address[0]) while 1: try: data = self.request.recv(1024) if not data: break print(\"receive client data : %s\" % data.decode(\"u8\")) self.request.send(data.upper()) except ConnectionResetError as e: break print(\"%s close connect\" % self.client_address[0]) self.request.close() if __name__ == \"__main__\": server = socketserver.ThreadingTCPServer( server_address=(\"localhost\", 8888), RequestHandlerClass=Server ) # run server server.serve_forever() ❶：self.request等同于双向链接通道conn ❷：self.client_address就是Client端的地址和端口信息 建立TCP/socketserver的步骤如下： 导入socketserver模块 创建一个新的类，并继承socketserver.BaseRequestHandler，重写其handle()方法，用于处理TCP请求 写入交互逻辑 防止客户端发送空信息以致双方卡死（针对Unix平台Client端异常关闭） 防止客户端突然断开服务端抛出的ConnectionResetError异常（针对Windows平台Client端异常关闭） 实例化socketserver.ThreadingTCPServer类，并传入自定义处理TCP请求的类和绑定ip+port 调用socketserver.ThreadingTCPServer实例对象下的serve_forever()方法，启动服务 注意：socketserver模块实现的TCP服务器并不会提供粘包优化，所以需要自己手动实现。 可以看见，使用socketserver模块来构建TCP/socket服务器会简单很多，同时使用它创建的服务器还支持并发服务，而不再是串行服务。 UDP/socketserver 下面是使用socketserver模块构建UDP服务器的基本格式： import socketserver class Server(socketserver.BaseRequestHandler): def handle(self) -> None: # self.request == (message, server) ❶ # self.client_address = clientAddr ❷ data = self.request[0] server = self.request[1] print(\"receive client data : %s\" % data.decode(\"u8\")) server.sendto(data.upper(), self.client_address) if __name__ == \"__main__\": server = socketserver.ThreadingUDPServer( server_address=(\"localhost\", 8888), RequestHandlerClass=Server ) # run server server.serve_forever() ❶：self.request和TCP的self.request不同，它不是双向链接通道conn，而是包含了信息与服务端本身 ❷：self.client_address就是Client端的地址和端口信息 TCP/socketserver解决粘包 使用socketserver模块来构建能够解决粘包的TCP服务器，以远程输入命令为例。 Server端代码如下： import json import struct import socketserver import subprocess class Server(socketserver.BaseRequestHandler): def handle(self) -> None: \"\"\" 处理通信 \"\"\" print(\"%s connect server\" % self.client_address[0]) while 1: try: command = self.request.recv(1024) if not command: break self.main(command) except ConnectionResetError as e: break print(\"%s close connect\" % self.client_address[0]) self.request.close() def main(self, command): \"\"\" 通信处理的主体逻辑 \"\"\" dataBody = self.runCommand(command) sendData = self.encapsulate(dataBody) self.request.send(sendData) def runCommand(self, command): \"\"\" 运行命令，并返回结果 Args: command string: 远程传入的命令 Returns: string: 命令执行结果 \"\"\" result = subprocess.Popen( args=command.decode(\"u8\"), shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE ) successOut = result.stdout.read() errorOut = result.stderr.read() return successOut or errorOut def encapsulate(self, dataBody): \"\"\" 对命令执行结果进行封装，自定义协议解决粘包问题 Args: dataBody: 命令执行结果 Returns: string: 封装完成的结果，格式是 '消息头长度 [消息头 {消息体长度} ] 消息体' \"\"\" dataHeadDict = { \"dataBodyLength\": len(dataBody), } dataHead = json.dumps(dataHeadDict).encode(\"u8\") dataHeadLength = struct.pack(\"i\", len(dataHead)) sendData = dataHeadLength + dataHead + dataBody return sendData if __name__ == \"__main__\": server = socketserver.ThreadingTCPServer( server_address=(\"localhost\", 8888), RequestHandlerClass=Server ) # run server server.serve_forever() Client端代码如下： import json import struct from socket import * client = socket() client.connect((\"localhost\", 8888)) while 1: command = input(\">>>\").strip() if not command: continue if command == \"exit\": break client.send(command.encode(\"u8\")) # step01：接收数据头长度，也就是数据头字典的bufsize dataHeadLength = struct.unpack(\"i\", client.recv(4))[0] # step02：提取数据头字典 dataHeadDict = json.loads(client.recv(dataHeadLength)) # step03：提取数据体长度和数据体类型 dataBodyLength= dataHeadDict.get(\"dataBodyLength\") # step04：提取数据体 dataBody = b\"\" currentRecvDataBodyLength = 0 while currentRecvDataBodyLength Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-28 18:43:46 "},"Python/Python网络编程/socketserver源码.html":{"url":"Python/Python网络编程/socketserver源码.html","title":"socketserver源码","keywords":"","body":"基础源码 包含信息 socketserver源代码中基本上所有的类都会分成两部分。 server类：处理链接相关 request类：处理通信相关 我们可以看一下socketserver中使用到了哪些比较基础的模块（socketserver.py line 126 - 136）： import socket # socket基础模块 import selectors # I/O多路复用模块 import os # 操作系统接口模块 import errno # 定义符号错误码的模块 import sys # 系统相关模块 try: import threading # 多线程模块，如果平台支持 except ImportError: import dummy_threading as threading # 多线程模块的另一个版本，当平台不支持时导入该模块 from io import BufferedIOBase # 读取相关模块 from time import monotonic as time # 单调时钟模块，避免时间波动的发生 下面是定义了允许导入该模块的内容，这里就基本上是socketserver模块最常用的一些类（socketserver.py line 138 - 141）： __all__ = [\"BaseServer\", \"TCPServer\", \"UDPServer\", \"ThreadingUDPServer\", \"ThreadingTCPServer\", \"BaseRequestHandler\", \"StreamRequestHandler\", \"DatagramRequestHandler\", \"ThreadingMixIn\"] 平台扩展 接下来socketserver模块的执行，会根据不同的平台做出一些不同的区分了。 如（socketserver.py line 142 - 147）： if hasattr(os, \"fork\"): __all__.extend([\"ForkingUDPServer\",\"ForkingTCPServer\", \"ForkingMixIn\"]) if hasattr(socket, \"AF_UNIX\"): __all__.extend([\"UnixStreamServer\",\"UnixDatagramServer\", \"ThreadingUnixStreamServer\", \"ThreadingUnixDatagramServer\"]) 这里主要的意思是动态的为__all__属性增加一些可用于导入的类，但是这些类可以说很少用到，因此不必太在意。 上面为__all__属性增加的类还未进行实现，在何时进行实现呢？你可以在（socketserver.py line 681 - 698）找到这些类的实现，代码如下： if hasattr(os, \"fork\"): class ForkingUDPServer(ForkingMixIn, UDPServer): pass class ForkingTCPServer(ForkingMixIn, TCPServer): pass class ThreadingUDPServer(ThreadingMixIn, UDPServer): pass class ThreadingTCPServer(ThreadingMixIn, TCPServer): pass if hasattr(socket, 'AF_UNIX'): class UnixStreamServer(TCPServer): address_family = socket.AF_UNIX class UnixDatagramServer(UDPServer): address_family = socket.AF_UNIX class ThreadingUnixStreamServer(ThreadingMixIn, UnixStreamServer): pass class ThreadingUnixDatagramServer(ThreadingMixIn, UnixDatagramServer): pass 下面这两行比较重要（socketserver.py line 151 - 154），它会根据平台选择不同的I/O多路复用机制，如果是Unix平台，会采用epoll，而Windows平台则只能采用性能较低的select机制。 if hasattr(selectors, 'PollSelector'): _ServerSelector = selectors.PollSelector else: _ServerSelector = selectors.SelectSelector 其实针对不同平台实例化或添加不同的应用类在各大框架中都比较常见，socketserver模块也不仅仅只有上面一些地方会根据平台进行区分，这里只是例举几个比较重要的。 类的介绍 当socketserver源码执行至此，基本上所有常用的类都被初始化了。 那么这些类的作用到底是什么？前面已经说过，socketserver模块中主要分为两大类，我们就依照这个来进行划分。 1）处理链接相关的类： 类名 描述 父类 BaseServer 基础链接类 object TCPServer TCP协议类 BaseServer UDPServer UDP协议类 TCPServer UnixStreamServer 文件形式字节流类 TCPServer UnixDatagramServer 文件形式数据报类 UDPServer 2）处理通信相关的类： 类名 描述 父类 BaseRequestHandler 基础请求处理类 object StreamRequestHandler 字节流请求处理类 BaseRequestHandler DatagramRequestHandler 数据报请求处理类 BaseRequestHandler 除此之外，还有一些多线程以及多进程相关的类，如下所示。 1）多线程相关的类： 类名 描述 父类 ThreadingMixIn 线程工具包类 object ThreadingUDPServer 多线程UDP协议服务类 ThreadingMixIn, UDPServer ThreadingTCPServer 多线程TCP协议服务类 ThreadingMixIn, TCPServer 2）多进程相关的类： 类名 描述 父类 ForkingMixIn 进程工具包类 object ForkingUDPServer 多进程UDP协议服务类 ForkingMixIn, UDPServer ForkingTCPServer 多进程TCP协议服务类 ForkingMixIn, TCPServer 继承图示 上面所举例的类的继承关系如下所示。 1）处理链接相关的类： 2）处理通信相关的类： 3）多线程相关的类： 4）多进程相关的类： 5）总继承关系一览图： TCP/socketserver分析 实例化过程分析 有了继承关系后，我们可以看TCP服务的实例化过程，首先它的启动如下： ins = socketserver.ThreadingTCPServer((\"ip\", port), RequestHandler) # RequestHandler即我们自己写的类，需要覆写handle()方法 所以我们首先是需要找到ThreadingTCPServer类的__init__()方法，在其父类TCPServer类中能找该方法（socketserver.py line 394 - 460 ）： class TCPServer(BaseServer): address_family = socket.AF_INET # 网络家族的socket，IPV4 socket_type = socket.SOCK_STREAM # TCP协议 request_queue_size = 5 # 消息队列最大数，即backlog半链接池 allow_reuse_address = False # 重用端口，默认关闭 def __init__(self, server_address, RequestHandlerClass, bind_and_activate=True): BaseServer.__init__(self, server_address, RequestHandlerClass) self.socket = socket.socket(self.address_family, self.socket_type) if bind_and_activate: try: self.server_bind() self.server_activate() except: self.server_close() raise 在这里，它又调用了BaseServer.__init__()方法，所以我们先看一下（socketserver.py line 157 - 209）： class BaseServer: timeout = None def __init__(self, server_address, RequestHandlerClass): self.server_address = server_address # 即传入的(ip+port) self.RequestHandlerClass = RequestHandlerClass # 即我们自己传入的类 self.__is_shut_down = threading.Event() # 线程加事件锁 self.__shutdown_request = False 这里的（socketserver.py line 208）会去实例化出一把线程锁，目的是为了今后控制多个请求的处理顺序，所以暂时不用管。接着回到（socketserver.py line 394 - 460 ）的TCPServer类中__init__()方法： 首先它会实例化出一个对象 然后会判断默认参数bind_and_activate是否为True 执行self.server_bind() self.server_activate() class TCPServer(BaseServer): address_family = socket.AF_INET # 网络家族的socket，IPV4 socket_type = socket.SOCK_STREAM # TCP协议 request_queue_size = 5 # 消息队列最大数，即backlog半链接池 allow_reuse_address = False # 重用端口，默认关闭 def __init__(self, server_address, RequestHandlerClass, bind_and_activate=True): BaseServer.__init__(self, server_address, RequestHandlerClass) self.socket = socket.socket(self.address_family, self.socket_type) if bind_and_activate: # bind_and_activate是默认参数，也就是True try: self.server_bind() self.server_activate() except: self.server_close() raise 现在又需要去找self.server_bind()方法，我们要时刻铭记self是谁，self目前是ThreadingTCPServer类的实例对象，所以还需要回到ThreadingTCPServer类中寻找该方法。 最终可以在其第二父类，TCPServer中找到该方法（socketserver.py line 462 - 471 ）： def server_bind(self): # 判断是否重用端口，该属性是TCPServer类属性，默认为False，即不重用端口 if self.allow_reuse_address: self.socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1) # 绑定地址 self.socket.bind(self.server_address) # 获取socket名字，实际上就是 (\"ip\", port) self.server_address = self.socket.getsockname() 该方法执行完毕后又要去找self.server_activate()方法，老样子，先去ThreadingTCPServer类中找，找不到去第一父类ThreadingMixIn中找，依旧找不到，所以再找TCPServer类，最终在（socketserver.py line 473 - 498 ）中找到。 其实该方法就是开启监听，backlog参数为TCPServer类属性request_queue_size，为5： def server_activate(self): \"\"\"Called by constructor to activate the server. May be overridden. \"\"\" self.socket.listen(self.request_queue_size) 现在整个实例化流程已经跑完了，因为没有任何异常的发生，就不会触发self.server_bind()方法。 该方法定义在TCPServer中（socketserver.py line 481 - 487 ），一旦实例化出错将关闭套接字对象，即停止服务器运行： def server_close(self): \"\"\"Called to clean-up the server. May be overridden. \"\"\" self.socket.close() server_forever()启动服务分析 接下来是启动服务，启动服务的代码是： ins.server_forever() 所以我们需要到ThreadingTCPServer类中去寻找该方法，最终可以在其第二父类TCPServer的父类BaseServer中找到（socketserver.py line 219 - 246 ），其实说白了该类就是使用I/O多路复用机制进行不断的死循环监听，一旦有请求过来就立即进行三次握手，创建双向链接通道： def serve_forever(self, poll_interval=0.5): # self.__is_shut_down是一把事件锁，用于控制子线程的启动顺序。 # 这里的clear()代表清除，这个不是重点，往下看。 self.__is_shut_down.clear() try: # （socketserver.py line 151 - 154）中定义了I/O多路复用的机制 # 所以这里会自动选择 with _ServerSelector() as selector: # 事件注册，可读事件，self即当前ThreadingTCPServer的实例 selector.register(self, selectors.EVENT_READ) # 该条件是BaseServer.__init__()的实例属性，默认为False # 所以下面开始死循环进行监听 while not self.__shutdown_request: # 每隔0.5秒，循环监听一次 ready = selector.select(poll_interval) # 由于该属性为False，所以不会跳出 if self.__shutdown_request: break # 一旦有客户端请求链接，便立即运行下面的方法 if ready: self._handle_request_noblock() self.service_actions() finally: self.__shutdown_request = False self.__is_shut_down.set() 如果有链接请求，则会执行self._handle_request_noblock()方法，它在哪里呢？ 其实就在BaseServer中，位于（socketserver.py line 307- 328 ）： def _handle_request_noblock(self): try: # self.get_request()方法在TCPServer中定义 # 返回值为 self.socket.accept()，也就是说它这里会返回conn和clientAddr request, client_address = self.get_request() except OSError: return # self.verify_request()方法的返回结果永远都是True，其实就是验证 # 双向链接通道和客户端地址是否合法，不用太在意 if self.verify_request(request, client_address): try: self.process_request(request, client_address) except Exception: self.handle_error(request, client_address) self.shutdown_request(request) except: self.shutdown_request(request) raise else: self.shutdown_request(request) 这里又要去找self.process_request()方法了，self是ThreadingTCPServer的实例对象，所以先去ThreadingTCPServer类中找，最终该方法可以在其第一父类ThreadingMixIn中找到（socketserver.py line 660- 669 ）。 该方法主要是针对请求验证成功后，需要进行通信的客户端，会创建一个线程来对其进行服务： def process_request(self, request, client_address): # 创建子线程任务，子线程运行self.process_request_thread()方法 # 并且传入了参数双向链接通道request以及客户端地址 t = threading.Thread(target = self.process_request_thread, args = (request, client_address)) # ThreadingMixIn的类属性，为False t.daemon = self.daemon_threads # 第一个值为False，第二个值为True。他们都是ThreadingMixIn的类属性 # 故下面会执行 if not t.daemon and self._block_on_close: if self._threads is None: self._threads = [] # 创建空列表 self._threads.append(t) # 将子线程任务添加至空列表中 t.start() # 执行子线程任务 process_request_thread()方法是子线程处理通信的方法，该方法位于ThreadingMixIn类中，在（socketserver.py line 647- 658 ）处： def process_request_thread(self, request, client_address): \"\"\"Same as in BaseServer but as a thread. In addition, exception handling is done here. \"\"\" try: self.finish_request(request, client_address) except Exception: self.handle_error(request, client_address) finally: self.shutdown_request(request) # 它不会关闭这个线程，而是将其设置为wait()状态 再来接着看self.finish_request()方法，该方法位于BaseServer类中（socketserver.py line 362- 364）： def finish_request(self, request, client_address): \"\"\"Finish one request by instantiating RequestHandlerClass.\"\"\" self.RequestHandlerClass(request, client_address, self) self.RequestHandlerClass即我们自己传入的类，现在会对其进行实例化，我们自定义的类没有__init__()方法，所以他会去寻找该自定义类的父类BaseRequestHandler（socketserver.py line 700- 735）： class BaseRequestHandler: def __init__(self, request, client_address, server): self.request = request # 双向链接通道 self.client_address = client_address # 客户端信息 self.server = server # 实例本身，self self.setup() # 一个钩子函数 try: self.handle() # 我们覆写的handle() finally: self.finish() # 一个钩子函数 def setup(self): pass def handle(self): pass def finish(self): pass 所以现在，你应该明白为什么我们自己写的类一定要覆写handle()方法了。 内部调用顺序图示 以下是实例化过程图示： 以下是启动服务过程图示： UDP/socketserver分析 关于UDP的分析这里暂时就不做了，感兴趣的朋友可以按照继承关系图和上述的分析思路自己分析实现一次。 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-29 18:12:22 "},"Python/Python并发编程/summary.html":{"url":"Python/Python并发编程/summary.html","title":"Python并发编程","keywords":"","body":" 任务处理发展史 并发与并行 线程与进程 GIL锁 threading模块使用 threading线程锁 threading.local功能介绍 multiprocessing模块使用 线程或进程通信 生产者消费者模型 使用执行器提交任务 Linux五大I/O模型 常见I/O示例演示 协程 asynic Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-07-07 16:44:40 "},"Python/Python并发编程/任务处理发展史.html":{"url":"Python/Python并发编程/任务处理发展史.html","title":"任务处理发展史","keywords":"","body":"从任务处理角度看待操作系统发展史 操作系统的作用是管理硬件，目的是为了让用户更加方便的来操控计算机底层的硬件。 可以看到操作系统对于人们操控计算机进行作业有着不可小觑的功劳，那么在早期没有操作系统的时候你能想象是什么样子吗？现在我们来看一看。 手动化时代 早期的计算机并没有操作系统，而是通过纸带来进行程序的编辑。 它有3台设备，分别是： 输入机 计算机 输出机 那个时候的程序员需要一起约定好时间，来轮流的对自己的程序进行编辑，因为那个时候的计算机在同一时刻下只能由一个人去运行和掌控，我们来看一下它的计算流程： 这个时代的计算机一次只能跑一个人的程序，即同一时刻至多只能运行一个任务，不会受到其他因素的干扰。 它的缺点非常明显，一次只能一个人使用而后面想要使用的人必须得等待前一个人用完之后才行，其执行效率非常低下。 除此之外最关键的就是人在进行与计算机交互的时候计算机的运算器是没有任何工作的，这就造成了资源上极大的浪费，那么这种浪费可以理解为I/O阻塞。 批处理系统时代 相比于前一代计算机处理任务的方式，批处系统的诞生让这一代计算机有了极大的进步，并且输入也不再使用纸带，而是采用磁带，批处理操作系统可以将多个用户的任务同时提交（但是不能同时运行）。 注意：批处理系统并不是一个真正意义上的我们现在所理解的操作系统，而仅是一种支持多任务同时提交、区分不同任务的一段代码 假设有三个程序员需要使用这台计算机，他们需要将自己的程序全部交由一个程序员让其进行人机之间的交互，那么这样就节省了三倍的时间。 但是这样的缺点也很明显，大家只能等待三个人的程序全部处理完后大家才能拿到各自的结果，这个等待过程是十分漫长的。 批处理最大的问题还是在于拥有人手动与计算机交互的过程，此时会发生I/O阻塞，那么能不能把中间的两个小人全部干掉让计算机来做他们做的事儿呢？当然可以，但是当时的人还没想到这一点，如图，缺点如下： 任务提交虽然是同时提交，但是任务执行依旧是串行执行 仍然具有人为操作，I/O时间太长 我们再来想一个问题，如果程序员A的程序出错了，它第一时间拿不到结果，输出的时候会一直卡在那，程序员B和程序员C的程序结果也不用拿了，反正都出不来。是不是很蛋疼？ 后来慢慢的经过时间的积累与技术的发展，针对这一代的批处理系统的缺点，又出现了一种新的技术。 该技术名叫SPOOLING技术，这个技术的出现让上图的两个小人下岗了。SPOOLING技术的出现极大的减少了I/O阻塞的时间。 除此之外，该代操作系统还提出了一个非常重要的思想，即多道程序设计的思想，这个技术思想目前在我们的进程中依然存在，它的主要功能就是解决了程序串行执行的问题。 也就是说： SPOOLING技术解决了人为的I/O阻塞问题 多道程序设计解决了程序串行执行的问题 如图所示： 尽管这样做的确让程序效率提高了不少，但是我们还有一个问题。 计算机中依然是批处理系统，还是要等A、B、C的程序同时出结果才能拿到最终结果，这个时间太长了，就像上面说的如果程序员A的程序出错了卡住了程序员B和C的正常程序也取不出来。 分时系统时代 为了解决上述统一化打印结果的问题，出现了分时操作系统。 该系统很形象的一个比喻就是一台计算机给A、B、C每个程序员一个键盘鼠标和显示器，大家共有一个主机各玩各的互不影响，它们都认为自己的程序是独享的并且马上就能看到自己程序的运行结果，但是实际上大家还是共用的同一个CPU，分时操作系统一言以蔽之即多用户多任务的系统。 分时操作系统到现在依然存在，并且还十分常见，比如许多人去操作同一台服务器。 这时候大家就在考虑，你丫键盘鼠标显示器啥都给我了，为啥直接给我一个主机呢？这主要还是受限于当时的计算机高额的成本造价问题，但是到了如今计算机的成本以及体积都下来后，这些都不是问题了。 个人操作系统的诞生 科技在发展，时代在进步，当科学技术达到一定的水平后，计算机造价变的越来越低廉，此时便出现了个人操作系统。 个人操作系统的出现让任务处理变的越来越迅速，每个人都能做到真正意义上的互不影响。 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-30 14:36:26 "},"Python/Python并发编程/并发与并行.html":{"url":"Python/Python并发编程/并发与并行.html","title":"并发与并行","keywords":"","body":"并发与并行 并发和并行是指操作系统处理任务的能力。 即有多个任务时是一个一个的处理？还是一次处理多个？ 并发：操作系统具有处理多个任务的能力 并行：操作系统具有同时处理多个任务的能力 并发是包含并行的，这里再提出一个伪并行的概念，就是看起来像是同时处理多个任务，但是实际上这些任务并不是被同时处理的，而是具有一定的先后次序，由于这种任务处理切换的速度太快了，所以看起来像是同时处理。 同步与异步 同步和异步是指任务的提交方式。 即当一个任务提交完成后是否需要等待任务的反馈结果出现后再去做其他的事情。 同步：当任务提交完成后，原地等待任务的返回结果，等待的过程中不做任何事 程序上面表现出来的感觉就是卡住了 异步：任务提交之后，不原地等待任务的返回结果，直接去做其他事情 当任务结果出现后会自动反馈给调用者 同步很好理解，但是异步的执行结果是怎么自动反馈的呢？ 这是因为我们在提交异步任务的时候会给任务绑定一个回调函数，当任务完成后会自动的触发该回调函数获得任务执行结果。 阻塞与非阻塞 阻塞和非阻塞是指程序的运行状态。 即程序现在是否卡住了？卡住了就是阻塞，没卡住就是非阻塞，常见I/O操作。 阻塞：当调用某个函数的时候卡住不懂了，如input()函数 非阻塞：当调用某个函数的时候，如遇见I/O操作程序并不会卡住而是去做其他的事情 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-30 16:25:28 "},"Python/Python并发编程/线程与进程.html":{"url":"Python/Python并发编程/线程与进程.html","title":"线程与进程","keywords":"","body":"进程相关 程序和进程 程序是一堆躺在硬盘中的代码，是“死”的 进程是程序被调用执行时活动的状态，是“活”的 当程序运行时必定会产生很多的数据，那么这些数据会被保存在进程中，所以： 进程是最小的资源单元 注意一点，程序只有在运行状态时才会产生进程，而不运行时就是一堆代码而已。 因此，你可以理解为每一段程序运行时都会创建一个“小房子”，这个“小房子”中存放了很多资源。 进程是由谁创建的 进程必定是由操作系统所创建，每个程序运行时都必然会产生一个进程，当然也可以产生多个进程。 如下图所示： 进程间的数据交互 不同进程之间的数据一般来说不允许共享，因为每个进程都是独立的“小房子”，每个“小房子”的资源都是自己独享的。 但我们之前学过socket，这玩意儿最早就是用来解决进程间数据交互问题的。 所以，进程之间虽然默认不支持数据交互，但是我们可以使用某些特殊手段让两个进程之间支持数据交互，这样做需要付出一些代价。 进程中的切换 一个CPU核心同一时刻最多只能运行一个进程，而多个CPU核心同一时刻可以运行多个进程，这个就是并发的体现。 一个系统中肯定有大量的进程，所以CPU需要不断的进行进程切换： 进程切换实际上是由操作系统说了算，但是进程切换的消耗是非常大的，系统需要保留当前进程的状态，进行切换后还需要将进程状态进行恢复，下面介绍一些最基本的进程切换策略。 1）先来先服务策略： 谁先创建进程，CPU就先执行谁。 该算法对一个存活时间很短的进程是相当不利的，如果一个存活时间很长的进程占用了一个CPU核心，而恰巧这个CPU又是单核的，那么其他存活时间短的进程永远也得不到CPU的眷顾了。 所以操作系统的进程调度如果仅有这一种策略是行不通的。 2）短作业优先调度策略： 那个进程作业时间短，CPU就先执行谁。 显然，单一的这种算法会让长作业进程得不到CPU眷顾，故也不能一直采取这种策略。 3）时间片轮询策略： 什么意思呢？就是说假如有多个进程，我每个进程让你运行个三五秒就切换到另一个进程运行，如此来回切换就是时间片轮转，即将时间分段，每个进程只运行一段时间。 在类Unix系统中，我们可以为某个进程分配更多的时间片。 4）多级反馈队列： 这个其实是基于时间片轮转做的，它会将当前所有的活动进程送入一个队列中，根据存活时间来为其分配到不同的队列中，进程存活时间越久，其得到CPU眷顾的次数越低。 如图所示： 其实在Unix系统中，我们可以为一个进程分配更多的时间片与更高的优先级，这里不再举例。 专业性解释 进程就是一个程序在一个数据集上的一次动态执行过程。 进程一般由以下三部分组成： 程序 数据集 进程控制块 我们编写的程序用来描述进程要完成哪些功能以及如何完成； 数据集则是程序在执行过程中所需要使用的资源； 进程控制块用来记录进程的外部特征，描述进程的执行变化过程，系统可以利用它来控制和管理进程，它是系统感知进程存在的唯一标志。 数据集提供所有程序运行时需要的资源，进程控制块用来记录程序的状态，比如说挂起被切换状态还是运行状态等等 线程相关 线程和进程 每个进程创建时也会默认至少创建一个线程，如果把进程比喻为“小房子”，那么线程就是小房子中的人，是真正干活的单元。 因此： 线程是最小的执行单元 一个进程中的所有线程都会共享该进程的所有资源。 需要注意，线程一定是包含在进程内的。 必须先有进程后才能有线程，就像线程这个人必须住在进程的房子里一样： 线程是由谁创建的 线程有2种，一般所说的线程都是系统级别创建的，但也有用户级别创建的线程，这种线程常常被称之为纤程。 它们的区别在于： 系统级线程的切换消耗较大 用户级线程的切换消耗较小 所以，对任务执行效率来说，使用 纤程 > 线程。 线程间的数据交互 线程必须存在于进程中，我们上面说过一个进程可以有多个线程，那么想当然的该进程里的所有资源都可以被位于该进程中的线程所拿到。 而跨进程之间的线程数据交互就是属于进程间的数据交互了： 线程之间的通信一定要注意线程安全问题，举个例子，假如你和你的同学均是一个线程： 你和你的同学在一个房间中，房间里有一颗糖，趁着你干活的时候你同学将糖吃掉了，你干完活回来之后肯定会以为糖果还在，当你去拿糖果的时候由于糖果不在了所以就会抛出异常。 那么这个就是线程安全问题，如何解决线程安全问题这是之后要聊到的一个话题。 线程的切换 线程切换与进程切换如出一辙，看上面的就行了。 专业性解释 1） 一个程序至少有一个进程，一个进程至少有一个线程 2） 进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率。 3） 线程在执行过程中与进程还是有区别的。每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。 4） 进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动，进程是系统进行资源分配和调度的一个独立单元。而线程是进程的一个实体，是CPU调度和分派的基本单元，它是比进程更小的能独立运行的基本单元。 5）线程自己基本上不拥有系统资源，只拥有一点在运行中必不可少的资源（如程序计数器，一组寄存器和栈）但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源。 6） 一个线程可以创建和撤销另一个线程，同一个进程中的多个线程之间可以并发执行。 切换流程 为了控制进程的执行，内核必须有能力挂起正在CPU上运行的进程，并恢复以前挂起的某个进程的执行。这种切换是由操作系统来完成的。因此可以说，任何进程都是在操作系统内核的支持下运行的，是与内核紧密相关的。 从一个进程的运行转到另一个进程上运行，这个过程中经过下面这些变化： 　　　　1. 保存处理机上下文，包括程序计数器和其他寄存器。 　　　　2. 更新PCB信息。 　　　　3. 把进程的PCB移入相应的队列，如就绪、在某事件阻塞等队列。 　　　　4. 选择另一个进程执行，并更新其PCB。 　　　　5. 更新内存管理的数据结构。 　　　　6.恢复处理机上下文。 总而言之，进程的切换非常的消耗资源。 不同的进程之间能进行切换那么不同的线程之间也必定能进行切换，既然线程是最小的执行单元那么同一进程中的线程切换的代价必然是少于进程间的切换的。 程序计数器 我们都知道软件的数据是存储在硬盘上的，这个调用的过程十分缓慢，但是在内存中就会快很多。 同时，一个线程或者进程的切换挂起状态如果是存放在内存中那么是肯定不行的，这个速度对于切换毫秒级别的线程或者进程来说速度依旧不够快。 所以在CPU旁边有了一个程序计数器的存在，由于距离CPU比较近传输状态的时间也会相应缩短。 它的大小并不是很大只有小小的1 - 2kb，主要功能就是存储了这些进程或者线程切换状态的数据。 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-30 18:22:16 "},"Python/Python并发编程/GIL锁.html":{"url":"Python/Python并发编程/GIL锁.html","title":"GIL锁","keywords":"","body":"GIL锁是什么 GIL锁是CPython所独有的，全称为Global Interpreter Lock，译为全局解释器锁。 它是CPython经常被人诟病的一个槽点，直接让CPython的多线程变成了残废。 GIL锁产生的原因 CPython中的一个线程对应于C语言中的一个线程，而CPython在执行函数时会将函数转变为可执行的字节码，如果多个线程同时运行一段字节码是很有可能出错的，为了避免这个错误所以Python使用了GIL锁限制了多线程技术。 GIL锁使得同一个时刻的同一进程下的多个线程只能有一个在CPU上执行字节码，无法将这些线程映射到不同的CPU核心上去执行。 因此CPython的GIL锁注定了其在多线程任务处理方面并没有太大优势，只能做到伪并行的效果，如下图所示： 而对比Java语言，Java语言能够将多个线程映射到不同的CPU核心上，所以他的多线程任务处理是真正的并行化的： GIL锁抢占策略 由于CPython中同一时刻一个CPU只能执行一个线程，那么其他的线程该怎么办呢？ 这个时候其他线程就要对GIL锁进行抢占了，当GIL锁死一个线程之后，并不是非要等这个线程运行完后才会释放，而是会在适当的时候就进行释放 : 该线程遇到了I/O操作 该线程的时间片轮询到了 我们可以通过sys模块查看GIL锁的释放时机： import sys print(sys.getcheckinterval()) # 100 这代表CPU接收100个指令后会切换另一条线程进行执行。 如下图所示： I/O密集型操作 CPython中，多线程技术常于I/O密集型业务中使用，如网络爬虫。 因为GIL锁的释放时机是当一个线程遇到I/O操作后就切换至另一条线程，所以对于需要频繁进行网络I/O的爬虫业务来说，CPython多线程还是很有必要的，它比多进程切换代价更小。 计算密集型操作 CPython中，多进程技术常于计算密集型业务中使用。 因为GIL锁的存在，CPython中一个进程中的多个线程无法映射到不同的CPU核心上进行执行，但是多个进程中的线程则可以映射到不同的CPU核心上，所以当实现一些计算密集型业务时，应当考虑多进程操作。 如下图所示： 为什么不干掉GIL锁 参考文章：Python 有可能删除 GIL 吗？ Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-30 19:53:38 "},"Python/Python并发编程/threading模块使用.html":{"url":"Python/Python并发编程/threading模块使用.html","title":"threading模块使用","keywords":"","body":"threading模块 Python中提供了threading模块来实现线程并发编程，官方文档如下： 官方文档 添加子线程 实例化Thread类 使用该方式新增子线程任务是比较常见的，也是推荐使用的。 简单的代码示例如下，创建3个子线程并向其添加任务，然后运行并打印它们的线程ID和线程名字： import threading import time def task(params): print(\"sub thread run\") currentThread = threading.current_thread() time.sleep(3) print(\"current subthread id : %s\\ncurrent subthread name : %s\\ncurrent subthread params : %s\" % ( currentThread.ident, currentThread.name, params)) if __name__ == \"__main__\": print(\"main thread run\") for item in range(3): subThreadIns = threading.Thread(target=task, args=(item, )) subThreadIns.start() print(\"main thread run end\") # main thread run # sub thread run # sub thread run # sub thread run # main thread run end # current subthread id : 123145534398464 # current subthread name : Thread-1 # current subthread params : 0 # current subthread id : 123145544908800 # current subthread name : Thread-3 # current subthread params : 2 # current subthread id : 123145539653632 # current subthread name : Thread-2 # current subthread params : 1 ❶：返回一个线程对象，注意args的参数必须是一个tuple，否则抛出异常，也就是说单实参必须添加逗号 ❷：start()方法是指该线程对象能够被系统调度了，但不是立即运行该线程，而是等待系统调度后才运行。所以你会看见上面子线程的运行顺序是0、2、1，另外一个线程对象只能运行一次该方法，若多次运行则抛出RunTimeError的异常。 ❸：获取当前的线程对象 ❹：获取当前线程对象的编号和名字，以及传入的参数。当线程启动时，系统都会分配给它一个随机的编号和名字 首先上述代码会先运行主线程，然后会创建3个子线程并运行。 当子线程运行的时候碰到了sleep(3)这种I/O操作时会释放掉GIL锁，并将线程执行权交还给了主线程。 然后主线程就运行完毕了，此时主线程并不会被kill掉，而是等待子线程运行结束后才会被kill掉，而子线程则是运行完毕后会被立刻kill掉。 我们可以看见，上面3个任务如果按照串行执行共会花费9.+秒时间，而通过多线程来运行，则仅需花费3.+秒的时间，极大的提升了任务处理效率。 自定义类覆写run()方法 上面的子线程任务对象是一个全局函数，我们也可以将它作为方法来进行调用。 书写一个类并继承Threading类，覆写run()方法即可： import threading import time class TaskClass(threading.Thread): # ❶ def __init__(self, params): self.params = params # ❷ super(__class__, self).__init__() def run(self): print(\"sub thread run\") currentThread = threading.currentThread() time.sleep(3) print(\"current subthread id : %s\\ncurrent subthread name : %s\\ncurrent subthread params : %s\" % ( currentThread.ident, currentThread.name, self.params)) if __name__ == \"__main__\": print(\"main thread run\") for item in range(3): subThreadIns = TaskClass(item) subThreadIns.start() print(\"main thread run end\") # main thread run # sub thread run # sub thread run # sub thread run # main thread run end # current subthread id : 123145495068672 # current subthread name : Thread-1 # current subthread params : 0 # current subthread id : 123145500323840 # current subthread name : Thread-2 # current subthread params : 1 # current subthread id : 123145505579008 # current subthread name : Thread-3 # current subthread params : 2 ❶：必须继承Threading类并调用父类的__init__()方法 ❷：传入的参数 源码浅析 为什么添加子线程有2种截然不同的方式呢？它们之间有什么区别？这些都可以从源码中找到答案。 我们从Thread类的实例看起，首先是__init__()方法（threading.py line 738 - 800），它主要做了一些初始化的准备工作： class Thread: _initialized = False _exc_info = _sys.exc_info def __init__(self, group=None, target=None, name=None, args=(), kwargs=None, *, daemon=None): # 如果group不是None，就会抛出断言异常 assert group is None, \"group argument must be None for now\" # 如果kwargs是None，则构造一个空字典 if kwargs is None: kwargs = {} # 传入的执行任务的函数或者None self._target = target # 线程名字 self._name = str(name or _newname()) # 任务函数传入的元组参数 self._args = args # 任务函数传入的关键字参数 self._kwargs = kwargs # 是否是守护线程启动，如果不是None则以守护线程模式启动 if daemon is not None: self._daemonic = daemon # 如果是None，则继承当前线程的守护模式 else: self._daemonic = current_thread().daemon # 线程编号 self._ident = None # 锁定状态，None self._tstate_lock = None # 一把Event事件锁 self._started = Event() # 是否停止运行的标志位 self._is_stopped = False # 初始化状态改为True self._initialized = True self._stderr = _sys.stderr _dangling.add(self) 参数释义： group：应该为None，为了日后扩展ThreadGroup类而保留的 target：传入一个可调用对象，即线程任务task，默认为None，即可以不进行传入 name：线程启动时将不再由系统分配线程名称，而是自定义，默认情况下，系统分配的线程名称会由 \"Thread-N\" 的格式构成一个唯一的名称，其中 N 是小的十进制数 args：用于调用目标函数的参数元组，默认是()空元组，你必须传入一个元组 kwargs：用于调用目标函数的关键字参数字典，默认是None，你必须传入一个字典 daemon：命名关键字参数，应当传入一个布尔值，默认为None，它会指定该线程是否是以守护线程模式启动，如果为None，该线程将继承当前线程的守护模式属性 接下来看start()方法，它是告知系统当前线程完成调度，可随时启用的方法（threading.py line 828 - 851）： def start(self): # 如果初始状态不为True，则抛出异常 if not self._initialized: raise RuntimeError(\"thread.__init__() not called\") # 判断当前线程是否被锁住，如果被锁住则抛出异常 if self._started.is_set(): raise RuntimeError(\"threads can only be started once\") with _active_limbo_lock: _limbo[self] = self try: # 执行引导 _start_new_thread(self._bootstrap, ()) except Exception: with _active_limbo_lock: del _limbo[self] raise self._started.wait() 这里关键是看self._bootstrap()方法，该该方法位于（threading.py line 870 - 888），看看它会做什么事情： def _bootstrap(self): try: self._bootstrap_inner() except: if self._daemonic and _sys is None: return raise 继续找self._bootstrap_inner()方法，该该方法位于（threading.py line 901 - 964）。 在该方法的916行时，它会执行run()方法： def _bootstrap_inner(self): ... try: # 执行run self.run() except SystemExit: pass except: ... 如果此时你按照第二种添加子线程的方式，则直接会运行被子类TaskClass覆写的run()方法。 如果是第一种添加子线程的方式，则还需要往里面看（threading.py line 835 - 868）： def run(self): try: # self._target = 我们自己传递的可调用对象task if self._target: self._target(*self._args, **self._kwargs) finally: del self._target, self._args, self._kwargs 至此可以发现，不管是使用哪一种方式添加子线程，都会运行5个方法。 所以说它们内部实现其实都是一样的，没什么特别的，也不要觉得它特别神奇。 threading模块方法大全 以下是threading模块提供的类或方法： 类或方法 描述 返回值 threading.Thread(target, args, kwargs) 创建并返回一个线程对象 threadObject threading.Timer(interval, function, args, kwargs) 创建并返回一个延迟启动的线程对象 threadObject threading.active_count() 获取当前进程下存活的线程数量 int threading.enumerate() 查看当前进程存活了的所有线程对象，以列表形式返回 [threadObject, ...] threading.main_thread() 获取主线程对象 threadObject threading.current_thread() 获取当前正在执行的线程对象 threadObject threading.currentThread() 获取当前正在执行的线程对象 threadObject threading.get_ident() 获取当前正在执行的线程对象的编号 int 下面我将使用该代码对上述功能进行演示： import threading import time class TaskClass(threading.Thread): def run(self): time.sleep(3) pass if __name__ == \"__main__\": for i in range(3): subThreadIns = TaskClass() subThreadIns.start() 1）获取当前进程下存活的线程数量： print(threading.active_count()) # 4 2）查看当前进程存活了的所有线程对象，以列表形式返回： print(threading.enumerate()) # [, , , ] 3）获取主线程对象： print(threading.main_thread()) # 4）获取当前正在执行的线程对象： print(threading.currentThread()) # 5）获取当前正在执行的线程对象的编号： print(threading.get_ident()) # 4380034496 threadObject方法大全 以下是针对线程对象提供的属性或者方法： 方法/属性 描述 返回值 threadObject.start() 通知系统该线程调度完毕，可以随时进行启动，一个线程对象只能运行一次该方法，若多次运行则抛出RunTimeError异常 ... threadObject.join(timeout=None) 主线程默认会等待子线程运行结束后再继续执行，timeou为等待的秒数，如不设置该参数则一直等待。 ... threadObject.getName() 获取线程对象的名字 str threadObject.setName(name) 设置线程对象的名字 None threadObject.is_alive() 查看线程对象是否存活 bool threadObject.isAlive() 查看线程对象是否存活，不推荐使用 bool threadObject.isDaemon() 查看线程对象是否是守护线程 bool threadObject.setDaemon() 设置线程对象为守护线程，主线程运行完毕之后设置为守护线程的子线程便立即结束执行 None threadObject.ident 获取线程对象的编号 int threadObject.name 获取或者设置线程对象的名字 str or None threadObject.daemon 查看线程对象是否是守护线程 bool 主线程阻塞 默认情况下，当子线程启动后，主线程会依旧往下运行而不是等待所有的子线程运行完毕后再继续往下运行。 如图所示，主线程在运行结束后并不会被理解kill掉，而是所有的子线程运行完毕后主线程才会被kill掉： 我们可以利用threadObject.join(timeout=None)来让主线程等待子线程运行完毕后再继续向下运行，timeout为等待的秒数，如不设置该参数则一直等待。 如图所示，这是没有设置timeout的示意图，主线程必须等待所有子线程运行完毕后再接着运行： 代码示例： import threading import time class TaskClass(threading.Thread): def run(self): thName = threading.current_thread().name print(\"%s start run\" % thName) time.sleep(3) print(\"%s run end\" % thName) if __name__ == \"__main__\": print(\"main thread start run\") threadLst = [] for i in range(3): threadLst.append(TaskClass()) for ins in threadLst: ins.start() # 开始运行所有子线程 for ins in threadLst: ins.join() # 让主线程等待所有子线程运行完毕后再接着运行，注意，设置主线程等待的子线程必须处于活跃状态 print(\"main thread carry on run\") print(\"main thread run end\") # main thread start run # Thread-1 start run # Thread-2 start run # Thread-3 start run # Thread-1 run end # Thread-2 run end # Thread-3 run end # main thread carry on run # main thread run end 守护线程 守护线程是指当主线程运行完毕后，子线程是否还要继续运行。 默认threadObject.setDaemon()为None，也就是False，即当前主线程运行完毕后，子线程依旧可以接着运行。 如果threadObject.setDaemon()为True，则当前主线程运行完毕后，子线程即使没有运行完毕也会结束运行。 代码示例： import threading import time class TaskClass(threading.Thread): def run(self): thName = threading.current_thread().name print(\"%s start run\" % thName) time.sleep(3) print(\"%s run end\" % thName) if __name__ == \"__main__\": print(\"main thread start run\") threadLst = [] for i in range(3): threadLst.append(TaskClass()) for ins in threadLst: # 注意，守护线程的设置必须在线程未启动时设置 ins.setDaemon(True) ins.start() print(\"main thread carry on run\") print(\"main thread run end\") # main thread start run # Thread-1 start run # Thread-2 start run # Thread-3 start run # main thread carry on run # main thread run end join()与setDaemon(True)共存 如果同时设置setDaemon(True)与join()方法会怎么样呢？有两种情况： join()方法没有设置timeout（没有设置即表示死等）或者timeout的时间比子线程作业时间要长，这代表子线程会死在主线程之前，setDaemon(True)也就没有了意义，即失效了 join()设置了timeout并且timeout的时间比子线程作业时间要短，这代表主线程会死在子线程之前，setDaemon(True)生效，子线程会跟着主线程一起死亡。 情况一： import threading import time class TaskClass(threading.Thread): def run(self): thName = threading.current_thread().name print(\"%s start run\" % thName) time.sleep(3) print(\"%s run end\" % thName) if __name__ == \"__main__\": subThread = TaskClass() subThread.setDaemon(True) # 主线程运行完后会立即终止子线程的运行。但是由于有join()，故不生效。 subThread.start() subThread.join() # 主线程必须等待子线程运行结束后再接着运行 print(\"main thread run end\") # Thread-1 start run # Thread-1 run end # main thread run end 情况2： import threading import time class TaskClass(threading.Thread): def run(self): thName = threading.current_thread().name print(\"%s start run\" % thName) time.sleep(3) print(\"%s run end\" % thName) if __name__ == \"__main__\": subThread = TaskClass() subThread.setDaemon(True) # 主线程运行完后会立即终止子线程的运行。但是由于有join()，故不生效。 subThread.start() subThread.join(1) # 主线程必须等待子线程运行结束后再接着运行，只等待1s print(\"main thread run end\") # Thread-1 start run # main thread run end 线程延迟启动 使用threading模块中提供的Timer类，可让子线程延迟启动，如下所示： import threading import time def task(): print(\"sub thread start run\") time.sleep(3) print(\"sub thread run end\") if __name__ == \"__main__\": print(\"main thread run\") t1 = threading.Timer(interval=3, function=task) t1.start() # 3秒后才启动子线程 t1.join() print(\"main thread run end\") # main thread run # sub thread start run # sub thread run end # main thread run end 如果要用类的形式，则可以继承threading.Timer()类，并修改self.function属性，个人极度不推荐这样做。 如下所示，在不知道某一个方法怎么使用时扒扒源码看一看，翻翻官方文档就大概能了解： import threading import time class TaskClass(threading.Timer): def __init__(self, *args, **kwargs): # 必须要修改function为你想执行的方法 super(__class__, self).__init__(*args, **kwargs) self.function = self.task def task(self, x, y): print(\"sub thread start run\") time.sleep(3) print(\"parmas %s %s\" % (x, y)) print(\"sub thread run end\") if __name__ == \"__main__\": # 必须传入一个None t1 = TaskClass(interval=3, function=None, args=(1, 2)) t1.start() t1.join() print(\"main thread run end\") # sub thread start run # parmas 1 2 # sub thread run end # main thread run end 多线程编程应用场景 由于GIL锁的存在，Python中对于I/O操作来说可以使用多线程编程，如果是计算密集型的操作则不应该使用多线程进行处理，因为没有I/O操作就不能通过I/O切换来执行其他线程，故对于计算密集型的操作来说多线程没有什么优势，甚至还可能比普通串行还慢（因为涉及到线程切换，虽然是毫秒级别，但是计算的数值越大这个切换也就越密集，GIL锁是100个CPU指令切换一次的） 注意：我们是在Python2版本下进行此次测试，Python3版本确实相差不大，但是，从本质上来说依然是这样的。 计算密集型程序的普通串行运行时间： import threading import time num = 0 def add(): global num for i in range(10000000): # 一千万次 num += 1 def sub(): global num for i in range(10000000): # 一千万次 num -= 1 if __name__ == '__main__': start_time = time.time() add() sub() end_time = time.time() print(\"执行时间:\",end_time - start_time) # ==== 执行结果 ==== 三次采集 \"\"\" 大约在 1.3 - 1.4 秒 \"\"\" 计算密集型程序的多线程并发运行时间： # coding:utf-8 import threading import time num = 0 def add(): global num for i in range(10000000): # 一千万次 num += 1 def sub(): global num for i in range(10000000): # 一千万次 num -= 1 if __name__ == '__main__': start_time = time.time() t1 = threading.Thread(target=add,) t2 = threading.Thread(target=sub,) t1.start() t2.start() t1.join() t2.join() end_time = time.time() print(u\"执行时间:\",end_time - start_time) # ==== 执行结果 ==== 三次采集 \"\"\" 大约 4 - 5 秒 \"\"\" Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-07-02 21:02:04 "},"Python/Python并发编程/threading线程锁.html":{"url":"Python/Python并发编程/threading线程锁.html","title":"threading线程锁","keywords":"","body":"前言 本章节将继续围绕threading模块讲解，基本上是纯理论偏多。 对于日常开发者来讲很少会使用到本章节的内容，但是对框架作者等是必备知识，同时也是高频的面试常见问题。 官方文档 线程安全 线程安全是多线程或多进程编程中的一个概念，在拥有共享数据的多条线程并行执行的程序中，线程安全的代码会通过同步机制保证各个线程都可以正常且正确的执行，不会出现数据污染等意外情况。 线程安全的问题最主要还是由线程切换导致的，比如一个房间（进程）中有10颗糖（资源），除此之外还有3个小人（1个主线程、2个子线程），当小人A吃了3颗糖后被系统强制进行休息时他认为还剩下7颗糖，而当小人B工作后又吃掉了3颗糖，那么当小人A重新上岗时会认为糖还剩下7颗，但是实际上只有4颗了。 上述例子中线程A和线程B的数据不同步，这就是线程安全问题，它可能导致非常严重的意外情况发生，我们按下面这个示例来进行说明。 下面有一个数值num初始值为0，我们开启2条线程： 线程1对num进行一千万次+1的操作 线程2对num进行一千万次-1的操作 结果可能会令人咋舌，num最后并不是我们所想象的结果0： import threading num = 0 def add(): global num for i in range(10_000_000): num += 1 def sub(): global num for i in range(10_000_000): num -= 1 if __name__ == \"__main__\": subThread01 = threading.Thread(target=add) subThread02 = threading.Thread(target=sub) subThread01.start() subThread02.start() subThread01.join() subThread02.join() print(\"num result : %s\" % num) # 结果三次采集 # num result : 669214 # num result : -1849179 # num result : -525674 上面这就是一个非常好的案例，想要解决这个问题就必须通过锁来保障线程切换的时机。 需要我们值得留意的是，在Python基本数据类型中list、tuple、dict本身就是属于线程安全的，所以如果有多个线程对这3种容器做操作时，我们不必考虑线程安全问题。 　　 锁的作用 锁是Python提供给我们能够自行操控线程切换的一种手段，使用锁可以让线程的切换变的有序。 一旦线程的切换变的有序后，各个线程之间对数据的访问、修改就变的可控，所以若要保证线程安全，就必须使用锁。 threading模块中提供了5种最常见的锁，下面是按照功能进行划分： 同步锁：lock（一次只能放行一个） 递归锁：rlock（一次只能放行一个） 条件锁：condition（一次可以放行任意个） 事件锁：event（一次全部放行） 信号量锁：semaphore（一次可以放行特定个） Lock() 同步锁 基本介绍 Lock锁的称呼有很多，如： 同步锁 互斥锁 它们是什么意思呢？如下所示： 互斥指的是某一资源同一时刻仅能有一个访问者对其进行访问，具有唯一性和排他性，但是互斥无法限制访问者对资源的访问顺序，即访问是无序的 同步是指在互斥的基础上（大多数情况），通过其他机制实现访问者对资源的有序访问 同步其实已经实现了互斥，是互斥的一种更为复杂的实现，因为它在互斥的基础上实现了有序访问的特点 下面是threading模块与同步锁提供的相关方法： 方法 描述 threading.Lock() 返回一个同步锁对象 lockObject.acquire(blocking=True, timeout=1) 上锁，当一个线程在执行被上锁代码块时，将不允许切换到其他线程运行，默认锁失效时间为1秒 lockObject.release() 解锁，当一个线程在执行未被上锁代码块时，将允许系统根据策略自行切换到其他线程中运行 lockObject.locaked() 判断该锁对象是否处于上锁状态，返回一个布尔值 使用方式 同步锁一次只能放行一个线程，一个被加锁的线程在运行时不会将执行权交出去，只有当该线程被解锁时才会将执行权通过系统调度交由其他线程。 如下所示，使用同步锁解决最上面的问题： import threading num = 0 def add(): lock.acquire() global num for i in range(10_000_000): num += 1 lock.release() def sub(): lock.acquire() global num for i in range(10_000_000): num -= 1 lock.release() if __name__ == \"__main__\": lock = threading.Lock() subThread01 = threading.Thread(target=add) subThread02 = threading.Thread(target=sub) subThread01.start() subThread02.start() subThread01.join() subThread02.join() print(\"num result : %s\" % num) # 结果三次采集 # num result : 0 # num result : 0 # num result : 0 这样这个代码就完全变成了串行的状态，对于这种计算密集型I/O业务来说，还不如直接使用串行化单线程执行来得快，所以这个例子仅作为一个示例，不能概述锁真正的用途。 死锁现象 对于同步锁来说，一次acquire()必须对应一次release()，不能出现连续重复使用多次acquire()后再重复使用多次release()的操作，这样会引起死锁造成程序的阻塞，完全不动了，如下所示： import threading num = 0 def add(): lock.acquire() # 上锁 lock.acquire() # 死锁 # 不执行 global num for i in range(10_000_000): num += 1 lock.release() lock.release() def sub(): lock.acquire() # 上锁 lock.acquire() # 死锁 # 不执行 global num for i in range(10_000_000): num -= 1 lock.release() lock.release() if __name__ == \"__main__\": lock = threading.Lock() subThread01 = threading.Thread(target=add) subThread02 = threading.Thread(target=sub) subThread01.start() subThread02.start() subThread01.join() subThread02.join() print(\"num result : %s\" % num) with语句 由于threading.Lock()对象中实现了__enter__()与__exit__()方法，故我们可以使用with语句进行上下文管理形式的加锁解锁操作： import threading num = 0 def add(): with lock: # 自动加锁 global num for i in range(10_000_000): num += 1 # 自动解锁 def sub(): with lock: # 自动加锁 global num for i in range(10_000_000): num -= 1 # 自动解锁 if __name__ == \"__main__\": lock = threading.Lock() subThread01 = threading.Thread(target=add) subThread02 = threading.Thread(target=sub) subThread01.start() subThread02.start() subThread01.join() subThread02.join() print(\"num result : %s\" % num) # 结果三次采集 # num result : 0 # num result : 0 # num result : 0 RLock() 递归锁 基本介绍 递归锁是同步锁的一个升级版本，在同步锁的基础上可以做到连续重复使用多次acquire()后再重复使用多次release()的操作，但是一定要注意加锁次数和解锁次数必须一致，否则也将引发死锁现象。 下面是threading模块与递归锁提供的相关方法： 方法 描述 threading.RLock() 返回一个递归锁对象 lockObject.acquire(blocking=True, timeout=1) 上锁，当一个线程在执行被上锁代码块时，将不允许切换到其他线程运行，默认锁失效时间为1秒 lockObject.release() 解锁，当一个线程在执行未被上锁代码块时，将允许系统根据策略自行切换到其他线程中运行 lockObject.locaked() 判断该锁对象是否处于上锁状态，返回一个布尔值 使用方式 以下是递归锁的简单使用，下面这段操作如果使用同步锁则会发生死锁现象，但是递归锁不会： import threading num = 0 def add(): lock.acquire() lock.acquire() global num for i in range(10_000_000): num += 1 lock.release() lock.release() def sub(): lock.acquire() lock.acquire() global num for i in range(10_000_000): num -= 1 lock.release() lock.release() if __name__ == \"__main__\": lock = threading.RLock() subThread01 = threading.Thread(target=add) subThread02 = threading.Thread(target=sub) subThread01.start() subThread02.start() subThread01.join() subThread02.join() print(\"num result : %s\" % num) # 结果三次采集 # num result : 0 # num result : 0 # num result : 0 with语句 由于threading.RLock()对象中实现了__enter__()与__exit__()方法，故我们可以使用with语句进行上下文管理形式的加锁解锁操作： import threading num = 0 def add(): with lock: # 自动加锁 global num for i in range(10_000_000): num += 1 # 自动解锁 def sub(): with lock: # 自动加锁 global num for i in range(10_000_000): num -= 1 # 自动解锁 if __name__ == \"__main__\": lock = threading.RLock() subThread01 = threading.Thread(target=add) subThread02 = threading.Thread(target=sub) subThread01.start() subThread02.start() subThread01.join() subThread02.join() print(\"num result : %s\" % num) # 结果三次采集 # num result : 0 # num result : 0 # num result : 0 Condition() 条件锁 基本介绍 条件锁是在递归锁的基础上增加了能够暂停线程运行的功能。并且我们可以使用wait()与notify()来控制线程执行的个数。 注意：条件锁可以自由设定一次放行几个线程。 下面是threading模块与条件锁提供的相关方法： 方法 描述 threading.Condition() 返回一个条件锁对象 lockObject.acquire(blocking=True, timeout=1) 上锁，当一个线程在执行被上锁代码块时，将不允许切换到其他线程运行，默认锁失效时间为1秒 lockObject.release() 解锁，当一个线程在执行未被上锁代码块时，将允许系统根据策略自行切换到其他线程中运行 lockObject.wait(timeout=None) 将当前线程设置为“等待”状态，只有该线程接到“通知”或者超时时间到期之后才会继续运行，在“等待”状态下的线程将允许系统根据策略自行切换到其他线程中运行 lockObject.wait_for(predicate, timeout=None) 将当前线程设置为“等待”状态，只有该线程的predicate返回一个True或者超时时间到期之后才会继续运行，在“等待”状态下的线程将允许系统根据策略自行切换到其他线程中运行。注意：predicate参数应当传入一个可调用对象，且返回结果为bool类型 lockObject.notify(n=1) 通知一个当前状态为“等待”的线程继续运行，也可以通过参数n通知多个 lockObject.notify_all() 通知所有当前状态为“等待”的线程继续运行 使用方式 下面这个案例会启动10个子线程，并且会立即将10个子线程设置为等待状态。 然后我们可以发送一个或者多个通知，来恢复被等待的子线程继续运行： import threading currentRunThreadNumber = 0 maxSubThreadNumber = 10 def task(): global currentRunThreadNumber thName = threading.currentThread().name condLock.acquire() # 上锁 print(\"start and wait run thread : %s\" % thName) condLock.wait() # 暂停线程运行、等待唤醒 currentRunThreadNumber += 1 print(\"carry on run thread : %s\" % thName) condLock.release() # 解锁 if __name__ == \"__main__\": condLock = threading.Condition() for i in range(maxSubThreadNumber): subThreadIns = threading.Thread(target=task) subThreadIns.start() while currentRunThreadNumber with语句 由于threading.Condition()对象中实现了__enter__()与__exit__()方法，故我们可以使用with语句进行上下文管理形式的加锁解锁操作： import threading currentRunThreadNumber = 0 maxSubThreadNumber = 10 def task(): global currentRunThreadNumber thName = threading.currentThread().name with condLock: print(\"start and wait run thread : %s\" % thName) condLock.wait() # 暂停线程运行、等待唤醒 currentRunThreadNumber += 1 print(\"carry on run thread : %s\" % thName) if __name__ == \"__main__\": condLock = threading.Condition() for i in range(maxSubThreadNumber): subThreadIns = threading.Thread(target=task) subThreadIns.start() while currentRunThreadNumber Event() 事件锁 基本介绍 事件锁是基于条件锁来做的，它与条件锁的区别在于一次只能放行全部，不能放行任意个数量的子线程继续运行。 我们可以将事件锁看为红绿灯，当红灯时所有子线程都暂停运行，并进入“等待”状态，当绿灯时所有子线程都恢复“运行”。 下面是threading模块与事件锁提供的相关方法： 方法 描述 threading.Event() 返回一个事件锁对象 lockObject.clear() 将事件锁设为红灯状态，即所有线程暂停运行 lockObject.is_set() 用来判断当前事件锁状态，红灯为False，绿灯为True lockObject.set() 将事件锁设为绿灯状态，即所有线程恢复运行 lockObject.wait(timeout=None) 将当前线程设置为“等待”状态，只有该线程接到“绿灯通知”或者超时时间到期之后才会继续运行，在“等待”状态下的线程将允许系统根据策略自行切换到其他线程中运行 使用方式 事件锁不能利用with语句来进行使用，只能按照常规方式。 如下所示，我们来模拟线程和红绿灯的操作，红灯停，绿灯行： import threading maxSubThreadNumber = 3 def task(): thName = threading.currentThread().name print(\"start and wait run thread : %s\" % thName) eventLock.wait() # 暂停运行，等待绿灯 print(\"green light, %s carry on run\" % thName) print(\"red light, %s stop run\" % thName) eventLock.wait() # 暂停运行，等待绿灯 print(\"green light, %s carry on run\" % thName) print(\"sub thread %s run end\" % thName) if __name__ == \"__main__\": eventLock = threading.Event() for i in range(maxSubThreadNumber): subThreadIns = threading.Thread(target=task) subThreadIns.start() eventLock.set() # 设置为绿灯 eventLock.clear() # 设置为红灯 eventLock.set() # 设置为绿灯 # start and wait run thread : Thread-1 # start and wait run thread : Thread-2 # start and wait run thread : Thread-3 # green light, Thread-1 carry on run # red light, Thread-1 stop run # green light, Thread-1 carry on run # sub thread Thread-1 run end # green light, Thread-3 carry on run # red light, Thread-3 stop run # green light, Thread-3 carry on run # sub thread Thread-3 run end # green light, Thread-2 carry on run # red light, Thread-2 stop run # green light, Thread-2 carry on run # sub thread Thread-2 run end Semaphore() 信号量锁 基本介绍 信号量锁也是根据条件锁来做的，它与条件锁和事件锁的区别如下： 条件锁：一次可以放行任意个处于“等待”状态的线程 事件锁：一次可以放行全部的处于“等待”状态的线程 信号量锁：通过规定，成批的放行特定个处于“上锁”状态的线程 下面是threading模块与信号量锁提供的相关方法： 方法 描述 threading.Semaphore() 返回一个信号量锁对象 lockObject.acquire(blocking=True, timeout=1) 上锁，当一个线程在执行被上锁代码块时，将不允许切换到其他线程运行，默认锁失效时间为1秒 lockObject.release() 解锁，当一个线程在执行未被上锁代码块时，将允许系统根据策略自行切换到其他线程中运行 使用方式 以下是使用示例，你可以将它当做一段限宽的路段，每次只能放行相同数量的线程： import threading import time maxSubThreadNumber = 6 def task(): thName = threading.currentThread().name semaLock.acquire() print(\"run sub thread %s\" % thName) time.sleep(3) semaLock.release() if __name__ == \"__main__\": # 每次只能放行2个 semaLock = threading.Semaphore(2) for i in range(maxSubThreadNumber): subThreadIns = threading.Thread(target=task) subThreadIns.start() # run sub thread Thread-1 # run sub thread Thread-2 # run sub thread Thread-3 # run sub thread Thread-4 # run sub thread Thread-6 # run sub thread Thread-5 with语句 由于threading.Semaphore()对象中实现了__enter__()与__exit__()方法，故我们可以使用with语句进行上下文管理形式的加锁解锁操作： import threading import time maxSubThreadNumber = 6 def task(): thName = threading.currentThread().name with semaLock: print(\"run sub thread %s\" % thName) time.sleep(3) if __name__ == \"__main__\": semaLock = threading.Semaphore(2) for i in range(maxSubThreadNumber): subThreadIns = threading.Thread(target=task) subThreadIns.start() 锁关系浅析 上面5种锁可以说都是基于同步锁来做的，这些你都可以从源码中找到答案。 首先来看RLock递归锁，递归锁的实现非常简单，它的内部会维护着一个计数器，当计数器不为0的时候该线程不能被I/O操作和时间轮询机制切换。但是当计数器为0的时候便不会如此了： def __init__(self): self._block = _allocate_lock() self._owner = None self._count = 0 # 计数器 而Condition条件锁的内部其实是有两把锁的，一把底层锁（同步锁）一把高级锁(递归锁)。 低层锁的解锁方式有两种，使用wait()方法会暂时解开底层锁同时加上一把高级锁，只有当接收到别的线程里的notfiy()后才会解开高级锁和重新上锁低层锁，也就是说条件锁底层是根据同步锁和递归锁的不断切换来进行实现的： def __init__(self, lock=None): if lock is None: lock = RLock() # 可以看到条件锁的内部是基于递归锁，而递归锁又是基于同步锁来做的 self._lock = lock self.acquire = lock.acquire self.release = lock.release try: self._release_save = lock._release_save except AttributeError: pass try: self._acquire_restore = lock._acquire_restore except AttributeError: pass try: self._is_owned = lock._is_owned except AttributeError: pass self._waiters = _deque() Event事件锁内部是基于条件锁来做的： class Event: def __init__(self): self._cond = Condition(Lock()) # 实例化出了一个条件锁。 self._flag = False def _reset_internal_locks(self): # private! called by Thread._reset_internal_locks by _after_fork() self._cond.__init__(Lock()) def is_set(self): \"\"\"Return true if and only if the internal flag is true.\"\"\" return self._flag isSet = is_set Semaphore信号量锁内部也是基于条件锁来做的： class Semaphore: def __init__(self, value=1): if value = 0\") self._cond = Condition(Lock()) # 可以看到，这里是实例化出了一个条件锁 self._value = value 基本练习题 条件锁的应用 需求：一个空列表，两个线程轮番往里面加值（一个加偶数，一个加奇数），最终让该列表中的值为 1 - 100 ，且是有序排列的。 import threading def even(): \"\"\"加偶数\"\"\" with condLock: # 必须先启动加奇数 condLock.wait() for i in range(2, 101, 2): lst.append(i) condLock.notify() condLock.wait() def odd(): \"\"\"加奇数\"\"\" with condLock: for i in range(1, 101, 2): lst.append(i) condLock.notify() condLock.wait() condLock.notify() if __name__ == \"__main__\": lst = [] condLock = threading.Condition() addEvenTask = threading.Thread(target=even) addOddTask = threading.Thread(target=odd) addEvenTask.start() addOddTask.start() addEvenTask.join() addOddTask.join() print(lst) 事件锁的应用 有2个任务线程来扮演李白和杜甫，如何让他们一人一句进行对答？文本如下： 杜甫：老李啊，来喝酒！ 李白：老杜啊，不喝了我喝不下了！ 杜甫：老李啊，再来一壶？ 杜甫：...老李？ 李白：呼呼呼...睡着了.. 代码如下： import threading def libai(): event.wait() print(\"李白：老杜啊，不喝了我喝不下了！\") event.set() event.clear() event.wait() print(\"李白：呼呼呼...睡着了..\") def dufu(): print(\"杜甫：老李啊，来喝酒！\") event.set() event.clear() event.wait() print(\"杜甫：老李啊，再来一壶？\") print(\"杜甫：...老李？\") event.set() if __name__ == '__main__': event = threading.Event() t1 = threading.Thread(target=libai) t2 = threading.Thread(target=dufu) t1.start() t2.start() t1.join() t2.join() Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-07-03 15:00:50 "},"Python/Python并发编程/threading.local功能介绍.html":{"url":"Python/Python并发编程/threading.local功能介绍.html","title":"threading.local功能介绍","keywords":"","body":"threading.local() threading.local()方法可以让每个线程都拥有一些自己独立的数据，这些数据是其他线程访问不到的。 如图所示： 或者用另外一种更形象的比喻更加的贴切，将一个进程比喻成一个公司，该进程下的线程比喻成公司的员工，而将threading.local()比喻为公司的储物柜，每个员工都有一个单独的柜格，且每个员工也只能访问自己的柜格。 如图所示： 那么这个东西到底有什么作用？举个例子，当你使用迅雷进行多线程下载时，每个线程的下载进度是不一样的，那么这个下载进度如何进行存储就显得尤为重要。 数据的存储一定是方便数据的取出，存储结构做的好，查找取出数据的速度才会更快。 threading.local()的设计思想其实在flask框架的上下文管理机制中也会体现到，两者基本如出一辙，所以现在了解threading.local()的原理后对flask框架的源码阅读也会变得轻松。 基本使用 下面是基本使用，使用步骤如下： 储物柜 = threading.local() 在线程下使用 储物柜.物品名称 = 物品 即可，以后对于该物品只有该线程可以获取 获取或者使用时，直接使用 储物柜.物品名称 即可，若要获取的物品不是该线程存放的，则会抛出异常 示例案例： import threading def jack(article): locker.rose = article print(locker.rose) # 正常取出 print(locker.food) # 抛出异常 def ken(article): locker.food = article print(locker.food) # 正常取出 print(locker.rose) # 抛出异常 if __name__ == \"__main__\": locker = threading.local() jackTask = threading.Thread(target=jack, args=(\"rose\",)) kenTask = threading.Thread(target=ken, args=(\"food\",)) jackTask.start() kenTask.start() # rose # AttributeError: '_thread._local' object has no attribute 'food' # food # AttributeError: '_thread._local' object has no attribute 'rose' 原理分析 我们可以自己做一个全局字典，来实现类似的功能，字典格式如下： locker = { \"线程ID\" : {\"物品名称\" : \"物品本身\"}, \"线程ID\" : {\"物品名称\" : \"物品本身\"}, \"线程ID\" : {\"物品名称\" : \"物品本身\"}, } 如下所示： import threading def task(article): thId = threading.get_ident() # 开始存放东西 locker[thId] = { \"rose\": article } # 取出东西 print(locker[thId][\"rose\"]) if __name__ == \"__main__\": locker = {} subThreadIns = threading.Thread(target=task, args=(\"rose\",)) subThreadIns.start() # rose 代码优化 上面这样存取东西是不是显得特别麻烦？所以我们可以定义一个类，让这个储物柜的操作变的更加简单。 如下所示： import threading class Locker: locker = {} def __getattr__(self, name): \"\"\"当试图使用.访问对象属性且找不到该属性时触发该方法\"\"\" ident = threading.get_ident() return __class__.locker[ident][name] def __setattr__(self, name, value): \"\"\"当试图使用.修改或添加对象属性时触发该方法\"\"\" ident = threading.get_ident() if ident not in __class__.locker: __class__.locker[ident] = {} __class__.locker[ident].update({name: value}) def task(article): # 开始存放东西 locker.rose = article print(locker.rose) if __name__ == \"__main__\": locker = Locker() subThreadIns = threading.Thread(target=task, args=(\"rose\",)) subThreadIns.start() # rose Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-07-02 16:55:52 "},"Python/Python并发编程/multiprocessing模块使用.html":{"url":"Python/Python并发编程/multiprocessing模块使用.html","title":"multiprocessing模块使用","keywords":"","body":"multiprocessing模块 Python中提供了multiprocessing模块来实现进程并发编程，官方文档如下： 官方文档 由于GIL锁的存在，所以CPython中多线程是不能够并行运行的，但是多进程可以并行运行，该模块用到的地方基本很少，但是仍然需要进行掌握。 此外，它和threading模块99%的接口都一模一样，只有少量的差别。 添加子进程 针对不同平台选择添加子进程的方式 multiprocessing模块针对不同的平台，添加子进程的方式也有所区别： spawn：该方式是Windows平台下的默认方式，它会创建一个新的解释器进程，速度比较慢 fork：该方式是Unix平台下的默认方式，内部会通过os.fork()产生一个新的解释器分叉 需要注意的是，如果平台是Windows，则必须将启动代码书写到if __name__ == \"__main__”语句的下面，否则将会抛出异常。 如何指定新进程的启动方式？示例如下： import multiprocessing if __name__ == \"__main__\": multiprocessing.set_start_method(\"fork\") 实例化Process类 使用该方式新增子线程任务是比较常见的，也是推荐使用的。 简单的代码示例如下，创建3个子进程并向其添加任务，然后运行并打印它们的PID和进程名字： import multiprocessing import time def task(params): print(\"sub process run\") currentThread = multiprocessing.current_process() time.sleep(3) print(\"current subProcess id : %s\\ncurrent sub process name : %s\\ncurrent sub process params : %s\" % ( currentThread.ident, currentThread.name, params)) if __name__ == \"__main__\": print(\"main Process run\") for item in range(3): subProcessIns = multiprocessing.Process(target=task, args=(item, )) subProcessIns.start() print(\"main Process run end\") # main Process run # main Process run end # sub process run # current subProcess id : 7761 # current sub process name : Process-1 # current sub process params : 0 # sub process run # current subProcess id : 7762 # current sub process name : Process-2 # current sub process params : 1 # sub process run # current subProcess id : 7763 # current sub process name : Process-3 # current sub process params : 2 自定义类覆写run()方法 上面的子进程任务对象是一个全局函数，我们也可以将它作为方法来进行调用。 书写一个类并继承Process类，覆写run()方法即可： import multiprocessing import time class TaskClass(multiprocessing.Process): def __init__(self, params): self.params = params super(__class__, self).__init__() def run(self): print(\"sub process run\") currentProcess = multiprocessing.current_process() time.sleep(3) print(\"current sub process id : %s\\ncurrent sub process name : %s\\ncurrent sub process params : %s\" % ( currentProcess.ident, currentProcess.name, self.params)) if __name__ == \"__main__\": print(\"main process run\") for item in range(3): subThreadIns = TaskClass(item) subThreadIns.start() print(\"main process run end\") # main process run # main process run end # sub process run # current sub process id : 7800 # current sub process name : TaskClass-1 # current sub process params : 0 # sub process run # current sub process id : 7801 # current sub process name : TaskClass-2 # current sub process params : 1 # sub process run # current sub process id : 7802 # current sub process name : TaskClass-3 # current sub process params : 2 multiprocessing模块方法大全 以下是multiprocessing模块提供的类或方法： 类或方法 描述 返回值 multiprocessing.Process(target, args, kwargs) 创建并返回一个进程对象 processObject multiprocessing.active_children() 查看当前进程下的所有子进程对象，以列表形式返回 [processObject, ...] multiprocessing.current_process() 获取当前的进程对象 processObject 以下是好伙伴os模块所提供的2个方法： 方法 描述 返回值 os.getpid() 返回当前进程pid int os.getppid() 返回当前进程的父进程的pid int processObject方法大全 以下是针对进程对象提供的属性或者方法： 方法/属性 描述 返回值 processObject.start() 通知系统该进程调度完毕，可以随时进行启动，一个进程对象只能运行一次该方法，若多次运行则抛出RunTimeError异常 ... processObject.join(timeout=None) 主进程默认会等待子进程运行结束后再继续执行，timeou为等待的秒数，如不设置该参数则一直等待。 ... processObject.close() 关闭进程 ... processObject.terminate() 终止进程 ... processObject.kill() 终止进程 ... processObject.is_alive() 查看进程对象是否存活 bool processObject.ident 获取进程对象的编号 int processObject.pid 获取进程对象的编号 processObject.name 获取或者设置进程对象的名字 str or None processObject.daemon 查看进程对象是守护进程 bool processObject.exitcode 子进程的退出代码。如果进程尚未终止，这将是None。负值 -N 表示子进程被信号 N 终止 int processObject.authkey 获取进程的身份验证密码 bytes 守护进程示例 multiprocessing模块的守护进程和threading的守护线程设置有所不同。 它是通过赋值来进行设置的，如下所示： import multiprocessing import time class TaskClass(multiprocessing.Process): def run(self): pName = multiprocessing.current_process().name print(\"%s start run\" % pName) time.sleep(3) print(\"%s run end\" % pName) if __name__ == \"__main__\": print(\"main process start run\") processLst = [] for i in range(3): processLst.append(TaskClass()) for ins in processLst: # 注意，守护进程的设置必须在进程未启动时设置 ins.daemon = True ins.start() print(\"main process carry on run\") print(\"main process run end\") # main process start run # TaskClass-1 start run # main process carry on run # main process run end multiprocessing与threading模块异同 　　1.创建子进程的方式针对不同平台有着差异化 　　2.关于守护线程的设置接口是setDaemon(True)，而关于守护进程的接口是deamon = True 　　3.multiprocessing模块下的获取进程名与设置进程名没有threading模块下的getName()和setName()，而是直接采取属性name进行操作 锁的使用 multiprocessing模块中锁的接口和使用与threading中锁的接口和使用一致。 所以这里仅介绍一个lock锁即可： import multiprocessing num = 0 def add(): lock.acquire() global num for i in range(10_000_000): num += 1 lock.release() def sub(): lock.acquire() global num for i in range(10_000_000): num -= 1 lock.release() if __name__ == \"__main__\": lock = multiprocessing.Lock() subProcess01 = multiprocessing.Process(target=add) subProcess02 = multiprocessing.Process(target=sub) subProcess01.start() subProcess02.start() subProcess01.join() subProcess02.join() print(\"num result : %s\" % num) # 结果三次采集 # num result : 0 # num result : 0 # num result : 0 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-07-03 15:05:48 "},"Python/Python并发编程/线程或进程通信.html":{"url":"Python/Python并发编程/线程或进程通信.html","title":"线程或进程通信","keywords":"","body":"线程或进程通信 在同一个进程中，该进程下的所有数据资源都会被该进程下的线程共享。 为了保证数据安全性，我们在多个线程进行数据交互时必须使用一种线程安全的容器来承载交互信息。 如，常见的Redis数据库、MQ等消息中间件是非常好的选择。 当然，多进程也是如此。 但是在实际的测试环境中，我们需要更加方便的一些工具来测试代码是否准确，这时候就会用到下面介绍的工具了。 多线程通信 queue queue模块对于多线程通信来讲是十分明智的选择，它使用简单开箱即用，最关键的一点是它是Python的内置模块，故不用经历任何额外的下载、安装过程。 官方文档 queue本身是线程安全的，它其实就是管道 + 锁的组合，它提供了3种队列供用户使用： queue.Queue：先进先出队列 queue.LifoQueue：后进先出队列 quque.PriorityQueue：优先级队列 以下是queue模块各个队列中提供的常见方法： 方法 描述 Queue.qsize() 返回当前队列的大小 Queue.empty() 判断当前队列是否为空 Queue.full() 判断当前队列是否已满 Queue.put(item, block=True, timeout=None) 将item放入队列中，如果block为True，则队列已满时进行阻塞，timeout为阻塞超时时间，超过该时间后抛出Full的异常 Queue.put_nowait(item) 相当于Queue.put(item, block=False, timeout=None)，将item放入队列时一旦队列已满就立即抛出Full的异常 Queue.get(block=True, timeout=None) 从队列中取出项目，如果block为True，则队列为空时进行阻塞，timeout为阻塞超时时间，超过该时间后抛出Empty的异常 Queue.get_nowait() 相当于Queue.get(block=False, timeout=None)，从队列中取出项目时一旦队列为空就立即抛出Empty的异常 Queue.join() 阻塞队列，此时队列中不可取出任何数据 Queue.task_done() 通知取消阻塞队列，此时队列中可取出数据 先进先出队列 以下是先进先出队列的简单使用： import queue q = queue.Queue() # 可指定maxsize参数，定义当前队列的容量 q.put(1) q.put(2) q.put(3) print(q.get()) print(q.get()) print(q.get()) # 1 # 2 # 3 后进先出队列 以下是后进先出队列的简单使用： import queue q = queue.LifoQueue() # 可指定maxsize参数，定义当前队列的容量 q.put(1) q.put(2) q.put(3) print(q.get()) print(q.get()) print(q.get()) # 3 # 2 # 1 优先级队列 以下是优先级队列的简单使用，出队时优先级较小的先出队： import queue q = queue.PriorityQueue() # 可指定maxsize参数，定义当前队列的容量 q.put([10, \"A\"]) # [优先级, 数据项] q.put([50, \"B\"]) q.put([30, \"C\"]) print(q.get()) print(q.get()) print(q.get()) # [10, 'A'] # [30, 'C'] # [50, 'B'] 队列阻塞 下面是队列阻塞方法Queue.join()和Queue.task_done()的示例： import threading import queue def putTask(article): name = \"Ken\" # 放入玫瑰 q.put(article) print(\"%s put %s\" % (name, article)) # 通知对面可以取了 q.task_done() def getTask(): name = \"Jack\" # 如果先启动该线程，则会阻塞进行等待对吗的task_done()进行通知 q.join() # 取出玫瑰 print(\"%s get %s\" % (name, q.get())) if __name__ == \"__main__\": q = queue.Queue() gT = threading.Thread(target=getTask) pT = threading.Thread(target=putTask, args=(\"rose\", )) gT.start() pT.start() # Ken put rose # Jack get rose 内部原理图示 由于多线程都在一个进程中，故queue这个队列是共享的，任意该进程下的线程都能自由的对其进行数据项的读取。 如下图所示： 多进程通信 multiprocessing.Queue 多进程通信时不可使用普通的queue模块所提供的队列，而必须多进程模块multiprocessing所提供的Queue。 这个进程队列是没有提供task_done()方法与join()方法的，如果你想使用这2个方法，则可以导入multiprocessing.JoinableQueue这个队列。 以下是multiprocessing.Queue()所提供的方法： 方法 描述 Queue.qsize() 返回当前队列的大小 Queue.empty() 判断当前队列是否为空 Queue.full() 判断当前队列是否已满 Queue.put(item, block=True, timeout=None) 将item放入队列中，如果block为True，则队列已满时进行阻塞，timeout为阻塞超时时间，超过该时间后抛出Full的异常 Queue.put_nowait(item) 相当于Queue.put(item, block=False, timeout=None)，将item放入队列时一旦队列已满就立即抛出Full的异常 Queue.get(block=True, timeout=None) 从队列中取出项目，如果block为True，则队列为空时进行阻塞，timeout为阻塞超时时间，超过该时间后抛出Empty的异常 Queue.get_nowait() 相当于Queue.get(block=False, timeout=None)，从队列中取出项目时一旦队列为空就立即抛出Empty的异常 Queue.close() 关闭队列，该队列将变得不可put() Queue.join_thread() 等待后台线程。这个方法仅在调用了 close()方法之后可用。这会阻塞当前进程，直到后台线程退出，确保所有缓冲区中的数据都被写入管道中 Queue.cancel_join_thread() 防止 join_thread() 方法阻塞当前进程。具体而言，这防止进程退出时自动等待后台线程退出。详见 join_thread() 方法 个人还是推荐使用multiprocessing.JoinableQueue这个队列，因为它比multiprocessing.Queue强大一点。 需要注意的是，不管是multiprocessing.Queue还是multiprocessing.JoinableQueue，它们都是先进先出队列。 队列阻塞 以下是使用multiprocessing.JoinableQueue实现的队列阻塞： import multiprocessing import queue def putTask(article): name = \"Ken\" # 放入玫瑰 q.put(article) print(\"%s put %s\" % (name, article)) # 通知对面可以取了 q.task_done() def getTask(): name = \"Jack\" # 如果先启动该线程，则会阻塞进行等待对吗的task_done()进行通知 q.join() # 取出玫瑰 print(\"%s get %s\" % (name, q.get())) if __name__ == \"__main__\": q = multiprocessing.JoinableQueue() gT = multiprocessing.Process(target=getTask) pT = multiprocessing.Process(target=putTask, args=(\"rose\", )) gT.start() pT.start() # Ken put rose # Jack get rose 内部原理 为什么线程队列queue.Queue不能做到进程间数据共享呢？ 这是因为进程队列multiprocessing.Queue会采取一种映射的方式来同步数据，所以说进程队列的资源消耗比线程队列要庞大很多。 由于一个进程下的所有线程中的信息是共享的，所以线程队列根本不需要映射关系。 进程队列只是告诉你可以这样使用它达到进程间的数据共享，但是并不推荐你滥用它。 multiprocessing.Pipe 除开使用进程队列来实现进程间的通信，multiprocessing还提供了Pipe管道来进行通信。 他的资源消耗较少并且使用便捷，但是唯一的缺点便是只支持点对点。 Pipe有点类似socket通信。但是比socket通信更加简单，它不需要将字符串转换成字节后再进行发送，先来看一个实例： import multiprocessing from multiprocessing.connection import Pipe def putTask(article): name = \"Ken\" # 发送玫瑰 conn1.send(article) print(\"%s send %s\" % (name, article)) def getTask(): name = \"Jack\" # 接收玫瑰 article = conn2.recv() print(\"%s receive %s\" % (name, article)) if __name__ == \"__main__\": conn1, conn2 = multiprocessing.Pipe() # 实例化2个电话 gT = multiprocessing.Process(target=getTask) pT = multiprocessing.Process(target=putTask, args=(\"rose\", )) gT.start() pT.start() # Ken send rose # Jack receive rose Pipe()会去创建一个双向链接通道，如下所示： multiprocessing.Manager 除了进程队列multiprocessing.Queue，管道Pipe之外，multiprocessing还提供了Manager作为共享变量来提供多进程数据交互。 但是这种方式是不应该被直接使用的，因为它相较于进程队列Queue是数据不安全的。当多个进程同时修改一个共享变量势必导致结果出现问题，所以要想使用共享变量还得使用multiprocessin提供的进程锁才行。 Manager类是数据不安全的 Mangaer类支持的类型非常多，如：value, Array, List, Dict, Queue(进程池通信专用)，Lock等。 Mangaer实现了上下文管理器，可使用with语句创建多个对象 下面这个例子是使用multiprocessing.Manager来实现进程数据共享： import multiprocessing from multiprocessing import Manager def task_1(): dic[\"task_1\"] = \"A\" def task_2(): dic[\"task_2\"] = \"B\" if __name__ == \"__main__\": with Manager() as m: dic = m.dict() subProcessIns01 = multiprocessing.Process(target=task_1) subProcessIns02 = multiprocessing.Process(target=task_2) subProcessIns01.start() subProcessIns02.start() subProcessIns01.join() subProcessIns02.join() print(dic) # {'task_1': 'A', 'task_2': 'B'} 可以看见使用multiprocessing.Manager所提供的数据类用来数据交互展示很方便，但是要操纵数据则需要考虑数据安全问题： import multiprocessing from multiprocessing import Manager def task_1(): for i in range(1000): dic[\"number\"] -= 1 def task_2(): for i in range(1000): dic[\"number\"] += 1 if __name__ == \"__main__\": with Manager() as m: dic = m.dict() dic[\"number\"] = 0 subProcessIns01 = multiprocessing.Process(target=task_1) subProcessIns02 = multiprocessing.Process(target=task_2) subProcessIns01.start() subProcessIns02.start() subProcessIns01.join() subProcessIns02.join() print(dic) # 结果三次采集 # {'number': -13} # {'number': 5} # {'number': 8} 我们可以使用进程锁，来保证数据一致性： import multiprocessing from multiprocessing import Manager def task_1(): with lock: for i in range(1000): dic[\"number\"] -= 1 def task_2(): with lock: for i in range(1000): dic[\"number\"] += 1 if __name__ == \"__main__\": lock = multiprocessing.RLock() with Manager() as m: dic = m.dict() dic[\"number\"] = 0 subProcessIns01 = multiprocessing.Process(target=task_1) subProcessIns02 = multiprocessing.Process(target=task_2) subProcessIns01.start() subProcessIns02.start() subProcessIns01.join() subProcessIns02.join() print(dic) # 结果三次采集 # {'number': 0} # {'number': 0} # {'number': 0} Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-07-03 15:53:28 "},"Python/Python并发编程/生产者消费者模型.html":{"url":"Python/Python并发编程/生产者消费者模型.html","title":"生产者消费者模型","keywords":"","body":"生产者消费者模型 生产者消费者模型是一种设计思想，生产者生产出产品，消费者对产品进行消费。 但是他们之间不直接进行接触，而是通过中间件进行产品交易，这样做的好处是降低生产者与消费者之间的耦合度，使他们没有强制的关联。 如下图所示，当生产者生产出产品后会将产品放入中间件中，消费者监听中间件当中间件状态一旦发生变化后就立即获取出产品并消费： 多线程实现 下面将采用多线程实现生产者与消费者模型，需要借助queue.Queue()作为中间件： import threading import queue import time def producer(): thName = threading.current_thread().name product = 0 while 1: time.sleep(3) q.put(product) print(\"%s create %s\" % (thName, product)) product += 1 def consumer(): thName = threading.current_thread().name while 1: product = q.get() print(\"%s get %s\" % (thName, product)) if __name__ == \"__main__\": q = queue.Queue(maxsize=5) producerSubThread = threading.Thread(target=producer, name=\"producer\") producerSubThread.start() for i in range(3): consumerSubThread = threading.Thread( target=consumer, name=\"consumer - %s\" % i) consumerSubThread.start() 首先生产者会每隔3s生产出一个产品，然后将产品放入q队列中，消费者们会不断的从q队列中取出产品。 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-07-03 17:46:38 "},"Python/Python并发编程/使用执行器提交任务.html":{"url":"Python/Python并发编程/使用执行器提交任务.html","title":"使用执行器提交任务","keywords":"","body":"concurrent.futures 我们在以往创建线程或进程的时候都会使用threading与multiprocessing模块进行创建。 那么在本章节学习完成后就不要使用这两种方式创建线程或者进程了，而是应当使用concurrent.futures所提供的执行器来构建线程或进程并执行任务。 concurrent.futures提供了2种执行器，如下所示，它们的接口使用也都一模一样： from concurrent.futures import ThreadPoolExecutor # 线程池执行器 from concurrent.futures import ProcessPoolExecutor # 进程池执行器 注意，在Python2中是没有线程池执行器的。 官方文档 使用执行器和不使用执行器创建线程或进程两者2有什么不同呢？如下表所示： 普通线程 执行器 创建线程 惰性创建，需要执行任务时再创建线程 及早创建，在初始化执行器时就会创建一堆线程 提交任务 同步的提交任务，获取结果时需要等待，完成任务的线程会立即销毁 异步的提交任务，获取结果时将采用回调机制，完成任务的线程会立即返回至执行器中 销毁线程 任务完成后立即销毁线程 删除执行器或解释器析构时销毁线程 我们可以从这张图中看出2者的差距： 线程的创建和销毁是需要额外占据系统资源的，所以使用线程池执行器来管理线程性能上也会得到一定的提升。 执行器对象 方法大全 下面是执行器所提供的方法，用于创建子线程以及给子线程派发并执行任务： 方法 描述 ThreadPoolExecutor(max_workers=int) 返回一个线程池执行器对象，可指定该池中工作线程的最大数量 submit(fn, *args, **kwargs) 异步提交任务fn并派发给线程池执行器中的线程进行任务执行，返回期程对象 map(fn, *iterables, timeout=None, chunksize=1) 类似于内置函数map，它将map中fn的任务提交变更为异步的 shutdown(wait=True) 等待，类似于join()方法。在所有任务完成后关闭线程池执行器 基本使用 下面将创建一个包含5个线程的线程池执行器，然后给这5个线程分配10个任务并执行： from concurrent.futures import ThreadPoolExecutor import threading import time def task(): thName = threading.current_thread().name time.sleep(0.2) print(thName) if __name__ == \"__main__\": executor = ThreadPoolExecutor(max_workers=5) for i in range(10): executor.submit(task) # ThreadPoolExecutor-0_0 # ThreadPoolExecutor-0_1 # ThreadPoolExecutor-0_2 # ThreadPoolExecutor-0_3 # ThreadPoolExecutor-0_4 # ThreadPoolExecutor-0_1 # ThreadPoolExecutor-0_2 # ThreadPoolExecutor-0_0 # ThreadPoolExecutor-0_4 # ThreadPoolExecutor-0_3 with语句 我们也可以使用with语句来初始化线程池执行器： from concurrent.futures import ThreadPoolExecutor import threading import time def task(): thName = threading.current_thread().name time.sleep(0.2) print(thName) if __name__ == \"__main__\": with ThreadPoolExecutor(5) as executor: for i in range(10): executor.submit(task) map() 如果要多次调用同一个任务，而传入的参数不同时可使用map()函数。 如下所示，模拟爬取3个不同的网站： from concurrent.futures import ThreadPoolExecutor import threading import time def task(url): thName = threading.current_thread().name time.sleep(0.2) print(\"%s get %s\" % (thName, url)) if __name__ == \"__main__\": urlLst = [\"http://www.google.com\", \"http://www.baidu.com\", \"http://www.biying.com\"] with ThreadPoolExecutor(5) as executor: executor.map(task, urlLst) # ThreadPoolExecutor-0_0 get http://www.google.com # ThreadPoolExecutor-0_1 get http://www.baidu.com # ThreadPoolExecutor-0_2 get http://www.biying.com 期程对象 方法大全 当执行器的线程、进程任务执行完毕后，会返回一个期程对象（也被称为未来对象）。 下面是期程对象所提供的方法： 方法 描述 result(timeout=None) 从期程对象中获取任务执行结果，可设置超时时间timeout，若不设置该时间则一直等待，也就是说该方法是一个同步阻塞的获取执行结果的方法，若超时则引发cancelledError异常 add_done_callback(fn) 为期程对象添加回调函数，用于异步非阻塞的获取任务执行结果，fn为一个函数，该函数的形参会接受已完成任务的期程对象 exception(timeout=None) 返回由调用引发的异常。如果调用还没完成那么这个方法将等待 timeout 秒。如果在 timeout 秒内没有执行完成，concurrent.futures.TimeoutError将会被触发。timeout 可以是整数或浮点数。如果 timeout 没有指定或为 None，那么等待时间就没有限制。 cancel() 尝试取消任务的调用，如果当前任务正在执行或已经执行完毕则不能取消。若成功取消返回True，若取消失败则返回False cancelled() 如果调用成功则取消并返回True running() 如果调用正在执行而且不能被取消那么返回True done() 如果调用已被取消或正常结束那么返回True 期程对象 executor.submit()的返回结果是一个期程对象： from concurrent.futures import ThreadPoolExecutor import time def task(): time.sleep(0.2) if __name__ == \"__main__\": with ThreadPoolExecutor(1) as executor: for i in range(3): futureObject = executor.submit(task) print(futureObject) # # # 上面这个例子中执行器中包含1个线程，但是却要执行3个任务，所以你会发现它们的状态并不相同。 期程对象拥有5个状态，它们表示未来将可能出现的任务执行状态： _FUTURE_STATES = [ PENDING, # 等待执行任务 RUNNING, # 正在执行任务 CANCELLED, # 被取消 CANCELLED_AND_NOTIFIED, # 被取消 FINISHED # 已完成 ] 同步的获取结果 使用futureObject.result()可同步的获得任务的返回结果： from concurrent.futures import ThreadPoolExecutor import threading import time def task(params): taskIndex = params - 64 print(\"start carried out task, this is %s task\" % taskIndex) time.sleep(3) return \"task %s carried out end, result : %s\" % (taskIndex, chr(params)) if __name__ == \"__main__\": with ThreadPoolExecutor(5) as executor: for i in range(65, 91): futureObject = executor.submit(task, i) print(futureObject.result()) # start carried out task, this is 1 task # task 1 carried out end, result : A # start carried out task, this is 2 task # task 2 carried out end, result : B # start carried out task, this is 3 task # task 3 carried out end, result : C # start carried out task, this is 4 task # task 4 carried out end, result : D # start carried out task, this is 5 task # task 5 carried out end, result : E # ... 这将会引发主线程的阻塞，因为result()方法必须等待任务执行完毕后才能获取到结果，所以不应该这么使用。 异步的获取结果 由于executor.submit()的任务提交是异步提交，故我们应当采取绑定回调函数的策略来获得任务执行结果，而不是使用直接result()方法。 绑定回调函数并不会引起主线程的阻塞，一旦某个任务完成后便会立即触发回调函数的执行，并将期程对象传入该回调函数中。 因为此时的期程对象状态一定是FINISHED，所以使用result()方法便不会等待了。 如下所示，异步的获取结果，你可以看见它的打印结果和上面的例子是完全不同的： from concurrent.futures import ThreadPoolExecutor import threading import time def task(params): taskIndex = params - 64 print(\"start carried out task, this is %s task\" % taskIndex) time.sleep(3) return \"task %s carried out end, result : %s\" % (taskIndex, chr(params)) def callback(futureObject): print(futureObject.result()) if __name__ == \"__main__\": with ThreadPoolExecutor(5) as executor: for i in range(65, 91): futureObject = executor.submit(task, i) futureObject.add_done_callback(callback) # start carried out task, this is 1 task # start carried out task, this is 2 task # start carried out task, this is 3 task # start carried out task, this is 4 task # start carried out task, this is 5 task # task 1 carried out end, result : A # start carried out task, this is 6 task # task 2 carried out end, result : B # start carried out task, this is 7 task # task 4 carried out end, result : D # start carried out task, this is 8 task # task 5 carried out end, result : E # start carried out task, this is 9 task # task 3 carried out end, result : C # start carried out task, this is 10 task # ... 进程池执行器的进程通信 当我们使用进程池执行器启动多进程执行任务时，如果想用数据共享，单纯multiprocessing.Queue进程队列并不支持。 import multiprocessing from concurrent.futures import ProcessPoolExecutor # 进程池执行器 def task_1(q): q.put(\"玫瑰花\") print(\"放完了...\") def task_2(q): print(q.get()) print(\"取到了\") if __name__ == '__main__': q = multiprocessing.Queue() with ProcessPoolExecutor(max_workers=2) as pool: pool.submit(task_1,q) pool.submit(task_2,q) # 会阻塞住 这个时候我们需要用到multiprocessing中的Manager()中的Queue。只有它支持进程池的进程数据共享： from multiprocessing import Manager from concurrent.futures import ProcessPoolExecutor # 进程池执行器 def task_1(q): q.put(\"玫瑰花\") print(\"放完了...\") def task_2(q): print(q.get()) print(\"取到了\") if __name__ == '__main__': q = Manager().Queue() with ProcessPoolExecutor(max_workers=2) as pool: pool.submit(task_1,q) pool.submit(task_2,q) # 放完了... # 玫瑰花 # 取到了 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-07-03 23:37:22 "},"Python/Python并发编程/Linux五大IO模型.html":{"url":"Python/Python并发编程/Linux五大IO模型.html","title":"Linux五大I/O模型","keywords":"","body":"基础知识 I/O分类 常见的I/O主要分为以下几类，如下所示： 阻塞I/O（blocking I/O） 非阻塞I/O（non-blocking I/O） 同步I/O（sync I/O） 异步I/O（async I/O） 同步：调用端会一直等待服务端响应，直到返回结果 异步：调用端发起调用之后不会等待服务端响应。服务端通过某种通知机制或者回调函数来通知客户端 阻塞：服务端返回结果之前，客户端线程会被挂起，此时线程不可被CPU调度，线程暂停运行 非阻塞：在服务端返回前，函数不会阻塞调用端线程，而会立刻返回 用户态与内核态 用户态（User model）和内核态（Kernel model）是CPU的2种工作状态。 内核态下运行的必然是操作系统相关的代码，它允许直接操作硬件。 而用户态下运行的必然是应用程序相关的代码，用户态下不可以直接操纵底层硬件。 它必须通过操作系统调用才能间接的使用底层硬件，而应用程序的运行必然是要操纵底层硬件的，所以就必须让CPU不断的做2种状态的切换才行。 需要注意的是，核心态和内核态中所产生的数据是不允许直接交互的，而是只能通过一种映射的方式进行数据交互，可以理解为copy。 在CPU中有一个名叫psw的寄存器就是区分内核态和用户态的，它有2个状态位，当CPU指令集是0的时候对应到内核态，也就获取了所有的内存权限。 当指令集是1的时候对应到用户态，保留一部分内存不让访问。所以说真正的内存是不可划分的，都只是一个状态不同的问题。 当应用层面的程序被CPU执行时，那么可以肯定的是它的状态必定是1，限制了一些调度硬件的权限。 文件描述符 文件描述符简称为fd，全称为file descriptor。 Linux系统一切皆文件，因此文件描述符通常是用于描述指向文件的引用的抽象化概念。文件描述符在形式上是一个非负整数。实际上，它是一个索引值，指向内核为每一个进程所维护的该进程打开文件的记录表。 当程序打开一个现有文件或者创建一个新文件时，内核都会向进程返回一个文件描述符。 在程序设计中，一些涉及底层的程序编写往往会围绕着文件描述符展开。但是文件描述符这一概念往往只适用于Linux这样的操作系统。 缓存I/O 缓存I/O又被称作标准I/O，大多数文件系统的默认I/O操作都是缓存IO。 在Linux的缓存I/O机制中，操作系统会将 I/O的数据缓存在文件系统的页缓存（ page cache ）中，也就是说，数据会先被拷贝到操作系统内核的缓冲区中，然后才会从操作系统内核的缓冲区拷贝到应用程序的地址空间。 缓存I/O的缺点： 数据在传输过程中需要在应用程序地址空间和内核进行多次数据拷贝操作，这些数据拷贝操作所带来的 CPU 以及内存开销是非常大的。 其实缓存I/O出现的原因还是用户态和内核态的内存不允许直接进行数据交互而产生的，必须拥有这样一个缓存机制。 event loop event loop中文释义为事件循环，是一种常见的编程范式，常用于前端领域。 它是一种非线性的驱动模式，举个例子： 任何的UI编程都是基于事件循环的驱动模型来完成的，当我们的鼠标放在任何一段文字之上，它会根据文字不同而做出对应的不同反应。 并且，我们进入一个网页不仅仅可以用鼠标与网页产生交互，也可以使用键盘与网页产生交互，那么这里就会有很多很多种不同的选择，如果想尝试用传统的编程思想来解决识别用户的操作无疑效率是非常低下的。 传统编程思想解决方案： 死循环来不断的检测是否有鼠标点击，键盘按下，鼠标悬浮等等操作 通过阻塞的方式来等待用户的一次点击或者键盘按下或者鼠标悬浮的等等操作 这种解决方案看似十分完美，但是拥有很大的缺点： 死循环占用大量CPU资源，并且如果需要检测的事件太多势必会引发延迟问题 通过阻塞方式只能检测一种操作，并不能同时检测多种操作 为了解决这些缺点，故诞生了event loop，它的设计思路如下： 有一个事件(消息)队列，包括但不仅限于鼠标事件，键盘事件，悬浮事件等等 假设当鼠标按下，便往这个队列中增加一个点击事件(消息) 有一个循环，不断的从队列中取出事件，根据不同的事件调用不同的函数 事件（消息）一般都各自保存各自的处理函数指针，这样每个消息都有独立的处理函数 图解如下： 包含一个事件循环并且只有当外部事件发生时才使用回调机制来触发相应的处理。 也就是说程序运行的整个流程都是取决于用户触发的各种事件来决定的，开发者并不用关心大体流程，而只是需要做好每一个事件对应的处理方式即可。 Linux五大I/O模型 阻塞I/O模型 发起I/O系统调用后，进程会被阻塞，直至出现响应数据。 当响应数据出现后，系统会转到内核空间进行处理，将内核缓冲区的数据映射（或被称为拷贝）至应用程序中。 举例说明： 一个人去食堂买饭，他问了食堂大妈还有没有饭后就站在窗口原地的等，此时这个人什么也做不了。 非阻塞I/O模型 发起I/O系统调用后，进程不会阻塞，而是通过死循环不断的查看是否出现响应数据，如果响应数据未出现时就进行拷贝，则会引起异常。 当响应数据出现后，系统会转到内核空间进行处理，将内核缓冲区的数据映射（或被称为拷贝）至应用程序中。 举例说明： 一个人要去食堂买饭，他会先问食堂大妈有没有饭，食堂大妈说没有饭这个人就走开了，过一会又会过来问食堂大妈有没有饭，直至食堂大妈说饭好了后他才端上饭满意的离开。 I/O复用模型 I/O复用模型与事件驱动模型相似，它会先将I/O事件以及回调函数进行注册，然后再进行循环监听，一旦文件描述符状态发生改变后就会触发回调函数。 我们可以注册多个文件描述符，来达到同时监听多个I/O的目的，相较于前两种I/O模型，它拥有了监听机制，而正是因为有了这个机制，故并发量可以得到质的提升。 I/O复用模型拥有3种不同的监听机制，分别是select、poll以及epoll。 I/O复用模型的出现很大程度改变了一个进程多个I/O阻塞的问题，它能够实现一个线程下监听多个I/O的功能，极大的提升了程序的并发性，也是目前较为主流的一种解决方案。 举例说明： 一群人要买饭，于是托付给一个人去食堂，这个人去食堂后会先告诉食堂大妈，我这里有多少人要吃饭，这个人等待食堂大妈做好饭后会打电话通知某一个人过来拿饭，即一份饭做完之后立马让一个人来吃。 信号驱动式I/O模型 当进程发起一个IO操作，会向内核注册一个信号处理函数，然后进程返回不阻塞； 当内核数据就绪时会发送一个信号给进程，进程便在信号处理函数中调用I/O读取数据。 由于该种I/O模型的编码难度较大，故现在很少有应用程序使用这种模型进行编程了。 异步I/O模型 当进程发起一个I/O操作，进程返回（不阻塞），但也不能返回果结； 内核把整个I/O处理完后，会通知进程结果。 如果I/O操作成功则进程直接获取到数据。 举例说明： 一个人要去食堂买饭，他告诉食堂大妈，我要吃饭，饭好了你让人给我送过来，然后这个人就可以去做其他的事情了。 五种I/O模型对比 5种I/O模型中，异步I/O模型的性能最高，它全程无阻塞，以下是对比图示： I/O复用select、poll、epoll简介 select selelct监听模式一般应用在Windows平台上。 它会使用顺序表存储所有注册的I/O事件描述符。 支持最大同时监听1024（32位系统）或者2048（64位系统）个描述符。 同时，它会不断的去轮询查看所有描述符的状态是否发生改变，以便触发回调函数，所以他的性能有点低，当然这只是针对其他的监听模式而言。 当描述符状态发生改变后，会将内核缓冲区的数据映射到应用程序中，这相当于拷贝一次。 还是举个例子，一个班主任最多管理1024个学生，当班主任想知道谁没有交作业的时候他会对这1024个学生一个一个进行询问，学生只会被动的回答。 如，老师问第一个学生，你交作业了吗？学生说交了，老师再问第二个学生，你交作业了吗？以此类推... 总结： 支持最大监听的描述符数量：1024（32位系统）或者2048（64位系统） 描述符存储结构：顺序表 处理事件响应：轮询处理 消息传递方式：将内核缓冲区的数据映射到应用程序中，这相当于拷贝一次 poll poll监听模式一般应用在Linux平台上。 它会使用链表存储所有注册的I/O事件描述符。 最大支持同时监听的描述符数量无上限。 他会采用轮询方式来处理事件响应。 当描述符状态发生改变后，会将内核缓冲区的数据映射到应用程序中，这相当于拷贝一次。 总结： 支持最大监听的描述符数量：无限制，2G内存就可存放20W个描述符 描述符存储结构：链表 处理事件响应：轮询处理 消息传递方式：将内核缓冲区的数据映射到应用程序中，这相当于拷贝一次 epoll epoll监听模式一般应用在Linux平台上。 它会使用红黑树存储所有注册的I/O事件描述符。 最大支持同时监听的描述符数量无上限。 它会采用及时响应的方式来处理事件响应。 epoll监听模式下，内核缓冲区的数据并不需要映射到应用程序中，因为epoll通过内核与用户空间共享一块内存来实现免拷贝的过程。 举个例子，如果说select以及poll对处理事件响应的机制是一个一个问，那么poll就是举手。 老师想知道谁没交作业，只需要吼一声，谁还没交作业？此时立马就会有人举手，相比于轮询来说它的响应速度上快了很多。 总结： 支持最大监听的描述符数量：无限制，2G内存就可存放20W个描述符 描述符存储结构：红黑树 处理事件响应：主动响应 消息传递方式：通过内核与用户空间共享一块内存来实现免拷贝的过程 LT和ET 水平触发(level-trggered)和边缘触发(edge-triggered)是2种读取内核缓冲区数据的机制。 水平触发(level-trggered) 只要文件描述符关联的读内核缓冲区非空，有数据可以读取，就一直发出可读信号进行通知， 当文件描述符关联的内核写缓冲区不满，有空间可以写入，就一直发出可写信号进行通知 边缘触发(edge-triggered) 当文件描述符关联的读内核缓冲区由空转化为非空的时候，则发出可读信号进行通知， 当文件描述符关联的内核写缓冲区由满转化为不满的时候，则发出可写信号进行通知 水平触发是只要读缓冲区有数据，就会一直触发可读信号，而边缘触发仅仅在空变为非空的时候通知一次，举个例子： 读缓冲区刚开始是空的 读缓冲区写入2KB数据 水平触发和边缘触发模式此时都会发出可读信号 收到信号通知后，读取了1kb的数据，读缓冲区还剩余1KB数据 水平触发会再次进行通知，而边缘触发不会再进行通知 边缘触发的效率比水平触发的效率明显要高出许多，它减少了重复且无用的通知。 poll和epoll均支持ET，而select只支持LT，但是一定要注意，要想支持水平触发，I/O读取机制必须设置成非阻塞的。 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-07-06 16:28:10 "},"Python/Python并发编程/常见IO示例演示.html":{"url":"Python/Python并发编程/常见IO示例演示.html","title":"常见I/O示例演示","keywords":"","body":"阻塞I/O的socket服务端 使用socket模块与concurrent.futures实现阻塞式I/O的socket服务端。 开启多个子线程，每个子线程单独负责一个链接，这意味着该服务器最大的并发量取决于你CPU能够打开的最大有效线程数： import socket import threading import concurrent.futures class TcpServer: def __init__(self, bind_addr=(\"localhost\", 8001), allow_reuse_address=False): self.socket = socket.socket() self.backlog = 5 self.bufsize = 1024 self.server_addr = bind_addr self.allow_reuse_address = allow_reuse_address # 默认创建的线程数为cpu核心数 * 5 self.executor = concurrent.futures.ThreadPoolExecutor() def run_server(self): \"\"\"运行服务\"\"\" self.server_bind() self.server_activate() self.handle_request() def server_bind(self): \"\"\"绑定地址\"\"\" if self.allow_reuse_address: self.socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1) self.socket.bind(self.server_addr) def server_activate(self): \"\"\"开启监听\"\"\" self.socket.listen(self.backlog) def handle_request(self): \"\"\"处理链接\"\"\" while 1: # 阻塞点1：accept()函数会导致程序卡住，直至有新的链接请求到来 conn, addr = self.socket.accept() self.executor.submit( self.handle_communicate, conn, addr) def handle_communicate(self, conn, addr): \"\"\"多线程处理通信\"\"\" thName = threading.current_thread().name print(f\"{addr} connect server, handle thread : {thName}\") while 1: try: # 阻塞点2：recv()函数会导致程序卡住，直至有新的信息放入conn双向链接通道中 data = conn.recv(self.bufsize) if not data: raise Exception( f\"{addr} close connect, handle thread : {thName}\") conn.send(data.upper()) except Exception as e: self.close_connect(conn, e) break def close_connect(self, conn, msg): \"\"\"关闭链接\"\"\" conn.close() print(msg) if __name__ == \"__main__\": server = TcpServer(allow_reuse_address=True) server.run_server() 非阻塞I/O的socket服务端 将上述的socket服务端改为非阻塞的： import socket import threading import concurrent.futures class TcpServer: def __init__(self, bind_addr=(\"localhost\", 8001), allow_reuse_address=False): self.socket = socket.socket() # 设置为非阻塞 self.socket.setblocking(False) self.backlog = 5 self.bufsize = 1024 self.server_addr = bind_addr self.allow_reuse_address = allow_reuse_address # 默认创建的线程数为cpu核心数 * 5 self.executor = concurrent.futures.ThreadPoolExecutor() def run_server(self): \"\"\"运行服务\"\"\" self.server_bind() self.server_activate() self.handle_request() def server_bind(self): \"\"\"绑定地址\"\"\" if self.allow_reuse_address: self.socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1) self.socket.bind(self.server_addr) def server_activate(self): \"\"\"开启监听\"\"\" self.socket.listen(self.backlog) def handle_request(self): \"\"\"处理链接\"\"\" while 1: # 设置非阻塞I/O后，accept()这个原本会阻塞的函数变的非阻塞了 # 所以这里要不断的检测是否有新的链接请求 try: conn, addr = self.socket.accept() self.executor.submit( self.handle_communicate, conn, addr) except BlockingIOError as e: continue def handle_communicate(self, conn, addr): \"\"\"多线程处理通信\"\"\" thName = threading.current_thread().name print(f\"{addr} connect server, handle thread : {thName}\") while 1: try: # 设置非阻塞I/O后，recv()这个原本会阻塞的函数变的非阻塞了 # 所以这里要不断的检测是否有新的链接请求 data = conn.recv(self.bufsize) if not data: raise Exception( f\"{addr} close connect, handle thread : {thName}\") conn.send(data.upper()) except BlockingIOError as e: continue except Exception as e: self.close_connect(conn, e) break def close_connect(self, conn, msg): \"\"\"关闭链接\"\"\" conn.close() print(msg) if __name__ == \"__main__\": server = TcpServer(allow_reuse_address=True) server.run_server() I/O多路复用的socket服务端 上述的2个示例中，每个线程都会负责监听双向链接通道和处理通信请求，所以这意味着你的系统最大有效线程数决定了你服务器的最高并发数，显然效率是十分低下的。 而如果有一种机制让一个线程来监听所有的双向链接通道的话那么并发量就会得到质的提升，它不再是单纯的一对一服务了，而是一对多服务。 下面将利用select模块实现select监听模式的I/O多路复用机制，仅仅利用单线程，最大并发数量就能提升到2048个： import socket import select class TcpServer: def __init__(self, bind_addr=(\"localhost\", 8001), allow_reuse_address=False): self.socket = socket.socket() # 设置为非阻塞（高性能的边缘触发必备条件） self.socket.setblocking(False) self.backlog = 5 self.bufsize = 1024 self.server_addr = bind_addr self.allow_reuse_address = allow_reuse_address # 1.存放注册读取事件描述符的列表，当有可读事件发生时意味着客户端请求建立与服务端的双向链接通道 # 或者客户端有新的消息发送给服务端 self.r_list = [] # 2.存放注册可写事件描述符的列表，当有可写事件发生时意味着服务端可以主动向客户端发送信息 self.w_list = [] # 3.存放注册错误事件描述符的列表，... self.e_list = [] # 4.存放被监听描述符回调函数的字典 self.callback_dict = {} # 5.循环监听的时间间隔 self.poll_interval = 0.5 def run_server(self): \"\"\"运行服务\"\"\" self.server_bind() self.server_activate() self.server_forever() def server_bind(self): \"\"\"绑定地址\"\"\" if self.allow_reuse_address: self.socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1) self.socket.bind(self.server_addr) def server_activate(self): \"\"\"开启监听\"\"\" self.socket.listen(self.backlog) def server_forever(self): \"\"\"I/O多路复用\"\"\" # 注册self.sockt的可读事件并绑定回调函数为self.handle_request # 当客户端试图建立与服务端的双向链接通道时将触发self.socket的可读事件 self.register(obj=self.socket, event_type=\"read\", callback=self.handle_request) # 开始循环监听描述符，每次while循环间隔0.5s while 1: # 当可读事件列表、可写事件列表、错误事件列表中任何一个fd的状态发生改变后 # 都会添加到r、w、e中 r, w, e = select.select( self.r_list, self.w_list, self.e_list, self.poll_interval) # 查看是否有可读事件发生，如果有就运行其回调函数 for fd in r: # 运行回调函数 fd_callback = self.callback_dict[fd][\"r\"] fd_callback(fd) def handle_request(self, fd_socket): \"\"\"处理链接\"\"\" conn, addr = fd_socket.accept() print(f\"{addr} connect server\") # 注册conn的可读事件并绑定回调函数为self.handle_communicate # 当该客户端向服务端发送信息时将触会触发conn的可读事件 self.register(obj=conn, event_type=\"read\", callback=self.handle_communicate) def handle_communicate(self, fd_conn): \"\"\"处理通信\"\"\" # 实际上就是链接服务端的客户端地址 addr = getattr(fd_conn, \"getsockname\")() try: data = fd_conn.recv(self.bufsize) # 针对Unix环境：客户端强制断开链接 if not data: raise Exception( f\"{addr} close connect\") fd_conn.send(data.upper()) # 针对Windows环境：客户端强制断开链接 except Exception as e: # 关闭双向链接通道并注销可读事件，这意味着不再监听该双向链接通道 self.close_connect(fd_conn, e) self.unregister(obj=fd_conn, event_type=\"read\") def close_connect(self, conn, msg): \"\"\"关闭链接\"\"\" conn.close() print(msg) def register(self, obj, event_type, callback): \"\"\"事件注册\"\"\" if event_type == \"read\": self.r_list.append(obj) self.callback_dict[obj] = {\"r\": callback} elif event_type == \"write\": self.w_list.append(obj) self.callback_dict[obj] = {\"w\": callback} elif event_type == \"error\": self.e_list.append(obj) self.callback_dict[obj] = {\"e\": callback} else: raise TypeError(\"unknown event type %r\" % event_type) def unregister(self, obj, event_type): \"\"\"取消注册\"\"\" if event_type == \"read\": self.r_list.remove(obj) del self.callback_dict[obj][\"r\"] elif event_type == \"write\": self.w_list.remove(obj) del self.callback_dict[obj][\"w\"] elif event_type == \"error\": self.e_list.remove(obj) del self.callback_dict[obj][\"e\"] else: raise TypeError(\"unknown event type %r\" % event_type) if __name__ == \"__main__\": server = TcpServer(allow_reuse_address=True) server.run_server() 异步的socket服务端 selectors模块是select模块的升级版，他还会根据平台自动选择监听方式，是十分方便的。 　官方文档 注意，Windows平台下不支持poll或者epoll模式 epoll模式仅有Linux平台支持 现在很多框架的内部，如著名的异步框架tornado，Twisted ，等等都是通过epoll实现的异步，其实epoll到底属于不属于异步在网络上有很大的争议，下面会有一节会和大家一起讨论一下epoll和异步之间的关系。 下面是它的使用案例，基本步骤和select模块使用类似，也是注册事件、绑定回调、监听描述符。 相较于使用select模式的I/O多路复用机制来说，epoll模式的I/O多路复用机制单线程下的效率和最大支持并发量提升了不少： import socket import selectors class TcpServer: def __init__(self, bind_addr=(\"localhost\", 8001), allow_reuse_address=False): self.socket = socket.socket() # 设置为非阻塞（高性能的边缘触发必备条件） self.socket.setblocking(False) self.backlog = 5 self.bufsize = 1024 self.server_addr = bind_addr self.allow_reuse_address = allow_reuse_address # 1.自动选择监听模式:select、poll、epoll self.sel = selectors.DefaultSelector() # 2.循环监听的时间间隔 self.poll_interval = 0.5 def run_server(self): \"\"\"运行服务\"\"\" self.server_bind() self.server_activate() self.server_forever() def server_bind(self): \"\"\"绑定地址\"\"\" if self.allow_reuse_address: self.socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1) self.socket.bind(self.server_addr) def server_activate(self): \"\"\"开启监听\"\"\" self.socket.listen(self.backlog) def server_forever(self): \"\"\"I/O多路复用\"\"\" # 注册self.sockt的可读事件并绑定回调函数为self.handle_request # 当客户端试图建立与服务端的双向链接通道时将触发self.socket的可读事件 self.sel.register(self.socket, selectors.EVENT_READ, self.handle_request) # 开始循环监听描述符，每次while循环间隔0.5s while 1: # 当有已注册描述符状态发生改变后，都会添加至fd_list # fd_list = [(fd, event), ...] fd_list = self.sel.select(self.poll_interval) for fd, event in fd_list: # 运行回调函数 fd_callback = fd.data fd_callback(fd.fileobj) def handle_request(self, fd_socket): \"\"\"处理链接\"\"\" conn, addr = fd_socket.accept() print(f\"{addr} connect server\") # 注册conn的可读事件并绑定回调函数为self.handle_communicate # 当该客户端向服务端发送信息时将触会触发conn的可读事件 self.sel.register(conn, selectors.EVENT_READ, self.handle_communicate) def handle_communicate(self, fd_conn): \"\"\"处理通信\"\"\" # 实际上就是链接服务端的客户端地址 addr = getattr(fd_conn, \"getsockname\")() try: data = fd_conn.recv(self.bufsize) # 针对Unix环境：客户端强制断开链接 if not data: raise Exception( f\"{addr} close connect\") fd_conn.send(data.upper()) # 针对Windows环境：客户端强制断开链接 except Exception as e: # 关闭双向链接通道并注销可读事件，这意味着不再监听该双向链接通道 self.close_connect(fd_conn, e) self.sel.unregister(fd_conn) def close_connect(self, conn, msg): \"\"\"关闭链接\"\"\" conn.close() print(msg) if __name__ == \"__main__\": server = TcpServer(allow_reuse_address=True) server.run_server() 更高性能的提升 上述的I/O多路复用服务端都是用单线程来实现对于请求的处理，如果加上了多线程进行处理请求，那么效率上又会有很大的提升。 如下所示： import socket import selectors import concurrent.futures class TcpServer: def __init__(self, bind_addr=(\"localhost\", 8001), allow_reuse_address=False): self.socket = socket.socket() # 设置为非阻塞（高性能的边缘触发必备条件） self.socket.setblocking(False) self.backlog = 5 self.bufsize = 1024 self.server_addr = bind_addr self.allow_reuse_address = allow_reuse_address # 默认创建的线程数为cpu核心数 * 5 self.executor = concurrent.futures.ThreadPoolExecutor() # 1.自动选择监听模式:select、poll、epoll self.sel = selectors.DefaultSelector() # 2.循环监听的时间间隔 self.poll_interval = 0.5 def run_server(self): \"\"\"运行服务\"\"\" self.server_bind() self.server_activate() self.server_forever() def server_bind(self): \"\"\"绑定地址\"\"\" if self.allow_reuse_address: self.socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1) self.socket.bind(self.server_addr) def server_activate(self): \"\"\"开启监听\"\"\" self.socket.listen(self.backlog) def server_forever(self): \"\"\"I/O多路复用\"\"\" # 注册self.sockt的可读事件并绑定回调函数为self.handle_request # 当客户端试图建立与服务端的双向链接通道时将触发self.socket的可读事件 self.sel.register(self.socket, selectors.EVENT_READ, self.handle_request) # 开始循环监听描述符，每次while循环间隔0.5s while 1: # 当有已注册描述符状态发生改变后，都会添加至fd_list # fd_list = [(fd, event), ...] fd_list = self.sel.select(self.poll_interval) for fd, event in fd_list: # 多线程运行回调函数 fd_callback = fd.data self.executor.submit(fd_callback, fd.fileobj) def handle_request(self, fd_socket): \"\"\"处理链接\"\"\" conn, addr = fd_socket.accept() print(f\"{addr} connect server\") # 注册conn的可读事件并绑定回调函数为self.handle_communicate # 当该客户端向服务端发送信息时将触会触发conn的可读事件 self.sel.register(conn, selectors.EVENT_READ, self.handle_communicate) def handle_communicate(self, fd_conn): \"\"\"处理通信\"\"\" # 实际上就是链接服务端的客户端地址 addr = getattr(fd_conn, \"getsockname\")() try: data = fd_conn.recv(self.bufsize) # 针对Unix环境：客户端强制断开链接 if not data: raise Exception( f\"{addr} close connect\") fd_conn.send(data.upper()) # 针对Windows环境：客户端强制断开链接 except Exception as e: # 关闭双向链接通道并注销可读事件，这意味着不再监听该双向链接通道 self.close_connect(fd_conn, e) self.sel.unregister(fd_conn) def close_connect(self, conn, msg): \"\"\"关闭链接\"\"\" conn.close() print(msg) if __name__ == \"__main__\": server = TcpServer(allow_reuse_address=True) server.run_server() epoll到底是同步还是异步 摘自知乎： 学习tornado、asyncio这些异步网络库时，遇到了同样的问题，网上查到的也都说不明白，原来几个概念没搞清楚。 I/O操作有多种，处理socket是一种，磁盘读写也是一种，暂时分为网络I/O和文件I/O、 I/O多路复用是操作系统级别的，属于linux操作系统的五种I/O模型中的一种，是操作系统级别同步非阻塞的 异步网络库 twisted、tornado、asyncio所谓的异步，是应用级别的异步，底层确实是基于epoll实现，基本上都是处理网络 I/O，而且都是基于事件驱动的，使用时划分事件也大多是根据网络请求。 操作系统级别的异步I/O才是真正异步非阻塞的，然后并没有很多应用，貌似unix平台没有，windows NT平台有也很少，而且基本都是文件I/O I/O多路复用的实现用的比较多，linux平台的epoll，windows平台的select等，基于epoll，select的应用大多是实现网络I/O。 所以，遇到异步框架，异步网络库都应该知道是应用级别的异步，而且基本上都是基于epoll/select实现的。 已知tornado会根据系统平台，选择epoll还是select。 实现高并发有多种方式，python多进程可以利用多核优势，协程(gevent、asyncio)可以实现应用级别的异步，celery实现任务异步，消息队列实现服务解耦等等，项目中可以根据实际情况选择或组合不同的方式。 tornado(web框架/异步网络库)：进程+异步+epoll asyncio：协程+epoll，使用中需要相应的异步库，如常用的aiohttp gevent：greenlet+猴子补丁，猴子补丁把socket相关库改为非阻塞 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-07-06 16:32:04 "},"Python/Python并发编程/协程asynic.html":{"url":"Python/Python并发编程/协程asynic.html","title":"协程 asynic","keywords":"","body":"协程 协程（coroutine）并不是一个系统层面上真实存在的东西，而是由程序员进行创造。 你可以理解为协程是用户态的“线程”，因此协程也被称为“微线程”或者“纤程（Fiber）”。 协程能够做到在单线程下实现多线程的并发操作，这是非常厉害的一点。 既然协程和线程很像，那么它对比线程有什么优势呢？ 协程和线程一样能够做切换，但是其切换代价远远小于线程，极大的提升了运行效率 协程中修改共享数据时不需要为数据加锁，因为协程本身就是一个单线程 协程有2大重要的概念，如下所示： 作为用户态线程，它必然存在于内核态线程中，也就是说协程本身是一个非常纯粹的单线程 协程最重要的意义就是切换 普通的代码运行总是顺序执行的，而如果我们有某种机制让它能够遇见I/O后进行自动切换执行就非常牛逼了。 例如下面这个例子，普通的运行打印结果是1、2、3、4，而我们如果加上遇见I/O自动切换执行的策略的话它的打印结果就会变成1、3、2、4： import time def task_01(): print(1) time.sleep(1) # I/O操作 print(2) def task_02(): print(3) time.sleep(1) # I/O操作 print(4) task_01() task_02() # 1 # 2 # 3 # 4 如果真的实现了上述的功能，那么使用单线程实现并发就变的不是那么遥不可及了。 生成器 我们可以利用生成器函数的yield关键字来实现代码的切换，如下所示： import time def task_01(): print(1) time.sleep(1) # I/O操作 yield # 手动切换 print(2) def task_02(): print(3) time.sleep(1) # I/O操作 yield # 手动切换 print(4) # 创建生成器对象 genObject_01 = task_01() genObject_02 = task_02() # 待执行任务列表 task_list = [genObject_01, genObject_02] # 开启循环 while 1: # 可执行任务列表 executable_list = task_list.copy() # 已执行任务列表 completed_list = [] for run_generator in executable_list: try: next(run_generator) except StopIteration as e: # 如果任务执行完毕，添加到已执行任务列表中 completed_list.append(run_generator) for end_generator in completed_list: # 从待执行任务列表、已执行任务列表中删除已完成任务 task_list.remove(end_generator) executable_list.remove(end_generator) else: # 清空已完成任务列表 completed_list.clear() if not task_list: break # 1 # 3 # 2 # 4 就这样一个基础的协程就做好了，但是你可以发现它的编码难度较大。 并且每次遇见I/O操作后都需要我们手动进行切换，十分的不方便。 gevent模块 针对yield协程的缺点，我们可以利用gevent模块，让整个碰见I/O操作就切换的过程变为自动进行。 它是一个第三方模块，所以你需要手动进行安装下载： $ pip3 install gevent 代码如下所示： import gevent import time from gevent import monkey # 声明：下面代码碰见I/O操作自动切换 monkey.patch_all() def task_01(): print(1) time.sleep(1) # I/O操作，自动切换 print(2) time.sleep(1) # I/O操作，自动切换 def task_02(): print(3) time.sleep(1) # I/O操作，自动切换 print(4) # 创建协程对象 fiberObject_01 = gevent.spawn(task_01, ) # 后面可传递参数 fiberObject_02 = gevent.spawn(task_02, ) # 任务列表 task_list = [fiberObject_01, fiberObject_02] # 开始执行 gevent.joinall( task_list ) # 1 # 3 # 2 # 4 asyncio模块 Python3.4之后，官方提供了asyncio模块来提供对协程的支持。 下面是代码示例： import asyncio # 函数头部加上该装饰器，表明该函数是一个协程函数 @asyncio.coroutine def task_01(): print(1) yield from asyncio.sleep(1) # I/O操作 自动切换 print(2) @asyncio.coroutine def task_02(): print(3) yield from asyncio.sleep(1) # I/O操作 自动切换 print(4) # 创建协程对象，并将它包装为期程对象 fiberObject_01 = asyncio.ensure_future(task_01()) fiberObject_02 = asyncio.ensure_future(task_02()) # 任务列表 task_list = [fiberObject_01, fiberObject_02] # 获取并开启循环 loop = asyncio.get_event_loop() # 运行任务列表，并等待所有协程任务执行完毕 loop.run_until_complete(asyncio.wait(task_list)) # 1 # 3 # 2 # 4 我们要注意，如果一个协程函数中要调用另一个函数，则必须使用yield from关键字，yield form后面可以运行的对象类型： 协程对象 期程对象 task任务对象 另外，如果你想在协程函数中运行一些模块方法，那么一定要保证模块所提供的方法是异步方法，否则协程切换无效。 有关于yield from的使用，请参照Python基础生成器一章节。 async&awit语法 async和awit语法在Python3.5中被支持，它本质和asyncio模块使用没有任何区别，只是简化了语法。 async：用于定义协程函数，而不再使用@asyncio.coroutine装饰器来进行定义 awit：相当于yield from的简写形式，必须书写在协程函数中 以下是它的使用示例： import asyncio async def task_01(): print(1) await asyncio.sleep(1) # I/O操作 自动切换 print(2) async def task_02(): print(3) await asyncio.sleep(1) # I/O操作 自动切换 print(4) # 创建协程对象，并将它包装为期程对象 fiberObject_01 = asyncio.ensure_future(task_01()) fiberObject_02 = asyncio.ensure_future(task_02()) # 任务列表 task_list = [fiberObject_01, fiberObject_02] # 获取并开启循环 loop = asyncio.get_event_loop() # 运行任务列表，并等待所有协程任务执行完毕 loop.run_until_complete(asyncio.wait(task_list)) # 1 # 3 # 2 # 4 协程的作用 单纯的协程只是能够做切换，没有其他的任何特定功能。 也就是说，协程本身并不能提高并发量，但是如果能够加上碰见I/O自动切换的机制，那么协程的真正意义才能够被体现。 注意一点： 对于计算密集型的操作来说，利用协程来回进行切换是没有任何意义的，来回切换并保存状态，反倒会降低性能 对于I/O密集型的操作来说，利用协程在I/O等待时间中去切换并执行其他任务，当I/O结束后再进行回调，那么就会大大节省系统资源并提供高性能从而实现异步编程 接下来我们将使用一个简单的爬虫案例，来探究协程和多线程的执行效率到底提升了多少。 下面是多线程爬虫的示例，需要用到requests模块，所以你必须先安装它： $ pip3 install requests 一个任务负责爬取资源，一个任务负责解析资源，为了更加方便对比，我们将整个运行时长都*10： import requests import time from concurrent.futures import ThreadPoolExecutor headers = { \"user-agent\": \"User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/87.0.4280.88 Safari/537.36\" } urls = [ \"https://www.jianshu.com/\", \"https://www.csdn.net/\", \"https://www.cnblogs.com/\", ] start = time.time() # 任务函数 def func(url): response = requests.get(url, headers=headers) return response.text # 绑定回调函数 def callback(futuresObject): print(futuresObject.result()) if __name__ == \"__main__\": with ThreadPoolExecutor() as executor: for url in urls: futuresObject = executor.submit(func, url) futuresObject.add_done_callback(callback) end = time.time() print(f\"总计花费时长{(end - start) * 10}\") # 总计花费时长21.973369121551514 下面是协程爬虫的示例，由于协程中不允许同步方法的出现，而requests模块下的请求方法都是同步请求方法，所以需要使用aiohttp模块下的异步请求方法完成网络请求，你必须先安装它： $ pip3 install aiohttp 示例如下： import asyncio import aiohttp import time headers = { \"user-agent\": \"User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/87.0.4280.88 Safari/537.36\" } urls = [ \"https://www.jianshu.com/\", \"https://www.csdn.net/\", \"https://www.cnblogs.com/\", ] start = time.time() # 任务函数 async def func(url): # async wait 相当于是执行一个异步的 __enter__ 方法 async with aiohttp.ClientSession() as session: # 防止ssl抛出错误 async with session.get(url, headers=headers, verify_ssl=False) as response: return await response.text() # 绑定回调函数 def callback(futuresObject): print(futuresObject.result()) if __name__ == \"__main__\": # 创建协程任务列表 task_list = [] # 创建协程任务 for url in urls: # 创建协程对象，并将它包装为期程对象 fiberObject = asyncio.ensure_future(func(url)) # 为期程对象绑定回调函数 fiberObject.add_done_callback(callback) # 添加到协程任务列表 task_list.append(fiberObject) # 创建事件循环 event_loop = asyncio.get_event_loop() # 执行任务，并且主线程会等待协程任务列表中的所有任务处理完毕后再执行 event_loop.run_until_complete(asyncio.wait(task_list)) end = time.time() print(f\"总计花费时长{(end - start) * 10}\") # 总计花费时长14.334436416625977 可以看见，协程爬虫比多线程爬虫的执行效率提高了不止一星半点，它真正称得上是Python中I/O密集型任务处理的大杀器。 asyncio详细探究 基于协程实现高性能的异步编程，这是Python未来发展方向，诸如fastapi、tornado等非常出名的异步web框架内部其实都与协程息息相关。 此外，Python web领域大火的Django也在3.x版本中正式迈入异步领域，这意味着：异步编程，永远的神。 事件循环 事件循环是asyncio的关键，你可以将它理解为一个while循环，它会在循环中周期性的执行协程任务，并且在特定的条件下终止循环。 你可以参照生成器实现协程的代码或者下面的伪代码，这就是事件循环最直观的体现。 待执行任务列表 = [协程任务, 协程任务] while 1: 可执行任务列表 = 待执行任务列表[:] 已执行任务列表 = [] for 可执行任务 in 可执行任务列表： try: next(可执行任务) except StopIteration as e: 已执行任务列表.append(可执行任务) for 已执行任务 in 已执行任务列表: 待执行任务.remove(已执行任务) 可执行任务.remove(已执行任务) else: 已执行任务列表.clear() if not 待执行任务列表: break 使用asyncio模块时，你可以直接通过下面方式获取到该事件循环： event_loop = asyncio.get_event_loop() 协程对象 协程函数就是加上了@asyncio.coroutine装饰器的函数，或者以async开头定义的函数，如下所示： async def task(): pass 它和生成器有着一样的特性，即加括号时不会调用函数体内部代码，而是返回一个协程对象： fiberObject = task() print(type(fiberObject)) # 任务执行 当要执行任务的时候，必须先获取事件循环，然后再将协程对象任务添加到事件循环中： import asyncio async def task(): print(\"run task ...\") fiberObject = task() event_loop = asyncio.get_event_loop() event_loop.run_until_complete(fiberObject) print(\"run main ...\") # run task ... # run main ... event_loop.run_until_complete()方法会添加协程对象至事件循环中，并且执行协程对象，直至协程对象运行完毕后才跳出事件循环。 在Python3.7之前，我们每次要运行一个协程对象都必须先获取事件循环，再调用event_loop.run_until_complete()添加协程对象并执行，这很麻烦。 在Python3.7之后asyncio模块新增了run()方法，它简化了这2步操作，如下所示： import asyncio async def task(): print(\"run task ...\") fiberObject = task() asyncio.run(fiberObject) print(\"run main ...\") # run task ... # run main ... await await关键字只能在协程函数中使用，类似于yield from只能在生成器函数中使用一样。 它与生成器函数相同，都用于运行嵌套在一个协程函数中的另一个协程函数，具体可参照yield from： import asyncio async def inner(): print(\"run ... inner\") return 1 async def warpper(): print(\"run ... warpper\") result = await inner() print(result) if __name__ == \"__main__\": fiberObject = warpper() event_loop = asyncio.get_event_loop() event_loop.run_until_complete(fiberObject) # run ... warpper # run ... inner # 1 await后面可以运行的对象类型： 协程对象 期程对象 taskr任务对象 期程对象 上述所有的代码都是在事件循环中添加一个协程对象，当事件循环中仅有一个对象时是无法做到遇见I/O就切换的操作的。 同时，协程对象本身不能绑定回调函数，所以要想绑定回调函数必须将它包装为期程对象。 在Python3.7之前，你可以使用asyncio.ensure_future()函数将一个协程对象包装为期程对象，这样它就可以绑定回调函数了： import asyncio async def task(): await asyncio.sleep(3) return 1 def callback(fiberObject): print(fiberObject.result()) if __name__ == \"__main__\": fiberObject = asyncio.ensure_future(task()) fiberObject.add_done_callback(callback) event_loop = asyncio.get_event_loop() event_loop.run_until_complete(fiberObject) # 1 如果想同时在事件循环中添加多个期程对象，你可以创建一个任务列表，并使用asyncio.wait()方法来将任务列表中所有的期程对象都添加到事件循环中，如下所示： import asyncio async def task(param): print(f\"run task{param}\") await asyncio.sleep(3) return param def callback(fiberObject): print(fiberObject.result()) if __name__ == \"__main__\": task_list = [] for i in range(3): fiberObject = asyncio.ensure_future(task(i)) fiberObject.add_done_callback(callback) task_list.append(fiberObject) event_loop = asyncio.get_event_loop() event_loop.run_until_complete( asyncio.wait(task_list) ) # run task0 # run task1 # run task2 # 0 # 1 # 2 这样一个异步提交的案例就出现了。 任务对象 任务对象是基于期程对象的一个封装。 如果你的Python版本是Python3.7或者更高，则可以直接创建任务对象并绑定回调函数，然后将它丢入的事件循环循环中： import asyncio async def task(param): print(f\"run task{param}\") await asyncio.sleep(3) return param def callback(fiberObject): print(fiberObject.result()) async def main(): task_list = [] for i in range(3): fiberObject = asyncio.create_task(task(i), name=f\"task{i}\") fiberObject.add_done_callback(callback) task_list.append(fiberObject) done, pending = await asyncio.wait(task_list, timeout=None) print(done, pending) if __name__ == \"__main__\": asyncio.run(main()) # run task0 # run task1 # run task2 # 0 # 1 # 2 concurrent.futures.Futures 在concurrent.futures模块中，也有一个期程对象，该模块用于提供线程执行器和进程执行器，能够更加方便管理线程和进程，详情参照前面>一章。 concurrent.futures.Futures和asyncio的Futures对象还是有所不同的，下面是官方文档的说明： 与 asyncio Futures 不同， concurrent.futures.Future 实例不能等待 asyncio.Future.result() 和 asyncio.Future.exception() 不接受超时参数 asyncio.Future.result() 和 asyncio.Future.exception() 在 Future 未完成时引发 InvalidStateError 异常 使用 asyncio.Future.add_done_callback() 注册的回调不会立即调用。 它们是用 loop.call_soon() 来安排的 asyncio Future 与 concurrent.futures.wait() 和 concurrent.futures.as_completed() 函数不兼容 如果想将concurrent.futures.Futures变的和asyncio.Future相同，则可以使用asyncio所提供的方法wrap_future()。 其实，一般在程序开发中我们要么统一使用 asycio 的协程实现异步操作、要么都使用进程池和线程池实现异步操作。但如果 协程的异步和 进程池/线程池的异步 混搭时，那么就会用到此功能了。 import time import asyncio import concurrent.futures def func1(): # 某个耗时操作 time.sleep(2) return 1 async def main(): loop = asyncio.get_running_loop() # 1. Run in the default loop's executor ( 默认ThreadPoolExecutor ) # 第一步：内部会先调用 ThreadPoolExecutor 的 submit 方法去线程池中申请一个线程去执行func1函数，并返回一个concurrent.futures.Future对象 # 第二步：调用asyncio.wrap_future将concurrent.futures.Future对象包装为asycio.Future对象。 # 因为concurrent.futures.Future对象不支持await语法，所以需要包装为 asycio.Future对象 才能使用 fut = loop.run_in_executor(None, func1) result = await fut print('default thread pool', result) # 2. Run in a custom thread pool: # with concurrent.futures.ThreadPoolExecutor() as pool: # result = await loop.run_in_executor( # pool, func1) # print('custom thread pool', result) # 3. Run in a custom process pool: # with concurrent.futures.ProcessPoolExecutor() as pool: # result = await loop.run_in_executor( # pool, func1) # print('custom process pool', result) asyncio.run(main()) 应用场景：当项目以协程式的异步编程开发时，如果要使用一个第三方模块，而第三方模块不支持协程方式异步编程时，就需要用到这个功能，例如： import asyncio import requests async def download_image(url): # 发送网络请求，下载图片（遇到网络下载图片的IO请求，自动化切换到其他任务） print(\"开始下载:\", url) loop = asyncio.get_event_loop() # requests模块默认不支持异步操作，所以就使用线程池来配合实现了。 future = loop.run_in_executor(None, requests.get, url) response = await future print('下载完成') # 图片保存到本地文件 file_name = url.rsplit('_')[-1] with open(file_name, mode='wb') as file_object: file_object.write(response.content) if __name__ == '__main__': url_list = [ 'https://www3.autoimg.cn/newsdfs/g26/M02/35/A9/120x90_0_autohomecar__ChsEe12AXQ6AOOH_AAFocMs8nzU621.jpg', 'https://www2.autoimg.cn/newsdfs/g30/M01/3C/E2/120x90_0_autohomecar__ChcCSV2BBICAUntfAADjJFd6800429.jpg', 'https://www3.autoimg.cn/newsdfs/g26/M0B/3C/65/120x90_0_autohomecar__ChcCP12BFCmAIO83AAGq7vK0sGY193.jpg' ] tasks = [download_image(url) for url in url_list] loop = asyncio.get_event_loop() loop.run_until_complete(asyncio.wait(tasks)) async for 异步可迭代对象 async for语句是针对异步可迭代对象所使用的。 异步可迭代对象是指内部是实现了__aiter__()方法的对象，它必须返回一个await iterator对象 异步迭代器 异步迭代器是指内部实现了__aiter__()和__anext__()方法的对象，其中__anext__()方法必须返回一个awaitable对象。 async for会处理异步迭代器的 __anext__()方法所返回的可等待对象，直到其引发一个StopAsyncIteration异常。由 PEP 492引入。 代码实现 下面实现一个异步可迭代对象，它的可迭代器就是本身。 import asyncio class Reader(object): \"\"\" 自定义异步迭代器（同时也是异步可迭代对象） \"\"\" def __init__(self): self.count = 0 async def readline(self): # await asyncio.sleep(1) self.count += 1 if self.count == 100: return None return self.count def __aiter__(self): return self async def __anext__(self): val = await self.readline() if val == None: raise StopAsyncIteration return val async def func(): # 创建异步可迭代对象 async_iter = Reader() # async for 必须要放在async def函数内，否则语法错误。 async for item in async_iter: print(item) asyncio.run(func()) async wait 异步上下文管理 此种对象通过定义__aenter__()和__aexit__()方法来对 async with 语句中的环境进行控制。由 PEP 492 引入。 import asyncio class AsyncContextManager: def __init__(self): self.conn = conn async def do_something(self): # 异步操作数据库 return 666 async def __aenter__(self): # 异步链接数据库 self.conn = await asyncio.sleep(1) return self async def __aexit__(self, exc_type, exc, tb): # 异步关闭数据库链接 await asyncio.sleep(1) async def func(): async with AsyncContextManager() as f: result = await f.do_something() print(result) asyncio.run(func()) 这个异步的上下文管理器还是比较有用的，平时在开发过程中 打开、处理、关闭 操作时，就可以用这种方式来处理。 uvloop Python标准库中提供了asyncio模块，用于支持基于协程的异步编程。 uvloop是 asyncio 中的事件循环的替代方案，替换后可以使得asyncio性能提高。事实上，uvloop要比nodejs、gevent等其他python异步框架至少要快2倍，性能可以比肩Go语言。 安装uvloop pip3 install uvloop 在项目中想要使用uvloop替换asyncio的事件循环也非常简单，只要在代码中这么做就行。 import asyncio import uvloop asyncio.set_event_loop_policy(uvloop.EventLoopPolicy()) # 编写asyncio的代码，与之前写的代码一致。 # 内部的事件循环自动化会变为uvloop asyncio.run(...) 注意：知名的asgi uvicorn内部就是使用的uvloop的事件循环。 官方文档 在程序中只要看到async和await关键字，其内部就是基于协程实现的异步编程，这种异步编程是通过一个线程在I/O等待时间去执行其他任务，从而实现并发。 以上就是异步编程的常见操作，其他具体的内容可参考官方文档。 中文版：https://docs.python.org/zh-cn/3.8/library/asyncio.html 英文本：https://docs.python.org/3.8/library/asyncio.html 此外，此篇文章基本借鉴于武Sir，再次特别感谢。 原文地址 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-08-21 15:19:52 "},"Python/Python驱动程序/summary.html":{"url":"Python/Python驱动程序/summary.html","title":"Python驱动程序","keywords":"","body":"Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-13 20:41:50 "},"前端专栏/summary.html":{"url":"前端专栏/summary.html","title":"前端专栏","keywords":"","body":" HTML CSS JavaScript jQuery Vue3 Webpack5 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-10-09 17:23:22 "},"前端专栏/HTML/summary.html":{"url":"前端专栏/HTML/summary.html","title":"HTML","keywords":"","body":" 基础知识 声明系标签 结构系标签 文本系标签 链接系标签 列表系标签 表格系标签 表单系标签 媒体系标签 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-07-10 19:51:56 "},"前端专栏/HTML/基础知识.html":{"url":"前端专栏/HTML/基础知识.html","title":"基础知识","keywords":"","body":"基础介绍 HTML全称为htyper text markup language，即超文本标记语言。 超文本：即超出了纯文字文本的范畴，它可以包含图片、链接、音乐等非文字元素 标记语言：由标签构成的语言，特点是学习简单上手容易 它最早诞生于1990年，由物理学家蒂姆·伯纳斯-李所创建，在1989年的时候蒂姆·伯纳斯-李就曾在一份备忘录中提出一个基于互联网的超文本系统这样的概念，并且在1990年规定出了HTML并在同年写出了浏览器与软件： 版本 年份 HTML 1991 HTML+ 1993 HTML 2.0 1995 HTML 3.2 1997 HTML 4.01 1999 XHTML 1.0 2000 HTML5 2012 XHTML5 2013 浏览器的作用 其实我们平时上网的过程就是一个不断上传、下载的过程。 浏览器会将我们输入的网址进行解析并请求服务器，服务器将资源返回后浏览器再将资源进行渲染并展示，最终构成了五彩缤纷的页面。 这里推荐大家统一使用Chrome浏览器，它应该算是目前前端开发人员首推的浏览器。 无论是渲染、调试等都是十分方便的，你可以打开浏览器后按f12得到控制台，在这里你可以做任何你想做的事。 而关于IDE的选择就有很多，你可以使用webstorm或者vscode。 认识文档树 我们拿一段最简单的HTML举例，可以暂时不用管他的内容，只看它的结构： Document HELLO WORLD 通过观察上面的这一小段代码，可以看出一个标准的HTML文档内容至少包含三部分，分别是最外部的标签，内部的标签和标签，而一个页面呈现的内容都会在标签中进行书写。 如果按照结构进行划分，那么我们就会得到一颗倒置的多叉树： 文档声明是什么 早期的浏览器种类繁杂，相同的代码在不同浏览器下的渲染结果都不相同。 为了避免这种差异化，万维网联盟（W3C）出台了一系列标准化的规范，如下这行代码： 就是声明该文档为HTML文档，告诉浏览器应当采用HTML标准模式进行渲染，如果不添加此标签代表使用浏览器自带的模式，也被称为怪异模式进行渲染，因此后面的学习中一定要将它加上。 怪异模式：BackCompat，浏览器使用自己的解析标准进行页面渲染 标准模式：CSS1Comapt，浏览器采用W3C的解析标准进行页面渲染 认识标签 什么是标签 标签是由一对儿尖括号包裹的单词构成，如就是一个标签。 标签分为闭合标签和自闭和标签。 闭合标签必须要有开始标签和结束标签，如： 自闭和标签则不需要结束标签，如： 自闭和标签我们通常会在后面加上一条斜杠，来更加容易区分： 标签名字不能以数字开头。 标签本身不区分大小写，如和渲染效果都是相同的，但是为了可读性更加推荐使用全小写。 此外，标签支持嵌套，如：，但是不支持交叉嵌套，如。 注释标签 注释标签是指不会被浏览器渲染的标签，作用是让人更好的理解这段代码的意思。 它以结尾。 内联标签 内联（inline）标签也被称为行内标签，它具有以下的一些特点： 不独占一行，可以和其他内联标签处于同一行上 不可设置宽度和高度，内联标签的宽高都是固定的 宽高本身是其内联标签文字或者图片的高度，不可以被改变 内联标签只能容纳文本或者嵌套其他的内联标签，不可嵌套块级标签 特殊的几个内联标签： img、input可以设置宽高，它们拥有内联标签和块级标签的特性，因此也被称为内联块级标签（inline-block） 块级标签 块级标签（block）常用于布局中，它具有以下的一些特点： 块级标签独占一行，这一行中不可并列其他的标签 可以设置宽度和高度 宽度的缺省值是容器的100%，除非设定一个宽度，换而言之就是一行占满 块级标签可以容纳文本或者嵌套其他的任何标签 特殊的几个块级标签： h~系、dt、p标签中只能包含内联标签，不能包含块级标签 认识属性 什么是属性 每个标签都能带上一些属性，这些属性或有特殊意义，或是开发人员自定义的用来存放某些特殊值的容器。 属性通常是以键值对形式出现，例如 gender=“male” 属性只能出现在开始标签或者自闭和标签中，不能出现在结束标签中 属性名字必须全部小写，属性值必须使用双引号或者单引号包裹，例如 gender=“male” 如果属性值合属性名一样，可以直接写属性名，例如 readonly id id属性是HTML4.0之后加入的，作用是用于定位某一个特定的标签，每一个标签的id属性在文档中必须是唯一的。 id属性在命名时，如果有多个单词则推荐使用 - 进行分割，这个主要涉及到与Js中window对象的冲突。 class class属性的作用是为一组相同功能的标签打上标识，用于对其添加CSS样式。 class属性在命名时，如果有多个单词则推荐使用 _ 进行分割，主要与id属性做区分。 文档渲染 渲染方式 浏览器的渲染是自上而下的，也就是说书写在HTML文档顶部的标签会比书写在HTML文档底部的标签先渲染到。 这个尤为重要，特别是后期学习CSS和JS的时候，它们的引入标签一般都要放在下面才能正确的找到并操纵HTML标签。 当然你也可以做一些特殊的处理，这里按下不表。 特殊字符 文档渲染的时候，有些字符不会被渲染出来。如多个空格仅显示一个，多个p标签仅一个生效等： h f 输入不会正常渲染等： 这个时候我们需要用到一些特殊字符来进行渲染，如下表所示： 特殊字符 含义 &nbsp; 空格 &lt; 小于号 &gt; 大于号 > &quot; 双引号 '' &copy; 圆圈c © &reg; 圆圈r ® &trade; 商标™ &amp; 符号& 流式排列 文档渲染的时候会按照自左向右自上而下的排列方式进行排列，这种排列方式也被称之为文档流排列。 如下所示，内联标签一行可以有多个，而块级标签独占一行。 标签修复 当一个HTML文档没有任何内容，仅只有一段文字时，浏览器会自动生成HTML结构并将文字放入body标签中： hello world 标签移动 所有的页面上展示的内容都要写在body标签中，如果写在了外面浏览器会自动将该内容移动进body标签里： Document this is title 渲染结果，h1标签被加入了body标签内： 表格处理 table标签中不允许放入非表格系的其他内容，否则浏览器在渲染时会将该内容放出去： Document this is title this is table 渲染结果，h1标签被移出了table标签内： 其他的知识 缩进规范 由于前端代码比较繁琐，故缩进推荐使用2空格进行缩进。 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-07-15 14:53:04 "},"前端专栏/HTML/声明系标签.html":{"url":"前端专栏/HTML/声明系标签.html","title":"声明系标签","keywords":"","body":"!DOCTYPE html 指定文档格式为HTML格式，浏览器会根据W3C的HTML标准格式渲染该文档中的内容。 该标签为必加标签。 html 根标签 HTML内容书写区域，也被称为根标签，所有的内容都应该写到他的内部。 属性：lang = “en” 表示页面是英文格式，翻译页面时会读取此值来获取当前页面是什么语言编写。 head 头部信息 该标签的作用是专门提供一下网页的配置信息，如网页的标题，检索内容，解码格式等等。 该部分内容虽然不会在页面展示，但也起到非常重要的作用。 title 页面标题 title标签用于指定网页的标题： link 页面图标 link标签可以设置网页标题上的图标： meta 元信息 meta标签可提供有关页面的元信息（meta-information），它能针对性的设置搜索引擎和更新频度相关的描述和关键词。 该标签位于head标签中，是一个自闭和标签。 它所提供的信息是用户不可见的。 字符编码 meta标签设置charset属性，可指定浏览器解析该文档时所使用的字符编码： Document 页面刷新 meta标签的http-equiv属性可用于页面刷新，指定该属性值为“Refresh”即可，此外你还应当在content属性中设置刷新频率。 下面这个示例中是五秒刷新一次页面，使用meta标签进行页面刷新的应用场景非常少，可忽略不计。 Document 页面跳转 meta标签的http-equiv属性还可用于页面跳转，指定该属性值为“Refresh”即可，此外你还应当在content属性中设置几秒后进行跳转，以及跳转的url，使用;进行分割。 下面这个示例中是两秒后跳转到google，使用meta标签进行页面跳转的应用场景非常少，可忽略不计。 Document 关键字筛选 meta标签的name属性可用于指定页面关键字，用于搜索引擎收录与关键字搜索。 如下所示，需要设置name属性为keywords以及在content中写入关键词即可： 网站描述 meta标签的name属性可用于书写网站描述信息，用于搜索引擎收录与网站分类。 如下所示，需要设置name属性为Description以及在content中写入网站描述即可： IE渲染 IE浏览器是前端开发领域最难搞的浏览器，因为它有一种自己的渲染规则，且每个IE版本的渲染规则都不一样。 meta标签的http-equiv属性设置为\"X-UA-Compatible”，即可告诉IE浏览器用最高级的渲染模式渲染当前页面： --> Document 国产浏览器渲染 一般的国产浏览器都会支持IE内核（兼容模式）和webkit内核（高速模式），且默认都是以兼容模式对页面进行渲染。 meta标签的name属性设置为”renderer”且content设置为“webkit”后，即可告诉国产浏览器用高速模式渲染当前页面： Document 触屏缩放 meta标签还可以设置页面是否支持触屏缩放的功能，只需将name设置为“viewport”以及在content中添加对应的选项即可。 如下所示： Document 常见的选项有： width=device-width：宽度按照设备屏幕宽度进行自适应 initial-scale=1.0：初始显示的缩放比例 minimum-scale=0.5：最小缩放比例 maximum-scale=1.0：最大缩放比例 user-scalable=yes：是否支持触屏缩放 常见的设置 上面就是关于head部分最常见的设置，最后放上一个模板： HTML学习 HELLO WORLD body 页面主体 body标签为页面主体标签，用户能看到的内容都包含在body标签内。 它里面能够书写的标签非常多，为了方便记忆我将它们分为了7类，如下所示： 文本系标签 结构系标签 链接系标签 列表系标签 表格系标签 表单系标签 媒体系标签 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-07-08 20:21:30 "},"前端专栏/HTML/结构系标签.html":{"url":"前端专栏/HTML/结构系标签.html","title":"结构系标签","keywords":"","body":"header 页眉标签 header标签代表一块内容区域的头部，一个页面中可以有一个或多个header标签。 它是一个块级标签： nav 导航标签 nav标签代表一块内容区域的导航，一个页面中可以有一个或多个nav标签。 它是一个块级标签： main 主内容标签 mian标签代表主要内容区域，一个页面中可以有一个或多个main标签，但通常只会定义一个。 它是一个块级标签： footer 页脚标签 footer标签代表一块内容区域的页脚，一个页面中可以有一个或多个footer标签，通常与header标签相对应。 它是一个块级标签： article 子内容标签 article标签代表一块子内容区域，一个页面中可以有一个或多个article标签。 它是一个块级标签： section 区块标签 article标签代表一个区块，一般是一组相似内容的排列组合，它可以有多个。 它是一个块级标签： aside 附加区域标签 aside标签代表一个附加内容块，可以放一些与主体内容无关的内容，如轮播图、广告、公告等。 它是一个块级标签： div 通用容器标签 div标签没有明确的界限来规定它做什么，与span标签类似。 上面标签能做的它都能做，所以他变成了一个万能的容器标签。 div标签是一个块级标签，你打开页面看见的都是它： Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-07-09 15:49:20 "},"前端专栏/HTML/文本系标签.html":{"url":"前端专栏/HTML/文本系标签.html","title":"文本系标签","keywords":"","body":"基础文本系标签 h~ 标题标签 h系列的标题标签拥有6个，即h1 - h6。 h系列标签会根据等级的大小，字体的粗细会发生相应的变化，h1最大、h6最小。 它是一个块级的自闭和标签，其内部只能嵌套内联标签，不能嵌套块级标签 Document h1 element h2 element h3 element h4 element h5 element h6 element 渲染结果： p 段落标签 p标签用于定义一段文本的内容，具有换行的功能。 p标签内只能存放文字系、图片系、表单系标签，其他的一律不要放进来，此外还需要注意p标签与br标签的区别。 它是一个块级标签： Document This is p element This is p element 渲染结果： br 换行标签 br标签用于对内容进行换行，注意与p标签的区别。 它是一个内联标签： Document This is p element This is p element this is a text this is a text 渲染结果： hr 水平线 hr标签会生成一条水平线，主要是用于对内容区域的划分。 它是一个块级标签： Document this is p element this is p element center 居中显示 center标签会将它内部的元素进行居中处理，h5中已经不推荐使用了。 它是一个块级标签： Document h1 element center h2 element don't center 渲染结果： font 普通文字 font标签没什么特别的效果，只有一个语义规定它应该包裹一串文字。被font包裹的文字可设置字体、尺寸和颜色，但是不推荐设置。 它是一个内联标签。 属性表： 属性 值 描述 color rgb(x, x, x) or #xxxxxx or color_name 设置字体颜色 face font_family 设置字体样式 size number 设置字体带下，1-7 如下所示： Document this is font 渲染结果： pre 原样显示 浏览器在渲染时，会对显示进行特殊处理，如多个空格压缩成一个。 此时可以选择使用pre标签对显示内容进行包裹，这样浏览器就不会特殊处理这一段显示内容了。 它是一个块级标签： Document A B C D E F 渲染结果： span 文本容器 span标签用于存放一些文本，它的语义并不是很明确，属于一个模糊的定位。 被span标签包裹的文本有极大的可能性后期会通过CSS进行样式修改，但若单纯使用HTML则没有任何明显的功能。 它是一个内联标签： Document #span-1{ color: red; font-style: italic; text-shadow: #ddd 5px 5px 0.4px; font-size: 22px; font-weight: bold; } This is a text 搭配CSS的渲染效果： 描述文本系标签 time 时间文本 time标签根据语义来进行区分的话可以用于存放时间类型的文本。 它是一个内联标签： Document current time 2016-02-18 渲染效果： abbr 描述文本 abbr标签用于存放一些具有描述的文本，它拥有一个title属性，title属性中可以放入一些描述信息。 当鼠标悬浮在abbr标签上，就可以显示title中所定义的描述信息。 它是一个内联标签： Document I want to say hello world 渲染效果，虽然具有下划线但是不必在意，后期CSS会帮你干掉他： sup - sub 角标 sup和sub用于定义上下角标，在书写一些数学公式时有用。 它们都是内联标签： Document sup : 3 2 sub : 3 2 渲染效果： code 代码文本 code标签中应当存放一些代码相关的文本，但是他没有任何特殊处理。 所以我们可以在外部套上pre标签，来达到代码原样显示的目的，这样代码的缩进才不会发生混乱。 它是内联标签： Document Here is a js code function show(){ console.log(\"hello world\"); } show() 渲染结果： progress 进度条 progress可生成一个进度条，它具有2个属性。 max：进度条长度 value：当前进度 后期可配合Js来进行控制。 它是一个内联标签： Document 渲染结果： address 地址信息 address用于设置地址信息。一般放在footer页脚中。 它是一个块级标签： Document 地址 : 北京市海淀区 渲染结果： 强调文本系标签 em - i 比较重要 em和i标签都意味着这段文字比较重要。 它们同属于内联标签： Document this is em element this is i element 渲染结果： strong - b 非常重要 strong和b标签都意味着这段文字非常重要。 它们同属于内联标签： Document this is strong element this is b element 渲染结果： del - s 已废弃 del和s标签都意味着这段文字已经废弃。 它们同属于内联标签： Document this is strong element this is b element 渲染结果： ins - u 已修正 ins和u标签都意味着这段文字已经修正，常和del与s标签搭配使用。 它们同属于内联标签： Document 原价：998 现价：9.8 渲染结果： mark 值得记录 mark标签都意味着这段文字值得记录，会以突出的方式进行显示。 它是一个内联标签： Document 普通文本 值得记录 渲染结果： 引用文本系标签 cite 引用信息 cite标签通常表示它所包含的文本对某个参考文献的引用，或文章作者的名字。 它属于块级标签： Document --再别康桥 &nbsp;&nbsp;轻轻的我走了，正如我轻轻地来 渲染结果： blockquote 块引用 blockquote标签通常来表示该段内容引用至其他地方。 它属于块级标签： Document --狂人日记 凡事总需研究，才会明白，古来时常吃人，我也还记得，可是不甚清楚。 我翻开历史一查，这历史没有年代，歪歪斜斜的每页上都写着“仁义道德”几个字。 我横竖睡不着，仔细看了半夜，才从字缝里看出来，满本都写着两个字是“吃人”！ 渲染结果： q 行内应用 q标签用于表示行内引用文本，在大部分浏览器中会加上引号。 它属于内联标签： Document --狂人日记 凡事总需研究，才会明白，古来时常吃人，我也还记得，可是不甚清楚。 我翻开历史一查，这历史没有年代，歪歪斜斜的每页上都写着“仁义道德”几个字。 我横竖睡不着，仔细看了半夜，才从字缝里看出来，满本都写着两个字是“吃人”！ 鲁迅先生的吃人一词用的恰到好处！ 渲染效果： Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-07-08 20:23:14 "},"前端专栏/HTML/链接系标签.html":{"url":"前端专栏/HTML/链接系标签.html","title":"链接系标签","keywords":"","body":"a 超链接 基本使用 a标签可定义一个超链接，用于从当前页面跳转到另一个页面。 a标签最重要的属性为href属性，它指向链接的目标。 它是一个内联标签： Document go to google search 渲染结果： 可以看见它虽然有一个下划线，但是不必在意，后期我们可以用CSS干掉他。 默认行为 如果一个a标签没有设置href属性的值，则默认它会刷新当前页面。 你可以给该属性的值设置为#或者“javascript:void(0)”以阻止它的默认行为： Document Don't Refresh 锚点定位 我们可以将a标签的href属性值设置为另一个标签的id属性，这样就可以做到锚点定位，href属性设置锚点的时候必须以#号跟上id的格式进行设置。 锚：指得是a标签的href属性 锚点：指的是被链接的标签id值 如下所示： Document goto chapter one goto chapter two goto chapter third goto chapter four Chapter One Chapter Two Chapter Third Chapter Four 拨打电话 针对移动端用户，a标签也可以用于拨打电话： Document call mobile customer service 渲染结果： 下载文件 如果a标签的href属性跟上一个下载链接地址，则可以下载到浏览器无法处理的文件。 如果要下载图像则需要后台语言先告知浏览器mime的类型： Document download image 常用属性 以下是a标签的常用属性： 属性 值 描述 href url 规定链接指向的url target _blank, _parent, _self, _top 规定在何处打开链接文档 title text 规定链接的标题描述 target属性是非常重要的，它有常用的4个属性，如下释义： _blank：在新窗口中打开链接文档 _parent：在父窗口中打开链接文档 _self：在当前窗口中打开链接文档（默认值） _top：在顶级窗口中打开链接文档 而title属性作用是在鼠标悬浮到a标签上时展示链接标题描述，这里不再例举。 img 图像资源 基本使用 img标签可使用src属性来链接一个图像资源，当前页面中会展示出该图像。 它是一个内联块级标签： Document 渲染结果： 三种格式 src属性支持3种格式的资源： base64位数据流格式 相对路径格式：./ 或者 ../ 网络资源格式：http:// 注意！它不支持file://，因为Unix下没有盘符的概念。 对于第一种，你可以打开网站图片数据流在线转换后传入图片获得base64位的数据流，然后添加至img标签的src属性中查看效果，这里不再进行演示。 等比缩放 如果要保证图像的等比例缩放，请只设置width和height属性其中一个。 Document 渲染结果： 图像链接 我们可以让a标签来包裹img标签，达到图像链接的目的。 前提是，a标签必须使用CSS将它设置为内联块级标签，以便内部嵌套img标签。 Document a{ display: inline-block; } 渲染效果： 常用属性 下面是img标签中常见的属性： 属性 值 描述 alt text 当图像加载失效后，将显示该属性值以替换图像 src url 图像的链接资源 width px、% 设置图像的宽度 height px、% 设置图像的高度 title text 设置图像的悬停文本 iframe 内联框架 基本使用 iframe标签的src属性可以将另外的整个页面都拿过来显示，类似于画中画的概念。 它是一个块级标签： Document Welcome to bilibili 渲染效果： 应用场景 钓鱼网站、伪Ajax请求。 iframe在实际开发中用的较少，但是在某些特定的场景下搭配一些其他的技术可达到令人意想不到的效果。 常用属性 下面是iframe标签中常见的属性： 属性 值 描述 name frame_name 规定iframe的名称 src url 规定在iframe中显示文档的url scrolling yes、no、auto 规定是否在iframe中显示滚动条 width px、% 规定iframe的宽度 height px、% 规定iframe的高度 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-08-03 18:42:24 "},"前端专栏/HTML/列表系标签.html":{"url":"前端专栏/HTML/列表系标签.html","title":"列表系标签","keywords":"","body":"ul - li 无序列表 基本使用 ul和li标签用于定义一个无序列表。 它们都是块级标签，使用ul来嵌套li标签，并在li标签中书写列表排列的元素. 你可以在li中书写任意元素，如a标签、纯文本、图片等： Document Unordered list go to google go to biying go to bilibili go to youtube 渲染结果： 样式修改 ul标签和li标签都可以修改样式，它们均有一个属性type，该属性可以定义以下的值： disc：实心圆（默认样式） circle：空心圆 square：实现块 1：数字列表（仅li支持设置） A：大写英文字母列表（仅li支持设置） a：小写英文字母列表（仅li支持设置） I：大写罗马字母列表（仅li支持设置） i：小写罗马字母列表（仅li支持设置） 如下所示： Document Unordered list set li styles separately DISC CIRCLE SQUARE Number Uppercase English letter Lowercase English letter Uppercase Rome letter Lowercase Rome letter Unordered list set ul styles unite SQUARE SQUARE SQUARE 渲染结果： 注意！当ul和li同时设置样式时，以li的样式为准。 ol - li 有序列表 基本使用 ol和li标签用于定义一个有序列表。 它们都是块级标签，使用ol来嵌套li标签，并在li标签中书写列表排列的元素。 你可以在li中书写任意元素，如a标签、纯文本、图片等： Document Ordered list go to google go to biying go to bilibili go to youtube 渲染结果： 样式修改 同ul一样，ol也支持修改列表样式，它的type属性共有以下8个值选项： disc：实心圆（默认样式） circle：空心圆 square：实现块 1：数字列表 A：大写英文字母列表 a：小写英文字母列表 I：大写罗马字母列表 i：小写罗马字母列表 我们单独设置li标签，来看一下不同的样式效果： Document Ordered list DISC CIRCLE SQUARE Number Uppercase English letter Lowercase English letter Uppercase Rome letter Lowercase Rome letter 渲染结果： 注意！当ol和li同时设置样式时，以li的样式为准。 升序降序 有序列表之所以称为有序，是因为它可以按照列表的排列对列表编号进行升序或者降序。 只需要使用ol标签的reversed属性进行设置即可，如果添加了该属性则是降序，不添加则为升序： Document asc A B C D E desc A B C D E 渲染结果： 起始值设定 给ul标签设置start属性，可用于生成初始编号，后续生成的编号都按照该初始编号进行生成： Document asc SQUARE SQUARE SQUARE SQUARE 渲染结果： dl - dt - dd 自定义列表 基本使用 使用dl、dt、dd来构建一个自定义列表，常见于小说章节预览、首页文章排列中。 dl用于声明这是一个自定义列表。 dt用于定义这是一个标题。 dd用于定义一个段落。 如下所示： Document dl dt dd Chapter One this is chapter one content ... Chapter Two this is chapter two content ... 渲染结果： Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-07-09 16:29:14 "},"前端专栏/HTML/表格系标签.html":{"url":"前端专栏/HTML/表格系标签.html","title":"表格系标签","keywords":"","body":"table 表格标签 table标签用于定义一个表格。 它是一个块级标签，内部可用于嵌套的元素较多： caption - 表格标题 thead - 表头结构（仅语义化标签，无实际作用） tbody - 表体结构（仅语义化标签，无实际作用） tfoot - 表尾结构（仅语义化标签，无实际作用） th - 表头单元格 td - 表体单元格 tr - 表行 如下所示，定义一个4行3列的表格： Document this is table name age gender Jack 18 male Mary 19 female .. .. .. 渲染结果： 边框合并 table标签应当设置的2个属性： border=\"1\" style=\"border-collapse:collapse;\" border：表格线的宽度，单位是px border-collapse：边框合并 这样看起来会好看许多： 表格大小 table标签可设置width和height属性，因此我们可以适当调整表格的大小： ... 渲染结果： 表格位置 表格的位置可以通过table标签的align属性来设置： left：表格居左 center：表格居中 right：表格居右 如下所示： ... 单元格合并 每个td或者th标签都有2个属性，rowspan和clospan，它们能够控制单元格的合并。 rowspan：纵向合并单元格（行合并） clospan：横向合并单元格（列合并） 如下所示： Document this is table name age gender other Jack 18 male Mary 19 female this is footage 渲染结果： Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-07-09 17:02:18 "},"前端专栏/HTML/表单系标签.html":{"url":"前端专栏/HTML/表单系标签.html","title":"表单系标签","keywords":"","body":"form 表单 基本介绍 form表单可用于向服务端提交数据，它是一个块级标签。 我们常见的登录框、留言板等很多功能都是通过form表单完成的，使用form表单进行数据提交会导致页面的刷新。 下面将采用flask框架作为后端，使用form表单进行一次数据提交。 后端代码，注意！表单action提交时不会触发浏览器的同源策略，所以后端并不需要做CORS： from flask import Flask from flask import request app = Flask(__name__) @app.route(\"/get\", methods=['GET']) def get_handler(): return f\"{request.args}\" @app.route(\"/post\", methods=['POST']) def post_handler(): return f\"{request.form}\" if __name__ == \"__main__\": app.run(debug=True) 前端代码： Document username password male female submit 整体效果如下： 前端提交的数据会被后端的服务器所接收到。 action 提交地址 form表单中action属性可设置表单内容的提交地址。 它指向一个url，一般情况下我们都会加上完整url，但如果你是前后端混合开发项目的话则可以不用加完整url。 下面这个是完整路径，如果点击提交表单它会朝这个url发起请求： 如果你把他改为非完整路径，它会朝当前页面发起请求，注意观察下面与上述地址栏中的端口变化： method 提交方式 form表单中的method属性可设置表单提交时的HTTP请求方式。 有2种选项： GET请求（form提交时的默认选择） POST请求 它们的区别如下。 GET请求： 没有请求体 数据必须控制在1KB之内 请求的数据会暴露在地址栏中（?之后，以&进行分割） POST请求： 有请求体 数据的大小没有上限 请求的数据不会暴露在地址栏中，因此相较于GET请求更加安全 以下行为将会触发GET请求： 地址栏直接输入地址并访问 点击页面a标签进行链接跳转 默认的form表单提交方式 img的图像资源请求 说的更直白一点，GET请求不能上传文件，但是POST请求可以上传文件。 enctype 数据编码 form表单中的enctype属性可设置表单提交时对于提交数据的编码方式。 application/x-www-form-urlencoded：url编码格式，也是form表单默认的编码格式，它不允许上传文件，一般配合GET方式使用 multipart/form-data：不对字符进行编码，它允许上传文件，一般配合POST方式进行使用 text/plain：将空格转换为“+”号，但不对特殊字符进行编码 url编码格式的特点： 将空格转换为 \"+\" 加号，特殊符号转换为 ASCII HEX 值 一言以蔽之，若想上传文件，则必须使用POST请求方式 + multipart/form-data的编码方式： target 提交结果 form表单中的target属性可设置表单提交后会在哪里打开action的提交结果。 有以下5个值： _blank：在新窗口中打开action的提交结果 _parent：在父窗口中打开action的提交结果 _self：在当前窗口中打开action的提交结果（默认值） _top：在顶级窗口中打开action的提交结果 framename：在内联框架iframe中打开action的提交结果 这个属性其实很少用到，但是该属性可以搭配一些其他的技术做到无页面刷新提交的功能，因此这里例举一下，后面也会有所介绍。 示例如下，提交后将会在新的页面打开提交结果： novalidate 取消验证 form表单中的novalidate属性可设置表单提交时不会验证填入数据的合法性。 有的input框可以设置为必填，如果一个必填的input框没有填入内容则在提交时浏览器将提示必须填写该字段，我们可以通过设定novalidate来取消这个验证功能。 如下是设置了提交验证的表单： submit 当点击提交时浏览器会提示你填入该字段： 如果为form表单加上了novalidate属性后，它将会直接提交，注意观察地址栏中的变化： submit 点击提交后页面会刷新一次，这代表已经绕过验证成功提交了： input 输入框 基本介绍 input标签为表单输入框，它是一个内联块级标签。 input框有多种形态，只需要设置属性type的值即可，如下表所示： 属性值 表现形式 对应代码 text 文本输入框 password 密码输入框 number 数字输入框 date 日期输入框 > checkbox 复选框 radio 单选框 submit 提交按钮 reset 重置按钮 button 普通按钮 hidden 隐藏输入框 file 文件选择框 image 图像域 list 数据列表栏 text 文本输入框 文本输入框可输入任何内容，它有2个最重要的属性name和value。 当form表单点击提交时，文本输入框会将输入的值赋值给value属性，并将name属性和value属性组成一组键值对提交给后端。 如果没有显式的设置value，那么这个文本输入框的内容是空的，当你输入内容后它会自动添加value属性并将所输入内容赋值给该属性： 渲染结果： 如果显式的设置了value，那么它就会作为默认值显示在文本输入框中： 渲染结果： 我们一般都不会这样做，而是利用placeholder属性来提示用户应该输入什么内容，placeholder属性在form表单提交时并不会被收集： 渲染结果： 除此之外，你可以使用required属性来规定该输入框是必填项，前提是form表单验证已被打开它才会生效： 如果使用了readonly属性，则该输入框就会变为只读，它通常和value设置的默认值搭配使用： 渲染结果： 你也可以使用disabled禁止该输入框，用户只能看到灰色被禁用的输入框，不能进行内容输入： 渲染结果： password 密码输入框 密码输入框和文本输入框差不多，不同的是输入内容时浏览器会用黑色实心圆遮蔽掉用户键入的内容： 渲染结果： 其他的属性和文本输入框通用。 number 数字输入框 数字输入框仅能够输入数字，不能输入其他的字符，可用于输入手机号： 其他的属性和文本输入框通用。 date 日期输入框 日期输入框可以上传一个年月日。 当input的type为datetime-local时，可以上传一份本地化的时间（年月日时分秒） 当input的type为date时，可以上传一份标准化的世界时间（年月日） 当input的type为month时，可以上传年份和月份 当input的type为time时，可以上传小时和分钟数 当input的type为week时，可以上传年份和周数 除此之外，你可以利用min属性设置开始时间，max属性设置结束时间，step属性设置步长即多少时间一个间隔： 如下所示： 渲染结果： checkbox 复选框 复选框常用于勾选兴趣爱好，一般来说都要具有多个。 像这种复选框或者单选框之类的，都应该显式的设置value，不然提交的数据则为空。 注意，一组复选框内的name应该都相同，而value则应该不同，如下所示： basketball: football: volleyball: 渲染结果： 当点击提交后，它会以列表的方式将所勾选的checkbox的value进行整合，类似于下面这种格式： { \"hobby\" : [\"basketball\", \"football\"] } 此外，如果你想让某个复选框设置为默认的，可为它添加checked属性即可： basketball: 这样在渲染页面时，该复选框就会被选中： 在某些特殊的情况下我们只会设置一个复选框，如用户必须点击已阅读协议后才能进行下一步操作，此时你可以将该复选框设置为required，即必填，然后搭配JavaScript做到这样的效果，这里不再例举。 radio 单选框 单选框的使用与复选框基本相同。 必须显式的设置value，且name要一致： male: female: 提交 渲染结果： 此外，如果想设置默认值，则在radio上加上checked属性即可。 如果想设置多个radio中必须至少选择一个，则在任意一个同组的radio上添加属性required即可。 submit 提交按钮 input的type设置为submit后，可用于提交表单的内容，你可以为其设置value属性值来指定按钮显示内容： 当点击该按钮后，form表单将发送数据至后端。 渲染结果： reset 重置按钮 input的type设置为reset后，可用于清空表单的内容，你可以为其设置value属性值来指定按钮显示内容： 当点击该按钮后，form表单中所有以填项都会被清空。 渲染结果： button 普通按钮 input的type设置为button后，可用于与JavaScript代码进行交互，你可以为其设置value属性值来指定按钮显示内容： Document \"use strict\"; document.querySelector(\"input[type=button]\").addEventListener(\"click\", () => { console.log(\"click in button\") }) 为该按钮绑定Js事件，点击按钮后将触发Js事件。 渲染结果： hidden 隐藏输入框 隐藏输入框可用于存储一些用户不可见的数据，如用户的ID号等信息，这在修改用户密码时很常用。 在进行form表单提交时，它将一起提交给后端： Document old password : new password : submit button 提交后的结果： ImmutableMultiDict([('user-id', '31926'), ('old_password', '123'), ('new_password', '456')]) file 文件选择框 当input的属性为file时，可用于上传文件。 注意，如想成功上传文件，则： form表单的method必须为POST form表单的enctype必须为multipart/form-data 如下示例，需要注意文本选择框也必须设置name属性，否则将无法上传文件： Document avatar : submit button 渲染结果如下： 后端flask可用request.files进行文件接收，以下是接收内容： ImmutableMultiDict([('avatar', )]) 我们为文本选择框新增属性multiple，用于一次性上传多个文件： avatar : 除此之外，我们也可以为文本框新增属性accept，用来指定允许上传文件的mime类型： avatar : 这样在文件选择时，你只能选择png或者gif格式的图片了： Image 图像域 图像域使用较少，因此不再举例，它类似于img标签和submit的集合体。 用于创建一个图片提交按钮，在点击时除了添加所有表单项之外，还会将鼠标位于图片上的坐标进行发送。 datalist 数据列表 通过数据列表，我们可以展示一些信息供用户选择，它由3种标签构成分别是input、datalist、option。 input首先设置为文本输入框，然后添加属性list并给定一个关键字，此外你还需要设置name属性。 而后输入datalist标签，该标签的id和文本输入框的list关键字一致。 在datalist标签中嵌套option标签，并设置value值，这样数据列表就做好了： Document city: Beijing Shanghai Tianjin Chongqing submit button 渲染结果： 注意！数据列表中一次只能选定一个选项。 input的常见属性 下表中将例举input中常见的属性： 属性 值 描述 name field_name 表单提交时的键 value text 表单提交时的值 placeholder text 输入提示 checked checked radio和checkbox默认选中 readonly readonly 只读 disabled disabled 禁用 required required 必填 size number 定义输入框显示宽度 min number 定义输入的字段最小值 max number 定义输入的字段最大值 pattern regexp 对输入内容进行正则验证 oninvalid JavaScript 当正则验证失败后运行的代码 autocomplete on 、off 自动记录键入输入历史 以下是常用属性举例： Document placeholder male: female: checked readonly disabled required size:3 min:10 max:100 email autocomplete submit button label 标签 基本介绍 label标签通常与input标签绑定使用，它将作为input标签的标注出现，它是一个块级标签。 label有一个特殊的属性，for，该属性的值应当与被绑定的input标签id值相同。 我们看一个简单的例子来理解label标签的作用，下面这个例子中是没有label标签的，当点击关键字“male”或者“female”时，浏览器不会自动聚焦到radio上： Document male: female: 渲染结果： 如果使用label标签作为radio的标注，则点击label标签文本时，浏览器将会自动的聚焦在radio标签上： Document male: female: select 选择框 基本介绍 select标签与optgroup标签（可选）和option标签搭配可作出选择框的效果。 它类似于数据列表，但比数据列表更加强大，以下是这3个标签的可选常用属性。 首先是select标签，它最少要设定一个属性name，作为键与option的value进行搭配： 属性 值 描述 name text 规定发往服务器的选项键 multiple multiple 规定下拉列表是否可以多选 autofocus autofocus 页面加载完成后文本区域自动获取焦点 disabled disabled 禁用该下拉列表 required required 规定文本区域是必填的 size number 规定下拉列表中可见选项的数目 其次是optgroup标签，这是一个可选标签，也就是说选择框的组成它并不是必须的： 属性 值 描述 label text 为选项组规定描述 disabled disabled 禁用该选项组 最后是option标签，它最少要设定一个属性value，作为值与select标签的name进行搭配： 属性 值 描述 value text 规定发往服务器的选项值 label text 定义当使用optgroup时所使用的标注 selected selected 规定默认选中的选项 disabled disabled 规定此选项应当在首次加载时禁用 单项选择框 下面是一个单项选择框的示例： Document city: Beijing Shanghai Tianjin Chongqing NewYork SanFrancisco LosAngeles Miami submit button 渲染结果： 多项选择框 如果为select标签新增multiple属性，则该选择框可变为多选： Document city: Beijing Shanghai Tianjin Chongqing NewYork SanFrancisco LosAngeles Miami submit button 渲染结果： 默认选中 当option标签设置为selected后，该标签会被默认选中： Document city: Beijing Shanghai Tianjin Chongqing NewYork SanFrancisco LosAngeles Miami submit button 渲染结果： textarea 文本域 textarea标签与文本输入框类似，但是能够输入更多的内容。 它是一个内联标签，以下是常用属性： 属性 值 描述 name text 规定发往服务器的选项键 autofocus autofocus 规定在页面加载后文本区域自动获得焦点 maxlength number 规定该文本域所支持输入的最大字符数 placeholder text 规定描述文本区域预期值的简短提示 rows number 规定文本域的可见行数，即高度 cols number 规定文本域的可见列数，即宽度 required required 必填 readonly readonly 只读 disabled disabled 禁用 如下所示： Document submit button 渲染结果： fieldset - legend 美化标签 fieldset和legend标签都是块级标签，没什么特别明显的作用就是为了美化元素。 fieldset：为被包裹元素外加上一个框，主要为字段进行逻辑分组 legend：作为fieldset标签的标题出现 如下所示： Document 用户信息 用户名: 密码: 性别 male: female: 其他信息 爱好 篮球 足球 排球 个人介绍 居住城市 北京 上海 天津 重庆 纽约 旧金山 洛杉矶 迈阿密 提交 渲染结果： button 按钮 button标签是一个块级标签，它有一个非常重要的属性type，可设置以下3个常用值： submit：作用和相同，如果不指定type，默认就是它 button，作用和相同 reset，作用和相同 相较于input的按钮，我更倾向于使用button，因为它的语义更加明确。 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-08-16 21:43:16 "},"前端专栏/HTML/媒体系标签.html":{"url":"前端专栏/HTML/媒体系标签.html","title":"媒体系标签","keywords":"","body":"video 视频 video标签可用于播放视频，但是他的效果并不是很好，所以推荐使用一些第三方插件，如： 阿里云播放器 video.js 以下是viedo标签的常用属性，它是一个块级标签： 属性 描述 autoplay 视频自动播放，即视频加载完后会立即播放而不是等待用户进行手动点击 preload 视频预加载，设置为auto即可，它会根据网络情况自动加载视频 controls 视频播放按键，该属性是必须的 height 视频窗口高度 width 视频窗口宽度 loop 视频循环播放 muted 视频播放时静音 poster 视频未播放时显示的图像 src 视频地址 代码如下： Document 渲染结果： audio 音频 audio标签主要用于音频播放，它和video标签基本类似。 以下是audio标签的常用属性，它是一个块级标签： 属性 描述 autoplay 音频自动播放，即音频加载完后会立即播放而不是等待用户进行手动点击 preload 音频预加载，设置为auto即可，它会根据网络情况自动加载视频 controls 音频播放按键，该属性是必须的 loop 音频循环播放 muted 音频播放时静音 src 音频地址 具体效果这里不再演示。 source 媒介元素 有些浏览器不支持多媒体格式，我们可以在video标签或者audio标签中嵌套进source标签，让浏览器支持该种格式的媒体： 使用时注意source标签的src和type属性即可。 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-07-10 16:24:10 "},"前端专栏/CSS/summary.html":{"url":"前端专栏/CSS/summary.html","title":"CSS","keywords":"","body":" 基础知识 选择器 属性继承 常见单位 文本控制 数据样式 背景处理 盒子模型 浮动布局 定位布局 弹性布局 栅格布局 变形动画 过渡时间 帧动画 响应式布局 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-07-20 08:26:14 "},"前端专栏/CSS/基础知识.html":{"url":"前端专栏/CSS/基础知识.html","title":"基础知识","keywords":"","body":"CSS介绍 基本介绍 CSS全称为Cascading Style Sheet，译为层叠样式表。 它能够为HTML进行样式美化以及页面布局。 如果将单纯的HTML所构成的页面当做一副素描画，那么CSS的作用就是为这幅素描画进行上色处理。 当然CSS也能对HTML文档进行布局，让其不再使用默认的文档流排列方式，而是利用CSS让元素进行自由的组合、排列。 值得一提的是在早期没有出现CSS时，对HTML布局我们大多会使用table标签来进行，但是CSS诞生后就不会那么做了，使用CSS布局更加的方便。 关于CSS的学习可分为三大块： 如何选择标签元素 如何操纵标签元素 如何对页面进行布局 版本更迭 CSS1 1994年，哈肯·维姆·莱和伯特·波斯合作设计CSS。他们在1994年首次在芝加哥的一次会议上第一次展示了CSS的建议。 1996年[11]12月发表的CSS1的要求有：[13] 支持字体的大小、字形、强调 支持字的颜色、背景的颜色和其他元素 支持文章特征如字母、词和行之间的距离 支持文字的排列、图像、表格和其他元素 支持边缘、围框和其他关于排版的元素 支持id和class CSS2-2.1 1998年[11]5月W3C发表了CSS2[14]，其中包括新的内容如： 绝对的、相对的和固定的定比特素、媒体型的概念、 双向文件和 一个新的字体。 CSS2.1修改了CSS2中的一些错误，删除了其中基本不被支持的内容和增加了一些已有的浏览器的扩展内容。[15] CSS3 CSS3标准已部分公布，但仍未全部制订完毕，还会有其它新内容继续加入。W3C网站上有专页展示CSS3发展的进展[16]。 CSS3的标志。 CSS3分成了不同类别，称为“modules”。而每一个“modules”都有于CSS2中额外增加的功能，以及向后兼容。CSS3早于1999年已经开始制订。[17]直到2011年6月7日，CSS 3 Color Module终于发布为W3C Recommendation。[18] CSS3里增加了不少功能，如：“border-radius”、“text-shadow”、“transform”以及“transition”。CSS3亦支持动画（animation）及立体（preserved-3d）。 部分属性（例如旋转类属性（如：transform），动画类属性，立体类属性），由于现时不同浏览器支持程度不同，需要加上不同的浏览器前缀来区分。 CSS4 W3C于2011年9月29日开始了设计CSS4[19][20]。直至现时只有极少数的功能被部分网页浏览器支持，如使用在HTML而非SVG上的pointer-events[21]。 CSS4增加了一些更方便的选择器，并简化了一些现有选择器的用法。 如何使用CSS 行内式 直接在HTML标签元素中添加style属性并书写CSS代码的方式即为行内式。 行内式并不推荐使用，它对后期维护造成了一些很大的困惑，且代码复用性也较低： Document HELLO WORLD 渲染结果： 嵌入式 在head标签中内嵌style标签，并在style标签中书写CSS代码的方式被称为嵌入式。 嵌入式在调试代码时使用很方便，但是后期项目上线应该将CSS代码和HTML做好分离： Document span:nth-child(1){ background-color: red; color: white; padding: 5px; font-style: italic; } HELLO WORLD 渲染结果： 链接式 在head标签中内嵌子标签link，利用link标签来链接一个已经书写好的CSS样式文件的方式被称为链接式。 链接式是实际生产中最常用的导入CSS样式的方式。 HTML文档： Document HELLO WORLD CSS文件： span:nth-child(1){ background-color: red; color: white; padding: 5px; font-style: italic; } 渲染结果： 导入式 在head标签中内嵌子标签style，style标签中利用CSS所提供的语法@import url(“path”)来导入一个已经书写好的CSS样式文件的方式被称为导入式。 导入式的方式在整合CSS代码时比较常见，如下所示。 HTML文档： Document @import url(\"./all_style.css\"); HELLO WORLD HELLO CSS 整合的CSS文件，all_style.css： @import url(\"./style1.css\"); @import url(\"./style2.css\"); 单独的CSS文件，style1.css： span:nth-child(1){ background-color: red; color: white; padding: 5px; font-style: italic; } 单独的CSS文件，style2.css： div:nth-of-type(1){ background-color: blue; color: white; padding: 5px; font-style: italic; margin-top: 5px; } 渲染结果： 样式重置 所有的HTML都有一些自带的样式，比如body文档有边距并不是直接铺满整个屏幕的，ol、ul等默认样式都是黑色实心圆、a标签有下划线等。 在实际的项目开发中，我们应当将这些默认样式全部取消掉，因此有人专门做了一个CSS文件，名为CSS Rest即为CSS样式重置，在编写CSS代码之前，我们应当先导入这个文件： /* http://meyerweb.com/eric/tools/css/reset/ v2.0 | 20110126 License: none (public domain) */ html, body, div, span, applet, object, iframe, h1, h2, h3, h4, h5, h6, p, blockquote, pre, a, abbr, acronym, address, big, cite, code, del, dfn, em, img, ins, kbd, q, s, samp, small, strike, strong, sub, sup, tt, var, b, u, i, center, dl, dt, dd, ol, ul, li, fieldset, form, label, legend, table, caption, tbody, tfoot, thead, tr, th, td, article, aside, canvas, details, embed, figure, figcaption, footer, header, hgroup, menu, nav, output, ruby, section, summary, time, mark, audio, video { margin: 0; padding: 0; border: 0; font-size: 100%; font: inherit; vertical-align: baseline; } /* HTML5 display-role reset for older browsers */ article, aside, details, figcaption, figure, footer, header, hgroup, menu, nav, section { display: block; } body { line-height: 1; } ol, ul { list-style: none; } blockquote, q { quotes: none; } blockquote:before, blockquote:after, q:before, q:after { content: ''; content: none; } table { border-collapse: collapse; border-spacing: 0; } 注释语法 CSS中若要添加注释，格式如下： /* Comment */ 它可以支持多行注释。 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-08-15 15:49:26 "},"前端专栏/CSS/选择器.html":{"url":"前端专栏/CSS/选择器.html","title":"选择器","keywords":"","body":"基本选择器 * 通用选择器 *会选择所有元素，无视层级。常用于做样式清除，如内边距、外边距清除等。 示例如下，将所有的标签元素文本设置为红色： Document * { color: red; } span element mark element time element p element 渲染结果： E 名字选择器 名字选择器可通过标签名进行选择，无视层级。 示例如下，仅将p标签的文本设置为红色： Document p { color: red; } span element mark element time element p element 渲染结果： # ID选择器 根据标签的id属性来选择元素，无视层级，因HTML标签的id属性具有唯一性，故该选择器每次只能选择一个元素。 它以#作为关键字，后面跟上id即可。 示例如下，将id属性为a的标签文本设置为红色： Document #a { color: red; } span element mark element time element p element 渲染结果： . 类选择器 根据标签的class属性来选择元素，无视层级，因HTML标签的class属性不具有唯一性，故该选择器一次可以选择多个元素。 它以 . 作为关键字，后面跟上class即可。 示例如下，将class属性为inline的标签文本设置为红色： Document .inline { color: red; } span element mark element time element p element 渲染结果： 组合选择器 Feature 交集选择器 交集选择器可以从一组具有特性的共同的元素中取出一个具有独特特征的元素。 示例如下，有2个div： 一个div的id为a 一个div的class为a 若我们想选择其中的一个进行渲染，则必须要使用到交集选择器： 标签名字是div且id是a的标签会选择出第一个div 标签名字是div且class是a的标签会选择出第二个div 由于这种性质，交集选择器也可被称为特征选择器，示例如下： Document div#a { color: blue; } div.a { color: red; } div-id-a div-class-a 渲染结果： E, F 并集选择器 并集选择器可通过逗号来一次选取多个元素。 示例如下，将mark和time标签的文本设置为红色： Document mark, time { color: red; } span element mark element time element p element 渲染结果： E F 后代选择器 后代选择器可以寻找某个元素下的特定元素，它的寻找层级是没有上限的，关键字为空格， 示例如下，我们需要寻找div中嵌套的article中的id为a的mark标签，可直接通过后代选择器进行查找： Document div mark#a { color: red; } time element mark element time element mark element p element 渲染结果： E > F 子代选择器 子代选择器可以寻找某个元素子级下的特定元素，它的寻找层级为1层，关键字为>。 示例如下，我们需要寻找div中嵌套的article中的id为a的mark标签，通过子代查找器就必须严格的对元素关系进行书写，不能跨代： Document div>article>mark#a { color: red; } time element mark element time element mark element p element 渲染结果： E + F 同级毗邻选择器 E+F会查找紧随E元素后的F元素。 即通过哥哥元素找紧挨着自己的弟弟元素。 示例如下： Document /* div的后面必须是p，p的前面也必须是div */ div+p { color: red; } div p div p p 渲染结果： E ~ F 同级多跨选择器 E~F会查找在E元素后的所有F元素。 即通过哥哥元素找自己的所有弟弟元素。 示例如下： Document /* div后面的所有p */ div~p { color: red; } div span p p article p 渲染结果： 伪类选择器 动态伪类选择器 动态伪类选择器是比较常用的一种伪类选择器，如表所示： 选择器 类型 功能描述 E:link 链接伪类选择器 选择匹配的E元素，而且匹配元素被定义了超链接并未被访问过。常用于链接锚点上 E:visited 链接伪类选择器 选择匹配的E元素，而且匹配元素被定义了超链接并已被访问过。常用于链接锚点上 E:active 用户行为选择器 选择匹配的E元素，且匹配元素被激活。常用于链接锚点和按钮上 E:hover 用户行为选择器 选择匹配的E元素，且用户鼠标停留在元素E上。IE6及以下浏览器仅支持a:hover E:focus 用户行为选择器 选择匹配的E元素，而且匹配元素获取焦点时的行为 动态伪类选择器主要针对a标签： Document /* 没点过是红色 */ a:link { color: red; } /* 点击时是绿色 */ a:active { color: green; } /* 点过后是蓝色 */ a:visited { color: blue; } /* 鼠标悬浮时出现阴影 */ a:hover { box-shadow: #ddd 10px 2px 3px; } /* 获得焦点时显示边框 */ a:focus { border: 1px solid red; } click me 目标伪类选择器 目标伪类选择器只有1个，如表所示： 选择器 功能描述 :target 匹配a标签所指向的锚点 这个常用在a标签上，当点击这个a标签后，与这个a标签对应的锚点标签发生变化，示例如下： Document :target { background-color: red; } link first first element link second second element link third third element 渲染结果： 状态伪类选择器 状态伪类选择器主要针对input标签，如表所示： 选择器 示例 说明 :enabled input:enabled 选择每个启用的 input 元素 :disabled input:disabled 选择每个禁用的 input 元素 :checked input:checked 选择每个被选中的 input 元素 :required input:required 选择包含required属性的元素 :optional input:optional 选择不包含required属性的元素 :valid input:valid 选择验证通过的表单元素 :invalid input:invalid 选择验证不通过的表单 这些都很好理解，所以这里就不再进行演示了。 否定伪类选择器 否定伪类选择器只有1个，如表所示： 选择器 功能描述 E:not(F, G) 匹配所有E元素，包含F或者G条件的除外，如果直接使用:not(ele, ele)则相当于反选所有标签 示例如下，选择所有class属性为a的元素，h1排除在外： Document .a:not(h1) { color: red; } h1 element p element div element 渲染结果： 结构伪类选择器 结构伪类选择器是最常用的选择器，如表所示： 择器 功能描述 :root 匹配根元素，即html标签 E:first-child 匹配E元素，并且E元素要作为第一个子元素出现 E:last-child 匹配E元素，并且E元素要作为最后的子元素出现 E:nth-child(n) 根据位置匹配正数第n个子元素E。其中n可以是整数（1，2，3）、关键字（even，odd）、可以是公式（2n+1）,而且n值起始值为1，而不是0 E:nth-last-child(n) 根据位置匹配倒数第n个子元素E。此选择器与E:nth-child(n)选择器计算顺序刚好相反，但使用方法都是一样的，其中：nth-last-child(1)始终匹配最后一个元素，与last-child等同 E:nth-of-type(n) 根据类型匹配正数第n个E元素 E:nth-last-of-type(n) 根据类型匹配倒数第n个E元素 E:first-of-type 根据类型匹配第一个E元素 E:last-of-type 根据类型匹配最后一个E元素 E:only-child 匹配独生子E元素 E:only-of-type 匹配只有一个孩子的E元素 E:empty 匹配没有孩子的E元素 注意事项： 参数n可以是从1开始的数字 可以是公式，如（2n+1） 可以是odd，它将选择所有奇数项（从1开始计数） 可以是even，它将选择所有的偶数项（从1开始计数） 这些选择器刚开始理解可能很难，但是用习惯了后会发现真的非常方便。 下面是案例代码： Document :root { /* 直接使用root，选择的是html标签 */ background-color: wheat; } h1:first-child { /* h1必须是第一个子元素，刚好body标签的第一个子元素就是h1 */ color: blue; font-size: 3rem; } main:last-child { /* main必须是最后一个子元素，刚好body标签的最后一个子元素就是main */ border: 1px solid #ddd; background-color: aqua; } main p:nth-child(2) { /* 选择main标签下的第二个子标签，该子标签必须为p */ background-color: red; } ul li:nth-last-child(2) { /* 选择ul标签下的倒数第二个子标签，该子标签必须为li */ background-color: aquamarine; } ul li:nth-of-type(1) { /* 选择ul标签下的第一个子标签，该子标签必须为li */ background-color: deeppink; } ul li:nth-last-of-type(3) { /* 选择ul标签下的倒数第三个子标签，该子标签必须为li */ background-color: deepskyblue; } li:first-of-type { /* 第一个出现的li标签 */ font-size: 1.5rem; } li:last-of-type { /* 最后一个出现的li标签 */ font-size: .9rem; } aside:only-child { /* 选择是独生子的标签，且该标签必须是aside标签 */ font-size: 1.8rem; } footer:only-of-type { /* 选择只有一个儿子的标签，且该标签必须是footer标签 */ background-color: aquamarine; } section:empty { /* 选择没有后代的标签(也包括文本)，且改标签必须是section */ height: 2rem; border: red 1px solid; } hello world li-1 li-2 li-3 div p article aside 属性选择器 属性选择器经常用到，使用它的时候应该考虑到和其他选择器一起搭配使用，如交集选择器。 选择器 功能描述 [attribute] 用于选取带有指定属性的元素 [attribute=value] 用于选取带有指定属性和值的元素 [attribute~=value] 用于选取属性值中包含指定词汇的元素 [attribute|=value] 用于选取带有以指定值开头的属性值的元素，该值必须是整个单词 [attribute^=value] 匹配属性值以指定值开头的每个元素 [attribute$=value] 匹配属性值以指定值结尾的每个元素 [attribute*=value] 匹配属性值中包含指定值的每个元素 示例如下，匹配type为text的input标签： Document input[type=text]{ background-color: red; } 渲染结果： 如果想匹配checked或者disabled这种属性名和属性值一样的标签元素，则只需要输入属性名即可，总而言之，每一个[]都是一个属性，通过多个属性的查找，即可进行高精度筛选： Document input[type=text][disabled]{ background-color: red; } 渲染结果： 文本选择器 文本选择器用的比较少，如表所示： 选择器 功能描述 ::first-line 匹配文本首行 ::first-letter 匹配文本首字母 ::selection 匹配被鼠标划中的文本 如下示例： Document blockquote::first-line{ color:blue; } blockquote::first-letter{ font-size: 2rem; } blockquote::selection{ background-color: yellow; } --狂人日记 凡事总需研究，才会明白，古来时常吃人，我也还记得，可是不甚清楚。 我翻开历史一查，这历史没有年代，歪歪斜斜的每页上都写着“仁义道德”几个字。 我横竖睡不着，仔细看了半夜，才从字缝里看出来，满本都写着两个字是“吃人”！ 渲染结果： 文本插入器 文本插入器有2个： 插入器 描述 ::before 使用 contnet 属性生成额外的内容并插入在标记中，插在前面 ::after 使用 content 属性生成额外的内容并插入在标记中，插在后面 相当于在被选中标签中再插入2个普通的inline标签，注意这2个标签的content的属性是必须的，它规定被插入标签的内容。 此外还需要注意，新插入的内容会改变原标签的大小，所以谨慎使用。 示例如下： Document div { color: yellowgreen; } div::before { content: \"before\"; color: deeppink; } div::after { content: \"after\"; color: deepskyblue; } &nbsp;mid&nbsp; 渲染结果： Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-08-16 21:49:56 "},"前端专栏/CSS/属性继承.html":{"url":"前端专栏/CSS/属性继承.html","title":"属性继承","keywords":"","body":"选择器优先级 不同的选择器具有优先级，如果一个元素同时被多个选择器所选择且设置了同名样式时，它会按照优先级来判定应用哪一个选择器的样式。 如果优先级相同，则下面的选择器生效，常见优先级示例： 行内式渲染：1000 id选择器：100 class选择器：10 name选择器：1 当使用组合选择器时，优先级会进行累加，如下所示： Document /* 有同名属性时会根据优先级排定应用哪一个属性 */ h1 { /* 优先级 = 1 */ color: blue; background-color: red; } h1#title { /* 优先级 = 1 + 100 */ color: white; } HELLO WORLD 最终结果，同名属性color会渲染为第二个选择器： !important 我们可以使用!important关键字来强制更改优先级，让其优先级变的无限高。 有2个需要注意的地方： 如果同名样式都设置成!important，则!important带来的优先级提升会相互抵消，依旧按照选择器优先级来选择最终样式的渲染 如果2个同名样式的选择器优先级相同，还是按照后者覆盖前者的特性进行渲染 所以说，!important不能滥用，大量使用!important可能导致你代码可读性变差： Document /* 有同名属性时会根据优先级排定应用哪一个属性 */ h1 { /* 优先级 = 1 + 无限 */ color: blue !important; background-color: red; } h1#title { /* 优先级 = 1 + 100 */ color: white; } HELLO WORLD 最终结果： 属性继承 对于子标签来说，其父级别或更高级别标签的某些样式是可以被继承的，如： 颜色相关样式 字体相关样式 文本相关样式 但是对于盒模型中的一些属性，如内外边距、浮动等是不能被继承的。 继承而来的属性无限趋于0，可直接被替换掉，并且不能使用!important来提升被继承属性标签的优先级，!!mportant只能影响自身。 如下所示，当div的background-color设置为red，color设置为white后，其内部嵌套标签也会继承到这些属性： Document div{ background-color: red; color: wheat; } h1 h2 h3 h4 h5 h6 渲染结果： 我们可以保留一些继承项，并覆盖掉一些继承项，如下所示： Document div{ background-color: red; color: wheat; } div :nth-child(odd){ background-color: blue; } h1 h2 h3 h4 h5 h6 渲染结果： Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-07-16 20:14:52 "},"前端专栏/CSS/常见单位.html":{"url":"前端专栏/CSS/常见单位.html","title":"常见单位","keywords":"","body":"像素大小 px px是固定的像素单位，如果你的网页要在多端进行使用那么尽可能的少使用它，它不具有响应式的特性。 如下所示： Document div:first-of-type{ font-size: 12px; } div:last-of-type{ font-size: 18px; } 字号设置：12px 字号设置：18px 渲染结果： % 百分数是子元素相对于父元素设置的大小，比如父元素的大小是18px，那么子元素设置为50%就是9px，如下所示： Document main{ font-size: 18px; } div:first-of-type{ font-size: 50%; } div:last-of-type{ font-size: 200%; } 字号设置：main 18px 字号设置：50% = 9px 字号设置：200% = 32px 渲染结果： em em和百分号类似，它也是相较于父元素设置子元素的大小，1em相当于100%，0.5rem相当于50%。 注意，如果是0.x开头的，可直接简写为.x，如下所示： Document main{ font-size: 18px; } div:first-of-type{ font-size: .5em; } div:last-of-type{ font-size: 2em; } 字号设置：main 18px 字号设置：.5em = 9px 字号设置：2em = 36px 渲染结果： rem rem是em的升级版，也是推荐使用的方式。所有的大小设置不会按照父元素的值变化而变化，而是统一以html文档的值做参照。 默认的Chorme浏览器的html文档字号大小为16px，如果某个元素设置为.5rem则是8px。 如下所示： Document :root{ font-size: 16px; } div:first-of-type{ font-size: .5rem; } div:last-of-type{ font-size: 2rem; } 字号设置：html 16px 字号设置：.5em = 8px 字号设置：2em = 32px 渲染结果： 颜色格式 #xxxxxx #xxxxxx（x为16进制数）中所有的x均相同时，可简写为#xxx。 如下所示： Document div:first-of-type{ color: #ddd; } div:last-of-type{ color: #ff0000; } 颜色设置：#ddd 颜色设置：#FF0000 渲染结果： word 可以直接用单词来设置颜色，如color:red;或者color:blue;等。 如下所示： Document div:first-of-type{ color: blue; } div:last-of-type{ color: red; } 颜色设置：blue 颜色设置：red 渲染结果： rgb(xxx, xxx, xxx) rgb是三原色，红绿蓝。格式为color:rgb(0~255, 0~255, 0~255)，括号中的数字也可以用单词代替。 如下所示： Document div:first-of-type { color: rgb(0, 0, 255); } div:last-of-type { color: rgb(255, 0, 0); } 颜色设置：blue 颜色设置：red 渲染结果： rgba(xxx, xxx, xxx, n) rgba相较于rgb来说，括号中多了第4位数值n，n的范围为0-1，用于指定透明度。 如下所示： Document div:first-of-type { color: rgba(0, 0, 255, .5); } div:last-of-type { color: rgba(255, 0, 0, .8); } 颜色设置：blue 透明度：50% 颜色设置：red 透明度：80% 渲染结果： RGB颜色对照表 以下是RGB颜色对照表： 图片格式 常见的图片格式有jpg、jpeg、png、gif、svg、tif、tiff等，它们都有不同的用途，以下是对这些格式的图片简单描述： jpg/jpeg：最适合保存照片或栩栩如生的图像。 绝大多数计算机和网络用户主要使用 JPEG 文件在线上传、下载或查看图像。保存在 JPEG 中可以压缩照片并使用相当小的文件大小，从而可以更快地下载和上传。这意味着使用 jpeg 可以获得高质量的图像，不会占用大量空间。从网络上传或下载图像时，JPEG 应该是首选的存储文件 png：最适合使用透明背景截屏和保存 PNG 文件主要供图形设计师、使用品牌和徽标的营销人员以及有大量空间在计算机上保存内容的网络用户使用。PNG 通常用于在图像上编辑图像，或在图像上编辑文本。这是因为保存为 PNG 允许将图像或图形放在透明背景上，因此可以创建徽标覆盖。对于线条或文本，PNG 还提供比 jpeg 更“清晰”的图像，因此它们也经常用于屏幕截图。由于 PNG 与 JPEG 文件相比占用了相当多的空间，因此最好避免使用它们，除非您需要透明的背景图像，或者文件大小不是问题 svg：最适合保存需要以数字方式放大或缩小的图形 SVG 文件主要由 Web 设计人员使用，这些设计人员处理的图像和图形将在许多不同大小的媒体上显示和使用。保存在 SVG 中可以实现无缝缩放，或允许图形在不同大小的屏幕上清晰显示（或在屏幕上放大）而不会损失图像质量或“像素化”。徽标通常使用 SVG 文件创建，因为徽标通常显示在视网膜屏幕上，或者需要在不降低质量的情况下放大和缩小 gif：最适合保存颜色有限的图像或短动画，或颜色有限的图形 历史上，GIF 文件主要用于存储颜色有限的图形或图像，不会占用大量存储空间。在当今世界，GIF 主要用作互联网上、消息平台之间来回以及流行文化中的有趣、短循环动画。尽管动画 GIF 占用的存储空间比视频少得多，但它们比 SVG 或 PNG 占用更多的空间。这个存储问题，除了动画循环的一些断断续续的交付（和有限的色谱）之外，还可能使 GIF 动画文件不如 SVG 或 PNG 文件受欢迎 tif、tiff：最适合保存将用于打印的图像 TIFF 文件主要由处理印刷材料的图形设计师使用。在使用数字媒体（网络使用的图像和图形、电子邮件等）时，TIFF 很可能不是您的首选媒体，因为它明显缺乏数字支持。虽然保存在 TIFF 中允许保存图层并在图形或照片中表示许多颜色，但它并不是所有 Web 浏览器或应用程序都支持的文件，并且它不能很好地压缩，因此仅适用于打印用 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-07-12 14:10:48 "},"前端专栏/CSS/文本控制.html":{"url":"前端专栏/CSS/文本控制.html","title":"文本控制","keywords":"","body":"基础设置 字体家族 font-family 使用font-family可定义多个字体，浏览器会按照从左至右的顺序进行查找这些字体。 为什么需要定义多个字体？原因是如果你只使用了一种字体而恰好用户的计算机中并没有该字体就会降低显示效果。 代码示例： Document :root { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; } English display result 中文显示结果 渲染结果： 自定义字体 @font-face 我们可以自定义一些字体，但是在使用自定义字体时应该先导入字体文件。 注意，字体文件导入后应当进行format，告知浏览器字体文件所代指字体的格式。 如下表所示： 字体文件后缀 format .otf opentype .woff woff .ttf truetype .eot Embedded-opentype 代码示例： Document /* 自定义一个字体*/ @font-face { /* 字体名字：mineFont */ font-family: \"mineFont\"; /* 导入字体文件并格式化，可以多设置几个url，字体文件可以是网络的，也可以是本地的 */ src: url(\"./ALLEGRO.ttf\") format(\"truetype\"), url(\"./ALLEGRO.ttf\") format(\"truetype\"); } :root { /* 优先使用自定义字体 */ font-family: 'mineFont', 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; } English display result 中文显示结果 渲染结果： 字体粗细 font-weight 使用font-weight可设置字体的粗细，它既可以指定数字（100-900），也可以指定单词。 它可设置的值如下表所示： 单词 数字 lighter（细） 100与lighter相同 normal（正常） 400与normal相同 bold（较粗） 700与bold相同 bolder（特粗） 900与bolder相同 代码示例： Document p:nth-of-type(1) { font-weight: 100; } p:nth-of-type(2) { font-weight: lighter; } p:nth-of-type(3) { font-weight: 400; } p:nth-of-type(4) { font-weight: normal; } p:nth-of-type(5) { font-weight: 700; } p:nth-of-type(6) { font-weight: bold; } p:nth-of-type(7) { font-weight: 900; } p:nth-of-type(8) { font-weight: bolder; } 100 lighter（细） 400 normal（正常） 700 bold（较粗） 900 bolder（特粗） 渲染结果： 字号大小 font-size 使用font-weight可设置字号的大小，可以使用单词、px、%、em、rem进行设置。 它可指定单词如下表所示： 单词 描述 xx-small 最小 x-small 较小 small 小 medium 中等 large 大 x-large 较大 xx-large 最大 代码示例： Document :root{ font-size: 16px; } p:nth-child(1){ font-size: xx-small; } p:nth-of-type(2) { font-size: x-small; } p:nth-of-type(3) { font-size: small; } p:nth-of-type(4) { font-size: medium; } p:nth-of-type(5) { font-size: large; } p:nth-of-type(6) { font-size: x-large; } p:nth-of-type(7) { font-size: xx-large; } 字号设置: xx-small 字号设置：x-small 字号设置：small 字号设置：medium 字号设置：large 字号设置：x-large 字号设置：xx-large 渲染结果： 文本颜色 color 使用color可设置文本的颜色，可以使用单词、rgb、rgba、#16进制色进行设置。 代码示例： Document p:first-of-type { color: red; } p:nth-of-type(2) { color: rgb(255, 0, 0); } p:nth-of-type(3) { color: rgba(255, 0, 0, 0.5); } p:last-of-type { color: #ff0000; } 文本颜色：red 文本颜色：rgb(255, 0, 0) 文本颜色：rgba(255, 0, 0, 0.5) 文本颜色：#ff0000 渲染结果： 文本行高 line-height 当一段文本放在一个标签中，默认会以标签左上角为起始点进行文本渲染。 如果我们想让文本垂直居中于元素内，可以使用 line-height: element-height 的设置。 代码示例： Document div { background-color: #ddd; color: #000; height: 10rem; width: 10rem; } div:last-of-type { line-height: 10rem; } p { font-style: italic; color: #bbb; margin: 20px 0; } 默认文本按照左上角为起始点 this is a text 将line-height设置为元素高度可令文本垂直居中 this is a text 渲染结果： 文本倾斜 font-style 使用font-style可令文本样式发生改变。 normal：正常 italic：倾斜 代码示例： Document p:first-of-type{ font-style: normal; } p:last-of-type{ font-style: italic; } 正常：normal 倾斜：italic 渲染结果： 组合定义 font 使用font可一次性定义上面的设置，语法如下： div { font : 文本倾斜 倾斜方式 字号大小/文本行高 字体 \"字体1\", \"字体2\"; } 注意，文本颜色不能进入组合定义之中，除此之外还需要留意： 必须要指定字号的大小 必须要指定文本的行高 代码示例： Document p:first-of-type { font: italic bold 1em/1.5 'Courier New', Courier, monospace; color: red; } p:nth-of-type(2) { font: italic bold /1.5 'Courier New', Courier, monospace; } p:last-of-type{ font: italic bold 1em/ 'Courier New', Courier, monospace; } 倾斜：italic 粗细：bold 字号：1em/行高:1.5 字体：'Courier New', Courier, monospace 颜色：rgba(255,0,0,.5) 失败，未定义字号大小 失败，未定义文本行高 渲染结果： 文本样式 字型设置 font-variant 使用font-variant可定义字型，让字型看起来不太一样。 它可设置的值如下表所示： 值 描述 normal 默认值，标准的字型 small-caps 浏览器会显示小型大写的字 inherit 从父元素继承font-variant的值 \u0014\u0014\u0014\u0014\u0014\u0014\u0003代码示例： Document p:first-of-type { font-variant: normal; } p:last-of-type { font-variant: small-caps; } 默认值 normal 小型大写 small-caps 渲染结果： 字母大小写 text-transform 使用text-transform可对文本的字母做大小写转换。 它可设置的值如下表所示： 值 描述 capitalize 首字母大写 uppercase 全字母大写 lowercase 全字母小写 代码示例： Document p:first-of-type { text-transform: capitalize; } p:nth-of-type(2) { text-transform: uppercase; } p:last-of-type { text-transform: lowercase; } capitalize uppercase lowercase 渲染结果： 文本线条 text-decoration 我们可以使用text-decoration来清除a标签自带的下划线。 它可设置的值如下表所示： 值 描述 none 无任何线条样式 underline 文本下的一条线 overline 文本上的一条线 line-through 文本中的一条线 blink 定义闪烁的文本 inherit 从父元素继承text-decoration的值 代码示例： Document a:first-of-type{ text-decoration: none; } p:first-of-type { text-decoration: underline; } p:nth-of-type(2) { text-decoration: overline; } p:last-of-type { text-decoration: line-through; } underline overline line-through 清除a标签样式：none 渲染结果： 文本阴影 text-shadow 使用text-shadow可对一段文本添加阴影效果。 设置参数顺序如下： 阴影颜色 水平偏移量 垂直偏移量 模糊度 代码示例： Document h1{ text-shadow: #ddd 15px 15px 6px; font-size: 3rem; font-style: italic; font-weight: bolder; } HELLO WORLD 渲染结果： 空白处理 white-space 由于浏览器的渲染特性，故出现多个空白时只会显示一个。 我们可以使用white-space来控制文本中的空白显示。 它可设置的值如下表所示： 值 描述 pre 原样显示，类似于pre标签 nowrap 不保留文本换行 pre-wrap 保留空白，保留换行 pre-line 合并空白，保留换行 代码示例： Document p:nth-of-type(1) { white-space: pre; } p:nth-of-type(2) { white-space: nowrap; } p:nth-of-type(3) { white-space: pre-wrap; } p:nth-of-type(4) { white-space: pre-line; } p { border: 1px solid black; width: 300px; height: 100px; padding: 10px; } mark { border-bottom: 1px solid black; border-top-left-radius: 30%; background-color: black; color: white; transform: translate(0, 1rem); padding: 5px; } pre 原样显示 A B C D E F nowrap 合并空白，禁止换行 A B C D E F pre-wrap 保留空白，保留换行 A B C D E F pre-wrap 合并空白，保留换行符 A B C D E F 渲染结果： 文本溢出 text-overflow 一个有宽度的容器中，如果一个文本字数超过了容器宽度，是不会进行换行的，这样就会发生溢出。 如下所示： Document p{ width: 80px; } ABCDEFGHIJKLMNOPQRSTUVWXYZ 我们可以使用 overflow-wrap: break-word 来让文本自动换行： Document p{ width: 80px; overflow-wrap: break-word; } ABCDEFGHIJKLMNOPQRSTUVWXYZ 或者可以设置 overflow: hidden 以及 text-overflow: ellipsis 来让超出容器宽度的文本隐藏并使用 … 进行代替。 注意，overflow: hidden 必须设置在 text-overflow: ellipsis 的上面。 Document p{ width: 80px; overflow: hidden; text-overflow: ellipsis; } ABCDEFGHIJKLMNOPQRSTUVWXYZ 渲染结果： 段落控制 文本缩进 text-indent 使用text-indent可进行文本缩进，单位可以是px、em或者rem。 代码示例： Document p { border: 1px dotted #ddd; text-indent: 2rem; font-size: 2rem; } 你好，世界 渲染结果： 水平对齐 text-align 使用text-align可对文本在容器内部的水平对齐方式进行设定。 它可设置的值如下表所示： 值 描述 left 左对齐 right 右对齐 center 水平居中对齐 代码示例： Document div { background-color: #ddd; color: #000; width: 150px; height: 150px; display: inline-block; } div:nth-of-type(1){ text-align: left; } div:nth-of-type(2){ text-align: center; } div:nth-of-type(3){ text-align: right; } left center right 渲染结果： 若想文字水平+垂直居中，可指定 line-height: element-height 和 text-align: center： Document div { background-color: #ddd; color: #000; width: 150px; height: 150px; display: inline-block; } div:nth-of-type(1){ line-height: 150px; text-align: center; } center 渲染结果： 垂直对齐 vertical-align 如果要在图片附近放上一段文本，那么你可以使用vertical-align定义该文本相较于图片的位置进行渲染。 vertical-align仅支持inline与inline-block标签，一般来说都是用图片和文字的垂直对齐方式，此外它还可以让表格单元格的内容进行垂直居中 它可设置的值如下表所示： 值 描述 top 文本相较于图片顶部进行对齐 middle 文本相较于图片中部进行对齐 bottom 文本相较于图片底部进行对齐 sub 图片垂直对齐文本的下标 super 图片垂直对齐文本的上标 text-top 图片与文本顶端对齐 text-bottom 图片与文本底端对其 % 使用 line-height 属性的百分比值来排列此元素，允许使用负值 inherit 从父元素继承vertical-align的值 代码示例： Document div { border: 1px dotted #ddd; padding: 1rem; font-size: 12px; } img { width: 100px; } body div:nth-of-type(1) img { vertical-align: top; } body div:nth-of-type(2) img { vertical-align: middle; } body div:nth-of-type(3) img { vertical-align: bottom; } top middle bottom 渲染结果： 单词间距 word-spacing 使用word-spacing来控制单词与单词之间的间距，单位可以是px、em或者rem。 代码示例： Document p { word-spacing: 1rem; } this is p element 渲染结果： 字符间距 letter-spacing 使用letter-spacing来控制字符与字符之间的间距，单位可以是px、em或者rem。 代码示例： Document p { letter-spacing: 1rem; } this is p element 渲染结果： 排版模式 writing-mode 如果想对文本进行排版，可使用writing-mode。 它可设置的值如下表所示： 值 描述 horizontal-tb 水平方向、自上而下进行排版 vertical-rl 垂直方向、自右而左进行排版 vertical-lr 垂直方向，自左而右进行排版 代码示例： Document p { writing-mode: vertical-rl; width: 8rem; height: 8rem; overflow-wrap: break-word; } 日照香炉生紫烟，遥看瀑布挂前川，飞流直下三千尺，疑似银河落九天。 渲染结果： Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-07-15 17:21:40 "},"前端专栏/CSS/数据样式.html":{"url":"前端专栏/CSS/数据样式.html","title":"数据样式","keywords":"","body":"表格 绘制表格 display 我们除了可以使用table标签进行表格绘制外，在CSS3中display也同样支持表格的绘制。 如下表所示： 样式规则 说明 table 对应 table table-caption 对应 caption table-row 对应 tr table-cell 对应 th 或 td table-row-group 对应 tbody table-header-group 对应 thead table-footer-group 对应 tfoot 代码示例： Document body main { display: table; border: 1px solid #ddd; } body main li { border: 1px solid #ddd; padding: 0.5rem; } body main h5 { display: table-caption; background-color: #bbb; padding: 0.5rem; text-align: center; } body main header { display: table-header-group; } body main header ul { display: table-row; } body main header ul li { display: table-cell; font-weight: bold; } body main section { display: table-row-group; } body main section ul { display: table-row; } body main section ul li { display: table-cell; } body main footer { display: table-footer-group; } body main footer ul { display: table-row; } body main footer ul li { display: table-cell; } user message name gender age Ken male 19 Jack male 18 Mary female 18 ... ... ... 渲染结果： 表格标题 caption-side 在table中使用caption-side来设置表格标题的位置。 值可以是top或者bottom，默认是top。 代码示例： Document table { caption-side: bottom; border: 1px solid #ddd; } table caption, table th, table td { border: 1px solid #ddd; padding: .5rem; } table caption { background-color: #bbb; } table th { font-weight: bold; } user message name gender age Ken male 19 Jack male 18 Mary female 18 ... ... ... 渲染结果： 内容对齐 text-align vertical-align 对于th，td的内容，我们可以在th、td中使用text-align以及vertical-align进行位置控制。 Ps：我个人更喜欢使用padding和text-align来使单元格根据内容而自动发生变化，而不是像下面的例子一样定死宽高。 水平对齐text-align： 值 描述 left 左对齐 right 右对齐 center 居中对齐 垂直对齐vertical-align： 属性 说明 top 顶对齐 middle 垂直居中 bottom 底部对齐 代码示例： Document table { caption-side: top; border: 1px solid #ddd; } table caption, table th, table td { border: 1px solid #ddd; } table caption { background-color: #bbb; } table th { font-weight: bold; } table th, table td { height: 3rem; width: 5rem; /* 水平、垂直居中 */ text-align: center; vertical-align: middle; } user message name gender age Ken male 19 Jack male 18 Mary female 18 ... ... ... 渲染结果： 颜色设置 我们可以为table中的任何HTML元素进行颜色设置。 代码示例： Document table { caption-side: top; border: 1px solid #ddd; } table caption, table th, table td { border: 1px solid #ddd; padding: .5rem; } table caption { background-color: #bbb; } table th { font-weight: bold; } table tbody tr:nth-child(odd) { background-color: #eee; } user message name gender age Ken male 19 Jack male 18 Mary female 18 ... ... ... 渲染结果： 边框间距 border-spacing 我们可以在table中使用border-spacing来设置表格边框与单元格边框的间距。 它有2个值，1个值对应上下边框、1个值对应左右边框，单位可以是px、em、rem、%等。 代码示例： Document table { caption-side: top; border: 1px solid #ddd; border-spacing: 2px 2px; /* 注意！在css reset文件中会进行边框合并 所以要想看见border-spacing的效果，必须取消边框合并 */ border-collapse: unset; } table caption, table th, table td { border: 1px solid #ddd; padding: .5rem; } table caption { background-color: #bbb; } table th { font-weight: bold; } table tbody tr:nth-child(odd) { background-color: #eee; } user message name gender age Ken male 19 Jack male 18 Mary female 18 ... ... ... 渲染结果： 边框合并 border-collapse 在table中使用border-collapse：collapse让表格边框与单元格边框进行合并。 如果使用了边框合并，边框间距失效。 注意！如果你使用了css reset文件，则该设置默认是打开的。 代码示例： Document table { caption-side: top; border-collapse: collapse; border: 1px solid #ddd; } table caption, table th, table td { border: 1px solid #ddd; padding: .5rem; } table caption { background-color: #bbb; } table th { font-weight: bold; } table tbody tr:nth-child(odd) { background-color: #eee; } user message name gender age Ken male 19 Jack male 18 Mary female 18 ... ... ... 渲染结果： 隐藏单元格 empty-cells 在table中使用empty-cells：hide来隐藏没有内容的单元格。 代码示例，由于tfoot中的td没有内容，所以他们将会被隐藏： Document table { caption-side: top; border-collapse: collapse; border: 1px solid #ddd; empty-cells: hide; } table caption, table th, table td { border: 1px solid #ddd; padding: .5rem; } table caption { background-color: #bbb; } table th { font-weight: bold; } table tbody tr:nth-child(odd) { background-color: #eee; } user message name gender age Ken male 19 Jack male 18 Mary female 18 渲染结果： 无边框表格 如果要使用无边框表格，可以利用选择器让左右边框隐藏。 代码示例： Document table { caption-side: top; border-collapse: collapse; border: 1px solid #ddd; } table caption, table th, table td { border: 1px solid #ddd; border-left-style: unset; border-right-style: unset; padding: .5rem; } table caption { background-color: #bbb; } table th { font-weight: bold; } table tbody tr:nth-child(odd) { background-color: #eee; } user message name gender age Ken male 19 Jack male 18 Mary female 18 ... ... ... 渲染结果： 数据表格 表格中可以嵌套input标签，通过:hover对tr做一些样式上的调整，比如变色、鼠标变小等。 代码示例： Document table { caption-side: top; border-collapse: collapse; border: 1px solid #ddd; empty-cells: hide; } table caption, table th, table td { border: 1px solid #ddd; border-left-style: unset; border-right-style: unset; padding: .5rem; } table caption { background-color: #bbb; } table th { font-weight: bold; } table tbody tr:nth-child(odd) { background-color: #eee; } table tbody tr:hover { background-color: #aaa; } table tbody tr * { cursor: pointer; } table tfoot tr td { text-align: right; } user message name gender age male female male female male female 渲染结果： 列表 列表符号 list-style-type 使用list-style-type对整个列表的标记设置样式，你也可以单独的为li标签的标记样式进行设置。 它们可设置的值如下所示： 值 描述 none 无标记 disc 默认，标记是实心圆 circle 标记是空心圆 square 标记是实心方块 decimal 标记是数字 decimal-leading-zero 0 开头的数字标记，如：01、02、03 等 lower-roman 小写罗马数字，如：i、 ii、 iii、 iv、 v 等 upper-roman 大写罗马数字，如：I、 II、 III、IV、V 等 lower-alpha 小写英文字母The marker is lower-alpha，如：a、b、c、d、e 等 upper-alpha 大写英文字母The marker is upper-alpha，如：A、B、C、D、E 等 lower-greek 小写希腊字母，如：alpha、beta、gamma 等 lower-latin 小写拉丁字母，如：a、 b、 c、 d、 e 等 upper-latin 大写拉丁字母，如：A、 B、 C、 D、 E 等 hebrew 传统的希伯来编号方式 armenian 传统的亚美尼亚编号方式 georgian 传统的乔治亚编号方式，如：an、 ban、 gan 等 cjk-ideographic 简单的表意数字 hiragana 标记是：a、 i、 u、 e、 o、 ka、 ki 等（日文片假名） katakana 标记是：A、 I、U、 E、 O、 KA、 KI 等（日文片假名） hiragana-iroha 标记是：i、ro、 ha、 ni、 ho、 he、 to 等（日文片假名） katakana-iroha 标记是：I、 RO、 HA、 NI、 HO、 HE、 TO等（日文片假名） 比如将所有的样式去除： ul { list-style-type: none; } 将标记定义为渐变色或者是img图片： ul { list-style-image: linear-gradient(to right, deeppink, deepskyblue); } 符号位置 list-style-position 使用list-style-position来定义列表标记符号的位置。 它可设置的值如下表所示： 值 描述 inside 内部 outside 外部 内部示例： ul { list-style-type: square; list-style-position: inside; } 外部示例： ul { list-style-type: square; list-style-position: outside; } 组合定义 list-style 使用list-style来一次性定义list-style-type与list-style-position。 代码示例： ul { list-style: square outside; } 渲染结果： 背景符号 我们可以先将每个li标签的list-style-type设置为none。 然后再对li标签增加背景图片，背景图片先调小然后设置为居左不重复，并配以文本缩进，让它来代替列表标记。 代码示例： ul li{ list-style: inside none; background: url(\"./img-002.png\") no-repeat; background-size: 1rem 1rem; text-indent: 2rem; } 渲染结果： 除此之外，我们也可以为li标签增加多个背景，一个背景做列表的标记符号，一个背景做li的标签背景。 代码示例： ul li { list-style: inside none; background: url(\"./img-002.png\") no-repeat, url(\"./width_background_image.jpeg\") no-repeat 1.8rem; background-size: 1rem 1rem, 80%; text-indent: 2rem; margin-bottom: .5rem; } 渲染结果： 追加内容 基本使用 ::after ::before 我们可以使用选择器::after向后追加内容，以及::before向前追加内容。 使用这2个选择器时一定要指定content属性，它们的content属性值将被加至被选择元素的content区域内。 注意，增加内容后会改变盒模型的面积大小，所以可能会引发布局混乱，谨慎使用。 代码示例： Document span{ border: 1px solid #ddd; } span:hover::before{ content: \"before \"; color: deeppink; } span:hover::after{ content: \" after\"; color: deepskyblue; } mid 渲染结果，可以发现盒模型被撑大了： 提取属性 attr() 在::before和::after中的content中，我们可以使用attr()方法提取出标签的属性值用作提示信息。 如下示例，当用户鼠标放到a标签上，会自动提取href属性并作为链接提示： Document a:hover::after { content: \"go to \"attr(href); background-color: #555; color: #fff; position: relative; top: 1.8rem; padding: .2rem; border-radius: 1rem; } link 渲染结果： 自定义输入框 原本的输入框比较丑，我们可以给他做出一些改变： 代码示例： Document div.fields { width: 170px; position: relative; } div.fields input[name=username] { outline: none; border: none; text-align: center; vertical-align: middle; /* 继承div宽度 */ width: 100%; } div.fields::after{ content: \"\"; display: block; /* 继承div宽度 */ width: 100%; height: 1px; background: linear-gradient(to right, white, blue, red, green, pink, white); } div.fields:hover::before{ /* 标签的属性如果是data-开头，则代表该属性专门用于被CSS或者JS提取的 */ content: attr(data-placeholder); position: absolute; top: -2rem; left: 0; color: #555; font-size: .5rem; } Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-07-15 17:36:38 "},"前端专栏/CSS/背景处理.html":{"url":"前端专栏/CSS/背景处理.html","title":"背景处理","keywords":"","body":"背景样式 纯色背景 background-color 使用background-color可定义纯色背景。 代码示例： Document div:nth-of-type(1){ background-color: red; color: #fff; font-style: italic; font-size: 3rem; padding: 2rem; width: 300px; text-align: center; } hello world 渲染结果： 图片背景 background-image 使用background-image: url(“path”)可定义图片背景。 图片背景本身不会改变盒模型的大小，这与在盒子中插入img标签是不同的。 代码示例： Document div:nth-of-type(1){ background-image: url(\"./width_background_image.jpeg\"); color: #fff; font-style: italic; font-size: 3rem; padding: 2rem; width: 300px; text-align: center; } hello world 渲染结果： 背景剪裁 background-clip 我们可以将背景设置为盒子的某一区域，比如content区域或者padding区域或者border区域。 请使用background-clip来进行指定。 它可设置的值如下表所示： 值 描述 border-box 包括边框 padding-box 不含边框，仅包含内边距与内容区域 content-box 不含边框、内边距，仅包含内容区域 代码示例： Document div:nth-of-type(1){ background-color: red; background-clip: content-box; color: #fff; font-style: italic; font-size: 3rem; padding: 2rem; width: 300px; text-align: center; border: 1px solid #ddd; } hello world 渲染结果： 背景重复 background-repeat 如果背景图小于盒子，那么默认会重复使用背景图铺满整个盒子。 我们可以使用background-repeat为它指定如何重复。 它可设置的值如下表所示： 值 描述 repeat 水平、垂直重复（默认） repeat-x 水平重复 repeat-y 垂直重复 no-repeat 不重复 space 背景图片对称均匀分布 代码示例，取消重复，并让背景图居中： Document div:nth-of-type(1){ background-image: url(\"./width_background_image.jpeg\"); background-repeat: no-repeat; background-position: center; color: #fff; font-style: italic; font-size: 3rem; padding: 2rem; width: 600px; text-align: center; border: 1px solid #ddd; } hello world 渲染结果： 背景滚动 background-attachment 使用background-attachment来设置背景是否固定。 它可设置的值如下表所示： 值 描述 scroll 背景跟随滚动条进行滚动 fixed 背景固定 背景位置 background-position 使用background-position来设置背景图居于容器中的位置。 它可设置的值如下表所示： 值 描述 left 左对齐 right 右对齐 center 居中对齐 top 顶部对齐 bottom 底部对齐 除开使用单词进行设置，也可以使用百分号进行设置，还可以同时设置2个值。 设置 left center为水平居左、垂直居中 设置 right center为水平居右，垂直居中 设置 center left 为水平居中，垂直居左 设置 center right 为水平居中，垂直居右 代码示例，使用%进行设置，50%为居中： Document div:nth-of-type(1){ background-image: url(\"./width_background_image.jpeg\"); background-repeat: no-repeat; background-position: 30% 50%; color: #fff; font-style: italic; font-size: 3rem; padding: 2rem; width: 600px; text-align: center; border: 1px solid #ddd; } hello world 渲染结果： 背景尺寸 background-size 使用background-size来定义背景尺寸，可以是单词、px、em、rem以及%。 如果该属性是用单词设置，一个词就可以搞定 如果该属性是用其他单位设置，需要2个值，一个是背景高度，一个是背景宽度 它可设置的单词如下表所示： 值 描述 cover 背景完全覆盖容器，可能会产生背景溢出 contain 背景不溢出容器，可能会产生容器部分留白 宽度固定高度自动的设置是最常用的： background-size: 50% auto; 代码示例，采用cover的单词选项： Document div:nth-of-type(1){ background-image: url(\"./width_background_image.jpeg\"); background-repeat: no-repeat; background-position: 50% 50%; background-size: cover; color: #fff; font-style: italic; font-size: 3rem; padding: 2rem; width: 600px; text-align: center; border: 1px solid #ddd; } hello world 渲染结果： 多个背景 background-image 我们可以一次指定多个背景，当指定多个背景之后，其他的属性要想作用到多个背景上，需要使用逗号对其进行分割： background-image: url(\"path1\"), url(\"path2\"); background-size: img_1_size, img_2_size; 代码示例： Document div:nth-of-type(1) { background-color: red; background-image: url(\"./img-001.jpeg\"), url(\"img-002.png\"); background-repeat: no-repeat, no-repeat; background-position: 4%, 96%; background-size: 40px, 40px; color: #fff; font-style: italic; font-size: 3rem; padding: 2rem; width: 300px; text-align: center; } hello world 渲染结果： 组合定义 background 使用background来进行组合定义。 推荐顺序为：颜色、图片地址、是否重复、背景剪裁、背景尺寸、是否跟随滚动。 如： background: color url(\"path\") no-repeat border-box center scroll; 也可以一次指定多个背景： background: url(\"path1\") left 50% no-repeat, url(\"path2\") right 100% no-repeat red; 代码示例： Document div:nth-of-type(1){ background: red url(\"./width_background_image.jpeg\") no-repeat border-box center scroll; color: #fff; font-style: italic; font-size: 3rem; padding: 2rem; width: 600px; text-align: center; border: 1px solid #ddd; } hello world 渲染结果： 背景阴影 box-shadow 使用box-shadow对盒子元素设置背景阴影。 设置参数顺序如下： 阴影颜色 水平偏移量 垂直偏移量 模糊度 代码示例： Document div:nth-of-type(1) { width: 100px; height: 100px; background-color: #eee; border: 1px solid #ddd; border-radius: 50%; box-shadow: rgba(100, 100, 100, .5) 10px 10px 5px; } 渲染结果： 颜色渐变 线性渐变 linear-gradient 渐变一般都是在背景颜色中进行使用，格式为background: linear-gradient(方向, 颜色, 颜色, ...); 下面这个示例中没有指定方向，所以方向是从上到下： /* 深粉到深空蓝 */ background: linear-gradient(deeppink, deepskyblue); 使用 deg 来改变渐变的角度，如果为负数则代表反方向： /* 倾斜30°，深粉到深空蓝 */ background: linear-gradient(30deg, deeppink, deepskyblue); 使用 to 方向1 方向2 来改变渐变的方向，但是它不能和倾斜同时用： /* 向右渐变，深粉到深空蓝 */ background: linear-gradient(to right, deeppink, deepskyblue); /* 向左渐变，深粉到深空蓝 */ background: linear-gradient(to left, deeppink, deepskyblue); /* 向左上方渐变，深粉到深空蓝 */ background: linear-gradient(to left top, deeppink, deepskyblue); /* 向右下方渐变，深粉到深空蓝 */ background: linear-gradient(to right bottom, deeppink, deepskyblue); 同时，我们也可以设置多颜色渐变，以及颜色透明度： Document div { width: 200px; height: 50px; margin-bottom: 1rem; } div:nth-of-type(1) { background: linear-gradient(90deg, #03001e 0%, #7303c0 33%, #ec38bc 66%, #fdeff9 100%); } div:nth-of-type(2) { background: linear-gradient(90deg, #feac5e 0%, #c779d0 50%, #4bc0c8 100%); } div:nth-of-type(3) { background: linear-gradient(90deg, #ada996 0%, #f2f2f2 33%, #dbdbdb 66%, #eaeaea 100%); } div:nth-of-type(4) { background: linear-gradient(90deg, #833ab4 0%, #fd1d1d 50%, #fcb045 100%); } 渲染结果： 径向渐变 radial-gradient 径向渐变的格式为 background: radial-gradient(方向, 宽度, 颜色, 颜色, ...); 它是从元素内部中心点向外进行扩散的渐变方式。 /* 深粉到深空蓝 */ background: radial-gradient(deeppink, deepskyblue); 我们可以设置渐变色的宽度。 /* 深粉到深空蓝 */ background: radial-gradient(20px 20px, deeppink, deepskyblue); 也可以使用 at 方向1 方向2 来进行渐变方向的控制。 /* 向右上方进行渐变，深粉到深空蓝, 深粉渐变标识位100px */ background: radial-gradient(at right top, deeppink 100px, deepskyblue); 我们依然可以设置很多的颜色来进行渐变： /* 从底部向中部进行渐变 */ background: radial-gradient(at bottom center, red, green ,blue ,yellow); 标识位 当未指定标识位时，渐变的过程是十分均匀的，一旦指定了标识位就会发生突变。 如下所示： /* 无标识位 */ background: linear-gradient(90deg, deeppink, deepskyblue); /* 单方设置标识位 */ background: linear-gradient(90deg, deeppink 50%, deepskyblue); /* 双方设置标识位 */ background: linear-gradient(90deg, deeppink 50%, deepskyblue 50%); 使用径向渐变加标识位绘制小太阳： 代码如下： Document div { width: 200px; height: 200px; border-radius: 50%; background: radial-gradient(red 10%, yellow 30%, black 70%) } 中间点阈值 所谓中间点阈值，指的就是两个颜色渐变的时候，从哪个点开始让一个颜色渐变到另一个颜色。 比如这个示例，红色标识位为60%，蓝色标识位为40%，渐变的中间点阈值就只能变成0了。 再比如这个示例，单方设置了标识位，那么它的阈值就是由系统产生的，所以我们才能看见它渐变的效果。 怎么设置中间点阈值呢？看下面这段代码： /* 0%就是中间点阈值，当设置为0后那么红色变蓝色会由0%的位置开始 */ background: linear-gradient(90deg, red ,0%, blue); 所以结果是： 将中间点阈值改为20%： /* 我们的中间点阈值是20%，先是红色占了10%，那么可观测范围中中间点阈值也就只有10%了，所以渐变区域为10% */ background: linear-gradient(90deg, red 10% ,20%, blue 80%); 重复的线性渐变 repeating-linear-gradient 要想使用线性渐变重复，请利用repeating-linear-gradient进行设置。 /* 一个格子为 75px */ background: repeating-linear-gradient(90deg, blue, 25px, red 50px); 如果我们想要生硬渐变过程，可以再随便加一个颜色充当过渡。 /* 过渡色和第一个渐变色的标志位设置为一样即可 */ background: repeating-linear-gradient(90deg, blue, 25px, yellow 25px, 25px, red 50px); 重复的径向渐变 repeating-radial-gradient 要想使用线性渐变重复，请利用repeating-radial-gradient进行设置。 background: repeating-radial-gradient(20px 20px, red 0%, yellow 20%, blue 30%, green 50%); 渲染结果： Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-07-15 14:45:06 "},"前端专栏/CSS/盒子模型.html":{"url":"前端专栏/CSS/盒子模型.html","title":"盒子模型","keywords":"","body":"盒子元素 基本介绍 每一个标签都可以看做一个盒子，在网页的布局中也是大盒子不断的嵌套小盒子。 每个盒子模型都包含以下名词： content：内容区域，可以由width与height来进行宽高设置，是盒子模型体积组成部分之一 padding：内边距，指的是content与border之间的距离，是盒子模型体积组成部分之一 border：边框，边框也算整个盒子模型的体积组成之一 margin：外边距，指的是该盒子与另一个盒子之间的距离 如下图所示： 一个盒子的可视面积由3部分所构成（content、padding、border）。 对其中任何一部分进行数值加减，都会影响到整个盒子可视面积的改变。 Ps：margin不可视，但它属于盒模型整体面积一部分。 宽高设置 我们很少来规定一个盒子的固定大小，基本都是由内容进行撑开。 内容区域可以通过width和height来设置宽高。 注意：使用width和height设计出的盒子仅针对content区域 如果后续对padding或者border进行修改都会改变整个盒子的大小从而引发整个页面的混乱，如果我们增加了padding或者border的数值，就需要减去content的width以及height的数值，反之亦然 代码示例： Document div { background-color: #ddd; width: 100px; height: 100px; } 渲染结果： 盒子整体占用面积： 如何手动计算一个标准盒模型的可视面积？公式如下： 宽度 = width + padding-left + padding-right + border-left + border-right 高度 = height + padding-top + padding-bottom + border-top + border-bottom 如果是计算整体占用面积，还需要加上margin。 box-sizing 默认的width和height设置的值仅针对内容区域，如果我们使用box-sizing来声明该盒子为边框盒子的话那么width和height设置值的应用范围就是整个盒子。 也就是说，如果你是边框盒子，那么后续对padding、border的修改都不会导致整体盒模型可视面积的变化了。 这个声明是强烈推荐使用的，它的出现让手动计算盒子可视面积的时代一去不复返。 box-sizing仅能设置2个值： box-sizing：border-box 边框盒子 box-sizing：content-box 内容盒子（默认值） 以下是内容盒子和边框盒子的对比： Document div { width: 200px; height: 200px; padding: 10px; text-align: center; line-height: 200px; font-weight: lighter; } div:first-of-type { border: 1px double #ddd; background-color: #ddd; } div:last-of-type { box-sizing: border-box; border: 1px double #eee; background-color: #eee; } content-box h-w:242px border-box h-w:200px 外边距 间距修改 如果想修改盒子的外边距，可使用margin进行修改，单位可以是px、em、rem以及%。 margin后面可以跟上1个至4个值，如下所示： 1个值：设置 (margin-top、margin-bottom、margin-left、margin-right) 的值 上下左右 2个值：设置 (margin-top、margin-bottom) | (margin-left、margin-right) 的值 上下 左右 3个值： 设置 (margin-top) | (margin-left、margin-right) | (margin-bottom) 的值 上 左右 下 4个值：设置 (margin-top) |( margin-right) | (margin-bottom) | (margin-left) 的值 上 右 下 左 或者你也可以单独的设置4个方向。 代码示例： Document p{ background-color: #bbb; height: 100px; width: 100%; } div { background-color: #ddd; width: 100px; height: 100px; display: inline-block; margin-top: 50px; margin-bottom: 50px; } div:nth-of-type(2){ margin: 50px; } 渲染结果： 盒子居中 当大盒子中嵌套了一个小盒子时，如果我们想让小盒子水平居中可对小盒子设置margin: auto。 Ps：如果小盒子想要垂直居中，就必然涉及到塌陷问题，这个后面会慢慢探讨。 代码示例： Document main { width: 100%; background-color: #bbb; height: 2rem; } div { height: 1rem; width: 1rem; background-color: #eee; margin: auto; } 渲染结果： 负值设置 当小盒子的margin-left或者margin-right有负值设置时，小盒子可能会跑出大盒子外面。 代码示例： Document main { width: 300px; height: 300px; background-color: #bbb; margin: auto; } div { height: 100px; width: 100px; background-color: #eee; margin: 0 -50px; } 渲染结果： 同级纵向合并 同级纵向合并是指2个并列的（无嵌套关系）的盒子一个设置margin-bottom、另一个设置margin-top的话会比较这2个值的大小，然后取最大值进行设置。 如下所示： 代码示例： Document div{ margin: auto; width: 100px; height: 100px; } div:nth-child(1){ background-color: #ddd; margin-bottom: 40px; } div:nth-child(2){ background-color: #eee; margin-top: 20px; } 结果展示： 越级纵向合并 当一个子级盒子想去设置margin-top或者margin-bottom与父盒子保持一定距离时，那么这个父盒子就必须要拥有一些内容。 若父盒子没有任何内容，子盒子就会不断的向上找，找父盒子的兄弟、找父盒子的父亲，直至找到html标签为止。 如下这个示例，由于父盒子中没有任何内容，子盒子在设置margin-top:20px后不仅没有拉开与父盒子之前的距离，反而让父盒子与html文档拉开了距离： Document html { background-color: deepskyblue; } main{ width: 200px; height: 200px; background-color: #ddd; } div { width: 100px; height: 100px; background-color: #eee; margin-top: 20px; } 如果父盒子有内容，就不会发生越级纵向合并问题了，现在往父盒子中加入了一个空格符号再看看结果。 可以看到子盒子与父盒子的距离拉开了： Document html { background-color: deepskyblue; } main{ width: 200px; height: 200px; background-color: #ddd; } div { width: 100px; height: 100px; background-color: #eee; margin-top: 20px; } &nbsp; 内边距 间距修改 内边距关键词是padding，我们可以使用padding来定义内边距。 使用规则和margin一样： Document div{ margin:50px; padding: 10px; background-color: #ddd; } content 渲染结果： 盒子居中 使用padding配合margin: auto，我们可以快速的让小盒子居中在大盒子内部。 大盒子不设置height，而是使用padding撑开 小盒子设置margin：auto 代码示例： Document main{ background-color: #ddd; padding: 10px; } div{ background-color: #eee; height: 20px; width: 20px; margin: auto; } 渲染结果： 边框设计 边框样式 使用border-style定义边框样式。 它可设置的值如下表所示： 值 描述 none 定义无边框 dotted 定义点状边框。在大多数浏览器中呈现为实线 dashed 定义虚线。在大多数浏览器中呈现为实线 solid 定义实线 double 定义双线。双线的宽度等于 border-width 的值 groove 定义 3D 凹槽边框。其效果取决于 border-color 的值 ridge 定义 3D 垄状边框。其效果取决于 border-color 的值 inset 定义 3D inset 边框。其效果取决于 border-color 的值 outset 定义 3D outset 边框。其效果取决于 border-color 的值 边框宽度 以下属性可用于定义边框宽度，它们的值可以是px、em、rem、%。 属性名称 说明 border-top-width 顶边宽度 border-right-width 右边宽度 border-bottom-width 下边宽度 border-left-width 左边宽度 border-width 四边宽度 边框颜色 使用以下属性可用于定义边框颜色，它们的值可以是单词、rgb、rgba、#16进制色。 属性名称 说明 border-top-color 顶边颜色 border-right-color 右边颜色 border-bottom-color 下边颜色 border-left-color 左边颜色 border-color 四边颜色 组合定义 使用以下属性可对边框样式、边框宽度、边框颜色进行组合定义。 可以一次只定义一条边，也可以定义四边： 属性名称 说明 border-top 顶边 border-right 右边 border-bottom 下边 border-left 左边 border 四边 代码示例： Document div { height: 80px; width: 100px; background-color: #eee; margin: 20px; display: inline-block; text-align: center; line-height: 80px; font-weight: lighter; } div:nth-of-type(1) { border: 3px dotted #bbb; } div:nth-of-type(2) { border: 3px dashed #bbb; } div:nth-of-type(3) { border: 3px solid #bbb; } div:nth-of-type(4) { border: 3px double #bbb; } div:nth-of-type(5) { border: 3px groove #bbb; } div:nth-of-type(6) { border: 3px ridge #bbb; } div:nth-of-type(7) { border: 3px inset #bbb; } div:nth-of-type(8) { border: 3px outset #bbb; } dotted dashed solid double groove ridge inset outset 渲染结果： 圆角边框 使用以下属性对边框单角或者四角设置为圆角，圆角支持px、%等单位。 属性 说明 border-top-left-radius 上左角 border-top-right-radius 上右角 border-bottom-left-radius 下左角 border-bottom-right-radius 下右角 border-radius 全部角 代码示例： Document div { height: 200px; width: 200px; background-color: #eee; margin: 20px; border: 1px dotted #bbb; border-radius: 50%; } 渲染结果： 外轮廓线 基础设置 外轮廓线与边框的使用一模一样，但是它不是盒子面积构成的一部分。 所以： 外轮廓线显示在边框外面 外轮廓线不会影响页面布局 此外，外轮廓线没有圆角设计。 我们可以使用outline来进行外轮廓线的组合定义，如下所示： Document div { height: 200px; width: 200px; background-color: #eee; margin: 20px; outline: 1px solid #bbb; } 渲染结果： input设置 input框在选中（focus）时会出现一个外轮廓线，非常的不美观： 我们可以做一些其他的设置，让它更好看： 代码如下： Document input{ border: none; background-color: #eee; } input:focus{ outline: 1px inset #bbb; } div{ margin-bottom: 1rem; } display 特性置换 通过display属性，我们可以将一个标签的特性进行置换。 它可设置的值如下表所示： 值 描述 inline 转换为内联标签 block 转换为块级标签 inline-block 转换为内联块级标签 代码示例： Document :not(hr, body, html) { margin: 1rem; border: 1px solid #ddd; } aside { display: inline; width: 200px; } span { display: block; } a { display: inline-block; height: 24px; } block -> inline block -> inline inline -> block inline -> block inline -> inline_block inline -> inline_block 渲染结果： 隐藏标签 使用display: none后，元素将被隐藏，它不会留下被隐藏元素的空间位置。 代码示例： Document div { width: 100px; height: 100px; } div:nth-of-type(1) { background-color: #ddd; display: none; } div:nth-of-type(2) { background-color: #eee; } 渲染结果： visibility 使用visibility: hidden后，元素将被隐藏，它会留下被隐藏元素的空间位置，实际上就是元素可见度设置为0。 代码示例： Document div { width: 100px; height: 100px; } div:nth-of-type(1) { background-color: #ddd; visibility: hidden; } div:nth-of-type(2) { background-color: #eee; } 渲染结果： overflow 使用overflow: hidden后，容器中溢出的内容将会被隐藏： Document div { width: 100px; height: 100px; overflow: hidden; background-color: #ddd; } ABCDEFGHIJKLMNOPQRSTUVWXYZ 或者你也可以将overflow的值设置为auto，这样容器就会出现滚动条（scroll）： Document div { width: 100px; height: 100px; overflow: auto; background-color: #ddd; } ABCDEFGHIJKLMNOPQRSTUVWXYZ 尺寸定义 min-w h&max-w h min-width与min-height常用于嵌套关系之中。 举个例子，一个大盒子中要放入一张图片，那么这张图片应该占据大盒子的多少空间呢？ min-width：定义元素的最小宽度 min-height：定义元素的最大高度 max-width：定义元素的最大宽度 max-height：定义元素的最大高度 注意： 子元素在使用时min-width会继承父元素的width 优先级问题：min-width > max-width > width 优先级问题：min-height > max-height > height 优先级问题是指元素同时设置这3个属性时，浏览器会选用哪一个。 代码示例： Document main { width: 200px; height: 200px; background-color: #ddd; } div { background-color: #eee; min-height: 90%; max-width: 90%; } 渲染结果： fill-available 设置w、h为fill-available的子元素会填满整个父元素可用空间。 在chorme浏览器中使用该属性时需要加上前缀 -webkit 进行样式书写。 width: -webkit-fill-available; height: -webkit-fill-available; 代码示例： Document main { width: 200px; height: 200px; background-color: #ddd; } div { background-color: #eee; width: -webkit-fill-available; height: -webkit-fill-available; } 渲染结果： fit-content 设置w、h为fit-content的容器，不管有多少内容都不会造成溢出。 他会根据内容的宽高自动调整整个容器的宽高，常用于移动端。 width: fit-content; height: fit-content; 代码示例： Document div { width: fit-content; height: fit-content; background-color: #ddd; } ABCDEFGHIJKLMNOPQRSTUVWXYZ 渲染结果： min-content&max-content min-content和max-content也是移动端使用较多。 它会根据元素内容来自动设置content区域大小： width: min-content; height: min-content; width: max-content; height: max-content; 代码示例： Document div:nth-of-type(1) { width: min-content; height: min-content; background-color: #ddd; } div:nth-of-type(2) { width: min-content; height: min-content; background-color: #eee; } ABCDEFGHIJKLMNOPQRSTUVWXYZ ABCDEFGHIJKLMNOPQRSTUVWXYZ 渲染结果： Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-07-16 20:15:18 "},"前端专栏/CSS/浮动布局.html":{"url":"前端专栏/CSS/浮动布局.html","title":"浮动布局","keywords":"","body":"浮动布局 基本介绍 浮动布局是CSS早期最常使用的一种布局方式。 说白了就是使元素进行漂浮，从而脱离默认文档流排列的一种技术手段。 使用浮动布局应该注意以下几点： 浮动应当发生在一个大盒子内部（body标签也可以看做一个大盒子） 浮动后的元素会影响后面未浮动元素的排列方式 浮动元素会自动转换为inline-block状态 浮动元素只会在父盒子的content区域，不会溢出到父盒子的padding区域 当一个父盒子中所有的元素都进行浮动后，可能会造成父盒子高度塌陷的问题 使用浮动 对一个元素使用float就可以让该元素漂浮起来，它可以指定以下一些方向： 选项 说明 left 向左浮动 right 向右浮动 none 不浮动 注意！使用向右浮动会发生倒序排列，1234变为4321，而左浮动则是正序排列。 如果你不想右浮动改变他们的排列顺序，则可以将它们全部包装在一个父级标签中，将父级标签右浮动，再将子标签做浮动。 如下图所示： 文档流 文档流排列是一种自上而下，自左向右的排列方式。 对于block块级元素来说，它应该是独占一行的。 代码示例： Document * { box-sizing: border-box; } main { width: 230px; padding: .5rem; border: 1px solid #000; } main div { width: 100px; height: 100px; } main div:nth-of-type(1) { border: 1px solid blue; } main div:nth-of-type(2) { background-color: red; } 渲染结果： 空间占用 在同级情况下，排列在前的一个标签如果进行浮动设置从而脱离了文档流，那么排列在后的标签会占用之前标签的位置。 如下所示，排列在前的蓝框div如果float: left后，排列在后的红色背景div会向上顶，占用掉之前蓝框div所在的空间位置，而蓝框div则漂浮在了红色背景div的上方。 main div:nth-of-type(1) { border: 1px solid blue; float: left; } 如果排列在前的蓝框div设置为float: right后，排列在后的红色背景div依旧会向上顶，占用掉之前蓝框div所在的空间位置。 main div:nth-of-type(1) { border: 1px solid blue; float: right; } 如果我们对排列在后的红色背景div进行浮动设置的话，排列在前的标签并不会受此影响，但会出现父级高度塌陷问题，即父级盒子的高度会出现令人意外的情况： main div:nth-of-type(2) { background-color: red; float: right; } 状态转换 设置为浮动的元素都会变为inline-block状态。 如下所示，对一个inline标签进行浮动，它变的可以设置宽高了，对一个block标签进行浮动，它变的不会独占一行了： 代码示例： Document * { box-sizing: border-box; } main { width: 230px; padding: .5rem; border: 1px solid #000; /* 为了防止父盒子塌陷，所以这里给他定一个高度 */ height: 200px; } main span, div { width: 100px; height: 100px; text-align: center; line-height: 100px; } main span { float: left; border: 1px solid blue; } main div{ float: right; background-color: red; } inline block 浮动边界 父盒子中的浮动元素始终会位于父盒子的content区域中，不会超出padding区域。 如下所示： content：蓝色 padding：绿色 margin：黄色 代码示例： Document * { box-sizing: border-box; } main { width: 230px; padding: .5rem; border: 1px solid #000; /* 为了防止父盒子塌陷，所以这里给他定一个高度 */ height: 200px; } main span, div { width: 100px; height: 100px; text-align: center; line-height: 100px; } main span { float: left; border: 1px solid blue; } main div{ float: right; background-color: red; } inline block 清除浮动 塌陷问题 当一个没有高度的父盒子中所有子元素都进行漂浮后，父盒子会产生高度塌陷的问题： Document * { box-sizing: border-box; } main { width: 230px; padding: .5rem; border: 1px solid #000; } main div { width: 100px; height: 100px; } main div:nth-of-type(1) { border: 1px solid blue; float: left; } main div:nth-of-type(2) { background-color: red; float: right; } 父盒子出现高度塌陷后，会影响整体布局的混乱。 这是正常情况下的布局： Document * { box-sizing: border-box; } main { width: 440px; padding: .5rem; border: 1px solid #000; height: 120px; } main div { border: 1px solid blue; float: left; width: 100px; height: 100px; margin-right: 5px; text-align: center; line-height: 100px; color: #fff; background-color: deeppink; } img img img img this is description message this is description message this is description message this is description message 这是高度塌陷后出现的布局情况： Document * { box-sizing: border-box; } main { width: 440px; padding: .5rem; border: 1px solid #000; /* height: 120px; */ } main div { border: 1px solid blue; float: left; width: 100px; height: 100px; margin-right: 5px; text-align: center; line-height: 100px; color: #fff; background-color: deeppink; } img img img img this is description message this is description message this is description message this is description message 解决这个问题的方案非常简单，就是给父盒子设定一个固定的高度，但这样做是不现实的。 我们以下面这个京东滚动条来进行说明，仔细观察它的结构你会发现它其实就是一个a标签中套着img，和我们上面所示例的布局情况非常相似。 a标签是设置为float：left的，这就意味着黑框的div部分可能会出现高度塌陷问题，让整个页面都乱掉： 如果你为黑框div设置了一个高度，假如后续新一轮方案中img高度发生变化后我们还需要调整div的高度，显然是非常麻烦的。 所以，为父盒子设置高度解决塌陷问题是不可取的。 clear 内墙法 我们可以使用 clear 内墙法来解决父盒子高度塌陷的问题。 步骤如下： step01：在父盒子中加入一个不浮动的空白块级标签，放在所有浮动元素的下面 step02：为该标签新增 clear 属性，并配置选项 clear可设置的选项值如下表所示： 值 描述 left 左边远离浮动元素 right 右边远离浮动元素 both 左右都远离浮动元素 它的意思是该标签的某个方向不允许有浮动元素，如果有就另起一行。 下面是设置了clear内墙法后的父盒子，不再产生高度塌陷问题了： 我们注意看下面这段代码，clear元素必须是块级元素，且必须设置在浮动元素的下面，因为浮动元素只会影响排列在后的标签，并不会影响排列在前的标签： Document * { box-sizing: border-box; } main { width: 230px; padding: .5rem; border: 1px solid #000; } main div { width: 100px; height: 100px; } main div:nth-of-type(1) { border: 1px solid blue; float: left; } main div:nth-of-type(2) { background-color: red; float: right; } .clearfix { /* clear:both 代表如果两边有浮动，我就另起一行，不占据漂浮元素的空间位置 */ clear: both; } 伪元素 内墙法 clear 内墙法虽然能够很好的解决父盒子高度塌陷问题，但是使用非常麻烦。 我们需要为每一个有浮动元素的父盒子都建立一个空标签并新增clearfix类，整个步骤还是比较繁琐的。 所以可以使用伪元素内墙法，使用::after插入器为父盒子自动创建一个元素。 注意，一定要使用::after才有效，因为它是将文本插入到浮动元素的后面，如果使用::before是没有效果的，浮动元素并不会影响之前元素的排列方式。 伪元素内墙法应该是个人比较推崇的一种方式，他非常的简单。 代码示例： Document * { box-sizing: border-box; } main { width: 230px; padding: .5rem; border: 1px solid #000; } main div { width: 100px; height: 100px; } main div:nth-of-type(1) { border: 1px solid blue; float: left; } main div:nth-of-type(2) { background-color: red; float: right; } .clearfix::after { content: \"\"; display: block; /* clear:both 代表如果两边有浮动，我就另起一行，不占据漂浮元素的空间位置 */ clear: both; } overflow 最后这种方式更加的简单，只需要为父盒子设置 overflow: auto; 或者overflow: hidden; 即可解决高度塌陷问题。 它会触发一个BFC机制来解决高度塌陷问题，但可能会产生子元素内容丢失的情况。 具体BFC机制比较麻烦，这里不进行探讨，会用就行： 代码示例： Document * { box-sizing: border-box; } main { width: 230px; padding: .5rem; border: 1px solid #000; } main div { width: 100px; height: 100px; } main div:nth-of-type(1) { border: 1px solid blue; float: left; } main div:nth-of-type(2) { background-color: red; float: right; } .clearfix { /* overflow会触发BFC机制，缺点是可能会造成浮动元素部分内容缺失 */ overflow: auto; } 浮动环绕 基本介绍 浮动环绕就是让文本内容对浮动元素进行环绕，类似于word中的排版环绕。 如果浮动元素是img，则img链接图片必须是具有透明度的png格式图片。 下面是效果展示： 距离控制 对浮动元素使用shape-outside可进行浮动元素与同级文本之间的距离控制。 它可设置的值如下表所示： 值 说明 margin-box 外边距环绕 padding-box 内边距环绕 border-box 边框 content-box 内容环绕 1）外边距环绕，文字依照浮动元素的外边距进行环绕： 2）内边距环绕，文字依照浮动元素的内边距进行环绕： 3）边框环绕文，字依照浮动元素的边框进行环绕： 4）内容环绕，文字依照浮动元素的内容进行环绕： 代码示例： Document main { width: 22rem; } main img { width: 50px; float: left; padding: .5rem; margin: 1rem; border: 3px solid #bbb; shape-outside: content-box; /* shape-outside: border-box; shape-outside: padding-box; shape-outside: margin-box; */ } .clearfix { overflow: auto; } 滑稽起源于百度贴吧，由百度团队设计，最初名字叫“斜眼笑”。由于其可以同时表达多种复杂的感情，2012年时已被在极易引战的贴吧广泛应用。 2012年10月，有微博网友发了张小孩儿怕打针缩墙角的照片，将害怕这种情绪表现得非常到位，被灵魂画手描了个形，做成最初的【墙角害怕】。 2016年10月，“滑稽”表情抱枕正式登陆日本亚马逊，售价1550日元，约合人民币101元。 内移距离 shape-outside除了可以使用上面的单词来控制浮动元素与文本之间的距离外，还可以使用inset手动指定浮动元素的内移距离。 指定顺序为：上、右、下、左 代码示例： Document main { width: 22rem; } main img { width: 50px; float: left; padding: .5rem; margin: 1rem; border: 3px solid #bbb; shape-outside: inset(0px -30px 0px 50px) border-box; } .clearfix { overflow: auto; } 滑稽起源于百度贴吧，由百度团队设计，最初名字叫“斜眼笑”。由于其可以同时表达多种复杂的感情，2012年时已被在极易引战的贴吧广泛应用。 2012年10月，有微博网友发了张小孩儿怕打针缩墙角的照片，将害怕这种情绪表现得非常到位，被灵魂画手描了个形，做成最初的【墙角害怕】。 2016年10月，“滑稽”表情抱枕正式登陆日本亚马逊，售价1550日元，约合人民币101元。 环绕模式 浮动元素的shape-outside还可以指定文本环绕模式： 它可设置的值如下表所示： 值 说明 circle 圆形 ellipse 椭圆 polygon 多边形 1）正圆外边距环绕： 2）椭圆外边距环绕： 3）多边形外边距环绕： 代码示例： Document main { width: 22rem; } main img { width: 50px; float: left; padding: .5rem; margin: 1rem; border: 3px solid #bbb; shape-outside: polygon(50% 0, 100% 100%, 0 100%) margin-box; /* 正圆外边距环绕 shape-outside: circle(50%) margin-box; 椭圆外边距环绕： shape-outside: ellipse(50% 80%) margin-box; 多边形外边距环绕： shape-outside: polygon(50% 0, 100% 100%, 0 100%) margin-box; */ } .clearfix { overflow: auto; } 滑稽起源于百度贴吧，由百度团队设计，最初名字叫“斜眼笑”。由于其可以同时表达多种复杂的感情，2012年时已被在极易引战的贴吧广泛应用。 2012年10月，有微博网友发了张小孩儿怕打针缩墙角的照片，将害怕这种情绪表现得非常到位，被灵魂画手描了个形，做成最初的【墙角害怕】。 2016年10月，“滑稽”表情抱枕正式登陆日本亚马逊，售价1550日元，约合人民币101元。 显示区域 对浮动元素使用clip-path可控制其显示的形状。 它可设置的值如下表所示： 值 说明 circle 圆形 ellipse 椭圆 polygon 多边形 1）圆形 2）椭圆形 3）多边形 代码示例： Document main { width: 22rem; } main div { width: 50px; height: 50px; float: left; padding: .5rem; margin: 1rem; background-color: #eee; clip-path: polygon(50% 0, 100% 100%, 0 100%); /* 代表正圆，圆心在中间 clip-path: clip-path: circle(50% at center); 代表椭圆，圆心在右边 两个数，一个代表宽度，一个代表高度，圆心在右上角 clip-path: ellipse(50% 80% at 100% 0); 代表三角形 clip-path: polygon(50% 0, 100% 100%, 0 100%); */ } .clearfix { overflow: auto; } 滑稽起源于百度贴吧，由百度团队设计，最初名字叫“斜眼笑”。由于其可以同时表达多种复杂的感情，2012年时已被在极易引战的贴吧广泛应用。 2012年10月，有微博网友发了张小孩儿怕打针缩墙角的照片，将害怕这种情绪表现得非常到位，被灵魂画手描了个形，做成最初的【墙角害怕】。 2016年10月，“滑稽”表情抱枕正式登陆日本亚马逊，售价1550日元，约合人民币101元。 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-07-18 21:59:56 "},"前端专栏/CSS/定位布局.html":{"url":"前端专栏/CSS/定位布局.html","title":"定位布局","keywords":"","body":"定位布局 基本介绍 CSS中，定位布局是非常常见的技术手段，它可以将任意元素放在页面中任意的位置上。 早期的页面基本都是由浮动+定位布局来完成的。 我们以京东为例，这就是一个非常好的定位布局小例子： 定位布局虽然常用但是不能滥用，他可能会出现一些意料之外的情况，我们应该只对一些特定元素进行定位，而对不需要定位的元素则可对其使用默认文档流和浮动的手段进行布局排列。 定位类型 position 使用position对一个元素进行定位。 它可设置的值如下表所示： 值 描述 static 默认定位，即文档流布局定位 relative 相对定位，仍然是文档流定位 absolute 绝对定位，脱离文档流 fixed 固定定位，脱离文档流 sticky 粘性定位 位置偏移 一个被定位的元素可以进行上下左右的偏移，你可以指定方向与偏移距离。 可指定方向如下表所示，偏移距离单位可以是px、em、rem、%等： 方向 描述 top 距离顶边 bottom 距离下边 left 距离左部 right 距离右边 相对定位 relative 示例演示 相对定位relative是相对元素原本的位置进行偏移控制。 当元素发生偏移时，原空间位置保留（不脱离文档流，其他元素不会顶上来）。 这是原本位置： 对第一个元素进行相对定位后，向右偏移30px，向下偏移10px。可以发现p标签并没有顶上去： 代码示例： Document main { width: 200px; height: 200px; border: 1px solid #bbb; background-color: #ddd; } main div:nth-of-type(1) { width: 100px; height: 100px; border: 1px solid #bbb; /* position: relative; top: 20px; left: 30px; */ } main p:nth-of-type(1) { border: 1px solid #bbb; font-weight: lighter; } this is p element 绝对定位 absolute 示例演示 绝对定位absolute是脱离文档流的定位方式，你可以将它理解为可以偏移到任意位置的漂浮。 被绝对定位后的元素拥有inline-block的特性。 被绝对定位的元素是会影响同级的正常排列的文档流元素的，即后面的元素会自动向上补齐。 此外，子元素的绝对定位不会影响父元素的整体高度，这与浮动布局不同，浮动布局中子元素的float会导致父元素的高度塌陷问题，这点在绝对定位中是不存在的。 下面我们将演示绝对定位的脱离文档流特点。 这是原本位置： 对第一个元素进行绝对定位后，向右偏移30px，向下偏移10px。可以发现p标签顶上去了： 代码示例： Document main { width: 200px; height: 200px; border: 1px solid #bbb; background-color: #ddd; } main div:nth-of-type(1) { width: 100px; height: 100px; border: 1px solid #bbb; /* position: absolute; top: 20px; left: 30px; */ } main p:nth-of-type(1) { border: 1px solid #bbb; font-weight: lighter; } this is p element 参照元素 绝对定位的元素不受文档流的控制，所以默认它会按照页面左上角进行定位以及偏移。 但是如果被绝对定位元素的父元素设置了relative或者fixed以及sticky定位的话，则该绝对定位子元素将会参照此父元素左上角位置进行定位以及偏移。 下面这个示例中，父元素没有设置为relative或者fixed以及sticky定位，子元素的绝对定位会以页面左上角作为参照点： Document body{ border: 2px solid #bbb; } main { width: 200px; height: 200px; border: 1px solid #bbb; background-color: #ddd; margin-top: 100px; margin-left: 100px; } main div:nth-of-type(1) { width: 100px; height: 100px; border: 1px solid #bbb; position: absolute; top: 20px; left: 30px; } 下面这个示例中，父元素设置了relative定位，子元素的绝对定位会以父元素左上角作为参照点： Document body{ border: 2px solid #bbb; } main { width: 200px; height: 200px; border: 1px solid #bbb; background-color: #ddd; margin-top: 100px; margin-left: 100px; position: relative; } main div:nth-of-type(1) { width: 100px; height: 100px; border: 1px solid #bbb; position: absolute; top: 20px; left: 30px; } 所以，当一个子元素要设置为absolute绝对定位时，父元素应当设置为relative相对定位。 居中定位 如果想对绝对定位的子元素设置水平垂直居中，则可以： top设置为50% left设置为50% margin-left设置为子元素宽度的一半 margin-right设置为子元素宽度的一半 如下示例： 代码演示： Document main { width: 200px; height: 200px; border: 1px solid #bbb; background-color: #ddd; position: relative; } main div:nth-of-type(1) { width: 100px; height: 100px; border: 1px solid #bbb; position: absolute; left: 50%; top: 50%; margin-left: -50px; margin-top: -50px; } 默认位置 如果被定位的子元素没有设置任何偏移，那么它将会受到父元素padding等属性的影响。 但是使用定位的元素一般都会进行偏移设置。 示例如下： Document main { width: 200px; height: 200px; border: 1px solid #bbb; background-color: #ddd; position: relative; } main div:nth-of-type(1) { width: 100px; height: 100px; border: 1px solid #bbb; position: absolute; } 跟随滚动 无论是绝对定位抑或是相对定位的元素，都会随着滚动条发生滚动。 Document main { width: 200px; height: 200px; border: 1px solid #bbb; background-color: #ddd; position: relative; /* Y轴滚动条 */ overflow-y: scroll; } main div:nth-of-type(1) { width: 100px; height: 100px; border: 1px solid #bbb; position: absolute; left: 50%; top: 50%; margin-left: -50px; margin-top: -50px; } main p:nth-of-type(1){ /* p元素比main要长，才能滚动 */ height:1000px; } z-index 如果2个同级别的元素都进行定位且位置相同。那么后定位的元素会层叠在先定位的元素之上，这个时候我们就需要用到z-index来改变层叠优先级。 默认所有元素的层叠优先级均为0，较大优先级的元素会显示在上方。 如下示例，后定位的元素是矩形div，他会显示在圆形div的上方，当我们改变圆形div的z-index后，圆形div会显示在矩形div的上方： Document main { width: 200px; height: 200px; border: 1px solid #bbb; background-color: #ddd; position: relative; /* Y轴滚动条 */ overflow-y: scroll; } main div { width: 100px; height: 100px; border: 1px solid #bbb; position: absolute; } main div:nth-of-type(1) { border-radius: 50%; background-color: deeppink; z-index: 1; } main div:nth-of-type(2) { background-color: deepskyblue; } 固定定位 fixed 固定定位fixed是脱离文档流的定位方式。 固定定位的元素不会随着滚动条进行滚动，他的偏移参照点是页面左上角。 如下所示，我们使用a标签锚点与固定定位，实现快速返回页面顶部的按钮功能： Document div { height: 200px; } div:nth-of-type(1) { background-color: red; } div:nth-of-type(2) { background-color: blue } div:nth-of-type(3) { background-color: green; } div:nth-of-type(4) { background-color: yellow; } div:nth-of-type(5) { background-color: pink; } button { position: fixed; bottom: 2rem; right: 2rem; box-shadow: 5px 5px 5px #555; } go to top 粘性定位 sticky 同级粘性定位 同级粘性定位sticky是会进行层叠的，后面的粘性定位元素不会挤掉上面的粘性定位元素。 同级指的就是不同的粘性定位元素粘的是同一个父级元素。 Document section { overflow-y: scroll; width: 250px; height: 180px; text-align: center; } section h2 { padding: 13px; color: #fff; font-weight: bolder; position: sticky; top: 0; } section h2:nth-of-type(1) { background-color: orange; } section h2:nth-of-type(2) { background-color: blue; } section h2:nth-of-type(3) { background-color: yellowgreen; } section img { width: 130px; margin-top: 1rem; } HTML CSS JavScript 非同级粘性定位 非同级粘性定位sticky是不会进行层叠的，后面的粘性定位元素会挤掉上面的粘性定位元素。 非同级指的就是不同的粘性定位元素粘的不是同一个父级元素。 Document section { overflow-y: scroll; width: 250px; height: 180px; text-align: center; } section h2 { padding: 13px; color: #fff; font-weight: bolder; position: sticky; top: 0; } section article:nth-of-type(1) h2 { background-color: orange; } section article:nth-of-type(2) h2 { background-color: blue; } section article:nth-of-type(3) h2 { background-color: yellowgreen; } section img { width: 130px; margin-top: 1rem; } HTML CSS JavScript 导航条示例 使用浮动 + 定位布局，来快速构建一个导航条： Document * { box-sizing: border-box; } :root { font-size: 16px; } .clearfix::after { content: \"\"; display: block; clear: both; } header { padding: 1rem; background: #1b1b1b; color: #fff; position: fixed; width: 100%; } header nav section div { cursor: pointer; padding: 0.5rem; z-index: 1; } header nav section div:hover { background: #eee; border-radius: 20px; color: #000; } header nav section:nth-of-type(1) { float: left; } header nav section:nth-of-type(1) div { float: left; } header nav section:nth-of-type(2) { float: right; } header nav section:nth-of-type(2) div { float: left; margin-left: 1rem; } header nav section:nth-of-type(2) div:nth-of-type(2), header nav section:nth-of-type(2) div:nth-of-type(3) { position: relative; } header nav section:nth-of-type(2) div:nth-of-type(2) ul, header nav section:nth-of-type(2) div:nth-of-type(3) ul { position: absolute; left: 5px; background: #eee; color: #000; font-size: 0.8rem; padding: 0.5rem; display: none; } header nav section:nth-of-type(2) div:nth-of-type(2) ul li, header nav section:nth-of-type(2) div:nth-of-type(3) ul li { margin-top: 0.6rem; padding: 1px; } header nav section:nth-of-type(2) div:nth-of-type(2) ul li:hover, header nav section:nth-of-type(2) div:nth-of-type(3) ul li:hover { background-color: #1b1b1b; color: #fff; } header nav section:nth-of-type(2) div:nth-of-type(2):hover ul, header nav section:nth-of-type(2) div:nth-of-type(3):hover ul { display: block; } main { background: #e3e2e2; height: 80vh; } footer { background: #5a5a5a; height: 20vh; } 首页 我的关注 我的收藏 默认收藏 观看最多 点赞最多 个人设置 头像设置 界面设置 资料设置 退出登录 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-07-18 22:13:48 "},"前端专栏/CSS/弹性布局.html":{"url":"前端专栏/CSS/弹性布局.html","title":"弹性布局","keywords":"","body":"弹性布局 基本介绍 弹性布局flex是CSS3新增的一种布局方式，相较于浮动布局，弹性布局在开发效率与维护性上都远胜前者。 flex全称为flexible box，因此也被称之为弹性盒子。 学习弹性布局最主要从2个方面入手： 弹性容器：被设置为display: flex或display: inline-flex的容器元素 弹性元素：弹性容器中包裹的元素 一个大的弹性容器中可以包含多个小的弹性容器，我们可以控制弹性容器中元素的排列方式，也可以为弹性元素进行单独的区域划分以及改变其排列方式，总之而言使用弹性盒模型布局非常方便。 弹性容器 容器声明 使用display: flex或者display: inline-flex声明一个元素为弹性容器。 flex：容器本身是block状态，但是其内部的弹性元素是inline-block状态 inline-flex：容器本身是inline-block状态，内部的弹性元素也是inline-block状态 flex，可以看见容器本身是独占一行的，容器内元素div变为inline-block状态： inline-flex，容器本身不会独占一行，容器内元素div变为inline-block状态： Document main{ display:inline-flex; background-color:#ddd; } main div{ width: 50px; height: 50px; background: #eee content-box; padding: .5rem; text-align: center; line-height: 50px; } 1 2 3 this is span element 排列方式 flex-direction 我们可以在弹性容器中设置flex-direction来控制容器内部弹性元素的排列方式。 它可设置的值如下表所示： 值 描述 row 从左到右水平排列元素（默认值） row-reverse 从右向左水平排列元素 column 从上到下垂直排列元素 column-reverse 从下到上垂直排列元素 1） 从左到右水平排列元素（默认值），row： 2）从右向左水平排列元素，row-reverse： 3）从上到下垂直排列元素，column： 4）从下到上垂直排列元素，column-reverse： 代码示例： Document main{ display:flex; flex-direction: row; /* flex-direction: row; flex-direction: row-reverse; flex-direction: column; flex-direction: column-reverse; */ width:300px; height:300px; background-color:#ddd; } main div{ width: 50px; height: 50px; background: #eee content-box; padding: .5rem; text-align: center; line-height: 50px; } 1 2 3 是否换行 flex-wrap 当一个弹性容器中的弹性元素太多时，默认是不会进行换行的而是挤压内部的弹性元素。 我们可以使用flex-wrap来规定弹性元素是否换行显示，并且还可以指定是否反向换行。 它可设置的值如下表所示： 值 描述 nowrap 元素不拆行或不拆列（默认值） wrap 容器元素在必要的时候拆行或拆列 wrap-reverse 容器元素在必要的时候拆行或拆列，但是以相反的顺序 1）水平方向row排列与不换行nowrap（默认设置）： 2）水平方向row排列与换行wrap： 3）水平方向row排列与反向换行： 代码示例： Document main{ display:flex; flex-direction: row; /* flex-direction: row; flex-direction: row-reverse; flex-direction: column; flex-direction: column-reverse; */ flex-wrap: wrap-reverse; /* flex-wrap: wrap; flex-wrap: wrap-reverse; */ width:300px; height:300px; background-color:#ddd; } main div{ width: 50px; height: 50px; background: #eee content-box; padding: .5rem; text-align: center; line-height: 50px; } 1 2 3 4 5 6 7 8 9 组合定义 flex-flow 使用flex-flow可进行组合定义，它提供了对flex-direction与flex-wrap的简写。 示例： flex-flow: row column; 轴与排列 轴的介绍 一个弹性容器拥有2根轴： 主轴 交叉轴（从轴） 轴是根据排列方式flex-direction值的不同来进行变化而并非是一成不变的。 常见变化如下所示： 1）如果flex-direction为row，则主轴为水平轴，交叉轴为垂直轴： 2）如果flex-direction为column，则主轴为垂直轴，交叉轴为水平轴： 此外，如果flex-direction为row-reverse或者column-reverse，那么轴的起始位置和结束位置也会发生变化。 这里不在举例，因为使用的比较少。 主轴控制 justify-content justify-content用于控制弹性元素在主轴上的排列方式。 它可设置的值如下表所示： 值 描述 flex-start 弹性元素排列从主轴起始点开始（默认值） flex-end 弹性元素排列从主轴结束点开始 center 弹性元素排列从弹性盒子中心点开始 space-between 第一个元素靠起点，最后一个元素靠终点，余下元素平均分配空间 space-around 每个元素两侧的间隔相等，所以，项目之间的间隔比项目与边框的间隔大一倍 space-evenly 元素间距离平均分配 1）flex-start 弹性元素排列从主轴起始点开始（默认值）： 2）flex-end 弹性元素排列从主轴结束点开始： 3）center 弹性元素排列从弹性容器中心点开始： 4）space-between 第一个元素靠起点，最后一个元素靠终点，余下元素平均分配空间： 5）space-around 每个元素两侧的间隔相等，所以，项目之间的间隔比项目与边框的间隔大一倍： 6）space-evenly 元素间距离平均分配： 代码示例： Document main{ display:flex; flex-flow: row wrap; justify-content: space-evenly; width:300px; height:300px; background-color:#ddd; } main div{ width: 50px; height: 50px; background: #eee content-box; padding: .5rem; text-align: center; line-height: 50px; } 1 2 3 4 5 6 7 8 9 交叉轴元素控制 align-items align-items用于控制弹性元素在交叉轴上的排列方式。 该设置仅在弹性元素只有一行时适用。 它可设置的值如下表所示： 值 描述 stretch 元素被拉伸以适应容器（默认值） center 元素位于容器的中心 flex-start 元素位于容器的交叉轴开头（默认值） flex-end 元素位于容器的交叉轴结尾 注意，如果弹性元素设置了 width | height | min-height | min-width | max-width | max-height ，将影响stretch的结果，因 stretch优先级低于宽高设置。 1）stretch 元素被拉伸以适应容器（默认值）： 2）center 元素位于容器的中心： 3）flex-start 元素位于容器的交叉轴开头（默认值）： 4）flex-end 元素位于容器的交叉轴结尾： 代码示例： Document main{ display:flex; flex-flow: row; justify-content: space-evenly; align-items: flex-end; /* align-items: stretch; align-items: center; align-items: flex-start; */ width:300px; height:300px; background-color:#ddd; } main div{ width: 50px; /* 如果验证stretch，请取消弹性元素的高度设置 */ height: 50px; background: #eee content-box; padding: .5rem; text-align: center; line-height: 50px; } 1 2 3 4 交叉轴内容控制 align-content align-content只适用于多行显示的弹性容器，它能够控制每一行（注意不是弹性元素）在交叉轴上的排列方式。 该设置仅在弹性元素具有多行时适用。 它可设置的值如下表所示： 值 描述 stretch 将空间平均分配给内容 flex-start 内容紧靠交叉轴起点 flex-end 内容紧靠交叉轴终点 center 内容从弹性容器中心开始 space-between 第一行元素靠起点，最后一行元素靠终点，余下元素平均分配空间 space-around 每行元素两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍 space-evenly 元素行间距离平均分配 1）stretch 将空间平均分配给内容： 2）flex-start 内容紧靠交叉轴起点： 3）flex-end 内容紧靠交叉轴终点： 4）center 内容从弹性容器中心开始： 5）space-between 第一行元素靠起点，最后一行元素靠终点，余下元素平均分配空间： 6）space-around 每行元素两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍： 7）space-evenly 元素行间距离平均分配： 代码示例： Document main { display: flex; flex-flow: row wrap; justify-content: space-evenly; align-content: space-evenly; /* align-content: stretch; align-content: flex-start; align-content: flex-end; align-content: center; align-content: space-between; align-content: space-evenly; */ width: 300px; height: 300px; background-color: #ddd; } main div { width: 50px; height: 50px; background: #eee content-box; padding: .5rem; text-align: center; line-height: 50px; } 1 2 3 4 5 6 7 8 9 弹性元素 交叉轴控制 align-self align-self用于控制单个弹性元素在交叉轴上的排列方式。 注意区分align-items与align-content和align-self的区别： align-items：弹性容器中设置，控制单行 align-content：弹性容器中设置，控制多行 align-self：弹性元素中设置，控制自己，即一个元素 它们的优先级如下： align-items 由于align-self的优先级小于align-content，故设置了align-content后就不要再使用align-self设置单个弹性元素的排列方式了。 它可设置的值如下表所示： 值 描述 stretch 元素被拉伸以适应容器（默认值） flex-start 元素紧靠主轴起点 flex-end 元素紧靠主轴终点 center 元素从弹性容器中心开始 示例如下，仅改变元素 1 在交叉轴的排列方式。 代码示例： Document main { display: flex; flex-flow: row wrap; justify-content: space-evenly; align-items: flex-end; width: 300px; height: 300px; background-color: #ddd; } main div { width: 50px; height: 50px; background: #eee content-box; padding: .5rem; text-align: center; line-height: 50px; } main div:nth-of-type(1){ align-self: center; } 1 2 3 4 增加自身可用空间 flex-grow 对弹性元素使用flex-grow，将弹性容器内部可用空间分配给该弹性元素，可以使用整数或小数声明空间占比。 如下示例，弹性容器的排列方式为row，content宽度为300px，其内部共有3个弹性元素，将它们的空间占用分别划分为1、3、6。 即将弹性容器整体宽度300px分为10份，然后按照1、3、6的比例分配给每个弹性元素。 计算规则： 弹性容器总宽度 / (元素1占比 + 元素2占比 + 元素3占比) * 要算的元素占比 元素1占用宽度为 ： 300 / (1 + 3 + 6) * 1 = 30px 元素2占用宽度为 ： 300 / (1 + 3 + 6) * 3 = 90px 元素3占用宽度为 ： 300 / (1 + 3 + 6) * 6 = 180px Document main { display: flex; flex-flow: row wrap; width: 300px; background-color: #ddd; } main div { background: #eee content-box; text-align: center; line-height: 50px; } main div:nth-of-type(1) { flex-grow: 1; background-color: deeppink; } main div:nth-of-type(2) { flex-grow: 3; background-color: deepskyblue; } main div:nth-of-type(3) { flex-grow: 6; background-color: violet; } 1 2 3 如果弹性元素设置了宽度，请把弹性容器宽度 - 所有弹性元素宽度总和后再按照flex-grow进行分配。 下面每个弹性元素的宽度为50px，总宽度为150px，弹性容器的宽度为300px，余下可分配空间为300px - 150px。 计算规则： 弹性容器剩余宽度 / (元素1占比 + 元素2占比 + 元素3占比) * 要算的元素占比 元素1占用宽度为 ： 150 / (1 + 3 + 6) * 1 = 15px + 50px（已有宽度） 元素2占用宽度为 ： 150 / (1 + 3 + 6) * 3 = 45px + 50px（已有宽度） 元素3占用宽度为 ： 150 / (1 + 3 + 6) * 6 = 90px + 50px（已有宽度） Document main { display: flex; flex-flow: row wrap; width: 300px; background-color: #ddd; } main div { background: #eee content-box; text-align: center; line-height: 50px; width: 50px; } main div:nth-of-type(1) { flex-grow: 1; background-color: deeppink; } main div:nth-of-type(2) { flex-grow: 3; background-color: deepskyblue; } main div:nth-of-type(3) { flex-grow: 6; background-color: violet; } 1 2 3 缩小自身可用空间 flex-shrink 与flex-grow相反flex-shrink是在弹性容器装不下元素时定义的缩小值。 注意！要取消弹性容器的换行，flex-shrink才能生效，否则无效，装不下时就直接换行了 计算规则如下： 溢出空间 = 元素1宽度 + 元素2宽度 + 元素n宽度 - 弹性容器宽度 最终尺寸 = 溢出空间 - (溢出空间 / (元素1宽度 * 元素1缩放比例 + 元素2宽度 * 元素2缩放比例 + 元素n宽度 * 元素n缩放比例) * 待计算元素的缩放比例 ) * 待计算元素宽度 如下示例，我们在宽度为300px且排列方式为row的弹性容器中放下了3个宽度为150px的弹性元素。很明显弹性容器会压缩器内部的弹性元素。 各个弹性元素的缩放比例为1， 3， 6。 开始套用规则进行计算： 溢出空间：3 * 150 - 300 = 150 元素1最终尺寸：150 - ( 150 / (150 * 1 + 150 * 3 + 150 * 6) * 1 ) * 150 = 135px 元素2最终尺寸：150 - ( 150 / (150 * 1 + 150 * 3 + 150 * 6) * 3 ) * 150 = 105px 元素3最终尺寸：150 - ( 150 / (150 * 1 + 150 * 3 + 150 * 6) * 6 ) * 150 = 60px Document main { display: flex; flex-flow: row nowrap; width: 300px; background-color: #ddd; } main div { background: #eee content-box; text-align: center; line-height: 50px; width: 150px; } main div:nth-of-type(1) { flex-shrink: 1; background-color: deeppink; } main div:nth-of-type(2) { flex-shrink: 3; background-color: deepskyblue; } main div:nth-of-type(3) { flex-shrink: 6; background-color: violet; } 1 2 3 定义基准尺寸 flex-basis 如果将轴的宽度看做100%，我们可以对弹性元素使用flex-basis来定义它占据主轴的百分比。 使用时需要注意一点，该项设置的优先级大于width和height。 如下所示，主轴宽度为300px，3个弹性元素占比为20%，20%，60%： Document main { display: flex; flex-flow: row nowrap; width: 300px; background-color: #ddd; } main div { background: #eee content-box; text-align: center; line-height: 50px; } main div:nth-of-type(1) { flex-basis: 20%; background-color: deeppink; } main div:nth-of-type(2) { flex-basis: 20%; background-color: deepskyblue; } main div:nth-of-type(3) { flex-basis: 60%; background-color: violet; } 1 2 3 组合定义 flex 使用flex可对flex-grow、flex-sharink以及flex-basis进行简写。 即：增容比例、缩容比例、基准尺寸占比。 在这其中，基准尺寸占比的优先级最大。 建议不要仅在flex中设置单独的1个值。 如下示例： Document main { display: flex; flex-flow: row nowrap; width: 300px; background-color: #ddd; } main div { background: #eee content-box; text-align: center; line-height: 50px; } main div:nth-of-type(1) { /* 增容比例、缩容比例、基准尺寸占比 */ flex: 1 0 40%; background-color: deeppink; } main div:nth-of-type(2) { flex: 3 1 20%; background-color: deepskyblue; } main div:nth-of-type(3) { flex: 3 1 20%; background-color: violet; } 1 2 3 元素排序优先级 order 所有的弹性元素优先级默认均为0，优先级越低越靠近主轴起始点。 Document main { display: flex; flex-flow: row nowrap; width: 300px; background-color: #ddd; } main div { background: #eee content-box; text-align: center; line-height: 50px; } main div:nth-of-type(1) { order: 3; flex-grow: 1; background-color: deeppink; } main div:nth-of-type(2) { order: 2; flex-grow: 1; background-color: deepskyblue; } main div:nth-of-type(3) { order: 1; flex-grow: 1; background-color: violet; } A-order 3 B-order 2 C-order 1 文本元素 文本也可以作为弹性元素。 Document main { display: flex; flex-flow: row nowrap; justify-content: center; align-items: center; width: 300px; height: 300px; background-color: #ddd; font-size: 4rem; } text 绝对定位 绝对定位的元素是不会参与到弹性布局中的。 可以看见弹性容器中绝对定位的元素交叉轴拉伸是不起作用的： Document main { display: flex; flex-flow: row nowrap; justify-content: center; align-items: stretch; width: 300px; height: 300px; background-color: #ddd; position: relative; } main div{ background-color: #eee; padding: .5rem; } main div:nth-child(2){ position: absolute; left: 1rem; top: 3rem; } stream absolute 自动空间 使用margin-right: auto可令弹性元素自动撑开余下的空间。 如下这个案例，我们是水平排列方式，要将滑稽头像放在最右边，但是对于滑稽这个弹性元素来说没有那种能够将自己放在水平主轴结束位置的选项。 所以我们可以对左边的ul弹性元素使用margin-right: auto;来进行自动将右边撑开： 或者也可以对header使用justify-content: space-between，达到相同的效果。 Document header { display: flex; flex-flow: row nowrap; width: 60%; background-color: #f3f3f3; box-shadow: 0 0 5px rgba(0, 0, 0, .2); /* 二选一 justify-content*: space-between */ } header ul { display: flex; /* 二选一 */ margin-right: auto; } header ul li { padding: 1rem; } header img { width: 3rem; margin-right: 1rem; border-radius: 50%; } 主页 我的关注 我的文章 我的好友 微信布局 使用弹性布局快速搭建微信布局： Document :root { background-color: #ccc; } header, main, footer { display: flex; flex-flow: row nowrap; padding: 0 1rem; border-bottom: 1px solid #bbb; justify-content: space-between; align-items: center; } header { height: 10vh; } main { height: 80vh; } main ul { width: 100%; display: flex; flex-flow: column nowrap; /* 优先级大于 align-items */ align-self: flex-start; } main ul li { margin-top: 3rem; display: flex; align-items: center; } main ul li:last-of-type { align-self: flex-end; } main ul li *:last-child { margin-left: .5rem; } main ul li i.icon-huaji, main ul li i.icon-mojinghuaji { font-size: 2rem; color: green; background-color: #ddd; } main ul li span { background-color: #fff; border: 1px solid #aaa; padding: .4rem; border-radius: 10px; } footer { height: 10vh; } footer i { font-size: 2rem !important; } footer input { height: 50%; } &lt; 大神 ... 老弟在吗？ 一起去看电影 哥我不去了，今天没时间 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-08-05 22:51:48 "},"前端专栏/CSS/栅格布局.html":{"url":"前端专栏/CSS/栅格布局.html","title":"栅格布局","keywords":"","body":"栅格布局 基本介绍 CSS的栅格布局也被称为网格布局(Grid Layout)，它是一种新兴的布局方式。 栅格布局是一个二维系统，这意味着它可以同时处理列和行，与弹性布局相似，栅格系统也是由栅格容器包裹栅格元素进行使用。 对于栅格布局来说，它的思想实际上非常简单，将一块区域绘制成格子，然后将元素填进去即可。 作为学习者应该从下面两个角度来学习栅格布局： 怎么样画出栅格容器 怎么样将元素放进栅格容器中的某一区域 　值得一提的是，现在的一些旧版浏览器对于栅格布局并没有较好的支持性，所以这项技术的应用场景其实相比于传统式的浮动布局以及弹性布局来说会少一些。 栅格容器 容器声明 使用display: grid或者display: inline-gid声明一个元素为栅格容器。 grid：块级栅格容器，独占一行 inline-grid：内联块级栅格容器，不独占一行 首先声明grid，即块级栅格容器，可以看见容器本身是独占一行的： 其次是inline-grid，即内联块级栅格容器，容器本身不会独占一行： 代码示例： Document main { border: solid 5px silver; /* 声明容器 */ display: inline-grid; /* display: grid; display: inline-grid; */ /* 划分行列 */ grid-template-rows: repeat(3, 100px); grid-template-columns: repeat(3, 100px); } main div { background: blueviolet content-box; padding: 10px; border: 1px #000 dashed; text-align: center; line-height: 80px; color: #fff; } 1 2 3 4 5 6 7 8 9 this is span element 栅格容器之行列划分 划分行列 光有栅格容器没有用，我们还需要为栅格容器划分行列以及指定宽度。 grid-template-rows：划分行数 grid-template-columns：划分列数 下面介绍几种划分行列的方式。 固定宽高 如我们想画一个2行3列固定宽高的栅格容器，可以使用下面的方法进行绘制： grid-template-rows: 100px 100px; grid-template-columns: 100px 100px 100px; 渲染结果，高度200px，款度300px： 代码示例： Document main { border: solid 5px silver; /* 声明容器 */ display: inline-grid; /* 划分行列 */ grid-template-rows: 100px 100px; grid-template-columns: 100px 100px 100px; } main div { background: blueviolet content-box; padding: 10px; border: 1px #000 dashed; text-align: center; line-height: 80px; color: #fff; } 1 2 3 4 5 6 百分比宽高 使用百分比来绘制行列线，使用这种方式你必须先指定栅格容器的宽高。 如下面示例中为一个300 * 300的栅格容器绘制出2行4列的线条： grid-template-rows: 50% 50%; grid-template-columns: 25% 25% 25% 25%; 渲染结果： 代码示例： Document main { border: solid 5px silver; width: 300px; height: 300px; /* 声明容器 */ display: inline-grid; /* 划分行列 */ grid-template-rows: 50% 50%; grid-template-columns: 25% 25% 25% 25%; } main div { background: blueviolet content-box; padding: 10px; border: 1px #000 dashed; text-align: center; line-height: 150px; color: #fff; } 1 2 3 4 5 6 7 8 重复划分 若每行或每列的间距是相同的，则直接可以使用重复绘制更加简便的划分行列。 grid-template-rows: repeat(3, 100px); grid-template-columns: repeat(3, 100px); 代码示例： Document main { border: solid 5px silver; /* 声明容器 */ display: inline-grid; /* 划分行列 */ grid-template-rows: repeat(3, 100px); grid-template-columns: repeat(3, 100px); } main div { background: blueviolet content-box; padding: 10px; border: 1px #000 dashed; text-align: center; line-height: 80px; color: #fff; } 1 2 3 4 5 6 7 8 9 我们也可以重复绘制不同宽度的单元格，比如奇数项的列要宽一点，偶数项的列要窄一点： grid-template-rows: repeat(3, 100px); grid-template-columns: repeat(2, 100px 50px); 代码示例： Document main { border: solid 5px silver; /* 声明容器 */ display: inline-grid; /* 划分行列 */ grid-template-rows: repeat(3, 100px); /* 重复2次， 奇数项列宽为100px、偶数项列宽为50px 最终总列数 = 重复次数 * 后面跟上的个数 即 2 * 2 = 4列 */ grid-template-columns: repeat(2, 100px 50px); } main div { background: blueviolet content-box; padding: 10px; border: 1px #000 dashed; text-align: center; line-height: 80px; color: #fff; } 1 2 3 4 5 6 7 8 9 10 11 12 自动划分 自动划分是指不指定划分多少行或者列，而是只给他一个行列占比的具体数值，它会自动根据容器的大小来进行划分。 我们想在一个宽和高都是300px的栅格容器中进行绘制，而每个单元格的宽高都是100px，那就设置一下交给他自动绘制。 grid-template-rows: repeat(auto-fill, 100px); grid-template-columns: repeat(auto-fill, 100px); 代码示例： Document main { width: 300px; height: 300px; border: solid 5px silver; /* 声明容器 */ display: inline-grid; /* 划分行列 */ grid-template-rows: repeat(auto-fill, 100px); grid-template-columns: repeat(auto-fill, 100px); } main div { background: blueviolet content-box; padding: 10px; border: 1px #000 dashed; text-align: center; line-height: 80px; color: #fff; } 1 2 3 4 5 6 7 8 9 比例划分 如果你的栅格容器已设置宽高，则我们可以按照空间比例进行行列划分。单位是fr。 如下所示，这是一个3行3列的栅格容器，第一行和最后一行的高度都为3fr，中间一行的高度为4fr，第一列和最后一列的宽度都为2fr，中间一列的宽度为6fr： grid-template-rows: 3fr 4fr 3fr; grid-template-columns: 2fr 6fr 2fr; 代码示例： Document main { width: 300px; height: 300px; border: solid 5px silver; /* 声明容器 */ display: inline-grid; /* 划分行列 */ grid-template-rows: 3fr 4fr 3fr; grid-template-columns: 2fr 6fr 2fr; } main div { background: blueviolet content-box; padding: 10px; border: 1px #000 dashed; text-align: center; line-height: 80px; color: #fff; } 1 2 3 4 5 6 7 8 9 组合定义 grid-template是grid-template-rows、grid-template-columns、grid-template-areas 的三个属性的简写。 但是我们目前还没有介绍到grid-template-areas，所以仅演示用grid-template来划分行列。 如下将采用组合定义的方式构建出一个3行3列宽高均为100px的栅格容器： 注意：先行后列 grid-template: repeat(3, 100px) / repeat(3, 100px); 代码示例： Document main { border: solid 5px silver; /* 声明容器 */ display: inline-grid; /* 划分行列 先行后列 */ grid-template: repeat(3, 100px) / repeat(3, 100px); } main div { background: blueviolet content-box; padding: 10px; border: 1px #000 dashed; text-align: center; line-height: 80px; color: #fff; } 1 2 3 4 5 6 7 8 9 minmax划分 如果你的栅格容器设置了宽高，且栅格容器中单元格的宽高大于整体栅格容器的宽高就会发生溢出现象。 我们在划分行列时，可以指定minmax，为行线或者列线设定一个动态的取值数值来防止溢出的发生。 上面这个例子中，栅格容器宽高为200px 300px，但是行列划分时设定是3列3行100px，所以就造成了列溢出。 此时我们可以在列划分时设置minmax来进行单元格的自动缩容或者扩容： 释义：列线3根，最小取值范围为50px，最大取值范围为100px grid-template: repeat(3, 100px) / repeat(3, minmax(50px, 100px)); 栅格容器之间距定义 行间距 row-gap 栅格容器中每一个元素，现在看是紧密挨在一起的。我们可以对栅格元素本身进行margin或者padding来将彼此之前撑开留出间隙，也可以使用栅格容器提供的方法。 使用row-gap设置行间距。 Document * { padding: 0; margin: 0; } body { padding: 100px; } main { width: 300px; /* height: 300px; */ border: solid 5px silver; display: grid; /* 行数，列数 */ grid-template: repeat(3,100px)/repeat(3,minmax(50px,100px)); /* 行间距 */ row-gap:30px ; } section { background-color: blueviolet; background-clip: content-box; padding: 10px; border: dashed 1px black; text-align: center; line-height: 78px; color: #fff; } 1 2 3 4 5 6 7 8 9 列间距 columns-gap 使用column-gap定义列间距。 Document * { padding: 0; margin: 0; } body { padding: 100px; } main { width: 300px; /* height: 300px; */ border: solid 5px silver; display: grid; /* 行数，列数 */ grid-template: repeat(3,100px)/repeat(3,minmax(50px,100px)); /* 列间距 */ column-gap:30px ; } section { background-color: blueviolet; background-clip: content-box; padding: 10px; border: dashed 1px black; text-align: center; line-height: 78px; color: #fff; } 1 2 3 4 5 6 7 8 9 组合定义 gap 使用gap规则可以一次定义行、列间距，如果间距一样可以只设置一个值。 Document * { padding: 0; margin: 0; } body { padding: 100px; } main { width: 300px; /* height: 300px; */ border: solid 5px silver; display: grid; /* 行数，列数 */ grid-template: repeat(3,100px)/repeat(3,minmax(50px,100px)); /* 行列间距 */ gap:30px ; } section { background-color: blueviolet; background-clip: content-box; padding: 10px; border: dashed 1px black; text-align: center; line-height: 78px; color: #fff; } 1 2 3 4 5 6 7 8 9 栅格容器之栅格线命名 基础知识 可以发现，其实最少有2条线的数据就可以定位一个栅格元素所在的位置。 如果我们想将元素放入正中间，可以这样设置： 行线开始位：2号线开始或者1号线结束位置 列线开始位：2号线开始或者1号线结束位置 行线结束位：3号线开始或者2号线结束位置 列线结束位：3号线开始或者2号线结束位置 那么这样，我们就可以将元素定位在该容器正中，并且大小只占据1个单元格。 独立命名 我们可以为每一条栅格线都进行独立命名，现在就来将上面的伪代码实现一下。 grid-template-rows: [r1-start] 100px [r1-end r2-start] 100px [r2-end r3-start] 100px [r3-end]; grid-template-columns: [c1-start] 100px [c1-end c2-start] 100px [c2-start c3-start] 100px [c3-end]; 每条线可以有多个名字，在使用的时候可以使用其任意的且具有的名字。 当我们需要定位的时候，使用如下格式对一个元素进行定位： grid-row-start: r2-start; grid-column-start:c1-end; grid-row-end: r2-end; grid-column-end: c3-start; 注意！默认的栅格容器是不会展示栅格线的，此时需要打开浏览器的检查功能就会看到栅格线。 Document * { padding: 0; margin: 0; } body { padding: 100px; } main { width: 300px; /* height: 300px; */ border: solid 5px silver; display: grid; /* 行数，列数 */ grid-template-rows: [r1-start] 100px [r1-end r2-start] 100px [r2-end r3-start] 100px [r3-end]; grid-template-columns: [c1-start] 100px [c1-end c2-start] 100px [c2-start c3-start] 100px [c3-end]; } section { background-color: blueviolet; background-clip: content-box; padding: 10px; border: dashed 1px black; text-align: center; line-height: 78px; color: #fff; grid-row-start: r2-start; grid-column-start: c1-end; grid-row-end: r2-end; grid-column-end: c3-start; } 中间 自动命名 对于重复设置的栅格容器系统会为它自动命名，使用时使用r1、c2的方式定位栅格。 r代表行 c代表列 重复设置，命名前缀： grid-template-rows: repeat(3, [r-start] 100px [r-end]); grid-template-columns: repeat(3, [c-start] 100px [c-end]); 在使用自动命名的栅格线进行定位时，应该按照如下格式： grid-row-start: r-start 2; grid-column-start: c-start 2; grid-row-end: r-start 2; grid-column-end: c-end 2; Document * { padding: 0; margin: 0; } body { padding: 100px; } main { width: 300px; /* height: 300px; */ border: solid 5px silver; display: grid; /* 行数，列数 */ grid-template-rows: repeat(3, [r-start] 100px [r-end]); grid-template-columns: repeat(3, [c-start] 100px [c-end]); } section { background-color: blueviolet; background-clip: content-box; padding: 10px; border: dashed 1px black; text-align: center; line-height: 78px; color: #fff; grid-row-start: r-start 2; grid-column-start: c-start 2; grid-row-end: r-start 2; grid-column-end: c-end 2; } 中间 栅格元素之元素定位 定位方法 我们可以使用以下方法对栅格元素进行定位，但是关于如何定位又分为很多种。 选项 描述 grid-row-start 行开始栅格线 grid-row-end 行结束栅格线 grid-column-start 列开始栅格线 grid-column-end 列结束栅格线 栅格线位置定位 栅格线位置定位实际上就是数数，在水平的第几根线，在垂直的第几根线。 还是老办法，规定行开始线位置与行结束线位置以及列开始线位置和列结束线位置。 如下，可以看到，单纯的就是数数，非常的简单粗暴。 grid-row-start: 2; grid-column-start: 2; grid-row-end: 2; grid-column-end: 2; Document * { padding: 0; margin: 0; } body { padding: 100px; } main { width: 300px; /* height: 300px; */ border: solid 5px silver; display: grid; /* 行数，列数 */ grid-template-rows: repeat(3, 100px); grid-template-columns: repeat(3, 100px); } section { background-color: blueviolet; background-clip: content-box; padding: 10px; border: dashed 1px black; text-align: center; line-height: 78px; color: #fff; grid-row-start: 2; grid-column-start: 2; grid-row-end: 2; grid-column-end: 2; } 中间 栅格线名称定位 我们说过栅格线有独立命名和自动命名。 根据栅格线名称也可以进行定位，这里不再举例，具体参见栅格线命名一章。 偏移量定位 这个其实也比较简单，我们只需要指定行线的开始位置以及列线的开始位置即可，关于结束为止也是数数，使用span来数，往后走一根线还是两根线。 grid-row-start: 1; grid-column-start: 1; /\\ 代表从行线开始位置向后数3根线 */* grid-row-end: span 3; /\\ 代表从列线开始位置向后数3根线 */* grid-column-end: span 3; Document * { padding: 0; margin: 0; } body { padding: 100px; } main { width: 300px; /* height: 300px; */ border: solid 5px silver; display: grid; /* 行数，列数 */ grid-template-rows: repeat(3, 100px); grid-template-columns: repeat(3, 100px); } section { background-color: blueviolet; background-clip: content-box; padding: 10px; border: dashed 1px black; text-align: center; line-height: 300px; color: #fff; grid-row-start: 1; grid-column-start: 1; /* 代表从行线开始位置向后数3根线 */ grid-row-end: span 3; /* 代表从列线开始位置向后数3根线 */ grid-column-end: span 3; } 全占 简写模式 可以使用grid-row设置行开始栅格线，使用grid-column设置结束栅格线。 grid-row: 3/span 3; grid-column: 2/span 3; Document * { padding: 0; margin: 0; } body { padding: 100px; } main { width: 300px; /* height: 300px; */ border: solid 5px silver; display: grid; /* 行数，列数 */ grid-template-rows: repeat(3, 100px); grid-template-columns: repeat(3, 100px); } section { background-color: blueviolet; background-clip: content-box; padding: 10px; border: dashed 1px black; text-align: center; line-height: 78px; color: #fff; grid-row: 3/span 3; grid-column: 2/span 3; } 右下角两格 极简模式 grid-area是对上面的简写模式grid-row以及grid-column的再次简写，它的语法结构如下： 行线开始/列线开始/行线结束/列线结束 grid-area: 2/1/span 1/span 3; Document * { padding: 0; margin: 0; } body { padding: 100px; } main { width: 300px; /* height: 300px; */ border: solid 5px silver; display: grid; /* 行数，列数 */ grid-template-rows: repeat(3, 100px); grid-template-columns: repeat(3, 100px); } section { background-color: blueviolet; background-clip: content-box; padding: 10px; border: dashed 1px black; text-align: center; line-height: 78px; color: #fff; grid-area: 2/1/span 1/span 3; } 中间三格 bootstrap 栅格原理 bootstrap中的栅格系统将整个栅格容器分为了12个块，其实它的原理非常简单。 我们用目前所学的知识也能开发类似的组件，如下图： Document * { padding: 0; margin: 0; } body { padding: 100px; } .row { padding: 10px; width: 600px; border: solid 5px silver; display: grid; grid-template-columns: repeat(12, 1fr); gap: 10px 10px; } .col-1 { grid-column-end: span 1; } .col-2 { grid-column-end: span 2; } .col-3 { grid-column-end: span 3; } .col-4 { grid-column-end: span 4; } .col-5 { grid-column-end: span 5; } .col-6 { grid-column-end: span 6; } .col-7 { grid-column-end: span 7; } .col-8 { grid-column-end: span 8; } .col-9 { grid-column-end: span 9; } .col-10 { grid-column-end: span 10; } .col-11 { grid-column-end: span 11; } .col-12 { grid-column-end: span 12; } [class^=\"col-\"] { background-color: blueviolet; background-clip: content-box; height: 30px; text-align: center; color: #fff; } col-8 col-4 col-4 col-4 col-4 col-6 col-6 栅格容器之栅格区域 基础介绍 栅格区域说白了就是一堆栅格的单元格组成的区域，一个单元格也是一个区域。 我们可以使用栅格区域更方便的放置元素而不用再慢慢的数线放置，栅格区域放置元素通常用在大布局上。 使用grid-template-areas声明栅格区域时需要注意一点，栅格区域放置元素必须是矩形的。 你不能这样放置这样的一个元素： 区域命名 来看一个简单的案例，如何使用grid-template-areas对栅格区域进行命名并填充元素。 Document * { padding: 0; margin: 0; } body { padding: 100px; } main { width: 300px; /* height: 300px; */ border: solid 5px silver; display: grid; /* 行数，列数 */ grid-template-rows: repeat(3, 100px); grid-template-columns: repeat(3, 100px); grid-template-areas: \"top top top\" \"mid mid mid\" \"bottom bottom bottom\"; /* 由于绘制了9*9的单元格，我们必须给每个单元格进行了命名 ，而且一定要是这种格式*/ } main * { background-clip: content-box; padding: 10px; border: dashed 1px black; } main header { /* 完整的写法，推荐使用下面的简写方式*/ /* grid-area: top-start/top-start//top-start/top-end/top-end/top-end; */ grid-area: top; background-color: blueviolet; } main article { grid-area: mid; background-color: violet; } main footer { grid-area: bottom; background-color: yellowgreen; } 自动命名 栅格容器中的每个单元格的列行线都会根据单元格名称自动进行命名，如下图所示： 按图中这种命名来进行实验： Document * { padding: 0; margin: 0; } body { padding: 100px; } main { width: 300px; /* height: 300px; */ border: solid 5px silver; display: grid; /* 行数，列数 */ grid-template-rows: repeat(3, 100px); grid-template-columns: repeat(3, 100px); grid-template-areas: \"top-left top-center top-right\" \"mid-left mid-center mid-right\" \"bottom-left bottom-center bottom-right\"; /* 由于绘制了9*9的单元格，我们必须给每个单元格进行了命名 ，而且一定要是这种格式*/ } main * { background-clip: content-box; padding: 10px; border: dashed 1px black; } main div:first-of-type { grid-area: top-left-start/top-left-start/mid-center-end/mid-center-end; background-color: blueviolet; } main div:last-of-type { grid-area: bottom-left-start/bottom-left-start/bottom-right-end/bottom-right-end; background-color: violet; } 占位命名 栅格区域命名占位就是说有的区域不想给他取名，那么就直接.就行。 为什么要这么做呢？看下图以及代码就能理解，我们在进行区域划分的时候就想好了这一块区域是来干什么的，应该有多大，那么多余的地方直接.占位即可。 Document * { padding: 0; margin: 0; } body { padding: 100px; } main { width: 300px; /* height: 300px; */ border: solid 5px silver; display: grid; /* 行数，列数 */ grid-template-rows: repeat(3, 100px); grid-template-columns: repeat(3, 100px); grid-template-areas: \"top top top\" \"mid mid .\" \"bottom . .\"; /* 由于绘制了9*9的单元格，我们给每个单元格进行了命名 ，一定要是这种格式*/ } main * { background-clip: content-box; padding: 10px; border: dashed 1px black; } main header { /* 完整的写法，推荐使用下面的简写方式*/ /* grid-area: top-start/top-start//top-start/top-end/top-end/top-end; */ grid-area: top; background-color: blueviolet; } main article { grid-area: mid; background-color: violet; } main footer { grid-area: bottom; background-color: yellowgreen; } 栅格元素之元素排序 排序方式 默认情况下，整个栅格元素都是以行（水平）进行填充排序，我们可以在容器中设置grid-auto-flow属性可以改变元素排序的方式。 值 描述 column 按列排序 row 按行排列 Document * { padding: 0; margin: 0; } body { padding: 100px; } main { width: 300px; height: 300px; border: solid 5px silver; display: grid; /* 行数，列数 */ grid-template: repeat(3, 100px)/repeat(3, 100px); /* 排序方式：垂直 */ grid-auto-flow: column; } section { background-color: blueviolet; background-clip: content-box; padding: 10px; border: dashed 1px black; text-align: center; line-height: 78px; color: #fff; } 1 2 3 4 5 6 7 8 9 空间填充 当元素在栅格中放不下时，将会发生换行产生留白，使用grid-auto-flow: row dense; 可以执行填充空白区域操作。 如下图，产生了两个空间。 当设置之后可以发现，1和2的位置都没变，3和4填充了上来： Document * { padding: 0; margin: 0; } body { padding: 100px; } main { width: 300px; height: 300px; border: solid 5px silver; display: grid; /* 行数，列数 */ grid-template: repeat(3, 100px)/repeat(3, 100px); /* 排序方式：水平 是否填充空间：填充 */ grid-auto-flow: row dense; } section { background-color: blueviolet; background-clip: content-box; padding: 10px; border: dashed 1px black; text-align: center; line-height: 78px; color: #fff; } main section:nth-of-type(1) { /* 列线 第1根开始往后数2根的区域 */ grid-column: 1/span 2; } main section:nth-of-type(2) { /* 列线 第2根开始往后数2根的区域 */ grid-column: 2/span 2; } 1 2 3 4 对齐方式 对齐选项 可以通过属性方便的定义栅格容器内栅格元素的对齐方式，可用值包括 start | end | center | stretch | space-between | space-evenly | space-around。 下面是提供对齐的属性： 属性 描述 对象 align-items 栅格内所有元素的垂直排列方式 栅格容器 justify-items 栅格内所有元素的横向排列方式 栅格容器 justify-content 所有栅格在容器中的水平对齐方式，容器有额外空间时 栅格容器 align-content 所有栅格在容器中的垂直对齐方式，容器有额外空间时 栅格容器 align-self 元素在栅格中垂直对齐方式 栅格元素 justify-self 元素在栅格中水平对齐方式 栅格元素 下面是属性中可填入的值： 值 描述 start 元素按排序方式顺序排列 end 元素按排序方式倒序排列 center 元素在容器中 space-between 第一个元素靠起点，最后一个元素靠终点，余下元素平均分配空间 space-around 每个元素两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍 space-evenly 元素间距离平均分配 整体区域对齐 其实这些和弹性布局中的用法都差不多，可以看一下前一章写的弹性布局，那么这里就举例一个平均分配吧。 平均分布指的是，栅格容器中的栅格区域（即单元格），在栅格容器中的对齐方式。 注意：栅格容器一定要有多余空间。 指定所有区域对齐方式使用justify-content与align-content： Document * { padding: 0; margin: 0; } body { padding: 100px; } main { width: 600px; /* 宽度和高度要足够大 */ height: 600px; border: solid 5px silver; display: grid; /* 行数，列数 */ grid-template: repeat(3, 100px)/repeat(3, 100px); /* 水平平均 */ justify-content: space-evenly; /* 垂直平均 */ justify-content: space-evenly; align-content: space-evenly; } section { background-color: blueviolet; background-clip: content-box; padding: 10px; border: dashed 1px black; text-align: center; line-height: 78px; color: #fff; } 1 2 3 4 5 6 7 8 9 所有元素对齐 指的是栅格区域中具体的栅格元素的对齐方式，比如说一个单元格太大了，那么里面内容又太小了该怎么做。 指定所有栅格区域中的具体元素使用：justify-items与align-items 注意：栅格区域一定要有多余空间。 Document * { padding: 0; margin: 0; } body { padding: 100px; } main { width: 300px; height: 300px; border: solid 5px silver; display: grid; /* 行数，列数 */ grid-template: repeat(3, 100px)/repeat(3, 100px); /* 控制具体元素在单元格中的位置 */ justify-items: center; align-items: center; } section { background-color: blueviolet; background-clip: content-box; padding: 10px; border: dashed 1px black; text-align: center; color: #fff; width: 30px; height: 30px; line-height: 30px; } 1 2 3 4 5 6 7 8 9 单个元素对齐 如果想控制单个元素对齐方式，使用justify-self与align-self即可。 注意：盛放该元素的栅格区域一定要有多余空间。 Document * { padding: 0; margin: 0; } body { padding: 100px; } main { width: 300px; height: 300px; border: solid 5px silver; display: grid; /* 行数，列数 */ grid-template: repeat(3, 100px)/repeat(3, 100px); /* 控制具体元素在单元格中的位置 */ justify-items: center; align-items: center; } section { background-color: blueviolet; background-clip: content-box; padding: 10px; border: dashed 1px black; text-align: center; color: #fff; width: 30px; height: 30px; line-height: 30px; } main section:nth-of-type(1) { justify-self: end; align-self: end; } main section:nth-of-type(2) { justify-self: start; align-self: end; } main section:nth-of-type(4) { justify-self: end; align-self: start; } main section:nth-of-type(5) { justify-self: start; align-self: start; } 1 2 3 4 5 6 7 8 9 简写模式 1）place-content用于控制栅格中所有区域的对齐方式，语法如下： place-content: 2）place-items用于控制所有区域中所有元素的对齐方式，语法如下： place-items: 3）place-self用于控制区域中单个元素的对齐方式，语法如下： place-self: Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-07-20 08:17:10 "},"前端专栏/CSS/变形动画.html":{"url":"前端专栏/CSS/变形动画.html","title":"变形动画","keywords":"","body":"前言 在开始介绍CSS变形动画之前，可以先了解一下学习了它之后能做什么，有什么用，这样你看这篇文章可能会有一些动力。 学习了CSS变形动画后，你可以为你的页面做出很多炫酷的效果，如一个3D的魔方，一个很酷的旋转菜单等等。 在本章节中将会采用大量的实例进行演示，相信你如果看完这篇文章后写出的页面会更加的吸引眼球。 基础知识 坐标系统 首先我们要学习的变形动画，想达到在上图中出现的3D效果单纯的X与Y两个轴是实现不了的，还需要加入一条纵深轴，即Y轴的参与才有一个3D的视觉感受。 那么如何来理解X,Y,Z这三条轴的关系呢？可以看一下下面这张图。 X轴代表水平轴 Y轴代表垂直轴 Z轴代表纵深轴 X和Y轴都非常好理解，怎么理解这个Z轴呢？ CSS的中文名称叫做层叠样式表，那么它肯定是一层一层的。之前学习过z-index就是用来设置层的优先级，优先级越高越在上面，也可以理解为离我们肉眼越近，它把优先级低的层给盖住了，所以Z轴可以理解为我们观察的视角与被观察物体之间的一条轴。 Z轴数值越大，说明观测距离越远。 Z轴的数值可以无限大，所以设置的时候一定要小心。 变形操作 可以使用transform规则控制元素的变形操作，包括元素移动、旋转、倾斜、3D转换等等。 下表中是CSS提供的变形动作，在接下来的学习中将会对一个变形动作进行详解。 选项 说明 none 定义不进行转换。 translate(x,y) 定义 2D 转换。 translate3d(x,y,z) 定义 3D 转换。 translateX(x) 定义转换，只是用 X 轴的值。 translateY(y) 定义转换，只是用 Y 轴的值。 translateZ(z) 定义 3D 转换，只是用 Z 轴的值。 scale(x,y) 定义 2D 缩放转换。 scale3d(x,y,z) 定义 3D 缩放转换。 scaleX(x) 通过设置 X 轴的值来定义缩放转换。 scaleY(y) 通过设置 Y 轴的值来定义缩放转换。 scaleZ(z) 通过设置 Z 轴的值来定义 3D 缩放转换。 rotate(angle) 定义 2D 旋转，在参数中规定角度。 rotate3d(x,y,z,angle) 定义 3D 旋转。 rotateX(angle) 定义沿着 X 轴的 3D 旋转。 rotateY(angle) 定义沿着 Y 轴的 3D 旋转。 rotateZ(angle) 定义沿着 Z 轴的 3D 旋转。 skew(x-angle,y-angle) 定义沿着 X 和 Y 轴的 2D 倾斜转换。 skewX(angle) 定义沿着 X 轴的 2D 倾斜转换。 skewY(angle) 定义沿着 Y 轴的 2D 倾斜转换。 perspective(n) 为 3D 转换元素定义透视视图。 变形叠加 这其实是一个坑点，在使用变形中一定要注意，重复对元素设置变形操作时只在元素的原形态上操作。 我们可以先看一下下面的案例，不懂代码没关系，懂这个意思就行了。 默认处理 下面设置了两次移动，并不会移动550px 而是只移动50px。 我们在元素中先设置了右移500px，鼠标放上去时再往右移动50px，可是下面却出现了向左移动的场景，这是因为对div进行了位置居中处理，它必须要按照之前居中的位置进行50px的移动。而不是按照居中后设置的500px的地方再进行向右移动50px。 上面这句话有点绕，总之。上面设置了，位置改变了，下面再设置，不会按照已改变的位置进行变化，而是按照原位置。 代码示例： Document * { margin: 0; padding: 0; box-sizing: border-box; list-style: none; } body { height: 100vh; width: 100vw; background-color: aliceblue; display: flex; justify-content: center; align-items: center; } div { width: 200px; height: 200px; background-color: blueviolet; /* 意思就是说按x轴移动500px */ transform: translateX(500px); /* 过渡时间2s */ transition: 2s; } div:hover { /* 意思就是说按x轴移动50px */ transform: translateX(50px); } 伪类叠加 还是设置两次移动，如果移动的方向都一样，且伪类设置的移动比原本的移动多一点，就在原本的基础上直接进行变形，而不用再找开始位置了。 我们还是拿上面的案例，只不过伪类移动的数值将50px改为600px，比第一次设置大100px，那么此时他就不会再往左走，而是直接在原有基础上进行叠加，向右移动100px。 代码示例： Document * { margin: 0; padding: 0; box-sizing: border-box; list-style: none; } body { height: 100vh; width: 100vw; background-color: aliceblue; display: flex; justify-content: center; align-items: center; } div { width: 200px; height: 200px; background-color: blueviolet; /* 意思就是说按x轴移动500px */ transform: translateX(500px); /* 过渡时间2s */ transition: 2s; } div:hover { /* 意思就是说按x轴移动600px */ transform: translateX(600px); } 内联元素 内联元素即行级元素，inline元素是不能参与变形的，将其转为 inline-block 或 block 以及弹性元素时才可以产生变化效果。 :hover伪类 鼠标移动到某一元素上发生的用户行为。 当该行为出现时，我们可以为它指定一些参数的改变。 如下，改变颜色。 :target伪类 意思就是说你点击一个\\，该\\标签中的href指向的锚点标签会发生变化。 点击第一个\\元素，与之相对的锚点元素发生变化。 点击第二个\\元素，与第一个\\元素相对的锚点变化停止，与第二个\\元素相对的锚点发生变化。 代码示例： Document * { padding: 0; margin: 0; list-style: none; box-sizing: border-box; } body { width: 100vw; height: 100vh; display: flex; flex-flow: column; justify-content: center; align-items: center; } div { width: 200px; height: 200px; display: flex; justify-content: center; align-items: center; color: #fff; font-size: 2em; } div:nth-child(1) { background: red; } div:nth-child(2) { background: blue; } #div-1:target { background-color: green; } #div-2:target { background-color: black; } 原本颜色：红 原本颜色：蓝 让div-1变绿 让div-2变黑 最后注意一点 事件元素上放过渡时间，:hover上放具体的事件，如移动，旋转，倾斜等操作。 如果你设置了移动却将过渡时间放在了:hover里面，那么就会出现下面这种情况。 可以看见，直勾勾的就回来了，这种效果显然不是我们想要的。 代码示例： Document * { padding: 0; margin: 0; list-style: none; box-sizing: border-box; } body { width: 100vw; height: 100vh; display: flex; justify-content: center; align-items: center; } main { width: 400px; height: 200px; border: 1px solid #ccc; display: flex; justify-content: center; align-items: center; /* 为了设置第一个div的中心点，所以这里设置一个定位，让子元素的绝对定位参照该元素进行偏移 */ position: relative; } div:first-child { height: 8px; width: 8px; background-color: black; z-index: 1; border-radius: 50%; /* 脱离文档流并居中 */ position: absolute; left: 50%; top: 50%; margin-left: -4px; margin-top: -4px; } div:last-child { height: 100px; width: 100px; background-color: blueviolet; /* 过渡时间1s,应该放这里，而不是:hover上面 */ /* transition: 1s; */ } div:last-child:hover { transform: translateX(100px); } 移动元素 沿X轴移动时正值向右移动、负值向左移动 沿Y轴移动时正值向下移动、负值向上移动 如果使用百分数将控制元素的原尺寸计算百分比然后移动 可同时设置多个值，解析器会从左向右依次执行 变形是在原基础上更改，即第二次设置值时不是在第一次值上变化 translateX 控制元素在X轴上的移动，正值向右、负值向左。 如，我们下面设置translateX(100px)，过渡时间为1s。 代码示例： Document * { padding: 0; margin: 0; list-style: none; box-sizing: border-box; } body { width: 100vw; height: 100vh; display: flex; justify-content: center; align-items: center; } main { width: 400px; height: 200px; border: 1px solid #ccc; display: flex; justify-content: center; align-items: center; /* 为了设置第一个div的中心点，所以这里设置一个定位，让子元素的绝对定位参照该元素进行偏移 */ position: relative; } div:first-child { height: 8px; width: 8px; background-color: black; z-index: 1; border-radius: 50%; /* 脱离文档流并居中 */ position: absolute; left: 50%; top: 50%; margin-left: -4px; margin-top: -4px; } div:last-child { height: 100px; width: 100px; background-color: blueviolet; /* 过渡时间1s,应该放这里，而不是:hover上面 */ transition: 1s; } div:last-child:hover { transform: translateX(100px); } translateY 控制元素在X轴上的移动，正值向下、负值向上。 如，我们下面设置translateY(100px)，过渡时间为1s。 代码示例： Document * { padding: 0; margin: 0; list-style: none; box-sizing: border-box; } body { width: 100vw; height: 100vh; display: flex; justify-content: center; align-items: center; } main { width: 200px; height: 400px; border: 1px solid #ccc; display: flex; justify-content: center; align-items: center; /* 为了设置第一个div的中心点，所以这里设置一个定位，让子元素的绝对定位参照该元素进行偏移 */ position: relative; } div:first-child { height: 8px; width: 8px; background-color: black; z-index: 1; border-radius: 50%; /* 脱离文档流并居中 */ position: absolute; left: 50%; top: 50%; margin-left: -4px; margin-top: -4px; } div:last-child { height: 100px; width: 100px; background-color: blueviolet; /* 过渡时间1s,应该放这里，而不是:hover上面 */ transition: 1s; } div:last-child:hover { transform: translateY(100px); } translate translate是translateX以及translateY的简写模式，第一个值控制X移动，第二个值控制Y移动。 一句话，设置X与Y轴的移动，注意，这个方法中不包含Z轴，因为一旦有Z轴参与就会变为3D效果。 代码示例： Document * { padding: 0; margin: 0; list-style: none; box-sizing: border-box; } body { width: 100vw; height: 100vh; display: flex; justify-content: center; align-items: center; } main { width: 400px; height: 400px; border: 1px solid #ccc; display: flex; justify-content: center; align-items: center; /* 为了设置第一个div的中心点，所以这里设置一个定位，让子元素的绝对定位参照该元素进行偏移 */ position: relative; } div:first-child { height: 8px; width: 8px; background-color: black; z-index: 1; border-radius: 50%; /* 脱离文档流并居中 */ position: absolute; left: 50%; top: 50%; margin-left: -4px; margin-top: -4px; } div:last-child { height: 100px; width: 100px; background-color: blueviolet; /* 过渡时间1s,应该放这里，而不是:hover上面 */ transition: 1s; } div:last-child:hover { /* 先设置X轴，再设置Y轴 */ transform: translate(100px, 100px); } 百分比移动 当要移动的元素宽高为100px时，如果使用50%进行移动，则代表移动50px。 代码示例： Document * { padding: 0; margin: 0; list-style: none; box-sizing: border-box; } body { width: 100vw; height: 100vh; display: flex; justify-content: center; align-items: center; } main { width: 400px; height: 400px; border: 1px solid #ccc; display: flex; justify-content: center; align-items: center; /* 为了设置第一个div的中心点，所以这里设置一个定位，让子元素的绝对定位参照该元素进行偏移 */ position: relative; } div:first-child { height: 8px; width: 8px; background-color: black; z-index: 1; border-radius: 50%; /* 脱离文档流并居中 */ position: absolute; left: 50%; top: 50%; margin-left: -4px; margin-top: -4px; } div:last-child { height: 100px; width: 100px; background-color: blueviolet; /* 过渡时间1s,应该放这里，而不是:hover上面 */ transition: 1s; } div:last-child:hover { /* 先设置X轴，再设置Y轴 */ transform: translate(50%, 50%); } 元素居中 我们之前介绍过很多元素居中的方法，如定位操作，弹性盒模型，其实使用移动也可以达到元素居中的效果。 给你丢一套模板。 /* 让子元素脱离文档流并参照副父级元素偏移。这是定位+margin的居中方法 */ position: absolute; left: 50%; top: 50%; /* left和top设置子元素宽高的负的50%就行 */ margin-left: -3px; margin-top: -3px; /* 这是弹性盒模型控制元素居中的方法 */ display: flex; justify-content: center; align-items: center; /* 让子元素脱离文档流并参照副父级元素偏移。这是定位+移动的居中方法 */ position: absolute; left: 50%; top: 50%; /* X和Y设置子元素宽高的负的50%就行 */ transform: translate(-50%, -50%); translateZ 控制Z轴移动，正数向外（距离我们近）、负数向里移动（距离我们远）。因为Z轴是透视轴没有像X/Y一样的固定尺寸，所以不能使用百分数。 代码示例： Document * { padding: 0; margin: 0; list-style: none; box-sizing: border-box; } body { width: 100vw; height: 100vh; display: flex; justify-content: center; align-items: center; } main { width: 200px; height: 200px; display: flex; justify-content: center; align-items: center; border: 1px solid #ccc; /* 如果将Z轴移动的:hover放在div上，我们不方便一直将鼠标放在div上面，故我们设置成放在main上面让div进行Z轴移动 */ /* 为了更好的视觉效果，我们给main容器做一个透视 ,并且让它按照Y轴旋转60度，按Z轴放大5倍*/ transform: perspective(900px) rotateY(60deg) scaleZ(5); /* 使用 transform-style 用于控制3d透视 */ transform-style: preserve-3d; } main:hover div:nth-child(2) { transform: translateZ(-100px); } div { height: 100px; width: 100px; background-color: blueviolet; /* 让子元素脱离文档流并参照副父级元素偏移。这是定位+移动的居中方法 */ position: absolute; left: 50%; top: 50%; transform: translate(-50%, -50%); } div:nth-child(1) { background-color: yellow; } div:nth-child(2) { background-color: blueviolet; /* 过渡时间1s */ transition: 1s; } translate3d 用于同时控制X/Y/Z轴的移动，三个值必须输入如果某个轴不需要移动时设置为零。 代码示例： Document * { padding: 0; margin: 0; list-style: none; box-sizing: border-box; } body { width: 100vw; height: 100vh; display: flex; justify-content: center; align-items: center; } main { width: 200px; height: 200px; display: flex; justify-content: center; align-items: center; border: 1px solid #ccc; /* 如果将Z轴移动的:hover放在div上，我们不方便一直将鼠标放在div上面，故我们设置成放在main上面让div进行Z轴移动 */ /* 为了更好的视觉效果，我们给main容器做一个透视 ,并且让它按照Y轴旋转60度，按Z轴放大5倍*/ transform: perspective(900px) rotateY(60deg) scaleZ(5); /* 使用 transform-style 用于控制3d透视 */ transform-style: preserve-3d; } main:hover div:nth-child(2) { /* 由于Z轴可以无限远，所以不能用百分比 */ transform: translate3d(50%, 50%, 100px); } div { height: 100px; width: 100px; background-color: blueviolet; /* 让子元素脱离文档流并参照副父级元素偏移。这是定位+移动的居中方法 */ position: absolute; left: 50%; top: 50%; transform: translate(-50%, -50%); } div:nth-child(1) { background-color: yellow; } div:nth-child(2) { background-color: blueviolet; /* 过渡时间1s */ transition: 1s; } 渐变输入框 代码示例： Document * { padding: 0; margin: 0; list-style: none; box-sizing: border-box; } body { width: 100vw; height: 100vh; display: flex; justify-content: center; align-items: center; background: #34495e; } #form-style-gradient { width: 200px; height: 200px; display: flex; flex-flow: column; justify-content: center; align-items: center; border: 1px solid #ccc; } #form-style-gradient label input { padding: 10px; outline: none; border: none; background-color: #ecf0f1; } #form-style-gradient label { width: 80%; position: relative; overflow: hidden; margin-bottom: 20px; display: flex; flex-flow: column; justify-content: center; align-self: center; } #form-style-gradient label::before { content: ''; position: absolute; /* 移动到最下面 */ left: 0; bottom: 0; height: 2px; width: 100%; background: linear-gradient(to right, white, #1abc9c, #f1c40f, #e74c3c, white); /* 移动到label标签外，然后会被隐藏掉 */ transform: translateX(-100%); transition: 2s; } #form-style-gradient label:hover::before { /* 移动回来 */ transform: translateX(100%); } 页面切换 代码示例： Document * { padding: 0; margin: 0; } a { text-decoration: none; } body { display: flex; width: 100vw; height: 100vh; flex-direction: column; } main { position: relative; background: #f3f3f3; flex: 1; overflow: hidden; } nav { display: flex; justify-content: space-around; align-items: center; height: 8vh; text-align: center; background: #34495e; } nav a { flex: 1; font-size: 1.3em; text-transform: uppercase; font-weight: bold; opacity: .8; color: white; } nav a:nth-child(2) { border-right: solid 1px #aaa; border-left: solid 1px #aaa; } main>div { position: absolute; left: 0; top: 0; width: 100%; height: 100%; transition: all 1s; z-index: 1; background: #f3f3f3; opacity: 0; display: flex; flex-direction: column; justify-content: center; align-items: center; transform: translate(0, -100%); color: white; font-size: 2em; } main>div:target { opacity: 1; transform: translate(0%, 0%); } main>div:nth-of-type(1):target { background: #3498db; } main>div:nth-of-type(2):target { background: #9b59b6; } main>div:nth-of-type(3):target { background: #16a085; } div i[class^=\"fa\"] { font-size: 100px; color: white; } houdunren.com home video live 缩放元素 比如数值为2时表示为原尺寸的两倍。 数值为.5时为原尺寸的一半。 scaleX 按X轴缩放一半。 代码示例： Document * { padding: 0; margin: 0; list-style: none; box-sizing: border-box; } body { width: 100vw; height: 100vh; display: flex; justify-content: center; align-items: center; } main { width: 400px; height: 200px; border: 1px solid #ccc; display: flex; justify-content: center; align-items: center; /* 为了设置第一个div的中心点，所以这里设置一个定位，让子元素的绝对定位参照该元素进行偏移 */ position: relative; } div:first-child { height: 8px; width: 8px; background-color: black; z-index: 1; border-radius: 50%; /* 脱离文档流并居中 */ position: absolute; left: 50%; top: 50%; margin-left: -4px; margin-top: -4px; } div:last-child { height: 100px; width: 100px; background-color: blueviolet; /* 过渡时间1s,应该放这里，而不是:hover上面 */ transition: 1s; } div:last-child:hover { transform: scaleX(.5); } scaleY 按Y轴缩放一半。 代码示例： Document * { padding: 0; margin: 0; list-style: none; box-sizing: border-box; } body { width: 100vw; height: 100vh; display: flex; justify-content: center; align-items: center; } main { width: 200px; height: 400px; border: 1px solid #ccc; display: flex; justify-content: center; align-items: center; /* 为了设置第一个div的中心点，所以这里设置一个定位，让子元素的绝对定位参照该元素进行偏移 */ position: relative; } div:first-child { height: 8px; width: 8px; background-color: black; z-index: 1; border-radius: 50%; /* 脱离文档流并居中 */ position: absolute; left: 50%; top: 50%; margin-left: -4px; margin-top: -4px; } div:last-child { height: 100px; width: 100px; background-color: blueviolet; /* 过渡时间1s,应该放这里，而不是:hover上面 */ transition: 1s; } div:last-child:hover { transform: scaleY(.5); } scale 使用 scale 可同时设置 X/Y 轴的缩放，如果只设置一个值时表示两轴缩放相同。 使用数值定义缩放，如 .5 表示缩小一半，2 表示放大两倍。 代码示例： Document * { padding: 0; margin: 0; list-style: none; box-sizing: border-box; } body { width: 100vw; height: 100vh; display: flex; justify-content: center; align-items: center; } main { width: 200px; height: 400px; border: 1px solid #ccc; display: flex; justify-content: center; align-items: center; /* 为了设置第一个div的中心点，所以这里设置一个定位，让子元素的绝对定位参照该元素进行偏移 */ position: relative; } div:first-child { height: 8px; width: 8px; background-color: black; z-index: 1; border-radius: 50%; /* 脱离文档流并居中 */ position: absolute; left: 50%; top: 50%; margin-left: -4px; margin-top: -4px; } div:last-child { height: 100px; width: 100px; background-color: blueviolet; /* 过渡时间1s,应该放这里，而不是:hover上面 */ transition: 1s; } div:last-child:hover { transform: scale(.5, 2); } scaleZ 沿Z轴缩放元素，需要有3D透视才可以查看到效果。 代码示例： Document * { padding: 0; margin: 0; list-style: none; box-sizing: border-box; } body { width: 100vw; height: 100vh; display: flex; justify-content: center; align-items: center; } main { width: 200px; height: 200px; display: flex; justify-content: center; align-items: center; border: 1px solid #ccc; /* 如果将Z轴移动的:hover放在div上，我们不方便一直将鼠标放在div上面，故我们设置成放在main上面让div进行Z轴移动 */ /* 为了更好的视觉效果，我们给main容器做一个透视 ,并且让它按照Y轴旋转60度，按Z轴放大5倍*/ transform: perspective(900px) rotateY(45deg) scaleZ(5); /* 使用 transform-style 用于控制3d透视 */ transform-style: preserve-3d; } main:hover div:nth-child(2) { /* 放大5倍 */ transform: scaleZ(5); } div { height: 100px; width: 100px; background-color: blueviolet; /* 让子元素脱离文档流并参照副父级元素偏移。这是定位+移动的居中方法 */ position: absolute; left: 50%; top: 50%; transform: translate(-50%, -50%); } div:nth-child(1) { background-color: yellow; } div:nth-child(2) { background-color: blueviolet; /* 过渡时间1s */ transition: 1s; transform: translateZ(100px); } scale3d 沿X/Y/Z三个轴缩放元素。 代码示例： Document * { padding: 0; margin: 0; list-style: none; box-sizing: border-box; } body { width: 100vw; height: 100vh; display: flex; justify-content: center; align-items: center; } main { width: 200px; height: 200px; display: flex; justify-content: center; align-items: center; border: 1px solid #ccc; /* 如果将Z轴移动的:hover放在div上，我们不方便一直将鼠标放在div上面，故我们设置成放在main上面让div进行Z轴移动 */ /* 为了更好的视觉效果，我们给main容器做一个透视 ,并且让它按照Y轴旋转60度，按Z轴放大5倍*/ transform: perspective(900px) rotateY(45deg) scaleZ(5); /* 使用 transform-style 用于控制3d透视 */ transform-style: preserve-3d; } main:hover div:nth-child(2) { /* 放大5倍 */ transform: scale3d(.5, .5, .5); } div { height: 100px; width: 100px; background-color: blueviolet; /* 让子元素脱离文档流并参照副父级元素偏移。这是定位+移动的居中方法 */ position: absolute; left: 50%; top: 50%; transform: translate(-50%, -50%); } div:nth-child(1) { background-color: yellow; } div:nth-child(2) { background-color: blueviolet; /* 过渡时间1s */ transition: 1s; transform: translateZ(100px); } 菜单缩放 代码示例： Document * { margin: 0; padding: 0; list-style: none; box-sizing: border-box; text-decoration: none; } body { height: 100vh; width: 100vw; display: flex; flex-flow: column; justify-content: center; align-items: center; } main { width: 100px; } div i { display: inline-block; background: darkgray; font-size: 30px !important; display: flex; justify-content: center; align-items: center; } ul { display: flex; flex-flow: column; justify-content: center; align-items: center; border: 1px solid #ddd; text-transform: uppercase; /* 基点设置为左上 */ transform-origin: left top; /* 鼠标放上去有个小手 */ cursor: pointer; /* 透明度 */ opacity: .6; transform: scale(0); transition: 1s; } ul>* { margin: 3px; } main:hover ul { transform: scale(1); } 我的资料 我的关注 我的收藏 相册放大 代码示例： Document * { margin: 0; padding: 0; list-style: none; box-sizing: border-box; text-decoration: none; } body { height: 100vh; width: 100vw; display: flex; justify-content: center; align-items: center; background-color: deepskyblue; } img { height: 100px; /* 高斯模糊 */ filter: blur(10px); transform: scale(.6); transition: .5s; /* 鼠标小手 */ cursor: pointer; border: 3px double black; } img:hover { filter: none; transform: scale(1.3); } 旋转元素 使用CSS可以控制元素按照不同坐标轴进行旋转。 rotateX 控制元素按照X轴进行旋转操作。单位为deg，即°度的意思。 按水平轴发生旋转，如果旋转90deg 将不可见。 正数向上翻，负数向下翻。 如何让他可见呢？我们只需要将父级容器也旋转一下，并加上透视3D效果即可。 代码示例： Document * { padding: 0; margin: 0; list-style: none; box-sizing: border-box; } body { width: 100vw; height: 100vh; display: flex; justify-content: center; align-items: center; } main { width: 400px; height: 200px; border: 1px solid #ccc; display: flex; justify-content: center; align-items: center; /* 使用 transform-style 用于控制3d透视 */ transform-style: preserve-3d; /* 为了更好的视觉效果，我们给main容器做一个透视 ,并且让它按照X轴旋转-45度 */ transform: perspective(900px) rotateX(-45deg); /* 为了设置第一个div的中心点，所以这里设置一个定位，让子元素的绝对定位参照该元素进行偏移 */ position: relative; } div { height: 100px; width: 150px; background-color: blueviolet; display: flex; justify-content: center; align-items: center; color: #fff; font-size: 14px; /* 过渡时间1s,应该放这里，而不是:hover上面 */ transition: 1s; } div:hover { transform: rotateX(90deg); } 将按照X轴旋转90deg rotateY 按垂直轴发生旋转，如果旋转90deg 将不可见。 正数向右翻，负数向左翻。 代码示例： Document * { padding: 0; margin: 0; list-style: none; box-sizing: border-box; } body { width: 100vw; height: 100vh; display: flex; justify-content: center; align-items: center; } main { width: 400px; height: 200px; border: 1px solid #ccc; display: flex; justify-content: center; align-items: center; /* 为了设置第一个div的中心点，所以这里设置一个定位，让子元素的绝对定位参照该元素进行偏移 */ position: relative; } div { height: 100px; width: 150px; background-color: blueviolet; display: flex; justify-content: center; align-items: center; color: #fff; font-size: 14px; /* 过渡时间1s,应该放这里，而不是:hover上面 */ transition: 1s; } div:hover { transform: rotateY(90deg); } 将按照Y轴旋转90deg rotateZ 按Z轴旋转元素，效果就是沿X/Y轴的平面旋转。 代码示例： Document * { padding: 0; margin: 0; list-style: none; box-sizing: border-box; } body { width: 100vw; height: 100vh; display: flex; justify-content: center; align-items: center; } main { width: 400px; height: 200px; border: 1px solid #ccc; display: flex; justify-content: center; align-items: center; /* 使用 transform-style 用于控制3d透视 */ transform-style: preserve-3d; /* 为了更好的视觉效果，我们给main容器做一个透视 ,并且让它按照X轴旋转-45度 */ transform: perspective(900px) rotateX(-45deg); /* 为了设置第一个div的中心点，所以这里设置一个定位，让子元素的绝对定位参照该元素进行偏移 */ position: relative; } div { height: 100px; width: 150px; background-color: blueviolet; display: flex; justify-content: center; align-items: center; color: #fff; font-size: 14px; /* 过渡时间1s,应该放这里，而不是:hover上面 */ transition: 1s; } div:hover { transform: rotateZ(90deg); } 将按照Z轴旋转90deg rotate 在X与Y轴平面旋转，效果与使用 rotateZ 相同。 代码示例： Document * { padding: 0; margin: 0; list-style: none; box-sizing: border-box; } body { width: 100vw; height: 100vh; display: flex; justify-content: center; align-items: center; } main { width: 400px; height: 200px; border: 1px solid #ccc; display: flex; justify-content: center; align-items: center; /* 使用 transform-style 用于控制3d透视 */ transform-style: preserve-3d; /* 为了更好的视觉效果，我们给main容器做一个透视 ,并且让它按照X轴旋转-45度 */ transform: perspective(900px) rotateX(-45deg); /* 为了设置第一个div的中心点，所以这里设置一个定位，让子元素的绝对定位参照该元素进行偏移 */ position: relative; } div { height: 100px; width: 150px; background-color: blueviolet; display: flex; justify-content: center; align-items: center; color: #fff; font-size: 14px; /* 过渡时间1s,应该放这里，而不是:hover上面 */ transition: 1s; } div:hover { transform: rotate(90deg); } 将按照Z轴旋转90deg rotate3d 同时设置X/Y/Z轴的旋转向量值来控制元素的旋转。 需要同时设置如下四个参数。 这个是按照向量进行旋转的，比如第四个参数是90deg，那么前三个参数填1就代表各转90°。 rotate3d(tx,ty,tz,angle) 1）只转X/Y轴 2）只转Y/Z轴 3）X/Y/Z都转 代码示例： Document * { padding: 0; margin: 0; list-style: none; box-sizing: border-box; } body { width: 100vw; height: 100vh; display: flex; justify-content: center; align-items: center; } main { width: 400px; height: 200px; border: 1px solid #ccc; display: flex; justify-content: center; align-items: center; /* 使用 transform-style 用于控制3d透视 */ transform-style: preserve-3d; /* 为了更好的视觉效果，我们给main容器做一个透视 ,并且让它按照X轴旋转-45度 */ transform: perspective(900px) rotateX(-45deg); /* 为了设置第一个div的中心点，所以这里设置一个定位，让子元素的绝对定位参照该元素进行偏移 */ position: relative; } div { height: 100px; width: 150px; background-color: blueviolet; display: flex; justify-content: center; align-items: center; color: #fff; font-size: 14px; /* 过渡时间1s,应该放这里，而不是:hover上面 */ transition: 1s; } div:hover { /* X/Y/Z */ transform: rotate3d(1, 1, 1, 180deg); } X/Y/Z 180° 参数顺序 可以同时设置多个旋转规则，顺序不同结果也会不同。 如下，先按X轴转90，再按Y轴转60 div:hover { transform: rotateX(90deg) rotateY(60deg); } 代码示例： Document * { padding: 0; margin: 0; list-style: none; box-sizing: border-box; } body { width: 100vw; height: 100vh; display: flex; justify-content: center; align-items: center; } main { width: 400px; height: 200px; border: 1px solid #ccc; display: flex; justify-content: center; align-items: center; /* 使用 transform-style 用于控制3d透视 */ transform-style: preserve-3d; /* 为了更好的视觉效果，我们给main容器做一个透视 ,并且让它按照X轴旋转-45度 */ transform: perspective(900px) rotateX(-45deg); /* 为了设置第一个div的中心点，所以这里设置一个定位，让子元素的绝对定位参照该元素进行偏移 */ position: relative; } div { height: 100px; width: 150px; background-color: blueviolet; display: flex; justify-content: center; align-items: center; color: #fff; font-size: 14px; /* 过渡时间1s,应该放这里，而不是:hover上面 */ transition: 1s; } div:hover { transform: rotateX(90deg) rotateY(60deg); } X 90° Y 60° 旋转文字 代码示例： Document * { margin: 0; padding: 0; list-style: none; box-sizing: border-box; } body { height: 100vh; width: 100vw; display: flex; justify-content: center; align-items: center; } main { width: 100px; height: 100px; display: flex; flex-flow: column; justify-content: center; align-items: center; background-color: blueviolet; } main p { display: flex; justify-content: center; align-items: center; color: white; } main p span { width: 50%; height: 50%; padding: 5px; font-size: 1em; box-shadow: 0 2px 10px rgba(0, 0, 0, .3); border-radius: 50%; /* 过渡时间 */ transition: 1s; display: flex; justify-content: center; align-items: center; } main p span:first-of-type { color: green; background-color: yellow; } main p span:nth-of-type(2) { color: yellow; background-color: green; } main p span:nth-of-type(3) { color: white; background-color: deeppink; } main p span:last-of-type { color: red; background-color: rgb(140, 173, 155); } main:hover p span:nth-of-type(odd) { transform: rotate(360deg); } main:hover p span:nth-of-type(even) { transform: rotate(-360deg); } CSS 3 动画 电子时钟 这个层级有点多，每个刻度都是一个元素，每个刻度之间距离都是30°，然后再加上3根针就好了。 其实应该分四层，一层做事件驱动，一层做最下面的黑色背景，一层做红色下面的指针，一层做红色。 我就做了三层，所以事件驱动就只能放在\\上了。 样式有点丑，别介意... 代码示例： Document * { margin: 0; padding: 0; box-sizing: border-box; list-style: none; } body { height: 100vh; width: 100vw; display: flex; justify-content: center; align-items: center; } main { height: 400px; width: 400px; background-color: #000; border-radius: 50%; position: relative; } main div { height: 5%; width: 5%; background-color: green; border-radius: 50%; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); z-index: 3; } main ul:nth-of-type(1) { height: 80%; width: 80%; background-color: red; border-radius: 50%; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); z-index: 2; } main ul:nth-of-type(1) li { background-color: #fff; position: absolute; top: 50%; left: 50%; /* 全部按照上方开始转 */ transform-origin: top; transition: 10s; } body:hover main ul:nth-of-type(1) li:nth-child(1) { transform: rotate(360deg) } main ul:nth-of-type(1) li:nth-child(1) { /* 秒针 */ width: 5px; height: 46%; } main ul:nth-of-type(1) li:nth-child(2) { /* 分针 */ width: 5px; height: 40%; transform: rotate(10deg); } main ul:nth-of-type(1) li:nth-child(3) { /* 分针 */ width: 10px; height: 30%; transform: rotate(60deg); } main ul:nth-of-type(2) { height: 95%; width: 90%; border-radius: 50%; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); z-index: 1; } main ul:nth-of-type(2) li { width: 10px; height: 100%; background-color: #fff; position: absolute; top: 50%; left: 50%; } main ul:nth-of-type(2) li:nth-child(1) { /* 由于不会叠加，所以我们需要在每个元素中设置 */ transform: translate(-50%, -50%) rotate(0deg); } main ul:nth-of-type(2) li:nth-child(2) { transform: translate(-50%, -50%) rotate(30deg); } main ul:nth-of-type(2) li:nth-child(3) { transform: translate(-50%, -50%) rotate(60deg); } main ul:nth-of-type(2) li:nth-child(4) { transform: translate(-50%, -50%) rotate(90deg); } main ul:nth-of-type(2) li:nth-child(5) { transform: translate(-50%, -50%) rotate(120deg); } main ul:nth-of-type(2) li:nth-child(6) { transform: translate(-50%, -50%) rotate(150deg); } 倾斜元素 倾斜元素的单位也是deg，即为度数°。 skewX 按X轴倾斜60deg 代码示例： Document * { padding: 0; margin: 0; list-style: none; box-sizing: border-box; } body { width: 100vw; height: 100vh; display: flex; justify-content: center; align-items: center; } main { width: 400px; height: 200px; border: 1px solid #ccc; display: flex; justify-content: center; align-items: center; /* 为了设置第一个div的中心点，所以这里设置一个定位，让子元素的绝对定位参照该元素进行偏移 */ position: relative; } div:first-child { height: 8px; width: 8px; background-color: black; z-index: 1; border-radius: 50%; /* 脱离文档流并居中 */ position: absolute; left: 50%; top: 50%; margin-left: -4px; margin-top: -4px; } div:last-child { height: 100px; width: 100px; background-color: blueviolet; /* 过渡时间1s,应该放这里，而不是:hover上面 */ transition: 1s; } div:last-child:hover { transform: skewX(60deg); } skewY 按Y轴倾斜60deg 代码示例： Document * { padding: 0; margin: 0; list-style: none; box-sizing: border-box; } body { width: 100vw; height: 100vh; display: flex; justify-content: center; align-items: center; } main { width: 200px; height: 400px; border: 1px solid #ccc; display: flex; justify-content: center; align-items: center; /* 为了设置第一个div的中心点，所以这里设置一个定位，让子元素的绝对定位参照该元素进行偏移 */ position: relative; } div:first-child { height: 8px; width: 8px; background-color: black; z-index: 1; border-radius: 50%; /* 脱离文档流并居中 */ position: absolute; left: 50%; top: 50%; margin-left: -4px; margin-top: -4px; } div:last-child { height: 100px; width: 100px; background-color: blueviolet; /* 过渡时间1s,应该放这里，而不是:hover上面 */ transition: 1s; } div:last-child:hover { transform: skewY(60deg); } skew 同时设置X/Y轴倾斜操作，不指定第二个参数时Y轴倾斜为零。 代码示例： Document * { padding: 0; margin: 0; list-style: none; box-sizing: border-box; } body { width: 100vw; height: 100vh; display: flex; justify-content: center; align-items: center; } main { width: 400px; height: 400px; border: 1px solid #ccc; display: flex; justify-content: center; align-items: center; /* 为了设置第一个div的中心点，所以这里设置一个定位，让子元素的绝对定位参照该元素进行偏移 */ position: relative; } div:first-child { height: 8px; width: 8px; background-color: black; z-index: 1; border-radius: 50%; /* 脱离文档流并居中 */ position: absolute; left: 50%; top: 50%; margin-left: -4px; margin-top: -4px; } div:last-child { height: 100px; width: 100px; background-color: blueviolet; /* 过渡时间1s,应该放这里，而不是:hover上面 */ transition: 1s; } div:last-child:hover { transform: skew(60deg, 60deg); } 按钮特效 代码示例： Document * { padding: 0; margin: 0; list-style: none; box-sizing: border-box; } body { width: 100vw; height: 100vh; display: flex; justify-content: center; align-items: center; } div { display: flex; justify-content: center; align-items: center; padding: 10px 50px; border: 5px double #ddd; box-shadow: 0 3px 8px rgba(0, 0, 0, .3); background: #fa7d09; color: #fff; cursor: pointer; position: relative; overflow: hidden; z-index: 0; } div::before { content: \"\"; background: #679b9b; height: 100%; position: absolute; /* 必须设置宽度，倾斜才会生效 */ width: 0; align-self: center; transform: skewX(-45deg); transition: all .8s; z-index: -1; } div:hover::before { width: 200%; } 按钮 立体按钮 代码示例： Document * { padding: 0; margin: 0; list-style: none; box-sizing: border-box; text-decoration: none; } body { width: 100vw; height: 100vh; display: flex; justify-content: center; align-items: center; } a { width: 100px; height: 30px; font-size: 12px; background: #900d0d; color: white; text-align: center; line-height: 30px; position: relative; transform: skew(25deg, 0) rotate(-15deg); } a::after { content: \"\"; background: #900d0d; height: 100%; width: 10px; position: absolute; left: -10px; transform: skew(0, -45deg) translate(0, 5px); } a::before { content: \"\"; background: #900d0d; height: 10px; width: 100%; position: absolute; bottom: -10px; left: 0; transform: skew(-45deg, 0) translate(-5px, 0); } 一砖下去可能要命 变形基点 使用 transform-origin 设置元素的X/YZ操作的基点，用于控制旋转、倾斜等操作。 可以使用百分比，也可使用英文单词进行修改。 百分比是按照变形元素的宽高进行取值。 旋转默认以元素中心进行旋转，改变基点后可控制旋转点位置 元素移动不受变形基点所影响 平面旋转 transform-origin: bottom right;将基点改在右下。 代码示例： Document * { padding: 0; margin: 0; list-style: none; box-sizing: border-box; } body { width: 100vw; height: 100vh; display: flex; justify-content: center; align-items: center; } main { width: 400px; height: 200px; border: 1px solid #ccc; display: flex; justify-content: center; align-items: center; /* 使用 transform-style 用于控制3d透视 */ transform-style: preserve-3d; /* 为了更好的视觉效果，我们给main容器做一个透视 ,并且让它按照X轴旋转-45度 */ transform: perspective(900px) rotateX(-45deg); /* 为了设置第一个div的中心点，所以这里设置一个定位，让子元素的绝对定位参照该元素进行偏移 */ position: relative; } div { height: 100px; width: 220px; background-color: blueviolet; display: flex; justify-content: center; align-items: center; color: #fff; font-size: 14px; /* 过渡时间1s,应该放这里，而不是:hover上面 */ transition: 1s; /* 修改基点 */ transform-origin: bottom right; } main:hover div { transform: rotate(90deg); } 将按照Z轴旋转90deg 基点在右下 倾斜控制 我们依然按照右下进行倾斜。 代码示例： Document * { padding: 0; margin: 0; list-style: none; box-sizing: border-box; } body { width: 100vw; height: 100vh; display: flex; justify-content: center; align-items: center; } main { width: 400px; height: 200px; border: 1px solid #ccc; display: flex; justify-content: center; align-items: center; /* 为了设置第一个div的中心点，所以这里设置一个定位，让子元素的绝对定位参照该元素进行偏移 */ position: relative; } div:first-child { height: 8px; width: 8px; background-color: black; z-index: 1; border-radius: 50%; /* 脱离文档流并居中 */ position: absolute; left: 50%; top: 50%; margin-left: -4px; margin-top: -4px; } div:last-child { height: 100px; width: 100px; background-color: blueviolet; /* 过渡时间1s,应该放这里，而不是:hover上面 */ transition: 1s; /* 基点改在右下 */ transform-origin: bottom right; } div:last-child:hover { transform: skewX(60deg); } 三维旋转 三维旋转需要新增Y轴的基点，还是老规矩，Y轴的基点不能使用百分比。 代码示例： Document * { padding: 0; margin: 0; list-style: none; box-sizing: border-box; } body { width: 100vw; height: 100vh; display: flex; justify-content: center; align-items: center; } main { width: 400px; height: 200px; border: 1px solid #ccc; display: flex; justify-content: center; align-items: center; /* 使用 transform-style 用于控制3d透视 */ transform-style: preserve-3d; /* 为了更好的视觉效果，我们给main容器做一个透视 ,并且让它按照X轴旋转-45度 */ transform: perspective(900px) rotateX(-45deg); /* 为了设置第一个div的中心点，所以这里设置一个定位，让子元素的绝对定位参照该元素进行偏移 */ position: relative; } div { height: 100px; width: 210px; background-color: blueviolet; display: flex; justify-content: center; align-items: center; color: #fff; font-size: 14px; /* 过渡时间2s,应该放这里，而不是:hover上面 */ transition: 2s; /* 基点 */ transform-origin: right center 100px; } main:hover div { /* X/Y/Z */ transform: rotate3d(1, 1, 1, 720deg); } X right/Y center/Z 100px 720° 新年贺卡 使用变形基点，然后加上旋转元素即可。 代码示例： Document * { padding: 0; margin: 0; list-style: none; box-sizing: border-box; } body { width: 100vw; height: 100vh; display: flex; justify-content: center; align-items: center; } div { width: 200px; height: 150px; background: #fa7d09; display: flex; justify-content: center; align-items: center; color: #fff; font-size: 25px; position: relative; transform-style: preserve-3d; transform: perspective(600px) rotateX(35deg) rotateY(15deg); } div:after { content: \"新年\"; height: 100%; width: 50%; position: absolute; background-color: #fa1616; left: 0; transition: 1s; transform-origin: center left; display: flex; justify-content: flex-end; align-items: center; } div:before { content: \"快乐\"; height: 100%; width: 50%; position: absolute; background-color: #fa1616; right: 0; transition: 1s; transform-origin: center right; display: flex; justify-content: flex-start; align-items: center; } div:hover::before { transform: rotateY(180deg); } div:hover::after { transform: rotateY(-180deg); } 祝你年年有余 动感菜单 这个应该是最难的一个了，那么首先我们要有一个大圆。 鼠标放上去之后所有的小圆跟随大圆的中心点旋转转出来，然后小圆也进行旋转，围绕自身的中心点。 代码示例： Document * { padding: 0; margin: 0; list-style: none; } body { display: flex; justify-content: center; align-items: center; width: 100vw; height: 100vh; } nav { width: 400px; height: 400px; display: flex; justify-content: center; align-items: center; cursor: pointer; } nav::before { content: \"\"; background: #e74c3c; border-radius: 50%; width: 200px; height: 200px; position: absolute; box-shadow: 3px 3px 0px #34495e; } nav::after { content: \"点我\"; background: #e74c3c; border-radius: 50%; width: 200px; height: 200px; display: flex; justify-content: center; align-items: center; position: absolute; font-size: 3em; color: #fff; } nav:hover ul { transform: scale(1); } ul { transition: .5s; transform: scale(0); width: 300px; height: 300px; border-radius: 50%; } ul li { width: 80px; height: 80px; background: #e49; border-radius: 50%; position: absolute; display: flex; justify-content: center; align-items: center; font-size: 2em; color: #fff; transition: 1s; transform-origin: 150px 150px; } ul li span { display: flex; justify-content: center; align-items: center; transition: 1s; } ul li span i { font-size: 1.6em !important; } nav:hover li:nth-of-type(1) { transform: rotate(60deg); } nav:hover li:nth-of-type(2) { transform: rotate(120deg); } nav:hover li:nth-of-type(3) { transform: rotate(180deg); } nav:hover li:nth-of-type(4) { transform: rotate(240deg); } nav:hover li:nth-of-type(5) { transform: rotate(300deg); } nav:hover li:nth-of-type(6) { transform: rotate(360deg); } /* 解决小图标倾斜 */ nav:hover li:nth-of-type(1) span { transform: rotate(300deg); } nav:hover li:nth-of-type(2) span { transform: rotate(600deg); } nav:hover li:nth-of-type(3) span { transform: rotate(900deg); } nav:hover li:nth-of-type(4) span { transform: rotate(1200deg); } nav:hover li:nth-of-type(5) span { transform: rotate(1500deg); } nav:hover li:nth-of-type(6) span { transform: rotate(1800deg); } 透视景深 perspective 使用 perspective 来控制元素的透视景深 perspective 规则为舞台元素控制景深， perspective 属性为控制单个元素 舞台透视 perspective 规则用于将父级整个做为透视元素，会造成里面的每个子元素的透视是不一样的。就像现实中摆一排杯子，是使用统一透视的，每个杯子的透视不一样，造成有大有小。 代码示例： Document * { padding: 0; margin: 0; list-style: none; } body { display: flex; justify-content: center; align-items: center; width: 100vw; height: 100vh; } main { width: 400px; height: 200px; /* 给整个台子做透视 */ perspective: 200px; position: relative; border: solid 5px silver; display: flex; justify-content: center; align-items: center; } main div { width: 50%; height: 50%; background-color: blueviolet; display: flex; justify-content: center; align-items: center; color: #fff; margin: 20px; transform: rotateY(60deg); } 车1 车2 单独透视 perspective 函数用于为元素设置单独透视，下面是为元素单独设置透视参数，每个元素的透视效果是一样的。 代码示例： Document * { padding: 0; margin: 0; list-style: none; } body { display: flex; justify-content: center; align-items: center; width: 100vw; height: 100vh; } main { width: 400px; height: 200px; position: relative; border: solid 5px silver; display: flex; justify-content: center; align-items: center; } main div { width: 50%; height: 50%; background-color: blueviolet; display: flex; justify-content: center; align-items: center; color: #fff; margin: 20px; /* 给每个车做透视，现在每辆车都以相同的角度对着你 */ transform: perspective(100px) rotateY(60deg); } 车1 车2 立方体 代码示例： Document * { padding: 0; margin: 0; box-sizing: border-box; list-style: none; } body { background: #34495e; } main { position: absolute; left: 50%; top: 50%; width: 200px; height: 200px; transform-style: preserve-3d; transform-origin: 50% 50% 50px; transform: translate(-50%, -50%) rotateY(0deg); transition: 2s; } main:hover { transform: translate(-50%, -50%) rotate3d(1, 1, 0, 180deg); } div { position: absolute; width: 200px; height: 200px; background: #000; display: flex; justify-content: center; align-items: center; font-size: 4em; } div:nth-child(1) { transform-origin: right; background: #1abc9c; transform-origin: bottom; transform: translateY(-200px) rotateX(-90deg); opacity: .8; } div:nth-child(2) { transform-origin: right; background: #27ae60; transform-origin: top; transform: translateY(200px) rotateX(90deg); opacity: .8; } div:nth-child(3) { transform-origin: bottom; background: #e67e22; transform-origin: right; transform: translateX(-200px) rotateY(90deg); opacity: .8; } div:nth-child(4) { transform-origin: top; background: #8e44ad; transform-origin: left; transform: translateX(200px) rotateY(-90deg); opacity: .8; } div:nth-child(5) { transform-origin: left bottom; background: #ecf0f1; opacity: .8; } div:nth-child(6) { transform-origin: left bottom; background: #ecf0f1; opacity: .5; transform: translateZ(200px); } 1 2 3 4 5 6 3D透视 transform-style 使用 transform-style 用于控制3d透视。 应用于舞台即变形元素的父级元素 设置 overflow:visible 时 preserve-3d 才无效 选项 描述 flat 2D平面舞台 preserve-3d 3D透视舞台 三维图集 代码示例： Document body { background: #34495e; } main { position: absolute; width: 400px; height: 200px; left: 50%; top: 50%; transform-style: preserve-3d; transform-origin: center center -300px; transform: translate(-50%, -50%) rotateX(-45deg); transition: 2s; } body:hover main { transform: translate(-50%, -50%) rotateX(-45deg) rotateY(900deg); } div { position: absolute; width: 100%; height: 100%; transform-origin: center center -300px; overflow: hidden; background: content-box; padding: 10px; opacity: .5; } div:nth-child(1) { background-color: #ade498; transform: rotateY(60deg); } div:nth-child(2) { background-color: #d3de32; transform: rotateY(120deg); } div:nth-child(3) { background-color: #ffffdd; transform: rotateY(180deg); } div:nth-child(4) { background-color: #006a71; transform: rotateY(240deg); } div:nth-child(5) { background-color: #fe91ca; transform: rotateY(300deg); } div:nth-child(6) { background-color: #cffe0f; transform: rotateY(360deg); } 观看视角 perspective-origin perspective-origin用于控制视线的落点，就像我们眼睛看物体时的聚焦点。可以理解眼镜看物体的位置，比如看一台汽车，是在看车头左边看还是车头右边看。 需要设置 perspective 透视后才可以看到效果。 一般设置在舞台元素上来控制子元素 取值 说明 x-axis 定义该视图在 x 轴上的位置。默认值：50%。可能的值：left、center、right、length、% y-axis 定义该视图在 y 轴上的位置。默认值：50%。可能的值：top、center、bottom、length、% 隐藏背面 backface-visibility 使用 backface-visibility 用于控制是否可以看到元素的背面。 一般设置在元素上而不是舞台元素上 需要舞台元素（父级元素）设置 transform-style: preserve-3d 选项 说明 visible 背面可见 hidden 背面隐藏 翻转卡片 下面使用隐藏背面与透视技术制作的翻转卡片效果。 代码示例： Document * { padding: 0; margin: 0; box-sizing: border-box; } main { position: absolute; width: 100vw; height: 100vh; transition: 2s; transform-style: preserve-3d; } main.login { transform: perspective(900px) rotateY(0deg); } main.register { transform: perspective(900px) rotateY(180deg); } div { position: absolute; width: 100%; height: 100%; font-size: 5em; display: flex; flex-direction: column; justify-content: center; align-items: center; backface-visibility: hidden; transition: 2s; text-transform: uppercase; color: white; } div span { text-transform: lowercase; letter-spacing: .2em; font-size: .2em; color: #2c3e50; } div:nth-child(1) { background: #2ecc71; transform: rotateY(0deg); } div:nth-child(2) { background: #e74c3c; transform: rotateY(180deg); } nav { position: absolute; width: 100%; height: 100%; z-index: 99; text-align: center; display: flex; align-items: flex-end; justify-content: center; padding-bottom: 30px; } nav a { padding: 10px; text-decoration: none; font-size: 1em; background: #000; color: white; margin-right: 10px; cursor: pointer; left: 0; top: 0; } login houdunren.com register houdunren.com 登录 注册 function change(t) { switch (t) { case 'login': $(\"main\").removeClass().addClass('login'); break; case 'register': $(\"main\").removeClass().addClass('register'); break; } } Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-07-20 08:19:08 "},"前端专栏/CSS/过渡时间.html":{"url":"前端专栏/CSS/过渡时间.html","title":"过渡时间","keywords":"","body":"过渡时间 基础知识 在了解CSS过渡时间之前，你应该先了解一下CSS的变形动画，可以参考之前的一篇博客。 我们的元素在属性发生变化时，如果没有特地的为它设置过渡时间，整个变化过程其实是以毫秒级别进行的，过程非常快，肉眼不易察觉。 故我们要学习CSS过渡时间，来让它的变化过程更加平滑。 动画属性 不是所有css属性都有过渡效果，查看支持动画的CSS属性 ，一般来讲有中间值的属性都可以设置动画如宽度、透明度等。 可以看一下下面这个例子，比如边框的样式就不支持过渡效果，而其他的诸如背景颜色，高度宽度等等都是支持过渡效果的。 可以看到，在鼠标放上去的瞬间，边框的样式就发生变化了，而不是再跟随过渡时间进行渐变。 而其他的属性，诸如背景颜色，圆角等都是跟随过渡时间进行渐变的。 代码示例： Document * { margin: 0; padding: 0; } body { display: flex; justify-content: center; align-items: center; height: 100vh; width: 100vw; } div { height: 50px; width: 50px; background: #747d8c; border: 10px solid #ff6348; /* 添加过渡时间 1s */ transition: 1s; } body:hover div { background: #5352ed; border: 10px dotted #ffa502; width: 100px; height: 100px; border-radius: 50%; transform: translate(100px, 100px); } 元素状态 初始形态 指当页面加载后的样式状态，下面是表单设置的初始样式。 变化形态 指元素由初始状态变化后的状态，比如鼠标放上、表单获得焦点后的形态。 代码示例： Document * { padding: 0; margin: 0; } body { background: #2c3e50; display: flex; flex-direction: column; justify-content: center; align-items: center; box-sizing: border-box; width: 100vw; height: 100vh; • padding: 20px; } input { border: solid 5px #e67e22; height: 60px; width: 400px; margin-bottom: 20px; transition: 2s; } input:hover { border: solid 5px #000 !important; } input:focus { background: #e67e22; } input:checked { position: relative; width: 60px; height: 60; border: none; } input:checked::before { content: '⩗'; color: white; display: flex; justify-content: center; align-items: center; font-size: 3em; position: absolute; left: 0; top: 0; right: 0; bottom: 0; box-sizing: border-box; background: #3498db; } 过渡效果 transition-property 用于设置哪些属性应用过渡效果。 默认值为all即所有属性都发生过渡效果 多个属性使用逗号分隔 当我们使用该选项时，注意要和transition-duration搭配使用才能生效，这个才是非简写的过渡时间。 transition只是一种简写形式，如果使用transition-duration与transition进行搭配使用，则不会生效transition-duration。 属性设置 注意看，下面的这张图片里transition-duration只设置了圆角与透明度，其他的诸如宽度高度背景颜色等均未设置，所以在鼠标放上去的一瞬间未设置的属性立刻产生了变化，而圆角和透明度是随着过渡时间渐渐变化的。 代码示例： Document * { margin: 0; padding: 0; box-sizing: border-box; } body { display: flex; justify-content: center; align-items: center; width: 100vw; height: 100vh; } main { width: 400px; height: 400px; display: flex; justify-content: center; align-items: center; } div { width: 100px; height: 100px; background: #f39c12; transition-property: border-radius, opacity; /* 这个才是真正的设置过渡时间， transition只是简写形式 */ transition-duration: 1s; opacity: .5; } main:hover div { border-radius: 50%; width: 150px; height: 150px; background: #2ecc71; opacity: 1; } 禁用属性 当设置transition-property:none;后，所有的变化形态均不会跟随过渡时间发生变化。 也就是说全部都是瞬发完成。 代码示例： Document * { margin: 0; padding: 0; box-sizing: border-box; } body { display: flex; justify-content: center; align-items: center; width: 100vw; height: 100vh; } main { width: 400px; height: 400px; display: flex; justify-content: center; align-items: center; } div { width: 100px; height: 100px; background: #f39c12; transition-property: none; /* 这个才是真正的设置过渡时间， transition只是简写形式 */ transition-duration: 1s; opacity: .5; } main:hover div { border-radius: 50%; width: 150px; height: 150px; background: #2ecc71; opacity: 1; } 结束事件 transitionend 用于控制过渡结束后执行的JS事件，简写属性会触发多次如 border-radius 会触发四次事件，不难理解因为可以为border-bottom-left-radius 等四个属性独立设置过渡，所以就会有四次事件。 属性 说明 propertyName 结束过渡样式 elapsedTime 过渡需要的时间 pseudoElement 过渡的伪元素 isTrusted true:用户触发，false:脚本触发 我们只需要有JS来监听该事件即可，如下图。 当我们检测的\\标签过渡时间结束后触发了transitionend事件，然后才显示出了恭候多时的字样。 　　 代码示例： Document * { margin: 0; padding: 0; box-sizing: border-box; } body { display: flex; justify-content: center; align-items: center; width: 100vw; height: 100vh; background-color: #57606f; } main { width: 400px; height: 400px; display: flex; justify-content: center; align-items: center; } div { width: 100px; height: 100px; background: #f39c12; transition-duration: 1s; position: relative; } div:after { content: \"恭候多时\"; color: #fff; width: 100%; font-size: 1.4em; display: flex; justify-content: center; align-items: center; position: absolute; bottom: -50px; transform: scale(0); transition-duration: 1s; } main:hover div { transform: rotate(360deg); } main:hover div.show-after::after { transform: scale(1) skew(360deg); } // 检测div的 transitionend 事件 document.querySelector('div').addEventListener('transitionend', function (e) { console.log(e); // 给div添加class为show-after document.querySelector('div').className = 'show-after'; }) 此时查看一下浏览器控制台，正好对应上表中的属性。 过渡时间 transition-duration 用于设置过渡时间，需要注意以下几点： 可使用单位为 ms毫秒、s秒 默认值为0s不产生过渡效果 一个值时，所有属性使用同样的时间 二个值时，奇数属性使用第一个，偶数属性使用第二个 变化属性数量大于时间数量时，后面的属性再从第一个时间开始重复使用 统一时间 让所有动画的变形在统一时间内完成： 代码示例： Document * { padding: 0; margin: 0; } body { background: #2c3e50; display: flex; flex-direction: column; justify-content: center; align-items: center; box-sizing: border-box; width: 100vw; height: 100vh; padding: 80px; } main { width: 400px; height: 400px; } div { width: 150px; height: 150px; background-color: #34495e; border-radius: 50%; opacity: 0.2; transition-property: background-color, transform, opacity, border-radius; transition-duration: 3s; } div:hover { opacity: 1; border-radius: 0; transform: scale(2) rotate(180deg); background-color: #e67e22; } 两个时间 下面共有四个属性并设置了两个时间值，1,3属性使用第一个值，2,4属性使用第二个值。 ... div { width: 150px; height: 150px; border-radius: 50%; opacity: 0.2; transition-property: background-color, transform, opacity, border-radius; transition-duration: 200ms, 5s; } ... 多个时间 下面共有四个属性并设置了三个时间值，1,2,3属性使用1,2,3时间值，第四个属性再从新使用第一个时间值。 ... div { width: 150px; height: 150px; border-radius: 50%; opacity: 0.2; transition-property: background-color, transform, opacity, border-radius; transition-duration: 200ms, 5s, 2s; } ... 不同时间 可以为初始与变化状态设置不同的时间。 下面是将hover设置为3s，当鼠标放上时变化时间为3s。 初始设置为1s即表示变化到初始状态需要1s。 代码示例： Document * { padding: 0; margin: 0; } body { background: #2c3e50; display: flex; flex-direction: column; justify-content: center; align-items: center; box-sizing: border-box; width: 100vw; height: 100vh; padding: 80px; } main { width: 400px; height: 400px; } div { width: 150px; height: 150px; background-color: #e67e22; border-radius: 50%; transition-property: background-color, transform, opacity, border-radius; /* 结束时间，变回初始状态 如果只有该时间，则过渡时间也采用它 */ transition-duration: 1s; } div:hover { border-radius: 0; transform: scale(2) rotate(180deg); background-color: #e67e22; /* 过渡时间 */ transition-duration: 3s; } 过渡速率 transition-timing-function 用于设置整体过渡效果的速度，可在 https://cubic-bezier.com 网站在线体验效果差异。 默认参数 以下是常见的transition-timing-function过渡效果： 值 描述 linear 规定以相同速度开始至结束的过渡效果（等于 cubic-bezier(0,0,1,1)） ease 开始慢，然后快，慢下来，结束时非常慢（cubic-bezier(0.25,0.1,0.25,1)）。默认值 ease-in 开始慢，结束快（等于 cubic-bezier(0.42,0,1,1)） ease-out 开始快，结束慢（等于 cubic-bezier(0,0,0.58,1)） ease-in-out 中间快，两边慢（等于 cubic-bezier(0.42,0,0.58,1)） cubic-bezier(n,n,n,n) 在 cubic-bezier 函数中定义自己的值 差异对比 我们用linear和ease来做一个对比，左边是linear，右边是ease。 其实他们的过渡时间都是一模一样的，只是视觉上有所差异。 代码示例： Document * { margin: 0; padding: 0; box-sizing: border-box; } body { height: 100vh; width: 100vw; display: flex; justify-content: center; align-items: center; } main { height: 400px; width: 400px; display: flex; justify-content: center; align-items: center; border: 1px solid #ddd; } main div { height: 100px; width: 100px; margin: 20px; transition-duration: 3s; } main div:nth-child(1) { background-color: #ff4757; transition-timing-function: linear; } main div:nth-child(2) { background-color: #3742fa; transition-timing-function: ease; } main:hover div { width: 150px; height: 150px; border-radius: 50%; } 贝塞尔曲线 其实不管是linear或者是ease都是由贝塞尔曲线来完成的。 我们需要设置四个值 cubic-bezier(\\, \\, \\, \\)来控制曲线速度，可在 https://cubic-bezier.com 网站在线体验效果。 　　如以下是我自己调的一个数值，右边的那个，对比的是linear。 代码示例： Document * { margin: 0; padding: 0; box-sizing: border-box; } body { height: 100vh; width: 100vw; display: flex; justify-content: center; align-items: center; } main { height: 400px; width: 400px; display: flex; justify-content: center; align-items: center; border: 1px solid #ddd; } main div { height: 100px; width: 100px; margin: 20px; transition-duration: 3s; } main div:nth-child(1) { background-color: #ff4757; transition-timing-function: linear; } main div:nth-child(2) { background-color: #3742fa; transition-timing-function: cubic-bezier(.17, .67, .88, -0.47); } main:hover div { width: 150px; height: 150px; border-radius: 50%; } 步进速度 过渡使用阶梯化呈现，有点像现实生活中的机械舞，下面是把过渡分3步完成。 选项 说明 steps(n, start) 设置n个时间点，第一时间点变化状态 steps(n, end) 设置n个时间点，第一时间点初始状态 step-start 等于steps(1,start)，可以理解为从下一步开始 step-end 等于steps(1,end)，可以理解为从当前步开始 start总是先走，end总是后走。 代码示例： Document * { margin: 0; padding: 0; box-sizing: border-box; } body { height: 100vh; width: 100vw; display: flex; justify-content: center; align-items: center; } main { height: 400px; width: 800px; display: flex; border: 1px solid #ddd; position: relative; } main div { width: 200px; height: 100%; border: 1px solid #ddd; } main::after { content: \"START\"; height: 30%; width: 25%; background: #ff4757; color: #fff; font-size: 2em; /* 过渡时间2s */ transition: 2s; /* 相当于把2s分成三步走 */ transition-timing-function: steps(3, start); position: absolute; top: 0; display: flex; justify-content: center; align-items: center; } main::before { content: \"END\"; height: 30%; width: 25%; background: #70a1ff; color: #fff; font-size: 2em; /* 过渡时间2s */ transition: 2s; /* 相当于把2s分成三步走 */ transition-timing-function: steps(3, end); position: absolute; bottom: 0; display: flex; justify-content: center; align-items: center; } main:hover::before { transform: translateX(600px); } main:hover::after { transform: translateX(600px); } 时钟效果 其实步进这样一帧一帧的来走非常时候做时钟，那么这里就做一个非常简陋的时钟吧。 代码示例： Document * { margin: 0; padding: 0; box-sizing: border-box; } body { height: 100vh; width: 100vw; display: flex; justify-content: center; align-items: center; } main { height: 400px; width: 400px; display: flex; position: relative; background: #ffa502; box-shadow: 3px 3px 3px #2f3542; border-radius: 50%; } main::after { content: \"\"; height: 20px; width: 20px; border-radius: 50%; position: absolute; left: 50%; top: 50%; transform: translate(-50%, -50%); background: #1e90ff; } main::before { content: \"\"; height: 48%; width: 6px; position: absolute; left: 50%; bottom: 50%; transform: translate(-50%, 0); background: #1e90ff; transition-duration: 60s; transition-timing-function: steps(60, start); transform-origin: bottom; } main:hover::before { transform: translateX(-50%) rotate(360deg); } 延迟过渡 transition-delay 用于设置延迟过渡的时间。 默认为0s即立刻开始过渡 值可以为负数 变化属性数量大于时间数量时，后面的属性再从第一个时间开始重复使用 基本使用 下面设置了延迟时间为1s，当鼠标放上时产生变化。 代码示例： Document * { padding: 0; margin: 0; } body { background: #2c3e50; display: flex; flex-direction: column; justify-content: center; align-items: center; box-sizing: border-box; width: 100vw; height: 100vh; padding: 80px; } main { width: 400px; height: 400px; } div { width: 150px; height: 150px; background-color: #e67e22; border-radius: 50%; transition-property: background-color, transform, opacity, border-radius; transition-duration: 1s; transition-delay: 1s; } div:hover { border-radius: 0; transform: scale(2) rotate(180deg); background-color: #e67e22; } 多值延迟 可以设置不同属性的延迟时间。 代码示例： Document * { padding: 0; margin: 0; } body { background: #2c3e50; display: flex; flex-direction: column; justify-content: center; align-items: center; box-sizing: border-box; width: 100vw; height: 100vh; padding: 80px; } main { width: 400px; height: 400px; } div { width: 150px; height: 150px; background-color: #fff; /* 一一对应 */ transition-property: background-color, transform, border-radius; transition-duration: 1s, 2s, 3s; transition-delay: 1s, 3s, 5s; } div:hover { border-radius: 50%; transform: scale(2) rotate(180deg); background-color: #e67e22; } 使用负值 下例圆角属性的过渡时间为4s，设置延迟为 -4s，表示鼠标放上时直接显示在4s上的效果。如果设置为-2s显示圆角变形一半的效果。 即对圆角来说不产生过渡，是瞬发的。 代码示例： Document * { padding: 0; margin: 0; } body { background: #2c3e50; display: flex; flex-direction: column; justify-content: center; align-items: center; box-sizing: border-box; width: 100vw; height: 100vh; padding: 80px; } main { width: 400px; height: 400px; } div { width: 150px; height: 150px; background-color: #fff; transition-property: background-color, transform, border-radius; transition-duration: 1s, 2s, 4s; transition-delay: 1s, 2s, -4s; } div:hover { border-radius: 50%; transform: scale(2) rotate(180deg); background-color: #e67e22; } 组合定义 transition 可以使用transition 指令将过渡规则统一设置，需要注意以下几点。 必须设置过渡时间 延迟时间放在逗号或结束前 如果只设置一个数值，那么该数值会认为是过渡时间 transition: border-radius linear 2s 0s, background 2s 2s, width linear 2s 4s, height linear 2s 4s; /* 参与过渡的动画 贝塞尔曲线 过渡时间 延迟时间 */ 点赞案例 代码示例： Document body { width: 100vw; height: 100vh; display: flex; justify-content: center; align-items: center; background: #ecf0f1; } div { position: relative; width: 100px; height: 100px; cursor: pointer; display: flex; justify-content: center; align-items: center; } div i.fa { font-size: 100px; position: absolute; transition: all .5s; color: #ddd; } div.heart i.fa { font-size: 400px; color: #e74c3c; opacity: 0; } div.heart i.fa:nth-child(2) { font-size: 80px; color: #e74c3c; opacity: 1; } function heart() { $(\"div\").toggleClass('heart'); } Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-07-19 22:23:18 "},"前端专栏/CSS/帧动画.html":{"url":"前端专栏/CSS/帧动画.html","title":"帧动画","keywords":"","body":"基础知识 通过定义一段动画中的关键点、关键状态来创建动画。@Keyframes相比transition对动画过程和细节有更强的控制。 过渡动画是两个状态间的变化，帧动画可以处理动画过程中不同时间的细节变化， 对过渡动画理解后再学习习帧动画会非常容易，也可以把帧动画理解为多个帧之间的过渡动画。 关键帧 使用@keyframes 规则配置动画中的各个帧 from 表示起始点 to表示终点 可以使用百分数如 20% 代表动画运行到20%处 基本使用 下面使用 @keyframes 定义了动画叫 radius 并配置了两个帧动作from/to ，然后在main:hover div中使用animation-name 引用了动画并使用animation-duration声明执行三秒。 注意：动画命名不要使用CSS关键字如 none 可以看到上面的动画是从30%的圆角过渡到了50%的圆角，但是整个动画的结束是瞬间结束，并不完美。 不要着急，下面会介绍各种方法让你的帧动画随心所欲。 代码示例： Document * { margin: 0; padding: 0; list-style: none; box-sizing: border-box; } body { height: 100vh; width: 100vw; display: flex; justify-content: center; align-items: center; } main { height: 200px; width: 200px; display: flex; justify-content: center; align-items: center; border: 1px solid #ddd; } div { height: 100px; width: 100px; background: #5352ed; } main:hover div { /* 一组帧的名字 */ animation-name: radius; /* 动画时长 */ animation-duration: 3s; } @keyframes radius { from { border-radius: 30%; } to { border-radius: 50%; } } 时间点 帧动画需要定义在不同时间执行的动作，开始与结束可以使用 form/to 或 0%/100% 声明。 必须添加百分号，25%是正确写法 时间点没有顺序要求，即100%写在25%前也可以 未设置0%与100% 时将使用元素原始状态 你可以这么理解，目前所学的一组帧动画它的运行应该是这样的 初始状态 ---> 0% 或者 from ---> 100% 或者 to ---> 初始状态 　所以现在看上面的动画，就知道为什么看起来比较生硬了。 物体移动 下面定义不同时间点来让物体元素移动一圈，下例中可以不设置from/to 系统将定义为元素初始状态。 代码示例： Document * { margin: 0; padding: 0; list-style: none; box-sizing: border-box; } body { height: 100vh; width: 100vw; display: flex; justify-content: center; align-items: center; } main { height: 400px; width: 400px; display: flex; justify-content: flex-start; align-items: flex-start; border: 1px solid #ddd; } div { height: 100px; width: 100px; background: #5352ed; } main:hover div { /* 一组帧的名字 */ animation-name: move; /* 动画时长 */ animation-duration: 3s; } @keyframes move { /* 初始状态 ---> 帧 ---> 初始状态 */ 25% { transform: translate(300px, 0); } 50% { transform: translate(300px, 300px); } 75% { transform: translate(0, 300px); } } 同时声明 时间点可以动画样式一样时可以一起声明，下面将25%/75%背景一起声明。 代码示例： Document * { margin: 0; padding: 0; list-style: none; box-sizing: border-box; } body { height: 100vh; width: 100vw; display: flex; justify-content: center; align-items: center; } main { height: 400px; width: 400px; display: flex; justify-content: flex-start; align-items: flex-start; border: 1px solid #ddd; } div { height: 100px; width: 100px; background: #5352ed; } main:hover div { /* 一组帧的名字 */ animation-name: move; /* 动画时长 */ animation-duration: 3s; } @keyframes move { /* 初始状态 ---> 帧 ---> 初始状态 */ 25% { transform: translate(300px, 0); } 50% { transform: translate(300px, 300px); } 75% { transform: translate(0, 300px); } 25%, 75% { background: #ff4757; } 50%, 100% { background: #5352ed; } } 使用动画 使用animation-name 规则可以在元素身上同时使用多个动画。 使用多个动画时用逗号分隔多个 动画有相同属性时，后面动画的属性优先使用 基本使用 代码示例： Document * { margin: 0; padding: 0; list-style: none; box-sizing: border-box; } body { height: 100vh; width: 100vw; display: flex; justify-content: center; align-items: center; } main { height: 400px; width: 400px; display: flex; justify-content: flex-start; align-items: flex-start; border: 1px solid #ddd; } div { height: 100px; width: 100px; background: #5352ed; } main:hover div { /* 一组帧的名字 可以使用多组帧*/ animation-name: move, radius; /* 动画时长 */ animation-duration: 3s; } @keyframes move { /* 初始状态 ---> 帧 ---> 初始状态 */ 25% { transform: translate(300px, 0); } 50% { transform: translate(300px, 300px); } 75% { transform: translate(0, 300px); } /* 相同设置，前者不生效 */ 25%, 75% { background: #ff4757; } 50%, 100% { background: #5352ed; } } @keyframes radius { 25% { border-radius: 50%; } 50% { border-radius: 30%; } 75% { border-radius: 50%; } /* 相同设置后者覆盖前者，所以移动时的颜色会变为下面两种 */ 25%, 75% { background: #ffa502; } 50%, 100% { background: #2ed573; } } 动画时间 使用 animation-duration 可以声明动画播放的时间，即把所有帧执行一遍所需要的时间。 可以使用m秒，ms毫秒时间单位 可为不同动画单独设置执行时间 如果动画数量大于时间数量，将重新从时间列表中计算 。 如一个动画有Move,Radius,Background 而时间是1s,2s，那么Move的时间是1s，Radius的时间是2s，Background的时间从头开始数，又是1s. 效果体验 如下图的过渡时间，圆角是六秒完成，背景色是四秒完成，移动是两秒完成，但是他们的开始时间都是一样的。 代码示例： Document * { margin: 0; padding: 0; list-style: none; box-sizing: border-box; } body { height: 100vh; width: 100vw; display: flex; justify-content: center; align-items: center; } main { height: 400px; width: 400px; display: flex; justify-content: center; align-items: flex-start; border: 1px solid #ddd; } div { height: 100px; width: 100px; background: #5352ed; } main:hover div { /* 一组帧的名字 可以使用多组帧*/ animation-name: radius, background, move; /* 动画时长 圆角是六秒完成，背景色是四秒完成，移动是两秒完成，但是他们的开始时间都是一样的 */ animation-duration: 6s, 4s, 2s; /* 将动画停留在最后一帧 */ animation-fill-mode: forwards; } @keyframes radius { to { border-radius: 50%; } } @keyframes background { to {} } @keyframes move { to { transform: translate(0, 150px); } } 动画属性 不是所有css属性都有过渡效果，查看支持动画的CSS属性 ，一般来讲有中间值的属性都可以设置动画如宽度、透明度等。 如何理解中间值？ 比如，一个元素的宽度从100px变为200px，那么它们之间就有中间值。 而一个元素的边框样式从实心线变为虚心线，他们就没有中间值。 效果体验 看下面这张图，从实心线变为虚心线是瞬间变化，而背景颜色的改变却是跟着动画时间来进行渐变的。 代码示例： Document * { margin: 0; padding: 0; list-style: none; box-sizing: border-box; } body { height: 100vh; width: 100vw; display: flex; justify-content: center; align-items: center; } main { height: 400px; width: 400px; display: flex; justify-content: center; align-items: flex-start; border: 1px solid #ddd; } div { height: 100px; width: 100px; background: #5352ed; } main:hover div { /* 一组帧的名字 可以使用多组帧*/ animation-name: radius, background, move; /* 动画时长 圆角是六秒完成，背景色是四秒完成，移动是两秒完成，但是他们的开始时间都是一样的 */ animation-duration: 6s, 4s, 2s; /* 将动画停留在最后一帧 */ animation-fill-mode: forwards; } @keyframes radius { to { border-radius: 50%; } } @keyframes background { to {} } @keyframes move { to { transform: translate(0, 150px); } } 中间值 可以看下下面这个例子，左边的块from与to设置的尺寸单位没有中间值，所以是瞬间变大。 而右边块的from与to设置的尺寸单位是具有中间值的，所以是跟随动画时间进行渐变。 代码示例： Document * { margin: 0; padding: 0; list-style: none; box-sizing: border-box; } body { height: 100vh; width: 100vw; display: flex; justify-content: center; align-items: center; } main { height: 400px; width: 400px; display: flex; justify-content: space-evenly; align-items: center; border: 1px solid #ddd; } main div:nth-child(1) { background: #5352ed; } main div:nth-child(2) { background: #ff4757; } main:hover div:nth-child(1) { /* 一组帧的名字 可以使用多组帧*/ animation-name: size-percentage; /* 动画时长 */ animation-duration: 2s; /* 将动画停留在最后一帧 */ animation-fill-mode: forwards; } main:hover div:nth-child(2) { /* 一组帧的名字 可以使用多组帧*/ animation-name: size-px; /* 动画时长 */ animation-duration: 2s; /* 将动画停留在最后一帧 */ animation-fill-mode: forwards; } @keyframes size-percentage { from { width: 200px; height: 200px; } /* px 与 % 之间没有中间值，所以是瞬间出现 */ to { width: 50%; height: 50%; } } @keyframes size-px { from { width: 100px; height: 100px; } /* 有中间值，跟随动画时间进行渐变 */ to { width: 200px; height: 200px; } } 重复动画 使用animation-iteration-count 规则设置动画重复执行次数，可以给一个数字。当设置值为 infinite 表示无限循环执行。 可同时设置元素的多个动画重复，使用逗号分隔 如果动画数量大于重复数量定义，后面的动画将重新计算重复 效果体验 如下面这个案例，移动的次数是一次，而变化圆角是无限次。 代码示例： Document * { margin: 0; padding: 0; list-style: none; box-sizing: border-box; } body { height: 100vh; width: 100vw; display: flex; justify-content: center; align-items: center; } main { height: 400px; width: 400px; display: flex; justify-content: flex-start; align-items: flex-start; border: 1px solid #ddd; } div { height: 100px; width: 100px; background: #5352ed; } main:hover div { /* 一组帧的名字 可以使用多组帧*/ animation-name: move, radius; /* 动画时长 */ animation-duration: 3s; /* 代表移动只走一遍，随后就不断的圆角变化，进入死循环 */ animation-iteration-count: 1, infinite; } @keyframes move { /* 初始状态 ---> 帧 ---> 初始状态 */ 25% { transform: translate(300px, 0); } 50% { transform: translate(300px, 300px); } 75% { transform: translate(0, 300px); } /* 相同设置，前者不生效 */ 25%, 75% { background: #ff4757; } 50%, 100% { background: #5352ed; } } @keyframes radius { 25% { border-radius: 50%; } 50% { border-radius: 30%; } 75% { border-radius: 50%; } /* 相同设置后者覆盖前者，所以移动时的颜色会变为下面两种 */ 25%, 75% { background: #ffa502; } 50%, 100% { background: #2ed573; } } 心动感觉 使用循环动画绘制心动效果。 代码示例： Document * { margin: 0; padding: 0; list-style: none; box-sizing: border-box; } body { height: 100vh; width: 100vw; display: flex; justify-content: center; align-items: center; } main { height: 400px; width: 400px; display: flex; justify-content: center; align-items: center; border: 1px solid #ddd; } main i.iconfont { font-size: 100px; color: red; } main:hover i { /* 添加一组帧动画 */ animation-name: xin; /* 时间 */ animation-duration: .5s; /* 循环次数 死循环 */ animation-iteration-count: infinite; } @keyframes xin { to { opacity: .5; font-size: 120px; } 20% { opacity: .6; font-size: 130px; } 40% { opacity: .7; font-size: 140px; } 60% { opacity: .8; font-size: 150px; } 80% { opacity: .9; font-size: 160px; } to { opacity: 1; font-size: 140px; } } 动画方向 使用 animation-direction 控制动画运行的方向。 选项 说明 normal 从0%到100%运行动画 reverse 从100%到0%运行动画 alternate 先从0%到100%，然后从100%到0% alternate-reverse 先从100%到0%，然后从0%到100% 效果对比 代码示例： Document * { margin: 0; padding: 0; list-style: none; box-sizing: border-box; } body { height: 100vh; width: 100vw; display: flex; justify-content: center; align-items: center; } main { height: 400px; width: 800px; display: flex; justify-content: space-evenly; align-items: center; border: 1px solid #ddd; } main i.iconfont { font-size: 100px; color: red; position: relative; } main:hover i { /* 添加一组帧动画 */ animation-name: xin; /* 时间 */ animation-duration: .5s; /* 循环次数 死循环 */ animation-iteration-count: infinite; } main i:nth-child(1):after { content: \"normal\"; font-size: 15px; color: white; position: absolute; left: 50%; top: 50%; transform: translate(-50%, -50%); } main i:nth-child(2):after { content: \"normal-reverse\"; font-size: 15px; color: white; position: absolute; left: 50%; top: 50%; transform: translate(-50%, -50%); } main i:nth-child(3):after { content: \"alternate\"; font-size: 15px; color: white; position: absolute; left: 50%; top: 50%; transform: translate(-50%, -50%); } main i:nth-child(4):after { content: \"alternate-reverse\"; font-size: 15px; color: white; position: absolute; left: 50%; top: 50%; transform: translate(-50%, -50%); } main:hover i:nth-child(1) { /* 0-100 */ animation-direction: normal; } main:hover i:nth-child(2) { /* 100-0 */ animation-direction: reverse; } main:hover i:nth-child(3) { /* 0-100 100-0 */ animation-direction: alternate; } main:hover i:nth-child(4) { /* 100-0 0-100 */ animation-direction: alternate-reverse; } @keyframes xin { to { opacity: .5; font-size: 120px; } 20% { opacity: .6; font-size: 130px; } 40% { opacity: .7; font-size: 140px; } 60% { opacity: .8; font-size: 150px; } 80% { opacity: .9; font-size: 160px; } to { opacity: 1; font-size: 140px; } } 弹跳球 alternate-reverse是100-0 0-100，因此非常适合用来做弹跳球。 我们先把球和阴影都定义在下方，然后使用alternate-reverse将球转移到上方即可。 代码示例： Document * { margin: 0; padding: 0; list-style: none; box-sizing: border-box; } body { height: 100vh; width: 100vw; display: flex; justify-content: center; align-items: center; } main { height: 400px; width: 400px; display: flex; flex-flow: column; justify-content: flex-end; align-items: center; border: 1px solid #ddd; } main div { height: 100px; width: 100px; background: linear-gradient(45deg, #7bed9f, #2ed573, #1e90ff, #3742fa); border-radius: 50%; } main section { width: 140px; height: 20px; background: #2f3542; border-radius: 75%; /* 高斯模糊 */ filter: blur(3px); } main:hover div { /* 添加一组帧动画 */ animation-name: beat; /* 动画时间 */ animation-duration: 1s; /* 运动方式 100-0 0-100 */ animation-direction: alternate-reverse; /* 死循环 */ animation-iteration-count: infinite; } main:hover section { /* 添加一组帧动画 */ animation-name: size; /* 动画时间 */ animation-duration: 1s; /* 运动方式 100-0 0-100 */ animation-direction: alternate-reverse; /* 死循环 */ animation-iteration-count: infinite; } @keyframes beat { from { background: linear-gradient(90deg, #7bed9f, #2ed573, #1e90ff, #3742fa); width: 140px; } to { transform: translateY(-280px); } } @keyframes size { to { width: 70px; } } 延迟动画 使用 animation-delay 规则定义动画等待多长时间后执行。 我们可以为多个动画指定不同的延迟时间，与动画时间的使用规则相同。 效果体验 延迟动画 圆角3s后执行，背景色2s后执行，移动1s后执行 代码示例： Document * { margin: 0; padding: 0; list-style: none; box-sizing: border-box; } body { height: 100vh; width: 100vw; display: flex; justify-content: center; align-items: center; } main { height: 400px; width: 400px; display: flex; justify-content: center; align-items: flex-start; border: 1px solid #ddd; } div { height: 100px; width: 100px; background: #5352ed; } main:hover div { /* 一组帧的名字 可以使用多组帧*/ animation-name: radius, background, move; /* 动画时长 */ animation-duration: 2s; /* 延迟动画 圆角3s后执行，背景色2s后执行，移动1s后执行*/ animation-delay: 3s, 2s, 1s; /* 将动画停留在最后一帧 */ animation-fill-mode: forwards; } @keyframes radius { to { border-radius: 50%; } } @keyframes background { to { background-color: #ffa502; } } @keyframes move { to { transform: translate(0, 150px); } } 动画速率 系统属性 使用animation-timing-function来控制动画速率 值 描述 linear 规定以相同速度开始至结束的过渡效果（等于 cubic-bezier(0,0,1,1)）。 ease 开始慢，然后快，慢下来，结束时非常慢（cubic-bezier(0.25,0.1,0.25,1)）默认值。 ease-in 开始慢，结束快（等于 cubic-bezier(0.42,0,1,1)） ease-out 开始快，结束慢（等于 cubic-bezier(0,0,0.58,1)） ease-in-out 中间快，两边慢（等于 cubic-bezier(0.42,0,0.58,1)） cubic-bezier(n,n,n,n) 在 cubic-bezier 函数中定义自己的值 可以在帧中单独定义，将影响当前帧的速率 贝塞尔曲线 其实不管是linear或者是ease都是由贝塞尔曲线来完成的。 我们需要设置四个值 cubic-bezier(\\, \\, \\, \\)来控制曲线速度，可在 https://cubic-bezier.com 网站在线体验效果。 效果体验 代码示例： Document * { margin: 0; padding: 0; list-style: none; box-sizing: border-box; } body { height: 100vh; width: 100vw; display: flex; justify-content: center; align-items: center; } main { height: 400px; width: 400px; display: flex; justify-content: space-evenly; align-items: flex-end; border: 1px solid #ddd; } div { padding: 10px; height: 100%; width: 25%; text-align: center; background: #ff4757 content-box; color: white; } main:hover div { /* 一组帧的名字 可以使用多组帧*/ animation-name: move; /* 动画时长 */ animation-duration: 3s; /* 重复动画 死循环 */ animation-iteration-count: infinite; } main:hover div:nth-child(1) { animation-timing-function: linear; } main:hover div:nth-child(2) { animation-timing-function: ease; } main:hover div:nth-child(3) { animation-timing-function: ease-in; } main:hover div:nth-child(4) { animation-timing-function: ease-out; } main:hover div:nth-child(5) { animation-timing-function: ease-in-out; } @keyframes move { to { height: 0; } } linear ease ease-in ease-out ease-in-out 弹跳球 ease-out是开始快，结束慢，而ease-in是结束快，开始慢。因此这两个组合做弹跳小球刚好。 代码示例： Document * { margin: 0; padding: 0; list-style: none; box-sizing: border-box; } body { height: 100vh; width: 100vw; display: flex; justify-content: center; align-items: center; } main { height: 400px; width: 400px; display: flex; flex-flow: column; justify-content: space-between; align-items: center; border: 1px solid #ddd; } main div { height: 100px; width: 100px; background: linear-gradient(45deg, #eccc68, #ffa502, #ff6b81, #ff4757); border-radius: 50%; } main section { width: 70px; height: 20px; background: #2f3542; border-radius: 75%; /* 高斯模糊 */ filter: blur(3px); } main:hover div { /* 添加一组帧动画 */ animation-name: beat; /* 动画时间 */ animation-duration: 3s; /* 死循环 */ animation-iteration-count: infinite; } main:hover section { /* 添加一组帧动画 */ animation-name: size; /* 动画时间 */ animation-duration: 3s; /* 死循环 */ animation-iteration-count: infinite; } @keyframes beat { 0% { background: linear-gradient(60deg, #eccc68, #ffa502, #ff6b81, #ff4757); transform: translateY(0px); animation-timing-function: ease-in; width: 100px; } 30% { background: linear-gradient(120deg, #eccc68, #ffa502, #ff6b81, #ff4757); transform: translateY(50px); animation-timing-function: ease-in; width: 100px; } 60% { background: linear-gradient(240deg, #eccc68, #ffa502, #ff6b81, #ff4757); transform: translateY(100px); animation-timing-function: ease-in; width: 100px; } 80% { background: linear-gradient(300deg, #eccc68, #ffa502, #ff6b81, #ff4757); transform: translateY(150px); animation-timing-function: ease-in; width: 100px; } 95% { background: linear-gradient(340deg, #eccc68, #ffa502, #ff6b81, #ff4757); transform: translateY(200px); animation-timing-function: ease-in; width: 100px; } 15%, 45%, 70%, 85%, 100% { width: 140px; transform: translateY(280px); animation-timing-function: ease-out; } } @keyframes size { 0% { width: 80px; } 30% { width: 85px; } 60% { width: 95px; } 80% { width: 110px; } 95% { width: 120px; } 15%, 45%, 70%, 85%, 100% { width: 140px; } } 按钮提交 这个需要用到盒子阴影，一个元素可以有多个阴影。 盒子阴影的设置规则如下： 水平偏移度/垂直偏移度/模糊度/颜色 对于颜色而言可以使用currentColor来获取当前盒子的color属性。 代码示例： Document * { margin: 0; padding: 0; list-style: none; box-sizing: border-box; } body { height: 100vh; width: 100vw; display: flex; justify-content: center; align-items: center; } main { height: 400px; width: 400px; display: flex; justify-content: center; align-items: center; border: 1px solid #ddd; } main button { height: 40px; width: 100px; background-color: #747d8c; color: white; display: flex; justify-content: center; align-items: center; } main button::after { content: ''; display: inline-block; height: 3px; width: 3px; margin-left: 5px; } /* Js中可换成点击事件 */ button:hover::after { /* 添加一组帧动画 */ animation-name: point; /* 动画时间 */ animation-duration: 2s; /* 死循环 */ animation-iteration-count: infinite; /* 动画速率 */ animation-timing-function: linear; } @keyframes point { 60% { box-shadow: none; } 30% { box-shadow: 3px 0 currentColor; } 60% { box-shadow: 3px 0 currentColor, 9px 0 currentColor; } to { box-shadow: 3px 0 currentColor, 9px 0 currentColor, 15px 0 currentColor; } } 提交 步进速度 过渡使用阶梯化呈现，有点像现实生活中的机械舞，下面是把过渡分3步完成。 选项 说明 steps(n,start) 设置n个时间点，第一时间点变化状态 steps(n,end) 设置n个时间点，第一时间点初始状态 step-start 等于steps(1,start)，可以理解为从下一步开始 step-end 等于steps(1,end)，可以理解为从当前步开始 start总是先走，end总是后走. 代码示例： Document * { margin: 0; padding: 0; box-sizing: border-box; } body { height: 100vh; width: 100vw; display: flex; justify-content: center; align-items: center; } main { height: 400px; width: 800px; display: flex; border: 1px solid #ddd; position: relative; } main div { width: 200px; height: 100%; border: 1px solid #ddd; } main::after { content: \"START\"; height: 30%; width: 25%; background: #ff4757; color: #fff; font-size: 2em; position: absolute; top: 0; display: flex; justify-content: center; align-items: center; } main::before { content: \"END\"; height: 30%; width: 25%; background: #70a1ff; color: #fff; font-size: 2em; position: absolute; bottom: 0; display: flex; justify-content: center; align-items: center; } main:hover::after { /* 添加一组动画帧 */ animation-name: move; /* 步进动画，3步 */ animation-timing-function: steps(3, start); /* 动画时长2s */ animation-duration: 2s; } main:hover::before { /* 添加一组动画帧 */ animation-name: move; /* 步进动画，3步 */ animation-timing-function: steps(3, end); /* 动画时长2s */ animation-duration: 2s; } @keyframes move { to { transform: translateX(600px); } } 播放状态 使用 animation-play-state 可以控制动画的暂停与运行。 选项 说明 paused 鼠标放上时暂停 running 鼠标放上时运行 轮播图 代码示例： Document * { padding: 0; margin: 0; } body { width: 100vw; height: 100vh; display: flex; justify-content: center; align-items: center; background: #2c3e50; } main { width: 400px; border: solid 5px #ddd; border-width: 5px 0 5px 0; overflow: hidden; position: relative; } main:hover section { animation-play-state: paused; } main:hover ul::before { animation-play-state: paused; } section { width: 1600px; height: 200px; display: flex; flex-direction: row; animation-name: slide; animation-duration: 4s; animation-iteration-count: infinite; animation-timing-function: steps(4, end); } section div { width: 400px; height: 200px; overflow: hidden; } section div img { width: 100%; } ul { width: 200px; position: absolute; list-style: none; display: flex; justify-content: center; align-items: center; z-index: 3; bottom: 20px; left: 50%; transform: translateX(-50%); } ul li { font-size: 2em; font-weight: bold; color: white; width: 50px; height: 50px; border-radius: 50%; border: solid 3px transparent; box-sizing: border-box; display: flex; justify-content: center; align-items: center; z-index: 2; background: rgba(0, 0, 0, .3); box-shadow: 0 0 3px rgba(0, 0, 0, 1); } ul::before { content: ''; width: 50px; height: 50px; border-radius: 50%; position: absolute; background: #e74c3c; left: 0; animation-name: num; animation-duration: 4s; animation-iteration-count: infinite; animation-timing-function: steps(4, end); z-index: 1; } @keyframes slide { from { transform: translateX(0px); } to { transform: translateX(-100%); } } @keyframes num { 100% { transform: translateX(200px); } } 1 2 3 4 填充模式 animation-fill-mode 用于定义动画播放结束后的处理模式，是回到原来状态还是停止在动画结束状态。 选项 说明 none 需要等延迟结束，起始帧属性才应用 backwards 动画效果在起始帧，不等延迟结束 forwards 结束后停留动画的最后一帧 both 包含backwards与forwards规则，即动画效果在起始帧，不等延迟结束，并且在结束后停止在最后一帧 效果对比 代码示例： Document * { margin: 0; padding: 0; box-sizing: content-box; } body { display: flex; justify-content: center; align-items: center; height: 100vh; width: 100vw; } main { display: flex; justify-content: space-evenly; align-items: center; height: 200px; width: 800px; border: 1px solid #ddd; } div { height: 80px; width: 200px; background: #000 content-box; padding: 10px; display: flex; justify-content: space-evenly; align-items: center; color: #fff; position: relative; } main:hover div { /* 添加一组帧动画 */ animation-name: background; /* 运行时间 */ animation-duration: 3s; /* 延迟时间 */ animation-delay: 2s; } main div:nth-child(1)::before { content: \"等待延迟 不停留最后一帧\"; display: flex; justify-content: space-evenly; align-items: center; color: red; font-weight: bolder; position: absolute; top: -20px; } main div:nth-child(2)::before { content: \"不等待延迟 不停留最后一帧 \"; display: flex; justify-content: space-evenly; align-items: center; color: red; font-weight: bolder; position: absolute; top: -20px; } main div:nth-child(3)::before { content: \"等待延迟 停留最后一帧 \"; display: flex; justify-content: space-evenly; align-items: center; color: red; font-weight: bolder; position: absolute; top: -20px; } main div:nth-child(4)::before { content: \"不等待延迟 停留最后一帧 \"; display: flex; justify-content: space-evenly; align-items: center; color: red; font-weight: bolder; position: absolute; top: -20px; } main:hover div:nth-child(1) { animation-fill-mode: none; } main:hover div:nth-child(2) { animation-fill-mode: backwards; } main:hover div:nth-child(3) { animation-fill-mode: forwards; } main:hover div:nth-child(4) { animation-fill-mode: both; } @keyframes background { from { background-color: #ff6348; } 30% { background-color: #ffa502; } 60% { background-color: #eccc68; } to { background-color: #2ed573; } } none backwards forwards both 简写模式 和CSS中的其他属性一样，可以使用animation组合定义帧动画。animation 属性是一个简写属性，用于设置六个动画属性： animation-name 帧动画名字 animation-duration 帧动画运行时间 animation-timing-function 帧动画速率 animation-delay 帧动画播放状态（暂停/运行） animation-iteration-count 帧动画循环次数 animation-direction 延迟时间 必须存在 animation-duration属性，否则过渡时间为0没有动画效果。 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-07-20 00:00:32 "},"前端专栏/CSS/响应式布局.html":{"url":"前端专栏/CSS/响应式布局.html","title":"响应式布局","keywords":"","body":"媒体查询 媒体查询是响应式布局中非常常用的一种手段，在学习媒体查询之前要先了解什么是响应式。 所谓响应式即在不同尺寸屏幕设备上响应的内容不同 相信在之前你写的页面在PC端看非常华丽工整，但是一拿到移动端全部乱了套，这就是因为没有对页面做响应式处理。 Media Queries能在不同的条件下使用不同的样式，使页面在不同在终端设备下达到不同的渲染效果。 媒体类型 选项 说明 all 所有媒体类型 screen 用于电脑屏幕，平板电脑，智能手机等 print 打印设备 speech 应用于屏幕阅读器等发声设备 另外还有很多设备类型，如tty, tv, projection, handheld, braille, embossed, aural 等等，但是这些类型已经被废弃。 可以使用 link 与 style 中定义媒体查询 也可以使用 @import url(screen.css) screen 形式媒体使用的样式 可以用逗号分隔同时支持多个媒体设备 未指定媒体设备时等同于all style 下面我们来感受一下在screen屏幕设备与print打印设备上同一个元素给出的不同响应。 在screen上响应出红色，而在print上响应出绿色。 我们平时用的style并未指定media，此时默认为all，即所有媒体设备。 代码示例： Document h1 { color: red; } h1 { color: green; } 屏幕设备上显示红色打印设备上显示绿色 link 在 link 标签中通过 media 属性可以设置样式使用的媒体设备。 common.css 没有指定媒体所以全局应用 screen.css 应用在屏幕设备 print.css 应用在打印设备 我们平时用的link并未指定media，此时默认为all，即所有媒体设备。 代码示例： Document 屏幕设备上显示红色打印设备上显示绿色 @import 使用@import 可以引入指定设备的样式规则。文件中引入一个样式文件，在这个文件中再引入其他媒体的样式文件。 /* 引入全局的CSS样式 */ /* 在全局的CSS样式中分别导入不同设备的CSS样式 */ @import url(screen.css) screen; @import url(print.css) print; @media 可以使用 @media 做到更细的控制，即在一个样式表中为多个媒体设备定义样式。 代码示例： Document @media screen { /* 屏幕设备 */ h1 { color: red; } } @media print { /* 打印设备 */ h1 { color: green; } } 屏幕设备上显示红色打印设备上显示绿色 多媒体支持 前面已经说过，如果没有进行限制media则默认是all，all代表全部，如果我们只想让一部分媒体设备应用样式，则可以使用逗号将它们分开。 @import url(screen.css) screen,print; @media screen,print {...} 查询条件 可以使用不同条件限制使用的样式 注意：条件表达式需要放在扩号中 逻辑与 需要满足多个条件时才使用样式，多个条件使用and 连接。下例中满足以下要求才使用样式。 横屏显示 宽度不能超过768px 代码示例： Document @media screen and (orientation: landscape) and (max-width: 768px) { /* 屏幕设备 必须是宽屏 宽度小于768px */ h1 { color: red; } } 必须是屏幕设备并且宽度小于768px 逻辑或 多个或条件查询使用,逗号连接，不像其他程序中使用 or 语法。 下面的示例中如果设备是横屏显示或宽度不超768px时就使用样式规则。 代码示例： Document @media screen and (orientation: landscape), screen and (max-width: 768px) { /* 屏幕设备 必须是横屏 宽度小于768px */ h1 { color: red; } } 必须是屏幕设备并且是横屏显示 或者是屏幕设备并且宽度小于768px 逻辑非 not 表示不应用样式，即所有条件都满足时不应用样式。 必须将not写在查询的最前面 代码示例： Document @media not screen { h1 { color: red; } } 如果是屏幕设备则不应用 反之 如果是不是屏幕设备则应用 only 用来排除不支持媒体查询的浏览器。 对支持媒体查询的设备，正常调用样式，此时就当only不存在 对不支持媒体查询的设备不使用样式 only 和 not 一样只能出现在媒体查询的开始 /* 必须支持媒体查询 必须是屏幕设备并且是横屏显示还有最小宽度为768px */ @media only screen and (orientation: landscape) and (max-width: 768px) { ... } 查询特性 根据查询特性筛选出使用样式的设备。 常用特性 下面列出常用的媒体查询特性 特性 说明 orientation: landscape \\ portrait landscape横屏，portrait竖屏 width 设备宽度 height 设备高度 min-width 最小宽度（可以理解为大于该数值即成立） max-width 最大宽度（可以理解为小于该数值即成立） min-height 最小高度（可以理解为大于该数值即成立） max-height 最大高度（可以理解为小于该数值即成立） 使用示例 　　在设备宽度为568px时使用样式 @media only screen and (width:568px) { ... } 　　在设备大于 569px时使用样式 @media only screen and (min-width:569px) { ... } 　　橫屏设备并且宽度大于569px时使用样式 @media only screen and (orientation: landscape) and (min-width:569px) { ... } 响应尺寸 设备像素 不同设备的像素尺寸差异很大，比如2K的27寸屏幕与4K的27寸屏幕的像素数量是不一样的。如果我们编写CSS时还要判断设备的物理像素就会很麻烦。 我们希望编写CSS时还是按照以往方式编写，至于具体绘制到屏幕上使用的具体像素让浏览器或小程序等自动计算就可以，这是最佳解决方案。 使用以下代码可以轻松解决上面的问题了。（ 在\\标签中插入） 初始样式 有些标签默认含有内外边距，且不同浏览器大小也不一样。为了统一我们可以重置标签的CSS默认样式。 最简单的方式就是使用插件css-reset完成 自动响应 实际操作中不同设备只能取宽或高一个尺寸为响应处理，一般情况下我们取宽度响应，高度自动处理。小尺寸时高度产生滚动条，这并不影响什么。 计算公式： 使用rem单位来处理响应，因为改变rem单位会影响所有使用rem的元素，这确实非常的方便。 rem是在根元素中定义的font-size rem用来在多个设备响应处理时使用 html元素也可以使用:root选择器选择 另外还有一个单位即vw与vh 100vw表示100%设备宽度 100vh代表100%设备高度 因为使用了vw宽度系统会根据不同设备自动计算rem :root{ font-size:15px; } Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-07-20 08:11:32 "},"前端专栏/JavaScript/summary.html":{"url":"前端专栏/JavaScript/summary.html","title":"JavaScript","keywords":"","body":" 基础介绍 变量与常量 运算符相关 分支结构 流程控制 Number Boolean undefined&null String Array Map&WeakMap Set&WeakSet 函数相关 函数闭包 面向对象 this指向 属性特征 属性代理 原型继承 class语法糖 JSON Symbol Date Math RegExp window对象 DOM操作 Event操作 空间坐标 XmlHttpRequest JSONP 伪Ajax请求 Promise 手动实现Promise 异常处理 模块封装 综合练习 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-08-15 15:31:24 "},"前端专栏/JavaScript/基础介绍.html":{"url":"前端专栏/JavaScript/基础介绍.html","title":"基础介绍","keywords":"","body":"基础知识 语言介绍 JavaScript是一种属于网络的动态、弱类型脚本语言，广泛应用于WEB开发领域，常用来为网页添加各式各样的动态功能，为用户提供更流畅美观的页面效果。 HTML、CSS、JavaScript的关系为： HTML定义网页结构 CSS提供网页表现 JavaScript提供网页行为 它的设计思路如下： 借鉴C语言基本语法 借鉴Java语言的数据类型和内存管理 借鉴Scheme语言，将函数作为“一等公民” 借鉴Self语言，使用基于原型（prototype）的继承机制 1995年2月，Netscape（网景）公司加入了一位年轻的小伙伴Brendan Eich（布兰登·艾奇），此时Netscape急需一款能够能够针对其自家产品Netscape Navigation浏览器的脚本语言，于是Brendan Eich便开发出了LiveScript。 后期Netscape与Sun（太阳）公司合作，将这款语言更名为JavaScript并在1995年12月正式发布。 其实Brendan Eich在接到任务并设计出JavaScript仅仅花费了10天，这使得在未来很长一段时间里JavaScript的语法非常混乱，甚至可以说千奇百怪... 之后，Netscape公司的头号大敌，Microsoft（微软）为了抢占浏览器脚本语言市场在JavaScript发布后的1996年8月推出了JScript。 为了使脚本语言不再混乱，1996年11月，网景公司将JavaScript提交给欧洲计算机制造商协会进行标准化。ECMA-262的第一个版本于1997年6月被ECMA组织采纳。 ECMA是欧洲计算机制造商协会由Sum、微软、NetScape公司的程序员组成 ECMAScript是由ECMA-262标准化的脚本语言的名称 JavaScript官方也将JavaScript称作为ECMAScript。 尽管JavaScript和JScript与ECMAScript兼容，但它包含超出ECMAScript的功能。 适用场景 JavaScript是一款一专多能的语言，非常适合学习使用。 它的主要适用场景如下： 可以做为浏览器网页端开发 可以作为服务端后台语言使用Node.js 移动端手机APP开发，如Facebook的 React Native、uniapp、PhoneGap、IONIC 跨平台的桌面应用程序，如使用 electronjs 发展历史 1994年Netscape（网景）公司发布了Navigator浏览器1.0版本，市场占用率超过90% 1995年发布了JavaScript语言 1996年JS在 Navigator浏览器中使用 1996年微软发布JScript在IE3.0中使用 1996年11月网景公司将JS提交给ECMA(国际标准化组织)成为国际标准，用于对抗微软。 由ECMA的第39号技术专家委员会（Technical Committee 39，简称TC39）负责制订ECMAScript标准，成员包括Microsoft、Mozilla、Google等大公司。 1997年ECMA发布ECMA-262标准，推出浏览器标准语言 ECMAScript 1.0 ECMAScript 是标准而Javascript是实现 ... 2009年ECMAScript 5.0发布 2011年ECMAScript5.1发布，成为ISO国际标准，从而推动所有浏览器都支持 ... 2015年ECMAScript6发布，更名为ECMAScript 2015。 2016年ECMAScript7发布，ECMAScript2016 2017年ECMAScript8发布，ECMAScript2017 2018年ECMAScript9发布，ECMAScript2018 2019年ECMAScript10，ECMAScript2019 2020年ECMAScript11，ECMAScript2020 .... 从2015年开始 tc39委员会决定每年发布新的ECMAScript版本。 推荐工具 学习JavaScript推荐工具有2个： vscode chrome vscode作为大前端开发利器，应付JavaScript轻轻松松不在话下，并且其本身就是基于JavaScript来开发的。 chrome应当是前端工程师最常用的浏览器没有之一，它的功能非常强大，因此也是学习JavaScript的重要工具之一。 引入方式 嵌入式 在HTML文档中使用标签，并且在该标签中嵌入JavaScript代码即可。 关于type等文档类型声明可写可不写。 Document \"use strict\" console.log(\"hello world\"); 引入式 在HTML文档中使用标签，并且利用该标签src属性引入一个js文件。 关于type等文档类型声明可写可不写。 Document 延迟加载 观察上面2个示例可以发现我们的JavaScript代码总是书写在HTML和CSS代码之后。 这是因为浏览器的渲染是自上而下的，所以我们在对元素节点进行操纵时应当将标签放在尾部。 如果放在头部将会导致无法读取到节点对象。 下面介绍3种方式，可以让放在头部并防止问题的发生。 1）defer延迟加载，仅针对引入式使用。 只需要为标签加上defer属性即可： Document hello world 2）window对象的onload事件绑定，可针对嵌入式、引用式使用。 必须等待HTML文档先渲染完毕后，再自动执行JavaScript代码： Document window.onload = function () { console.log(document.querySelector(\"p\")); document.querySelector(\"p\").style.cssText = \"color:red; font-size:2rem;\" } hello world 3）使用setTimeout进行异步处理，可针对嵌入式、引用式使用。 只需要将执行代码包裹在setTimeout之中，它就能在同步渲染完成HTML文档之后再执行JavaScript代码： Document setTimeout(function () { console.log(document.querySelector(\"p\")); document.querySelector(\"p\").style.cssText = \"color:red; font-size:2rem;\" }) hello world 代码注释 单行注释 将//放在语句前，即可完成单行注释： // this is comment console.log(\"hello world\"); 多行注释 将语句包裹在/**/中间，即可完成多行注释： /* this is comment you can see hello world */ console.log(\"hello world\"); 自动分号 分号规范 一段语句结束后，应当在结尾加上分号; 这并不是强制性的，仅作为一种规范。 如果你不加分号，解释器也可以通过ASI规则进行解析并进行自动断句，一般情况下并不会出现什么错误。 除了下面的语句，JavaScript中其他的语句在结尾后都应该加上分号： 循环语句：for、while 分支语句：if、switch、try 函数声明（非函数表达式，即自执行函数） 如下所示： (function () { console.log(\"hello world\"); alert(\"hello world\"); document.write(\"hello world\"); })(); 意义作用 JavaScript库部署上线前，一般会对代码进行压缩将它变为一行。 此时如果不加分号进行手动断句，被压缩后的代码执行时解释器可能出现解析错误的情况。 因此保持手动加分号是一个良好的习惯。 运行模式 普通模式 如果直接开始编写JavaScript代码，则是普通模式运行： console.log(\"ordinary mode\"); 严格模式 如果在书写代码前加上“use strict”;则是严格模式运行： \"use strict\"; console.log(\"ordinary mode\"); 我们也可以单独的为某个函数使用严格模式： function show(){ \"use strict\"; console.log(\"strict mode run function\"); } show(); 差异对比 主流框架都采用严格模式，严格模式也是未来JavaScript的标准，所以建议代码编写时都在严格模式下进行。 它们的差异如下： 1）严格模式下变量必须使用关键字声明，未声明的变量不允许赋值，这在非严格模式下是允许的： \"use strict\"; userName = \"YunYa\" console.log(userName); // Uncaught ReferenceError: userName is not defined 2）严格模式下的关键词不允许当做变量名使用，否则抛出异常，这在非严格模式下是允许的： \"use strict\"; let try = \"data\" console.log(try); // Uncaught SyntaxError: Unexpected strict mode reserved word 3）严格模式下的函数形参不可出现多次同名的重复定义，这在非严格模式下是允许的： \"use strict\"; function show(param, param) { console.log(param); } show(1, 1); // Uncaught SyntaxError: Duplicate parameter name not allowed in this context 4）严格模式下不允许链式赋值，这在非严格模式下是允许的： \"use strict\"; let a = b = c = 1; console.log(a); console.log(b); console.log(c); // Uncaught ReferenceError: c is not defined 5）严格模式下的解构赋值必须先进行变量的关键字声明，这在非严格模式下是可以省略的： \"use strict\"; let { name, gender } = { \"name\": \"Jack\", \"gender\": 18 } console.log(name, gender); // Jack 18 有趣的JavaScript JavaScript是一门非常有趣的语言，在非严格模式下你可以看到花样百出的结果。 网络上有一张非常形象的图，Thanks for inventing JavaScript正好阐述了这一切： Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-08-25 23:35:08 "},"前端专栏/JavaScript/变量与常量.html":{"url":"前端专栏/JavaScript/变量与常量.html","title":"变量与常量","keywords":"","body":"变量声明 命名规则 JavaScript由于是动态语言，所以他的变量标识符可以保存所有类型的数据。 命名规则： 变量名必须以字母、下划线或者$开始，后面可以跟上字母、数字、下划线 不要使用关键字来做变量名，比如true、if、while、class等 推荐使用驼峰式命名 以下是JavaScript中常见的30个关键字： var let const if else switch case default for while do in break continue try catch finally throw true else null void with typeof instanceof function class new this return 声明赋值 变量必须先声明后使用，可以使用let、var关键字进行声明。 更推荐使用let进行变量声明，它是ES6后推出的新的变量声明方式，相较于var来说更优秀。 1）先声明、后赋值、再使用： \"use strict\"; let username username = \"Jack\" console.log(username); // Jack 2）声明并赋值再使用： \"use strict\"; let username = \"Jack\" console.log(username); // Jack 常量声明 命名规则 常量的命名规则与变量基本一致，但是使用的声明关键字有所不同。 常量在命名和使用时，应当注意以下一些规则： 常量名建议全部大写 常量一经声明后不可更改 常量在声明时必须同时赋值 声明赋值 常量必须先声明后使用，可以使用const关键字进行声明。 注意！常量在声明时必须同时赋值，不能先声明后赋值： \"use strict\"; const PI = 3.1415926 console.log(PI); // 3.1415926 常量一经声明后将不允许更改，否则会抛出异常。 \"use strict\"; const PI = 3.1415926 PI = 3.1415926 console.log(PI); // Uncaught TypeError: Assignment to constant variable. var let const 三大作用域 JavaScript中拥有3大作用域： 全局作用域：函数外，只有一个 局部作用域：函数内，可有多个 块级作用域：循环语句内，可有多个 不同的声明方式，声明出的变量会有不同的效果。 下面会逐一进行介绍。 window对象 window对象是一个全局对象，这意味着你可以在代码中的任何地方调用到它。 如下示例，在函数show中能调用到window： \"use strict\"; function show(){ console.log(window); } show() // Window {window: Window, self: Window, document: document, name: \"Jack\", location: Location, …} 它的作用是存储一些全局方法，全局变量。如alert()就是一个全局方法。 我们可以通过window.alert()来调用它，也可以直接简写为alert()： \"use strict\"; function show(){ alert(\"i can call alert method\"); window.alert(\"i can call alert method too\"); } show(); 1）非严格模式下，未使用关键字声明的变量将被存储到window对象中，这可能造成变量污染。 如下所示我们在局部作用域中定义了userName变量，但是在外部的全局作用域下也能调用到它，这显然十分的不合理： function show(){ userName = \"Jack\" // 等同于 window.userName = \"Jack\" } show(); console.log(userName); 2）在全局作用域中使用var声明定义的变量会被存放至window对象中，但是在局部作用域中使用var声明定义的变量不会被存放到window对象中： \"use strict\"; function show(){ var userName = \"Jack\" console.log(window.userName); } show(); var userName = \"Tom\"; console.log(window.userName); // undefined // Tom 3）使用let声明定义的变量不会被存放至window对象中： \"use strict\"; function show(){ let userName = \"Jack\" console.log(window.userName); } show(); let userName = \"Tom\"; console.log(window.userName); // undefined // undefined 4）使用const声明定义的常量不会被存放至window对象中： \"use strict\"; function show(){ const userName = \"Jack\" console.log(window.userName); } show(); const userName = \"Tom\"; console.log(window.userName); // undefined // undefined 变量提升 仅有var关键字声明的变量具有变量提升的功能。 它是指在代码运行之前，解释器会先将所有var声明定义的变量提到最前面进行初始化，检测变量名是否符合规范。 变量提升会造成一个问题，使用var声明的变量可以先使用、后定义，最终得到的结果是undefined，并不会抛出异常： \"use strict\"; console.log(userName); var userName = \"Jack\" // undefined 如果是使用let声明定义变量，则直接抛出异常，不会得到undefined，这才是我们所期望的结果： \"use strict\"; console.log(userName); let userName = \"Jack\" // Uncaught ReferenceError: Cannot access 'userName' before initialization TDZ暂时性死区 仅有let、const关键字声明的变量、常量具有TDZ暂时性死区的功能。 它其实就一个作用，let和const声明定义的变量、常量必须先定义后使用，否则就会抛出异常。 1）let具有TDZ暂时性死区的功能，所以必须先定义变量后进行使用，否则抛出异常： \"use strict\"; console.log(userName); let userName = \"Jack\" // Uncaught ReferenceError: Cannot access 'userName' before initialization 2）const具有TDZ暂时性死区的功能，所以必须先定义常量后进行使用，否则抛出异常： \"use strict\"; console.log(PI); const PI = \"Jack\" // Uncaught ReferenceError: Cannot access 'PI' before initialization 3）var不具有TDZ暂时性死区的功能，当没有先定义变量后使用时，通过变量提升机制得到的结果为undefined： \"use strict\"; console.log(userName); var userName = \"Jack\" // undefined 重复定义 在同一个作用域下，使用var声明定义的变量可以重复进行定义，但是let和const声明定义的变量、常量不能重复定义。 1）var可以在同一作用域下重复定义相同变量： \"use strict\"; var userName = \"Jack\" var userName = \"Tom\" console.log(userName); // Tom 2）let不可以在同一作用域下重复定义相同变量： \"use strict\"; let userName = \"Jack\" let userName = \"Tom\" console.log(userName); // Uncaught SyntaxError: Identifier 'userName' has already been declared 3）const不可以在同一作用域下重复定义相同常量： \"use strict\"; const userName = \"Jack\" const userName = \"Tom\" console.log(userName); // Uncaught SyntaxError: Identifier 'userName' has already been declared 块级作用域 仅有let关键字声明的变量具有块级作用域的功能。 块级作用域常出现在循环语句中。 如下所示，由于var关键字声明的变量不具有块级作用域，故可能出现变量污染的情况。 \"use strict\"; for (var i = 0; i let关键字声明的变量具有块级作用域，所以上述这种变量污染的情况可以避免，它会直接抛出一个异常： \"use strict\"; for (let i = 0; i 差异总结 上面介绍了这么多，其实就想说明1点。 不要使用var声明变量，应当使用let 以下是var、let、const的差异对照表： 声明关键字 window对象（弊端） 变量提升（缺点） TDZ暂时性死区（优点） 重复定义（缺点） 块级作用域（优点） var 全局作用域下定义的变量会存放到window对象中，非全局作用域下定义的变量不会存放到window对象中 有 无 允许 无 let 不会存放到window对象中 无 有 不允许 有 const 不会存放到window对象中 无 有 不允许 无 对象分类 值与引用 JavaScript中的所有数据类型可以分为2类，分别是值类型和object引用类型。 值类型作为基本数据类型，是直接存放在栈区内存中的，而引用类型则是存放在堆区内存中。 值类型（基本数据类型）： number、boolean、null、undefined、string 引用类型： object、array、function 它们的区别如下： 值类型是按值访问，操作的就是它们实际所保存的值，当赋值、传递时也都是传递的值本身 引用类型是按引用访问，操作时，解释器需要先从栈中读取内存地址，然后再顺藤摸瓜地找到保存在堆内存中的值，赋值、传递时也都是传递对象指针，而不是值本身 如图所示： typeof typeof用于判断基本的值类型，它可能返回的结果如下： number、boolean、undefined、string、function、object 示例演示： \"use strict\"; let num = 1; console.log(typeof num); let bool = true; console.log(typeof bool); let undef = undefined; console.log(typeof undef); let str = \"string\"; console.log(typeof str); let func = function () { return 1 + 1 }; console.log(typeof func); let obj = { x: 1, y: 2 }; console.log(typeof obj); // number // boolean // undefined // string // function // object instanceof Instanceof会返回布尔值，主要判定当前对象是否是某个对象的实例。 它比typeof更加强大，比如typeof不能区分数组，但是instanceof可以。 示例演示： \"use strict\"; let num = 1; console.log(num instanceof Number); let bool = true; console.log(bool instanceof Boolean); let str = \"string\"; console.log(str instanceof String); let func = function () { return 1 + 1 }; console.log(func instanceof Function); let obj = { x: 1, y: 2 }; console.log(obj instanceof Object); let ary = [1, 2, 3]; console.log(ary instanceof Array); // false // false // false // true // true // true 注意！instanceof如果判断字面量的基本数据类型，会返回false。 如果对象生成不是字面量形式而是完整的实例化形式就会返回true。 \"use strict\"; let num = new Number(1); console.log(num instanceof Number); let bool = new Boolean(true); console.log(bool instanceof Boolean); let str = new String(\"string\"); console.log(str instanceof String); let func = function () { return 1 + 1 }; console.log(func instanceof Function); let obj = { x: 1, y: 2 }; console.log(obj instanceof Object); let ary = [1, 2, 3]; console.log(ary instanceof Array); // true // true // true // true // true // true Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-10-22 14:56:52 "},"前端专栏/JavaScript/运算符相关.html":{"url":"前端专栏/JavaScript/运算符相关.html","title":"运算符相关","keywords":"","body":"算数运算符 四则运算 以下是常见的四则运算符 符号 意义 + 加法运算 - 减法运算 * 乘法运算 / 除法运算 ** 幂运算 % 求余运算 代码示例，普通的四则运算会生成新的值： \"use strict\"; let x = 3; let y = 2; console.log( x + y, x - y, x * y, x / y, x ** y, x % y, ); // 5 1 6 1.5 9 1 增量运算 以下是常见的增量运算符,： 符号 意义 += 增量加法运算 -= 增量减法运算 *= 增量乘法运算 /= 增量除法运算 **= 增量幂运算 %= 增量求余运算 代码示例，增量运算是在某个值原有的基础上做操作： \"use strict\"; let x = 3; let y = 2; console.log( x += y, //eq x = x + y | x = 3 + 2 x -= y, //eq x = x - y | x = 5 - 2 x *= y, //eq x = x * y | x = 3 * 2 x /= y, //eq x = x / y | x = 6 / 2 x **= y, //eq x = x ** y | x = 3 ** 2 x %= y, //eq x = x % y | x = 9 % 2 ); // 5 3 6 3 9 1 一元运算 一元运算有前置和后置的区别。 前置运算： ++i --i 后置运算： i-- i++ 它们都相当于在原有基础上+1或者-1的操作，类似于i += 1和i -= 1。 在平时使用时，两者没有什么区别，但是参与数学运算时会有一些区别。 1）前置运算的操作会先于表达式进行执行： \"use strict\"; let x = 0; console.log(++x + 30); // 第一步 x + 1 = 1 然后再 1 + 30 // 31 2）后置运算的操作会后于表达式进行执行： \"use strict\"; let x = 0; console.log(x++ + 30); // 第一步：0 + 30 = 30 第二步：计算完了对x进行+1，不过此时的x对计算结果已经没有影响了 // 30 赋值运算符 普通赋值 赋值符号为=，以下是普通赋值： \"use strict\"; let x = 0; console.log(x); // 0 平行赋值 可以进行平行赋值，一次为多个标识符进行赋值： \"use strict\"; let x = 1, y = 2, z = 3; console.log(x, y, z); // 1 2 3 链式赋值 在非严格模式下，可以进行链式赋值，多个标识符引用同一个对象： let a = b = c = 1; console.log(a); console.log(b); console.log(c); // 1 // 1 // 1 严格模式下你可以这样做： \"use strict\"; let a, b, c; a = b = c = 1; console.log(a); console.log(b); console.log(c); // 1 // 1 // 1 交叉赋值 可以进行交叉赋值，将2个标识符所指向的对象进行互换，注意使用交叉赋值时必须用[]对标识符进行包裹： \"use strict\"; let x = 1; let y = 2; [x, y] = [y, x]; console.log(x); console.log(y); // 2 // 1 比较运算符 符号意义 比较运算符的返回结果总是为true或者false，一般是用于比较2个相同类型的值的大小。 常用于条件分支结构中： 符号 意义 > 大于 小于 == 形式等于 === 类型形式等于 != 形式不等于 !== 类型形式不等于 >= 大于或者等于 小于或者等于 这里着重说明一下，比较运算符两侧如果一个是数字类型，一个是其他类型，会将其它类型转换成数字类型。 形式等于、类型形式等于、形式不等于、类型形式不等于的区别。 形式只判断2个值长的一不一样，不关心他们是否是同一类型，而类型形式则必须长的一样的同时类型也必须一样 或者说形式判定时会进行隐式转换，将对比的值统一转换为相同类型后再进行对比 如下所示： \"use strict\"; console.log(1 == \"1\"); console.log(1 === \"1\"); console.log(1 != \"1\"); console.log(1 !== \"1\"); // true // false // false // true 注意，当2侧对比的值均为引用类型时，得到的结果永远为false，此时你可以将它们全部转换为string类型后再对比： \"use strict\"; console.log( [1, 2, 3] == [1, 2, 3], [1, 2, 3] === [1, 2, 3], { k1: \"v1\" } == { k1: \"v1\" }, { k1: \"v1\" } === { k1: \"v1\" } ); console.log( [1, 2, 3].toString() == [1, 2, 3].toString(), [1, 2, 3].toString() === [1, 2, 3].toString(), { k1: \"v1\" }.toString() == { k1: \"v1\" }.toString(), { k1: \"v1\" }.toString() === { k1: \"v1\" }.toString() ); // false false false false // true true true true 逻辑运算符 符号意义 JavaScript中的常见逻辑运算符有3个： 单词 意义 ! 非，统一取反 && 与，一真一假取一假，两个为真才取真 || 或，一真一假取一真，两个为假才取假 它们的优先级是，! > && > ||。 比如，! true && false || true时，第一个true是给!计算还是给&&进行计算呢？ 根据优先级来看，它应该是给!进行计算，推算流程如下： !true && false || true false && false || true false || true true 短路运算 如果一次逻辑运算中的逻辑运算符号全部为&&或者||则会从左至右依次进行逻辑运算。 如果每一次都进行运算是很消耗时间的，所以这个时候出现了短路机制。 and = && or = || 如图所示： Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-10-22 14:42:06 "},"前端专栏/JavaScript/分支结构.html":{"url":"前端专栏/JavaScript/分支结构.html","title":"分支结构","keywords":"","body":"if 多条if语句会逐行进行判断，条件为真则执行其下的代码块，条件为假则略过： if(条件判断){ 逻辑代码; } if(条件判断){ 逻辑代码; } if(条件判断){ 逻辑代码; } 示例演示： \"use strict\"; let userAge = prompt(\"Please enter your age:\").trim(); if (userAge = 18 && userAge = 30 && userAge = 60 && userAge = 80) { console.log(\"can still meal\"); } else if代表如果怎样就怎样，else代表否则怎样就怎样。 一组if/else只会执行其中的一个。 以下是JavaScript中if/else语法： if(条件判断){ 逻辑代码; } else{ 逻辑代码; } 示例演示： \"use strict\"; let userInput = Number(prompt(\"Enter any character, determine if it is a numeric string:\").trim()); if (!Number.isNaN(userInput)) { console.log(\"Is a digital string\"); } else { console.log(\"Not a digital string\"); } else if 多条if会按顺序依次执行，对每一条if语句都进行判定，而如果使用else if则只会从多条逻辑判定中取出最先为true的进行执行，后续的判定将不会被执行。 也就是说，if/else if/else三者只会执行一个。 语法如下： if(条件判断){ 逻辑代码; } else if(条件判断){ 逻辑代码; } else{ 逻辑代码; } 示例演示： \"use strict\"; let userAge = prompt(\"Please enter your age:\").trim(); if (userAge switch switch是一种结构更加清晰的流程控制语句。 基本语法如下： 如果case后表达式或结果等于switch括号后的值，将执行此case代码块 break或者return关键字会终止switch的执行，每个case代码块后都应该加上它们中的一个 如果case执行后缺少break或return则接着执行后面的语句 当没有任何case被匹配时，将执行default后的代码块 default尽量放在最下面，如果放在上面需要在后面加上break或return switch (值){ case \"选项\": 逻辑代码; break case \"选项\": 逻辑代码; break default: 默认行为; } 示例演示： \"use strict\"; let userName = prompt(\"Please enter your name:\").trim(); switch(userName){ case \"Jack\": console.log(\"hello Jack\"); break case \"Tom\": console.log(\"hello Tom\"); break default: console.log(\"who are you\"); } 多个case可以共用一个代码块： \"use strict\"; let userGender = prompt(\"Please enter your gender\").trim(); switch (userGender) { case \"male\": case \"female\": console.log(\"I see\"); break default: console.log(\"I don't know\"); } 其实在case后可以跟随表达式，case还具有if的功能。 但是注意switch括号中一定要写上true，否则会走default： \"use strict\"; let userAge = Number(prompt(\"Please enter your age:\").trim()); switch(true){ case Number.isNaN(userAge) || userAge = 80: console.log(\"illegal\"); break case userAge 三元表达式 三元表达式中有三个重要的元素： 条件是第一元素 　 条件成立返回的值是第二元素 　 条件不成立返回的值是第三元素 JavaScript中三元表达式语法如下： ? : ; 示例如下： \"use strict\"; let userAge = Number(prompt(\"Please enter your name:\").trim()); userAge >= 18 ? console.log(\"adult\") : console.log(\"underage\"); 可选链 可选链操作符( ?. )允许读取位于连接对象链深处的属性的值，而不必明确验证链中的每个引用是否有效。?. 操作符的功能类似于 . 链式操作符，不同之处在于，在引用为空(nullish ) (null 或者 undefined) 的情况下不会引起错误，该表达式短路返回值是 undefined。与函数调用一起使用时，如果给定的函数不存在，则返回 undefined。 当尝试访问可能不存在的对象属性时，可选链操作符将会使表达式更短、更简明。在探索一个对象的内容时，如果不能确定哪些属性必定存在，可选链操作符也是很有帮助的。 ? 示例如下，只有当x为array时，才执行接下来的操作： \"use strict\"; let x = [1, 2, 3]; // 取值 let item = x?.[1]; console.log(item); // 调用方法 x?.push(4); console.log(x); // 2 // [1, 2, 3, 4] Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-08-22 22:29:12 "},"前端专栏/JavaScript/流程控制.html":{"url":"前端专栏/JavaScript/流程控制.html","title":"流程控制","keywords":"","body":"while 当程序需要重复做一件事情时，可使用while循环。 条件为真时进入循环体，条件为假时退出循环体。 注意避免死循环。 \"use strict\"; let count = 0; while (count++ do/while do while循环与while循环非常相似，它会在循环体代码执行一次后再进行条件判断，若条件为真则继续执行，条件为假则退出执行。 也就是说，do while循环会至少执行一次循环体代码： \"use strict\"; let count = 6; do { // 执行一次 console.log(count); } while (count++ for for语句只要判断条件为true就会一直执行。 我们可以用它来遍历数组、字符串、对象等容器类型的数据： \"use strict\"; let ary = [\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\"]; for (let i = 0; i for/in for/in在迭代遍历具有index的对象（数组、字符串）时，迭代变量拿到的全是索引。 for/in更适合遍历object，它只会拿到key。 切记不要用for/in来遍历DOM对象集合，它会拿出该对象所包含的全部内容！ 1）遍历数组时，迭代变量拿到的全是索引： \"use strict\"; let ary = [\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\"]; for (let idx in ary) { console.log(ary[idx]); } // A // B // C // D // E // F // G 2）遍历对象时，迭代变量拿到的全是key： \"use strict\"; let obj = { k1: \"v1\", k2: \"v2\", k3: \"v3\" }; for (let k in obj) { console.log(obj[k]); } // v1 // v2 // v3 3）遍历DOM对象集合NodeList时，会发现遍历出很多我们并不关心的数据项，如NodeList的长度、所包含方法等，所以不要用for/in来遍历DOM对象集合： // HTML 1 2 3 4 5 6 // JavaScript \"use strict\"; let nodeList = document.querySelectorAll(\"p\"); for (let idx in nodeList) { console.log(nodeList[idx]); } // 1 // 2 // 3 // 4 // 5 // 6 // 下面都是我们不关心的数据项，方法、长度 // ƒ entries() { [native code] } // ƒ keys() { [native code] } // ƒ values() { [native code] } // ƒ forEach() { [native code] } // 6 // f item() { [native code] } for/of for/of是ES6中新推出的语法。 它仅适用于遍历可迭代对象，内置可迭代对象有：String、Array、TypedArray、Map、Set 若要遍历其他对象则需要创建出迭代器后方能使用for/of 1）迭代遍历数组、字符串时迭代变量只会拿到数据项本身，不会拿到索引： \"use strict\"; let ary = [\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\"]; for (let item of ary) { console.log(item); } // A // B // C // D // E // F // G 2）迭代遍历object时，要手动创建一个迭代器才能迭代： \"use strict\"; let obj = { k1: \"v1\", k2: \"v2\", k3: \"v3\" }; for (let [k,v] of Object.entries(obj)) { console.log(k, v); } // k1 v1 // k2 v2 // k3 v3 3）遍历DOM对象集合时，只会遍历出元素本身，不会遍历出NodeList所包含的方法、长度： // HTML 1 2 3 4 5 6 // JavaScript \"use strict\"; let nodeList = document.querySelectorAll(\"p\"); for (let element of nodeList) { console.log(element); } // 1 // 2 // 3 // 4 // 5 // 6 continue continue用于跳过本次循环。 如下所示，在遍历遇到奇数项时跳过： \"use strict\"; for (let i = 10; i > 0; i--) { if ((i % 2)) { continue; } console.log(i); } // 10 // 8 // 6 // 4 // 2 break break用于跳出当前循环。 如下所示，当i等于5时终止循环： \"use strict\"; let i = 0 while (i label 当有多层循环嵌套时，我们可以为每一层循环设置一个label。 当使用break label的时候就可直接跳出多层循环。 注意！该方法很少使用到，因为他会降低代码可读性： \"use strict\"; outer: for (let i = 0; i Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-07-24 22:16:32 "},"前端专栏/JavaScript/Number.html":{"url":"前端专栏/JavaScript/Number.html","title":"Number","keywords":"","body":"基本声明 JavaScript中的Number类型包含整数和浮点数。 以下是使用类实例化的形式进行对象声明： \"use strict\"; let age = new Number(12); console.log(`value : ${age}\\ntype : ${typeof age}`); // value : 12 // type : number 也可以选择使用更方便的字面量形式进行对象声明： \"use strict\"; let age = 12; console.log(`value : ${age}\\ntype : ${typeof age}`); // value : 12 // type : number 若new Number()时没有传入参数，则生成0： \"use strict\"; let age = new Number(); console.log(`value : ${age}\\ntype : ${typeof age}`); // value : 0 // type : number NaN NaN表示一个无效的数值，它不能使用==与其他值做对比。 你可以通过Number.isNaN()方法或者Object.is()方法判定一个值是否属于NaN： \"use strict\"; let v = 123.4; console.log(Number.isNaN(v)); console.log(Object.is(v, NaN)); // false // false 类型转换 基本转换 基本上所有类型都可以隐式的转换为Number类型，区别在于有的会转换为有效数值，有的会转换为无效数值NaN。 1）非数字串的string类型转换为number得到的结果是NaN，即无效数字： \"use strict\"; console.log( Number(\"string\") ); // NaN 2）如果是纯数字串的string类型，则可以转换为number： \"use strict\"; console.log( Number(\"1000\"), ); // 1000 3）true会转换为1，false会转换为0： \"use strict\"; console.log( Number(true), Number(false) ); // 1 0 4）空的array会转换为0，空的object会转换为NaN： \"use strict\"; console.log( Number([]), Number({}) ); // 0 NaN 5）如果array的长度为1，且数据项为number或者数字字符串类型，会直接进行提取，否则将转换为NaN： \"use strict\"; console.log( Number([100]), // 长度为1，且数据项类型为number Number([\"100\"]), // 长度为1，且数据项类型为数字串 Number([\"100\", 100]), ); // 100 100 NaN 6）JavaScript是弱类型语言，故number类型可以和str的纯数字串做四则运算，加法运算得到的结果是string，其他的运算得到的结果都是number或NaN： \"use strict\"; console.log( 100 + \"3\", 100 - \"3\", 100 * \"3\", 100 / \"3\" ); // 1003 97 300 33.333333333333336 // string number number number 强转整数 parseInt() 如果一个string类型即包含数字又包含其他字符，则可通过parseInt()方法进行强制转换。 parseInt()：提取字符串中的整数部分并将其转换为number类型 示例如下： \"use strict\"; let digitalString = \"123.4this is string\" console.log(parseInt(digitalString)); // 123 强转浮点数 parseFloat() 如果一个string类型即包含数字又包含其他字符，则可通过parseFloat()方法进行强制转换。 parseFloat()：提取字符串中的浮点数部分并将其转换为number类型 示例如下： \"use strict\"; let digitalString = \"123.4this is string\" console.log(parseFloat(digitalString)); // 123.4 类型判断 整数判定 isInteger() 使用isInteger()方法判断一个值是否是整数。 返回一个布尔值。 \"use strict\"; let v = 123.4; console.log(Number.isInteger(v)); // false NaN判定 isNaN() 使用isNaN()方法判断一个值是否有效。 返回一个布尔值。 \"use strict\"; let v = 123.4; console.log(Number.isNaN(v)); // false 浮点舍入 toFixed() 使用toFixed()方法对数值进行四舍五入的操作，可指定保留小数点后的位数： \"use strict\"; let v = 123.4344; console.log(v.toFixed()); console.log(v.toFixed(2)); // 123 // 123.43 浮点精度 基本上所有的编程语言中浮点数都有精度问题，当然JavaScript也不例外： \"use strict\"; let n1 = 0.1; let n2 = 0.2; let v = n1 + n2; console.log(v); // 0.30000000000000004 这是因为计算机以二进制处理值类型，上面的0.1和0.2转换为2进制后是无穷的： \"use strict\"; let n1 = 0.1; let n2 = 0.2; let v = n1 + n2; console.log(n1.toString(2)); console.log(n2.toString(2)); // 0.0001100110011001100110011001100110011001100110011001101 // 0.001100110011001100110011001100110011001100110011001101 我们可以使用toFixed()方法来进行小数截取： \"use strict\"; let n1 = 0.1; let n2 = 0.2; let v = (n1 + n2).toFixed(2); console.log(v); // 0.30 或者用一些第三方库进行操作，如decimal.js： // HTML部分 // Js部分 \"use strict\"; let n1 = 0.1; let n2 = 0.2; let v = Decimal.add(n1, n2).valueOf(); console.log(v); // 0.3 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-07-24 13:41:32 "},"前端专栏/JavaScript/Boolean.html":{"url":"前端专栏/JavaScript/Boolean.html","title":"Boolean","keywords":"","body":"基本声明 boolean的值被称为布尔值，常用于分支流程中，仅有2种表现形式： true：代表条件为真 false：代表条件为假 以下是使用类实例化的形式进行对象声明： \"use strict\"; let bool = new Boolean(true); console.log(`value : ${bool}\\ntype : ${typeof bool}`); // value : true // type : boolean 也可以选择使用更方便的字面量形式进行对象声明： \"use strict\"; let bool = true; console.log(`value : ${bool}\\ntype : ${typeof bool}`); // value : true // type : boolean 若new Boolean()时没有传入参数，则生成false： \"use strict\"; let bool = new Boolean(); console.log(`value : ${bool}\\ntype : ${typeof bool}`); // value : false // type : boolean 类型转换 显式转换 使用 !! 或Boolean()将任意类型对象包裹均能获得其布尔值的表现形式。 !代表取反，2个!!刚好获得布尔值对象 如下所示： \"use strict\"; console.log(!![]); console.log(!!{}); console.log(!!\"\"); console.log(!!\"0\"); console.log(!!\"1\"); console.log(!!0); console.log(!!1); // true // true // false // true // true // false // true 隐式转换 基本上所有类型都可以隐式转换为Boolean类型。 1）boolen与number比较时，true等同于1，false等同于0： \"use strict\"; console.log(3 > true); console.log(0 > false); // true // false 2）boolen与数字串比较时，两边都会转换为number后再进行比较： \"use strict\"; console.log(\"3\" > true); console.log(\"0\" > false); // true // false 3）boolen与array比较时，两边都会转换为number后再进行比较： \"use strict\"; console.log([3] > true); console.log([0] > false); // true // false 4）NaN和布尔值的比较结果都是false： \"use strict\"; console.log(NaN == true); console.log(NaN == false); // false // false 5）非空的string布尔值为true、空的string布尔值为false： \"use strict\"; console.log(!!\"str\"); console.log(!!\"\"); // true // false 6）引用类型的布尔值总为true，无论它其中是否有值，如array和object，以及map和set： \"use strict\"; console.log(!![]); console.log(!![1, 2, 3]); console.log(!!{}); console.log(!!{ x: 1, y: 2 }); console.log(!!new Map()); console.log(!!new Map([[\"x\", 1], [\"y\", 2]])); console.log(!!new Set()); console.log(!!new Set([1, 1, 2, 2, 3, 3])); // true // true // true // true // true // true // true // true 7）要判断容器类型是否为空，则需要通过length或者size以及其他方法进行判断，如下所示： \"use strict\"; console.log(!![].length); console.log(!![1, 2, 3].length); console.log(!!Object.keys({}).length); console.log(!!Object.keys({ x: 1, y: 2 }).length); console.log(!!new Map().size); console.log(!!new Map([[\"x\", 1], [\"y\", 2]]).size); console.log(!!new Set().size); console.log(!!new Set([1, 1, 2, 2, 3, 3]).size); // false // true // false // true // false // true // false // true Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-08-15 16:47:50 "},"前端专栏/JavaScript/undefined&null.html":{"url":"前端专栏/JavaScript/undefined&null.html","title":"undefined&null","keywords":"","body":"两者关系 在ECMA中认为null与undefined是相等的。 它们均代表没有、未定义、未初始的意思。 它们等同于Go语言的nil，Python的None。 但是2者之间还是有一些语义上的区别的。 undefined undefined常用于代表未定义。 1）定义好变量，未进行赋值，此时如果使用该变量得到的结果是undefined： \"use strict\"; let userName; console.log(userName); // undefined 2）函数无返回值： \"use strict\"; function demo(){} let result = demo(); console.log(result); // undefined null null代表未引用任何对象，常在初始化变量中使用。 某些情况下你可能还没想好这个变量存什么值但确定它后续能存值的时候下可用null进行变量初始化。 null本身是属于object，也就是引用类型 \"use strict\"; let userName = null; let userAge = null; // 请求后端获得数据 userName = \"Jack\"; userAge = 18; Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-07-21 20:24:14 "},"前端专栏/JavaScript/String.html":{"url":"前端专栏/JavaScript/String.html","title":"String","keywords":"","body":"基本声明 字符串是JavaScript中非常常见的一种数据类型。 以下是使用类实例化的形式进行对象声明，注意typeof会返回object： \"use strict\"; let str = new String(\"hello world\"); console.log(`value : ${str}\\ntype : ${typeof str}`); // value : hello world // type : object 也可以选择使用更方便的字面量形式进行对象声明，用英文状态下的单引号、双引号将数据项进行包裹即可： \"use strict\"; let str = \"hello world\"; console.log(`value : ${str}\\ntype : ${typeof str}`); // value : hello world // type : string 若new String()时没有传入参数，则生成空字符串： \"use strict\"; let str = new String(); console.log(`value : ${str}\\ntype : ${typeof str}`); // value : // type : object 模板字面量 ${} ` JavaScript中没有format方法进行字符串格式化，但是可以通过模板字面量来达到相同的功能。 语法如下，使用字符串2侧使用`进行包裹，并使用${变量 or 函数 or 表达式}来进行格式化。 \"use strict\"; let userName = prompt(\"please enter your name:\").trim(); console.log(`hello ${userName}, welcome home`); // 用户输入: Jack // 打印结果: hello Jack, welcome home 此外，模板字面量中可以直接使用换行操作，这里不再举例。 模板拆解 模板拆解是指定义一个函数，该函数可以提取出模板字符串中的普通字符串与格式化变量。 代码示例： \"use strict\"; let userName = \"Jack\"; let userAge = 18; function func(s, ...f) { // s:普通字符串 // f:格式化变量 console.log(s); // (3) [\"name:\", \",age:\", \"\", raw: Array(3)] console.log(f); // (2) [\"Jack\", 18] } func`name:${userName},age:${userAge}`; 特殊的\\ 在普通的声明字符串中，\\后面一般都会跟上一个特殊字符。 该字符具有特殊的意义，如\\n代表换行，\\t代表制表符等，这种具有特殊意义的\\char组合被称为转义字符。 常见的转义字符如下表所示： 转义字符 意义 ASCII码值（十进制） \\a 响铃(BEL) 007 \\b 退格(BS) ，将当前位置移到前一列 008 \\f 换页(FF)，将当前位置移到下页开头 012 \\n 换行(LF) ，将当前位置移到下一行开头 010 \\r 回车(CR) ，将当前位置移到本行开头 013 \\t 水平制表(HT) （跳到下一个TAB位置） 009 \\v 垂直制表(VT) 011 \\ 代表一个反斜线字符''' 092 \\' 代表一个单引号（撇号）字符 039 \\\" 代表一个双引号字符 034 ? 代表一个问号 063 \\0 空字符(NUL) 000 \\ddd 1到3位八进制数所代表的任意字符 三位八进制 \\xhh 十六进制所代表的任意字符 十六进制 类型转换 string支持与boolean、number进行转换，这是最常见的操作： \"use strict\"; let str = \"string\"; console.log( !!str, Number(str) ); // true NaN string也支持转换为array： \"use strict\"; let str = \"string\"; console.log( Array(str), ); // [\"string\"] 四则运算 四则运算中用的比较多的就是string与string之间的运算以及string与number之间的运算。 1）string与string的四则运算只有+得到的结果是string，其他得到的结果均为number或者NaN： \"use strict\"; console.log( \"3\" + \"3\", \"3\" - \"3\", \"3\" * \"3\", \"3\" / \"3\", ); // 33 0 9 1 // string number number number 2）string与number的四则运算只有+得到的结果是string，其他得到的结果均为number或者NaN： \"use strict\"; console.log( \"3\" + 3, \"3\" - 3, \"3\" * 3, \"3\" / 3, ); // 33 0 9 1 // string number number number 索引切片 string底层是以一种连续的顺序结构存储数据项，故可以使用索引（index）单个数据项进行获取等操作。 JavaScript中只有正向索引，没有负向索引 正向索引起始值从0开始 如下所示： ----------------------------| | A | B | C | D | E | F | G | ----------------------------| | 0 | 1 | 2 | 3 | 4 | 5 | 6 | ----------------------------| 如下所示，取出第3个元素： \"use strict\"; let v = \"ABCDEFG\"; console.log(v[3]); // D 如果想取出最后一个元素，可以搭配length属性： \"use strict\"; let v = \"ABCDEFG\"; let len = v.length; console.log(v[len - 1]); // G 长度获取 length length 获取字符串长度： \"use strict\"; let str = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"; let len = str.length; console.log(len); // 26 大小写转换 转全大写 toUpperCase() toUpperCase() 将字符串转换为全大写： \"use strict\"; let str = \"abcdefghijklmnopqrstuvwxyz\"; console.log(str.toUpperCase()); // ABCDEFGHIJKLMNOPQRSTUVWXYZ 转全小写 toLowerCase() toLowerCase() 将字符串转换为全小写： \"use strict\"; let str = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"; console.log(str.toLowerCase()); // abcdefghijklmnopqrstuvwxyz 空白移除 移除两侧空白 trim() trim() 移除字符串两侧的空白： \"use strict\"; let str = \" mid \"; console.log(str.trim()); // mid 移除左侧空白 trimLeft() trimLeft() 移除字符串左侧的空白： \"use strict\"; let str = \" mid \"; console.log(str.trimLeft()); // mid 移除右侧空白 trimRight() trimRight() 移除字符串右侧的空白: \"use strict\"; let str = \" mid \"; console.log(str.trimRight()); // mid 元素获取 单字符获取 charAt() charAt() 通过索引值获取单字符，与[idx]效果相同： \"use strict\"; let str = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"; console.log( // 取出A str.charAt(0), str[0], // 取出Z str.charAt(str.length - 1), str[str.length - 1], // 取出X str.charAt(str.length - 3), str[str.length - 3], ); // A A Z Z X X 字符转Unicode charCodeAt() charCodeAt() 通过索引值获取单字符的Unicode编码，如果str本身就是单字符，则不用填入索引值： \"use strict\"; let str = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"; console.log( // 取出A的字符编码 65 str.charCodeAt(0), // 取出Z的字符编码 90 str.charCodeAt(str.length - 1), // 取出X的字符编码 88 str.charCodeAt(str.length - 3), ); // 单字符不用填索引值 console.log(\"Z\".charCodeAt()); // 65 90 88 // 90 Unicode转字符 fromCharCode() fromCharCode() 可将Unicode编码转换为字符，通常对应charCodeAt()使用。 可理解为根据ASCII码值将Number转换为String： \"use strict\"; console.log(String.fromCharCode(65)); // A 切片操作 截取子串 slice() slice() 字符串按照索引切片，顾头不顾尾。 start：索引开始的位置 end：索引结束的位置，若不指定该值，则全切 \"use strict\"; let str = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"; console.log( // 拿出全部 str.slice(0), // 拿出A-W str.slice(0, str.length - 3) ); // ABCDEFGHIJKLMNOPQRSTUVWXYZ // ABCDEFGHIJKLMNOPQRSTUVW 截取子串 substr() 获取从指定位置开始并具有指定长度的子字符串。 form：从哪个位置开始切 length：切几个，若不指定该值，则全切 \"use strict\"; let str = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"; console.log( // 拿出全部 str.substr(0), // 从B开始切，向后数5-1个 str.substr(1, 5) ); // ABCDEFGHIJKLMNOPQRSTUVWXYZ // BCDEF 截取子串 substring() substring() 字符串按照索引切片，顾头不顾尾。 start：索引开始的位置 end：索引结束的位置，若不指定该值，则全切 \"use strict\"; let str = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"; console.log( // 拿出全部 str.substring(0), // 拿出A-W，与slice()相同 str.substring(0, str.length - 3) ); // ABCDEFGHIJKLMNOPQRSTUVWXYZ // ABCDEFGHIJKLMNOPQRSTUVW 查找相关 左侧搜索子串 indexOf() indexOf() 从左侧开始向右查找子串，若子串存在则返回子串开始的索引位置，若子串不存在则返回-1，第2参数为从哪个位置开始找。 searchString：要被搜索的子串 position：从哪里开始搜索 \"use strict\"; let str = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"; console.log( // 能找到，返回子串开始的索引位置 str.indexOf(\"FGH\"), // 找不到，返回-1 str.indexOf(\"abc\") ); // 5 // -1 右侧搜索子串 lastIndexOf() lastIndexOf() 从右侧开始向右查找子串，若子串存在则返回子串开始的索引位置，若子串不存在则返回-1，第2参数为从哪个位置开始找。 searchString：要被搜索的子串 position：从哪里开始搜索 \"use strict\"; let str = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"; console.log( // 能找到，返回子串开始的索引位置 str.lastIndexOf(\"FGH\"), // 找不到，返回-1 str.lastIndexOf(\"abc\") ); // 5 // -1 是否包含子串 search() search() 通过正则表达式搜索子串，若子串存在则返回子串开始的索引位置，若子串不存在则返回-1。 \"use strict\"; let str = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"; console.log( // 能找到，返回子串开始的索引位置 str.search(\"Z$\"), // 找不到，返回-1 str.search(\"^B\") ); // 25 // -1 是否包含子串 includes() includes() 查看字符串中是否包含子串，若子串存在则返回true，若子串不存在则返回false，可指定查找位置。 searchString：要被搜索的子串 position：从哪里开始搜索 \"use strict\"; let str = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"; console.log( // 能找到，返回true str.includes(\"ABC\"), // 找不到，返回false str.includes(\"abc\") ); // true // false 特定子串开头 startsWith() startsWith() 查看字符串是否以特定子串开头，返回true或者false，可指定开头索引的查找位置。 \"use strict\"; let str = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"; console.log( // 是否已ABC开头 str.startsWith(\"ABC\"), // 索引5处是否已FGH开头 str.includes(\"FGH\", 5) ); // true // true 特定子串结尾 endsWith() endsWith() 查看字符串是否以特定子串结尾，返回true或者false，可指定结尾索引的查找位置。 \"use strict\"; let str = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"; console.log( // 是否已XYZ结尾 str.endsWith(\"XYZ\"), // 索引5处是否已FGH结尾 str.includes(\"FGH\", 5) ); // true // true 替换与重复生成 替换子串 replace() replace() 替换字符串中的子串为新串，默认只替换一次，返回新的字符串。 searchValue：被替换的子串 replaceValue：替换的子串 \"use strict\"; let str = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"; console.log( // 将XYZ替换为xyz str.replace(\"XYZ\", \"xyz\"), ); // ABCDEFGHIJKLMNOPQRSTUVWxyz 重复生成 repeat() repeat() 重复生成字符串： \"use strict\"; let str = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"; console.log( // 将str重复生成3次 str.repeat(3), ); // ABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZ 将电话号码中间4位隐藏： \"use strict\"; let str = \"13899320641\"; console.log( str.replace(str.slice(3, 7), \"*\".repeat(4)) ); // 138****0641 拆分与拼接 拆分字符串 split() split() 拆分字符串为数组。 separator：根据那个子串进行拆分 limit：指定数组中存入的拆分结果数量 默认数组会将所有拆分结果都进行存入： \"use strict\"; let str = \"hello, world, hello, JavaScript\"; console.log( // 以,进行拆分 str.split(\",\") ); // [\"hello\", \" world\", \" hello\", \" JavaScript\"] 指定数组仅存入拆分结果的前2个： \"use strict\"; let str = \"hello, world, hello, JavaScript\"; console.log( str.split(\",\", 2) ); // [\"hello\", \" world\"] 字符串拼接 concat() concat() 拼接字符串，类似于 string + string 的操作： \"use strict\"; let str = \"hello\"; console.log( // 相当于 str + , + world str.concat(\",\", \"world\"), ); // hello,world Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-08-03 14:32:20 "},"前端专栏/JavaScript/Array.html":{"url":"前端专栏/JavaScript/Array.html","title":"Array","keywords":"","body":"基本声明 数组创建 以下是使用类实例化的形式进行对象声明： \"use strict\"; let ary = new Array(1, 2, 3); console.log(ary); // [ 1, 2, 3 ] 也可以选择使用更方便的字面量形式进行对象声明，利用[]对数据项进行包裹，并且使用逗号将数据项之间进行分割： \"use strict\"; let ary = [1, 2, 3]; console.log(ary); // [ 1, 2, 3 ] 若new Array()时没有传入参数，则生成空数组： \"use strict\"; let ary = new Array(); console.log(ary); // [] Array.of() 在使用类实例化的形式进行对象声明时，若数组只想有1个数据项元素，则可通过Array.of()进行创建。 否则创建的是一个长度为填入值的空数组： \"use strict\"; let ary1 = Array.of(3); // 创建出只有一个数据项元素3的数组 console.log(ary1); let ary2 = new Array(3); // 创建出长度为3的空数组 console.log(ary2); // [ 3 ] // [ ] Array.fill() 若想创建一个数组中具有相同数据项元素的数组，则可通过Array.fill()进行创建。 如下示例，该数组中的数据项元素全部为A： \"use strict\"; let ary = new Array(5).fill(\"A\"); console.log(ary); // [ 'A', 'A', 'A', 'A', 'A' ] 多维数组 当一个数组中嵌套另一个数组时，该数组即为多维数组： \"use strict\"; let ary = [1, 2, 3, [\"A\", \"B\", \"C\"]]; console.log(ary); // [ 1, 2, 3, [ 'A', 'B', 'C' ] ] 不可变数组 数组是引用类型，使用const声明后依旧能改变数组中元素的值： \"use strict\"; const ary = [1, 2, 3]; ary[0] = \"A\"; console.log(ary); // [ 'A', 2, 3 ] 你可以使用Object.freeze()方法将数组包裹起来，让该数组变为不可变数组： \"use strict\"; const ary = [1, 2, 3]; Object.freeze(ary); ary[0] = \"A\"; console.log(ary); // TypeError: Cannot assign to read only property '0' of object '[object Array]' 类型转换 数组转字符串 1）大部分数据类型都可以使用toString()方法将自身转换为字符串： \"use strict\"; let ary = [\"A\", \"B\", \"C\"]; let strArray = ary.toString(); console.log(strArray); console.log(typeof strArray); // A,B,C // string 2）也可以通过String()将数组包裹起来，这样做会将数组转换为字符串： \"use strict\"; let ary = [\"A\", \"B\", \"C\"]; let strArray = String(ary); console.log(strArray); console.log(typeof strArray); // A,B,C // string 3）join()方法也可以将数组转换为字符串，你需要指定元素之间的链接字符： \"use strict\"; let ary = [\"A\", \"B\", \"C\"]; let strArray = ary.join(\"-\"); console.log(strArray); console.log(typeof strArray); // A-B-C // string 类数组转数组 通过Array.form()方法可以将类数组转换为数组。 类数组是指具有length属性或者是可迭代的对象 Array.form()具有2个参数： arrayLike：待转换为数组的类数组 callbackfn：回调函数，它会对类数组中的元素挨个挨个的做操作，最终会将return的值加入到新数组中 如下示例，将DOM对象集合的NodeList转换为数组： // HTML代码里6个P标签，内容是 1 2 3 4 5 6 \"use strict\"; let nodeList = document.querySelectorAll(\"p\"); let nodeInnerTextArray = Array.from(nodeList, (element, index) => { return \"p -> \" + element.innerText }) console.log(nodeInnerTextArray); // [\"p -> 1\", \"p -> 2\", \"p -> 3\", \"p -> 4 \", \"p -> 5 \", \"p -> 6\"] 索引使用 单元素操作 在String一章节中我们介绍过索引的基本使用。由于String类型是不可变的，所以你只能通过索引进行数据项获取。 而Array是可变类型，所以你可以利用索引对元素进行增删改查。 JavaScript中的[]索引语法仅支持单元素操作，不能进行切片 1）获取单元素，直接使用ary[idx]即可： \"use strict\"; let ary = [\"A\", \"B\", \"C\", \"D\", \"E\"]; // 获取第一个 console.log(ary[0]); // 获取最后一个 console.log(ary[ary.length - 1]); // A // E 2）增加单元素，如果增加单元素的索引位置大于数组已有的最大索引位置，则之前的位置都会用empty进行占位。其实empty就是undefined： \"use strict\"; let ary = [\"A\", \"B\", \"C\", \"D\", \"E\"]; // ary -> current max index = 4 ary[8] = \"I\"; console.log(ary); // empty = undefined console.log(ary[6]); // [ 'A', 'B', 'C', 'D', 'E', , 'I' ] // undefined 3）修改单元素，如果要修改的索引位置大于数组已有的最大索引位置，则相当于增加单元素。 \"use strict\"; let ary = [\"A\", \"B\", \"C\", \"D\", \"E\"]; ary[0] = \"a\"; console.log(ary); // [ 'a', 'B', 'C', 'D', 'E' ] 4）删除单元素，使用delete配合[idx]来删除单个元素，被删除的元素位置会用undefined进行占位，即整个数组不会缩容。若要删除的索引位置大于数组已有的最大索引位置，则无效： \"use strict\"; let ary = [\"A\", \"B\", \"C\", \"D\", \"E\"]; // 索引1处变为undefined delete ary[1]; // 并不会抛出异常 delete ary[8]; console.log(ary); // [ 'A', , 'C', 'D', 'E' ] 实现元素位置调整 通过索引的操作，实现一个元素位置调整函数： \"use strict\"; function move(array, beforePosition, toPosition) { if (beforePosition = array.length) { throw new Error(\"move position error\"); } let beforeValue = array[beforePosition]; let toValue = array[toPosition]; array[beforePosition] = toValue; array[toPosition] = beforeValue; } let ary = [\"C\", \"B\", \"A\", \"D\"]; move(ary, 0, 2); console.log(ary); // [ 'A', 'B', 'C', 'D' ] ...语法 数组合并 …语法可用于拆解一个数组。 如下所示，新数组由2个旧的数组合并而成： \"use strict\"; let ary1 = [\"A\", \"B\", \"C\"], ary2 = [\"D\", \"E\", \"F\"]; let newArray = [...ary1, ...ary2]; console.log(newArray); // [ 'A', 'B', 'C', 'D', 'E', 'F' ] 解构赋值 对一个数组进行解构赋值时，变量名外部必须由[]进行包裹，且变量名与元素一一对应： \"use strict\"; let ary = [\"Jack\", \"18\", \"male\"]; let [userName, age, gender] = ary; console.log(userName); console.log(age); console.log(gender); // Jack // 18 // male 若你想一个变量接收多个被解构的元素，可使用...语法接收它们： \"use strict\"; let ary = [\"Jack\", \"18\", \"male\", \"basketball\", \"football\", \"volleyball\"]; let [userName, age, gender, ...hobby] = ary; console.log(userName); console.log(age); console.log(gender); console.log(hobby); // Jack // 18 // male // [ 'basketball', 'football', 'volleyball' ] 某些变量对你来说没用，可使用_作为匿名变量进行占位，或者直接使用,放弃接收它： \"use strict\"; let ary = [\"Jack\", \"18\", \"male\", \"basketball\", \"football\", \"volleyball\", \"1.92m\", \"80kg\"]; // basketball使用匿名变量接收， football和volleyball直接舍弃 let [userName, age, gender, _, , , height, weight] = ary; console.log(userName); console.log(age); console.log(gender); console.log(height); console.log(weight); // Jack // 18 // male // 1.92m // 80kg 类数组转数组 使用…语法也可以实现类数组转数组，如下所示： \"use strict\"; let nodeList = document.querySelectorAll(\"p\"); let nodeInnerTextArray = new Array(...nodeList).map((element, index) => { return \"p -> \" + element.innerText }) console.log(nodeInnerTextArray); // [\"p -> 1\", \"p -> 2\", \"p -> 3\", \"p -> 4 \", \"p -> 5 \", \"p -> 6\"] 迭代器方法 keys() 返回所有元素的索引值： \"use strict\"; let ary = [ 'A', 'B', 'C', 'D', 'E', 'F' ]; let aryIdx = ary.keys(); while (1){ let iterItem = aryIdx.next(); if(iterItem.done === false){ console.log(iterItem.value); continue } break } // 0 // 1 // 2 // 3 // 4 // 5 values() 返回所有元素的值本身： \"use strict\"; let ary = [ 'A', 'B', 'C', 'D', 'E', 'F' ]; let aryEle = ary.values(); while (1){ let iterItem = aryEle.next(); if(iterItem.done === false){ console.log(iterItem.value); continue } break } // A // B // C // D // E // F entries() 以数组形式返回所有元素的索引值与值本身： \"use strict\"; let ary = ['A', 'B', 'C', 'D', 'E', 'F']; let aryIE = ary.entries(); while (1) { let iterItem = aryIE.next(); if (iterItem.done === false) { console.log(iterItem.value); continue } break } // [ 0, 'A' ] // [ 1, 'B' ] // [ 2, 'C' ] // [ 3, 'D' ] // [ 4, 'E' ] // [ 5, 'F' ] 长度获取 length length 获取数组长度： \"use strict\"; let ary = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L']; let len = ary.length; console.log(len); // 12 循环遍历 for 根据数组长度结合for循环来遍历整个数组： \"use strict\"; let ary = ['A', 'B', 'C', 'D', 'E', 'F']; for (let i = 0; i for/in for/in迭代时的迭代变量是数组的索引值： \"use strict\"; let ary = ['A', 'B', 'C', 'D', 'E', 'F']; for (let idx in ary) { console.log(ary[idx]); } // A // B // C // D // E // F for/of for/of迭代时的迭代变量是数组的值本身： \"use strict\"; let ary = ['A', 'B', 'C', 'D', 'E', 'F']; for (let item of ary) { console.log(item); } // A // B // C // D // E // F 配合迭代器方法entries()和解构赋值，可同时拿到索引和值： \"use strict\"; let ary = ['A', 'B', 'C', 'D', 'E', 'F']; for (let [idx, item] of ary.entries()) { console.log(idx, item); } // 0 'A' // 1 'B' // 2 'C' // 3 'D' // 4 'E' // 5 'F' forEach() forEach()用于递归的操作元素，并根据操作修改原数组中的元素。 使用该方法时需要绑定一个回调函数，该回调函数没有返回结果。 注意与map()方法的区别，该方法是对数组进行原地操作，不会生成新的数组。 回调函数共有3个参数： value：被遍历的元素值本身 index：被遍历的元素索引值 array：被遍历的数组本身 如下示例，对原数组每个数据项+100： \"use strict\"; let ary = [1, 2, 3, 4, 5]; ary.forEach((element, idx, ary)=>{ ary[idx] += 100; }) console.log(ary); // [ 101, 102, 103, 104, 105 ] 反向遍历 for循环也可用于反向遍历，如下所示： \"use strict\"; let ary = ['A', 'B', 'C', 'D', 'E', 'F']; for(let i=ary.length; i>=0; i--){ console.log(ary[i]); } // F // E // D // C // B // A 元素管理 压入尾部 push() 将元素追加至数组尾部： \"use strict\"; let ary = ['A', 'B', 'C', 'D', 'E', 'F']; ary.push(\"G\", \"H\", \"I\", \"J\", \"K\") console.log(ary); // [ 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K' ] 弹出尾部 pop() 将数组尾部最后一个元素弹出并返回，它将引起数组的缩容，并不会使用undefined进行占位： \"use strict\"; let ary = ['A', 'B', 'C', 'D', 'E', 'F']; let lastElement = ary.pop(); console.log(lastElement); console.log(ary); // F // [ 'A', 'B', 'C', 'D', 'E' ] 压入头部 unshift() 将元素插入至数组头部： \"use strict\"; let ary = ['A', 'B', 'C', 'D', 'E', 'F']; ary.unshift(\"1\", \"2\", \"3\", \"4\", \"5\") console.log(ary); // [ '1', '2', '3', '4', '5', 'A', 'B', 'C', 'D', 'E', 'F' ] 弹出头部 shift() 将数组头部第一个元素弹出并返回，它将引起数组的缩容，并不会使用undefined进行占位： \"use strict\"; let ary = ['A', 'B', 'C', 'D', 'E', 'F']; let firstElement = ary.shift(); console.log(firstElement); console.log(ary); // A // [ 'B', 'C', 'D', 'E', 'F' ] 切片方法 slice() 使用slice()方法对数组进行切片，顾头不顾尾。 start：索引开始的位置 end：索引结束的位置，若不指定该值，则全切 \"use strict\"; let ary = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z']; console.log( // 拿出全部 ary.slice(0), // 拿出A-W ary.slice(0, ary.length - 3) ); 万能方法 splice() 使用splice()方法对原数组中的元素进行添加、删除、替换操作。 1）删除元素，返回值为被删除的元素数组： 第一个参数：从哪里开始删除 第二个参数：删除几个元素 \"use strict\"; let ary = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L']; let delElementArray = ary.splice(0, 3); // 从第0个元素开始删，删3个 console.log(delElementArray); console.log(ary); // [ 'A', 'B', 'C' ] // [ 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L' ] 2）向末尾添加元素，配合length属性进行操作： \"use strict\"; let ary = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L']; // 从最后一个位置删，删除0个，并新增M、N、O元素至数组尾部 ary.splice(ary.length, 0, \"M\", \"N\", \"O\") console.log(ary); // [ 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O' ] 3）向头部插入元素： \"use strict\"; let ary = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L']; // 从第一个位置删，删除0个，并插入1, 2, 3, 4, 5元素至数组尾部 ary.splice(0, 0, \"1\", \"2\", \"3\", \"4\", \"5\"); console.log(ary); // [ '1', '2', '3', '4', '5', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L' ] 4）先删除元素，再添加元素到头部： \"use strict\"; let ary = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L']; // 从第一个位置删，删3个，并且新增元素到头部 let delElementArray = ary.splice(0, 3, \"1\", \"2\", \"3\", \"4\", \"5\"); console.log(delElementArray); console.log(ary); // [ 'A', 'B', 'C' ] // [ '1', '2', '3', '4', '5', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L' ] 数组清空 数组清空的方法有很多。 1）将数组的length属性改为0即可： \"use strict\"; let ary = [\"A\", \"B\", \"C\"]; ary.length = 0; console.log(ary); // [] 2）改变变量的标识符指向，旧的数组会自动被GC机制清理掉： \"use strict\"; let ary = [\"A\", \"B\", \"C\"]; ary = [] console.log(ary); // [] 3）使用pop()或者shift()方法来清空数组： \"use strict\"; let ary = [\"A\", \"B\", \"C\"]; while(ary.pop()){}; console.log(ary); // [] 4）使用splice()方法来清空数组： \"use strict\"; let ary = [\"A\", \"B\", \"C\"]; ary.splice(0, ary.length); console.log(ary); // [] 查找元素 左侧搜索元素 indexOf() 从左侧开始向右查找元素，若元素存在则返回该元素首次出现的索引位置，若元素不存在则返回-1，第2参数为从哪个位置开始找。 searchElement：要被搜索的元素 fromIndex：从哪里开始搜索 \"use strict\"; let ary = [\"A\", \"B\", \"C\"]; console.log( // 能找到，返回元素的索引位置 ary.indexOf(\"B\"), // 找不到，返回-1 ary.indexOf(\"Z\") ); // 1 // -1 右侧搜索元素 lastIndexOf() 从右侧开始向右查找元素，若元素存在则返回该元素首次出现的索引位置，若元素不存在则返回-1，第2参数为从哪个位置开始找。 searchElement：要被搜索的元素 fromIndex：从哪里开始搜索 \"use strict\"; let ary = [\"A\", \"B\", \"C\"]; console.log( // 能找到，返回元素的索引位置 ary.lastIndexOf(\"B\"), // 找不到，返回-1 ary.lastIndexOf(\"Z\") ); // 1 // -1 是否包含元素 includes() 查看数组中是否包含某个元素，若该元素存在则返回true，若该元素不存在则返回false，可指定查找位置。 searchElement：要被搜索的元素 fromIndex：从哪里开始搜索 \"use strict\"; let ary = [\"A\", \"B\", \"C\"]; console.log( // 能找到，返回true ary.includes(\"B\"), // 找不到，返回false ary.includes(\"Z\") ); // true // false 元素查找 find() 查看数组中是否包含某个元素，若该元素存在则返回该元素，若该元素不存在则返回undefined。 predicate：回调函数，当该函数的return结果为true时，将返回被遍历的元素值本身 thisArg：如果提供，它将用作每次调用predicate的this值，如果未提供，则使用undefined find()常用于查找引用类型的数据，比如我们要查找多维数组时，includes()是查找不到的，此时就可以使用find()进行查找： \"use strict\"; let ary = [1, 2, 3, [\"A\", \"B\", \"C\"]]; let result = ary.find((element, index, array) => { return [\"A\", \"B\", \"C\"].toString() == element }) console.log(result); // [ 'A', 'B', 'C' ] 索引查找 findIndex() 查看数组中是否包含某个元素，若该元素存在则返回该元素在数组中的索引，若该元素不存在则返回undefined。 predicate：回调函数，当该函数的return结果为true时，将返回被遍历的元素在数组中的索引 thisArg：如果提供，它将用作每次调用predicate的this值，如果未提供，则使用undefined findIndex()常用于查找引用类型的数据，比如我们要查找多维数组时，includes()是查找不到的，此时就可以使用find()进行查找： \"use strict\"; let ary = [1, 2, 3, [\"A\", \"B\", \"C\"]]; let result = ary.findIndex((element, index, array) => { return [\"A\", \"B\", \"C\"].toString() == element }) console.log(result); // 3 find原理 以下是find()和findIndex()的原理： \"use strict\"; function find(array, callbackfn) { for (let item of array) { // 如果被可迭代对象返回true，则返回被遍历的值 if (callbackfn(item) === true) { return item } } return undefined } let ary = [1, 2, 3, [\"A\", \"B\", \"C\"]]; let result = find(ary, element => { return [\"A\", \"B\", \"C\"].toString() == element }) console.log(result); // [ 'A', 'B', 'C' ] 我们可以将该函数稍作修改后添加进Array的原型中，这样所有的Array实例都能调用该方法了： \"use strict\"; Array.prototype.findItem = function (callbackfn) { // this = 调用该方法的数组 for (let item of this) { if (callbackfn(item) === true) { return item } } return undefined } let ary = [1, 2, 3, [\"A\", \"B\", \"C\"]]; let result = ary.findItem(element => { return [\"A\", \"B\", \"C\"].toString() == element }) console.log(result); // [ 'A', 'B', 'C' ] 反转排序 数组翻转 reverse() reverse()方法用于将数组进行翻转，它并不会生成新的数组，而是在原数组基础上做操作： \"use strict\"; let ary = [\"A\", \"B\", \"C\", \"D\", \"E\", \"F\"]; ary.reverse(); console.log(ary); // [ 'F', 'E', 'D', 'C', 'B', 'A' ] 元素排序 sort() sort()方法可对数组中的元素项进行排序，默认按照从小到大的升序排列进行排序，它并不会生成新的数组，而是在原数组基础上做操作： \"use strict\"; let ary = [3, 2, 5, 1, 4]; ary.sort(); console.log(ary); // [ 1, 2, 3, 4, 5 ] 配合reverse()方法，实现倒序排列： \"use strict\"; let ary = [3, 2, 5, 1, 4]; ary.sort().reverse(); console.log(ary); // [ 5, 4, 3, 2, 1 ] 为sort()方法指定回调函数，实现自定义规则排序。 回调函数接收2个参数，a和b 若回调函数返回的是负数，则a排在b之前 若回调函数返回的是正数，则a排在b之后 若回调函数返回的是0，则代表a和b相等，不进行位置调整 如下所示： \"use strict\"; let ary = [3, 2, 5, 1, 4]; ary.sort((a, b)=>{ // a - b 升序排列 // b - a 降序排列 return b - a; }); console.log(ary); // [ 5, 4, 3, 2, 1 ] 实例演示 按照薪资待遇从大到小进行排序： \"use strict\"; let ary = [ { name: \"Jack\", salary: 2000 }, { name: \"Tom\", salary: 5000 }, { name: \"Mary\", salary: 3000 }, { name: \"Ken\", salary: 8000 }, ]; ary.sort((a, b) => { // a - b 升序排列 // b - a 降序排列 return b.salary - a.salary; }); console.log(ary); // [ // { name: 'Ken', salary: 8000 }, // { name: 'Tom', salary: 5000 }, // { name: 'Mary', salary: 3000 }, // { name: 'Jack', salary: 2000 } // ] 排序原理 以下是排序原理实现： \"use strict\"; Array.prototype.sortItem = function (callback) { // this = 调用该方法的数组 for (let a in this) { for (let b in this) { // 如果调用结果小于0，则意味着a小于b，需要调整位置 if (callback(this[a], this[b]) { return a - b }) console.log(ary); // [ 5, 4, 3, 2, 1 ] 合并拆分 数组合并为字符串 join() 使用join()方法，将数组合并为字符串，它会产生一个新的字符串并返回： 你需要指定元素之间的链接字符： \"use strict\"; let ary = [\"www\", \"google\", \"com\"]; let str = ary.join(\".\"); console.log(str); // www.google.com 字符串拆分为数组 split() 使用split()方法，将字符串合并为数组，它会产生一个新的数组并返回。 你需要指定依据那个字符进行拆分，并且指定拆分次数。 具体示例参见String一章： \"use strict\"; let str = \"www.google.com\"; let ary = str.split(\".\"); console.log(ary); // [ 'www', 'google', 'com' ] 链接多个数组 concat() 使用concat()方法，将多个数组进行链接合并，它会产生一个新的数组并返回。 \"use strict\"; let ary = [1, 2, 3]; let newAry = ary.concat([4, 5, 6], [7, 8, 9]); console.log(newAry); // [ 1, 2, 3, 4, 5, 6, 7, 8, 9 ] 扩展方法 全部为真 every() every()用于递归的检测元素，所有检测为true结果才为true，若有一个检测结果为false则直接返回false。 使用该方法时需要要绑定一个回调函数，该回调函数必须返回true或者false。 回调函数共有3个参数： value：被遍历的元素值本身 index：被遍历的元素索引值 array：被遍历的数组本身 如下示例，检测班级中所有JavaScript成绩都及格的同学： \"use strict\"; let ary = [ {name : \"Tom\", js : 98}, {name : \"Jack\", js : 67}, {name : \"Tom\", js : 58}, ]; let result = ary.every((item, idx, array)=>{ return item.js >= 60 }) console.log(result); // false 内部实现原理： \"use strict\"; Array.prototype.everyItem = function (callbackfn) { // this = 调用该方法的数组 for (let [index, item] of this.entries()) { if (!callbackfn(item, index, this)) { return false } } return true } let ary = [ { name: \"Tom\", js: 98 }, { name: \"Jack\", js: 67 }, { name: \"Tom\", js: 59 }, ]; let result = ary.everyItem((item, idx, array) => { return item.js >= 60 }) console.log(result); // false 一个为真 some() some()用于递归的检测元素，所有检测为false结果才为false，若有一个检测结果为true则直接返回true。 使用该方法时需要绑定一个回调函数，该回调函数必须返回true或者false。 回调函数共有3个参数： value：被遍历的元素值本身 index：被遍历的元素索引值 array：被遍历的数组本身 如下示例，检测用户输入的内容是否包含敏感词汇： Document \"use strict\"; const detect = [\"蛤蟆\", \"维尼熊\", \"跳跳虎\"]; let inputElement = document.querySelector(\"input[name=username]\"); inputElement.addEventListener(\"keyup\", function (event) { let content = event.target.value; let result = detect.some((item, index, array) => { return detect.indexOf(content) >= 0; }) if (result) { inputElement.value = \"\"; inputElement.placeholder = \"请不要输入敏感词汇\"; } }) 内部实现原理： \"use strict\"; Array.prototype.someItem = function (callbackfn) { // this = 调用该方法的数组 for (let [index, item] of this.entries()) { if (callbackfn(item, index, this)) { return true } } return false } let ary = [ { name: \"Tom\", js: 98 }, { name: \"Jack\", js: 67 }, { name: \"Tom\", js: 59 }, ]; let result = ary.someItem((item, idx, array) => { return item.js 元素过滤 filter() filter()用于递归的检测元素，所有检测结果为true的元素添加至新的数组中，检测结果为false的元素丢弃。 当检测完毕后会返回新的数组。 使用该方法时需要绑定一个回调函数，该回调函数必须返回true或者false。 回调函数共有3个参数： value：被遍历的元素值本身 index：被遍历的元素索引值 array：被遍历的数组本身 如下示例，筛选出班级中所有JavaScript成绩都及格的同学： \"use strict\"; let ary = [ { name: \"Tom\", js: 98 }, { name: \"Jack\", js: 67 }, { name: \"Tom\", js: 59 }, ]; let result = ary.filter((item, idx, array) => { return item.js >= 60 }) console.log(result); // [ { name: 'Tom', js: 98 }, { name: 'Jack', js: 67 } ] 内部实现原理： \"use strict\"; Array.prototype.filterItem = function (callbackfn) { // this = 调用该方法的数组 let newArray = [] for (let [index, item] of this.entries()) { if (callbackfn(item, index, this)) { newArray.push(item); } } return newArray } let ary = [ { name: \"Tom\", js: 98 }, { name: \"Jack\", js: 67 }, { name: \"Tom\", js: 59 }, ]; let result = ary.filterItem((item, idx, array) => { return item.js >= 60 }) console.log(result); // [ { name: 'Tom', js: 98 }, { name: 'Jack', js: 67 } ] 遍历操作 map() map()用于递归的操作元素，并将操作完成后的元素添加进新数组中，当操作完毕后会返回新的数组。 使用该方法时需要绑定一个回调函数，该回调函数可有返回结果，也可以没有返回结果，若没返回结果新数组则为空。 注意与forEach()方法的区别，该方法不会对原数组造成任何改变，只会生成新的数组。 回调函数共有3个参数： value：被遍历的元素值本身 index：被遍历的元素索引值 array：被遍历的数组本身 如下示例，对原数组每个数据项+100，生成新的数组并返回，原数组并不受影响： \"use strict\"; let ary = [1, 2, 3, 4, 5]; let result = ary.map((element, idx, ary) => { return element += 100; }) console.log(result); console.log(ary); // [ 101, 102, 103, 104, 105 ] // [ 1, 2, 3, 4, 5 ] 内部实现原理： \"use strict\"; Array.prototype.mapItem = function (callbackfn) { // this = 调用该方法的数组 let newArray = [] for (let [index, item] of this.entries()) { newArray.push(callbackfn(item, index, this)); } return newArray } let ary = [1, 2, 3, 4, 5]; let result = ary.mapItem((element, idx, ary) => { return element += 100; }) console.log(result); console.log(ary); // [ 101, 102, 103, 104, 105 ] // [ 1, 2, 3, 4, 5 ] 多元素操作 reduce() reduce()方法有1个初始值，你可以指定该初始值或者不指定。 每次对数组进行遍历后，都会使用回调函数处理该遍历项，并且将该遍历项与初始值进行操作。 常用于累积运算，如累加，累乘等。 除此之外，还有个reduceRight()方法，它是从右向左的遍历，而reduce()方法是从左向右的遍历。 回调函数的参数： prev：上次调用回调函数返回的结果 cur：被遍历的元素值本身 index：被遍历的元素索引值 array：被遍历的数组本身 下面代码示例。 1）统计元素在数组中出现的次数： \"use strict\"; function getCount(ary, item) { return ary.reduce((prev, cur, index, array) => { return prev += (cur === item ? 1 : 0) }, 0) } let ary = [1, 2, 3, 4, 4, 5, 6]; console.log(getCount(ary, 4)); // 2 2）返回数组中最大元素： \"use strict\"; function getMax(ary) { return ary.reduce((prev, cur, index, array) => { return prev > cur ? prev : cur }) } let ary = [1, 2, 3, 4, 4, 5, 6]; console.log(getMax(ary)); // 6 3）进行累加操作： \"use strict\"; function getMax(ary) { return ary.reduce((prev, cur, index, array) => { return prev > cur ? prev : cur }) } // 创建一个数组，长度是100全是空的，然后获取其下索引值 // 再通过 ...语法展开到新的数组中，这个新数组的元素就 // 变为了0-99 let ary = [...Array(100).keys()]; let result = ary.reduce((prev, cur, index, array) => { return prev + cur }) console.log(result); // 4950 4）在100的基础上进行累加操作： \"use strict\"; function getMax(ary) { return ary.reduce((prev, cur, index, array) => { return prev > cur ? prev : cur }) } let ary = [...Array(11).keys()]; let result = ary.reduce((prev, cur, index, array) => { return prev + cur }, 100) console.log(result); // 155 内部实现原理： \"use strict\"; Array.prototype.reduceMethod = function (callbackfn, initialValue = undefined) { // this = 调用该方法的数组 for (let [index, item] of this.entries()) { initialValue = callbackfn(initialValue, item, index, this); } return initialValue } let ary = [...Array(11).keys()]; let result = ary.reduceMethod((prev, cur, index, array) => { return prev + cur }, 100) console.log(result) // 155 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-07-24 21:56:06 "},"前端专栏/JavaScript/Map&WeakMap.html":{"url":"前端专栏/JavaScript/Map&WeakMap.html","title":"Map&WeakMap","keywords":"","body":"Map 基本介绍 Map是一组键值对的结构，用于解决以往不能用对象做键的问题，它在ES6中被引入。 Map拥有极快的查找速度 对比Object，它的键可以是任意类型 其实Map和Object非常相似，但是Object的键只能是String或者Symbol类型，Map在这方面就显得没有这么严苛。 以下是Map和Object的区别对比： 对比项 Map Object 意外的键 Map默认情况下不包含任何键，只包含显式插入的键 Object有一个prototype对象，原型链上的键名可能和你已有对象中的键名发生冲突，虽然ES5开始可以用object.create(null)来创建一个没有原型的对象，但是这种用法不太常见 键的类型 Map的键可以是任意类型，包含函数、对象或任意基本类型 Object中键的类型必须是String或者Symbol 键的顺序 Map中的键是有序的，先插入的k-v排列在前，后插入的k-v排列在后 Object中的键是无序的。注意：自ECMAScript 2015规范以来，对象确实保留了字符串和Symbol键的创建顺序； 因此，在只有字符串键的对象上进行迭代将按插入顺序产生键 Size Map的键值对个数可以通过size属性轻松的进行获取 Object的键值对个数只能手动进行计算 迭代 Map遵循了 可迭代协议，所以可以直接被迭代 Object需要手动的创建出迭代器后才能够对其进行迭代 性能 在频繁增删键值对的场景下表现更好 在频繁添加和删除键值对的场景下未作出优化 声明定义 使用Map()加上嵌套的二维数组即可声明出一个Map容器： \"use strict\"; let map = new Map([ [\"k1\", \"v1\"], [\"k2\", \"v2\"], [\"k3\", \"v3\"], ]); console.log(map instanceof Map); console.log(map); console.log(map.get(\"k1\")); // true // Map { 'k1' => 'v1', 'k2' => 'v2', 'k3' => 'v3' } // v1 Map的键必须是不同的对象，若相同内存地址的对象作为Map中的多个键，将会引发键冲突。 换而言之，Map中的键必须是唯一的。 1）ary1和ary2的内存地址不同，故不会发生键冲突： \"use strict\"; let ary1 = [1, 2, 3]; let ary2 = [1, 2, 3]; let map = new Map([ [ary1, \"v1\"], [\"k2\", \"v2\"], [ary2, \"v3\"], ]); console.log(map instanceof Map); console.log(map); // true // Map { [ 1, 2, 3 ] => 'v1', 'k2' => 'v2', [ 1, 2, 3 ] => 'v3' } 2）ary1和ary2的内存地址相同，将会引发键冲突： \"use strict\"; let ary1 = [1, 2, 3]; let ary2 = ary1; let map = new Map([ [ary1, \"v1\"], [\"k2\", \"v2\"], [ary2, \"v3\"], ]); console.log(map instanceof Map); console.log(map); // true // Map { [ 1, 2, 3 ] => 'v3', 'k2' => 'v2' } 获取数量 size 使用size属性可获取当前Map容器中的键值对数量： \"use strict\"; let map = new Map([ [\"k1\", \"v1\"], [\"k2\", \"v2\"], [\"k3\", \"v3\"], ]); console.log(map.size); // 3 新增数据 set() 使用set()方法为Map容器新增一组键值对： \"use strict\"; let map = new Map(); for (let i = 1; i 'v1', 'k2' => 'v2', 'k3' => 'v3' } 元素检测 has() 使用has()方法可检测当前Map容器中是否存在某个键，返回布尔值。 注意，如果键是引用类型则必须要使用原本键对象的引用才行，单纯的形式相似总会返回false \"use strict\"; let ary = [1, 2, 3]; let map = new Map([ [ary, \"v1\"], [\"k2\", \"v2\"], [\"k3\", \"v3\"], ]); // 同一引用，返回true console.log(map.has(ary)); // 非同一引用，返回false console.log(map.has([1, 2, 3])); // true // false 获取元素 get() 使用get()方法根据键获取值，若键不存在则返回undefined： \"use strict\"; let map = new Map([ [\"k1\", \"v1\"], [\"k2\", \"v2\"], [\"k3\", \"v3\"], ]); console.log(map.get(\"k1\")); console.log(map.get(\"k8\")); // v1 // undefined 删除元素 delete() 使用delete()方法根据键来删除Map容器中的一组键值对。 若删除成功则返回true，否则返回false： \"use strict\"; let map = new Map([ [\"k1\", \"v1\"], [\"k2\", \"v2\"], [\"k3\", \"v3\"], ]); console.log(map.delete(\"k8\")); console.log(map.delete(\"k1\")); // false // true 清空容器 clear() 使用clear()方法可清空Map容器： \"use strict\"; let map = new Map([ [\"k1\", \"v1\"], [\"k2\", \"v2\"], [\"k3\", \"v3\"], ]); map.clear(); console.log(map); // Map {} 数组转换 可使用…语法或者Array.form()将Map容器转换为二维数组： \"use strict\"; let map = new Map([ [\"k1\", \"v1\"], [\"k2\", \"v2\"], [\"k3\", \"v3\"], ]); let ary1 = new Array(...map); let ary2 = Array.from(map); console.log(ary1); console.log(ary2); // [ [ 'k1', 'v1' ], [ 'k2', 'v2' ], [ 'k3', 'v3' ] ] // [ [ 'k1', 'v1' ], [ 'k2', 'v2' ], [ 'k3', 'v3' ] ] 遍历操作 迭代器方法 使用以下3个方法都可创建出Map迭代器。 kes() values() entries() 示例如下： \"use strict\"; let map = new Map([ [\"k1\", \"v1\"], [\"k2\", \"v2\"], [\"k3\", \"v3\"], ]); console.log(map.keys()); console.log(map.values()); console.log(map.entries()); // [Map Iterator] { 'k1', 'k2', 'k3' } // [Map Iterator] { 'v1', 'v2', 'v3' } // [Map Iterator] { [ 'k1', 'v1' ], [ 'k2', 'v2' ], [ 'k3', 'v3' ] } for/of 由于Map本身属于可迭代对象，所以你可以直接使用for/of对其进行遍历操作。 这么做将拿到k-v，它们会以数组的形式返回： \"use strict\"; let map = new Map([ [\"k1\", \"v1\"], [\"k2\", \"v2\"], [\"k3\", \"v3\"], ]); for(let kv of map){ console.log(kv); } // [ 'k1', 'v1' ] // [ 'k2', 'v2' ] // [ 'k3', 'v3' ] forEach() 使用forEach()方法也可对Map容器进行遍历操作。 它与Array的forEach()方法使用基本相同。 \"use strict\"; let map = new Map([ [\"k1\", \"v1\"], [\"k2\", \"v2\"], [\"k3\", \"v3\"], ]); map.forEach((key, value) => { console.log(key, value); }) // v1 k1 // v2 k2 // v3 k3 WeakMap 基本介绍 WeakMap和Map非常相似，它也是根据键值对的形式来进行数据的存取。 但它和Map也有一些不同之处，如下所示： WeakMap中的键必须是对象（引用类型） WeakMap中的键是无序的 WeakMap中的键是弱引用的，也就是说WeakMap中的键并不会增加键源对象的引用计数 在GC机制运行时，如果键源对象在其他地方被删除，WeakMap中也会删除掉该键值对 因为WeakMap中的键是弱引用的，故WeakMap不包含keys()、values()、entries()等方法和size属性，同时WeakMap是不可被迭代的 由于WeakMap中的键是弱引用的特性，故我们可以用它来保存一些经常存取的数据。 当键源对象在外部被删除后，WeakMap中的键值对也会删除，以此达到动态视图的功能。 声明定义 使用WeakMap()加上嵌套的二维数组即可声明出一个WeakMap容器。 注意！键必须是引用类型，若是值类型则会抛出异常 \"use strict\"; let ary = [1, 2, 3]; let obj = { k1: \"v1\", k2: \"v2\" }; let map = new Map([[\"k1\", \"v1\"], [\"k2\", \"v2\"]]); let wMap = new WeakMap([ [ary, \"v1\"], [obj, \"v2\"], [map, \"v3\"], ]) console.log(wMap); // WeakMap {{…} => \"v2\", Map(2) => \"v3\", Array(3) => \"v1\"} WeakMap的键必须是不同的对象，若相同内存地址的对象作为WeakMap中的多个键，将会引发键冲突。 换而言之，WeakMap中的键必须是唯一的。 1）ary1和ary2的内存地址不同，故不会发生键冲突： \"use strict\"; let ary1 = [1, 2, 3]; let ary2 = [1, 2, 3]; let obj = { k1: \"v1\", k2: \"v2\" }; let wMap = new WeakMap([ [ary1, \"v1\"], [obj, \"v2\"], [ary2, \"v3\"], ]) console.log(wMap); // WeakMap {{…} => \"v2\", Array(3) => \"v1\", Array(3) => \"v3\"} 2）ary1和ary2的内存地址相同，将会引发键冲突： \"use strict\"; let ary1 = [1, 2, 3]; let ary2 = ary1; let obj = { k1: \"v1\", k2: \"v2\" }; let wMap = new WeakMap([ [ary1, \"v1\"], [obj, \"v2\"], [ary2, \"v3\"], ]) console.log(wMap); // WeakMap {Array(3) => \"v3\", {…} => \"v2\"} 常用操作 WeakMap容器仅包含3个可用的方法： set()：新增一组键值对，其中键必须是引用类型 delete()：删除一组键值对 has()：根据键判断键值对是否存在于WeakMap容器中 弱引用 对于GC机制的引用计数法来说，存在于WeakMap中的对象键并不会为其增加引用计数，因此这种特性也被称为弱引用。 当WeakMap中对象键在外部的引用计数为0后，WeakMap内部中该键值对也会被清除，如下所示： \"use strict\"; let ary = [1, 2, 3]; let obj = { k1: \"v1\", k2: \"v2\" }; let map = new Map([[\"k1\", \"v1\"], [\"k2\", \"v2\"]]); let wMap = new WeakMap([ [ary, \"v1\"], [obj, \"v2\"], [map, \"v3\"], ]) console.log(wMap); // 引用计数归0 ary = undefined; // 等待GC机制运行，3s后打印结果 setTimeout(() => { console.log(wMap); }, 3000); // WeakMap {{…} => \"v2\", Map(2) => \"v3\", Array(3) => \"v1\"} // WeakMap {{…} => \"v2\", Map(2) => \"v3\"} Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-07-25 15:05:06 "},"前端专栏/JavaScript/Set&WeakSet.html":{"url":"前端专栏/JavaScript/Set&WeakSet.html","title":"Set&WeakSet","keywords":"","body":"Set 基本介绍 Set是一种具有去重特性的容器，它可以存入任意类型的数据。它在ES6中被引入。 Set常用来操纵数据，而非存储数据。 你可以将Set理解为只有key没有value的map Set中的元素会进行严格类型检测存储，即数字字符串不等于数字 Set中存储的值具有唯一性，即Set本身能对元素进行去重 Set中存入的元素是有序的，即先存入的元素在遍历时会先被遍历到 声明定义 使用Set()时传入一个数组即可声明出一个Set容器： \"use strict\"; let set = new Set([ new Number(1), new String(\"1\"), new Boolean(true), new Array(\"A\", \"B\", \"C\"), new Map([[\"k1\", \"v1\", \"k2\", \"v2\"]]) ]); console.log(set instanceof Set); console.log(set); // true // Set { // [Number: 1], // [String: '1'], // [Boolean: true], // [ 'A', 'B', 'C' ], // Map { 'k1' => 'v1' } // } 去重特性 如果一个相同内存地址的对象多次被存入Set中，则只会保留一个。 1）ary1和ary2的内存地址不同，故不会触发Set的去重特性： \"use strict\"; let ary1 = [1, 2, 3]; let ary2 = [1, 2, 3]; let set = new Set([ ary1, ary2, ]); console.log(set); // Set { [ 1, 2, 3 ], [ 1, 2, 3 ] } 2）ary1和ary2的内存地址相同，将会触发Set的去重特性： \"use strict\"; let ary1 = [1, 2, 3]; let ary2 = ary1; let set = new Set([ ary1, ary2, ]); console.log(set); // Set { [ 1, 2, 3 ] } 获取数量 size 使用size属性可获取当前Set容器中的元素数量： \"use strict\"; let set = new Set([ new Number(1), new String(\"1\"), new Boolean(true), new Array(\"A\", \"B\", \"C\"), new Map([[\"k1\", \"v1\", \"k2\", \"v2\"]]) ]); console.log(set.size); // 5 新增元素 add() 使用add()方法为Set容器新增元素项： \"use strict\"; let set = new Set(); for (let i = 1; i 元素检测 has() 使用has()方法可检测当前Set容器中是否存在某个元素项，返回布尔值。 注意，如果元素是引用类型则必须要使用原本元素对象的引用才行，单纯的形式相似总会返回false \"use strict\"; let ary = [1, 2, 3]; let set = new Set([ ary, \"v2\", \"v3\", ]); // 同一引用，返回true console.log(set.has(ary)); // 非同一引用，返回false console.log(set.has([1, 2, 3])); // true // false 删除元素 delete() 使用delete()方法根据键来删除Set容器中的某个元素项。 若删除成功则返回true，否则返回false： \"use strict\"; let set = new Set([ \"v1\", \"v2\", \"v3\", ]); console.log(set.delete(\"v8\")); console.log(set.delete(\"v1\")); // false // true 清空容器 clear() 使用clear()方法可清空Set容器： \"use strict\"; let set = new Set([ \"v1\", \"v2\", \"v3\", ]); set.clear(); console.log(set); // Set {} 数组转换 可使用…语法或者Array.form()将Set容器转换为数组。 我们可以利用Set的去重特性来剔除掉数组中的重复数据项，如下示例： \"use strict\"; let ary = [1, 1, 2, 2, 3, 3]; ary = Array.from(new Set(ary)); console.log(ary); // [ 1, 2, 3 ] 交差并集 通过集合和数组的转换，可实现多集合之间求交差并集操作。 1）交集，求出2个集合之间共有的部分： \"use strict\"; let set1 = new Set([1, 2, 3]); let set2 = new Set([2, 3, 4]); let intersection = new Set( Array.from(set1).filter((item, index, array) => { return set2.has(item); }) ) console.log(intersection); // Set { 2, 3 } ，2）差集，求出一个集合独有的部分： \"use strict\"; let set1 = new Set([1, 2, 3]); let set2 = new Set([2, 3, 4]); let difference = new Set( Array.from(set1).filter((item, index, array) => { return !set2.has(item); }) ) console.log(difference); // Set { 1 } 3）并集，将多个集合合并成一个集合，共有元素只取一次： \"use strict\"; let set1 = new Set([1, 2, 3]); let set2 = new Set([2, 3, 4]); let union = new Set([...set1, ...set2]); console.log(union); // Set { 1, 2, 3, 4 } 遍历操作 迭代器方法 使用以下3个方法都可创建出Set迭代器。 kes() values() entries() 示例如下： \"use strict\"; let set = new Set([ \"v1\", \"v2\", \"v3\", ]); console.log(set.keys()); console.log(set.values()); console.log(set.entries()); // SetIterator {\"v1\", \"v2\", \"v3\"} // SetIterator {\"v1\", \"v2\", \"v3\"} // SetIterator {\"v1\" => \"v1\", \"v2\" => \"v2\", \"v3\" => \"v3\"} for/of 由于Set本身属于可迭代对象，所以你可以直接使用for/of对其进行遍历操作。 \"use strict\"; let set = new Set([ \"v1\", \"v2\", \"v3\", ]); for(let v of set){ console.log(v); } // v1 // v2 // v3 forEach() 使用forEach()方法也可对Set容器进行遍历操作。 它与Array的forEach()方法使用基本相同。 \"use strict\"; let set = new Set([ \"v1\", \"v2\", \"v3\", ]); set.forEach((item, _, set) => { console.log(item); }) // v1 // v2 // v3 WeakSet 基本介绍 WeakSet和Set非常相似，它也具有去重的特性。 但它和Set也有一些不同之处，如下所示： WeakSet中的元素项必须是对象（引用类型） WeakSet中的元素是无序的 WeakSet中的元素是弱引用的，也就是说WeakSet中的元素并不会增加源对象的引用计数 在GC机制运行时，如果源对象在其他地方被删除，WeakSet中也会删除掉该元素 因为WeakSet的元素是弱引用的，故WeakSet不包含keys()、values()、entries()等方法和size属性，同时WeakSet是不可被迭代的 声明定义 使用WeakSet()时传入一个数组即可声明出一个WeakSet容器： \"use strict\"; let ary = new Array([1, 2, 3]); let map = new Map([[\"k1\", \"v1\"]]); let obj = new Object({\"k1\" : \"v1\"}); let wSet = new WeakSet([ ary, map, obj, ]); console.log(wSet instanceof WeakSet); console.log(wSet); // true // WeakSet {Map(1), {…}, Array(1)} 常用操作 WeakMap容器仅包含3个可用的方法： add()：新增一个元素 delete()：删除一个元素 has()：判断某个元素是否存在于WeakSet容器中 弱引用 对于GC机制的引用计数法来说，存在于WeakSet中的元素并不会为其增加引用计数，因此这种特性也被称为弱引用。 当WeakSet中元素在外部的引用计数为0后，WeakSet内部中该元素也会被清除，如下所示： \"use strict\"; let ary = new Array([1, 2, 3]); let map = new Map([[\"k1\", \"v1\"]]); let obj = new Object({\"k1\" : \"v1\"}); let wSet = new WeakSet([ ary, map, obj, ]); console.log(wSet); // 引用计数归0 ary = undefined; // 等待GC机制运行，3s后打印结果 setTimeout(() => { console.log(wSet); }, 3000); // WeakSet {Map(1), {…}, Array(1)} // WeakSet {Map(1), {…}} Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-07-25 15:19:30 "},"前端专栏/JavaScript/函数相关.html":{"url":"前端专栏/JavaScript/函数相关.html","title":"函数相关","keywords":"","body":"自定义函数 对象声明 JavaScript中的函数其实是Function的实例对象，因此我们可以采用实例化的方式来定义函数： \"use strict\"; // new Function(\"参数\", \"函数体代码\"); let func = new Function(\"param1\", \"param2\", \"console.log(param1, param2);\"); func(1, 2); // 1 2 标准声明 对象声明的方式太过麻烦，因此推荐使用function标准语法进行函数定义： \"use strict\"; function func(param1, param2){ console.log(param1, param2); } func(1, 2); // 1 2 变量赋值 也可以先使用function声明出一个匿名函数，再将该匿名函数绑定给某个变量或常量。 注意这种方式需要在代码结尾处加上分号： \"use strict\"; let func = function (param1, param2) { console.log(param1, param2); }; func(1, 2); // 1 2 匿名执行 使用以下方式将声明出一个匿名自执行函数（IIFE），它只会执行一次。 注意这种方式需要在代码结尾处加上分号： \"use strict\"; (function (param1, param2) { console.log(param1, param2); })(1, 2); // 1 2 使用函数 函数名加括号即可调用该函数。 若函数没有显式的进行return，则默认返回undefined： \"use strict\"; function show() { } let result = show(); console.log(result); // undefined 函数提升 标准声明的函数具有函数提升的特性，即可以先使用、后声明函数，这显然不是我们想看到的结果。 但是匿名函数则不会有这种特性，因此更建议使用变量赋值的方式来进行函数声明： \"use strict\"; func(1, 2); function func(param1, param2){ console.log(param1, param2); } // 1 2 函数提升比var变量提升优先级更高，如果标准声明的函数和var赋值声明的函数名字相同时，var赋值声明的函数会被GC所清理： \"use strict\"; func(); function func(){ console.log(\"run standard func\"); } var func = function(){ console.log(\"run var func\"); } // run standard func 更加建议使用let进行函数的赋值声明，它将带来2点好处： TDZ暂时性死区意味着必须先定义再使用let所赋值声明的函数 不会将函数名存入到window对象中 \"use strict\"; let func = function(){ console.log(\"run let func\"); } func(); // run let func 不过一般只要谨记不论是变量或是函数必须先定义后使用的规范时，即可使用标准声明定义函数。 参数相关 参数传递 在参数进行传递时，要注意以下几点： 实参和形参必须一一对应 实参数量若大于形参数量时，多余的实参将忽略掉，并不会报错 形参数量若大于实参数量时，未传入实参的形参值将为undefined 我们可以使用funcName.length来获取需要传递形参的数量。 \"use strict\"; function show(param1, param2, param3){ console.log(param1); console.log(param2); console.log(param3); } // 1.获取形参数量 console.log(show.length); // 3 // 2.实参多，形参少，不会抛出异常 show(\"A\", \"B\", \"C\", \"D\", \"E\"); // A B C // 3.实参少，形参多，未传递形参的值将变为undefined show(\"A\", \"B\"); // A B undefined 默认形参 默认形参是ES6新引进的语法，在使用时需要注意默认形参必须放在最后，当该形参没有实参传递时将采用所设定的默认值，当有实参传递时将采用实参所传递进来的值： \"use strict\"; function show(param1, param2, param3=\"default parameter\"){ console.log(param1); console.log(param2); console.log(param3); } // 实参少，形参多，未传递形参的值将采用默认形参 show(\"A\", \"B\"); // A B default parameter 在ES6之前，我们会这么来定义默认形参： \"use strict\"; function show(param1, param2, param3){ // 定义默认形参 param3 = param3 || \"default parameter\"; console.log(param1); console.log(param2); console.log(param3); } // 实参少，形参多，未传递形参的值将采用默认形参 show(\"A\", \"B\"); // A B default parameter ...语法 …语法形参是ES6新引进的语法。 当不确定使用者会传递进多少实参时，可用...语法接收所有多余的传递进来的参数： \"use strict\"; function show(x, y, ...args){ console.log(args); } show(\"A\", \"B\", \"C\", \"D\", \"E\"); // [ 'C', 'D', 'E' ] 数组解构传参 当实参是一个数组时，形参可以对其进行解构： \"use strict\"; // b c d都是默认形参 function show(a, [b, c, d] =\"default parameter\"){ console.log(a); console.log(b); console.log(c); console.log(d); } show(\"A\", [\"B\", \"C\"]); // A // B // C // undefined 对象解构传参 当实参是一个对象时，形参可以对其进行解构： \"use strict\"; // b c d都是默认形参 function show(a, { b, c, d = \"default parameter\" }) { console.log(a); console.log(b); console.log(c); console.log(d); } show(\"A\", { b: \"B\", c: \"C\" }); // A // B // C // default parameter arguments 使用arguments查看使用者传递的所有实参。 即使该实参未被形参接收到： \"use strict\"; function show(x, y){ console.log(arguments); } show(\"A\", \"B\", \"C\", \"D\", \"E\"); // [Arguments] { '0': 'A', '1': 'B', '2': 'C', '3': 'D', '4': 'E' } 注意！arguments本身是属于Arguments对象，并不是一个数组，但是我们可以将它转换为数组后再做操作。 高阶函数 一等公民 function是JavaScript中的一等公民，所以函数可以被赋值、传参、被当做返回值return、被当做容器中的数据项进行存储。 赋值 函数可以被赋值： \"use strict\"; let f1 = function () { console.log(\"run\"); } let f2 = f1; let f3 = f2; f1(); f2(); f3(); // run // run // run 传参 函数可以被当做参数传递给另一个函数： \"use strict\"; function f1(){ console.log(\"run f1\"); } function f2(f){ console.log(\"run f2\"); f(); } f2(f1); // run f2 // run f1 返回值 函数可以被当做返回值： \"use strict\"; function wrapper(){ console.log(\"run wrapper\"); return function(){ console.log(\"run inner\"); } } wrapper()(); // run wrapper // run inner 数据项 函数可以被当做容器的数据项： \"use strict\"; let ary = [ function(item){console.log(`func${item} run`);}, function(item){console.log(`func${item} run`);}, function(item){console.log(`func${item} run`);}, ] for(let [idx, func] of ary.entries()){ func(idx); } // func0 run // func1 run // func2 run 递归函数 递归函数即自己调用自己的函数。 主要用于数量不确定的循环操作 要有退出时机否则会陷入无限递归的过程 以下示例将用递归函数来解决汉诺塔问题： \"use strict\"; function hanoi(n, a, b, c) { if (n) { hanoi(n - 1, a, c, b); console.log(`moving from ${a} to ${c}`); hanoi(n - 1, b, a, c); } } hanoi(3, \"A\", \"B\", \"C\"); // moving from A to C // moving from A to B // moving from C to B // moving from A to C // moving from B to A // moving from B to C // moving from A to C 以下示例将用递归函数来打印倒三角： \"use strict\"; function show(num) { if (!num) { return } console.log(\"*\".repeat(num)); show(num - 1); } show(5); // ***** // **** // *** // ** // * 回调函数 回调函数是指在某些特定情况下会被其他函数所调用的函数，比如处理键盘事件、鼠标事件等函数都是回调函数： Document click me \"use strict\"; let btn = document.querySelector(\"#btn\"); let section = btn.nextElementSibling.nextElementSibling; btn.addEventListener(\"click\", function (event) { let r = Math.floor(Math.random() * 255); let g = Math.floor(Math.random() * 255); let b = Math.floor(Math.random() * 255); let a = Math.random().toFixed(1); console.log(a); section.style.backgroundColor = `rgba(${r}, ${g}, ${b}, ${a})`; }) 箭头函数 箭头函数是常规函数的一种简写形式。 在使用递归调用、构造函数、事件处理器时不建议使用箭头函数。 函数无形参时使用空括号即可，函数体代码块过短可直接省略花括号 函数体代码块如果只有一句，且为单一的表达式形式时可不必显示return，它会自动进行return 函数只有1个形参时可省略花括号，但如果有多个参数时不可省略 以下是3个箭头函数的定义案例： \"use strict\"; // 函数无形参时使用空括号即可，函数体代码块过短可直接省略花括号 let show = () => console.log(\"run function show\"); // 函数体代码块如果只有一句，且为单一的表达式形式时可不必显示return，它会自动进行return let add = (x, y) => x + y; // 函数只有1个形参时可省略花括号，但如果有多个参数时不可省略 let warning = msg => console.log(msg); show(); console.log(add(1, 2)); warning(\"warning message\"); // run function show // 3 // warning message 上面只是介绍箭头函数的用法，个人在实际使用时不论什么情况下都会加上return，这算是一种习惯吧。 模板函数 模板拆解是指定义一个模板函数，该函数可以提取出模板字符串中的普通字符串与格式化变量。 注意！模板函数会自动进行执行。 代码示例： \"use strict\"; let userName = \"Jack\"; let userAge = 18; function func(s, ...f) { // s:普通字符串 // f:格式化变量 console.log(s); // (3) [\"name:\", \",age:\", \"\", raw: Array(3)] console.log(f); // (2) [\"Jack\", 18] } func`name:${userName},age:${userAge}`; Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-08-13 20:27:18 "},"前端专栏/JavaScript/函数闭包.html":{"url":"前端专栏/JavaScript/函数闭包.html","title":"函数闭包","keywords":"","body":"作用域 作用域介绍 在JavaScript中，所有的标识符（变量名、常量名、函数名、类名）都有一个作用范围。 这个作用范围即被称之为作用域。 举个简单的例子： 清华大学的校规只在清华大学范围内生效 那么清华大学就是清华校规的作用域 全局作用域 全局作用域即是在全局下定义标识符的作用范围。 在JavaScript中，全局作用域中的标识符全局有效，在任何作用域下都能进行访问。 生命周期：代码运行时自动产生，代码运行完毕后自动销毁 数量：至多一个 下列代码中，全局作用域中自定义的标识符有： userName userAge show \"use strict\"; let userName = \"Jack\"; let userAge = 18; function show(){ console.log(userName); } show(); // Jack 由于全局作用域中的标识符全局有效，故在局部作用域中也能对其进行访问。 局部作用域 局部作用域即是在函数或者类下定义标识符的作用范围。 在JavaScript中，局部作用域中的标识符局部有效，外部作用域不能够进行访问。 生命周期：函数体代码执行时产生，函数体代码执行完毕后销毁 数量：可有多个 下列代码中，局部作用域中自定义的标识符有： count message \"use strict\"; let userName = \"Jack\"; let userAge = 18; function show(){ let count = 1; let message = \"this is a message\"; console.log(count); console.log(message); } show(); // 外部作用域不能访问内部作用域 // console.log(count); // console.log(message); // 1 // this is a message 由于局部作用域中的标识符局部有效，故只有在局部作用域中才能对其进行访问，外部作用域是访问不到的。 块级作用域 块级作用域即是在for循环下定义标识符的作用范围，且只有const、let作为迭代变量声明时才具有块级作用域。 在JavaScript中，块级作用域中的标识符局部有效，外部作用域不能够进行访问。 生命周期：循环体代码执行时产生，循环体代码执行完毕后销毁 数量：可有多个 下列代码中，块级作用域中自定义的标识符有： i currentItem \"use strict\"; let userName = \"Jack\"; let userAge = 18; for (let i = 0; i 由于块级作用域中的标识符局部有效，故只有在块级作用域中才能对其进行访问，外部作用域是访问不到的。 标识符查找顺序 先到自身的作用域中查找，如果没有再到定义自己作用域的作用域中进行查找。 示例如下，局部作用域需要使用userName，发现自己有就用自己的，自己没有就往上找： \"use strict\"; let userName = \"Jack\"; let userAge = 18; function show() { let userName = \"Tom\"; // 在show的局部作用域中定义了匿名自执行函数 (function () { // ↑ 向上找，定义自己的作用域中去找 console.log(userName); }()); } show(); // Tom 闭包函数 若一个函数中嵌套定义并返回了另一个函数，那个这个函数即被称为闭包函数。 内部函数在外部被进行使用时其父函数的命名空间并不会被销毁而是依旧存活： \"use strict\"; // 全局作用域下定义的标识符：wrapper innerFunction result // wrapper局部作用域下定义的标识符: funcName .. 匿名函数 function wrapper() { let funcName = \"wrapper\"; return function () { return funcName } } let innerFunction = wrapper(); // 外部要使用内层函数，故wrapper的命名空间不会被销毁 let result = innerFunction(); console.log(result); // wrapper 基于这个特性，异步提交网络请求、处理DOM事件才变得可行。 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-07-26 18:14:36 "},"前端专栏/JavaScript/面向对象.html":{"url":"前端专栏/JavaScript/面向对象.html","title":"面向对象","keywords":"","body":"Object 基本声明 JavaScript中一切皆对象，我们可以自定义一个对象将一组功能进行整合。 对象声明方式为： 使用{}对键值对进行包裹，键值对采用k:v的形式分割，多个键值对之间使用逗号进行分割。 在声明对象时，需要注意以下2点： 键只能是String类型或者Symbol类型 键没有被引号包裹时，会自动将其转换为String类型 代码如下： \"use strict\"; let obj = { userName: \"Jack\", userAge: 18, userGender: \"male\", getInfo: function () { return `name:${this.userName}\\nage:${this.userAge}\\ngender:${this.userGender}` } }; let userMessage = obj.getInfo(); console.log(userMessage); // name:Jack // age:18 // gender:male 注意！对象是引用类型，故传递时只会传递引用地址，并不会传递值本身。 访问语法 不管是对象内部还是对象外部，我们都可以使用点来访问某个属性或方法。 如下所示： \"use strict\"; let obj = { userName: \"Jack\", userAge: 18, userGender: \"male\", getInfo: function () { return `name:${this.userName}\\nage:${this.userAge}\\ngender:${this.userGender}` } }; console.log(obj.userName); console.log(obj.userAge); console.log(obj.userGender); // Jack // 18 // male 你也可以使用[]来进行访问，但是这样的做法很少见： \"use strict\"; let obj = { userName: \"Jack\", userAge: 18, userGender: \"male\", getInfo: function () { return `name:${this.userName}\\nage:${this.userAge}\\ngender:${this.userGender}` } }; console.log(obj[\"userName\"]); console.log(obj[\"userAge\"]); console.log(obj[\"userGender\"]); // Jack // 18 // male 变量属性 当对象中的某个键是一个变量时，在声明时必须使用[]对变量名进行包裹，并且在访问时也需要使用[]对变量名进行包裹。 如下所示： \"use strict\"; let userName = Symbol(\"username\"); let obj = { [userName]: \"Jack\", userAge: 18, userGender: \"male\", getInfo: function () { return `name:${this.userName}\\nage:${this.userAge}\\ngender:${this.userGender}` } }; // 注意2者区别，变量键不加引号 // 普通键需要加上引号 console.log(obj[userName]); console.log(obj[\"userAge\"]); console.log(obj[\"userGender\"]); // Jack // 18 // male this介绍 当在对象内部要访问某个属性时，可以通过this进行访问。 this在大多数情况下总是指向当前对象，它相当于Python中的self： \"use strict\"; let obj = { userName: \"Jack\", userAge: 18, userGender: \"male\", method: function () { // this指向当前object console.log(this); } }; obj.method(); // { userName: 'Jack', // userAge: 18, // userGender: 'male', // method: [Function: method] } 箭头方法 在定义方法时，不要使用箭头函数进行定义，因为箭头函数没有this指向，他会根据上层作用域的this指向来定义，所以在箭头函数中使用this返回的永远都是window对象： \"use strict\"; let obj = { userName: \"Jack\", userAge: 18, userGender: \"male\", method:()=>{ console.log(this); } }; obj.method(); // window 简写形式 在ES6中，如果对象的键值对相同，则可以进行简写： \"use strict\"; let userName = \"Jack\"; let userAge = 18; let userGender = \"male\"; let obj = { userName, userAge, userGender, method() { console.log(\"run method...\"); } }; console.log(obj.userName); console.log(obj.userAge); console.log(obj.userGender); // Jack // 18 // male 创建对象 工厂函数 当一个函数中返回一组结构相似的对象时，该函数即可被称为工厂函数。 使用工厂函数创建对象时具有以下2点优势： 减少重复创建相同类型对象的代码 修改工厂函数的方法将影响所有同类对象 使用工厂函数，实现类似于class的功能： \"use strict\"; function Person(userName, userAge, userGender = \"male\") { return { userName, userAge, userGender, getInfo() { return `name:${this.userName}\\nage:${this.userAge}\\ngender:${this.userGender}`; } } } let insJack = Person(\"Jack\", 18); let insTom = Person(\"Tom\", 19); let insMary = Person(\"Mary\", 17, \"male\"); console.log(insJack.getInfo()); console.log(insTom.getInfo()); console.log(insMary.getInfo()); // name:Jack // age:18 // gender:male // name:Tom // age:19 // gender:male // name:Mary // age:17 // gender:male 构造函数 构造函数的作用也是用于创建对象，它比工厂函数更常用。 该函数不必显式的return一个对象，而是在使用时通过new关键字来生成一个对象。 构造函数命名风格必须采用大驼峰形式 构造函数在使用时必须通过new来创建对象 构造函数拥有this，该this不必手动声明，系统会自动生成 构造函数中的this总是指向当前创建的对象 构造函数说白了就是其他语言中的class，当然这里面还有一些非常大的区别，后面会进行介绍，如下所示： \"use strict\"; function Person(userName, userAge, userGender = \"male\") { this.userName = userName; this.userAge = userAge; this.userGender = userGender; this.getInfo = function () { return `name:${this.userName}\\nage:${this.userAge}\\ngender:${this.userGender}`; }; } let insJack = new Person(\"Jack\", 18); let insTom = new Person(\"Tom\", 19); let insMary = new Person(\"Mary\", 17, \"male\"); console.log(insJack.getInfo()); console.log(insTom.getInfo()); console.log(insMary.getInfo()); // name:Jack // age:18 // gender:male // name:Tom // age:19 // gender:male // name:Mary // age:17 // gender:male 类型转换 Symbol.toPrimitive() 如果对象内部定义了Symbol.toPrimitive()方法，它将用来处理所有的转换场景： \"use strict\"; let obj = { num: 100, [Symbol.toPrimitive]: function () { return this.num; } } console.log(1 + obj); // 101 valueOf() 对象内部定义的valueOf()方法可将对象转换任意类型： \"use strict\"; let obj = { num: 100, valueOf() { return this.num; } } console.log(1 + obj); // 101 toString() 对象内部定义的toString()方法也可将对象转换成任意类型，但是一般我们会将该对象转换为String类型以符合该方法的语义： \"use strict\"; let obj = { num: 100, description: \"this is a object\", toString(){ return this.description; } } // 模板字面量，自动调用toString方法 console.log(`${obj}`); // this is a object 解构语法 解构赋值 基本使用，外部必须由{}进行包裹： \"use strict\"; let obj = { userName: \"Jack\", userAge: 18, userGender: \"male\", userHobby: [\"basketball\", \"football\", \"volleyball\"] } // 完整写法 { 键名:赋值的变量名, ...} let { userName: n, userAge: a, userGender: g, userHobby: hobby } = obj; console.log(n, a, g, hobby); // Jack 18 male [ 'basketball', 'football', 'volleyball' ] // 简写形式，接收解构的变量名必须和键名一致 let {userName, userAge, userGender, userHobby} = obj; console.log(userName, userAge, userGender, userHobby); // Jack 18 male [ 'basketball', 'football', 'volleyball' ] 若你想一个变量接收多个被解构的元素，可使用...语法接收它们： \"use strict\"; let obj = { userName: \"Jack\", userAge: 18, userGender: \"male\", userHobby: [\"basketball\", \"football\", \"volleyball\"] } let {userName, ...other} = obj; console.log(userName, other); // Jack // { userAge: 18, userGender: 'male', userHobby: [ 'basketball', 'football', 'volleyball' ] } 此外，你也可以不填入某个需要被解构赋值的键名来达省略获取的目的： \"use strict\"; let obj = { userName: \"Jack\", userAge: 18, userGender: \"male\", userHobby: [\"basketball\", \"football\", \"volleyball\"] } let {userName, userAge} = obj; console.log(userName, userAge); // Jack 18 嵌套解构 解构多层嵌套的对象： \"use strict\"; let obj = { userName: \"Jack\", userAge: 18, userGender: \"male\", userHobby: { first: \"basketball\", second: \"football\", last: \"volleyball\" } } let { userName, userHobby: { // { 键名:赋值的变量名, ...} first: userFirstHobby, second: userSecondHobby, last: userLastHobby } } = obj; console.log(userName, userFirstHobby, userSecondHobby, userLastHobby); // Jack basketball football volleyball 默认解构 可以为一个变量设置默认值，如果解构的对象中有该变量作为键名则取消默认值采用对象中键对应的值。 \"use strict\"; let obj = { userName: \"Jack\", userAge: 18, userGender: \"male\", userHobby: { first: \"basketball\", second: \"football\", last: \"volleyball\" } } let {userName, userDesc=\"self introduction\"} = obj; console.log(userName, userDesc); // Jack self introduction 对象合并 ...语法 通过…语法，可让多个不同的对象合并成一个对象： \"use strict\"; let obj_1 = { k1: \"v1\", k2: \"v2\", }; let obj_2 = { k3: \"v3\", k4: \"v4\", }; let new_obj = { ...obj_1, ...obj_2 }; console.log(new_obj); // { k1: 'v1', k2: 'v2', k3: 'v3', k4: 'v4' } assign() 通过Object.assign()方法，可让多个不同的对象合并成一个对象： \"use strict\"; let obj_1 = { k1: \"v1\", k2: \"v2\", }; let obj_2 = { k3: \"v3\", k4: \"v4\", }; let new_obj = Object.assign(obj_1, obj_2); console.log(new_obj); // { k1: 'v1', k2: 'v2', k3: 'v3', k4: 'v4' } 对象遍历 迭代器方法 使用以下3个方法都可创建出Object迭代器，它们都会返回一个数组对象。 Object.kes() Object.values() Object.entries() 示例如下： \"use strict\"; let obj = { k1: \"v1\", k2: \"v2\", k3: \"v3\", }; console.log(Object.keys(obj)); console.log(Object.values(obj)); console.log(Object.entries(obj)); // [ 'k1', 'k2', 'k3' ] // [ 'v1', 'v2', 'v3' ] // [ [ 'k1', 'v1' ], [ 'k2', 'v2' ], [ 'k3', 'v3' ] ] for/in for/in拿到的结果始终是key： \"use strict\"; let obj = { k1: \"v1\", k2: \"v2\", k3: \"v3\", }; for (let k in obj) { console.log(k, \"->\", obj[k]); } // k1 -> v1 // k2 -> v2 // k3 -> v3 for/of 由于Object本身不属于可迭代对象，所以我们只能通过Object.kes()、Object.values()、Object.entries()手动创建出迭代器后再进行遍历操作，如下所示： \"use strict\"; let obj = { k1: \"v1\", k2: \"v2\", k3: \"v3\", }; for (let [k, v] of Object.entries(obj)) { console.log(k, \"->\", v); } // k1 -> v1 // k2 -> v2 // k3 -> v3 属性管理 添加属性 . 通过.语法直接为对象添加属性或方法； \"use strict\"; let obj = {}; obj.k1 = \"v1\"; console.log(obj.k1); // v1 删除属性 delete 使用delete可以删除非保护的属性： \"use strict\"; let obj = { k1: \"v1\", k2: \"v2\", k3: \"v3\", }; delete obj.k1; console.log(obj); // { k2: 'v2', k3: 'v3' } 计算属性 对象属性可以通过表达式计算定义，这在动态设置属性或执行属性方法时很好用。 \"use strict\"; let id = 1; let obj = { [`id-${id++}`]: id, [`id-${id++}`]: id, [`id-${id++}`]: id, [`id-${id++}`]: id, }; console.log(obj); // { 'id-1': 2, 'id-2': 3, 'id-3': 4, 'id-4': 5 } 属性封装 有一些属性我们不希望外部直接获取到，如age属性，我们可以为其进行封装： \"use strict\"; let obj = { userName: \"Jack\", userGender: \"male\", __userData: { userAge: 18, }, getAge() { return this.__userData.userAge; } }; console.log(obj.getAge()); // 18 构造函数形式： \"use strict\"; let Person = function (userName, userGender, userAge) { this.userName = userName; this.userGender = userGender; this.__userData = { userAge, } this.getAge = function(){ return this.__userData.userAge; } }; let ins = new Person(\"Jack\", \"male\", 18); console.log(ins.getAge()); // 18 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-07-28 22:55:14 "},"前端专栏/JavaScript/this指向.html":{"url":"前端专栏/JavaScript/this指向.html","title":"this指向","keywords":"","body":"this是什么 this是JavaScript中的一个关键字。 一般我们会在函数或者方法中来对它进行使用。 this和Python中的self非常像，但是又不大一样，它使用范围更广，并且自身也代表多重含义。 对于新手来说this可能是非常难迈过的一道坎，因为它的变化实在太多了，但是当你真正理解它后其实不难掌握它变化的规律。 常见this指向情况 全局环境下的this 1）严格模式中，全局环境下this指向为window对象： \"use strict\"; console.log(this); // window 2）非严格模式中，全局环境下this指向为window对象： console.log(this); // window 普通函数的this 1）严格模式中，普通函数下this指向为undefined： \"use strict\"; function show(){ console.log(this); } show(); // undefined 2）非严格模式中，普通函数下this指向为window对象： function show(){ console.log(this); } show(); // window 箭头函数的this 箭头函数没有this，大部分情况下它会继承上层作用域的this。 1）严格模式中，箭头函数下this指向为window，因为它的上层是全局作用域： \"use strict\"; let show = () => { console.log(this); } show(); // window 2）非严格模式中，箭头函数下this指向为window，因为它的上层是全局作用域： let show = () => { console.log(this); } show(); // window 对象中的this 1）严格模式中，对象下this指向当前对象： \"use strict\"; let obj = { show : function(){ console.log(this); } }; obj.show(); // { show: [Function: show] } 2）非严格模式中，对象下this指向当前对象： let obj = { show : function(){ console.log(this); } }; obj.show(); // { show: [Function: show] } 构造函数的this 1）严格模式中，构造函数下this指向构造完成后的实例对象： \"use strict\"; function A(param){ this.param = param; console.log(this); } new A(\"x\"); new A(\"y\"); // A { param: 'x' } // A { param: 'y' } 2）非严格模式中，构造函数下this指向构造完成后的实例对象： function A(param){ this.param = param; console.log(this); } new A(\"x\"); new A(\"y\"); // A { param: 'x' } // A { param: 'y' } 普通方法的this 1）严格模式中，对象的普通方法下this指向当前对象： \"use strict\"; let obj = { show : function(){ console.log(this); } }; obj.show(); // { show: [Function: show] } 2）非严格模式中，对象的普通方法下this指向当前对象： let obj = { show : function(){ console.log(this); } }; obj.show(); // { show: [Function: show] } 箭头方法的this 1）严格模式中，对象的箭头方法下this指向window对象，实际上它是跟随的obj指向，即跟随上层： \"use strict\"; let obj = { show: () => { console.log(this); } }; obj.show(); // window 2）非严格模式中，对象的箭头方法下this指向window对象，实际上它是跟随的obj指向，即跟随上层： let obj = { show: () => { console.log(this); } }; obj.show(); // window 普通闭函数的this 在包函数是个普通函数的情况下，若闭函数是普通函数则可能发生如下情况。 1）严格模式中，普通闭函数的this指向undefied： \"use strict\"; let obj = { show: function () { (function(){ console.log(this); }()) } }; obj.show(); // undefined 2）非严格模式中，普通闭函数的this指向window： let obj = { show: function () { (function(){ console.log(this); }()) } }; obj.show(); // window 箭头闭函数的this 在包函数是个普通函数的情况下，若闭函数是箭头函数则可能发生如下情况。 1）严格模式中，箭头闭函数的this跟随上层包函数的this指向： \"use strict\"; let obj = { show: function () { let inner = () => { console.log(this); } inner(); } }; obj.show(); // { show: [Function: show] } 2）非严格模式中，箭头闭函数的this跟随上层包函数的this指向： let obj = { show: function () { let inner = () => { console.log(this); } inner(); } }; obj.show(); // { show: [Function: show] } 普通事件回调函数的this 1）严格模式中，普通事件回调函数的this指向事件源本身，即元素本身： Document click me \"use strict\"; document.querySelector(\"button\").addEventListener(\"click\", function (event) { console.log(this); // click me }) 2）非严格模式中，普通事件回调函数的this指向事件源本身，即元素本身： Document click me document.querySelector(\"button\").addEventListener(\"click\", function (event) { console.log(this); // click me }) 箭头事件回调函数的this 1）严格模式中，箭头事件回调函数的this指向window对象，实际上它是跟随的addEventListener指向，即跟随上层： Document click me \"use strict\"; document.querySelector(\"button\").addEventListener(\"click\", event => { console.log(this); // window }) 2）非严格模式中，箭头事件回调函数的this指向window对象，实际上它是跟随的addEventListener指向，即跟随上层：： Document click me document.querySelector(\"button\").addEventListener(\"click\", event => { console.log(this); // window }) 若想在箭头事件回调函数中获取事件源本身，可使用event.target属性： Document click me \"use strict\"; document.querySelector(\"button\").addEventListener(\"click\", event => { console.log(event.target); // click me console.log(this); // window }) 根据上下文改变指向 我们谨记一个规律即可，对象下的this永远指向当前对象（特殊情况下除外，如代理器）。 换个简单的说法，我们可以看谁调用了个方法，那么就是谁就是this。 示例1： \"use strict\"; function show(){ console.log(this); } // 等同于 window.show(); 故this为window; 但是严格模式下普通函数的this不能为window，所以是undefined show(); // undefined 示例2： \"use strict\"; let obj = { show(){ console.log(this); } } // obj.show() 那么show中的this就指向obj obj.show(); // { show: [Function: show] } 示例3： \"use strict\"; let obj = { show: () => { console.log(this); } } // 等同于 window.obj.show()，show是箭头函数，跟随上层obj的指向，故指向window obj.show(); // window 示例4： \"use strict\"; let obj = { show: function(){ let inner = function(){ console.log(this); } // 虽然let声明的对象不会存放到window中，但若inner()前面没有任何调用者，则默认还是window // 但是严格模式下普通函数的this不能为window，所以是undefined inner(); } } obj.show(); // undefined 示例5： \"use strict\"; let obj = { show: function(){ let self = this; let inner = function(){ // 向上查找，this为obj对象 self.func(); } inner(); }, func:function(){ // 等同于obj.func() 故结果是obj对象 console.log(this); } } obj.show(); // { show: [Function: show], func: [Function: func] } 示例6： \"use strict\"; function show() { console.log(this); } let obj = { show }; // 等同于 window.show(); 故this为window; 但是严格模式下普通函数的this不能为window，所以是undefined show(); // undefined // obj.show() 那么show中的this就指向obj obj.show(); // { show: [Function: show] } 相信这6个例子看完后，你对this的指向已经了如指掌了。 改变this指向 call() 通过call()方法，让原本函数的this指向发生变化。 thisArg：新的this指向对象 argArray：需要为函数传递的参数 特点：立即执行。 如下示例，通过call()方法改变函数setAttribute()的this指向，让它为obj增添属性： \"use strict\"; function setAttribute(userName, userAge){ this.userName = userName; this.userAge = userAge; } let obj = {} // 将setAttribute的this指向改为obj，达到为obj增添属性的功能 setAttribute.call(obj, \"Jack\", 19); console.log(obj); // { userName: 'Jack', userAge: 19 } apply() apply()方法和call()的特性以及参数都一样，唯一不同的是在为函数传递参数时必须传递数组。 thisArg：新的this指向对象 argArray：需要为函数传递的参数，必须传递数组，内部会进行解构 特点：立即执行。 如下示例，通过apply()方法改变函数setAttribute()的this指向，让它为obj增添属性： \"use strict\"; function setAttribute(userName, userAge){ this.userName = userName; this.userAge = userAge; } let obj = {} // 必须传递数组 setAttribute.apply(obj, [\"Jack\", 19]); console.log(obj); // { userName: 'Jack', userAge: 19 } bind() bind()方法也可以用来改变this指向，不同的是它会返回一个新的函数，也就是说它不是立即执行的。 bind()方法的参数传递有很多种，我们只需要记住一种即可，如下示例： \"use strict\"; function setAttribute(userName, userAge){ this.userName = userName; this.userAge = userAge; } let obj = {} // 返回新函数 // 第一步，告诉需要将this对象改变成谁 let newSetAttribute = setAttribute.bind(obj); // 第二步，调用新函数，参数正常传递即可 newSetAttribute(\"Jack\", 18) console.log(obj); // { userName: 'Jack', userAge: 19 } 它们能做什么 上述介绍的三个方法用处非常大，搭配原型链可做到方法借用。 String本身没有forEach()方法，但是Array却有，我们利用上述3个方法改变this指向做到方法借用： \"use strict\"; let str = \"ABCDEF\" // 借用Array原型对象中的forEach方法，改变this指向为str，并绑定回调即可 Array.prototype.forEach.call(str, (value, index, str) => { console.log(value, index); }); // A 0 // B 1 // C 2 // D 3 // E 4 // F 5 图表总结 以下是常见this指向情况的表总结，针对实在不能理解this指向的同学，下面的情况可以预防90%的情况： 调用环境 window对象 undefined 当前对象或未来返回的实例对象 上层this指向 事件源DOM对象 全局环境 严格/非严格模式：√ 普通函数 非严格模式：√ 严格模式：√ 箭头函数 因为跟随上层this指向，所以这里是√ 严格/非严格模式：√ 对象 严格/非严格模式：√ 构造函数 严格/非严格模式：√ 普通方法 严格/非严格模式：√ 箭头方法 严格/非严格模式：√ 普通闭函数 非严格模式：√ 严格模式：√ 箭头闭函数 严格/非严格模式：√ 普通事件回调函数 严格/非严格模式：√ 箭头事件回调函数 因为跟随上层this指向，所以这里很大概率是√ 严格/非严格模式：√ 若想了解更多，可参照官方文档和阮一峰大神的文章。 官方文档 this指向的原理 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-07-27 23:07:52 "},"前端专栏/JavaScript/属性特征.html":{"url":"前端专栏/JavaScript/属性特征.html","title":"属性特征","keywords":"","body":"特征介绍 对象下每一个属性都具有一些特征。 我们可以通过设定这些特征来定制该属性是否能被删除、修改、遍历。 常见属性特征如下表所示： 特征 描述 默认值 configurable 是否能使用delete删除属性、是否允许修改属性特征、是否能够修改访问器属性 true enumerable 属性是否可被遍历到 true writable 属性是否可修改 true value 属性的默认值 undefined 查看特征 单一查看 使用Object.getOwnPropertyDescriptor()方法来查看对象下某一属性的特征： \"use strict\"; function Person(userName, userAge) { this.userName = userName; this.userAge = userAge; this.getInfo = function () { return `name : ${this.userName}\\nage : ${this.userAge}`; }; } let ins = new Person(\"Ken\", 18); let userNameFeature = Object.getOwnPropertyDescriptor(ins, \"userName\"); console.log(userNameFeature); // { // value: 'Ken', 值 // writable: true, 可修改 // enumerable: true, 可被遍历 // configurable: true 可配置 // } 查看全部 使用Object.getOwnPropertyDescriptors()方法来查看对象下所有属性的特征： \"use strict\"; function Person(userName, userAge) { this.userName = userName; this.userAge = userAge; this.getInfo = function () { return `name : ${this.userName}\\nage : ${this.userAge}`; }; } let ins = new Person(\"Ken\", 18); let instanceAttributeFeature = Object.getOwnPropertyDescriptors(ins); console.log(instanceAttributeFeature); // { // userName: // { value: 'Ken', // writable: true, // enumerable: true, // configurable: true }, // userAge: // { value: 18, // writable: true, // enumerable: true, // configurable: true }, // getInfo: // { value: [Function], // writable: true, // enumerable: true, // configurable: true } // } 设置特征 单一设置 使用Object.defineProperty()方法来对设置对象下某一属性的特征。 如下所示，userAge属性将变得不能被遍历到、不能被删除、不可再进行特征配置： \"use strict\"; function Person(userName, userAge) { this.userName = userName; this.userAge = userAge; this.getInfo = function () { return `name : ${this.userName}\\nage : ${this.userAge}`; }; Object.defineProperty(this, \"userAge\", { value: 19, // 此处的修改拥有更高的优先级 writeable: false, // 不可修改 enumerable: false, // 不可被遍历 configurable: false, // 不可再进行特征配置，不可删除，不可修改访问属性的设置 }) } let ins = new Person(\"Ken\", 18); // 不可被遍历 console.log(Object.entries(ins)); // [ [ 'userName', 'Ken' ], [ 'getInfo', [Function] ] ] // 不可修改，严格模式下抛出异常 ins.userAge = 20; // 不可删除，严格模式下抛出异常 delete ins.userAge; // 不可再进行特征配置，严格模式下抛出异常 Object.defineProperty(ins, \"userAge\", { configurable: true, }) 设置全部 使用Object.defineProperties()方法来对设置对象下全部属性的特征。 \"use strict\"; function Person(userName, userAge) { this.userName = userName; this.userAge = userAge; this.getInfo = function () { return `name : ${this.userName}\\nage : ${this.userAge}`; }; Object.defineProperties(this, { userName : { value : \"---\" + this.userName + \"---\" // 此处的修改拥有更高的优先级 }, userAge: { value: 19, // 此处的修改拥有更高的优先级 writeable: false, // 不可修改 enumerable: false, // 不可被遍历 configurable: false, // 不可再进行特征配置，不可删除，不可修改访问属性的设置 } }) } let ins = new Person(\"Ken\", 18); // 不可被遍历 console.log(Object.entries(ins)); // [ [ 'userName', '---Ken---' ], [ 'getInfo', [Function] ] ] // 不可修改，严格模式下抛出异常 ins.userAge = 20; // 不可删除，严格模式下抛出异常 delete ins.userAge; // 不可再进行特征配置，严格模式下抛出异常 Object.defineProperty(ins, \"userAge\", { configurable: true, }) 禁止添加 禁止方法 使用Object.preventExtensions()方法来对禁止再向该对象添加新属性。 \"use strict\"; function Person(userName, userAge) { this.userName = userName; this.userAge = userAge; this.getInfo = function () { return `name : ${this.userName}\\nage : ${this.userAge}`; }; // 禁止添加新属性，必须放置最后一行设置 Object.preventExtensions(this); } let ins = new Person(\"Ken\", 18); // 禁止添加新属性！抛出异常 ins.userGender = \"male\"; 判断方法 使用Object.isExtensible()方法来查看是否能向该对象中添加新属性。 \"use strict\"; function Person(userName, userAge) { this.userName = userName; this.userAge = userAge; this.getInfo = function () { return `name : ${this.userName}\\nage : ${this.userAge}`; }; // 禁止添加新属性，必须放置最后一行设置 Object.preventExtensions(this); } let ins = new Person(\"Ken\", 18); console.log(Object.isExtensible(ins)); // false 封闭对象 封闭方法 使用Object.seal()方法来封闭一个对象。 它相当于将configurable设置为false，并且会禁止添加新属性。 所体现的结果为： 不能使用delete删除属性 不能修改属性特征 不能修改访问器属性 不能添加新的属性 但是还可以修改已有属性的值，如下所示： \"use strict\"; function Person(userName, userAge) { this.userName = userName; this.userAge = userAge; this.getInfo = function () { return `name : ${this.userName}\\nage : ${this.userAge}`; }; // 封闭该对象 Object.seal(this); } let ins = new Person(\"Ken\", 18); // 可以修改已有的属性值 ins.userAge = 22; console.log(ins.userAge); // 不能删除已有属性 delete ins.userName; // 不能修改属性特征 Object.defineProperty(ins, \"userName\", { configurable : true, }) // 不能添加新的属性 ins.userGender = \"male\"; 判断方法 使用Object.isSealed()方法来判断一个对象是否已封闭。 \"use strict\"; function Person(userName, userAge) { this.userName = userName; this.userAge = userAge; this.getInfo = function () { return `name : ${this.userName}\\nage : ${this.userAge}`; }; // 封闭该对象 Object.seal(this); } let ins = new Person(\"Ken\", 18); console.log(Object.isSealed()); // true 不可变对象 冻结方法 使用Object.freeze()方法来冻结一个对象。 它相当于将configurable设置为false，并且会禁止添加新属性，禁止修改已有属性。 所体现的结果为： 不能使用delete删除属性 不能修改属性特征 不能修改访问器属性 不能添加新的属性 不能修改已有属性 如下所示： \"use strict\"; function Person(userName, userAge) { this.userName = userName; this.userAge = userAge; this.getInfo = function () { return `name : ${this.userName}\\nage : ${this.userAge}`; }; // 冻结该对象 Object.freeze(this); } let ins = new Person(\"Ken\", 18); // 不能修改已有的属性值 ins.userAge = 22; // 不能删除已有属性 delete ins.userName; // 不能修改属性特征 Object.defineProperty(ins, \"userName\", { configurable : true, }) // 不能添加新的属性 ins.userGender = \"male\"; 判断方法 使用Object.isFrozen()方法来判断一个对象是否已冻结。 \"use strict\"; function Person(userName, userAge) { this.userName = userName; this.userAge = userAge; this.getInfo = function () { return `name : ${this.userName}\\nage : ${this.userAge}`; }; // 冻结该对象 Object.freeze(this); } let ins = new Person(\"Ken\", 18); console.log(Object.isFrozen(ins)); // true Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-07-26 19:05:54 "},"前端专栏/JavaScript/属性代理.html":{"url":"前端专栏/JavaScript/属性代理.html","title":"属性代理","keywords":"","body":"属性代理 Getter/Setter Getter/Setter是JavaScript中用于提供属性代理的语法： Getter规定获取某属性时的运行逻辑 Setter规定设置某属性时的运行逻辑 注意！属性必须在普通属性和代理属性中二选一，同名属性无法同时设置为普通属性和代理属性。 如下示例，我们将实例属性userAge进行封装，并为其配置属性代理器set和get。 在设置时新的userAge值时类型必须是number，在获取时总是返回一个年龄段而不返回具体年龄： \"use strict\"; function Person(userName, userAge) { return { userName, __userData: { userAge, }, set userAge(value) { // value就是新设定的值，这里规定它必须是number类型且小于等于100岁大于0岁 if (typeof value === \"number\" && (value 0)) { // 这里一定要将被代理属性进行封装。因为 // this.userAge = value 或 this[\"userAge\"] // 都将会引发无限递归，因此，属性必须在普通属性和代理属性中二选一 this.__userData.userAge = value; return } throw new Error(\"error! type or age range error\"); }, get userAge() { let age = this.__userData.userAge; switch (true) { case age 静态方法 使用get实现一个伪属性，即不存在的属性，它实际上是一个方法，但是不加括号就可以自动运行。 如下示例，获取书籍总价格： \"use strict\"; let bookShop = { bookList: [ { book_name: \"JavaScript\", price: 99 }, { book_name: \"CSS3\", price: 80 }, { book_name: \"HTML5\", price: 72 }, ], get total() { return this.bookList.reduce((prev, cur, index, array) => { return prev + cur.price; }, 0) } }; console.log(bookShop.total); // 251 描述符代理 更推荐使用描述符进行代理，做到代理属性与普通属性的分离。 利用Object.defineProperties()方法完成： \"use strict\"; function Person(userName, userAge) { this.__userData = { userAge, userName }; Object.defineProperties(this, { userName: { set(value) { console.log(\"run set userName()\"); // 描述符代理中的this指向被代理对象 this.__userData.userName = value; }, get() { console.log(\"run get userName()\"); return this.__userData.userName } }, userAge: { set(value) { console.log(\"run set userAge()\"); this.__userData.userAge = value; }, get() { console.log(\"run get userAge()\"); return this.__userData.userAge } }, }) } // 这里不会触发代理 let ins = new Person(\"Jack\", 32); console.log(ins.userName); console.log(ins.userAge); ins.userName = \"Tom\"; ins.userAge = 18; // run get userName() // Jack // run get userAge() // 32 // run set userName() // run set userAge() 对象代理 Proxy Getter/Setter是对对象内部属性代理，一次只能设置一个。 而通过Proxy可直接为对象进行代理，如下所示： 注意！Proxy的set()方法应该返回一个布尔值，否则将会抛出异常： \"use strict\"; function Person(userName, userAge) { this.userName = userName; this.userAge = userAge; } let ins = new Person(\"Jack\", 32); // 实例化代理 const insProxy = new Proxy(ins, { get(obj, attribute) { console.log(\"run Proxy get()\"); // 不能使用.语法进行设置，因为attribute是一个String类型 return obj[attribute]; }, set(obj, attribute, value) { // set方法必须返回布尔值 console.log(\"run Proxy set()\"); try { obj[attribute] = value; return true } catch (e) { console.error(e); return false } } }); // 访问任何属性，都会触发代理 console.log(insProxy.userName); console.log(insProxy.userAge); insProxy.userName = \"Tom\"; insProxy.userAge = 18; // run Proxy get() // Jack // run Proxy get() // 32 // run Proxy set() // run Proxy set() 函数代理 Proxy还可以作为函数代理进行使用，当作为函数代理时会执行Proxy中所定义的apply()方法。 该方法包含3个参数： 被代理函数本身 上下文对象 参数 如下所示，使用函数代理统计某函数运行时长，实现类似于装饰器的功能： \"use strict\"; function factorial(num) { return num == 1 ? 1 : num * factorial(num - 1); } let proxy = new Proxy(factorial, { apply(func, obj, args) { // 添加运行时间计算的功能 console.time(\"run\"); func.apply(obj, args); console.timeEnd(\"run\"); } }); proxy.apply(this, [1, 2, 3]); // 参数传递必须是数组。 // run: 0.198ms 实用案例 双向绑定 以下是通过属性代理实现Vue等前端框架数据绑定的特性： Document \"use strict\"; function View(obj) { this.obj = obj; this.init = function () { this.obj.el = document.querySelector(this.obj.el); this.obj.el.querySelectorAll(\"[v-model]\").forEach(element => { element.addEventListener(\"keyup\", (event) => { let bind = event.target.getAttribute(\"v-model\"); let value = event.target.value; // 触发代理 this.proxy[bind] = value; // 测试 console.log(bind, \"=>\", this.obj.data[bind]); }); }); }; this.proxy = new Proxy(this.obj, { set(obj, attribute, value) { obj.data[attribute] = value; obj.el.querySelectorAll(`[v-model=${attribute}]`).forEach(element => { element.innerHTML = value; element.value = value; }) return true; } }); this.init(); } let app = new View({ el: \"#app\", data: { username: null, password: null, } }); 表单验证 使用代理来进行表单验证，验证规则写在标签属性中。 Document body { padding: 50px; background: #34495e; } input { border: solid 10px #ddd; height: 30px; } .error { border: solid 10px red; } \"use strict\"; //验证处理类 class Validate { max(value, len) { return value.length = len; } isNumber(value) { return /^\\d+$/.test(value); } } //代理工厂 function makeProxy(target) { return new Proxy(target, { get(target, key) { return target[key]; }, set(target, key, el) { const rule = el.getAttribute(\"rule\"); const validate = new Validate(); let state = rule.split(\",\").every(rule => { const info = rule.split(\":\"); return validate[info[0]](el.value, info[1]); }); el.classList[state ? \"remove\" : \"add\"](\"error\"); return true; } }); } const nodes = makeProxy(document.querySelectorAll(\"[validate]\")); nodes.forEach((item, i) => { item.addEventListener(\"keyup\", function () { nodes[i] = this; }); }); Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-08-13 22:08:08 "},"前端专栏/JavaScript/原型继承.html":{"url":"前端专栏/JavaScript/原型继承.html","title":"原型继承","keywords":"","body":"原型介绍 原型是什么 JavaScript中每个对象都有一个prototype原型对象，原型即是一个指向对象的指针。 我们知道OOP语言中有一个继承的概念，JavaScript不同于其他语言，它不是基于类的继承，而是基于原型的继承。 我们以构造函数举例： 构造函数的prototype属性即指向自己的原型对象，它的作用是为构造函数所创建出的实例对象提供公有方法和属性，且这些方法和属性是允许被继承的 实例对象的__proto__属性指向自己将要使用的原型对象 在每个构造函数的原型对象中，都有一个constructor键，它指向构造函数本身。 每个构造函数在生成时，都将会有一个默认继承了Object原型的原型对象。 如下图所示： 代码示例： \"use strict\"; function Person(userName){ this.userName = userName; } let ins = new Person(\"Jack\"); console.log(Person.prototype === ins.__proto__); console.log(ins.__proto__.__proto__ === Object.prototype); console.log(ins.__proto__.__proto__.constructor === Object); // true // true // true 获取原型对象 构造函数要获取自身的原型对象，使用属性prototype即可。 实例对象要获取原型链上第一个对象，使用属性__proto__或者Object.getPrototypeOf()方法即可。 \"use strict\"; function Person(userName){ this.userName = userName; } let ins = new Person(\"Jack\"); console.log(Person.prototype); console.log(ins.__proto__); console.log(Object.getPrototypeOf(ins)); // {constructor: ƒ} // {constructor: ƒ} // {constructor: ƒ} 一切皆对象 构造函数本身也是一个对象，因为JavaScript中一切皆对象。 构造函数所指向的原型对象是空函数，调用它将返回undefined： \"use strict\"; function Person(userName){ this.userName = userName; } let ins = new Person(\"Jack\"); console.log(Person.__proto__); // ƒ () { [native code] } 构造函数的prototype属性指向自身的原型对象，该原型对象会提供给其实例所调用的方法，如下示例： \"use strict\"; function Person(userName) { this.userName = userName; } // 为原型对象中新增一个方法show() Person.prototype.show = function(){ console.log(this); } let ins = new Person(\"Jack\"); ins.show(); // Person { userName: 'Jack' } 在原型中定义的方法是允许被继承的，在构造函数中所定义的方法是不允许继承的，接下来的继承章节中会专门指出两者之间的差距。 更改原型对象 更改原型对象的方式有很多种。 1）局部修改，添加新方法，在已有原型对象基础上进行改变。 它将影响所有其实例对象： \"use strict\"; function Person(userName) { this.userName = userName; } // 为原型对象中新增一个方法show() Person.prototype.show = function(){ console.log(this); } let ins = new Person(\"Jack\"); ins.show(); // Person { userName: 'Jack' } 2）全局修改，直接将构造函数的原型对象修改为新的一个原型对象。 它将影响所有其实例对象： \"use strict\"; function Person(userName) { this.userName = userName; } // 为原型对象中新增一个方法show() Person.prototype = { // 必须指定构造函数 constructor: Person, show() { console.log(this); } } let ins = new Person(\"Jack\"); ins.show(); // Person { userName: 'Jack' } 3）通过Object.setPrototypeOf()方法，将某个对象所使用的原型对象替换为另一个原型对象。 它将影响当前对象。 \"use strict\"; function Person(userName) { this.userName = userName; } let ins = new Person(\"Jack\"); // 更改ins所使用的原型对象 Object.setPrototypeOf(ins, { show() { console.log(this); } }) ins.show(); // 可以看到ins所使用的原型对象是不合格的，它没有constructor属性指向一个构造函数 console.log(ins.__proto__); // Person { userName: 'Jack' } // {show: ƒ} 原型链检测 instanceof运算符用于检测构造函数的prototype属性是否出现在某个实例对象的原型链上。 isPrototypeOf()方法用于测试一个对象是否存在于另一个对象的原型链上。 \"use strict\"; function Person(userName) { this.userName = userName; } let ins = new Person(\"Jack\"); // ins实例的原型链上是否包含Person的原型对象? 结果是true console.log(ins instanceof Person); // ins实例的原型链上是否包含Object的原型对象? 结果是true console.log(ins instanceof Object); // Person的原型对象是否在ins的原型链上出现过？结果是true console.log(Person.prototype.isPrototypeOf(ins)); // Object的原型对象是否在ins的原型链上出现过？结果是true console.log(Object.prototype.isPrototypeOf(ins)); // true // true // true // true 下面是instanceof的原理，其实就是不断的递归原型链并检测对象： function checkPrototype(obj, constructor) { if (!obj.__proto__) return false; if (obj.__proto__ == constructor.prototype) return true; return checkPrototype(obj.__proto__, constructor); } 使用hasOwnProperty()方法只检测对象自身所包含的属性或方法。 它不会检测原型链上继承而来的属性或方法，返回一个布尔值： \"use strict\"; // 创建原型对象 let prototypeObject = { k1: \"v1\" } // 创建对象 let A = { k2: \"v2\" }; // 修改A所使用的的原型对象 A.__proto__ = prototypeObject; console.log(A.hasOwnProperty(\"k1\")); console.log(A.hasOwnProperty(\"k2\")); // false // true 使用in检测当前对象是否能够调用某个属性或方法。 它会检测原型链上继承来的属性或方法，返回一个布尔值： \"use strict\"; // 创建原型对象 let prototypeObject = { k1: \"v1\" } // 创建对象 let A = { k2: \"v2\" }; // 修改A所使用的的原型对象 A.__proto__ = prototypeObject; console.log(\"k1\" in A); console.log(\"k2\" in A); console.log(\"k3\" in A); // false // true // false 属性遍历 for/in会按照原型链进行遍历，先遍历自身属性，然后遍历原型链： \"use strict\"; // 创建原型对象1,2,3 let prototypeObject_01 = { \"k1\": \"v1\" }; let prototypeObject_02 = { \"k2\": \"v2\", __proto__: prototypeObject_01 }; let prototypeObject_03 = { \"k3\": \"v3\", __proto__: prototypeObject_02 }; // 创建对象 let A = { \"k4\": \"v4\" } // 修改A所使用的的原型对象 A.__proto__ = prototypeObject_03; // 开始遍历 for (let k in A) { console.log(k); } // k4 // k3 // k2 // k1 原型借用 通过call()、apply()、bind()方法修改this指向，达到方法借用的目的。 String本身没有forEach()方法，但是Array却有，我们利用上述3个方法改变this指向做到方法借用： \"use strict\"; let str = \"ABCDEF\" // 借用Array原型对象中的forEach方法，改变this指向为str，并绑定回调即可 Array.prototype.forEach.call(str, (value, index, str) => { console.log(value, index); }); // A 0 // B 1 // C 2 // D 3 // E 4 // F 5 Object.create() 该方法用于创建对象。 参数1：指定该对象所使用的原型对象 参数2：该对象的具体内容，包含方法、属性等，以属性特征形式进行创建 若不填写参数2，则直接创建一个指定参数1原型的空对象 如下示例： \"use strict\"; // 创建无原型的对象 let no_prototype_obj = Object.create(null, { // 创建属性、方法 userName: { // 创建userName属性特征 value: \"Jack\", }, show: { // 创建show属性特征 value: function () { console.log(this.userName); } } }); no_prototype_obj.show(); console.log(no_prototype_obj.__proto__); // Jack // undefined // 创建有原型的对象，该对象指向Array的原型 let obj = Object.create(Array.prototype, { k1: { value: \" v1\", }, k2: { value: \" v2\", } }); console.log(obj); // Array {k1: \" v1\", k2: \" v2\"} 继承与多态 原型继承 JavaScript的继承是原型继承，且只有单继承没有多继承。 当一个对象要使用某个属性、方法时会先找自己，然后会不断的使用__proto__属性开始原型链查找。 我们可以对使用Object.setPrototypeOf()方法或者设置原型对象的__proto__属性达到原型继承的目的。 如下所示： \"use strict\"; // 3个构造函数 function A() { }; function B() { }; function C() { }; // 设置原型方法 A.prototype.f1 = function () { console.log(\"run A.prototype.f1()\"); }; B.prototype.f2 = function () { console.log(\"run B.prototype.f1()\"); }; C.prototype.f3 = function () { console.log(\"run C.prototype.f1()\"); }; // 原型继承 // B原型继承A原型 // Object.setPrototypeOf(B.prototype, A.prototype); // C原型继承B原型 // Object.setPrototypeOf(C.prototype, B.prototype); // 效果同上 // B原型继承A原型 B.prototype.__proto__ = A.prototype; // C原型继承B原型 C.prototype.__proto__ = B.prototype; // 创建实例 let ins = new C(); ins.f3(); ins.f2(); ins.f1(); // run C.prototype.f1() // run B.prototype.f1() // run A.prototype.f1() 图示如下： 方法覆写 由于查找顺序是由下而上，所以我们在最近的原型对象中写入同名方法就不会继续向上查找了。 \"use strict\"; // 3个构造函数 function A() { }; function B() { }; function C() { }; // 设置原型方法 A.prototype.show = function () { console.log(\"run A.prototype.show()\"); }; B.prototype.show = function () { console.log(\"run B.prototype.show()\"); }; // 原型继承 // B原型继承A原型 // Object.setPrototypeOf(B.prototype, A.prototype); // C原型继承B原型 // Object.setPrototypeOf(C.prototype, B.prototype); // 效果同上 // B原型继承A原型 B.prototype.__proto__ = A.prototype; // C原型继承B原型 C.prototype.__proto__ = B.prototype; // 创建实例 let ins = new C(); ins.show(); // run B.prototype.show() 为何要将方法写入原型中 我们也可以不把方法写入原型对象中，这样的方法是不能被继承的，但是其直属实例对象依旧可以调用： \"use strict\"; function A() { this.show = function () { console.log(\"A.constructor.show()\"); } } let ins = new A(); ins.show(); // A.constructor.show() 如下，构造函数B不能继承A的show()方法了： \"use strict\"; function A() { this.show = function () { console.log(\"A.constructor.show()\"); } } function B(){ } // 下面的方法都不行 // B.prototype.__proto__ = A.prototype; // B.prototype.__proto__ = A; let ins = new B(); ins.show(); // TypeError: ins.show is not a function // A.constructor.show() 如果你的构造函数和构造函数的原型对象中具有同名方法，那么会优先使用构造函数中的方法： \"use strict\"; // 3个构造函数 function A() { }; function B() { }; function C() { this.show = function(){console.log(\"run C.constructor.show()\");}}; // 设置原型方法 A.prototype.show = function () { console.log(\"run A.prototype.show()\"); }; B.prototype.show = function () { console.log(\"run B.prototype.show()\"); }; C.prototype.show = function () { console.log(\"run C.prototype.show()\"); }; // 原型继承 // B原型继承A原型 // Object.setPrototypeOf(B.prototype, A.prototype); // C原型继承B原型 // Object.setPrototypeOf(C.prototype, B.prototype); // 效果同上 // B原型继承A原型 B.prototype.__proto__ = A.prototype; // C原型继承B原型 C.prototype.__proto__ = B.prototype; // 创建实例 let ins = new C(); ins.show(); // run C.constructor.show() 多态体现 多态是指不同对象调用同一个方法但是会产生不同的结果。 JavaScript天生支持多态，如下所示： \"use strict\"; function User() { }; function Admin() { }; function Member() { }; function Enterprise() { }; // 开始继承 Admin.prototype.__proto__ = User.prototype; Member.prototype.__proto__ = User.prototype; Enterprise.prototype.__proto__ = User.prototype; // 添加原型方法 User.prototype.show = function () { return this.description() }; Admin.prototype.description = function () { return \"管理员\" }; Member.prototype.description = function () { return \"会员\" }; Enterprise.prototype.description = function () { return \"公司账户\" }; // 不同的对象都来调用description()方法，得到的结果都不一样 for (const ins of [new Admin(), new Member(), new Enterprise()]) { console.log(ins.show()); } // 管理员 // 会员 // 公司账户 深究继承 构造函数 如果多个构造函数在功能上极其相似，我们希望进行复用代码则可以利用其它函数来进行函数的构建。 如下所示： \"use strict\"; function basePerson(userName, userGender) { // 普通函数 // 注意！此时this指向undefined this.userName = userName; this.userGender = userGender; } basePerson.prototype.show = function () { return `name : ${this.userName}\\ngender : ${this.userGender}` } // 构造函数 function Man(userName) { // 构造函数this指向未来创建的实例对象，所以使用call来改变basePerson函数的this指向 basePerson.call(this, userName, \"male\"); } function Woman(userName) { // 构造函数this指向未来创建的实例对象，所以使用call来改变basePerson函数的this指向 basePerson.call(this, userName, \"female\"); } // 原型继承，让Man和Woman的原型都继承至basePerson的原型 Object.setPrototypeOf(Man.prototype, basePerson.prototype); Object.setPrototypeOf(Woman.prototype, basePerson.prototype); let j = new Man(\"Jack\"); let m = new Woman(\"Mary\"); console.log(j.show()); console.log(m.show()); // name : Jack // gender : male // name : Mary // gender : female 原型工厂 Object.setPrototypeOf()方法太长了，不好记，我们可以对Object.setPrototypeOf()方法进行封装，实现原型工厂： \"use strict\"; // 原型工厂 function inherit(child, parent) { // 亦可使用： // child.prototype.__proto__ = parent.prototype; Object.setPrototypeOf(child.prototype, parent.prototype); } // 创建构造函数 function A(){}; function B(){}; A.prototype.show = function(){console.log(\"run A.prototype.show()\");}; // B继承A inherit(B, A) let ins = new B(); ins.show(); // run A.prototype.show() 对象工厂 让构造函数复用和原型工厂结合，实现对象工厂： \"use strict\"; function User(name, age) { this.name = name; this.age = age; } User.prototype.show = function () { console.log(this.name, this.age); }; function Admin(name, age) { // 创建了一个新对象，该对象所使用原型指向User的原型对象 let instance = Object.create(User.prototype, {}); User.call(instance, name, age); instance.role = function () { console.log('admin.role'); } return instance; } let ins = Admin(\"管理员\", 19); ins.show(); // 管理员 19 MixIn机制 由于Js不支持多继承，所以想添加功能必须在某一个原型对象上不断的增加功能，这势必会让其本来的原型显得混乱不堪。 这种时候就可以使用Mixin机制来实现。 注意：Minin类应该当做工具箱来使用，而不应该作为其他类的父类被继承下来 super super属性用于在原型链上找某个属性，它智能在对象内部使用，如下示例： \"use strict\"; // 原型对象 let a = { username: \"云崖\" }; // 普通对象 let b = { __proto__: a, show() { console.log(super.username); // super会去找__proto__，相当于拿到a.username }, }; b.show(); // 云崖 本章总结 你只要捋清楚，构造函数、原型对象、实例对象之间的关系即可。 举个例子： 构造函数：爸爸 原型对象：爸爸的背包 实例对象：儿子 零食：方法或者属性 儿子要吃零食，肯定先找爸爸，爸爸身上没有就让儿子去背包里面翻，儿子如果在爸爸背包里面没翻到就会去爷爷的背包里面翻。 每个背包都有一张字体，指向这个背包的主人（constructor键）。 为什么要把零食放在背包？而不是放在人身上呢？因为如果你放在身上你的子孙后代就拿不到这包零食，但如果你放在背包里你的子孙后代就能拿到这包零食了。这就是JavaScript的原型继承本质了。 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-07-28 22:54:34 "},"前端专栏/JavaScript/class语法糖.html":{"url":"前端专栏/JavaScript/class语法糖.html","title":"class语法糖","keywords":"","body":"class 基本介绍 严格来说，JavaScript中是没有类这一个概念的。 ES6之前，我们可以通过构造函数模拟出其他语言中的类。 ES6之后，JavaScript引入了关键词class，使用它来书写面向对象的程序比用构造函数来书写面向对象的程序更加直观也更加方便。 class仅作为语法糖参与代码编写，它不是其他语言中你所认为的类，它归根结底其实还是函数。 使用class语法糖定义类，其书写的方法会全部写入到原型对象中，这个非常方便 class语法糖中书写的方法是不会被for/in遍历出来的，但是构造函数的书写方法for/in是能遍历出方法的 class代码块中默认使用严格模式进行代码执行 简单使用 使用class来定义类，命名应采用大驼峰式风格。 此外你还需要在类中书写constructor()构造方法，以接收实例对象时外部所传递的值。 类中的方法不必加上function前缀且会自动写入原型对象中，也不用使用逗号进行分割。 如下示例： \"use strict\"; class Person { constructor(userName, userAge, userGender) { this.userName = userName; this.userAge = userAge; this.userGender = userGender; } getInfo() { return `name : ${this.userName}\\nage : ${this.userAge}\\ngender : ${this.userGender}` } } let ins = new Person(\"Jack\", 18, \"male\"); console.log(ins); // Person { userName: 'Jack', userAge: 18, userGender: 'male' } 构造方法 constructor()构造方法不是必须要写的，只有当你需要为实例对象传递参数时才需要写上他。 即使你不写它系统内部也会通过super在原型链上找到该方法并执行。 相当于下面这条代码： constructor(...args){ super(...args); } 遍历差异 class中书写的方法是不会被遍历出来的，而构造函数的原型对象中书写的方法却可以被遍历出来。 这也是2者之间比较大的一个差异： \"use strict\"; class Person { constructor(userName, userAge, userGender) { this.userName = userName; this.userAge = userAge; this.userGender = userGender; } getInfo() { return `name : ${this.userName}\\nage : ${this.userAge}\\ngender : ${this.userGender}` } } let ins = new Person(\"Jack\", 18, \"male\"); for(let attr in ins){ console.log(ins[attr]); } // Jack // 18 // male 严格模式 class中书写的代码默认使用strict严格模式进行执行： class A { show() { (function () { console.log(this); }()) // 严格模式，闭函数指向undefined } } let ins = new A(); ins.show(); 原理剖析 JavaScript中没有类，所以class归根结底还是函数。 如下，这是class语法编写的类，获取它的类型结果为function： \"use strict\"; class Person { constructor(userName, userAge, userGender) { this.userName = userName; this.userAge = userAge; this.userGender = userGender; } getInfo() { return `name : ${this.userName}\\nage : ${this.userAge}\\ngender : ${this.userGender}` } } console.log(typeof Person); // function 上面这个定义与下面的构造函数定义相同： \"use strict\"; function Person(userName, userAge, userGender) { this.userName = userName; this.userAge = userAge; this.userGender = userGender; } Person.prototype.getInfo = function () { \"use strict\"; return `name : ${this.userName}\\nage : ${this.userAge}\\ngender : ${this.userGender}` }; Object.defineProperties(Person.prototype, { getInfo:{ enumerable: false, // 不可被遍历 } }); let ins = new Person(\"Jack\", 18, \"male\"); for(let attr in ins){ console.log(ins[attr]); } // Jack // 18 // male 两者一对比就会发现，class语法糖确实比构造函数+原型对象设置的方式书写代码要好很多。 类成员 类属性 类属性在JavaScript中其实应该称作静态属性，它不是为实例对象提供的而是为类本身提供的。 使用static进行声明即可： \"use strict\"; class Person { // 如果不加static，则会变成实例属性 static desc = \"Humanity\"; constructor(userName, userAge, userGender) { this.userName = userName; this.userAge = userAge; this.userGender = userGender; } getInfo() { return `name : ${this.userName}\\nage : ${this.userAge}\\ngender : ${this.userGender}` } } console.log(Person.desc); // Humanity 实现原理： \"use strict\"; function Person(userName, userAge, userGender) { this.userName = userName; this.userAge = userAge; this.userGender = userGender; } Person.desc = \"Humanity\" // ... console.log(Person.desc); 类方法 类方法和类属性都差不多，同样使用static进行声明： \"use strict\"; class Person { // 如果不加static，则会变成实例属性 static desc = \"Humanity\"; static help(){ return \"This is about class Person help information\" } constructor(userName, userAge, userGender) { this.userName = userName; this.userAge = userAge; this.userGender = userGender; } getInfo() { return `name : ${this.userName}\\nage : ${this.userAge}\\ngender : ${this.userGender}` } } console.log(Person.help()); // This is about class Person help information 实现原理： \"use strict\"; function Person(userName, userAge, userGender) { this.userName = userName; this.userAge = userAge; this.userGender = userGender; } Person.desc = \"Humanity\" Person.help = function () { return \"This is about class Person help information\" } // ... console.log(Person.help()); // This is about class Person help information 属性代理 Getter/Setter 使用get和set关键字定义用户在访问某一属性、设置某一属性时做的操作。 如下示例，我们将实例属性userAge进行封装，并为其配置属性代理器set和get。 在设置时新的userAge值时类型必须是number，在获取时总是返回一个年龄段而不返回具体年龄： \"use strict\"; class Person { // 定义绝对私有属性 #userAge; constructor(userName, userAge, userGender) { this.userName = userName; // 绝对私有，不允许外部访问或继承 this.#userAge = userAge; this.userGender = userGender; } set userAge(value) { if (typeof value === \"number\" && (value 0)) { this.#userAge = value; return } throw new Error(\"error! type or age range error\"); } get userAge() { let age = this.#userAge; switch (true) { case age 静态属性 BMI指数是用来衡量一个人的体重与身高对健康影响的一个指标，计算公式为： BMI指数计算公式: BMI = 体重(kg) / (身高m**2) BMI正常值在20至25之间，超过25为超重，30以上则属肥胖 身高或体重是不断变化的，因而每次想查看BMI值都需要通过计算才能得到，但很明显BMI听起来更像是一个特征而非功能。 所以我们可以利用get关键字来定义一个伪属性，它其实是一个方法： \"use strict\"; class Person { constructor(userName, userHight, userWeight) { this.userName = userName; this.userHight = userHight; this.userWeight = userWeight; } get bmi() { let v = this.userWeight / (this.userHight ** 2); switch (true) { case 20 25: return \"overweight\" default: return \"obesity\" } } } // 这里不会触发代理 let ins = new Person(\"Jack\", 1.75, 77); // 触发get console.log(ins.bmi); // normal 私有公有 public public指不受保护的、公开的属性。类的内部或外部及其子类均可访问或者修改该属性。 默认所有的属性都是public： class Person { constructor(name, age, gender) { this.name = name; this.age = age; this.gender = gender; } getInfo() { // ❶ 类的内部可以进行访问，也可以进行修改 return `name : ${this.name}\\nage : ${this.age}\\ngender : ${this.gender}` } setAge(age) { this.age = age; } } let person = new Person(\"Jack\", 18, \"male\"); // ❷ 类的外部也可以进行访问和修改 console.log(person.getInfo()); person.setAge(22); person.name = \"--Jack--\"; console.log(person.name); // ❸ 被继承的子类中也可以进行访问和修改 class Child extends Person { constructor(name, age, gender) { super(name, age, gender) this.name = \"Mary\"; // 可以修改 } } let child = new Child(\"Tom\", 12, \"male\"); console.log(child.getInfo()); private private指受保护的、私有的属性。仅能在当前类的内部访问或修改，外部的访问和修改是做不到的，但可通过类内部暴露的接口方法进行访问。 private属性经常与属性代理一起使用，使用#关键字定义私有属性即可： class Person { // 必须先声明私有属性 // 方法没有私有的一说，它们都是存在原型链上的，故不用声明 #name; #age; #gender; constructor(name, age, gender) { this.#name = name; this.#age = age; this.#gender = gender; } getInfo() { // ❶ 类的内部可以进行访问，也可以进行修改 return `name : ${this.#name}\\nage : ${this.#age}\\ngender : ${this.#gender}` } setAge(age) { this.age = age; } } let person = new Person(\"Jack\", 18, \"male\"); // ❷ 类的外部仅能通过类内部暴露的接口方法访问，直接访问是访问不到的 console.log(person.getInfo()); person.setAge(22); // person.#name = \"--Jack--\"; // console.log(person.#name); // ❸ 被继承的子类中不能进行访问和修改，但可以通过类内部暴露的接口方法进行访问和修改 class Child extends Person { constructor(name, age, gender) { super(name, age, gender) // this.#name = \"Mary\"; // 不可以修改 抛出异常！ } } let child = new Child(\"Tom\", 12, \"male\"); console.log(child.getInfo()); child.setAge(10); protected protected是指受保护的，半私有的属性。仅能在类的内部访问和修改，外部的访问和修改是做不到的，但它允许在子类中进行访问和修改。 下面介绍三种半私有封装方式。 下划线封装法 这是一种君子约定的封装法，使用单下划线进行封装。 它其实并不会有任何强制性措施，只是告诉使用者，请不要在外部使用该属性。 它仅作为提示功能，就像吸烟时烟盒上出现的吸烟有害健康，但还是可以抽： \"use strict\"; class Person { constructor(userName, userAge, userGender) { this.userName = userName; this._userAge = userAge; this._userGender = userGender; } getInfo() { return `name : ${this.userName}\\nage : ${this._userAge}\\ngender : ${this._userGender}` } } let ins = new Person(\"Jack\", 18, \"male\"); // 外部依然可以访问，君子约定而已 console.log(ins._userAge); console.log(ins._userGender); // 18 // male Symobl封装法 由于我们的代码都是在一个模块中进行封装的，所以使用Symbol()来进行私有封装非常的方便。 除非使用者打开源代码找到Symbol键，否则他只能通过提供的类内部暴露的接口方法来拿到数据。 \"use strict\"; let userAgeKey = Symbol(\"user userAge key\"); let userGenderKey = Symbol(\"user gender key\"); class Person { constructor(userName, userAge, userGender) { this.userName = userName; this[userAgeKey] = { userAge }; this[userGenderKey] = { userGender }; } getInfo() { // 仅能内部访问 return `name : ${this.userName}\\nage : ${this[userAgeKey].userAge}\\ngender : ${this[userGenderKey].userGender}` } } let ins = new Person(\"Jack\", 18, \"male\"); console.log(ins.getInfo()); // 外部若想访问，只能扒源码来找Symbol键 console.log(ins[userGenderKey].userGender); // name : Jack // age : 18 // gender : male // male WeakMap封装法 WeakMap有弱引用的特性，所以我们可以利用WeakMap来做私有封装。 它和Symbol封装法一样，使用者若想在外部访问被封装的实例变量，只能扒源码来找WeakMap容器： \"use strict\"; let wMap = new WeakMap(); class Person { constructor(userName, userAge, userGender) { this.userName = userName; wMap.set(this, { userAge, userGender, }) } getInfo() { // 仅能内部访问 return `name : ${this.userName}\\nage : ${wMap.get(this).userAge}\\ngender : ${wMap.get(this).userGender}` } } let ins = new Person(\"Jack\", 18, \"male\"); console.log(ins.getInfo()); // 外部若想访问，只能扒源码来找wMap容器 console.log(wMap.get(ins).userGender); // name : Jack // age : 18 // gender : male // male 类的继承 extends class通过extends关键字进行原型继承，JavaScript中只支持单继承不支持多继承。 注意，如果子类中有构造方法，那么一定要使用super()方法来调用父类的构造方法，否则将会抛出异常。 1）错误示例： \"use strict\"; class A { constructor(param) { this.param = param; } } class B extends A { // 未使用super调用父类构造方法，抛出异常 constructor(param) { this.param = param } } let ins = new B(\"x\"); console.log(ins); // ReferenceError: Must call super constructor in derived class before accessing 'this' or returning from derived constructor 2）正确示例： \"use strict\"; class A { constructor(param) { this.param = param; } } class B extends A { constructor(param) { super(param); } } let ins = new B(\"x\"); console.log(ins); // B {param: \"x\"} 3）或者你也可以不为super()方法传参： \"use strict\"; class A { show() { console.log(\"run show...\"); } } class B extends A { constructor(param) { super(); this.param = param; } } let ins = new B(\"x\"); console.log(ins); // B {param: \"x\"} 内部原理如下： \"use strict\"; function A() { }; A.prototype.show = function () { console.log(\"run show...\"); } function B(param) { A.call(this); this.param = param; } let ins = new B(\"x\"); console.log(ins); // B {param: \"x\"} super() super表示从当前原型中执行方法。 super一直指向当前对象 在构造方法中，super()一定要放在this声明的前面 super只能在类或对象的方法中使用，而不能在函数中使用，也就是说你应当使用ES6的简写语法表示该函数是一个方法，而不是利用函数关键字function进行声明 1）正确的super使用案例： \"use strict\"; class A { show() { console.log(\"run show...\"); } } class B extends A { constructor(param) { // 在构造方法中，super()一定要放在this声明的前面 super(); this.param = param; } run() { // super只能在类或对象的方法中使用，而不能在函数中使用 return super.show(); } } let ins = new B(\"x\"); ins.run(); // run show... 2）其他的super使用案例： \"use strict\"; let obj_1 = { show() { console.log(\"run show...\"); } }; let obj_2 = { __proto__: obj_1, // 由于run采用简写形式，故可以使用super run() { return super.show(); } } obj_2.run(); // run show... 3）失败的使用案例： \"use strict\"; let obj_1 = { show() { console.log(\"run show...\"); } }; let obj_2 = { __proto__: obj_1, // 出现问题，利用function定义了该方法就不能使用super run: function () { return super.show(); } } obj_2.run(); // SyntaxError: 'super' keyword unexpected here 继承类成员 extends关键字也可以继承类成员： \"use strict\"; class A { // 定义类属性 static desc = \"class A\"; } class B extends A{} console.log(B.desc); // class A Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-08-23 21:34:24 "},"前端专栏/JavaScript/JSON.html":{"url":"前端专栏/JavaScript/JSON.html","title":"JSON","keywords":"","body":"基本介绍 JSON格式是目前最火热的跨语言交互格式，它十分利于人的阅读和编写。 使用JSON数据格式是替换XML最佳方式，主流语言都很好的支持JSON格式。 JSON标准中要求使用双引号包裹属性，虽然有些语言不强制，但使用双引号可避免多程序间传输发生错误语言错误的发生。 序列化 序列化是指将数据转换为JSON字符串，一般是当前语言向其他语言传递信息时使用。 JavaScript中JSON序列化方法为JSON.stringify()。 参数释义： value：序列化的对象 replacer：指定保存的属性，如果为null则代表所有 space：格式化后对table空格的定义，默认是4空格 代码示例： \"use strict\"; let obj = { username: \"Jack\", age: 18, gender: \"male\" }; jString = JSON.stringify( obj, [\"username\", \"age\"], // 仅保留username、age属性 8 // table空格为8 ); console.log(jString); // { // \"username\": \"Jack\", // \"age\": 18 // } 反序列化 反序列化是指将JSON字符串转换为JavaScript中的数据类型，一般是当前语言接收其他语言传递信息时使用。 JavaScript中JSON反序列化方法为JSON.parse()。 参数释义： text：JSON字符串 reviver：回调函数，接收key、value参数，用于对反序列化出的数据进行二次处理 代码示例： \"use strict\"; let obj = { username: \"Jack\", age: 18, gender: \"male\" }; jString = JSON.stringify(obj); str = JSON.parse(jString, (k, v) => { if (k === \"gender\") { return v === \"male\" ? \"男\" : \"女\" } return v; }) console.log(str); // { username: 'Jack', age: 18, gender: '男' } Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-07-30 16:47:36 "},"前端专栏/JavaScript/Symbol.html":{"url":"前端专栏/JavaScript/Symbol.html","title":"Symbol","keywords":"","body":"Symbol介绍 Symbol对象是ES6中新引进的一种数据类型，主要作为对象的键而使用。 在ES6之前，对象的键必须是String类型，且不能重复。 在ES6之后，对象的键多了一种选择即Symbol对象，Symbol对象最大的特点就是具有唯一性。 唯一型Symbol 基本声明 Symbol没有构造函数，这使得我们不能new它，而是直接使用Symbol()即可。 Symbol对象具有唯一性，每个创建出的Symbol对象都是独一无二的： \"use strict\"; let first = Symbol(); let last = Symbol(); console.log(typeof first, typeof last); console.log(first === last); // symbol symbol // false 如图所示： 描述信息 在声明唯一型Symbol对象时，可以添加一段描述信息。 后面可以对唯一型Symbol对象使用description属性来获取这段描述信息，若没有描述信息时返回undefined。 如下所示，2个Symbol对象是不同的，但他们的描述信息是相同的： \"use strict\"; let first = Symbol(\"this is a description information\"); let last = Symbol(\"this is a description information\"); console.log(first === last); console.log(first.description === last.description); // false // true 引用型Symbol 基本声明 Symbol.for()方法用于创建一个全局引用的Symbol对象，后续再通过该方法创建的Symbol对象会引用第一个Symbol对象。 \"use strict\"; let first = Symbol.for(); let last = Symbol.for(); console.log(typeof first, typeof last); console.log(first === last); // symbol symbol // true 如图所示： 若2个Symbol.for()创建出的对象描述信息不同，则会认为是不同的Symbol对象： \"use strict\"; let first = Symbol.for(\"X\"); let last = Symbol.for(\"Y\"); console.log(typeof first, typeof last); console.log(first === last); // symbol symbol // false 如图所示： 描述信息 在声明引用型Symbol对象时，可以添加一段描述信息。 后面可以对引用型Symbol对象使用Symbol.keyFor()方法来获取这段描述信息，若没有描述信息时返回undefined。 注意，如果使用description属性获取引用型Symbol的描述信息的话，得到的结果永远是undefined： \"use strict\"; let first = Symbol.for(\"this is a first symbol description information\"); console.log(first.description); console.log(Symbol.keyFor(first)); // undefined // this is a first symbol description information 对象与Symbol 对象的Symbol键 JavaScript中对象的键如果直接声明内部会将其转变为String类型，这在某种程度上可能会引起键冲突问题。 对象键最好是唯一的，因此唯一型Symbol对象是最好的选择。 当我们想使用Symbol作为对象键时，需要注意1点： Symbol声明的对象键在访问使用时都不能利用.点语法进行操作，而是用利用[]语法进行操作，因为.点语法是操作字符串属性的 如下所示： \"use strict\"; \"use strict\"; let userNameKey = Symbol(\"userNameKey\"); let userAgeKey = Symbol(\"userAgeKey\"); let userGenderKey = Symbol(\"userGenderKey\"); let userMessage = { [userNameKey] : \"Jack\", [userAgeKey] : 18, [userGenderKey] : \"male\" } console.log(userMessage[userNameKey]); console.log(userMessage[userAgeKey]); console.log(userMessage[userGenderKey]); // Jack // 18 // male 遍历获取 Symbol类型的值不能被for/in、for/of遍历到。 普通的for/in、for/of、迭代器方法仅能获取对象下的String键： \"use strict\"; let userNameKey = Symbol(\"userNameKey\"); let userAgeKey = Symbol(\"userAgeKey\"); let userGenderKey = Symbol(\"userGenderKey\"); let userMessage = { [userNameKey] : \"Jack\", [userAgeKey] : 18, [userGenderKey] : \"male\", \"hobby\" : [\"basketball\", \"football\", \"volleyball\"] } for(let k in userMessage){ console.log(userMessage[k]); } for(let v of Object.values(userMessage)){ console.log(v); } // [ 'basketball', 'football', 'volleyball' ] // [ 'basketball', 'football', 'volleyball' ] 仅获取Symbol键 使用Object.getOwnPropertySymbols()获取对象下的所有Symbol键，注意仅是获取Symbol键而已： \"use strict\"; let userNameKey = Symbol(\"userNameKey\"); let userAgeKey = Symbol(\"userAgeKey\"); let userGenderKey = Symbol(\"userGenderKey\"); let userMessage = { [userNameKey]: \"Jack\", [userAgeKey]: 18, [userGenderKey]: \"male\", \"hobby\": [\"basketball\", \"football\", \"volleyball\"] } for (let k of Object.getOwnPropertySymbols(userMessage)) { console.log(userMessage[k]); } // Jack // 18 // male 获取所有的键 使用Reflect.ownKeys()获取对象下的所有键，注意仅是获取键而已： \"use strict\"; let userNameKey = Symbol(\"userNameKey\"); let userAgeKey = Symbol(\"userAgeKey\"); let userGenderKey = Symbol(\"userGenderKey\"); let userMessage = { [userNameKey]: \"Jack\", [userAgeKey]: 18, [userGenderKey]: \"male\", \"hobby\": [\"basketball\", \"football\", \"volleyball\"] } for (let k of Reflect.ownKeys(userMessage)) { console.log(userMessage[k]); } // [ 'basketball', 'football', 'volleyball' ] // Jack // 18 // male 半私有属性 我们可以使用Symbol不能被for/in以及for/of访问的特性，为类制作半私有属性以及提供访问接口。 \"use strict\"; let userAgeKey = Symbol(\"user userAge key\"); let userGenderKey = Symbol(\"user gender key\"); class Person { constructor(userName, userAge, userGender) { this.userName = userName; this[userAgeKey] = { userAge }; this[userGenderKey] = { userGender }; } getInfo() { // 仅能内部访问 return `name : ${this.userName}\\nage : ${this[userAgeKey].userAge}\\ngender : ${this[userGenderKey].userGender}` } } let ins = new Person(\"Jack\", 18, \"male\"); console.log(ins.getInfo()); // 外部若想访问，只能扒源码来找Symbol键 console.log(ins[userGenderKey].userGender); // name : Jack // age : 18 // gender : male // male Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-07-30 16:58:24 "},"前端专栏/JavaScript/Date.html":{"url":"前端专栏/JavaScript/Date.html","title":"Date","keywords":"","body":"基本介绍 JavaScript中提供了Date()对象，它用于对时间的管控。 Date()对象所包含的方法众多，下表将介绍一些常用的方法： 方法 描述 Date() 返回本地化当前完整日期的Date对象 getFullYear() 根据本地时间从Date对象中以四位数字格式返回年份 getMonth() 根据本地时间从Date对象中返回一年中的某一月（1 ~ 11） getDate() 根据本地时间从Date对象中返回一月中的某一天（1 ~ 31） getDay() 根据本地时间从Date对象中返回一周中的某一天（1 ~ 6） getHours() 根据本地时间从Date对象中返回当前天数中的的小时 (0 ~ 23) getMinutes() 根据本地时间从Date对象中返回当前小时中的分钟数 (0 ~ 59) getSeconds() 根据本地时间从Date对象中返回当前分钟数中的秒数 (0 ~ 59) getMilliseconds() 根据本地时间从Date对象中返回当前秒数中的的毫秒数 (0 ~ 999) setFullYear() 根据本地时设置Date对象中的年份（四位数字） setMonth() 根据本地时设置Date对象中月份 (0 ~ 11) setDate() 根据本地时设置Date对象中月的某一天 (1 ~ 31) setHours() 根据本地时设置Date对象中的小时 (0 ~ 23) setMinutes() 根据本地时设置Date对象中的分钟 (0 ~ 59) setSeconds() 根据本地时设置 Date 对象中的秒钟 (0 ~ 59) setMilliseconds() 根据本地时设置 Date 对象中的毫秒 (0 ~ 999) getUTCFullYear() 根据世界时间从Date对象中以四位数字格式返回年份 getUTCMonth() 根据世界时间从Date对象中返回一年中的某一月（1 ~ 11） getUTCDate() 根据世界时间从Date对象中返回一月中的某一天（1 ~ 31） getUTCDay() 根据世界时间从Date对象中返回一周中的某一天（0 ~ 6） getUTCHours() 根据世界时间从Date对象中返回当前天数中的的小时 (0 ~ 23) getUTCMinutes() 根据世界时间从Date对象中返回当前小时中的分钟数 (0 ~ 59) getUTCSeconds() 根据世界时间从Date对象中返回当前分钟数中的秒数 (0 ~ 59) getUTCMilliseconds() 根据世界时间从Date对象中返回当前秒数中的的毫秒数 (0 ~ 999) setUTCFullYear() 根据世界时设置Date对象中的年份（四位数字） setUTCMonth() 根据世界时设置Date对象中的月份 (0 ~ 11) setUTCDate() 根据世界时设置Date对象中月份的一天 (1 ~ 31) setUTCHours() 根据世界时设置Date对象中的小时 (0 ~ 23) setUTCMinutes() 根据世界时设置Date对象中的分钟 (0 ~ 59) setUTCSeconds() 根据世界时设置Date对象中的秒钟 (0 ~ 59) setUTCMilliseconds() 根据世界时设置Date对象中的毫秒 (0 ~ 999) toISOString 以ISO格式返回一个字符串值的日期 toLocaleString() 根据本地时间格式，把Date对象转换为字符串 toUCTString() 根据世界时间格式，把Date对象转换为字符串 toJson() 将时间对象格式化为JSON字符串 toDateString() 根据世界时间格式，把Date对象的日期部分转换为字符串 toLocalDateString() 根据本地时间格式，把Date对象的日期部分转换为字符串 toTimeString() 根据世界时间格式，把Date对象的时间部分转换为字符串 toLocalTimeString() 根据本地时间格式，把Date对象的时间部分转换为字符串 getTime() 根据本地时返回 1970 年 1 月 1 日至今的毫秒数，注意它返回的是Number类型 Date.parse() 返回 1970 年 1 月 1 日午夜到指定日期的毫秒数，注意它返回的是字符串类型 Date.UTC() 根据世界时返回 1970 年 1 月 1 日到指定日期的毫秒数，注意它返回的是字符串类型 setTime() 根据本地时以毫秒级别设置Date对象 getTimezoneOffset() 返回本地时间与格林威治标准时间 (GMT) 的分钟差 toString() 返回Date对象的字符表示值 valueOf() 返回Date对象的原始表示值 对象声明 以下例举最常见的使用方式： \"use strict\"; // 获取当前日期和时间，返回一个时间对象：Fri Jul 30 2021 20:18:01 GMT+0800 (中国标准时间) console.log(new Date()); // 也可以直接使用Date()，返回的是一个string类型，不能调用时间对象的方法：Fri Jul 30 2021 20:18:01 GMT+0800 (中国标准时间) console.log(Date()); // 获取本地时间戳：1627647554707 // 1970年1月1日凌晨8点0分0秒开始距离现在所经历过的时间，单位是毫秒 console.log(new Date() * 1); // 获取本地时间戳：1627647554707 console.log(Date.now()); // 填入参数，获取时间：Wed May 23 2018 12:00:12 GMT+0800 (中国标准时间) console.log(new Date(2018, 4, 23, 12, 0, 12, 13)); 时间统计 最通用的方法，以时间戳的毫秒为单位，结束时间减去开始时间： \"use strict\"; const sTime = Date.now(); for (let i = 0; i JavaScript独有的console系列方法，适用于控制台打印，单位也是毫秒： \"use strict\"; console.time(\"Statistics Time\") for (let i = 0; i 时间转换 以下是将时间对象转换为时间戳格式： \"use strict\"; const time = new Date(); // 可以与Number类型做运算得到时间戳 console.log(time * 1); console.log(Number(time)); // 可以调用时间对象内部提供的方法 console.log(time.valueOf()); console.log(time.getTime()); // 1627648373167 如果后端提供的时间戳格式，我们前端需要为它进行手动转换，如下所示，使用requestTime()函数模拟请求： \"use strict\"; function requestTime() { return new Date(1990, 2, 22, 13, 22, 19).getTime(); } const timestamp = requestTime(); console.log(new Date(timestamp)); // Thu Mar 22 1990 13:22:19 GMT+0800 (中国标准时间) 时间计算 以下是时间计算的相关演示： \"use strict\"; // 求5天后的3小时22分的时间 const time = new Date(1990, 2, 22, 13, 22, 19); // 5天后的时间 time.setDate(time.getDate() + 5); // 3小时 time.setHours(time.getHours() + 3); // 22分 time.setMinutes(time.getMinutes() + 22); // 最终结果 console.log(time); // Tue Mar 27 1990 16:44:19 GMT+0800 (中国标准时间) 时间格式化 有时候我们会觉得JavaScript提供给我们的格式不太好用，这个时候可以写一个函数自定义格式： \"use strict\"; function dateFormat(date, format = \"YYYY-MM-DD HH:mm:ss\") { const config = { YYYY: date.getFullYear(), // 获取年份 MM: date.getMonth() + 1, // 获取月份，月份+1是因为Js中的月份是0-11 DD: date.getDate(), // 获取天数 HH: date.getHours(), // 获取小时 mm: date.getMinutes(), // 获取分 ss: date.getSeconds() // 获取秒 }; for (const key in config) { format = format.replace(key, config[key]); } return format; } console.log(dateFormat(new Date(), \"YYYY年MM月DD日\")); // 2020年7月28日 moment.js Moment.js是一个轻量级的JavaScript时间库，它方便了日常开发中对时间的操作，提高了开发效率。 更多使用方法请访问 中文官网或英文官网。 在线引入： 1）获取当前时间： \"use strict\"; console.log(moment().format(\"YYYY-MM-DD HH:mm:ss\")); // 2021-07-30 20:45:58 2）时间计算： \"use strict\"; console.log(moment().add(10, \"days\").format(\"YYYY-MM-DD hh:mm:ss\")); // 2021-08-09 08:47:45 3）格式化时间： \"use strict\"; console.log(moment().format(\"YYYY-MM-DD HH:mm:ss\")); // 2021-07-30 20:45:58 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-07-30 20:48:38 "},"前端专栏/JavaScript/Math.html":{"url":"前端专栏/JavaScript/Math.html","title":"Math","keywords":"","body":"基本介绍 Math我们常叫它数学工具包，它没有构造函数所以不用new，直接使用其下所定义的数学或方法即可。 如： \"use strict\"; console.log(Math.PI); // 3.141592653589793 属性一览 以下是Math中提供的常用属性： 属性 描述 E 返回算术常量 e，即自然对数的底数（约等于2.718） LN2 返回 2 的自然对数（约等于0.693） LN10 返回 10 的自然对数（约等于2.302） LOG2E 返回以 2 为底的 e 的对数（约等于 1.414） LOG10E 返回以 10 为底的 e 的对数（约等于0.434） PI 返回圆周率（约等于3.14159） SQRT1_2 返回返回 2 的平方根的倒数（约等于 0.707） SQRT2 返回 2 的平方根（约等于 1.414） 方法一览 以下是Math中提供的常用方法： 方法 描述 abs(x) 返回数的绝对值 acos(x) 返回数的反余弦值 asin(x) 返回数的反正弦值 atan(x) 以介于 -PI/2 与 PI/2 弧度之间的数值来返回 x 的反正切值 atan2(y,x) 返回从 x 轴到点 (x, y) 的角度（介于 -PI/2 与 PI/2 弧度之间） ceil(x) 对数进行上舍入 cos(x) 返回数的余弦 exp(x) 返回 e 的指数 floor(x) 对数进行下舍入 log(x) 返回数的自然对数（底为e） max(x,y) 返回 x 和 y 中的最高值 min(x,y) 返回 x 和 y 中的最低值 pow(x,y) 返回 x 的 y 次幂 random() 返回 0 ~ 1 之间的随机数 round(x) 把数四舍五入为最接近的整数 sin(x) 返回数的正弦 sqrt(x) 返回数的平方根 tan(x) 返回角的正切 valueOf() 返回 Math 对象的原始值 取最大值 max() max()方法用于求出众多参数中的最大值： \"use strict\"; console.log(Math.max(1, 2, 3, 4)); // 4 取最小值 min() min()方法用于求出众多参数中的最小值： \"use strict\"; console.log(Math.min(1, 2, 3, 4)); // 1 对象求值 apply() 通过apply()搭配其他的一些方法，我们可以为数组、对象等进行求值。 如，求数组中的最大值： \"use strict\"; let ary = [1, 2, 3, 4]; console.log(Math.min.apply(Math, ary)); // 1 向上取整 ceil() 使用ceil()方法进行向上取整，它针对小数，即小数位只要不为0都向上进一位： \"use strict\"; let v = 33.01; console.log(Math.ceil(v)); // 34 向下取整 floor() 使用floor()方法进行向下取整，它针对小数，即抹除掉小数位： \"use strict\"; let v = 33.99; console.log(Math.floor(v)); // 33 四舍五入 round() 使用round()方法进行四舍五入： \"use strict\"; let v1 = 33.5; let v2 = 33.4; console.log(Math.round(v1)); console.log(Math.round(v2)); // 34 // 33 幂运算 pow() 使用pow()方法进行幂运算： \"use strict\"; let v = 3; // 等同于 3 ** 3，即 3*3*3 console.log(Math.pow(3, 3)); // 27 随机数 random() 1）直接使用random()方法会返回大于0小于1的浮点数： \"use strict\"; let v = Math.random(); console.log(v); // 0.20942996211521936 2）使用floor()方法搭配random()进行取整： \"use strict\"; let v = Math.floor(Math.random() * 5); console.log(v); 3）生成10 - 20 之间的整数，包括10，包括20： // 公式 Math.floor(Math.random() * (max - min + 1)) + min \"use strict\"; let v = Math.floor(Math.random() * (20 - 10 + 1)) + 10; console.log(v); 4）生成10 - 20 之间的整数，包括10，不包括20： // 公式 Math.floor(Math.random() * (max - min)) + min \"use strict\"; let v = Math.floor(Math.random() * (20 - 10)) + 10; console.log(v); 5）从数组中随机抽取一个元素项： \"use strict\"; let ary = [1, 2, 3, 4, 5]; const idx = Math.floor(Math.random() * ary.length); console.log(ary[idx]); 6）从数组中随机抽取索引 1 - 3 之间的元素，包括3： \"use strict\"; let ary = [1, 2, 3, 4, 5]; const idx = Math.floor(Math.random() * 3) + 1; console.log(ary[idx]); 7）从数组中随机抽取索引 1 - 3 之间的元素，不包括3： \"use strict\"; let ary = [1, 2, 3, 4, 5]; const idx = Math.floor(Math.random() * 2) + 1; console.log(ary[idx]); Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-07-30 21:26:18 "},"前端专栏/JavaScript/RegExp.html":{"url":"前端专栏/JavaScript/RegExp.html","title":"RegExp","keywords":"","body":"RegEXP 正则表达式其本身就是一种小型的，高度专业化的编程语言，能够非常方便的对字符串进行处理。 正则语法在各个语言中都是通用的，所以掌握它显得十分有必要。 创建正则 字面量创建 使用//包裹的字面量创建方式是推荐的作法，但它不能在其中使用变量： \"use strict\"; let str = \"hello,world\"; let reg = /^h\\w+,\\w+$/; // 创建正则对象 console.log(reg.test(str)); // true 可以使用eval()将字符串转换为Js语法来实现将变量解析到正则表达式中，但是比较麻烦： \"use strict\"; let str = \"hello,world\"; let a = \"hello\"; console.log(eval(`/${a}/`).test(str)); // 验证字符串中是否有hello // true 实例化创建 使用构造函数创建对象： \"use strict\"; let str = \"hello,world\"; let reg = new RegExp(/^h\\w+,\\w+$/) console.log(reg.test(str)); // true 当正则需要动态创建时使用这种方式将变量作为匹配规则： \"use strict\"; let str = \"hello,world\"; let a = \"hello\"; let reg = new RegExp(a); console.log(reg.test(str)); // true 基础字符 . 通配符 代表匹配除\\n外的任意字符。如果想匹配\\n可使用s模式： \"use strict\"; let str = \"hello,world\\nJavaScript-RegExp\"; // 匹配十个除开\\n外的任意字符 let reg = /........../g; console.log(str.match(reg)); // (2) [\"hello,worl\", \"JavaScript\"] ^ 开始符 ^开始符会匹配以特定字符开始的字符串，在检测时只会检测开头第一个字符并立即返回结果： \"use strict\"; let str = \"hello,world\\nJavaScript-RegExp\"; // 必须以h开始，后面必须是ello, 然后匹配五个除开\\n的任意字符。 let reg = /^hello,...../g; console.log(str.match(reg)); // [\"hello,world\"] $ 结束符 $结束符会匹配以特定字符结尾的字符串，在检测时只会检测结尾最后一个字符并立即返回结果： \"use strict\"; let str = \"hello,world\\nJavaScript-RegExp\"; // 必须以p结束，前面两个字符必须是E与x let reg = /Exp$/g; console.log(str.match(reg)); // [\"Exp\"] 重复字符 * 可有重复 *代表可以取0-∞位*号前面的字符（默认贪婪取值，可通过?取消贪婪模式）： \"use strict\"; let str_1 = \"hello,world\\nJavaScript-RegExp\"; let str_2 = \"h\\np\"; // 必须是以h开头，可以有0个也可以有多个除\\n外的任意字符，紧接\\n，可以有0个也可以有多个除\\n外的任意字符，必须以p结尾。 let reg = /^h.*\\n.*p$/g; console.log(str_1.match(reg)); console.log(str_2.match(reg)); // 上面条件只有三个是必须的 h开头，p结束，中间必须有换行\\n。所以str_2也能匹配出来 // [\"hello,world↵JavaScript-RegExp\"] // [\"h↵p\"] + 必有重复 +代表可以取1-∞位+号前面的字符（默认贪婪取值，可通过?取消贪婪模式）: \"use strict\"; let str_1 = \"hello,world\\nJavaScript-RegExp\"; let str_2 = \"h\\np\"; // 必须是以h开头，可以有0个也可以有多个除\\n外的任意字符，紧接\\n，可以有0个也可以有多个除\\n外的任意字符，必须以p结尾。 let reg = /^h.*\\n.*p$/g; // 上面条件只有三个是必须的 h开头，p结束，中间必须有换行\\n。所以str_2也能匹配出来 console.log(str_1.match(reg)); console.log(str_2.match(reg)); // [\"hello,world↵JavaScript-RegExp\"] // [\"h↵p\"] ? 单一重复 ?代表可以取1-∞位?号前面的字符（默认贪婪取值，可通过?取消贪婪模式）： \"use strict\"; let str_1 = \"123456789\"; let str_2 = \"23456789\"; // 可以以1开头，也可以不以，后面是23456789，必须是9结尾 let reg = /^1?23456789$/g; console.log(str_1.match(reg)); console.log(str_2.match(reg)); // [\"123456789\"] // [\"23456789\"] {n,m} 区间重复 {n,m}代表可以取到n-m位{n,m}前面的字符（默认贪婪取值，可通过?取消贪婪模式）: \"use strict\"; let str_1 = \"1111111\"; // 可以是3个1，也可以是4个1 let reg = /1{3,4}/g; console.log(str_1.match(reg)); // [\"1111\", \"111\"] {n} 精确重复 {n}代表可以精确取到n位{n}前面的字符： \"use strict\"; let str_1 = \"1111111\"; // 3个1 let reg = /1{3}/g; console.log(str_1.match(reg)); // [\"111\", \"111\"] 取消贪婪 默认的*，+，?，{n,m}都是贪婪取值。 即有多个就取多个，没有多个才少取。 在它们后面加上?即可取消贪婪匹配，如下示例： \"use strict\"; let str_1 = \"1111111\"; let reg_1 = /1*?/g; // 0个或者多个，取消贪婪后不取 let reg_2 = /1+?/g; // 1个或者多个，取消贪婪后取1个 let reg_3 = /1??/g; // 0个或者1个，取消贪婪后不取 let reg_4 = /1{3,4}?/g; // 3个或者4个，取消贪婪后取3个 console.log(str_1.match(reg_1)); // [\"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\"] console.log(str_1.match(reg_2)); // [\"1\", \"1\", \"1\", \"1\", \"1\", \"1\", \"1\"] console.log(str_1.match(reg_3)); // [\"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\"] console.log(str_1.match(reg_4)); // [\"111\", \"111\"] 字符集 [] 字符集 在[]中多个字符仅能匹配到1个，并且字符集中所有符号失去特殊意义，仅有- ^ \\ 这3个符号在字符集中具有特殊意义： \"use strict\"; let str_1 = \"1111111\"; let str_2 = \"2222222\"; // 1或者2，取多个 let reg_1 = /[12]+/g; console.log(str_1.match(reg_1)); console.log(str_2.match(reg_1)); // [\"1111111\"] // [\"2222222\"] [-] 区间符 字符集中的-号代表可以取从多少到多少区间的值，按照ASCII码排序，比如[a-z0-9A-Z]代表这1位取全部的英文字母和数字： \"use strict\"; let str_1 = \"12345abcde\"; // 字符可以是a-z或者0-9，取多个 let reg_1 = /[a-z0-9]+/g; console.log(str_1.match(reg_1)); // [\"12345abcde\"] [^] 排除符 字符集中的^号代表非的作用，比如[^0-9]代表这1位并非是数字： \"use strict\"; let str_1 = \"12345abcde\"; let str_2 = \"x2345abcde\"; // 不能以0-9开头，紧跟着取处\\n外的任意字符 let reg_1 = /^[^0-9].+/g; console.log(str_1.match(reg_1)); console.log(str_2.match(reg_1)); // null // [\"x2345abcde\"] [\\] 转义符 除开在字符集中使用还可以在外部使用，它可以使所有具有特殊意义的字符失去特殊意义。并且还可以为特定的字符指定意义： \"use strict\"; let str_1 = \"\\t\\n\\t\\n\"; // 取\\t或\\n let reg_1 = /[\\t\\n]+/g; console.log(str_1.match(reg_1)); // [\" ↵ ↵\"] 转义字符 \\ 转义符 转义符如果在字符集外使用，可以为特定的字符赋予特殊的意义，并且还可以让特定的字符失去特殊的意义。 如失去特殊意义： .本来是通配符，如果是.就是普通的.，再也没有任何意义了。 如下示例，匹配一个url： \"use strict\"; let str = \"www.google.com www.biying.com\"; let rule = /w{3}\\.\\w+\\.com/g; console.log(str.match(rule)); // [ 'www.google.com', 'www.biying.com' ] 以下是常用加上\\后就拥有特殊意义的字符： 符号 中文名称 释义 \\d ... 匹配任何十进制数，它相当于在字符集中使用[0-9] \\D ... 匹配任何非十进制数，它相当于在字符集中使用0-9 \\s ... 匹配任何空白字符，它相当于在字符集中使用[\\t\\n\\r\\f\\v] \\S ... 匹配任何非空白字符，它相当于在字符集中使用\\t\\n\\r\\f\\v \\w ... 匹配任何字母数字下划线字符,它相当于在字符集中使用[a-z A-Z 0-9] \\W ... 匹配任何非字母数字下划线字符,它相当于在字符集中使用[a-z A-Z 0-9] \\b ... 匹配一个特殊字符边界，比如空格,&.#等(不常用) \\d和\\D \\d可以匹配任何十进制数，它相当于在字符集中使用[0-9]： \"use strict\"; let reg = /\\d+/g; let str = \"123 abc 1a2b3c\"; console.log(str.match(reg)); // [ '123', '1', '2', '3' ] \\D可以匹配任何非十进制数，它相当于在字符集中使用[^0-9]： \"use strict\"; let reg = /\\D+/g; let str = \"123 abc 1a2b3c\"; console.log(str.match(reg)); // [ ' abc ', 'a', 'b', 'c' ] \\s和\\S \\s可以匹配任何空白字符，它相当于在字符集中使用[\\t\\n\\r\\f\\v]： \"use strict\"; let reg = /\\s/g; let str = \"123 abc 1a2b3c\"; console.log(str.match(reg)); // [ ' ', ' ' ] \\S匹配任何非空白字符，它相当于在字符集中使用[^\\t\\n\\r\\f\\v]： \"use strict\"; let reg = /\\S/g; let str = \"123 abc 1a2b3c\"; console.log(str.match(reg)); // [ '1', '2', '3', 'a', 'b', 'c', '1', 'a', '2', 'b', '3', 'c' ] \\w和\\W \\w可以匹配任何字母数字下划线字符,它相当于在字符集中使用[a-z A-Z 0-9]： \"use strict\"; let reg = /\\w+/g; let str = \"user_name123 \\t\\n\\f\"; console.log(str.match(reg)); // [ 'user_name123' ] \\W可以匹配任何非字母数字下划线字符,它相当于在字符集中使用[a-z A-Z 0-9]： \"use strict\"; let reg = /\\W+/g; let str = \"user_name123 \\t\\n\\f\"; console.log(str.match(reg)); // [ ' \\t\\n\\f' ] 管道 | 管道符 |管道符相当于或，注意与字符集里的区别，管道符将前后分为2段，左右看做1个整体，而字符集中的或仅仅代表从众多选项中拿出1个。 \"use strict\"; let str_1 = \"abcdefabcccde\"; // 取abc或者def let reg_1 = /abc|def/g; console.log(str_1.match(reg_1)); // [\"abc\", \"def\", \"abc\"] 分组 () 分组符 ()分组符将多个元素字符看做一个整体，也就是将它们当做一个元素字符进行匹配。 若整个匹配规则中无子分组，则默认的匹配结果为一组： \"use strict\"; let str_1 = \"asdfghjkl\"; let str_2 = \"asbfghjkl\"; // 必须以asd开头，必须以l结尾 let reg_1 = /^(asd)\\w+l$/g; console.log(str_1.match(reg_1)); console.log(str_2.match(reg_1)); // [\"asdfghjkl\"] // null 分组别名 组别名使用 (?匹配规则) 形式定义。 在使用match检测时需要取消g模式的全局匹配。 \"use strict\"; let str_1 = \"http://www.google.com/\"; let reg_1 = /^https?:\\/\\/w{3}\\.(?\\w+)\\.(com|cn|org|hk)/; console.log(str_1.match(reg_1)); console.dir(str_1.match(reg_1).groups.name); // [\"http://www.google.com\", \"google\", \"com\", index: 0, input: \"http://www.google.com/\", groups: {name: \"google\"}] // google 分组引用 每一个分组都有一个编号，如1,2,3,4,5。 \\num在匹配时引用原子组（匹配到的具体内容，注意不是规则），$num指在替换时使用匹配的组数据。 如下所示，将所有的\\标签替换为\\标签，使用编号替换。 \"use strict\"; let str_1 = ` hello,world hello,JavaScript PHP,no.1!!! `; // 最后的\\1代表引用第一个分组的内容，即grade组 [\\s\\S]代表匹配任意 let reg = /h[1-6])>(?[\\s\\S]*?)\\/\\1/gi; // $2 代表拿到第二个分组的内容，即content分组。 let new_str = str_1.replace(reg, `$2`); console.log(new_str); // hello,world> // hello,JavaScript> // PHP,no.1!!!> 　也可以使用别名替换。$： let new_str = str_1.replace(reg,`$`); // 拿到content分组 console.log(new_str); 记录取消 通常情况下，我们的分组会记录编号方便后面使用。 如果一个分组的内容编号不想被记录，可使用(?:)进行处理： \"use strict\"; let str_1 = \"123,abc,456\"; let reg_1 = /(?:\\d+),([a-z]+),(\\w+)/; let reg_2 = /(\\d+),([a-z]+),(\\w+)/; console.log(str_1.match(reg_1)); // (3) [\"123,abc,456\", \"abc\", \"456\", index: 0, input: \"123,abc,456\", groups: undefined] console.log(str_1.match(reg_2)); // (4) [\"123,abc,456\", \"123\", \"abc\", \"456\", index: 0, input: \"123,abc,456\", groups: undefined] // 可以看到。reg_2的长度多了一位，记录了第一个分组。 断言匹配 断言匹配虽然都有1个括号，但它们并不是子分组。 故括号中的内容也不会当做结果进行保持，可以将它们理解为匹配时的条件。 (?=exp) 零宽先行断言匹配后面为exp的内容。 \"use strict\"; let str_1 = \"hello,JavaScript\"; // 匹配出后面是,JavaScript的内容 let reg_1 = /\\w+(?=,JavaScript)/g; console.log(str_1.match(reg_1)); // [\"hello\"] (? 零宽后行断言，匹配前面为exp的内容。 \"use strict\"; let str_1 = \"hello,JavaScript\"; // 匹配出前面是hello,的内容 let reg_1 = /(?(?!exp) 零宽负向先行断言，匹配后面不能是exp的内容。 \"use strict\"; let str_1 = \"_123\"; let str_2 = \"yun23\"; let str_3 = \"123\"; // 匹配开始不能是下划线的 let reg_1 = /^(?!_)[\\w]+/g; console.log(str_1.match(reg_1)); console.log(str_2.match(reg_1)); console.log(str_3.match(reg_1)); // null // [\"yun23\"] // [\"123\"] (? (? \"use strict\"; let str_1 = \"abc123 456\"; // 前面不能是空格的三位数字 let reg_1 = /(?匹配模式 模式介绍 正则表达式在执行时会按他们的默认执行方式进行，但有时候默认的处理方式总不能满足我们的需求，所以可以使用模式修正符更改默认方式。 如下表所示： 匹配模式 描述 i 不分大小写字母的匹配模式 g 全局搜索所有匹配内容 m 视为多行的匹配模式，以\\n作为行分割符 s 视为单行的匹配模式，使用.可以匹配所有字符 y 从 regexp.lastInde 开始匹配 u 宽字符匹配模式，即支持匹配占4个字符的UTF-16匹配模式 注意，JavaScript中regexp的匹配模式可同时应用多个。 i i模式匹配时不区分大小写： \"use strict\"; let str_1 = \"HELLO,WORLD\"; let reg_1 = /hello,world/i; console.log(str_1.match(reg_1)); // [\"HELLO,WORLD\", index: 0, input: \"HELLO,WORLD\", groups: undefined] g g模式不会在第一次匹配成功后就停止，而是继续向后匹配，直到匹配完成： \"use strict\"; let str_1 = \"HELLO,WORLD\"; let reg_1 = /./g; console.log(str_1.match(reg_1)); // (11) [\"H\", \"E\", \"L\", \"L\", \"O\", \",\", \"W\", \"O\", \"R\", \"L\", \"D\"] m m模式会将每一行单独匹配，用于将内容视为多行匹配，主要是对 ^和 $的修饰： \"use strict\"; let str_1 = ` # 1.HTML5 # # 2.CSS # # 3.JavaScript # `; // g模式，全局，m模式，多行。每一行必须是多个空格开头，#号结尾。 let reg_1 = /^\\s+# \\d\\.\\w+ #$/gm; console.log(str_1.match(reg_1)); // [\"↵↵ # 1.HTML5 #\", \" # 2.CSS #\", \" s s模式将多行以一行匹配，忽略换行符\\n。这代表使用.可匹配到任意字符： \"use strict\"; let str_1 = `123\\n456\\n789`; let reg_1 =/.*/gs; console.log(str_1.match(reg_1)); // [\"123↵456↵789\", \"\"] u 每个字符都有属性，如L属性表示是字母，P表示标点符号，需要结合 u 模式才有效。 其他属性简写可以访问 属性的别名 网站查看。 如果是一些特殊的生僻字符，那么它的字节宽度可能是4字节或更多，此时就无法正确匹配出来，使用u模式可解决该问题。 \"use strict\"; let str_1 = \"𝒳𝒴\"; let reg_1 = /𝒳𝒴/g; let reg_2 = /𝒳𝒴/gu; console.log(str_1.match(reg_1)); // 结果为乱字符\"�\" console.log(str_1.match(reg_1)); // [\"𝒳𝒴\"] 字符也有Unicode文字系统，属性Script=文字系统。 下面是使用 \\p{sc=Han}获取中文字符 han为中文系统，其他语言请查看 文字语言表 \"use strict\"; let str_1 = \"Mr. Yun 云崖先生 C\"; let reg_1 = /\\p{sc=Han}+/gu; console.log(str_1.match(reg_1)); // [\"云崖先生\"] lastIndex RegExp对象lastIndex属性可以返回或者设置正则表达式开始匹配的位置。 必须结合g修饰符使用 仅对exec()方法有效 匹配完成时，lastIndex会被重置为0 如下所示： \"use strict\"; let str_1 = \"Hello,My name is YunYa,YunYa age is 19\"; let reg_1 = /YunYa.+/g; // 从索引23处开始匹配。 reg_1.lastIndex = 23; console.log(reg_1.exec(str_1)); // [\"YunYa age is 19\", index: 23, input: \"Hello,My name is YunYa,YunYa age is 19\", y g模式无论成功与否都会一直向后匹配，直到lastIndex等于length。 而y模式也是一直向后匹配，但是只要匹配不成功就会停止。 \"use strict\"; let str_1 = \"1211111\"; let reg_1 = /1/g; let reg_2 = /1/y; console.log(reg_1.exec(str_1)); // [\"1\", index: 0, input: \"1211111\", groups: undefined] console.log(reg_2.exec(str_1)); // [\"1\", index: 0, input: \"1211111\", groups: undefined] console.log(reg_1.lastIndex); // 1 console.log(reg_2.lastIndex); // 1 console.log(reg_1.exec(str_1)); // [\"1\", index: 2, input: \"1211111\", groups: undefined] console.log(reg_2.exec(str_1)); // null console.log(reg_1.lastIndex); // 3 没找到，g模式继续 console.log(reg_2.lastIndex); // 0 没找到，y模式归零 字符串方法 下面例举一些字符串中支持正则匹配的方法。 search() search() 方法用于检索字符串中指定的子字符串的索引值，也可以使用正则表达式搜索，返回值为索引位置: \"use strict\"; let str_1 = \"YunYaSir c2323182108@gmail.com\"; let reg_1 = /c\\d+@\\w+.?\\w+?\\.com/; console.log(str_1.search(reg_1)); // 9 match() match()方法可以返回出匹配到的子字符串： \"use strict\"; let str_1 = \"YunYaSir c2323182108@gmail.com\"; let reg_1 = /c\\d+@\\w+.?\\w+?\\.com/; console.log(str_1.match(reg_1)); // [\"c2323182108@gmail.com\", index: 9, input: \"YunYaSir c2323182108@gmail.com\", groups: undefined] // 查找到的内容 索引位置 被查找的字符串 分组信息 如果使用g模式，返回的内容没那么详细了： \"use strict\"; let str_1 = \"YunYaSir c2323182108@gmail.com\"; let reg_1 = /c\\d+@\\w+.?\\w+?\\.com/g; console.log(str_1.match(reg_1)); // [\"c2323182108@gmail.com\"] matchAll() matchAll()和match()使用相同，必须在g模式下使用。 但matchAll()返回一个可迭代对象，而match()返回一个数组： \"use strict\"; let str_1 = \"YunYaSir c2323182108@gmail.com c238923874@qq.com\"; let reg_1 = /c\\d+@\\w+.?\\w+?\\.com/g; let resultIter = str_1.matchAll(reg_1); for (let result of resultIter) { console.log(result); } split() 用于使用字符串或正则表达式分隔字符串。 如下示例，时间的分隔符不确定是那个，此时可以使用正则匹配。 \"use strict\"; let str_1 = \"2020-08/09\"; let reg_1 = /[-/]/g; console.log(str_1.split(reg_1)); // (3) [\"2020\", \"08\", \"09\"] replace() replace() 方法不仅可以执行基本字符替换，也可以进行正则替换，下面替换日期连接符： \"use strict\"; let str_1 = \"2020-08/09\"; let reg_1 = /[-/]/g; console.log(str_1.replace(reg_1,\"-\")); // 2020-08-09 字符串替换 替换字符串可以插入下面的特殊变量名： 变量 说明 $$ 插入一个 \"$\"。 $& 插入匹配的子串。常用 `$`` 插入当前匹配的子串左边的内容。 $' 插入当前匹配的子串右边的内容。 $n 假如第一个参数是 RegExp对象，并且 n 是个小于100的非负整数，那么插入第 n 个括号匹配的字符串。提示：索引是从1开始 将百度一下四个文字加上链接： 百度一下，你就知道 \"use strict\"; let div = document.querySelector(\"div\"); div.innerHTML = div.innerHTML.replace(\"百度一下\",\"$&\") 回调函数 replace()支持回调函数操作，用于处理复杂的替换逻辑： 回调函数参数释义： match：匹配的子串内容，相当于特殊变量$& p1, p2, … ：假如replace()方法的第一个参数是一个 RegExp 对象，则代表第n个括号匹配的字符串。（对应于上述的$1，$2等。）例如，如果是用 /(\\a+)(\\b+)/ 来进行匹配，p1 就是匹配的 \\a+，p2 就是匹配的 \\b+ offset：匹配到的子字符串在原字符串中的偏移量，即子串开始时的索引位置（比如，如果原字符串是 abcd，匹配到的子字符串是 bc，那么这个参数将会是 1） string：被匹配的原字符串 NamedCaptureGroup：命名捕获组匹配的对象 使用回调函数将百度一下四个字加上链接： 百度一下，你就知道 \"use strict\"; let div = document.querySelector(\"div\"); div.innerHTML = div.innerHTML.replace(\"百度一下\", (match, defaultGroup, source) => `${match}`) 正则对象方法 下面是RegExp正则对象提供的操作方法 test() 返回布尔值，是否验证成功。 检测输入的邮箱是否合法： \"use strict\"; let email = document.querySelector(`[name=\"email\"]`); email.addEventListener(\"keyup\", e => { console.log(/^\\w+@\\w+\\.\\w+$/.test(e.target.value)); }); exec() 不使用 g 修饰符时与 match方法使用相似，使用 g 修饰符后可以循环调用直到全部匹配完。 使用 g修饰符多次操作时使用同一个正则，即把正则定义为变量使用 使用 g修饰符最后匹配不到时返回null 示例如下，计算JavaScript共出现了几次： JavaScript的事件循环模型与许多其他语言不同的一个非常有趣的特性是，它永不阻塞。JavaScript非常优秀！ \"use strict\"; let txt = document.querySelector(\"div\").innerHTML; let reg = /(?JavaScript)/gi; let num = 0; while (reg.exec(txt)) { num++; } console.log(`JavaScript共出现:${num}次。`); Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-07-31 15:15:20 "},"前端专栏/JavaScript/window对象.html":{"url":"前端专栏/JavaScript/window对象.html","title":"window对象","keywords":"","body":"window介绍 window是一个内置的全局对象，在其中存储了许多公用的方法。 所有的浏览器都支持window对象，它并不需要我们手动的进行创建。 JavaScript中一切皆对象，故浏览器中每一个HTML文档都对应一个window对象，如下图所示： 常用方法 window中的常用方法如下： 方法 描述 alert() 显示带有一段消息和一个确认按钮的警告框 confirm() 显示带有一段消息以及确认按钮和取消按钮的对话框 prompt() 显示可接收到用户输入的对话框 open() 打开一个新窗口并进入指定网址 close() 关闭浏览器窗口 setinterval() 按照指定的周期（以毫秒计）来调用函数或计算表达式，循环调用 clearInterval() 取消由 setInterval() 设置的 timeout setTimeout() 在指定的毫秒数后调用函数或计算表达式，只调用一次 clearTimeout() 取消由 setTimeout() 方法设置的 timeout scrollTo() 移动滚动条至指定位置 此外还有4个常用子对象： 对象 描述 history 存储当前窗口的浏览记录 location 存储当前窗口的页面信息 localStorage 存储在浏览器中的信息，具有持久性 sessionStorage 存储在当前窗口的信息，具有临时性 交互框系列 alert() 显示带有一段消息和一个确认按钮的警告框： \"use strict\"; alert(\"hello,world\"); // window为全局对象，不用加前缀 显示结果： confirm() 显示带有一段消息以及确认按钮和取消按钮的对话框。 点击确定是true，取消是false： \"use strict\"; let select = confirm(\"云崖是个帅哥对吗?\"); // window为全局对象，不用加前缀 console.log(select); // 点击确定是true，取消是false 显示结果： prompt() 显示可提示用户输入的对话框。 可用变量变量接收输入的内容： \"use strict\"; let message = prompt(\"请输入信息\"); // window为全局对象，不用加前缀 console.log(message); // HELLO,WORLD 显示结果： 窗口系列 open() open()方法用于打开一个新窗口并进入指定网址。 参数详解： url：新窗口打开的网址链接 _target：一个可选的字符串，它规定了新窗口的名称，或者从何处打开新窗口，如果你填入的参数在_self、_parent、_top、_blank或者已有窗口名称之间，它将在规定处打开新窗口，如果你填入了其他参数，它将视为该新窗口的名称 features：一个可选的字符串，声明了新窗口要显示的标准浏览器的特征。如果省略该参数，新窗口将具有所有标准特征。在窗口特征这个表格中，我们对该字符串的格式进行了详细的说明。 replace： 一个可选的布尔值。规定了装载到窗口的 URL 是在窗口的浏览历史中创建一个新条目，还是替换浏览历史中的当前条目。支持下面的值：true - URL 替换浏览历史中的当前条目。false - URL 在浏览历史中创建新的条目。 代码示例： \"use strict\"; open(\"http://www.google.com\"); // 打开一个新窗口，进入指定的网址 显示结果： close() close()方法用于关闭当前的浏览器窗口。 \"use strict\"; let select = confirm(\"点击确定关闭当前窗口\"); if (select) { close() }; 显示结果： 定时器系列 setInterval() 按照指定的周期（以毫秒计）来调用函数或计算表达式，循环调用。 \"use strict\"; setInterval(() => { console.log(\"hello,world\"); }, 3000); // 每隔3000毫秒运行一次 clearInterval() 取消由setInterval()设置的timeout，这代表将不会继续循环执行setInterval()中的代码。 以下示例将演示使用setInterval()与clearInterval()制作一个定时器。 Document 开始计时 停止计时 \"use strict\"; let tag = null; function start(ele) { if (tag == null) { let time = new Date().toLocaleString(); ele.previousElementSibling.value = time; } tag = setInterval(() => { let time = new Date().toLocaleString(); ele.previousElementSibling.value = time; // 上一个兄弟标签 }, 1000); } function end(ele) { clearInterval(tag); // 取消继续循环 tag = null; ele.previousElementSibling.previousElementSibling.value = \"继续计时\"; } 还有一个复杂版的： Document main { height: 100vh; width: 100vw; display: flex; flex-flow: column nowrap; justify-content: center; align-items: center; } main div:nth-of-type(1) { padding: 1rem; background-color: #ddd; font-weight: lighter; margin-bottom: .5rem; border-radius: 50%; width: 100px; height: 100px; display: flex; justify-content: center; align-items: center; } main div:nth-of-type(2) { display: flex; border: 1px solid #ddd; padding: .5rem; } main div:nth-of-type(2) button { margin-right: .5rem; } button { color: #444444; background: #F3F3F3; border: 1px #DADADA solid; padding: 5px 10px; border-radius: 2px; font-weight: bold; font-size: 9pt; outline: none; } button:hover { border: 1px #C6C6C6 solid; box-shadow: 1px 1px 1px #EAEAEA; color: #333333; background: #F7F7F7; } button:active { box-shadow: inset 1px 1px 1px #DFDFDF; } /* Blue button as seen on translate.google.com*/ button.blue { color: white; background: #4C8FFB; border: 1px #3079ED solid; box-shadow: inset 0 1px 0 #80B0FB; } button.blue:hover { border: 1px #2F5BB7 solid; box-shadow: 0 1px 1px #EAEAEA, inset 0 1px 0 #5A94F1; background: #3F83F1; } button.blue:active { box-shadow: inset 0 2px 5px #2370FE; } /* Orange button as seen on blogger.com*/ button.orange { color: white; border: 1px solid #FB8F3D; background: -webkit-linear-gradient(top, #FDA251, #FB8F3D); background: -moz-linear-gradient(top, #FDA251, #FB8F3D); background: -ms-linear-gradient(top, #FDA251, #FB8F3D); } button.orange:hover { border: 1px solid #EB5200; background: -webkit-linear-gradient(top, #FD924C, #F9760B); background: -moz-linear-gradient(top, #FD924C, #F9760B); background: -ms-linear-gradient(top, #FD924C, #F9760B); box-shadow: 0 1px #EFEFEF; } button.orange:active { box-shadow: inset 0 1px 1px rgba(0, 0, 0, 0.3); } /* Red Google Button as seen on drive.google.com */ button.red { background: -webkit-linear-gradient(top, #DD4B39, #D14836); background: -moz-linear-gradient(top, #DD4B39, #D14836); background: -ms-linear-gradient(top, #DD4B39, #D14836); border: 1px solid #DD4B39; color: white; text-shadow: 0 1px 0 #C04131; } button.red:hover { background: -webkit-linear-gradient(top, #DD4B39, #C53727); background: -moz-linear-gradient(top, #DD4B39, #C53727); background: -ms-linear-gradient(top, #DD4B39, #C53727); border: 1px solid #AF301F; } button.red:active { box-shadow: inset 0 1px 1px rgba(0, 0, 0, 0.2); background: -webkit-linear-gradient(top, #D74736, #AD2719); background: -moz-linear-gradient(top, #D74736, #AD2719); background: -ms-linear-gradient(top, #D74736, #AD2719); } 未计时 开始计时 停止计时 清空计时 \"use strict\"; let time = document.querySelector(\"time\"); let startBTN = document.querySelector(\"button[class=blue]\"); let stopBTN = document.querySelector(\"button[class=orange]\"); let resetBTN = document.querySelector(\"button[class=red]\"); let tag = null; let timeArray = [0, 0, 0]; let len = timeArray.length; function modifyTime() { // 修改显示时间 time.innerText = timeArray.map((value, index, array) => { let v = String(value); return v.length { // 防止多次点击计时后计时器加快的bug if(tag){ return } modifyTime(); event.target.innerText = \"正在计时\"; tag = setInterval(() => { if (timeArray[len - 1] != 60) { timeArray[len - 1] += 1; } else { timeArray[len - 1] = 1 timeArray[len - 2] += 1; } if (timeArray[len - 2] == 60) { timeArray[len - 2] = 0; timeArray[len - 3] += 1; } if (timeArray[len - 3] == 24) { clearInterval(tag) } modifyTime(); }, 1000) }) stopBTN.addEventListener(\"click\", event => { if (!tag) { alert(\"未开始计时!\") return } clearInterval(tag); tag = null; startBTN.innerText = \"继续计时\"; }) resetBTN.addEventListener(\"click\", event => { clearInterval(tag); tag = null; time.innerText = \"未计时\"; startBTN.innerText = \"开始计时\"; timeArray = [0, 0, 0]; }) setTimeout() 在指定的毫秒数后调用函数或计算表达式，只调用一次。 \"use strict\"; setTimeout(() => { console.log(\"hello,world\"); }, 3000); // 3000毫秒后打印一次hello，world clearTimeout() 取消由setTimeout()设置的timeout，这代表将不会继续循环执行setTimeout()中的代码。 \"use strict\"; let tag = setTimeout(() => { alert(\"HELLO,WORLD\"); }, 1000); // 一千毫秒后将打印HELLO,WORLD let select = confirm(\"如果您点击确定，会有一个弹窗在1s后向您打招呼，如果您点击取消，则没有弹窗向您打招呼。\"); if (select == false) { clearTimeout(tag); } // 由于同步任务在宏任务之前，所以先运行同步任务。 注意事项 setInterval()和setTimeout()虽然都是以毫秒进行计时，但是本身有一个最低限度。 setInterval()的最短间隔时间是10毫秒 setTimeout()的最短时间间隔是4毫秒，也就是说，小于4毫秒的时间间隔会被调整到4毫秒 此外，由于JavaScript是单线程的，所以定时器都不是立即执行，而是在所有同步任务执行完成后才会执行。 \"use strict\"; setTimeout(() => { console.log(\"4s\"); }, 4) for (let i = 0; i history对象 基本介绍 history是window对象的一个子对象，实际应用中比较少见。 它包含用户在当前浏览器窗口中访问过的URL，通过它提供的方法可以进行前进或者后退。 相当于浏览器中这2个按键： 方法如下所示： 方法 描述 back() 加载 history 列表中的前一个URL forward() 加载 history 列表中的下一个URL go() 加载 history 列表中的某个具体页面 pushState() 向 history 列表中压入一个URL，页面会进行跳转 replaceState() 先清空 histroy 列表，再向列表中压入一个URL，页面会进行跳转，但是无法进行back操作 每次用户访问过的url，都存储在history列表中，你可以将它理解为一个栈。 back()方法是出栈操作，forward()是进栈操作，而go()方法可以从栈中任意位置调出URL元素项： back() & forward() 以下有两个h5的页面，一个为主页一个为首页。 // 主页 跳转到子页 forward // 子页 back-返回到主页 显示结果： go() 使用go()也可以达到上述效果，但是里面参数要设置成+1或者-1，这样才会跳转最近一次的页面，如果设置大于1，则跳转最近n次的页面。 // 主页 跳转到子页 go(1) // 子页 go(-1)-返回到主页 显示结果： Localtion对象 基本介绍 location对象也是window对象下的一个子对象，它主要包含了当前页面的一些信息，如URL。 常用属性： 属性 描述 hash 设置或返回从井号 (#) 开始的 URL（锚） host 设置或返回主机名和当前 URL 的端口号 hostname 设置或返回当前 URL 的主机名 href 设置或返回完整的 URL ，如果设置href，则相当于在当前页打开新的文档 pathname 设置或返回当前 URL 的路径部分 port 设置或返回当前 URL 的端口号 protocol 设置或返回当前 URL 的协议 search 设置或返回从问号 (?) 开始的 URL（查询部分） 常用方法： 方法 描述 assign() 加载新的文档 reload() 重新加载当前文档 replace() 用新的文档替换当前文档 方法案例 以下是使用location对象下提供的方法案例： \"use strict\"; location.assign(\"http://www.google.com/\"); // 页面跳转访问google，不能通过浏览器自带的back按钮返回。 location.reload(); // 刷新当前页面，类似F5刷新功能 location.replace(\"http://www.google.com/\"); // 使用google来替换当前页面，不能通过浏览器自带的back返回 localStorage & sessionStorage 基本介绍 localStorage和sessionStorage都是window对象下的2个子对象。 后端中有些数据会存储在这2个地方，比如cookie，session-key等。 localStorage中存储的信息会永久保留在浏览器中，重置浏览器后信息清除 sessionStorage中存储的信息会临时保留在当前页面中，关闭页面后信息清除 以下是它们的操作方式： localStorage.attribute = value; // 新增或修改存储信息 del localStorage.attribute // 删除存储信息 如果通过第三方工具包如$cookie进行操作就很简单，它是将数据存储在localStorage中的： 名称 作用 clear 清空localStorage上存储的数据 getItem 读取数据 hasOwnProperty 检查localStorage上是否保存了变量x，需要传入x key 读取第i个数据的名字或称为键值(从0开始计数) length localStorage存储变量的个数 propertyIsEnumerable 用来检测属性是否属于某个对象的 removeItem 删除某个具体变量 setItem 存储数据 toLocaleString 将（数组）转为本地字符串 valueOf 获取所有存储的数据 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-09-30 00:25:02 "},"前端专栏/JavaScript/DOM操作.html":{"url":"前端专栏/JavaScript/DOM操作.html","title":"DOM操作","keywords":"","body":"DOM DOM的全称为Document Object Model即为文档对象模型。 DOM支持将HTML文档转换为JavaScript的对象进行操作。 节点对象 基本介绍 HTML文档中的任何内容在JavaScript中统称为DOM节点对象。 每个节点对象都包含若干操纵方法。以下是节点对象的常用知识： 节点对象可分为12种类型 根节点对象为document，即文档本身 所有的节点对象都是Node的实例 常见节点对象有根节点、元素节点、文本节点、注释节点 节点类型与编号如下所示： 节点类型 类型编号 元素节点 1 属性节点 2 文本节点 3 CDATA节点 4 实体引用名称节点 5 实体名称节点 6 处理指令节点 7 注释节点 8 文档节点 9 文档类型节点 10 文档片段节点 11 DTD声明节点 12 代码示例： Document \"use strict\"; console.log(document.body.nodeType); // 1 body标签，元素节点 let main = document.getElementById(\"main\"); console.log(main.attributes[0].nodeType); // 2 main标签的id属性也是一个节点。属性节点 console.log(main.firstChild.nodeType); // 3 main标签下的第一个子标签 即空白行。文本节点 console.log(main.lastChild.nodeType); // 3 main标签下的第一个子标签 即空白行。文本节点 console.log(main.COMMENT_NODE); // 8 main标签下的注释标签。 注释节点 console.log(document.nodeType); // 9 document也是一个节点。文档节点 console.log(document.childNodes.item(0).nodeType); // 10 文档类型节点 节点原型链 对每一种类型的节点对象进行原型链的攀升，可得到如下结论： 原型 说明 Object 根对象 EventTarget 提供事件支持 Node 提供parentNode等节点关系操作方法的支持 Element 提供getElementsByTagName()、querySelector()等节点查找方法的支持 HTMLElement 所有元素的基础类，提供className、nodeName等节点标准属性的支持 HTMLHeadingElement Head标题元素类 以下以元素节点标签为例，它的最终原型对象为ElementTarget.proptrpy： Document \"use strict\"; let main = document.getElementById(\"main\"); console.log(main.__proto__); console.log(main.__proto__.__proto__); console.log(main.__proto__.__proto__.__proto__); console.log(main.__proto__.__proto__.__proto__.__proto__); console.log(main.__proto__.__proto__.__proto__.__proto__.__proto__); 如图所示： 节点对象属性 nodeType 每个节点对象都有nodeType属性，它返回节点类型的编号。 节点类型 类型编号 元素节点 1 属性节点 2 文本节点 3 CDATA节点 4 实体引用名称节点 5 实体名称节点 6 处理指令节点 7 注释节点 8 文档节点 9 文档类型节点 10 文档片段节点 11 DTD声明节点 12 以下是nodeType属性的基本使用： Document \"use strict\"; console.log(document.querySelector(\"h1\").nodeType); // 1 使用对象原型进行检测： Document \"use strict\"; console.log(document.querySelector(\"h1\") instanceof Element); // true nodeName nodeName属性可供任何类型的节点对象使用，其作用是获取节点名称： 节点类型 类型编号 节点名称 元素节点 1 元素名称（返回值为全大写形式） 属性节点 2 属性名称 文本节点 3 #text 注释节点 8 #comment 表格释义： 对类型编号为1的元素节点对象使用nodeName属性，将返回元素名称 对类型编号为8的注释节点对象使用nodeName属性，将返回#comment 如下所示： Document hello，world 标题 文本 \"use strict\"; let h1 = document.querySelector(\"h1\"); let h2Attr = document.querySelector(\"h2\").attributes[0]; let comment = document.body.childNodes[5]; let text = document.body.childNodes[6]; // 获取为大写形式 console.log(h1.nodeName); // H1 console.log(h2Attr.nodeName); // class console.log(comment.nodeName); // #comment console.log(text.nodeName); // #text console.log(document.body.nodeName); // BODY tagName tagName属性只供元素节点对象使用，其作用是获取节点名称： tagName属性存在于Elment原型中 对元素节点使用tagName或nodeName没有任何差异 该属性获取的值都是全大写形式的 代码示例： Document hello，world 标题 文本 \"use strict\"; console.log(document.querySelector(\"h1\").tagName); // H1 console.log(document.body.tagName); // BODY nodeValue 使用nodeValue属性或data属性获取节点值。 它仅针对非元素节点使用，元素节点使用该属性总是返回null： Document hello，world 标题 文本 \"use strict\"; let h1 = document.querySelector(\"h1\"); let h2Attr = document.querySelector(\"h2\").attributes[0]; let comment = document.body.childNodes[5]; let text = document.body.childNodes[6]; console.log(h1.nodeValue); // null 元素节点获取不到值 console.log(h2Attr.nodeValue); // show console.log(comment.data); // 注释 console.log(text.data); // 文本 document对象 基本介绍 document是window的一个子对象，是由HTMLDocument实现的实例。 document对象的原型链中包含Node，所以可以使用所有节点操作方法与属性，如nodeType/nodeName等。 文档信息 系统为document对象提供了一些属性，可以快速获取一些常用信息。 属性 说明 title 获取和设置当前HTML文档标题 URL 获取当前HTML文档的URL domain 获取当前HTML文档的域名 referrer 获取当前HTML文档的来源地址 1）使用title属性可或获取和设置当前HTML文档标题： Document \"use strict\"; console.log(document.title); setTimeout(() => { document.title = \"DOM LEARN\" }, 1000); // 1s后修改页面title 2）使用URL属性可获取当前HTML文档的URL： Document \"use strict\"; console.log(document.URL); // http://localhost:5500/ 3）使用domain属性可获取当前HTML文档的域名： Document \"use strict\"; console.log(document.domain); // localhost 4）使用referrer属性可获取当前HTML文档的来源地址，可用于页面引流统计或者防盗链上： Document \"use strict\"; console.log(document.referrer); // http://localhost:5500/ 元素节点获取 手动获取所有元素节点 下面将通过使用节点的nodeType属性判断并获取所有的元素节点。 let html = [...document.childNodes].filter((node) => { if (node.nodeType === 1) { return node } })[0] console.log(html) 快速获取元素节点一览 如果只想获取元素节点，可通过下面的属性或方法进行快速获取。 属性/方法 描述 返回值 普通节点对象是否可调用 document.documentElement 获取html元素节点 node 否 document.body 获取body元素节点 node 否 document.head 获取head元素节点 node 否 document.links 获取a元素节点集合 HTMLCollection 否 document.anchors 获取具有name属性的a元素节点集合 HTMLCollection 否 document.forms 获取form元素节点集合 HTMLCollection 否 document.images 获取img元素节点集合 HTMLCollection 否 document.getElmentById() 根据id属性获取元素节点 node 否 document.getElmentByName() 根据name属性获取元素节点集合 NodeList 否 document.getElmentByTagName() 根据tagName属性获取元素节点集合 HTMLCollection 是 document.getElmentByClassName() 根据class属性获取元素节点集合 HTMLCollection 是 document.querySelectorAll() 根据CSS选择器获取元素节点集合 NodeList 是 document.querySelector() 根据CSS选择器获取元素节点 node 是 document.documentElement document.documentElement属性可获取HTML标签。 注意！仅能在document对象中使用该属性！ 它返回单一被选中的元素节点： Document \"use strict\"; console.log(document.documentElement); // html document.body document.body属性可获取body标签。 注意！仅能在document对象中使用该属性！ 它返回单一被选中的元素节点： Document \"use strict\"; console.log(document.body); // body document.head document.head属性可获取head标签。 注意！仅能在document对象中使用该属性！ 它返回单一被选中的元素节点： Document \"use strict\"; console.log(document.head); // head document.links document.links属性可获取所有的a标签。 注意！仅能在document对象中使用该属性！ 它返回HTMLCollection元素集合对象： Document first second last \"use strict\"; console.log(document.links); // HTMLCollection(3) [a, a, a] document.anchors document.anchors属性可获取所有具有name属性的的a标签锚点。 注意！仅能在document对象中使用该属性！ 它返回HTMLCollection元素集合对象： Document first second last \"use strict\"; console.log(document.anchors); // HTMLCollection(2) [a, a, first: a, second: a] document.forms document.links属性可获取所有的form标签。 注意！仅能在document对象中使用该属性！ 它返回HTMLCollection元素集合对象： Document \"use strict\"; console.log(document.forms); // HTMLCollection(3) [form, form, form] document.images document.images属性可获取所有的img标签。 注意！仅能在document对象中使用该属性！ 它返回HTMLCollection元素集合对象： Document \"use strict\"; console.log(document.images); // HTMLCollection(3) [img, img, img] document.getElmentById() document.getElmentById()方法可根据id属性获取元素节点。 注意！仅能在document对象中使用该方法！ 它返回单一被选中的元素节点： Document \"use strict\"; console.log(document.getElementById(\"div-1\")); // 拥有标准属性id的元素可做为window对象的属性进行访问，但注意不要与变量名进行重合，所以不推荐这种方式。 这也是为什么推荐在为标签id属性取名的时候用-进行分割而不是用_进行分割的原因。 Document \"use strict\"; console.log(first_div); // document.getElmentByName() document.getElmentByName()方法可根据name属性获取元素节点集合。 注意！仅能在document对象中使用该方法！ 该方法通常用于获取表单元素标签，但实际上只要有name属性的标签它都能获取到 它返回NodeList元素集合对象： Document \"use strict\"; let nameAttributeElementCollection = document.getElementsByName(\"username\") console.log(nameAttributeElementCollection); // NodeList(2) [input, p] document.getElmentByTagName() document.getElmentByTagName()方法可根据tagName属性获取元素节点集合。 注意！不论是document对象还是普通的节点对象都能使用该方法！ 元素名不区分大小写 可使用通配符*获取所有元素节点 它返回HTMLCollection元素集合对象： Document \"use strict\"; let divCollection = document.getElementsByTagName(\"div\"); console.log(divCollection); let timeCollection = divCollection[2].getElementsByTagName(\"time\"); console.log(timeCollection); // HTMLCollection(3) [div#div-1, div#div-2, div#div-3, div-1: div#div-1, div-2: div#div-2, div-3: div#div-3] // HTMLCollection [time] document.getElmentByClassName() document.getElmentByClassName()方法可根据class属性获取元素节点集合。 注意！不论是document对象还是普通的节点对象都能使用该方法！ 它返回HTMLCollection元素集合对象： Document 1 2 A B \"use strict\"; let nodeMain = document.getElementsByTagName(\"main\")[0]; let classListCollection = nodeMain.getElementsByClassName(\"list\") console.log(classListCollection); // HTMLCollection(3) [ul.list, li.list, li.list] querySelectorAll() document.querySelectorAll()方法可根据CSS Selectors获取元素节点集合。 注意！不论是document对象还是普通的节点对象都能使用该方法！ CSS的:checked选择器能够获取所有已被选中的radio、checkbox元素，而使用querySelectorAll(“:checked”)仅能获取所有默认被选中的radio、checkbox元素 它返回NodeList元素集合对象： Document 1 2 3 A B C \"use strict\"; console.log(document.querySelectorAll(\"main section article:first-of-type\")); // NodeList [article] console.log(document.querySelectorAll(\"main nav ul li\")); // NodeList(3) [li, li, li] console.log(document.querySelectorAll(\"main section article:nth-child(2)\")); // NodeList [article] querySelector() document.querySelector()方法可根据CSS Selectors获取元素节点。 注意！不论是document对象还是普通的节点对象都能使用该方法！ 如果有多个符合条件的元素，则只返回第一个，也就是说它相当于document.querySelectorAll()[0] CSS的:checked选择器能够获取所有已被选中的radio、checkbox元素，而使用querySelector(“:checked”)仅能获取一个默认被选中的radio、checkbox元素 它返回单一被选中的元素节点： Document 1 2 3 A B C \"use strict\"; console.log(document.querySelector(\"main:nth-child(2) ul li\")); // 1 表单项查找 组合查找 JavaScript为表单的查找提供了单独的属性接口： 使用document.forms可获取所有的表单元素 根据form的name属性获取单独的表单元素 使用form.elements可获取表单元素下的所有表单项元素 根据表单项的name属性使用form.elements.title可获取单独的表单项元素，它可以直接简写成form.name 针对form.name获取到radio或者checkbox，返回的结果将是一个集合而不是单独的表单项元素 示例如下： \"use strict\"; let formCollection = document.forms; // 获取所有表单 let formNode = formCollection.register; // 根据name获取某个表单 let formChildren = formNode.elements; // 拿到其下所有表单项 let username = formNode.elements.username; // 拿到name为username的表单项 console.log(formChildren); // HTMLFormControlsCollection(2) [input, input, username: input, pwd: input] console.log(username); // 获取被选中的单、复选框 单纯的使用:checked选择器，只会找到默认被选中的单选框、复选框、以及option，对于后续手动添加的单选框复选框是检测不到的。 若想获取所有被选中的单、复选框，只有循环单选框、复选框列表，判定其是否具有属性checked才行。 如下所示： 男 女 篮球 足球 排球 检测 \"use strict\"; let btnNode = document.querySelector(\"button\"); let radioAndCheckboxNodeList = document.forms.register.querySelectorAll(\"input[type=radio], input[type=checkbox]\"); btnNode.addEventListener(\"click\", (event) => { let checkedRadioCheckbox = Array.from(radioAndCheckboxNodeList).filter((element, index) => { return element.checked }) console.log(checkedRadioCheckbox); }); 获取select选中值 如果想获取select中被选中的option，则可使用以下方法： 先获取select标签 根据select节点的options属性获取其下所有的option的集合 循环遍历options集合，判断option是否具有selected属性 如下所示： 北京 上海 深圳 广州 检测 \"use strict\"; let btnNode = document.querySelector(\"button\"); let selectNode = document.forms.register.city; btnNode.addEventListener(\"click\", (event) => { let selectedOption = Array.from(selectNode.options).filter((element, index, array) => { return element.selected; }); console.log(selectedOption); }) 获取file的文件对象 如果想获取一个文件选择框中的文件对象，则可使用以下方法： 先获取input标签 根据input节点的files属性获取其下所有的已上传文件的集合 根据已上传文件集合的索引操作，获取你想要的文件对象 如下所示： 检测 \"use strict\"; let btnNode = document.querySelector(\"button\"); let fileInputNode = document.forms.register.avatar; btnNode.addEventListener(\"click\", (event) => { console.log(fileInputNode.files); // 可使用索引操作，获取你想要的文件对象 }); 元素节点筛选 属性筛选 matches() matches()方法验证某一个节点是否具有特定属性。 如下示例，我们获取了所有的元素节点，现在要通过Array原型借用filter()方法筛选出具有show属性的元素： Document \"use strict\"; let allElementNodeList = document.querySelectorAll(\"*\"); let showElementArray = Array.prototype.filter.call(allElementNodeList, (element, index, nodelst) => { return element.matches(\"[show]\"); }) console.log(showElementArray); // (2) [div, mark] 祖先筛选 closest() closest()方法会查找最近的符合选择器的祖先元素（包括自身）。 找祖先，看最近的祖先能不能被选择器选中，如果不能继续向上找。 如下示例，我们获取了.float元素，需要查找它的祖先中具有show属性的标签： Document \"use strict\"; let floatNode = document.querySelector(\".float\"); console.log(floatNode.closest(\".show\")); // ... 节点关系获取 普通节点关系获取一览 节点对象可通过以下属性可获取与其他节点之间关系。 它们包含文本节点与注释节点： 节点属性 描述 返回值 childNodes 获取子节点对象 node parentNode 获取父节点对象 NodeList firstChild 获取第一个子节点对象 node lastChild 获取最后一个子节点对象 node previousSibling 获取上一个兄弟节点对象 node nextSibling 获取下一个兄弟节点对象 node 由于使用的较少，这里不再进行演示，注意2点： 换行也包括在节点关系中，它是一个单独的#text文本节点 文本节点不能作为父节点，因为它不会嵌套任何子节点 元素节点关系获取一览 节点对象可通过以下属性获取与其他元素节点之间的关系。 它们不包含文本节点与注释节点，所以是非常常用的。 节点属性 描述 返回值 parentElement 获取父元素节点对象 node children 获取子元素节点对象 HTMLCollection childElementCount 获取子元素节点对象的数量 number firstElementChild 获取第一个子元素节点对象 node lastElementChild 获取最后一个子元素节点对象 node previousElementSibling 获取上一个兄弟元素节点对象 node nextElementSibling 获取下一个兄弟元素节点对象 node parentElment parentElment属性用于获取父元素节点对象，它返回单一被选中的元素节点： Document 1 2 3 4 5 6 7 \"use strict\"; let ulNode = document.querySelector(\"ul\"); console.log(ulNode.parentElement); // main children children属性用于获取子元素节点对象，它返回HTMLCollection元素集合对象： Document 1 2 3 4 5 6 7 \"use strict\"; let ulNode = document.querySelector(\"ul\"); console.log(ulNode.children); // HTMLCollection(7) [li#li-1, li#li-2, li#li-3, li#li-4, li#li-5, li#li-6, li#li-7, li-1: li#li-1, li-2: li#li-2, li-3: li#li-3, li-4: li#li-4, li-5: li#li-5, …] firstElementChild firstElementChild属性用于获取第一个子元素节点对象，它返回单一被选中的元素节点： Document 1 2 3 4 5 6 7 \"use strict\"; let ulNode = document.querySelector(\"ul\"); console.log(ulNode.firstElementChild); // li#li-1 lastElmentChild lastElementChild属性用于获取最后一个子元素节点对象，它返回单一被选中的元素节点： Document 1 2 3 4 5 6 7 \"use strict\"; let ulNode = document.querySelector(\"ul\"); console.log(ulNode.lastElementChild); // li#li-7 previousElementSibling previousElementSibling属性用于获取上一个兄弟元素节点对象，它返回单一被选中的元素节点： Document 1 2 3 4 5 6 7 \"use strict\"; let mainNode = document.querySelector(\"main\"); console.log(mainNode.previousElementSibling); // header nextElementSibling nextElementSibling属性用于获取下一个兄弟元素节点对象，它返回单一被选中的元素节点： Document 1 2 3 4 5 6 7 \"use strict\"; let mainNode = document.querySelector(\"main\"); console.log(mainNode.nextElementSibling); // footer 元素节点集合对象 基本介绍 JavaScript中共有2种元素节点集合对象，分别是NodeList和HTMLCollection。 它们的相同点在于： 都是类数组 都具有length属性 都可以用index进行元素项访问 都提供了item()方法来根据index操纵元素项 都实现了迭代器协议，可以通过for/of进行遍历 它们的不同点在于： NodeList是动态映射DOM的（querySelectorAll()方法获得的NodeList除外），而HTMLCollection不是 HTMLCollection提供了namedItem()方法来根据元素name属性、id属性提取元素项 NodeList提供了forEach()方法来进行遍历，但是HTMLCollection未提供该方法 两者对比而言，其实NodeList更加的优秀，它支持动态映射DOM这个就令HTMLCollection汗颜了。 length NodeList与HTMLCollection都包含length属性，记录了其中包含元素节点的数量： Document 1 2 3 \"use strict\"; let liNodeList = document.querySelectorAll(\"li\"); let liCollection = document.getElementsByTagName(\"li\"); console.log(liNodeList.length); console.log(liCollection.length); // 3 // 3 item() NodeList与HTMLCollection都提供了item()方法来根据索引获取元素： Document 1 2 3 \"use strict\"; let liNodeList = document.querySelectorAll(\"li\"); let liCollection = document.getElementsByTagName(\"li\"); console.log(liNodeList.item(0)); console.log(liCollection.item(0)); // 等同于 console.log(liNodeList[0]); console.log(liCollection[0]); namedItem() HTMLCollection提供了namedItem()方法来根据元素name属性、id属性提取元素项： Document 1 2 3 4 5 \"use strict\"; let divCollection = document.getElementsByTagName(\"div\"); console.log(divCollection.namedItem(\"div-name\")); console.log(divCollection.namedItem(\"div-id\")); // 1 // 2 动态映射 NodeList拥有动态映射的特征，也就是说当DOM上的元素对象发生改变后NodeList中的元素项也会发生改变。 注意：querySelectorAll()方法返回的NodeList是静态的 动态特性示例，在获取了NodeList后新增了一个标签插入文档中，可以发现NodeList也会新增标签： Document \"use strict\"; let divNodeList = document.getElementsByName(\"show\"); console.log(divNodeList.length); // 3 let newDiv = document.createElement(\"div\"); newDiv.setAttribute(\"name\", \"show\"); // div的name属性是特征属性，input的name是标准属性 document.body.append(newDiv); console.log(divNodeList.length); // 4 querySelectorAll()方法返回的NodeList是静态的： Document \"use strict\"; let divNodeList = document.querySelectorAll(\"[name=show]\"); console.log(divNodeList.length); // 3 let newDiv = document.createElement(\"div\"); newDiv.setAttribute(\"name\", \"show\"); // div的name属性是特征属性，input的name是标准属性 document.body.append(newDiv); console.log(divNodeList.length); // 3 数组转换 HTMLCollection和NodeList都可以转换为数组，我们以NodeList示例。 1）通过Array.form()方法将NodeList转换为数组： Document \"use strict\"; let divNodeList = document.querySelectorAll(\"[name=show]\"); let divNodeArray = Array.from(divNodeList); console.log(divNodeArray); // (3) [div, div, div] 2）通过…语法将NodeList转换为数组： Document \"use strict\"; let divNodeList = document.querySelectorAll(\"[name=show]\"); let divNodeArray = [...divNodeList]; console.log(divNodeArray); // (3) [div, div, div] 其实在通过Array.form()方法将NodeList转换为数组时，可对mapfn形参传入一个回调函数用以操作数据项。 如下所示，我们只提取元素节点的文本内容： Document A B C \"use strict\"; let ary = Array.from( document.querySelectorAll(\"div\"), (element, index) => { return element.innerText; } ); console.log(ary); // [\"A\", \"B\", \"C\"] 原型借用 HTMLCollection和NodeList都是类数组，所以可以很好的借用Array原型对象的方法。 如下示例，计算书籍总价格并写入到文档中： Document table#book-table { width: 300px; border: 1px solid #ddd; caption-side: top; border-collapse: collapse; } table#book-table th, td, caption { border: 1px solid #ddd; } table#book-table caption { background-color: #aaa; font-weight: bolder; padding: .3rem; } table#book-table tfoot td { font-weight: bolder; } table#book-table th, td { padding: .2rem; text-align: center; } table tbody tr:nth-child(odd) { background-color: #eee; } table tbody tr:hover { background-color: #aaa; } table tbody tr * { cursor: pointer; } book table book name book price JavaScript 32 HTML5 24 CSS3 36 total price \"use strict\"; let bookNodeList = document.querySelectorAll(\"[book]\"); let bookTotalPrice = Array.prototype.reduce.call(bookNodeList, (prev, cur, idx, nodelst) => { return prev + Number(cur.nextElementSibling.innerText); }, 0) document.querySelector(\"#total-price\").innerText = bookTotalPrice; 渲染结果： 对象遍历 NodeList和Collection都支持的遍历方式有： for遍历 for/of遍历 此外，NodeList还支持forEach()方法进行遍历。 这里不再进行演示，其实它们可以通过Array原型借用获得更好的遍历体验，如借用reduce()、map()、every()、some()等方法实现遍历。 节点对象创建 创建文本节点 document.createTextNode() 使用document.createTextNode()方法来创建文本节点对象： Document \"use strict\"; let textNode = document.createTextNode(\"HELLO WORLD\"); console.log(textNode); // \"HELLO WORLD\" console.log(textNode.nodeType); // 3 console.log(textNode.nodeName); // #text console.log(textNode.nodeValue); // HELLO WORLD 创建元素节点 document.createElement() 使用document.createElement()方法来创建元素节点对象： Document \"use strict\"; let elementNode = document.createElement(\"div\"); console.log(elementNode); // console.log(elementNode.nodeType); // 1 console.log(elementNode.nodeName); // DIV console.log(elementNode.nodeValue); // null 元素节点使用该属性总是返回null 克隆节点 node.cloneNode() 节点对象都拥有cloneNode()方法，旨在克隆出一个一模一样的节点。 如果它的deep参数为true，会进行递归的深度克隆。 注意，如果事件绑定是绑定在元素身上，则会连同事件一起拷贝 示例如下： Document A \"use strict\"; document.importNode function callbackfn(element, event) { let ascii = element.firstElementChild.innerText.charCodeAt(); let newDiv = element.cloneNode(true); newDiv.firstElementChild.innerText = String.fromCharCode(ascii + 1); element.after(newDiv); } 导入节点 document.importNode() document.importNode()和node.cloneNode()的功能基本相同，但是使用上有所不同。 importNode()方法仅能由document调用 cloneNode()方法可以由任何节点对象调用 document.importNode()方法有2个参数： node：传入要被拷贝的节点对象 deep：是否进行深度拷贝 值得注意的是，在部分IE浏览器上该方法的支持性并不如node.cloneNode()方法。 如下所示，将node.cloneNode()方法改变为document.importNode()，效果不会发生任何变化： Document A \"use strict\"; function callbackfn(element, event) { let ascii = element.firstElementChild.innerText.charCodeAt(); let newDiv = document.importNode(element, true); newDiv.firstElementChild.innerText = String.fromCharCode(ascii + 1); element.after(newDiv); } 元素节点内容 innerHTML 元素节点可通过innerHTML属性获取或设置标签中嵌套的内容。 如果是设置内容，它将触发浏览器解析器重新绘制DOM。 设置内容时，可以通过innerHTML为源标签创建一个嵌套标签，但不能创建标签 + JavaScript代码，这样做会抛出异常。 如下示例： Document HELLO WORLD \"use strict\"; let divNode = document.querySelector(\"div\"); // 获取内容 console.log(divNode.innerHTML); // HELLO WORLD // 设置内容 有效，只要不是标签即可 divNode.innerHTML = \"hello world\" // 最后DOM上渲染结果为 ： hello world outerHTML innerHTML只包含内容，而outerHTML包含标签本身。 如下图所示： 当要替换outerHTML时，它会将标签本身也一起替换： Document HELLO WORLD \"use strict\"; let divNode = document.querySelector(\"div\"); // 获取内容 console.log(divNode.outerHTML); // HELLO WORLD // 设置内容 有效，只要不是script标签即可 divNode.outerHTML = \"hello world\" // 最后DOM上渲染结果为 ： hello world innerText & textContent 元素节点可通过innerText或textContent属性获取或设置标签中嵌套的文本内容，注意与innerHTML的区别。 innerText和textContent属性的功能都一样，但是兼容性上有一些差别： textContent属性不被部分IE浏览器所支持 innerText属性不被部分FireFox浏览器所支持 在获取时，忽略标签本身，只获取其文本内容。 在设置时，不能设置嵌套标签，它将被当做普通文本进行对待。 示例如下： Document 外层文本内层文本 \"use strict\"; let divNode = document.querySelector(\"div\"); // 在获取时，忽略标签本身，只获取其文本内容。 console.log(divNode.innerHTML); // 外层文本内层文本 console.log(divNode.innerText); // 外层文本内层文本 // 在设置时，不能设置嵌套标签，它将被当做普通文本进行对待。 divNode.innerText = \"HELLO WORLD\" // 最后页面上会直接显示出 ： hello world，并不会做标签渲染 outerText 区别点同innerHTML和outerHTML相同。 即在替换时，是否连同标签本身一起替换。 Document 外层文本内层文本 \"use strict\"; let divNode = document.querySelector(\"div\"); divNode.outerHTML = \"不会解析成标签\"; 节点对象管理 推荐方法 在当前版本，JavaScript中对节点对象的管理主要使用以下方法，它们都支持插入、删除、替换文本节点和元素节点。 以下方法是任意节点对象都可调用的，其中也包括document对象： 方法 描述 append() 在节点内部的末尾添加新的元素节点对象或文本节点对象 prepend() 在节点内部的首部插入新的元素节点对象或文本节点对象 before() 在节点同级的前面插入新的元素节点对象或文本节点对象 after() 在节点同级的后面插入新的元素节点对象或文本节点对象 replaceWith() 将当前节点对象替换为新的元素节点对象或文本节点对象 append() 在节点内部的末尾添加新的元素节点对象或文本节点对象。 如图所示： 代码示例： Document unorder list start 1 2 3 unorder list end \"use strict\"; let ulNode = document.querySelector(\"ul\"); let newNode = document.createElement(\"li\"); newNode.innerText = \"append()\"; ulNode.append(newNode); 渲染结果： prepend() 在节点内部的首部插入新的元素节点对象或文本节点对象。 如图所示： 代码示例： Document unorder list start 1 2 3 unorder list end \"use strict\"; let ulNode = document.querySelector(\"ul\"); let newNode = document.createElement(\"li\"); newNode.innerText = \"prepend()\"; ulNode.prepend(newNode); 渲染结果： before() 在节点同级的前面插入新的元素节点对象或文本节点对象。 如图所示： 代码示例： Document unorder list start 1 2 3 unorder list end \"use strict\"; let ulNode = document.querySelector(\"ul\"); let newNode = document.createElement(\"h2\"); newNode.innerText = \"before()\"; ulNode.before(newNode); 渲染结果： after() 在节点同级的后面插入新的元素节点对象或文本节点对象。 如图所示： 代码示例： Document unorder list start 1 2 3 unorder list end \"use strict\"; let ulNode = document.querySelector(\"ul\"); let newNode = document.createElement(\"h2\"); newNode.innerText = \"after()\"; ulNode.after(newNode); 渲染结果： replaceWith() 将当前节点对象替换为新的元素节点对象或文本节点对象。 如图所示： 代码示例，将h1替换为mark，保留原本的内容： Document unorder list start 1 2 3 unorder list end \"use strict\"; setTimeout(() => { let h1NodeList = document.querySelectorAll(\"h1\"); h1NodeList.forEach((element, index, lst) => { let elementContent = element.innerHTML; let newNode = document.createElement(\"mark\"); newNode.innerHTML = elementContent; element.replaceWith(newNode); }) }, 5000); 渲染结果： 1）替换之前： 2）替换之后： 其他方法 上面介绍的5个节点管理方法可针对文本节点、也可针对元素节点，是最常用的节点管理方法，没有什么局限性。 而下面介绍的方法3个节点管理方法或只针对文本节点、或只针对元素节点，都有一定的局限性，因此不太常用。 这3个方法任意节点对象都可调用的，其中也包括document对象： insertAdjacentText()：只能将文本节点对象插入到节点的某个位置上，它不会对文本中的标签进行解析 insertAdjacentHTML()：只能将文本节点对象插入到节点的某个位置上，它可以对文本中的标签进行解析 insertAdjacentElement()：只能将元素节点对象插入到节点的某个位置上 这3个方法都有2个参数： InsertPosition：插入的位置 text、html、insertedElement：待插入的对象 其中，插入位置可指定的字符串如下所示： InsertPosition 描述 beforebegin 元素同级前面 afterend 元素同级后面 afterbegin 元素内部前面 beforeend 元素内部后面 代码示例： Document unorder list start 1 2 3 unorder list end \"use strict\"; let node = document.querySelector(\"ul\"); // 只能将文本节点对象插入到节点的某个位置上，它不会对文本中的标签进行解析 node.insertAdjacentText(\"beforeend\", \"new text\"); // 只能将文本节点对象插入到节点的某个位置上，它可以对文本中的标签进行解析 node.insertAdjacentHTML(\"beforeend\", \"new html li\"); // 只能将元素节点对象插入到节点的某个位置上 let newNode = document.createElement(\"li\"); newNode.innerHTML = \"new element li\" node.insertAdjacentElement(\"beforeend\", newNode); 渲染结果： 古老方法 下面是过去使用的操作节点的方法，现在不建议使用了，在阅读一些老旧代码时可参照此表： 方法 说明 appendChild() 添加子节点对象 insertBefore() 在同级的前面插入一个节点对象 removeChild() 删除子节点对象 replaceChild() 替换子节点对象 标准属性操作 什么是标准属性 标准属性即为HTML标签中自带的一些常见属性。 如：id、class、的name、value、readonly、disabled等。 一言以蔽之，只要不是自定义的标签属性都被称之为标准属性。 一些特殊的标准属性 一些标准属性的名字和JavaScript关键字有冲突，对此JavaScript对这些标准属性进行了重命名操作： 标准属性class被重命名为className 标准属性for被重命名为htmlFor 如何操纵标准属性 对元素节点对象使用点语法，跟上标准属性名即可。 标准属性的获取不一定完全是字符串，也有可能是布尔值 操作标准属性时，严格区分大小写 操作标准属性时，采用驼峰命名法，如readonly要变更为readOnly 如下所示： Document .blue { color: blue; } .tilt { font-style: italic; } HELLO WORLD \"use strict\"; let h1ElementNode = document.querySelector(\"h1\"); h1ElementNode.className = \"blue tilt\"; let inputElementNode = document.querySelector(\"input\"); console.log(inputElementNode.readOnly); // true console.log(inputElementNode.placeholder); // this is input element console.log(inputElementNode.value); // console.log(inputElementNode.type); // text 常见标准属性与设置 以下例举常见标准属性与值的设置： 标签类型 标准属性 值类型 全标签 id string 全标签 className string 全标签 hidden boolean href string target string src string alt string action string method string enctype string novalidate boolean name string value string placeholder string required boolean readonly boolean disabled boolean checked boolean multiple boolean selected boolean 特征属性操作 什么是特征属性 特征属性即我们为HTML标签自定义的一些属性。 一言以蔽之，只要不是自带的标签属性都被称之为特征属性 特征属性的操作方法 特征属性不能使用点语法进行操作，而是要用节点对象提供的方法进行操作。 特征属性的操作不区分大小写 特征属性的值都为string类型 节点属性操作常用方法如下所示，它们不仅支持操作标准属性，还支持操作特征属性： 方法 说明 getAttribute() 获取某一属性 setAttribute() 设置某一属性 removeAttribute() 删除某一属性 hasAttribute() 检测某一属性是否存在 getAttribute() 获取某一属性，支持获取标准、特征属性： Document \"use strict\"; let divNode = document.querySelector(\"div\"); // 标准属性获取 console.log(divNode.getAttribute(\"class\")); console.log(divNode.getAttribute(\"id\")); // 特征属性获取 console.log(divNode.getAttribute(\"data\")); // structure // div-1 // this is div setAttribute() 设置某一属性，支持设置标准、特征属性： Document \"use strict\"; let divNode = document.querySelector(\"div\"); // 设置标准属性 divNode.setAttribute(\"class\", \"c1 c2 c3\"); divNode.setAttribute(\"id\", \"div--1\"); // 设置特征属性 divNode.setAttribute(\"data\", \"new description\"); console.log(divNode); // removeAttribute() 删除某一属性，支持删除标准、特征属性： Document \"use strict\"; let divNode = document.querySelector(\"div\"); // 删除标准属性 divNode.removeAttribute(\"class\"); // 删除特征属性 divNode.removeAttribute(\"data\"); console.log(divNode); // hasAttribute() 检测某一属性是否存在，支持检测标准、特征属性： Document \"use strict\"; let divNode = document.querySelector(\"div\"); // 检测标准属性 console.log(divNode.hasAttribute(\"class\")); // 检测特征属性 console.log(divNode.hasAttribute(\"data\")); // true // true attributes返回所有属性 节点对象可使用attributes属性来返回所有的特征、标准属性。 attributes将返回一个NameNodeMap对象： Document \"use strict\"; let divNode = document.querySelector(\"div\"); console.log(divNode.attributes); // NamedNodeMap {0: class, 1: id, 2: data, class: class, id: id, data: data, length: 3} NameNodeMap是一个可迭代对象，你可以使用for/of迭代它或者直接使用index对其进行操作： Document \"use strict\"; let divNode = document.querySelector(\"div\"); let divNodeAttributes = divNode.attributes; console.log(divNodeAttributes[0]); // class=\"structure\" for (let v of Object.values(divNodeAttributes)) { console.log(v.nodeName, v.nodeValue); } // class structure // id div-1 // data this is div dataset 特征属性集 我们自定义的特征属性在某些时候很容易和标准属性名字发生冲突。 针对这种情况，我们只需要在特征属性定义时前面加上data-的前缀即可。 要获取这些特征属性时，可直接通过node.dataset属性集进行获取，属性集和以data-开头的特征属性之间拥有动态映射的关系，你可以在属性集中访问、修改、删除这些以data-开头的特征属性。 通过属性集去获取特征属性时，忽略data-的前缀 通过属性集去获取特征属性时，要按照小驼峰式命名法 通过属性集去操作特征属性时，DOM也会相应发生变化 1）只有data-开头的特征属性才会被加入属性集中，并且在属性集中存储这些特征属性时会去掉data-开头的前缀： Document HELLO WORLD \"use strict\"; let divNode = document.querySelector(\"div\"); let divDataSet = divNode.dataset; console.log(divDataSet); // DOMStringMap {position: \"left\", fontColor: \"#888\", fontSize: \"2rem\"} 2）属性集的删改操作都会影响到元素本身，这说明dataset具有动态响应的特性： Document HELLO WORLD \"use strict\"; let divNode = document.querySelector(\"div\"); let divDataSet = divNode.dataset; // 改 divDataSet.fontSize = \"30px\"; divDataSet.position = \"center\"; // 删 delete divDataSet.fontColor; console.log(divDataSet); // DOMStringMap {position: \"center\", fontSize: \"30px\"} console.log(divNode); // HELLO WORLD 样式设置 style 元素节点使用style属性可以单独的为某一个元素进行单一的样式设置。 当被设置的样式名有-分割时，应当采用小驼峰命名法： Document HELLO WORLD \"use strict\"; let divNode = document.querySelector(\"div\"); divNode.style.color = \"red\"; divNode.style.fontSize = \"2rem\"; divNode.style.fontStyle = \"italic\"; // HELLO WORLD style.cssText 元素节点使用style.cssText属性可以单独的为某一个元素进行多种样式设置。 Document HELLO WORLD \"use strict\"; let divNode = document.querySelector(\"div\"); divNode.style.cssText = \"color: red; font-size: 2rem; font-style: italic;\"; // HELLO WORLD setAttribute() 元素节点使用setAttribute()方法也可以单独的为某一个元素进行多种样式设置。 Document HELLO WORLD \"use strict\"; let divNode = document.querySelector(\"div\"); divNode.setAttribute(\"style\", \"color: red; font-size: 2rem; font-style: italic;\"); // HELLO WORLD classList 元素节点可以通过classList属性下提供的方法来切换已有的class可实现批量化的样式控制。 classList属性下可使用的方法如下表所示： 方法 描述 classList.contains() 检测某个class是否存在 classList.add() 新增一个或多个class classList.remove() 删除一个或多个class classList.toggle() 如果class以存在，则删除，如果class不存在，则新增，相当于切换 1）检测某个class是否存在： Document .ft { font: italic bold 1em/1.5 'Courier New', Courier, monospace; } .bg { background: red; } .show { display: block; } .hidden { display: none; } HELLO WORLD click me \"use strict\"; let divNode = document.querySelector(\"div\"); let btnNode = document.querySelector(\"button\"); btnNode.addEventListener(\"click\", (event) => { console.log(divNode.classList.contains(\"show\")); console.log(divNode.classList.contains(\"hidden\")); console.log(divNode.classList.contains(\"bg\")); console.log(divNode.classList.contains(\"ft\")); }); // false // false // true // true 2）新增class，可用空格进行分割，进而一次添加多个class： Document .ft { font: italic bold 1em/1.5 'Courier New', Courier, monospace; } .bg { background: red; } .show { display: block; } .hidden { display: none; } HELLO WORLD click me \"use strict\"; let divNode = document.querySelector(\"div\"); let btnNode = document.querySelector(\"button\"); btnNode.addEventListener(\"click\", (event) => { divNode.classList.add(\"bg\"); }); 3）删除class，可用空格进行分割，进而一次删除多个class： Document .ft { font: italic bold 1em/1.5 'Courier New', Courier, monospace; } .bg { background: red; } .show { display: block; } .hidden { display: none; } HELLO WORLD click me \"use strict\"; let divNode = document.querySelector(\"div\"); let btnNode = document.querySelector(\"button\"); btnNode.addEventListener(\"click\", (event) => { divNode.classList.remove(\"bg\"); }); 4）如果class以存在，则删除，如果class不存在，则新增，相当于切换： Document .ft { font: italic bold 1em/1.5 'Courier New', Courier, monospace; } .bg { background: red; } .show { display: block; } .hidden { display: none; } HELLO WORLD click me \"use strict\"; let divNode = document.querySelector(\"div\"); let btnNode = document.querySelector(\"button\"); btnNode.addEventListener(\"click\", (event) => { divNode.classList.toggle(\"show\"); divNode.classList.toggle(\"hidden\"); }); 样式获取 style 如果节点的样式是行内式的话，那么可以通过style属性单独的获取某一样式。 注意！仅针对行内式： Document HELLO WORLD \"use strict\"; let divNode = document.querySelector(\"div\"); console.log(divNode.style.color); console.log(divNode.style.fontSize); console.log(divNode.style.fontStyle); // red // 2rem // italic getComputedStyle() 通过getComputedStyle()方法，获取节点元素身上所有以生效的样式。 这是计算后的样式属性，所以取得的单位和定义时的可能会有不同。 参数释义： elt：要获取样式的元素节点对象 pseudoElt：获取的伪类样式 示例如下： Document HELLO WORLD \"use strict\"; let divNode = document.querySelector(\"div\"); console.log(getComputedStyle(divNode)); 可通过点语法获取单独的某个样式： Document HELLO WORLD \"use strict\"; let divNode = document.querySelector(\"div\"); console.log(getComputedStyle(divNode).color); console.log(getComputedStyle(divNode).fontSize); console.log(getComputedStyle(divNode).fontStyle); // rgb(255, 0, 0) // 32px // italic Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-08-18 21:23:44 "},"前端专栏/JavaScript/Event操作.html":{"url":"前端专栏/JavaScript/Event操作.html","title":"Event操作","keywords":"","body":"基础知识 事件作用 某些时候，我们希望用户在页面上做出一些行为后JavaScript能够自动的运行一段特定的代码。 如用户鼠标单击后放大图片、用户鼠标双击后改变文本颜色等需求均可使用事件来完成。 事件的使用总体分为2大部分： 如何给元素绑定事件 如何编写事件的处理逻辑 在JavaScript中对于事件的处理采用异步驱动形式进行，所以它的效率是非常高的，不必担心出现任何性能问题。 事件类型 事件拥有多种类型，比如文档事件、鼠标事件、键盘事件等。 不同类型的事件是不同的对象，他们会提供不同的属性来供开发人员使用。 事件对象 事件本身是一个对象，当一个事件发生时会自动的创建出该类型的事件对象，大多数情况下它都会被存储在window对象中。 我们可以通过window.event属性来调用出当前的事件对象。 所有的事件对象原型都继承了Event，Event为所有类型的事件对象提供了一些通用的属性及方法，如下所示： 属性 描述 Event.type 事件的类型，不区分大小写 Event.target 对事件原始目标的引用，这里的原始目标指最初派发（dispatch）事件时指定的目标 Event.currentTarget 当前正在执行事件的对象，如果有事件冒泡发生，它将是不断变化的 Event.cancelable 一个布尔值，表示事件是否可以取消 Event.bubbles 一个布尔值，用来表示该事件是否会在 DOM 中冒泡 Event.eventPhase 表示事件流正被处理到了哪个阶段 事件目标 事件目标分为2种，一种是引发事件的目标，一种是正在执行事件的目标。 event.target：它指向引发此处事件的源目标，是不会改变的 event.currentTarget：它指向事件正在执行的目标，是允许改变的，只有在冒泡行为产生后才能体现该属性的作用 为什么会有2种目标呢？ 这个就和事件执行周期有关了，因为元素是可以嵌套的，所以大多数事件在执行时都会产生多个目标对象。 事件周期 当一个事件被绑定且执行时，一定会有3个大阶段，为了方便后续探讨，我将它分为4个小阶段，分别是： 捕获阶段：事件从Window对象开始派发给源目标 目标阶段：事件到达源目标 传播阶段：事件开始在源目标上主动执行处理逻辑的回调函数，此时事件的执行目标等同于源目标 （这是一个自我划分的阶段） 冒泡阶段：事件从源目标上进行冒泡，被动执行父级相同事件的回调函数，此时事件的执行目标发生改变，源目标不变 如下图所示： 事件绑定 回调函数 一般来说我们在为一个元素添加一个事件监听后会为其绑定一个回调函数。 该回调函数会在事件发生后自动进行调用。 HTML on 直接在HTML代码中绑定事件回调函数，在绑定时必须添加括号。 它会在事件发生后自动进行执行，可传入参数this和event： this：事件源目标对象，即标签本身 event：当前的事件对象 需要注意this的执行是会根据回调函数形态的不同而发生变化的，具体可参照下面this指向一章节。 示例如下： click me \"use strict\"; function callbackfn(target, event) { console.log(\"run\"); } DOM on 也可以将事件回调函数绑定到DOM节点对象的属性中，有2点注意事项： 不能使用setAttribute()方法进行属性设置，因为它针对的是标签的普通、特征属性，而非Node节点本身的属性 属性名必须区分大小写 在绑定时，我们可指定形参event，它将在回调函数运行时自动传入当前的事件对象。 示例如下： click me \"use strict\"; let btnNode = document.querySelector(\"button\"); btnNode.onclick = function (event) { console.log(\"run\"); }; 监听绑定 addEventListener() 不论是HTML绑定还是DOM绑定都具有一定的缺陷，因此推荐使用ES6新增的addEventListener()方法进行事件绑定。 它的优点如下： 支持transtionend和DOMContentLoaded等事件类型的绑定 同一节点对象支持多次绑定相同事件，它会按照绑定顺序进行依次执行 支持对未来元素添加绑定事件 参数说明： 参数 描述 type 需要绑定的监听事件类型 listener 需要绑定的回调处理程序，如果是回调函数，可传入形参event options 定制选项 着重说明options的可定制选项： once：布尔值，如果为true代表只执行一次事件处理程序，默认是false capture：布尔值，表示listener会在该类型的事件捕获阶段传播到该元素时触发，默认是false passive：布尔值，如果为true代表用于不要在回调函数中使用event.preventDefault()，否则将抛出异常，默认是false 示例如下，添加一个只执行一次的事件，指定options的once为true即可： click me \"use strict\"; let btnNode = document.querySelector(\"button\"); btnNode.addEventListener(\"click\", function (event) { console.log(\"run\"); event.target.innerText = \"don't click me\"; }, { once: true }); removeEventListener() 使用removeEventListener()方法删除某个节点所绑定的事件及回调函数。 示例如下，左键单击按钮会令内容+1，右键单击按钮会令左键功能失效： 0 click me \"use strict\"; let btnNode = document.querySelector(\"button\"); let spanNode = document.querySelector(\"div span\"); function click(event) { spanNode.innerText = Number(spanNode.innerHTML) + 1; } function contextmenu(event) { btnNode.removeEventListener(\"click\", click); btnNode.disabled = true; // 禁止右键的弹出菜单 event.preventDefault(); } btnNode.addEventListener(\"click\", click); btnNode.addEventListener(\"contextmenu\", contextmenu); handleEvent() 如果事件处理的回调程序不是一个函数，而是一个对象的话，那么对象中的handleEvent()方法会在事件触发后自动进行执行： click me \"use strict\"; let btnNode = document.querySelector(\"button\"); class BTNEventHandle { constructor(node) { node.addEventListener(\"mousedown\", this); node.addEventListener(\"mouseup\", this); } handleEvent(event) { // 寻找同名方法 this.类型方法 // 并传递进事件对象和源目标对象 this[event.type](event, event.target); } mousedown(event, target) { console.log(\"按下了鼠标左键\"); } mouseup(event, target) { console.log(\"松开了鼠标左键\"); } } new BTNEventHandle(btnNode); this指向 如果回调函数是普通函数，那么this即指向事件的源目标对象。 如果回调函数是箭头函数，那么this即指向window对象。 示例如下： ordinary arrow \"use strict\"; let btnNodeOrdinary = document.querySelector(\"button:first-of-type\"); let btnNodeArrow = document.querySelector(\"button:last-of-type\"); btnNodeOrdinary.addEventListener(\"click\", function (event) { console.log(this); // ordinary }); btnNodeArrow.addEventListener(\"click\", event => { console.log(this); // Window }); event.target 如果想在箭头函数中拿到事件源目标对象，可使用event.target属性。 ordinary arrow \"use strict\"; let btnNodeOrdinary = document.querySelector(\"button:first-of-type\"); let btnNodeArrow = document.querySelector(\"button:last-of-type\"); btnNodeOrdinary.addEventListener(\"click\", function (event) { console.log(this); // ordinary console.log(event.target); // ordinary }); btnNodeArrow.addEventListener(\"click\", event => { console.log(this); // Window console.log(event.target); // ordinary }); 事件传播 HTML on和DOM on的方式都不支持为同一监听事件绑定多个回调函数： ordinary arrow \"use strict\"; // 总会执行第2个 let btnNodeOrdinary = document.querySelector(\"button:first-of-type\"); btnNodeOrdinary.onclick = ordinaryFunc01; btnNodeOrdinary.onclick = ordinaryFunc02; function arrowFunc01(target, event) { console.log(\"run arrow function 01\"); } function arrowFunc02(target, event) { console.log(\"run arrow function 02\"); } function ordinaryFunc01(event) { console.log(\"run ordinary function 01\"); } function ordinaryFunc02(event) { console.log(\"run ordinary function 02\"); } 但是addEventListener()支持为同一监听事件绑定多个回调函数，当事件发生时他会依次进行处理。 整个执行的过程我将其称之为事件传播过程： click me \"use strict\"; let btnNode = document.querySelector(\"button\"); btnNode.addEventListener(\"click\", event => { console.log(\"1\"); }); btnNode.addEventListener(\"click\", event => { console.log(\"2\"); }); btnNode.addEventListener(\"click\", event => { console.log(\"3\"); }); 如下图所示： on是什么意思 on其实就是开始监听的意思。 通过HTML属性或者DOM属性绑定回调函数时，需要在事件名前加入on，比如click就变为onclick，copy变为oncopy。 而使用事件监听的方式则不需要加上on，因为addEventListener()本身就有监听的功能。 默认行为 默认事件 某些元素会有一些默认监听的行为。 比如： 标签点击后会自动进行页面跳转 点击后会自动搜集表单项并提交 在某些场景下我们需要对这些具有默认行为的元素绑定事件，并且还要让其阻止默认行为的发生。 阻止默认 阻止默认行为一共有2个方案： 适用于任何场景：在回调函数中加上event.preventDefault()即可 仅适用于DOM on：在回调函数中return false即可 1）适用于任何场景：在回调函数中加上event.preventDefault()即可： click me \"use strict\"; function linkClick(target, event) { event.preventDefault(); }; 2）仅适用于DOM on：在回调函数中return false即可： click me \"use strict\"; let linkNode = document.querySelector(\"a\"); linkNode.onclick = function(event){ return false }; 左键双击选中文本 左键双击选中文本是一个常见的默认行为，我们只需要在元素身上添加上属性onselectstart=\"return false\"即可阻止选中： content \"use strict\"; let divNode = document.querySelector(\"div\"); divNode.addEventListener(\"dblclick\", event=>{ console.log(\"run\"); }); 右键单击打开菜单 右键单击打开菜单是一个常见的默认行为，我们只需要在元素身上添加上属性oncontextmenu=\"return false\"即可阻止选中： 点击鼠标右键试试? \"use strict\"; let divNode = document.querySelector(\"div\"); document.addEventListener(\"contextmenu\", event => { divNode.innerText = \"是不是发现不好使了?\" }); 冒泡行为 冒泡行为 元素是支持嵌套的，当子元素与父元素都绑定了相同的一个事件时，子元素事件触发后会进行事件的冒泡传递，也就是说父元素也会自动的执行这一事件，冒泡会一直到达HTML根元素标签。 大部分事件都会冒泡，但有的事件不会，如focus事件 event.target属性是对事件原始目标的引用，这里的原始目标指最初派发（dispatch）事件时指定的目标 event.currentTarget属性是当前执行事件的目标对象，如果有事件冒泡发生，它将是不断变化的 event.target和event.currentTarget的区别在于，谁引起了本次事件的产生，谁正在执行本次事件的处理 如下图所示： 示例演示： click me \"use strict\"; // 传播阶段 document.querySelector(\"main div button\").addEventListener(\"click\", event => { console.log(\"button click event callbackfn run 1\"); console.log(`current target : ${event.currentTarget.tagName}, target : ${event.target.tagName}`); }); document.querySelector(\"main div button\").addEventListener(\"click\", event => { console.log(\"button click event callbackfn run 2\"); console.log(`current target : ${event.currentTarget.tagName}, target : ${event.target.tagName}`); }); document.querySelector(\"main div button\").addEventListener(\"click\", event => { console.log(\"button click event callbackfn run 3\"); console.log(`current target : ${event.currentTarget.tagName}, target : ${event.target.tagName}`); }); // 冒泡阶段 document.querySelector(\"main div\").addEventListener(\"click\", event => { console.log(\"div click event callbackfn run\"); console.log(`current target : ${event.currentTarget.tagName}, target : ${event.target.tagName}`); }); document.querySelector(\"main\").addEventListener(\"click\", event => { console.log(\"main click event callbackfn run\"); console.log(`current target : ${event.currentTarget.tagName}, target : ${event.target.tagName}`); }); 执行结果： button click event callbackfn run 1 current target : BUTTON, target : BUTTON button click event callbackfn run 2 current target : BUTTON, target : BUTTON button click event callbackfn run 3 current target : BUTTON, target : BUTTON div click event callbackfn run current target : DIV, target : BUTTON main click event callbackfn run current target : MAIN, target : BUTTON 阻止冒泡 阻止事件冒泡的方法有2个： 在处理程序中添加event.stopPropagation() 在处理程序中添加event.stopImmediatePropagation() event.stopPropagation()用于阻止父元素的同事件监听回调不再执行。 event.stopImmediatePropagation()用于阻止父元素的同事件监听回调不再执行，并且相同元素的相同事件类型的监听事件也不再执行。 如下图所示： 根据不同的情况，选用不同的冒泡阻止方案。 一般来说使用event.stopPropagation()情况会更多一点： click me \"use strict\"; // 传播阶段 document.querySelector(\"main div button\").addEventListener(\"click\", event => { console.log(\"button click event callbackfn run 1\"); console.log(`current target : ${event.currentTarget.tagName}, target : ${event.target.tagName}`); event.stopPropagation(); }); document.querySelector(\"main div button\").addEventListener(\"click\", event => { console.log(\"button click event callbackfn run 2\"); console.log(`current target : ${event.currentTarget.tagName}, target : ${event.target.tagName}`); }); document.querySelector(\"main div button\").addEventListener(\"click\", event => { console.log(\"button click event callbackfn run 3\"); console.log(`current target : ${event.currentTarget.tagName}, target : ${event.target.tagName}`); }); // 冒泡阶段 document.querySelector(\"main div\").addEventListener(\"click\", event => { console.log(\"div click event callbackfn run\"); console.log(`current target : ${event.currentTarget.tagName}, target : ${event.target.tagName}`); event.stopPropagation(); }); document.querySelector(\"main\").addEventListener(\"click\", event => { console.log(\"main click event callbackfn run\"); console.log(`current target : ${event.currentTarget.tagName}, target : ${event.target.tagName}`); event.stopPropagation(); }); 执行结果： button click event callbackfn run 1 current target : BUTTON, target : BUTTON button click event callbackfn run 2 current target : BUTTON, target : BUTTON button click event callbackfn run 3 current target : BUTTON, target : BUTTON 事件捕获 captrue 事件执行周期由捕获 > 目标 > 传播 > 冒泡这4个阶段组成。 我们可以设置addEventListener()的options参数为true或{ capture: true } 让其在捕获阶段执行事件处理程序。 怎么样表述这一行为呢？其实同冒泡一样，它也必须建立在元素嵌套的基础上进行，当父元素和子元素都监听了同一个事件后，父元素会先执行第一个监听回调，然后再进行正常的逻辑，如下图所示： 事件捕获在实际使用中频率不高。 如下所示： click me \"use strict\"; document.querySelector(\"main\").addEventListener(\"click\", event => { console.log(\"main click event callbackfn run\"); }, { capture: true }); document.querySelector(\"main div\").addEventListener(\"click\", event => { console.log(\"div click event callbackfn run\"); }, { capture: true }); document.querySelector(\"main div button\").addEventListener(\"click\", event => { console.log(\"button click event callbackfn run\"); }, { capture: true }); 执行结果： main click event callbackfn run 1 current target : MAIN, target : BUTTON button click event callbackfn run current target : BUTTON, target : BUTTON div click event callbackfn run current target : DIV, target : BUTTON main click event callbackfn run 2 current target : MAIN, target : BUTTON main click event callbackfn run 3 current target : MAIN, target : BUTTON 事件代理 未来元素 我们想让所有已有的，包括未来可能会创建的元素都监听click事件，该怎么做呢？ 目前能掌握到最简单的方法就是先将已有的元素都添加上click事件，未来创建的元素在创建时也添加上click事件： 65 66 67 add new li \"use strict\"; let ulNode = document.querySelector(\"ul\"); let btnNode = document.querySelector(\"button\"); // 先将所有已有的li添加上事件 Array.prototype.forEach.call(ulNode.children, (element, index, lst) => { element.addEventListener(\"click\", liCallbackfn) }) // 添加新的标签，并为其绑定事件 btnNode.addEventListener(\"click\", event => { let lastLiNode = ulNode.lastElementChild; let lastText = lastLiNode.innerText; let newNode = document.createElement(\"li\"); newNode.innerText = Number.isNaN(Number.parseInt(lastText)) ? lastText.charCodeAt() + 1 : Number(lastText) + 1; newNode.addEventListener(\"click\", liCallbackfn); lastLiNode.after(newNode); }) function liCallbackfn(event) { event.target.innerText = String.fromCharCode(event.target.innerText); } 委托代理 上述的实现方案非常笨，我们可以借助事件冒泡的思路来完成一个事件委托的操作。 实现过程如下： 不为具体的子元素设置监听事件 将监听事件设置在父元素上，让父元素监听这一个事件 在子元素上点击时，这一行为必定发生在父元素的区域内，此时将触发父元素监听回调 父元素通过event.target判定事件发生源是否是指定的某子元素即可，如果是则开始正常执行回调逻辑，如果不是则不执行回调逻辑 实现代码： 65 66 67 add new li \"use strict\"; let ulNode = document.querySelector(\"ul\"); let btnNode = document.querySelector(\"button\"); // 直接给ul绑定事件 ulNode.addEventListener(\"click\", event => { // 如果事件目标是li，执行li的回调 if (event.target.tagName === \"LI\") { liCallbackfn(event); } }) // 添加新的标签 btnNode.addEventListener(\"click\", event => { let lastLiNode = ulNode.lastElementChild; let lastText = lastLiNode.innerText; let newNode = document.createElement(\"li\"); newNode.innerText = Number.isNaN(Number.parseInt(lastText)) ? lastText.charCodeAt() + 1 : Number(lastText) + 1; lastLiNode.after(newNode); }) function liCallbackfn(event) { event.target.innerText = String.fromCharCode(event.target.innerText); } 将事件代理进行完善，将它做成一个on方法并添加进Element原型对象中，使所有的DOM节点都能进行调用： 65 66 67 add new li \"use strict\"; Element.prototype.on = function (eventType, eventTarget, callbackfn) { this.addEventListener(eventType, event => { if (event.target.tagName === eventTarget.toUpperCase()) { callbackfn(event); } }) } let ulNode = document.querySelector(\"ul\"); let btnNode = document.querySelector(\"button\"); // 委托的DOM节点 代理的事件 事件目标 事件目标的回调函数 ulNode.on(\"click\", \"li\", (event) => { event.target.innerText = String.fromCharCode(event.target.innerText); }) // 添加新的标签 btnNode.addEventListener(\"click\", event => { let lastLiNode = ulNode.lastElementChild; let lastText = lastLiNode.innerText; let newNode = document.createElement(\"li\"); newNode.innerText = Number.isNaN(Number.parseInt(lastText)) ? lastText.charCodeAt() + 1 : Number(lastText) + 1; lastLiNode.after(newNode); }) 文档事件 常用事件 文档常用事件如下所示，它们一般绑定给window对象。 事件 描述 load 文档解析完成，且所有外部资源加载完成时 DOMContentLoaded 文档解析完成时 beforeunload 文档刷新或关闭时 unload 文档卸载时 load load事件会在文档解析完成，且所有外部资源加载完成时触发。 一般我们会将其作为JavaScript的入口函数使用： \"use strict\"; window.onload = function (event) { console.log(\"文档加载完成,外部资源加载完成\"); } DOMContentLoaded DOMContentLoaded事件会在文档解析完成时触发，它不需要等待所有外部资源加载完成。 该事件只能使用addEventListener()进行设置。 相较于load事件，它更适合作为JavaScript的入口函数，在jQuery库中就是采用该事件作为入口函数的： \"use strict\"; window.addEventListener(\"DOMContentLoaded\", function (event) { console.log(\"文档加载完成\"); }) beforeunload beforeunload事件会在文档刷新或关闭时触发。 在某些浏览器上，该事件的回调函数返回值将作为提示信息弹出，或者你可以通过event.returnValue进行设置 部分浏览器无法使用addEventListener()绑定该事件 必须在网页上做出更改后，刷新或关闭时才会弹出提示 所设定的值并不是一定会显示的，这与浏览器版本有关 该事件常见于一些小网站上，当然我印象最深的地方是拼多多： \"use strict\"; window.onbeforeunload = function (event) { // 兼容IE8和Firefox 4之前的版本 event.returnValue = '关闭提示'; // Chrome, Safari, Firefox 4+, Opera 12+ , IE 9+ return '关闭提示'; }; unload unload事件会在文档卸载时触发，它位于beforeunload事件之后。 此时不能使用alert()、confirm()等交互窗指令 发生错误也不会阻止页面关闭或刷新 如下示例： \"use strict\"; window.onunload = function (event) { console.log(\"刷新或关闭了\"); }; 表单事件 常用事件 可用于监听的表单事件如下表所示： 事件 描述 focus 元素获取焦点后触发 blur 元素失去焦点后触发 input 元素内容发生改变后触发 click 单击了某个表单项 change 元素内容发生改变并且失去焦点时触发 submit 提交表单时触发 注意，node.focus()和node.blur()可强制的让元素获取、失去焦点。 另外，如果input的type是submit，则可以调用submit()方法进行表单提交。 此外，如果input的type是file，则可以调用click()方法来选择文件。 鼠标事件 常用事件 可用于监听的鼠标事件如下表所示： 事件 描述 click 鼠标左键单击（同时触发mousedown以及mouseup） dblclick 鼠标左键双击 mousedown 鼠标左键、右键按下 mouseup 鼠标左键、右键松开 mouseover 鼠标移入时 mousemove 鼠标移动时 mouseout 鼠标移出时 mouseenter 鼠标移入时，不产生冒泡行为 mouseleave 鼠标移出时，不产生冒泡行为 copy 拷贝时 scroll 滚动时 测试代码： div:nth-child(1) { height: 200px; width: 200px; background-color: #ddd; overflow: scroll; } content \"use strict\"; class MouseEventTest { constructor(node) { // 添加测试项 node.addEventListener(\"copy\", this); node.addEventListener(\"scroll\", this); } handleEvent(event) { this[event.type](event.target, event); } click(target, event) { console.log(\"左键单击\"); } dblclick(target, event) { console.log(\"左键双击\"); } mousedown(target, event) { console.log(\"某个键按下\"); } mouseup(target, event) { console.log(\"某个键松开\"); } mouseover(target, event) { console.log(\"鼠标移入\"); } mousemove(target, event) { console.log(\"鼠标移动\"); } mouseout(target, event) { console.log(\"鼠标移出\"); } mouseenter(target, event) { console.log(\"鼠标移动入 不冒泡\"); } mouseleave(target, event) { console.log(\"鼠标移出, 不冒泡\"); } copy(target, event) { console.log(\"拷贝\"); } scroll(target, event) { console.log(\"滚动\"); } } new MouseEventTest(document.querySelector('div')) 事件属性 鼠标事件对象是MouseEvent，它派生自UIEvent，而UIEvent派生自Event。 该事件对象可调用属性如下： 属性 描述 MouseEvent.which 鼠标事件触发时按下的按键 MouseEvent.button 鼠标事件触发时是否按下了某个鼠标按键，将返回1个数值 MouseEvent.buttons 鼠标事件触发时是否按下了多个鼠标按键，将返回1个或N个数值 MouseEvent.altKey 鼠标事件触发时是否按下了alt键，返回Boolean值 MouseEvent.ctrlKey 鼠标事件触发时是否按下了ctrl键，返回Boolean值 MouseEvent.shiftKey 鼠标事件触发时是否按下了shift键，返回Boolean值 MouseEvent.metaKey 鼠标事件触发时是否按下了window键，返回Boolean值 MouseEvent.offsetX 鼠标位于当前目标元素中的X坐标 MouseEvent.offsetY 鼠标位于当前目标元素中的Y坐标 MouseEvent.pageX 鼠标位于当前整个文档中的X坐标 MouseEvent.pageY 鼠标位于当前整个文档中的Y坐标 MouseEvent.clientX 鼠标位于当前整个窗口中的X坐标 MouseEvent.clientY 鼠标位于当前整个窗口中的Y坐标 MouseEvent.screenX 鼠标位于当前整个屏幕中的X坐标 MouseEvent.screenY 鼠标位于当前整个屏幕中的Y坐标 MouseEvent.relatedTarget 鼠标事件的次要目标（如果有的话） relatedTarget属性主要针对mouseover、mouseout事件： mouseover：鼠标移入到当前元素之前在哪个元素身上 mouseout：鼠标移出到当前元素之后在哪个元素身上 当无来源，或移动到窗口外时值为null which属性的按键代号如下所示： 0：左键 1：中键 2：右键 在IE8之前版本中代号有所不同： 0：没有按下任何按键 1：按下左键 2：按下右键 3：同时按下左、右键 4：按下中键 5：同时按下左、中键 6：同时按下右、中键 7：3个按键同时按下 键盘事件 常用事件 可用于监听的键盘事件如下表所示： 事件 描述 keydown 按下某个键、长按时将重复触发 keyup 松开某个键 keypress 按下并松开某个键、长按时将重复触发 测试代码： div:nth-child(1) { height: 200px; width: 200px; background-color: #ddd; overflow: scroll; } \"use strict\"; class MouseEventTest { constructor(node) { // 添加测试项 node.addEventListener(\"keydown\", this); node.addEventListener(\"keyup\", this); node.addEventListener(\"keypress\", this); } handleEvent(event) { this[event.type](event.target, event); } keydown(target, event) { console.log(\"按下或长按了\"); } keyup(target, event) { console.log(\"松开了\"); } keypress(target, event) { console.log(\"按下并松开了\"); } } new MouseEventTest(document.querySelector('textarea')) 事件属性 鼠标事件对象是KeyboardEvent，它派生自UIEvent，而UIEvent派生自Event。 该事件对象可调用属性如下： 属性 描述 KeyboardEvent.key 返回按键字符 KeyboardEvent.code 返回按键编码 KeyboardEvent.keyCode 返回按键ASCII码 KeyboardEvent.altKey 键盘事件触发时是否按下了alt键，返回Boolean值 KeyboardEvent.ctrlKey 键盘事件触发时是否按下了ctrl键，返回Boolean值 KeyboardEvent.shiftKey 键盘事件触发时是否按下了shift键，返回Boolean值 KeyboardEvent.metaKey 键盘事件触发时是否按下了window键，返回Boolean值 KeyboardEvent.key释义： 按键字符，按键的字符含义表示，大小写不同。不能区分左右ALT等。不同语言操作系统下值会不同 KeyboardEvent.code释义： 按键编码，字符以Key开始，数字以Digit开始，特殊字符有专属名字。左右ALT键字符不同。 不同布局的键盘值会不同 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-08-19 09:55:40 "},"前端专栏/JavaScript/空间坐标.html":{"url":"前端专栏/JavaScript/空间坐标.html","title":"空间坐标","keywords":"","body":"基础知识 参考画布分为视口和文档2个概念。 网页很多都是多屏，所以文档尺寸一般大于视口尺寸 视口尺寸不包括浏览器工具条、菜单、标签、状态栏等 当打开控制台后，视口尺寸相应变小 文档坐标在页面滚动时不发生改变 视口坐标的操作需要考虑滚动条的位置 视口相当于postion:fixed，而文档相当于postion:absolute 如下图所示： 视口大小 以下属性均可获取视口大小： 属性 描述 window.innerWidth 窗口宽度（包含X轴滚动条、不常用） window.innerHeight 窗口高度（包含Y轴滚动条、不常用） document.documentElement.clientWidth 文档宽度 document.documentElement.clientHeight 文档高度 推荐使用document来获取文档可见区域的宽高，不包含浏览器工具条、菜单、标签、状态栏等： Height: Width: \"use strict\"; document.querySelector(\"div:nth-child(1)\").innerHTML += document.documentElement.clientHeight; document.querySelector(\"div:nth-child(2)\").innerHTML += document.documentElement.clientWidth; 单位均是px，即像素点。 元素信息 元素在页面中拥有多个描述几何数值的尺寸，如下所示： 属性说明： 属性 描述 offsetParent 获取该元素拥有绝对定位的父级元素，会一直向上找，body、tbale、th、td clientWidth 获取该元素的宽度尺寸，不包含边框，仅包含内边距和内容区域 clientHeight 获取该元素的高度尺寸，不包含边框，仅包含内边距和内容区域 clientLeft 表示一个元素的左边框的宽度 clientTop 表示一个元素的上边框的宽度 offsetWidth 获取该元素的宽度尺寸，包括内边距与边框和滚动条 offsetHeight 获取该元素的高度尺寸，包括内边距与边框和滚动条 offsetLeft 获取该元素从边框开始相对于offsetParent的X轴距离 offsetTop 获取该元素从边框开始相对于offsetParent的Y轴距离 scrollWidth 获取该元素的宽度尺寸，包括内边距与边框以及溢出区域的尺寸 scrollHeight 获取该元素的高度尺寸，包括内边距与边框以及溢出区域的尺寸 scrollLeft 获取水平滚动条左侧已经滚动的宽度 scrollTop 获取垂直滚动条顶部已经滚动的高度 代码示例： * { margin: 0; padding: 0; } body { display: flex; justify-content: center; align-items: center; } div { width: 200px; height: 200px; background-color: #eee; padding: 10px; margin: 10px; border: 1px solid #ddd; } \"use strict\"; let divNode = document.querySelector(\"div\"); console.log(divNode.offsetParent); console.log(divNode.clientWidth); // 220 console.log(divNode.clientHeight); // 220 console.log(divNode.clientLeft); // 1 console.log(divNode.clientTop); // 1 console.log(divNode.offsetWidth); // 222 console.log(divNode.offsetHeight); // 222 console.log(divNode.offsetLeft); // 638 console.log(divNode.offsetTop); // 96 你也可以使用getBoundingClientRect()方法来获取元素矩形信息，计算结果的矩形尺寸不包括外边距： * { margin: 0; padding: 0; } body { display: flex; justify-content: center; align-items: center; } div { width: 200px; height: 200px; background-color: #eee; padding: 10px; margin: 10px; border: 1px solid #ddd; } \"use strict\"; let divNode = document.querySelector(\"div\"); console.log(divNode.getBoundingClientRect()); // bottom: 237.4000005722046 // height: 222 // left: 637.7999877929688 // right: 859.7999877929688 // top: 15.40000057220459 // width: 222 // x: 637.7999877929688 // y: 15.40000057220459 对于inline元素来说，你可以使用getClientRects()方法来获取该元素每行所占据的尺寸： span { width: 200px; overflow: auto; } 网页很多都是多屏，所以文档尺寸一般大于视口尺寸,当打开控制台后，视口尺寸相应变小。网页很多都是多屏，所以文档尺寸一般大于视口尺寸,当打开控制台后，视口尺寸相应变小。网页很多都是多屏，所以文档尺寸一般大于视口尺寸,当打开控制台后，视口尺寸相应变小。 \"use strict\"; let span = document.querySelector('span') let info = span.getClientRects() console.log(info) 根据视口大小，行内文字可能会产生折叠，如产生折叠就会出现多行。 以下是2行时的信息： // 第一行信息 bottom: 29.33333396911621 height: 21.33333396911621 left: 8 right: 1683.5555419921875 top: 8 width: 1675.5555419921875 x: 8 y: 8 // 第二行信息 bottom: 50.66666793823242 height: 21.33333396911621 left: 8 right: 264 top: 29.33333396911621 width: 256 x: 8 y: 29.33333396911621 坐标判断 JavaScript提供了2种方法获取当前在视口某个坐标上的元素。 坐标都是从左上角进行计算的 如果指定的坐标点在视口外，将返回None 方法如下： 方法 描述 element.elementsFromPoint() 返回指定坐标点所在的元素集合 element.elementFromPoint() 返回指定坐标点所在的顶级元素 示例如下： * { margin: 0; padding: 0; } body, main, div, article { display: flex; justify-content: center; align-items: center; } main { width: 200px; height: 200px; background-color: #eee; padding: 10px; margin: 10px; border: 1px solid #ddd; } content \"use strict\" let position = [500, 200]; // 获取集合 console.log(document.elementsFromPoint(...position)); // (3) [main, body, html] // 获取顶级元素 console.log(document.elementFromPoint(...position)); // main 滚动控制 以下是用于控制元素滚动的相关方法或数学： 方法 说明 参数说明 window.pageXOffset 文档相对窗口水平滚动的像素距离 window.pageYOffset 文档相对窗口垂直滚动的像素距离 element.scrollLeft 获取和设置元素X轴滚动位置 属性，通过=进行设置 element.scrollTop 获取和设置元素Y轴滚动位置 属性，通过=进行设置 element.scrollLeft() 元素X轴滚动位置 方法，通过传参进行设置 element.scrollTop() 元素Y轴滚动位置 方法，通过传参进行设置 element.scrollBy() 按偏移量进行滚动内容 参数为对象，{top : 垂直偏移量, left : 水平偏移量, behavior : '滚动方式'} element.scroll() 以及element.scrollTo() 滚动到指定的具体位置 参数为对象，{top : X轴文档位置, left : Y轴文档位置, behavior : '滚动方式'} element.scrollIntoView(bool) 定位到顶部或底部 参数为true元素定位到顶部，为false定位到窗口底部 1）使用scrollBy()滚动文档： setInterval(() => { // 相当于每个3秒往下滚动30px，参照于上次所停留位置，smooth平滑滚动 document.documentElement.scrollBy({ top: 30, behavior: \"smooth\" }, 100); }, 3000); 2）使用scroll()滚动到指定位置： setInterval(() => { // 按照绝对位置，往下滚动30px，只走一次，smooth平滑滚动 document.documentElement.scroll({ top: 30, behavior: \"smooth\" }, 100); }, 3000); 3）使用scrollIntoView()方法实现滚动操作，参数可以是布尔值或对象。 参数为 true时顶部对齐，相当于{block: \"start\"} 参数为 false时底部对齐，相当于{block: “end\"} 定义 {behavior : smooth}为平滑滚动 Document section { height: 2000px; background: linear-gradient(to bottom, red, green, blue, yellow) } body button { position: fixed; bottom: 10%; width: 100px; height: 30px; } body button:first-of-type { right: 5%; } body button:last-of-type { left: 5%; } 头部 TOP BOTTOM 底部 \"use strict\"; document.querySelector(\"button.top\").addEventListener(\"click\", (event) => { let h1 = document.querySelector(\"header h1\"); h1.scrollIntoView({ behavior: \"smooth\", }) }); document.querySelector(\"button.bottom\").addEventListener(\"click\", (event) => { let h1 = document.querySelector(\"footer h1\"); h1.scrollIntoView({ behavior: \"smooth\", }) }) Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-08-13 23:33:02 "},"前端专栏/JavaScript/XmlHttpRequest.html":{"url":"前端专栏/JavaScript/XmlHttpRequest.html","title":"XmlHttpRequest","keywords":"","body":"基本介绍 XMLHttpRequest XMLHttpRequest是JavaScript中原生的，历史悠久的一种发送网络请求的方案。 基本上所有前端框架对于网络请求的部分都是基于它来完成的。 在没有学习XMLHttpRequest之前，与后端的交互我们都会使用来进行，但这样做会引起页面的刷新。 那么在学习了XMLHttpRequest之后，就可以使页面不刷新的同时和后端进行数据交互了，这是一种非常常用的技术，俗称ajax，因此要好好掌握。 在本章节中我们将了解XMLHttpRequest的基本用法，并且会实现一个与jQuery.ajax功能百分之九十相似的网络请求组件。 我是没有读过jQuery.ajax源码的，并且我也不是一个专精前端的程序员，所以后面的代码写的可能不太好，仅和大家在此做个交流。 后端代码 为了方便后续前后端交互的代码测试，我们后端采用Python-flask框架来完成。 IP：localhost PORT：5700 代码如下： from flask import Flask from flask import request from flask import make_response from flask import jsonify app = Flask(__name__) @app.after_request # 解决CORS跨域请求 def cors(response): response.headers['Access-Control-Allow-Origin'] = \"*\" if request.method == \"OPTIONS\": # 允许的请求头 response.headers[\"Access-Control-Allow-Headers\"] = \"Origin,Content-Type,Cookie,Accept,Token,authorization,user_head\" return response @app.route(\"/get\", methods=[\"get\"]) def get(): user_head = request.headers.get(\"user_head\") user_params = request.args print(user_params) return jsonify(user_params, user_head) @app.route(\"/post\", methods=[\"post\"]) def post(): user_head = request.headers.get(\"user_head\") user_params = request.form print(user_params) return jsonify(user_params, user_head) @app.route(\"/json\", methods=[\"post\"]) def json(): user_head = request.headers.get(\"user_head\") user_params = request.json return jsonify(user_params, user_head) @app.route(\"/file\", methods=[\"post\"]) def file(): file_obj = request.files.get(\"avatar\") if file_obj is None: return make_response(jsonify(\"unload avatar\"), 400) file_name = file_obj.filename file_obj.save(file_name) return jsonify(\"upload avatar success!!\") if __name__ == \"__main__\": app.run(host=\"localhost\", port=5700, debug=True) open() open()方法用于创建并返回一个请求对象（单纯创建，并不发送）。 参数释义： method：请求方式 url：请求地址 async：是否异步请求 注意：如果method为GET方式，则需要我们手动在url中添加参数 请求相关 send() send()方法用于发送一次网络请求。 参数释义： body：method为POST时携带的请求体数据，必须是字符串类型 注意：如果method为GET方式，则直接xhr.send(null)即可，因为GET请求没有请求体 setRequestHeader() setRequestHeader()方法用于设置请求头。 参数释义： header：请求头的key value：请求头的value 注意：每次只能设置一组请求头键值对，如果要设置多组请求头键值对请多次调用该方法 abort() abort()方法用于取消本次网络请求。 响应相关 getAllResponseHeaders() getAllResponseHeaders()方法用于获取所有响应头数据。 返回的数据类型为字符串。 getResponseHeader() getResponseHeader()方法用于获取响应头中指定header的value。 返回的数据类型为字符串。 status status属性用于返回服务端响应的HTTP响应状态码。 以下是常见的HTTP响应状态码： 200：请求成功 404：请求失败，请求的资源错误 500：请求失败，服务器内部出现错误 302：重定向 304：缓存优先 statesText statesText属性用于返回服务端响应的状态文本。 如OK、NotFound等字样。 responseText responseText属性用于返回响应体主体内容。 返回的数据类型为字符串。 回调函数 readyState readyState属性用于返回一个整数类型的状态值，它表明当前xhr对象的请求状态。 共有5种形态： 0：未初始化，尚未调用open()方法 1：已初始化，调用了open()方法，但还未调用send()方法 2：已发送，调用了send()方法，但还未收到服务端响应 3：已接收，已经收到了部分服务端响应数据 4：已完成，已经收到了全部服务端响应数据 readystatechange readystatechange事件用于设置xhr对象的readState状态发生改变时所执行的回调函数。 简单使用 contentType说明 contentType是HTTP协议中的一个请求头，它包含了浏览器告知后端服务器本次发送数据的格式。 它和表单的enctype参数类似，共有以下一些常见值的选项： 常见的媒体格式类型如下： text/html ： HTML格式 text/plain ：纯文本格式 text/xml ： XML格式 image/gif ：gif图片格式 image/jpeg ：jpg图片格式 image/png：png图片格式 以application开头的媒体格式类型： application/xhtml+xml ：XHTML格式 application/xml： XML数据格式 application/atom+xml ：Atom XML聚合格式 application/json： JSON数据格式 application/pdf：pdf格式 application/msword ： Word文档格式 application/octet-stream ： 二进制流数据（如常见的文件下载） application/x-www-form-urlencoded ： 中默认的enctype，form表单数据被编码为key/value格式发送到服务器（表单默认的提交数据的格式） 另外一种常见的媒体格式是上传文件之时使用的： multipart/form-data ： 在表单中进行文件上传时，就需要使用该格式 我们接下来会使用2种最主流的格式进行试验： application/x-www-form-urlencoded （默认的GET和POST数据格式） application/json（前端需要发送的JSON格式数据） GET请求 发送GET请求： \"use strict\"; let xhr = new XMLHttpRequest(); // 绑定回调函数 xhr.addEventListener(\"readystatechange\", () => { switch (xhr.readyState) { case 0: console.log(\"未初始化，尚未调用open()方法\"); break case 1: console.log(\"已初始化，调用了open()方法，但还未调用send()方法\"); break case 2: console.log(\"已发送，调用了send()方法，但还未收到服务端响应\"); break case 3: console.log(\"已接收，已经收到了部分服务端响应数据\"); break default: console.log(\"已完成，已经收到了全部服务端响应数据\"); if (xhr.statusText === \"OK\") { console.log(\"请求成功\"); console.log(xhr.status); console.log(xhr.statusText); console.log(xhr.responseText); } else { console.log(\"请求失败\"); console.log(xhr.status); console.log(xhr.statusText); console.log(xhr.responseText); } } }) // 请求方式，请求地址与参数，是否开启异步提交 提交的数据格式为url编码 xhr.open(\"GET\", \"http://localhost:5700/get?username=Jack&userage=18\", true); // 设置请求头，提交的数据格式为url编码 xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded; charset-UTF-8'); xhr.setRequestHeader('user_head', 'HELLO WORLD'); // 发送请求 xhr.send(null); POST请求 发送POST请求： \"use strict\"; let xhr = new XMLHttpRequest(); // 绑定回调函数 xhr.addEventListener(\"readystatechange\", () => { switch (xhr.readyState) { case 0: console.log(\"未初始化，尚未调用open()方法\"); break case 1: console.log(\"已初始化，调用了open()方法，但还未调用send()方法\"); break case 2: console.log(\"已发送，调用了send()方法，但还未收到服务端响应\"); break case 3: console.log(\"已接收，已经收到了部分服务端响应数据\"); break default: console.log(\"已完成，已经收到了全部服务端响应数据\"); if (xhr.statusText === \"OK\") { console.log(\"请求成功\"); console.log(xhr.status); console.log(xhr.statusText); console.log(xhr.responseText); } else { console.log(\"请求失败\"); console.log(xhr.status); console.log(xhr.statusText); console.log(xhr.responseText); } } }) // 请求方式，请求地址与参数，是否开启异步提交 xhr.open(\"POST\", \"http://localhost:5700/post\", true); // 设置请求头，提交的数据格式为url编码 xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded; charset-UTF-8'); xhr.setRequestHeader('user_head', 'HELLO WORLD'); // 发送请求，提交的数据格式为url编码 xhr.send(\"username=Jack&userage=18\"); JSON格式 JSON格式的数据只能由POST请求发起，并且contentType应设置为appliction/json。 示例如下： \"use strict\"; let xhr = new XMLHttpRequest(); // 绑定回调函数 xhr.addEventListener(\"readystatechange\", () => { switch (xhr.readyState) { case 0: console.log(\"未初始化，尚未调用open()方法\"); break case 1: console.log(\"已初始化，调用了open()方法，但还未调用send()方法\"); break case 2: console.log(\"已发送，调用了send()方法，但还未收到服务端响应\"); break case 3: console.log(\"已接收，已经收到了部分服务端响应数据\"); break default: console.log(\"已完成，已经收到了全部服务端响应数据\"); if (xhr.statusText === \"OK\") { console.log(\"请求成功\"); console.log(xhr.status); console.log(xhr.statusText); console.log(xhr.responseText); } else { console.log(\"请求失败\"); console.log(xhr.status); console.log(xhr.statusText); console.log(xhr.responseText); } } }) // 请求方式，请求地址与参数，是否开启异步提交 xhr.open(\"POST\", \"http://localhost:5700/json\", true); // 设置请求头 xhr.setRequestHeader('Content-Type', 'application/json'); xhr.setRequestHeader('user_head', 'HELLO WORLD'); // 发送请求 xhr.send(JSON.stringify({ \"k1\": \"v1\", \"k2\": \"v2\" })); 了解jQuery.ajax的原理 实现代码 原生的XmlHttpRequest所提供的方法太过于底层，因此我们可以对其进行封装。 这里以jQuery的Ajax为蓝本，实现一个类似功能的小组件，也是为了方便后期更加了解jQuery.Ajax()做准备。 我们准备实现的功能： 实现发送GET请求 实现发送POST请求 实现更加方便的添加请求头 实现发送JSON格式的请求数据 实现自动反序列化JSON格式的响应数据 实现文件上传 实现如下： \"use strict\"; class Ajax { constructor({ url, contentType, headers, data, beforeSend, dataFilter, success, error, complete, dataType = \"\", processData = true, type, method = type, traditional = false }) { // url：发送请求的地址，String类型 // type：发送请求的方式，String类型，它和method都可以使用 // method：发送请求的方式，String类型，它和type都可以使用 // contentType：数据编码格式，相当于form表单的enctype，String类型 // headers：设置的请求头，Object类型 // dataType：接收的响应数据类型，如果是json则自动进行反序列化，String类型 // data：发送的数据，post请求方式发送在请求体内，get请求发送会将其添加在url后，Object类型 // processData：如果为true，浏览器将采用application/x-www-form-urlencoded方式对数据进行编码，如果为false则按照传入的contentType为准，bool类型 // traditional：如果前端传递的是一个Array，如{\"k1\":[1,2,3,4]}则需要添加一个属性traditional:true，否则后端将接收不到该参数。（实际上接受的时候要使用request.POST.get(\"k1[]\")）来进行接受，这是有问题的 this.xhr = new XMLHttpRequest(); this.url = url; this.type = (type || method).toUpperCase(); this.method = method.toUpperCase(); this.headers = headers; this.contentType = processData && !contentType ? \"application/x-www-form-urlencoded\" : contentType; this.data = data; this.dataType = dataType.toLowerCase(); this.traditional = traditional; // beforeSend 在发送请求之前调用，并且传入一个XMLHttpRequest作为参数。 // dataFilter 在请求成功之后调用。传入返回的数据以及\"dataType\"参数的值。并且必须返回新的数据（可能是处理过的）传递给success回调函数，也就是说它会在success与error之前调用 // success 在请求成功之后调用。传入返回后的数据，以及包含成功代码的字符串 // error 在请求出错时调用。传入XMLHttpRequest对象，描述错误类型的字符串以及一个异常对象（如果有的话） // complete 当请求完成之后调用这个函数，无论成功或失败。传入XMLHttpRequest对象，以及一个包含成功或错误代码的字符串 this.beforeSend = beforeSend || function (xhr) { }; // 该函数默认会自动的根据dataType对象responseText进行解码 this.dataFilter = dataFilter || function (data, ty) { switch (ty) { case \"application/json\": case \"json\": this.xhr.responseJSON = JSON.parse(data); return this.xhr.responseJSON default: return data } }; this.success = success || function (data, statusText) { }; this.error = error || function (xhr, statusText) { }; this.complete = complete || function (xhr, statusText) { }; // 绑定回调函数 this.bindStateChangeEvent(); // 设置发送的数据并发送 this.setRequestData(); // 设置发送方式 this.setXhrOpen(); // 设置请求头 this.setRequestHeader(); // 发送请求 this.sendRequest(); } bindStateChangeEvent() { let data = \"\"; let textStatus = \"\"; // 绑定回调函数，这里采用匿名函数使this指向Object，否则this将指向xhr this.xhr.addEventListener(\"readystatechange\", () => { switch (this.xhr.readyState) { case 1: this.beforeSend(this.xhr); break case 4: // 回调函数dataFilter的dataType参数如果你设定了就传递设定的值，如果未设定就用响应头里的contentType进行传递 data = this.dataFilter(this.xhr.responseText, this.dataType || this.xhr.getResponseHeader(\"Content-Type\").toLowerCase()); if (this.xhr.statusText === \"OK\") { textStatus = \"success\"; this.success(data, textStatus); } else { textStatus = \"error\"; this.error(this.xhr, textStatus); } this.complete(this.xhr, textStatus); break } }); } setRequestData() { // 判断是否要进行url编码，有2种情况： // 1.contentType是application/x-www-form-urlencoded时需要url编码 // 2.传入的对象不是serialize()方法已经序列化好后的对象时不需要url编码 if (this.contentType === \"application/x-www-form-urlencoded\" && !Object.isFrozen(this.data)) { this.data = this.urlEncode(this.data); } } urlEncode() { return Object.entries(this.data).reduce((prev, cur, index, array) => { // key let key = cur[0]; // value：2种情况，如果value是普通字符串，则直接进行encodeURIComponent编码处理，如果是数组将按照 k1=v1&k2=v2 的方式进行编码，并且判断是否传入traditional let value = this.checkValueIsArray(cur); if (array.length - 1 === index) { // 判断是否是最后一位，如果是最后一位就加上& // traditional：如果前端传递的是一个Array，如{\"k1\":[1,2,3,4]}则需要添加一个属性traditional:true，否则后端将接收不到该参数。（实际上接受的时候要使用request.POST.get(\"k1[]\")）来进行接受，这是有问题的 return !this.traditional && cur[1] instanceof Array ? prev += `${key}[]=${value}` : prev += `${key}=${value}`; } else { return !this.traditional && cur[1] instanceof Array ? prev += `${key}[]=${value}&` : prev += `${key}=${value}&`; } }, \"\"); } checkValueIsArray(cur) { if (cur[1] instanceof Array) { cur[1].forEach((value, index, array) => { if (index != array.length - 1) { value = encodeURIComponent(value); array[index] = value + \"&\"; } else { array[index] = String(value); } }) // traditional：如果前端传递的是一个Array，如{\"k1\":[1,2,3,4]}则需要添加一个属性traditional:true，否则后端将接收不到该参数。（实际上接受的时候要使用request.POST.get(\"k1[]\")）来进行接受，这是有问题的，这里主要对数组中的第2个元素开始及其之后的所有元素进行url编码格式转换 return this.traditional ? cur[1].join(`${cur[0]}=`) : cur[1].join(`${cur[0]}[]=`) } else { return encodeURIComponent(cur[1]) } } setXhrOpen() { // 如果请求方式是GET请求，则在url后加上编码后的data，否则将只传递this.url // true参数为开启异步调用，也是默认的选项 this.xhr.open( this.method, this.method === \"GET\" ? this.url.concat(\"?\", this.data) : this.url, true ); } setRequestHeader() { // 在不上传文件的时候，请求头Content-Type是必须的 for (let [k, v] of Object.entries(this.headers)) { this.xhr.setRequestHeader(k, v); } if (this.contentType) { this.xhr.setRequestHeader(\"Content-Type\", this.contentType); } } sendRequest() { // 发送请求时，如果请求方式为GET将使用this.xhr.send(null)，否则将使用this.xhr.send(this.data) this.xhr.send(this.method === \"GET\" ? null : this.data); } } function getAjax(ajaxSettings) { return new Ajax(ajaxSettings); } function serialize(selector) { // 整体思路：先获取一个包含所有表单项对象，再将对象进行url编码 let formNode = document.querySelector(selector); let haveValueNodeObject = {}; Array.prototype.forEach.call(formNode.elements, (element, index, lst) => { switch (true) { // 多选或者单选select都将组成列表 case element.tagName === \"SELECT\": Array.prototype.forEach.call(element.options, (option, index, array) => { if (option.selected) { haveValueNodeObject[element.name] ? haveValueNodeObject[element.name].push(option.value) : haveValueNodeObject[element.name] = [option.value]; } }) break // 多选，组成列表 case element.type === \"checkbox\": if (element.checked) { haveValueNodeObject[element.name] ? haveValueNodeObject[element.name].push(element.value) : haveValueNodeObject[element.name] = [element.value]; } break // 单选 case element.type === \"radio\": if (element.checked) { haveValueNodeObject[element.name] = element.value } break // 其他的项目，注意文件对象不获取 default: if (element.name && element.type !== \"file\") { haveValueNodeObject[element.name] = element.value || \"\"; } } } ) // 冻结对象，代表已经经过序列化了，在发送数据时已避免url二次编码 // 这里是传入一个对象并且继承Ajax的原型对象，因为这样做才能在编码时使用checkValueIsArray方法 return Object.freeze(Ajax.prototype.urlEncode.call( { data: haveValueNodeObject, traditional: true, __proto__: Ajax.prototype }, )); } function serializeArray(selector) { // 提取form表单中的数据，并将其构建为一个name：value的数组 [{name:value}, {name:value}, {name:value}] let formNode = document.querySelector(selector); let haveValueArray = []; Array.prototype.forEach.call(formNode.elements, (element, index, lst) => { switch (true) { case element.tagName === \"SELECT\": Array.prototype.forEach.call(element.options, (option, index, array) => { if (option.selected) { haveValueArray.push({ \"name\": element.name, \"value\": option.value }); } }) break case element.type === \"checkbox\" || element.type === \"radio\": if (element.checked) { haveValueArray.push({ \"name\": element.name, \"value\": element.value }); } break default: if (element.name && element.type !== \"file\") { haveValueArray.push({ \"name\": element.name, \"value\": element.value }); } } } ) return haveValueArray; } window.$ = { ajax: getAjax, serialize, serializeArray }; 支持的上传格式 由于我们JavaScript的原生Ajax高度按照jQuery.ajax作为蓝本。所以常见的特性要与其保持一致。 如支持的原生上传数据格式实现： 仅支持上传k-v的对象，不支持上传数组（仅针对非JSON数据格式的发送） 前端上传的数据中，不允许出现对象嵌套的形式。如{\"k1\":{\"k1-1\":v1}}，这样只会得到{“k1” : “object”} 如果前端传递的是一个Array，如 {\"k1\":[1, 2, 3, 4]} 则需要添加一个属性 traditional:true，否则后端将接收不到该参数。（实际上接受的时候要使用request.POST.get(\"k1[]\")）来进行接受，这是有问题的 如果你上传的数据是json格式，当然就不会出现这些问题了。 如何发送GET请求 发送GET请求示例如下： $.ajax({ url: \"http://localhost:5700/get\", method: \"GET\", dataType: \"JSON\", headers: { \"user_head\": \"Hello World\" }, data: { name: \"Jack\", age: 18, gender: \"male\" }, success: (data, textStatus) => { console.log(\"成功\"); console.log(data); console.log(textStatus); }, error: (xhr, textStatus) => { console.log(\"失败\"); console.log(xhr); console.log(textStatus); }, complete: (xhr, textStatus) => { console.log(\"总是执行,此处可获取响应头\"); console.log(xhr); console.log(textStatus); } }) 如何发送POST请求 发送POST请求示例如下： $.ajax({ url: \"http://localhost:5700/post\", method: \"POST\", dataType: \"JSON\", headers: { \"user_head\": \"Hello World\" }, data: { name: \"Jack\", age: 18, gender: \"male\" }, success: (data, textStatus) => { console.log(\"成功\"); console.log(data); console.log(textStatus); }, error: (xhr, textStatus) => { console.log(\"失败\"); console.log(xhr); console.log(textStatus); }, complete: (xhr, textStatus) => { console.log(\"总是执行,此处可获取响应头\"); console.log(xhr); console.log(textStatus); } }) 如何发送JSON数据 发送JSON格式数据示例如下。 你需要手动指定contentType为application/json和手动的对上传数据进行序列化 如果你发送JSON格式的数据，是支持上传数组格式的数据的： $.ajax({ url: \"http://localhost:5700/json\", method: \"POST\", // 必须是POST dataType: \"JSON\", headers: { \"user_head\": \"Hello World\" }, contentType: \"application/json\", // 1.手动指定请求头中contentType的格式 data: JSON.stringify([1, 2, 3, 4, 5]), // 2.手动的对上传数据进行JSON序列化 success: (data, textStatus) => { console.log(\"成功\"); console.log(data); console.log(textStatus); }, error: (xhr, textStatus) => { console.log(\"失败\"); console.log(xhr); console.log(textStatus); }, complete: (xhr, textStatus) => { console.log(\"总是执行,此处可获取响应头\"); console.log(xhr); console.log(textStatus); } }) 如何提交form表单的数据 针对form表单提交的数据，我们可以使用封装好的2个函数serialize()和serializeArray()。 serialize()：提取form表单中的数据项，并对其做url编码处理，返回一个字符串，注意，它不会提取文件选择框 serializeArray()：提取form表单中的数据，并将其构建为一个name：value的数组，注意，它不会提取文件选择框，最终格式为 [{name : “attribute”, value : “input”}, {name : “attribute”, value : “input”}] 示例如下，如果是serialize()则直接提交即可： 用户名 密码 男 女 篮球 足球 排球 城市 北京 上海 深圳 上传头像 提交 document.querySelector(\"button\").addEventListener(\"click\", (event) => { $.ajax({ url: \"http://localhost:5700/post\", method: \"POST\", headers: { \"user_head\": \"Hello World\" }, data: $.serialize(\"#register\"), dataType: \"JSON\", success: (data, textStatus) => { console.log(\"成功\"); console.log(data); console.log(textStatus); }, error: (xhr, textStatus) => { console.log(\"失败\"); console.log(xhr); console.log(textStatus); }, complete: (xhr, textStatus) => { console.log(\"总是执行,此处可获取响应头\"); console.log(xhr); console.log(textStatus); } }) console.log($.serialize(\"#register\")); // username=%E4%BA%91%E5%B4%96&password=123&gender=male&hobby=basketball&hobby=football&city=shanghai&city=shenzhen }) 如果是serializeArray()，需要使用appliction/json的方式进行提交，因为该方法返回的是一个数组： 用户名 密码 男 女 篮球 足球 排球 城市 北京 上海 深圳 上传头像 提交 document.querySelector(\"button\").addEventListener(\"click\", (event) => { $.ajax({ url: \"http://localhost:5700/json\", method: \"POST\", headers: { \"user_head\": \"Hello World\" }, contentType: \"application/json\", // 1.手动指定请求头中contentType的格式 data: JSON.stringify($.serializeArray(\"#register\")), // 2.手动的对上传数据进行JSON序列化 dataType: \"JSON\", success: (data, textStatus) => { console.log(\"成功\"); console.log(data); console.log(textStatus); }, error: (xhr, textStatus) => { console.log(\"失败\"); console.log(xhr); console.log(textStatus); }, complete: (xhr, textStatus) => { console.log(\"总是执行,此处可获取响应头\"); console.log(xhr); console.log(textStatus); } }) console.log($.serializeArray(\"#register\")); // Array(7) // 0: {name: \"username\", value: \"云崖\"} // 1: {name: \"password\", value: \"123\"} // 2: {name: \"gender\", value: \"male\"} // 3: {name: \"hobby\", value: \"basketball\"} // 4: {name: \"hobby\", value: \"football\"} // 5: {name: \"city\", value: \"shanghai\"} // 6: {name: \"city\", value: \"shenzhen\"} }) 如何进行文件上传 如果要发送文件，我们需要借助FormData对象进行数据提交，以下是注意事项。 在表单中上传文件，必须要将enctype设置为multipart/form-data。 但是在使用XmlHttpRequest对象上传文件时，并不需要指定 contentType为multipart/form-data 格式，所以不添加contentType请求头。 contentType应设置为false，即不使用任何数据格式，不使用任何编码 processData应设置为false，不让浏览器做任何数据格式的编码 示例如下，我们使用FormData搭配serializeArray()方法实现一个真正意义上的异步提交表单： 用户名 密码 男 女 篮球 足球 排球 城市 北京 上海 深圳 上传头像 提交 document.querySelector(\"button\").addEventListener(\"click\", (event) => { // 获取上传的文件对象 let fileNode = document.querySelector(\"#avatar\"); let fileObj = fileNode.files[0]; // 使用FormData用于伪造form表单提交的数据 let fd = new FormData(); // 添加文件 fd.append(fileNode.name, fileObj); // 添加其他表单项 $.serializeArray(\"#register\").forEach((obj, index, array) => { fd.append(obj.name, obj.value); }); // 发送json格式数据 $.ajax({ url: \"http://localhost:5700/file\", method: \"POST\", headers: {\"user_head\": \"Hello World\"} data: fd, // 直接发送ForData对象即可 dataType: \"JSON\", contentType: false, // 必须设置为false processData: false, // 必须设置为false success: (data, textStatus) => { console.log(\"成功\"); console.log(data); console.log(textStatus); }, error: (xhr, textStatus) => { console.log(\"失败\"); console.log(xhr); console.log(textStatus); }, complete: (xhr, textStatus) => { console.log(\"总是执行,此处可获取响应头\"); console.log(xhr); console.log(textStatus); } }) }) Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-08-21 15:05:32 "},"前端专栏/JavaScript/JSONP.html":{"url":"前端专栏/JavaScript/JSONP.html","title":"JSONP","keywords":"","body":"同源策略 所有支持JavaScript的浏览器都不允许跨域请求资源的情况出现，这种策略被称为同源策略（Same origin policy）。 所谓同源无外乎同协议、同域名、同端口。 比如你在http://localhost:5500下发送一个请求去获取http://localhost:5700/的资源时浏览器会触发同源策略对服务端响应进行拦截。 如下图所示： 要突破同源策略只有使用CORS技术和JSONP技术，这里着重介绍JSONP。 突破同源策略的标签 JSONP适用于请求一些服务器上的公共开放接口，并不适用于内部项目开发，也就是说只有当你需要去某个服务器上取出一些开放数据时这项技术才会被使用到。 我们仔细的想想，是不是有一些标签可以发送网络请求并且无视同源策略呢？没错，在MDN Web Docs)中详细的记载了有哪些标签可以突破同源策略。 如（仅列举常见标签）： 除此之外,CSS中的@font-face字体引入也是允许突破同源策略的。 接下来该怎么做 我们可以利用JavaScript新建一个标签，并且通过src属性来访问远程服务端，那么这样就能获取到数据。 远程服务端会返回给你一个特定格式的字符串，如下所示： \"callbackfn('The data you want')\" 仔细观察不难发现，它是准备调用一个JavaScript中的函数。 如果你定义了该函数的话，当JavaScript解析返回结果时，将自动的执行该函数。 最后我们应该将这个无用的删除。 OK，到了这里我们要明白2点，整个JSONP其实是一个双向约定的过程，必须有2个必要条件： 作为服务方来说，你必须按照“callback(“other”)”的方式来定义请求的返回结果 作为请求方来说，你必须知道远程服务端返回的字符串格式，并且定义好该函数 整个JSONP请求过程图如下所示： 代码实现 前端代码实现，这里是用的vscode默认服务器打开的页面，端口号是5500： click me \"use strict\"; let btnNode = document.querySelector(\"button\"); let spanNode = document.querySelector(\"span\"); btnNode.addEventListener(\"click\", (event) => { let scriptNode = document.createElement(\"script\"); scriptNode.src = \"http://localhost:5700/\"; document.head.append(scriptNode); document.head.removeChild(scriptNode); }) function callbackfn(result) { spanNode.innerText = result; } 后端代码实现，这里采用Python的Flask框架作为后端，每次都返回一个随机数： from logging import debug, error from flask import Flask import random app = Flask(__name__) @app.route(rule=\"/\", methods=[\"GET\"], strict_slashes=False) def publicAPI(): number = random.randint(1, 100) return f\"callbackfn({number})\" if __name__ == \"__main__\": app.run(host=\"localhost\", port=5700, debug=True) 运行结果： Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-08-10 20:38:44 "},"前端专栏/JavaScript/伪Ajax请求.html":{"url":"前端专栏/JavaScript/伪Ajax请求.html","title":"伪Ajax请求","keywords":"","body":"基本介绍 我们都知道，使用表单提交数据时，会造成页面的刷新。 如果你想提交数据的同时不让页面进行刷新，则可用XMLHttpRequest发送异步网络请求。 但是在这里我们介绍一种搭配表单实现的伪Ajax请求，也能让页面不刷新的同时提交数据，它的兼容性是最好的，因为不需要借助XMLHttpRequest。 实现过程 首先，标签有一个target属性，它能规定在何处显示action URL的提交结果。 在target属性中，有一个可设置的选项为framename，即在内联框架中打开action的提交结果。 我们可以设置一个display为none的，并且将其与标签的target属性与的name属性进行绑定，这样提交后服务端的响应结果就会存储在这个标签中，接下来再通过JavaScript拿到中的响应内容即可。 注意！伪Ajax请求只能应用在前后端混合开发中，前后端分离项目中由于子页面与document主页面跨域，故不能获取到数据 也就是说，如果页面A和页面B不是来自同一个域，那么我们将不能在页面A上去获取页面B的数据，而就是一个单独的嵌套子页面 后端采用Python的Flask框架完成。 由于表单提交数据时并不会触发浏览器的同源策略，所以后端并不需要做CORS： from flask import Flask from flask import request from flask import make_response from flask import jsonify from flask.templating import render_template app = Flask(__name__, template_folder=\"./templates\") @app.route(rule=\"/\", methods=[\"GET\"]) def index(): return render_template(\"index.html\") @app.route(rule=\"/register\", methods=[\"POST\"]) def register(): user_message = { **request.values.to_dict() } avatar = request.files.get(\"avatar\") user_message[\"avatar\"] = \"uploaded success\" if avatar else \"no uploaded\" return jsonify(user_message) if __name__ == \"__main__\": app.run(host=\"localhost\", port=5700, debug=True) 前端的index.html代码： 用户名 密码 男 女 篮球 足球 排球 城市 北京 上海 深圳 上传头像 提交 \"use strict\"; let iframeNode = document.querySelector(\"iframe\"); iframeNode.addEventListener(\"load\", (event) => { // 从iframe表单中提取出内容 let submitResult = event.target.contentWindow.document.body.innerHTML; // 如果前后端分离，则因为同源策略的影响不能获取数据 document.querySelector(\"footer\").innerHTML = submitResult; }) 显示结果： 组件封装 其实伪Ajax请求用的比较少，因为它的局限性很强，就是只能在前后端混合开发时使用。 在这里我还是将它封装成一个组件，用于混合开发的朋友做一个参考，实现思路如下： 通过JavaScript创建一个，并添加name属性 接收一个表单，将其target属性设置为的name属性 注册一个回调函数 代码实现： 用户名 密码 男 女 篮球 足球 排球 城市 北京 上海 深圳 上传头像 提交 \"use strict\"; function foreAjax(selector, callbackfn = (resultText) => { }) { let node = document.querySelector(selector); let iframeNode = document.createElement(\"iframe\"); iframeNode.style.display = \"none\"; iframeNode.name = \"targetIframe\"; node.append(iframeNode); node.target = iframeNode.name; iframeNode.addEventListener(\"load\", event => { callbackfn(event.target.contentWindow.document.body.innerText); }) } // 使用方式 foreAjax(\"#register\", (resultText) => { console.log(resultText); }) Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-08-10 19:02:56 "},"前端专栏/JavaScript/Promise.html":{"url":"前端专栏/JavaScript/Promise.html","title":"Promise","keywords":"","body":"事件循环 基本介绍 JavaScript是一门单线程的编程语言，所以没有真正意义上的并行特性。 为了协调事件处理、页面交互、脚本调用、UI渲染、网络请求等行为对主线程造成的影响，事件循环（event loop）方案应运而生。 事件循环说白了就是一个不断的在等待任务、执行任务的方案。 在JavaScript中，根据执行方式的不同，有2种状态的任务，分别是同步任务和异步任务。 同步任务率先执行，而后执行异步任务，所有的异步任务由2个队列存储，分别是： 微任务队列 宏任务队列 主线程在执行完同步任务后，会不断的从这2个任务队列中按照先进先出的策略取出异步任务并执行。 并且在此期间也会有新的事件不断的加入至各个任务队列中，以此循环往复、永不阻塞。 如下图所示： 任务分类 宏任务包括： setInterval setTimeout setImmediate Node.Js独有 XHR callbackfn event callbackfn requestAnimationFrame UI rendering 微任务包括： Promise.then catch finally process.nextTick Node.Js独有 MutationObserver 执行顺序 根据任务的状态，任务的执行优先级也会有所不同，具体执行顺序如下所示： 同步任务（sync-task） 微任务（micro-task） 宏任务（macro-task） 而关于微任务和宏任务的执行，还有更详细的划分： 微任务队列中一旦有任务，将全部执行完成后再执行宏任务 宏任务队列中的任务在执行完成后，会检查微任务队列中是否有新添加的任务，如果有，那么将执行微任务队列中所有新添加的任务，如果没有则继续执行下一个宏任务 如下图所示： 代码测试： \"use strict\"; // 宏任务，每5s添加一个微任务并执行 setInterval(() => { async function foo() { return \"micro-task\" } async function bar() { let result = await foo(); console.log(result); } bar(); }, 5000); // 宏任务，每1s执行一次 setInterval(() => { console.log(\"macro-task\"); }, 1000); // 同步任务 (() => { console.log(\"hello world\"); })(); 测试结果，虽然同步任务的代码在最下面，但是它会最先执行，而每添加一个微任务时，宏任务的执行会被插队： Promise 认识Promise Promise是ES6中出现的新功能，用于在JavaScript中更加简单的实现异步编程。 我们可以使用new Promise()创建出一个Promise对象，它接收一个执行器函数，该函数需要指定resolve和reject参数用于改变当前Promise对象的执行状态。 由于Promise对象中执行器代码是属于同步任务，所以他会率先的进行执行，一个Promise对象拥有以下几种状态： fulfilled：任务完成、使用resolve改变了任务状态 rejected：任务失败、使用reject改变了任务状态，或任务执行中抛出了异常 pending：正在等待、未使用resolve或reject改变任务状态 注意，每个Promise对象的状态只允许改变一次！不可以多次更改。 示例如下。 1）Promise中执行器任务是同步任务，所以会率先执行： \"use strict\"; setInterval(() => { console.log(\"macro task 3\"); }, 1000) let task = new Promise((resolve, reject) => { console.log(\"sync task 1\"); }); console.log(\"sync task 2\"); // sync task 1 // sync task 2 // macro task 3 2）使用resolve()方法改变Promise对象的状态为fulfilled： \"use strict\"; let task = new Promise((resolve, reject) => { let x = Math.floor(Math.random() * 100) + 1; let y = Math.floor(Math.random() * 100) + 1; let result = x + y; // 返回结果为resolve()中的值 resolve(result); }); console.log(task); // Promise {: 83} 3）使用reject()方法改变Promise对象的状态为rejected， 它将引发一个异常： \"use strict\"; let task = new Promise((resolve, reject) => { let x = Math.floor(Math.random() * 100) + 1; let y = Math.floor(Math.random() * 100) + 1; let result = x + y; // 返回结果为reject()中的值 reject(\"error!\") }); console.log(task); // Promise {: \"error!\"} // Uncaught (in promise) error! 4）如果未使用resolve()或reject()方法改变Promise对象状态，那么该任务的状态将为pending： \"use strict\"; let task = new Promise((resolve, reject) => { let x = Math.floor(Math.random() * 100) + 1; let y = Math.floor(Math.random() * 100) + 1; let result = x + y; }); console.log(task); // Promise {} then() 我们可以在Promise对象后，添加一个用于处理任务状态的回调then()方法。 then()方法只有在Promise对象状态为fulfilled或者rejected时才会进行执行，它具有2个参数，接收2个回调函数： onfulfilled：Promise对象状态为fulfilled将执行该函数，具有1个参数value，接收Promise任务中resolve()所传递的值 onrejected：Promise对象状态为rejected将执行该函数，具有1个参数reason，接收Promise任务中reject()或异常发生时所传递的值 此外，then()方法是属于微任务，所以他会插在宏任务之前进行执行。 代码示例如下： 1）Promise对象状态为fulfilled，运行then()方法的第1个回调函数： \"use strict\"; let task = new Promise((resolve, reject) => { resolve(\"success\"); }).then( value => { console.log(value); }, reason => { console.log(reason); }); // success 2）Promise对象状态为rejected，运行then()方法的第2个回调函数： \"use strict\"; let task = new Promise((resolve, reject) => { throw new Error(\"error\"); }).then( value => { console.log(value); }, reason => { console.log(reason); }); // error then()链式调用 其实每一个then()都将返回一个全新的Promise，默认情况下，该Promise的状态是fulfilled。 此时就会产生一种链式关系，每一个then()都将返回一个新的Promise对象，而每个then()的作用又都是处理上个Promise对象的状态。 这意味着我们可以无限的链式排列then()，如下所示： 代码示例： \"use strict\"; let task = new Promise((resolve, reject) => { console.log(\"first Promise task status is fulfilled\"); resolve(\"success\"); }) .then( value => { console.log(\"then1 fulfilled\", value); return value }, reason => { console.log(reason); }) .then( value => { console.log(\"then2 fulfilled\", value); return value }, reason => { console.log(reason); }) .then( value => { console.log(\"then3 fulfilled\", value); return value }, reason => { console.log(reason); }); // first Promise task status is fulfilled // then1 fulfilled success // then2 fulfilled success // then3 fulfilled success then()的返回值 要想真正的了解链式调用，就必须搞明白每个then()在不同状态下的返回值对下一个then()的影响。 具体情况如下所示： 1）当前then()无返回值，则当前Promise状态则为fulfilled。 下一个then()的onfulfilled回调函数参数value为undefined： 代码示例： \"use strict\"; let task = new Promise((resolve, reject) => { console.log(\"first Promise task status is fulfilled\"); resolve(\"success\"); }) .then( value => { console.log(\"then1 fulfilled\", value); // success }, reason => { console.log(reason); }) .then( value => { console.log(\"then2 fulfilled\", value); // undefined }, reason => { console.log(reason); }); // first Promise task status is fulfilled // then1 fulfilled success // then2 fulfilled undefined 2）当前then()有返回值，则当前Promise状态则为fulfilled。 下一个then()的onfulfilled回调函数参数value为当前then()的返回值： 代码示例： let task = new Promise((resolve, reject) => { console.log(\"first Promise task status is fulfilled\"); resolve(\"success\"); }) .then( value => { console.log(\"then1 fulfilled\", value); // success return \"then1 value\" }, reason => { console.log(reason); }) .then( value => { console.log(\"then2 fulfilled\", value); // then1 value }, reason => { console.log(reason); }); // first Promise task status is fulfilled // then1 fulfilled success // then2 fulfilled then1 value 3）当前then()有返回值，且返回了一个状态为fulfilled的Promise对象。 下一个then()的onfulfilled回调函数参数value为当前then()中被返回Promise里resolve()所传递的值： 代码示例： \"use strict\"; let task = new Promise((resolve, reject) => { console.log(\"first Promise task status is fulfilled\"); resolve(\"success\"); }) .then( value => { console.log(\"then1 fulfilled\", value); // success return new Promise((resolve, reject) => { resolve(\"then1 Promise success\") }) }, reason => { console.log(reason); }) .then( value => { console.log(\"then2 fulfilled\", value); // then1 Promise success }, reason => { console.log(reason); }); // first Promise task status is fulfilled // then1 fulfilled success // then2 fulfilled then1 Promise success 4）当前then()有返回值，且返回了一个状态为rejected的Promise对象。 下一个then()的onrejected回调函数参数reason为当前then()中被返回Promise里reject()所传递的值，或者是被返回Promise里抛出异常的值： 代码示例： \"use strict\"; let task = new Promise((resolve, reject) => { console.log(\"first Promise task status is fulfilled\"); resolve(\"success\"); }) .then( value => { console.log(\"then1 fulfilled\", value); // success return new Promise((resolve, reject) => { reject(\"then1 Promise error\") }) }, reason => { console.log(reason); }) .then( value => { console.log(\"then2 fulfilled\", value); }, reason => { console.log(reason); // then1 Promise error }); // first Promise task status is fulfilled // then1 fulfilled success // then1 Promise error 5）当前then()有返回值，且返回了一个状态为pending的Promise对象。下一个then()则必须等待当前then()中被返回Promise对象状态发生改变后才能继续执行： 代码示例： \"use strict\"; let task = new Promise((resolve, reject) => { console.log(\"first Promise task status is fulfilled\"); resolve(\"success\"); }) .then( value => { console.log(\"then1 fulfilled\", value); // success return new Promise((resolve, reject) => { console.log(\"pending\"); }) }, reason => { console.log(reason); }) .then( value => { console.log(\"then2 fulfilled\", value); }, reason => { console.log(reason); }); // first Promise task status is fulfilled // then1 fulfilled success // pending 另外，如果在代码执行时抛出了异常，那么返回的Promise对象状态则为rejected，下一个then()的onrejected回调函数参数reason为当前then()中抛出异常的值，这里不再进行演示。 then()穿透 then()是具有穿透功能的，当一个then()没有指定需要被执行的回调函数时，它将继续冒泡向下传递： 代码示例： \"use strict\"; let task = new Promise((resolve, reject) => { console.log(\"first Promise task status is fulfilled\"); resolve(\"success\"); }) .then() .then( value => { console.log(\"then2 fulfilled\", value); }, reason => { console.log(reason); }); // first Promise task status is fulfilled // then2 fulfilled success catch() 每个then()都可以指定onrejected回调函数用于处理上一个Promise状态为rejected的情况。如果每个then()都进行这样的设置会显得很麻烦，所以我们只需要使用catch()即可。 catch()可以捕获之前所有Promise的错误执行，故建议将catch()放在最后。 catch()需要指定一个回调函数onrejected，具有1个参数reason，接收Promise任务中reject()或异常发生时所传递的值。 错误是冒泡传递的，如果没有任何一个then()定义onrejected的回调函数，那么错误将一直冒泡到catch()处进行处理： 代码示例： \"use strict\"; let task = new Promise((resolve, reject) => { console.log(\"first Promise task status is fulfilled\"); resolve(\"success\"); }) .then( value => { console.log(\"then1 fulfilled\", value); return value } ) .then( value => { console.log(\"then2 rejected\", value); throw new Error(\"error\"); }) .then( value => { console.log(\"then3 ...\", value); } ) .catch( reason => { console.log(reason); }); // first Promise task status is fulfilled // then1 fulfilled success // then2 rejected success // Error: error finally() finally()是无论任务处理成功或者失败都会执行，因此建议将它放在链式调用的最后面。 它需要指定一个回调函数onfinally，该回调函数没有任何参数： \"use strict\"; let task = new Promise((resolve, reject) => { console.log(\"first Promise task status is fulfilled\"); resolve(\"success\"); }) .then( value => { console.log(\"then1 fulfilled\", value); return value } ) .catch( reason => { console.log(reason); } ) .finally( () => { console.log(\"run\"); } ); // first Promise task status is fulfilled // then1 fulfilled success // run 扩展方法 resolve() resolve()方法用于快速返回一个状态为fulfilled的Promise对象，生产环境中使用较少： \"use strict\"; let task = Promise.resolve(\"success\"); console.log(task); // Promise {: \"success\"} reject() reject()方法用于快速返回一个状态为rejected的Promise对象，生产环境中使用较少： \"use strict\"; let task = Promise.reject(\"error\"); console.log(task); // Promise {: \"error\"} // Uncaught (in promise) error all() all()方法用于一次同时执行多个异步任务，并且必须确保这些任务是成功的。 all()方法接收的参数必须是可迭代类型，如Array、map、set 任何一个Promise状态为rejected，都将调用catch()方法 当所有任务成功执行后，将返回一个包含所有任务的执行结果数组 all()方法应用场景还是非常广泛的，如我们需要使用Ajax请求后端的书籍与价格信息时，不论是书籍获取失败还是价格获取失败，都将认为此次任务的失败。 示例如下： \"use strict\"; const getBookNameTask = new Promise((resolve, reject) => { // 模拟请求后端的书籍名称，需要花费3s setTimeout(() => { resolve(JSON.stringify( [\"HTML\", \"CSS\", \"JavaScript\"] )) }, 3000); }); const getBookPriceTask = new Promise((resolve, reject) => { // 模拟请求后端的书籍价格，需要花费5s setTimeout(() => { resolve(JSON.stringify( [98, 120, 40] )) }, 5000); }) // 执行任务 Promise.all( [getBookNameTask, getBookPriceTask] ) .then(value => { // 书籍和价格全部获取后才执行这里 // value = [\"[\\\"HTML\\\",\\\"CSS\\\",\\\"JavaScript\\\"]\", \"[98,120,40]\"] const bookNameArray = JSON.parse(value[0]); const bookPriceArray = JSON.parse(value[1]); const bookAndNameMap = new Map(); for (let i = 0; i { // 任何一个没获取到都执行这里 console.log(reason); }); allSettled() allSettled()方法和all()方法相似，都是用于同时执行多个异步任务，但是它并不关心所有任务是否都执行成功。 allSettled()的状态只会是fulfilled： \"use strict\"; const getBookNameTask = new Promise((resolve, reject) => { setTimeout(() => { reject(\"error! Can't query all books name\") }, 3000); }); const getBookPriceTask = new Promise((resolve, reject) => { setTimeout(() => { reject(\"error! Can't query all books price\") }, 5000); }) // 执行任务 Promise.allSettled( [getBookNameTask, getBookPriceTask] ) .then(value => { // 不管怎样都会执行这里 console.log(\"run me\"); }) race() race()也可同时执行多个任务，它仅会返回最快完成任务的执行结果。 以最快返回的任务结果为准 如果最快返回的任务状态为rejected，那么race()的状态也将视为rejected，此时将执行catch()方法 race()方法用的也比较多，如我们需要加载一些图片，这些图片在多个服务端上都有存储，但为了提高用户体验我们需要根据用户所在的地理位置选择最近的服务器，此时race()就派上了用场： \"use strict\"; const getCacheImages = new Promise((resolve, reject) => { setTimeout(() => { resolve(\"get cache images success!!\"); }, 1000); }) const getWebImages = new Promise((resolve, reject) => { setTimeout(() => { resolve(\"get web images success!!\"); }, 3000); }) // 创建任务 Promise.race( [getCacheImages, getWebImages] ) .then(value => { console.log(value); }) .catch(reason => { console.log(reason); }) // get cache images success!! async&await async async其实是new Promise()的语法糖简写形式。 在某一个函数前面加上async，运行该函数时将会返回一个Promise对象。 没有return：返回的Promise对象状态为fulfilled，下一个then()的onfulfilled回调函数参数value为undefined 直接return：返回的Promise对象状态为fulfilled，下一个then()的onfulfilled回调函数参数value为当前async函数的返回值 return了一个状态为fulfilled的Promise对象：下一个then()的onfulfilled回调函数参数value为当前async函数中被返回Promise里resolve()所传递的值 return了一个状态为rejected的Promise对象：下一个then()的onrejected回调函数参数reason为当前async函数中被返回Promise里reject()所传递的值，或者是被返回Promise里抛出异常的值 运行时抛出异常：返回的Promise对象状态为rejected，下一个then()的onrejected回调函数参数reason为当前async函数中抛出异常的值 示例演示： \"use strict\"; async function task() { return \"success\" } task().then(value => { console.log(value); }); // success await await其实是then()的另一种写法，它只能在async函数中使用。 await后面一般都会跟上一个Promise对象，如果不是Promise对象，将直接返回该值。 await使用必须在async函数中 await作为then()的语法糖形式，使用它编写代码将使代码变的更加优雅 如下所示，我们有3个任务，这3个任务必须是先通过用户ID获取人员姓名、再通过用户ID获取信息ID、最后再通过用户ID获取人员信息。 如果你用纯Promise+then()的方式进行代码编写，它将是这样的： \"use strict\"; const idAndName = new Map([ [1, \"Jack\"], [2, \"Tom\"], [3, \"Mary\"], ]); const personnelInformation = new Map([ [1, { gender: \"female\", age: 18, addr: \"TianJin\", desc: \"my name is Mary\" }], [2, { gender: \"male\", age: 21, addr: \"ShangHai\", desc: \"my name is Tom\" }], [3, { gender: \"male\", age: 18, addr: \"BeiJing\", desc: \"my name is Jack\" }], ]); const nameAndMessage = new Map([ [1, 3], [2, 2], [3, 1], ]) function getUserMessage(id) { let userName, messageId, message, str; new Promise((resolve, reject) => { // 获取姓名 if (idAndName.has(id)) { userName = idAndName.get(id); resolve(); } reject(`no information id : ${id}`); }) .then(() => { // 获取关系 messageId = nameAndMessage.get(id); }) .then(() => { // 获取信息 message = personnelInformation.get(messageId); }) .then(() => { // 进行渲染 str = `name : ${userName}`; for (let [k, v] of Object.entries(message)) { str += `${k} : ${v}`; } document.write(str) }) .catch(reason => { document.write(`${reason}`); }) } getUserMessage(3); 如果你使用async+awit的方式编写，那么它的逻辑就会清楚很多： \"use strict\"; const idAndName = new Map([ [1, \"Jack\"], [2, \"Tom\"], [3, \"Mary\"], ]); const personnelInformation = new Map([ [1, { gender: \"female\", age: 18, addr: \"TianJin\", desc: \"my name is Mary\" }], [2, { gender: \"male\", age: 21, addr: \"ShangHai\", desc: \"my name is Tom\" }], [3, { gender: \"male\", age: 18, addr: \"BeiJing\", desc: \"my name is Jack\" }], ]); const nameAndMessage = new Map([ [1, 3], [2, 2], [3, 1], ]) // 获取姓名 async function getName(id) { if (idAndName.has(id)) { return idAndName.get(id); } throw new Error(`no information id : ${id}`); } // 获取关系 async function getRelation(id) { return nameAndMessage.get(id); } // 获取信息 async function getMessage(messageId) { return personnelInformation.get(messageId); } // 入口函数，进行渲染 async function getUserMessage(id) { try { let userName = await getName(id); // 必须等待该函数执行完成才会继续向下执行 let messageId = await getRelation(id); let message = await getMessage(messageId); let str = `name : ${userName}`; for (let [k, v] of Object.entries(message)) { str += `${k} : ${v}`; } document.write(str) } catch (e) { document.write(`${e}`); } } getUserMessage(3); 异常处理 async+await的异常处理推荐使用try+catch语句将所有执行代码进行包裹，它将处理所有可能出现的异常，相当于在链式调用的最后面加上catch()方法： \"use strict\"; async function task01() { console.log(\"run task 01\"); } async function task02() { throw new Error(\"task02 error\"); console.log(\"run task 02\"); } async function task03() { console.log(\"run task 03\"); } async function main() { try { await task01(); await task02(); await task03(); } catch (e) { console.log(e); } } main(); 也可以在主函数外部使用catch()方法来处理异常，但是我并不推荐这么做。 \"use strict\"; async function task01() { console.log(\"run task 01\"); } async function task02() { throw new Error(\"task02 error\"); console.log(\"run task 02\"); } async function task03() { console.log(\"run task 03\"); } async function main() { await task01(); await task02(); await task03(); } main().catch(reason => { console.log(reason); }); 除此之外，你也可以使用try+catch语句块对单独的async函数语句块进行处理，预防可能出现的异常。 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-08-27 14:38:56 "},"前端专栏/JavaScript/手动实现Promise.html":{"url":"前端专栏/JavaScript/手动实现Promise.html","title":"手动实现Promise","keywords":"","body":"Promise状态实现 在原生Promise中具有三种状态，分别是 pending：未解决状态 fulfilled：已解决状态 rejected：解决失败状态 所以第一步，要先实现这三种状态。 并且在原生Promise中具有value用于记录执行函数resolve()与reject()中的值用于传递给then()方法。 所以我们要定义一个value： class AsyncPromise { static PENDING = \"pending\"; static FULFILLED = \"fulfilled\"; static REJECTED = \"rejected\"; constructor(executor) { this.status = AsyncPromise.PENDING; // 初始为准备状态 this.value = null; // 初始值 } } Promise执行函数 原生Promise的构造函数中会接收一个executor参数，该参数当是一个函数。 用于同步的执行当前任务，当任务完成后应该具有resolve()方法以及reject()方法来通知then()方法当前执行任务的执行状态并传递值。 class AsyncPromise { static PENDING = \"pending\"; static FULFILLED = \"fulfilled\"; static REJECTED = \"rejected\"; constructor(executor) { this.status = AsyncPromise.PENDING; // 初始状态为准备状态 this.value = null; // 初始值 executor(this.resolve, this.reject); // 传递形参，运行executor函数 } resolve(value) { this.status = AsyncPromise.FULFILLED; this.value = value; } reject(reason) { this.status = AsyncPromise.REJECTED; this.value = reason; } } 上面这样写在执行resolve()以及reject()时会出现问题，原因是this指向为undefiled(严格模式)。 \"use strict\"; let task = new AsyncPromise((resolve, reject) => { resolve(\"成功\") }) console.log(task); // undefined 这是由于我们在执行函数中调用了resolve()与reject()，故this指向为executor的函数上下文。 解决这个问题可以使用bind()来改变this指向。 class AsyncPromise { static PENDING = \"pending\"; static FULFILLED = \"fulfilled\"; static REJECTED = \"rejected\"; constructor(executor) { this.status = AsyncPromise.PENDING; // 初始状态为准备状态 this.value = null; // 初始值 executor(this.resolve.bind(this), this.reject.bind(this)); // 传递形参，运行executor函数 } resolve(value) { this.status = AsyncPromise.FULFILLED; this.value = value; } reject(reason) { this.status = AsyncPromise.REJECTED; this.value = reason; } } Promise状态限制 当前Promise状态只应该改变一次而不能多次改变，显然我们上面的代码不能做到这点限制。 \"use strict\"; let task = new AsyncPromise((resolve, reject) => { resolve(\"成功\"); reject(\"失败\"); // 对于原生Promise来说，状态只能改变一次。但是这里却允许两次改变，故是有问题的 }) console.log(task); // AsyncPromise {status: \"rejected\", value: \"失败\"} 所以这里要对代码加上限制。 class AsyncPromise { static PENDING = \"pending\"; static FULFILLED = \"fulfilled\"; static REJECTED = \"rejected\"; constructor(executor) { this.status = AsyncPromise.PENDING; // 初始状态为准备状态 this.value = null; // 初始值 executor(this.resolve.bind(this), this.reject.bind(this)); // 传递形参，运行executor函数 } resolve(value) { if (this.status == AsyncPromise.PENDING) { // 限制 this.status = AsyncPromise.FULFILLED; this.value = value; } } reject(reason) { if (this.status == AsyncPromise.PENDING) { // 限制 this.status = AsyncPromise.REJECTED; this.value = reason; } } } Promise执行异常 在执行函数executor中可能引发异常，这会让当前的Promise的状态改变为rejected。 所以在上面代码基础上需要加入try/catch进行处理。 当then()方法捕捉到执行函数executor中的异常时，可以让第二个参数的函数对其异常进行处理，但是我们目前还没实现then()，所以直接丢给reject()即可，当实现then()时自然会使用到reject()中传递过来的值。 class AsyncPromise { static PENDING = \"pending\"; static FULFILLED = \"fulfilled\"; static REJECTED = \"rejected\"; constructor(executor) { this.status = AsyncPromise.PENDING; // 初始状态为准备状态 this.value = null; // 初始值 try { executor(this.resolve.bind(this), this.reject.bind(this)); // 传递形参，运行executor函数 } catch (e) { this.status = AsyncPromise.REJECTED; // 异常发生改变状态 this.reject(e); // 记录异常信息 } } resolve(value) { if (this.status == AsyncPromise.PENDING) { // 限制 this.status = AsyncPromise.FULFILLED; this.value = value; } } reject(reason) { if (this.status == AsyncPromise.PENDING) { // 限制 this.status = AsyncPromise.REJECTED; this.value = reason; } } } then方法基础实现 原生的Promise状态改变后，可以执行其下的then()方法，所以我们需要来封装出一个then()方法。 then()方法接收两个函数，第一个函数onfulfilled用于处理上一个Promise的fulfilled状态，第二个函数onrejected用于处理上一个Promise的rejected状态。 并且then()方法中的这两个函数都应该具有一个形参，用于接收到Promise的resolve()或reject()中传递的值。 class AsyncPromise { static PENDING = \"pending\"; static FULFILLED = \"fulfilled\"; static REJECTED = \"rejected\"; constructor(executor) { this.status = AsyncPromise.PENDING; // 初始状态为准备状态 this.value = null; // 初始值 try { executor(this.resolve.bind(this), this.reject.bind(this)); // 传递形参，运行executor函数 } catch (e) { this.status = AsyncPromise.REJECTED; // 异常发生改变状态 this.reject(e); // 记录异常信息 } } resolve(value) { if (this.status == AsyncPromise.PENDING) { // 限制 this.status = AsyncPromise.FULFILLED; this.value = value; } } reject(reason) { if (this.status == AsyncPromise.PENDING) { // 限制 this.status = AsyncPromise.REJECTED; this.value = reason; } } then(onfulfilled, onrejected) { if (this.status == AsyncPromise.FULFILLED) { // 状态改变时执行 onfulfilled(this.value); } if (this.status == AsyncPromise.REJECTED) { // 状态改变时执行 onrejected(this.value); } } } then方法参数优化 上面已经说过，then()方法具有两个参数，这两个参数分别对应两个函数用来处理上一个Promsie的resolve()与reject()。 但是在原生Promise中，这两个方法可以不进行传递，所以我们需要对上述代码进行优化。 当then()方法中的某一个参数不为函数时，让它自动创建一个空函数。 class AsyncPromise { static PENDING = \"pending\"; static FULFILLED = \"fulfilled\"; static REJECTED = \"rejected\"; constructor(executor) { this.status = AsyncPromise.PENDING; // 初始状态为准备状态 this.value = null; // 初始值 try { executor(this.resolve.bind(this), this.reject.bind(this)); // 传递形参，运行executor函数 } catch (e) { this.status = AsyncPromise.REJECTED; // 异常发生改变状态 this.reject(e); // 记录异常信息 } } resolve(value) { if (this.status == AsyncPromise.PENDING) { // 限制 this.status = AsyncPromise.FULFILLED; this.value = value; } } reject(reason) { if (this.status == AsyncPromise.PENDING) { // 限制 this.status = AsyncPromise.REJECTED; this.value = reason; } } then(onfulfilled, onrejected) { if (typeof onfulfilled != \"function\") { // 如果传入的不是一个函数，默认创建空函数 onfulfilled = () => { }; } if (typeof onrejected != \"function\") { // 如果传入的不是一个函数，默认创建空函数 onrejected = () => { }; } if (this.status == AsyncPromise.FULFILLED) { // 状态改变时执行 onfulfilled(this.value); } if (this.status == AsyncPromise.REJECTED) { // 状态改变时执行 onrejected(this.value); } } } then方法异常捕获 当then()方法中处理fulfilled状态的函数onfulfilled或者处理rejected状态的函数onrejected在运行时出现异常应该进行捕获并且传递给下一个then()的处理rejected状态的函数onrejected。 这里我们先让所有的异常都交由当前then()处理rejected状态的函数onrejected，后面再进行优化。 class AsyncPromise { static PENDING = \"pending\"; static FULFILLED = \"fulfilled\"; static REJECTED = \"rejected\"; constructor(executor) { this.status = AsyncPromise.PENDING; // 初始状态为准备状态 this.value = null; // 初始值 try { executor(this.resolve.bind(this), this.reject.bind(this)); // 传递形参，运行executor函数 } catch (e) { this.status = AsyncPromise.REJECTED; // 异常发生改变状态 this.reject(e); // 记录异常信息 } } resolve(value) { if (this.status == AsyncPromise.PENDING) { // 限制 this.status = AsyncPromise.FULFILLED; this.value = value; } } reject(reason) { if (this.status == AsyncPromise.PENDING) { // 限制 this.status = AsyncPromise.REJECTED; this.value = reason; } } then(onfulfilled, onrejected) { if (typeof onfulfilled != \"function\") { // 如果传入的不是一个函数，默认创建空函数 onfulfilled = () => { }; } if (typeof onrejected != \"function\") { // 如果传入的不是一个函数，默认创建空函数 onrejected = () => { }; } if (this.status == AsyncPromise.FULFILLED) { // 状态改变时执行 try { // then处理成功的函数onfulfilled中出现异常，交由当前then处理失败的函数onrejected函数进行处理。这个后面会做优化 onfulfilled(this.value); } catch (e) { onrejected(e); } } if (this.status == AsyncPromise.REJECTED) { // 状态改变时执行 try { // then处理失败的函数onrejected中出现异常,交由当前then处理失败的函数onrejected函数进行处理。这个后面会做优化 onrejected(this.value); } catch (e) { onrejected(e); } } } } then方法异步执行 在原生的Promise中，executor函数是同步执行的，而then()方法是异步执行故排在同步执行之后。 但是我们的Promise却没有做到这一点，下面的实验将说明这个问题 \"use strict\"; let task = new AsyncPromise((resolve, reject) => { reject(\"失败\"); }).then( null, error => { console.log(error); // 先打印 失败 } ) console.log(\"hello,Promise\"); // 后打印 hello,Promise 最简单的解决方案就是为then()中处理成功或处理失败的函数运行外套上一个setTimeout，让其处理排在线程同步任务执行之后再进行执行。 class AsyncPromise { static PENDING = \"pending\"; static FULFILLED = \"fulfilled\"; static REJECTED = \"rejected\"; constructor(executor) { this.status = AsyncPromise.PENDING; // 初始状态为准备状态 this.value = null; // 初始值 try { executor(this.resolve.bind(this), this.reject.bind(this)); // 传递形参，运行executor函数 } catch (e) { this.status = AsyncPromise.REJECTED; // 异常发生改变状态 this.reject(e); // 记录异常信息 } } resolve(value) { if (this.status == AsyncPromise.PENDING) { // 限制 this.status = AsyncPromise.FULFILLED; this.value = value; } } reject(reason) { if (this.status == AsyncPromise.PENDING) { // 限制 this.status = AsyncPromise.REJECTED; this.value = reason; } } then(onfulfilled, onrejected) { if (typeof onfulfilled != \"function\") { // 如果传入的不是一个函数，默认创建空函数 onfulfilled = () => { }; } if (typeof onrejected != \"function\") { // 如果传入的不是一个函数，默认创建空函数 onrejected = () => { }; } if (this.status == AsyncPromise.FULFILLED) { // 状态改变时执行 setTimeout(() => { // 晚于线程同步任务执行 try { // then处理成功的函数onfulfilled中出现异常，交由当前then处理失败的函数onrejected函数进行处理。这个后面会做优化 onfulfilled(this.value); } catch (e) { onrejected(e); } }) } if (this.status == AsyncPromise.REJECTED) { // 状态改变时执行 setTimeout(() => { // 晚于线程同步任务执行 try { // then处理失败的函数onrejected中出现异常,交由当前then处理失败的函数onrejected函数进行处理。这个后面会做优化 onrejected(this.value); } catch (e) { onrejected(e); } }) } } } 执行函数异步阻塞 此时我们的代码仍然具有一个问题，即在执行函数executor中使用setTimeout时，下面的then()会进行阻塞。 这是因为当前Promise状态是pending而then()方法中并没有对pending状态进行处理的策略所导致的。 \"use strict\"; new AsyncPromise((resolve, reject) => { setTimeout(() => { resolve(\"成功\"); // 同步任务执行完三秒后才会改变当前Promise状态 }, 3000); }).then((success) => { // 但是这里先执行了then，Promise状态为pending，故发生阻塞 console.log(success); // 阻塞了，不打印 }) 既然当前Promise状态是pending，3秒后状态才发生改变，那么我们就可以通过不断的循环来看看它何时改变状态。 所以第一步是定义一个执行异步的数组。然后再将then()中处理正确的函数onfulfilled与处理错误的函数onrejected压进去。 class AsyncPromise { static PENDING = \"pending\"; static FULFILLED = \"fulfilled\"; static REJECTED = \"rejected\"; constructor(executor) { this.status = AsyncPromise.PENDING; // 初始状态为准备状态 this.value = null; // 初始值 this.callbacks = []; // 如果是一个异步操作，则放入该数组中 try { executor(this.resolve.bind(this), this.reject.bind(this)); // 传递形参，运行executor函数 } catch (e) { this.status = AsyncPromise.REJECTED; // 异常发生改变状态 this.reject(e); // 记录异常信息 } } resolve(value) { if (this.status == AsyncPromise.PENDING) { // 限制 this.status = AsyncPromise.FULFILLED; this.value = value; }) } } reject(reason) { if (this.status == AsyncPromise.PENDING) { // 限制 this.status = AsyncPromise.REJECTED; this.value = reason; } } then(onfulfilled, onrejected) { if (typeof onfulfilled != \"function\") { // 如果传入的不是一个函数，默认创建空函数 onfulfilled = () => { }; } if (typeof onrejected != \"function\") { // 如果传入的不是一个函数，默认创建空函数 onrejected = () => { }; } if (this.status == AsyncPromise.FULFILLED) { // 状态改变时执行 setTimeout(() => { // 晚于线程同步任务执行 try { // then处理成功的函数onfulfilled中出现异常，交由当前then处理失败的函数onrejected函数进行处理。这个后面会做优化 onfulfilled(this.value); } catch (e) { onrejected(e); } }) } if (this.status == AsyncPromise.REJECTED) { // 状态改变时执行 setTimeout(() => { // 晚于线程同步任务执行 try { // then处理失败的函数onrejected中出现异常,交由当前then处理失败的函数onrejected函数进行处理。这个后面会做优化 onrejected(this.value); } catch (e) { onrejected(e); } }) } if (this.status == AsyncPromise.PENDING) { // 如果当前Promise是等待处理状态，则将处理成功的函数与处理失败的函数压入异步数组。 this.callbacks.push({ onfulfilled, onrejected, }); } } } 当数组压入完成后，执行函数executor会去调用resolve()或者reject()改变当前Promise状态。 所以我们还需要在resolve()与reject()方法中对异步的数组处理函数进行调用。 class AsyncPromise { static PENDING = \"pending\"; static FULFILLED = \"fulfilled\"; static REJECTED = \"rejected\"; constructor(executor) { this.status = AsyncPromise.PENDING; // 初始状态为准备状态 this.value = null; // 初始值 this.callbacks = []; // 如果是一个异步操作，则放入该数组中 try { executor(this.resolve.bind(this), this.reject.bind(this)); // 传递形参，运行executor函数 } catch (e) { this.status = AsyncPromise.REJECTED; // 异常发生改变状态 this.reject(e); // 记录异常信息 } } resolve(value) { if (this.status == AsyncPromise.PENDING) { // 限制 this.status = AsyncPromise.FULFILLED; this.value = value; this.callbacks.map(callback => { // // 调用处理异步executor里resolve的方法。 callback.onfulfilled(value); }) } } reject(reason) { if (this.status == AsyncPromise.PENDING) { // 限制 this.status = AsyncPromise.REJECTED; this.value = reason; this.callbacks.map(callback => { // 调用处理异步executor里reject的方法。 callback.onrejected(reason); }) } } then(onfulfilled, onrejected) { if (typeof onfulfilled != \"function\") { // 如果传入的不是一个函数，默认创建空函数 onfulfilled = () => { }; } if (typeof onrejected != \"function\") { // 如果传入的不是一个函数，默认创建空函数 onrejected = () => { }; } if (this.status == AsyncPromise.FULFILLED) { // 状态改变时执行 setTimeout(() => { // 晚于线程同步任务执行 try { // then处理成功的函数onfulfilled中出现异常，交由当前then处理失败的函数onrejected函数进行处理。这个后面会做优化 onfulfilled(this.value); } catch (e) { onrejected(e); } }) } if (this.status == AsyncPromise.REJECTED) { // 状态改变时执行 setTimeout(() => { // 晚于线程同步任务执行 try { // then处理失败的函数onrejected中出现异常,交由当前then处理失败的函数onrejected函数进行处理。这个后面会做优化 onrejected(this.value); } catch (e) { onrejected(e); } }) } if (this.status == AsyncPromise.PENDING) { // 如果当前Promise是等待处理状态，则将处理成功的函数与处理失败的函数压入异步数组。 this.callbacks.push({ onfulfilled, onrejected, }); } } } 异步执行函数的then异常捕获 上面我们对同步执行函数executor调用then()方法中可能出现的异常进行了处理。 就是下面这一段代码。 if (this.status == AsyncPromise.FULFILLED) { // 状态改变时执行 setTimeout(() => { // 晚于线程同步任务执行 try { // then处理成功的函数onfulfilled中出现异常，交由当前then处理失败的函数onrejected函数进行处理。这个后面会做优化 onfulfilled(this.value); } catch (e) { onrejected(e); } }) } if (this.status == AsyncPromise.REJECTED) { // 状态改变时执行 setTimeout(() => { // 晚于线程同步任务执行 try { // then处理失败的函数onrejected中出现异常,交由当前then处理失败的函数onrejected函数进行处理。这个后面会做优化 onrejected(this.value); } catch (e) { onrejected(e); } }) } 但是我们还没有对异步执行函数executor调用then()方法中可能出现的异常进行处理。 if (this.status == AsyncPromise.PENDING) { // 如果当前Promise是等待处理状态，则将处理成功的函数与处理失败的函数压入异步数组。 this.callbacks.push({ onfulfilled, onrejected, }); } } 这会导致下面这样的使用场景出现问题。 \"use strict\"; new AsyncPromise((resolve, reject) => { setTimeout(() => { resolve(\"成功\"); }, 3000); }).then((success) => { throw new Error(\"自定义异常抛出\"); // 直接在处理成功状态的函数onfulfilled中抛出了异常，显然是不符合原生Promise的 }); 那么我们就来加上异常捕获即可，这里还是先传递给当前then()处理rejected状态的函数，后面会做修改。 因为原版Promise会传递给下一个then()中处理rejected状态的函数，而不是当前then()。 class AsyncPromise { static PENDING = \"pending\"; static FULFILLED = \"fulfilled\"; static REJECTED = \"rejected\"; constructor(executor) { this.status = AsyncPromise.PENDING; // 初始状态为准备状态 this.value = null; // 初始值 this.callbacks = []; // 如果是一个异步操作，则放入该数组中 try { executor(this.resolve.bind(this), this.reject.bind(this)); // 传递形参，运行executor函数 } catch (e) { this.status = AsyncPromise.REJECTED; // 异常发生改变状态 this.reject(e); // 记录异常信息 } } resolve(value) { if (this.status == AsyncPromise.PENDING) { // 限制 this.status = AsyncPromise.FULFILLED; this.value = value; this.callbacks.map(callback => { // // 调用处理异步executor里resolve的方法。 callback.onfulfilled(value); }) } } reject(reason) { if (this.status == AsyncPromise.PENDING) { // 限制 this.status = AsyncPromise.REJECTED; this.value = reason; this.callbacks.map(callback => { // 调用处理异步executor里reject的方法。 callback.onrejected(reason); }) } } then(onfulfilled, onrejected) { if (typeof onfulfilled != \"function\") { // 如果传入的不是一个函数，默认创建空函数 onfulfilled = () => { }; } if (typeof onrejected != \"function\") { // 如果传入的不是一个函数，默认创建空函数 onrejected = () => { }; } if (this.status == AsyncPromise.FULFILLED) { // 状态改变时执行 setTimeout(() => { // 晚于线程同步任务执行 try { // then处理成功的函数onfulfilled中出现异常，交由当前then处理失败的函数onrejected函数进行处理。这个后面会做优化 onfulfilled(this.value); } catch (e) { onrejected(e); } }) } if (this.status == AsyncPromise.REJECTED) { // 状态改变时执行 setTimeout(() => { // 晚于线程同步任务执行 try { // then处理失败的函数onrejected中出现异常,交由当前then处理失败的函数onrejected函数进行处理。这个后面会做优化 onrejected(this.value); } catch (e) { onrejected(e); } }) } if (this.status == AsyncPromise.PENDING) { // 如果当前Promise是等待处理状态，则将处理成功的函数与处理失败的函数压入异步数组。 this.callbacks.push({ onfulfilled: value => { try { // 异步executor改变状态对其then中的onfulfilled进行异常捕获 onfulfilled(value); } catch (e) { onrejected(e); } }, onrejected: value => { try { // 异步executor改变状态对其then中的onrejected进行异常捕获 onrejected(value); } catch (e) { onrejected(e); } } }); } } } then方法链式操作 对于原生的Promise来讲，每一个then()最后返回的都是一个新的Promise。所以才能达到支持不断的then()进行链式操作，所以我们也可以这样做。 class AsyncPromise { static PENDING = \"pending\"; static FULFILLED = \"fulfilled\"; static REJECTED = \"rejected\"; constructor(executor) { this.status = AsyncPromise.PENDING; // 初始状态为准备状态 this.value = null; // 初始值 this.callbacks = []; // 如果是一个异步操作，则放入该数组中 try { executor(this.resolve.bind(this), this.reject.bind(this)); // 传递形参，运行executor函数 } catch (e) { this.status = AsyncPromise.REJECTED; // 异常发生改变状态 this.reject(e); // 记录异常信息 } } resolve(value) { if (this.status == AsyncPromise.PENDING) { // 限制 this.status = AsyncPromise.FULFILLED; this.value = value; this.callbacks.map(callback => { // // 调用处理异步executor里resolve的方法。 callback.onfulfilled(value); }) } } reject(reason) { if (this.status == AsyncPromise.PENDING) { // 限制 this.status = AsyncPromise.REJECTED; this.value = reason; this.callbacks.map(callback => { // 调用处理异步executor里reject的方法。 callback.onrejected(reason); }) } } then(onfulfilled, onrejected) { if (typeof onfulfilled != \"function\") { // 如果传入的不是一个函数，默认创建空函数 onfulfilled = () => { }; } if (typeof onrejected != \"function\") { // 如果传入的不是一个函数，默认创建空函数 onrejected = () => { }; } return new AsyncPromise((resolve, reject) => { // 返回一个新的Promise if (this.status == AsyncPromise.FULFILLED) { // 状态改变时执行 setTimeout(() => { // 晚于线程同步任务执行 try { // then处理成功的函数onfulfilled中出现异常，交由当前then处理失败的函数onrejected函数进行处理。这个后面会做优化 onfulfilled(this.value); } catch (e) { onrejected(e); } }) } if (this.status == AsyncPromise.REJECTED) { // 状态改变时执行 setTimeout(() => { // 晚于线程同步任务执行 try { // then处理失败的函数onrejected中出现异常,交由当前then处理失败的函数onrejected函数进行处理。这个后面会做优化 onrejected(this.value); } catch (e) { onrejected(e); } }) } if (this.status == AsyncPromise.PENDING) { // 如果当前Promise是等待处理状态，则将处理成功的函数与处理失败的函数压入异步数组。 this.callbacks.push({ onfulfilled: value => { try { // 异步executor改变状态对其then中的onfulfilled进行异常捕获 onfulfilled(value); } catch (e) { onrejected(e); } }, onrejected: value => { try { // 异步executor改变状态对其then中的onrejected进行异常捕获 onrejected(value); } catch (e) { onrejected(e); } } }); } }); } } 现在我们的Promise已经支持then()的链式操作了，但是上面代码还是遗留了几个问题。 then()还没有返回值，返回普通值该怎么处理，返回一个新的Promise该怎么处理 没有异常传递，原生Promise中的then()当抛出异常时应该进行捕获并传递给下一个then() 不支持then()穿透 不支持类型限制 接下来继续对代码做出优化调整。 then中返回普通值 在原生的Promise中每一个then()所产生的Promise默认状态都是fulfilled，如果当前then()返回是一个值的话那么下一个then()将接受到该值。 这个也非常简单，代码接收一下每一个onfulfilled()与onrejected()的返回值就好，并使用resolve()改变状态为fulfilled以及将值进行传递给下一个then()。 class AsyncPromise { static PENDING = \"pending\"; static FULFILLED = \"fulfilled\"; static REJECTED = \"rejected\"; constructor(executor) { this.status = AsyncPromise.PENDING; // 初始状态为准备状态 this.value = null; // 初始值 this.callbacks = []; // 如果是一个异步操作，则放入该数组中 try { executor(this.resolve.bind(this), this.reject.bind(this)); // 传递形参，运行executor函数 } catch (e) { this.status = AsyncPromise.REJECTED; // 异常发生改变状态 this.reject(e); // 记录异常信息 } } resolve(value) { if (this.status == AsyncPromise.PENDING) { // 限制 this.status = AsyncPromise.FULFILLED; this.value = value; this.callbacks.map(callback => { // // 调用处理异步executor里resolve的方法。 callback.onfulfilled(value); }) } } reject(reason) { if (this.status == AsyncPromise.PENDING) { // 限制 this.status = AsyncPromise.REJECTED; this.value = reason; this.callbacks.map(callback => { // 调用处理异步executor里reject的方法。 callback.onrejected(reason); }) } } then(onfulfilled, onrejected) { if (typeof onfulfilled != \"function\") { // 如果传入的不是一个函数，默认创建空函数 onfulfilled = () => { }; } if (typeof onrejected != \"function\") { // 如果传入的不是一个函数，默认创建空函数 onrejected = () => { }; } return new AsyncPromise((resolve, reject) => { // 返回一个新的Promise if (this.status == AsyncPromise.FULFILLED) { // 状态改变时执行 setTimeout(() => { // 晚于线程同步任务执行 try { // then处理成功的函数onfulfilled中出现异常，交由当前then处理失败的函数onrejected函数进行处理。这个后面会做优化 let result = onfulfilled(this.value); resolve(result); } catch (e) { onrejected(e); } }) } if (this.status == AsyncPromise.REJECTED) { // 状态改变时执行 setTimeout(() => { // 晚于线程同步任务执行 try { // then处理失败的函数onrejected中出现异常,交由当前then处理失败的函数onrejected函数进行处理。这个后面会做优化 let result = onrejected(this.value); resolve(result); } catch (e) { onrejected(e); } }) } if (this.status == AsyncPromise.PENDING) { // 如果当前Promise是等待处理状态，则将处理成功的函数与处理失败的函数压入异步数组。 this.callbacks.push({ onfulfilled: value => { try { // 异步executor改变状态对其then中的onfulfilled进行异常捕获 let result = onfulfilled(value); resolve(result); } catch (e) { onrejected(e); } }, onrejected: value => { try { // 异步executor改变状态对其then中的onrejected进行异常捕获 let result = onrejected(value); resolve(result); } catch (e) { onrejected(e); } } }); } }); } } 这样我们的then()就支持返回普通值了。 \"use strict\"; new AsyncPromise((resolve, reject) => { setTimeout(() => { resolve(\"成功\"); }, 3000); }).then((success) => { return \"hello\"; }).then((success) => { console.log(success); // hello }); then中的异常传递 在上面的代码中，then()方法里的处理成功函数onfulfilled以及处理失败函数onrejected在代码执行时抛出的异常都会统一进行捕获并且传递给当前then()方法处理失败的函数onrejected。 这个与原生的Promise有出入，对于原生Promise来讲应该是传递给下一个then()进行处理而不是当前then()。 改动也非常简单，将原来发生异常传递的函数onrejected()改为reject()即可，这就是传递给下一个then()。 class AsyncPromise { static PENDING = \"pending\"; static FULFILLED = \"fulfilled\"; static REJECTED = \"rejected\"; constructor(executor) { this.status = AsyncPromise.PENDING; // 初始状态为准备状态 this.value = null; // 初始值 this.callbacks = []; // 如果是一个异步操作，则放入该数组中 try { executor(this.resolve.bind(this), this.reject.bind(this)); // 传递形参，运行executor函数 } catch (e) { this.status = AsyncPromise.REJECTED; // 异常发生改变状态 this.reject(e); // 记录异常信息 } } resolve(value) { if (this.status == AsyncPromise.PENDING) { // 限制 this.status = AsyncPromise.FULFILLED; this.value = value; this.callbacks.map(callback => { // // 调用处理异步executor里resolve的方法。 callback.onfulfilled(value); }) } } reject(reason) { if (this.status == AsyncPromise.PENDING) { // 限制 this.status = AsyncPromise.REJECTED; this.value = reason; this.callbacks.map(callback => { // 调用处理异步executor里reject的方法。 callback.onrejected(reason); }) } } then(onfulfilled, onrejected) { if (typeof onfulfilled != \"function\") { // 如果传入的不是一个函数，默认创建空函数 onfulfilled = () => { }; } if (typeof onrejected != \"function\") { // 如果传入的不是一个函数，默认创建空函数 onrejected = () => { }; } return new AsyncPromise((resolve, reject) => { // 返回一个新的Promise if (this.status == AsyncPromise.FULFILLED) { // 状态改变时执行 setTimeout(() => { // 晚于线程同步任务执行 try { let result = onfulfilled(this.value); resolve(result); } catch (e) { reject(e); // 传递给下一个then } }) } if (this.status == AsyncPromise.REJECTED) { // 状态改变时执行 setTimeout(() => { // 晚于线程同步任务执行 try { let result = onrejected(this.value); resolve(result); } catch (e) { reject(e); // 传递给下一个then } }) } if (this.status == AsyncPromise.PENDING) { // 如果当前Promise是等待处理状态，则将处理成功的函数与处理失败的函数压入异步数组。 this.callbacks.push({ onfulfilled: value => { try { let result = onfulfilled(value); resolve(result); } catch (e) { reject(e); // 传递给下一个then } }, onrejected: value => { try { let result = onrejected(value); resolve(result); } catch (e) { reject(e); // 传递给下一个then } } }); } }); } } 代码测试： \"use strict\"; new AsyncPromise((resolve, reject) => { setTimeout(() => { resolve(\"成功\"); }, 3000); }).then((success) => { throw new Error(\"新错误\"); }).then(null, error => { console.log(error); // 上一个then的错误成功由该then接收 }); then穿透功能实现 在原生的Promise中是支持then()的穿透传值的。 \"use strict\"; new Promise((resolve, reject) => { resolve(\"成功\"); }) .then() // 穿透 .then( success => { console.log(success); // 成功 }, error => { console.log(error); }) 但是我们的Promise却不支持。 \"use strict\"; new AsyncPromise((resolve, reject) => { resolve(\"成功\"); }) .then() // 不支持穿透 .then( success => { console.log(success); }, error => { console.log(error); }) 原因在于如果没有对then()进行传递参数，那么内部其实是会创建两个空函数。 我们只需要在空函数内部返回this.value即可。 class AsyncPromise { static PENDING = \"pending\"; static FULFILLED = \"fulfilled\"; static REJECTED = \"rejected\"; constructor(executor) { this.status = AsyncPromise.PENDING; // 初始状态为准备状态 this.value = null; // 初始值 this.callbacks = []; // 如果是一个异步操作，则放入该数组中 try { executor(this.resolve.bind(this), this.reject.bind(this)); // 传递形参，运行executor函数 } catch (e) { this.status = AsyncPromise.REJECTED; // 异常发生改变状态 this.reject(e); // 记录异常信息 } } resolve(value) { if (this.status == AsyncPromise.PENDING) { // 限制 this.status = AsyncPromise.FULFILLED; this.value = value; this.callbacks.map(callback => { // // 调用处理异步executor里resolve的方法。 callback.onfulfilled(value); }) } } reject(reason) { if (this.status == AsyncPromise.PENDING) { // 限制 this.status = AsyncPromise.REJECTED; this.value = reason; this.callbacks.map(callback => { // 调用处理异步executor里reject的方法。 callback.onrejected(reason); }) } } then(onfulfilled, onrejected) { if (typeof onfulfilled != \"function\") { // 如果传入的不是一个函数，默认创建空函数 onfulfilled = () => this.value; // 支持穿透 } if (typeof onrejected != \"function\") { // 如果传入的不是一个函数，默认创建空函数 onrejected = () => this.value; // 支持穿透 } return new AsyncPromise((resolve, reject) => { // 返回一个新的Promise if (this.status == AsyncPromise.FULFILLED) { // 状态改变时执行 setTimeout(() => { // 晚于线程同步任务执行 try { let result = onfulfilled(this.value); resolve(result); } catch (e) { reject(e); // 传递给下一个then } }) } if (this.status == AsyncPromise.REJECTED) { // 状态改变时执行 setTimeout(() => { // 晚于线程同步任务执行 try { let result = onrejected(this.value); resolve(result); } catch (e) { reject(e); // 传递给下一个then } }) } if (this.status == AsyncPromise.PENDING) { // 如果当前Promise是等待处理状态，则将处理成功的函数与处理失败的函数压入异步数组。 this.callbacks.push({ onfulfilled: value => { try { let result = onfulfilled(value); resolve(result); } catch (e) { reject(e); // 传递给下一个then } }, onrejected: value => { try { let result = onrejected(value); resolve(result); } catch (e) { reject(e); // 传递给下一个then } } }); } }); } } then返回Promise 原生的Promise支持返回一个新的Promise，但是我们的Promise现在还不支持。 其实也很简单，判断一下then()中两个函数返回的是不是一个新的Promise，如果是的话则使用其then()方法将其中resolve()或reject()的值进行传递。 class AsyncPromise { static PENDING = \"pending\"; static FULFILLED = \"fulfilled\"; static REJECTED = \"rejected\"; constructor(executor) { this.status = AsyncPromise.PENDING; // 初始状态为准备状态 this.value = null; // 初始值 this.callbacks = []; // 如果是一个异步操作，则放入该数组中 try { executor(this.resolve.bind(this), this.reject.bind(this)); // 传递形参，运行executor函数 } catch (e) { this.status = AsyncPromise.REJECTED; // 异常发生改变状态 this.reject(e); // 记录异常信息 } } resolve(value) { if (this.status == AsyncPromise.PENDING) { // 限制 this.status = AsyncPromise.FULFILLED; this.value = value; this.callbacks.map(callback => { // // 调用处理异步executor里resolve的方法。 callback.onfulfilled(value); }) } } reject(reason) { if (this.status == AsyncPromise.PENDING) { // 限制 this.status = AsyncPromise.REJECTED; this.value = reason; this.callbacks.map(callback => { // 调用处理异步executor里reject的方法。 callback.onrejected(reason); }) } } then(onfulfilled, onrejected) { if (typeof onfulfilled != \"function\") { // 如果传入的不是一个函数，默认创建空函数 onfulfilled = () => this.value; // 支持穿透 } if (typeof onrejected != \"function\") { // 如果传入的不是一个函数，默认创建空函数 onrejected = () => this.value; // 支持穿透 } return new AsyncPromise((resolve, reject) => { // 返回一个新的Promise if (this.status == AsyncPromise.FULFILLED) { // 状态改变时执行 setTimeout(() => { // 晚于线程同步任务执行 try { let result = onfulfilled(this.value); if (result instanceof AsyncPromise) { // 判断是否返回Promise对象 result.then(resolve, reject); } else { resolve(result); // 改变状态并将值交由下一个then接收 } } catch (e) { reject(e); // 传递给下一个then } }) } if (this.status == AsyncPromise.REJECTED) { // 状态改变时执行 setTimeout(() => { // 晚于线程同步任务执行 try { let result = onrejected(this.value); if (result instanceof AsyncPromise) { // 判断是否返回Promise对象 result.then(resolve, reject); } else { resolve(result); // 改变状态并将值交由下一个then接收 } } catch (e) { reject(e); // 传递给下一个then } }) } if (this.status == AsyncPromise.PENDING) { // 如果当前Promise是等待处理状态，则将处理成功的函数与处理失败的函数压入异步数组。 this.callbacks.push({ onfulfilled: value => { try { let result = onfulfilled(value); if (result instanceof AsyncPromise) { // 判断是否返回Promise对象 result.then(resolve, reject); } else { resolve(result); // 改变状态并将值交由下一个then接收 } } catch (e) { reject(e); // 传递给下一个then } }, onrejected: value => { try { let result = onrejected(value); if (result instanceof AsyncPromise) { // 判断是否返回Promise对象 result.then(resolve, reject); } else { resolve(result); // 改变状态并将值交由下一个then接收 } } catch (e) { reject(e); // 传递给下一个then } } }); } }); } } then的代码优化 可以观察到上面的then()方法中有很多重复代码，所以我们需要对重复代码做一下优化。 class AsyncPromise { static PENDING = \"pending\"; static FULFILLED = \"fulfilled\"; static REJECTED = \"rejected\"; constructor(executor) { this.status = AsyncPromise.PENDING; // 初始状态为准备状态 this.value = null; // 初始值 this.callbacks = []; // 如果是一个异步操作，则放入该数组中 try { executor(this.resolve.bind(this), this.reject.bind(this)); // 传递形参，运行executor函数 } catch (e) { this.status = AsyncPromise.REJECTED; // 异常发生改变状态 this.reject(e); // 记录异常信息 } } resolve(value) { if (this.status == AsyncPromise.PENDING) { // 限制 this.status = AsyncPromise.FULFILLED; this.value = value; this.callbacks.map(callback => { // // 调用处理异步executor里resolve的方法。 callback.onfulfilled(value); }) } } reject(reason) { if (this.status == AsyncPromise.PENDING) { // 限制 this.status = AsyncPromise.REJECTED; this.value = reason; this.callbacks.map(callback => { // 调用处理异步executor里reject的方法。 callback.onrejected(reason); }) } } then(onfulfilled, onrejected) { if (typeof onfulfilled != \"function\") { // 如果传入的不是一个函数，默认创建空函数 onfulfilled = () => this.value; // 支持穿透 } if (typeof onrejected != \"function\") { // 如果传入的不是一个函数，默认创建空函数 onrejected = () => this.value; // 支持穿透 } return new AsyncPromise((resolve, reject) => { // 返回一个新的Promise if (this.status == AsyncPromise.FULFILLED) { // 状态改变时执行 setTimeout(() => { // 晚于线程同步任务执行 this.parse(onfulfilled(this.value), resolve, reject); }) } if (this.status == AsyncPromise.REJECTED) { // 状态改变时执行 setTimeout(() => { // 晚于线程同步任务执行 this.parse(onrejected(this.value), resolve, reject); }) } if (this.status == AsyncPromise.PENDING) { // 如果当前Promise是等待处理状态，则将处理成功的函数与处理失败的函数压入异步数组。 this.callbacks.push({ onfulfilled: value => { this.parse(onfulfilled(value), resolve, reject); }, onrejected: value => { this.parse(onrejected(value), resolve, reject); } }); } }); } parse(result, resolve, reject) { try { if (result instanceof AsyncPromise) { // 判断是否返回Promise对象 result.then(resolve, reject); } else { resolve(result); // 改变状态并将值交由下一个then接收 } } catch (e) { reject(e); // 向下传递异常 } } } then返回类型限制 我们都知道then()会创建一个Promise并返回，但是原生的Promise不支持then()将自己创建的Promise进行返回 \"use strict\"; let task = new Promise((resolve, reject) => { resolve(\"成功\"); }) let then01 = task.then( // 由于then中的处理成功与处理失败的函数是属于异步执行。所以会先将创建好的Promise对象返回再运行其中的处理成功函数与处理失败函数。 success => { return p2; } ) // Uncaught (in promise) TypeError: Chaining cycle detected for promise # 但是我们的Promise还不支持这一点，所以需要改一改代码。 解决的思路也很简单，在运行失败或处理函数时判断一下本次返回的值是否等同于创建的Promise对象。 class AsyncPromise { static PENDING = \"pending\"; static FULFILLED = \"fulfilled\"; static REJECTED = \"rejected\"; constructor(executor) { this.status = AsyncPromise.PENDING; // 初始状态为准备状态 this.value = null; // 初始值 this.callbacks = []; // 如果是一个异步操作，则放入该数组中 try { executor(this.resolve.bind(this), this.reject.bind(this)); // 传递形参，运行executor函数 } catch (e) { this.status = AsyncPromise.REJECTED; // 异常发生改变状态 this.reject(e); // 记录异常信息 } } resolve(value) { if (this.status == AsyncPromise.PENDING) { // 限制 this.status = AsyncPromise.FULFILLED; this.value = value; this.callbacks.map(callback => { // // 调用处理异步executor里resolve的方法。 callback.onfulfilled(value); }) } } reject(reason) { if (this.status == AsyncPromise.PENDING) { // 限制 this.status = AsyncPromise.REJECTED; this.value = reason; this.callbacks.map(callback => { // 调用处理异步executor里reject的方法。 callback.onrejected(reason); }) } } then(onfulfilled, onrejected) { if (typeof onfulfilled != \"function\") { // 如果传入的不是一个函数，默认创建空函数 onfulfilled = () => this.value; // 支持穿透 } if (typeof onrejected != \"function\") { // 如果传入的不是一个函数，默认创建空函数 onrejected = () => this.value; // 支持穿透 } let promise = new AsyncPromise((resolve, reject) => { // 返回一个新的Promise if (this.status == AsyncPromise.FULFILLED) { // 状态改变时执行 setTimeout(() => { // 晚于线程同步任务执行 this.parse(promise, onfulfilled(this.value), resolve, reject); }) } if (this.status == AsyncPromise.REJECTED) { // 状态改变时执行 setTimeout(() => { // 晚于线程同步任务执行 this.parse(promise, onrejected(this.value), resolve, reject); }) } if (this.status == AsyncPromise.PENDING) { // 如果当前Promise是等待处理状态，则将处理成功的函数与处理失败的函数压入异步数组。 this.callbacks.push({ onfulfilled: value => { this.parse(promise, onfulfilled(value), resolve, reject); }, onrejected: value => { this.parse(promise, onrejected(value), resolve, reject); } }); } }); return promise; // 同步，先返回。onfulfilled与onrejected由于套了setTimeout，是异步执行。 } parse(promise, result, resolve, reject) { if (promise == result) { throw new TypeError(\"Chaining cycle detected\"); } try { if (result instanceof AsyncPromise) { // 判断是否返回Promise对象 result.then(resolve, reject); } else { resolve(result); // 改变状态并将值交由下一个then接收 } } catch (e) { reject(e); // 向下传递异常 } } } resolve与reject实现 使用 Promise.resolve() 方法可以快速的返回一个状态是fulfilled的Promise对象。 使用 Promise.reject() 方法可以快速的返回一个状态是rejected的Promise对象。 class AsyncPromise { static PENDING = \"pending\"; static FULFILLED = \"fulfilled\"; static REJECTED = \"rejected\"; constructor(executor) { this.status = AsyncPromise.PENDING; // 初始状态为准备状态 this.value = null; // 初始值 this.callbacks = []; // 如果是一个异步操作，则放入该数组中 try { executor(this.resolve.bind(this), this.reject.bind(this)); // 传递形参，运行executor函数 } catch (e) { this.status = AsyncPromise.REJECTED; // 异常发生改变状态 this.reject(e); // 记录异常信息 } } resolve(value) { if (this.status == AsyncPromise.PENDING) { // 限制 this.status = AsyncPromise.FULFILLED; this.value = value; this.callbacks.map(callback => { // // 调用处理异步executor里resolve的方法。 callback.onfulfilled(value); }) } } reject(reason) { if (this.status == AsyncPromise.PENDING) { // 限制 this.status = AsyncPromise.REJECTED; this.value = reason; this.callbacks.map(callback => { // 调用处理异步executor里reject的方法。 callback.onrejected(reason); }) } } then(onfulfilled, onrejected) { if (typeof onfulfilled != \"function\") { // 如果传入的不是一个函数，默认创建空函数 onfulfilled = () => this.value; // 支持穿透 } if (typeof onrejected != \"function\") { // 如果传入的不是一个函数，默认创建空函数 onrejected = () => this.value; // 支持穿透 } let promise = new AsyncPromise((resolve, reject) => { // 返回一个新的Promise if (this.status == AsyncPromise.FULFILLED) { // 状态改变时执行 setTimeout(() => { // 晚于线程同步任务执行 this.parse(promise, onfulfilled(this.value), resolve, reject); }) } if (this.status == AsyncPromise.REJECTED) { // 状态改变时执行 setTimeout(() => { // 晚于线程同步任务执行 this.parse(promise, onrejected(this.value), resolve, reject); }) } if (this.status == AsyncPromise.PENDING) { // 如果当前Promise是等待处理状态，则将处理成功的函数与处理失败的函数压入异步数组。 this.callbacks.push({ onfulfilled: value => { this.parse(promise, onfulfilled(value), resolve, reject); }, onrejected: value => { this.parse(promise, onrejected(value), resolve, reject); } }); } }); return promise; // 同步，先返回。onfulfilled与onrejected由于套了setTimeout，是异步执行。 } parse(promise, result, resolve, reject) { if (promise == result) { throw new TypeError(\"Chaining cycle detected\"); } try { if (result instanceof AsyncPromise) { // 判断是否返回Promise对象 result.then(resolve, reject); } else { resolve(result); // 改变状态并将值交由下一个then接收 } } catch (e) { reject(e); // 向下传递异常 } } static resolve(value) { return new AsyncPromise((resolve, reject) => { if (value instanceof AsyncPromise) { value.then(resolve, reject); } else { resolve(value); } }); } static reject(value) { return new AsyncPromise((resolve, reject) => { reject(value); }); } } all与race实现 使用Promise.all() 方法可以同时执行多个并行异步操作，比如页面加载时同进获取课程列表与推荐课程。任何一个 Promise 执行失败就会调用 catch方法，成功后返回 Promise 结果的有序数组。（Ps：我们这个Promise没有实现catch方法） 使用Promise.race() 处理容错异步，和race单词一样哪个Promise快用哪个，哪个先返回用哪个。 class AsyncPromise { static PENDING = \"pending\"; static FULFILLED = \"fulfilled\"; static REJECTED = \"rejected\"; constructor(executor) { this.status = AsyncPromise.PENDING; // 初始状态为准备状态 this.value = null; // 初始值 this.callbacks = []; // 如果是一个异步操作，则放入该数组中 try { executor(this.resolve.bind(this), this.reject.bind(this)); // 传递形参，运行executor函数 } catch (e) { this.status = AsyncPromise.REJECTED; // 异常发生改变状态 this.reject(e); // 记录异常信息 } } resolve(value) { if (this.status == AsyncPromise.PENDING) { // 限制 this.status = AsyncPromise.FULFILLED; this.value = value; this.callbacks.map(callback => { // // 调用处理异步executor里resolve的方法。 callback.onfulfilled(value); }) } } reject(reason) { if (this.status == AsyncPromise.PENDING) { // 限制 this.status = AsyncPromise.REJECTED; this.value = reason; this.callbacks.map(callback => { // 调用处理异步executor里reject的方法。 callback.onrejected(reason); }) } } then(onfulfilled, onrejected) { if (typeof onfulfilled != \"function\") { // 如果传入的不是一个函数，默认创建空函数 onfulfilled = () => this.value; // 支持穿透 } if (typeof onrejected != \"function\") { // 如果传入的不是一个函数，默认创建空函数 onrejected = () => this.value; // 支持穿透 } let promise = new AsyncPromise((resolve, reject) => { // 返回一个新的Promise if (this.status == AsyncPromise.FULFILLED) { // 状态改变时执行 setTimeout(() => { // 晚于线程同步任务执行 this.parse(promise, onfulfilled(this.value), resolve, reject); }) } if (this.status == AsyncPromise.REJECTED) { // 状态改变时执行 setTimeout(() => { // 晚于线程同步任务执行 this.parse(promise, onrejected(this.value), resolve, reject); }) } if (this.status == AsyncPromise.PENDING) { // 如果当前Promise是等待处理状态，则将处理成功的函数与处理失败的函数压入异步数组。 this.callbacks.push({ onfulfilled: value => { this.parse(promise, onfulfilled(value), resolve, reject); }, onrejected: value => { this.parse(promise, onrejected(value), resolve, reject); } }); } }); return promise; // 同步，先返回。onfulfilled与onrejected由于套了setTimeout，是异步执行。 } parse(promise, result, resolve, reject) { if (promise == result) { throw new TypeError(\"Chaining cycle detected\"); } try { if (result instanceof AsyncPromise) { // 判断是否返回Promise对象 result.then(resolve, reject); } else { resolve(result); // 改变状态并将值交由下一个then接收 } } catch (e) { reject(e); // 向下传递异常 } } static resolve(value) { return new AsyncPromise((resolve, reject) => { if (value instanceof AsyncPromise) { value.then(resolve, reject); } else { resolve(value); } }); } static reject(value) { return new AsyncPromise((resolve, reject) => { reject(value); }); } static all(value) { return new AsyncPromise((resolve, reject) => { const values = []; // 记录当前有多少promise状态是成功 promise.forEach((promise) => { promise.then(value => { values.push(value); if (values.length == promise.length) { resolve(values); // 如果都成功，当前all返回的promise则状态为fulfilled。 } }, reason => { reject(reason); // 如果有一个promise错误，则当前all返回的promise则为拒绝 }) }); }); } static race(value) { return new AsyncPromise((resolve, reject) => { value.forEach(promise => { promise.then(value => { // 如果循环中的promise状态为fulfilled，则当前的race创建的promise状态也为resolve resolve(value); }, reason => { reject(value); // 同上 }) }) }) } } Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-08-13 16:03:24 "},"前端专栏/JavaScript/异常处理.html":{"url":"前端专栏/JavaScript/异常处理.html","title":"异常处理","keywords":"","body":"异常处理 程序异常可分为逻辑异常和语法异常，对于初学者而言语法异常居多，随着不断的学习对语言越来越熟悉后语法异常减少逻辑异常增多。 在JavaScript中提供了对异常进行处理的语句，在适当的时候使用它们能够使程序变得更加健壮。 但是要注意不要滥用异常处理，它会使程序的可读性变差。 异常类型 所有的异常都是对象，在JavaScript中，常见异常类型有以下几种： 异常类型 简述 Error 基本异常，该异常作为所有异常的基类产生 EvalError eval错误，一般是由于不当的使用eval()函数产生 RangeError 范围错误，常见于Array中产生，如索引无效 ReferenceError 引用错误，常见于定义变量时产生，如变量名不存在 SyntaxError 语法错误 TypeError 类型错误 URIError 在使用encodeURI()或者decodeURI()因为URL格式不正确时，就会导致URIError错误。 异常捕获 try catch 使用try与catch语句进行捕获异常： try用于检测可能出现异常的代码块 catch用于处理捕捉到的异常，可指定参数获取异常信息 try/catch语句有一个包含一条或者多条语句的，0个或1个的catch代码块，catch代码块中的语句会在try代码块中抛出异常时执行。 如果try代码块中的语句（或者try代码块中调用的方法）一旦抛出了异常，那么执行流程会立即进入catch代码块。 如果try代码块没有抛出异常，catch代码块就会被跳过： \"use strict\"; try { console.log(username); } catch (e) { console.log(\"处理了一个异常:\", e); } // 处理了一个异常,ID: ReferenceError: username is not defined finally finally块包含了在try和catch块完成后、下面接着try/catch的语句之前执行的语句。 finally块无论是否抛出异常都会执行，如果抛出了一个异常，就算没有异常处理，finally块里的语句也会执行： \"use strict\"; try { console.log(username); } catch (e) { console.log(\"处理了一个异常,ID:\", e); } finally { console.log(\"无论有没有异常都会执行我\"); } // 处理了一个异常,ID: ReferenceError: username is not defined // 无论有没有异常都会执行我 主动异常 throw new Error 在某些时候我们需要主动抛出异常，使用throw语句抛出异常： \"use strict\"; throw new Error(\"这是一个错误\") // demo.js:3 Uncaught Error: 这是一个错误 表达式形式 你可以抛出任意表达式而不是特定一种类型的表达式。 下面的代码中抛出了几个不同类型的表达式： \"use strict\"; throw \"Error2\"; // String type throw 42; // Number type throw true; // Boolean type throw { toString: function () { return \"I'm an object!\"; } }; 自定义异常 原型继承 继承Error原型对象，可配置自定义的异常。 Error构造函数具有message可选参数，用于显示人类可阅读的错误描述信息。 如下所示： \"use strict\"; function MyError(message) { this.name = 'MyError'; this.message = message || 'Default Message'; this.stack = (new Error()).stack; } Object.setPrototypeOf(MyError, Error); // 继承Error原型对象 try { throw new MyError(); } catch (e) { console.log(e.name); // MyError console.log(e.message); // Default Message } try { throw new MyError(\"自定义异常被抛出\"); } catch (e) { console.log(e.name); // MyError console.log(e.message); // 自定义异常被抛出 } // MyError // Default Message // MyError // 自定义异常被抛出 类继承 使用class语法进行自定义异常： \"use strict\"; class MyError extends Error { constructor(message) { super(); this.name = \"MyError\"; this.message = message || 'Default Message'; this.stack = (new Error()).stack; } } try { throw new MyError(); } catch (e) { console.log(e.name); console.log(e.message); } try { throw new MyError(\"自定义异常被抛出\"); } catch (e) { console.log(e.name); console.log(e.message); } // MyError // Default Message // MyError // 自定义异常被抛出 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-07-31 19:06:26 "},"前端专栏/JavaScript/模块封装.html":{"url":"前端专栏/JavaScript/模块封装.html","title":"模块封装","keywords":"","body":"基础知识 历史背景 在早期时，JavaScript并没有模块这一个概念，通常是一个文档对应一个JS文件即可。 但是随着时间的推移和技术的发展，我们面临的需求也越来越大，此时将一些复用性较强的代码封装成模块变成了必要的趋势。 本章节中主要介绍原生的JavaScript封装的几种常用手段以及ES6新增的Module封装法。 window对象 假设你在一个文档中导入了多个JavaScript脚本文件，如果这些JavaScript脚本文件中不采用任何封装手段那么将会直接导致window环境污染的问题。 我们知道，所有函数名、var声明的变量名都会存放到window对象中，即使是多个JavaScript脚本文件中的函数名、变量名也不例外，只要在一个文档中引入它们，它们都会存放在这个文档的window对象中。 如下所示，我们将展示可能出现的环境污染问题： 1）demo1.js代码： \"use strict\"; var moduleName = \"demo1\"; function show() { console.log(\"hello demo1\"); } 2）demo2.js代码： \"use strict\"; var moduleName = \"demo2\"; function show() { console.log(\"hello demo2\"); } 3）HTML代码，注意，demo2引入在demo1之后，所以window对象中demo1的moduleName和show都被demo2的同名变量及函数覆盖掉了： \"use strict\"; console.log(moduleName); // demo2 show(); // hello demo2 整个过程如图所示： IIFE封装 针对上述问题，我们可以采取函数的作用域特性以及对象声明进行解决。 解决的办法就是利用自执行函数（IIFE），这在ES6之前是通用的解决策略，它总共分为2个步骤： 第一步：将所有代码包裹在一个自执行函数之中，这样var变量和函数就不会提升到window作用域下，且外部禁止访问自执行函数内部代码 第二步：向外部暴露接口，为window对象添加一组新的键值对 如下所示，使用IIFE进行对模块代码进行封装： 1）demo1.js代码： \"use strict\"; (function () { var moduleName = \"demo1\"; function show() { console.log(\"hello demo1\"); } window.demo1 = { \"moduleName\": moduleName, \"show\": show, }; })(); 2）demo2.js代码： \"use strict\"; (function () { var moduleName = \"demo2\"; function show() { console.log(\"hello demo2\"); } window.demo2 = { \"moduleName\": moduleName, \"show\": show, }; })(); 3）HTML代码： \"use strict\"; console.log(demo1.moduleName); // demo1 console.log(demo2.moduleName); // demo2 demo1.show(); // hello demo1 demo2.show(); // hello demo2 整个过程如图所示： ES6块级封装 ES6之前，模块封装的主流方式是IIFE，它利用了函数作用域 + 对象声明的方式解决了window环境污染问题。 但是在ES6之后，由于块级作用域的出现，故我们可以使用块级作用域来代替函数作用域，它更加简单也更加直白，但是其实它的本质也是和IIFE封装法相同，都是利用作用域 + 对象声明的特性来进行解决的。 如下所示，使用块级作用域进行对模块代码进行封装： 1）demo1.js代码，注意！仅有const和let具有块级作用域： \"use strict\"; { let moduleName = \"demo1\"; let show = function () { console.log(\"hello demo1\"); } window.demo1 = { // ES6新语法 moduleName, show, }; } 2）demo2.js代码，注意！仅有const和let具有块级作用域： \"use strict\"; (function () { var moduleName = \"demo2\"; function show() { console.log(\"hello demo2\"); } window.demo2 = { \"moduleName\": moduleName, \"show\": show, }; })(); 3）HTML代码： \"use strict\"; console.log(demo1.moduleName); // demo1 console.log(demo2.moduleName); // demo2 demo1.show(); // hello demo1 demo2.show(); // hello demo2 整个过程如图所示，它其实和IIFE封装法原理相同： ES6 module 上面的两种方式虽然都能达到模块封装的效果，但是我们依然有更好的选择。 下面将介绍极力推荐的ES6 module语法进行导入。 学习ES6 module从以下3个方面进行入手： 作为使用者，学会使用模块标签，并了解它的特性 作为使用者，如何导入模块中的某个功能 作用开发者，如何导出模块中的某个功能 模块标签 声明标签 模块标签，顾名思义我们需要使用该标签来导入模块，在JavaScript中所有以js后缀名结尾的文件都是一个模块。 声明标签只需要在标签中添加标准属性type=“module”即可： 注意！只有模块标签中才可以使用import系列语法，而普通标签中是不能使用的。 导入路径 导入路径必须使用相对路径导入，即使模块位于当前目录中也不可省略./前缀。 1）正确的导入路径： 2）错误的导入路径： 其实无论什么语言，在导入某个文件时都应该使用相对路径，而不是绝对路径，这是一个良好的行为习惯。 延迟解析 延迟解析是指在模块标签中的代码会在标准的标签以及添加了defer的之后执行。 如下所示，模块标签即使声明在最上方，但是它的代码也会最后执行： \"use strict\"; console.log(\"module\"); \"use strict\"; console.log(\"standard\"); \"use strict\"; console.log(\"defer\"); 执行结果： standard defer module 严格模式 模块标签中的所有代码都是按严格模式运行的，即使你没有声明use strict。 所以请注意变量声明以及this指向还有解构赋值等问题。 1）必须使用关键字声明变量： userName = \"Jack\"; // userName is not defined 2）留意this指向： (()=>{ console.log(this); })(); // undefined 3）解构赋值前也需要声明变量： let ary = [\"Jack\", \"18\", \"male\"]; let [name, age, gender] = ary; console.log(name); console.log(age); console.log(gender); // Jack // 18 // male 作用域 每个模块标签中的代码系统都会为其创建一个专属的作用域，禁止相互之间访问： \"use strict\"; let name = \"Jack\"; \"use strict\"; console.log(name); // Uncaught ReferenceError: name is not defined 而普通标签中的代码执行都会在全局作用域下，相互之间可以访问： \"use strict\"; let name = \"Jack\"; \"use strict\"; console.log(name); // Jack 预加载 模块在导入时就会将模块中的代码全部运行一次，后续再次导入时将不会重复运行，而是使用第一次的解析结果。 demo.js代码如下： \"use strict\"; console.log(\"hello demo\"); 模块标签，多次导入只运行一次： 普通标签，导入几次执行几次： 导出模块 基本介绍 我们可以使用export来将模块中的某个功能进行导出，导出方式分为以下几种： 单个导出 批量导出 默认导出 混合导出 别名导出 单个导出 在需要导出的功能前加上export关键字即可，如下所示，一次export只能导出一个功能： \"use strict\"; export let moduleName = \"demo\"; export function show() { console.log(\"hello demo\"); } export class Person { constructor(name, age) { this.name = name; this.age = age; } get info() { return `your name : ${this.name}`; } } 批量导出 我们可以使用export搭配{}来批量添加需要导出的功能。 这种方法应该是最常用的： \"use strict\"; let moduleName = \"demo\"; function show() { console.log(\"hello demo\"); } class Person { constructor(name, age) { this.name = name; this.age = age; } get info() { return `your name : ${this.name}`; } } export { moduleName, show, Person }; 注意！这个{}并不是一个对象，不能使用key:value的形式进行定义！ 默认导出 一个模块中，只能有一个默认导出。 也就是说，当你的模块只有一个对外部开放的接口的时，你可以使用默认导出。 如果默认导出的是一个类，那么该类就可以不用起名字，函数同理： \"use strict\"; export default class { constructor(name, age) { this.name = name; this.age = age; } get info() { return `your name : ${this.name}`; } } 混合导出 我们可以使用单个+默认导出和批量导出达到混合导出的功能，如下所示： \"use strict\"; let moduleName = \"demo\"; function show() { console.log(\"hello demo\"); } export default class { constructor(name, age) { this.name = name; this.age = age; } get info() { return `your name : ${this.name}`; } } export { moduleName, show }; 别名导出 使用as为导出的接口添加一个别名，如果别名为default则将该功能当做默认导出。 \"use strict\"; let moduleName = \"demo\"; function show() { console.log(\"hello demo\"); } class Person { constructor(name, age) { this.name = name; this.age = age; } get info() { return `your name : ${this.name}`; } } export { moduleName, show, Person as default }; 导入模块 基本介绍 使用import与from静态的导入一个模块，注意导入时应当将导入语句放在最顶层（如果有严格声明，则将导入语句放在严格声明语句之下）。 同时，导入模块的import/from语句只能在模块标签中使用，普通的标签中无法进行使用。 模块的导入分为以下几部分： 单个导入 批量导入 默认导入 混合导入 别名导入 动态导入 单个导入 单个导入的时候，使用import {} form “filePath.js”来导入模块中具体的功能。 一次可以导入一个，也可以导入多个。 注意，导入的接口名称应当和导出的接口名称一致，如下所示。 1）模块导出的代码： \"use strict\"; let moduleName = \"demo\"; function show() { console.log(\"hello demo\"); } class Person { constructor(name, age) { this.name = name; this.age = age; } get info() { return `your name : ${this.name}`; } } export { moduleName, show, Person }; 2）模块导入的代码： \"use strict\"; import { moduleName, show, Person } from \"./demo.js\"; console.log(moduleName); // demo show(); // hello demo let ins = new Person(\"Jack\", 18); console.log(ins.info); // your name : Jack 批量导入 使用import * as 别名 from “path”来导入一个模块中所有被导出的功能。 注意，在使用某个功能前，需要加上别名的前缀，然后点出功能，如下所示。 1）模块导出的代码： \"use strict\"; let moduleName = \"demo\"; function show() { console.log(\"hello demo\"); } class Person { constructor(name, age) { this.name = name; this.age = age; } get info() { return `your name : ${this.name}`; } } export { moduleName, show, Person }; 2）模块导入的代码： \"use strict\"; import * as demo from \"./demo.js\"; console.log(demo.moduleName); demo.show(); let ins = new demo.Person(\"Jack\", 18); console.log(ins.info); 默认导入 使用默认导入时不需要用{}来进行接收，可以使用任意一个名字来接收默认导出的接口。 如下所示。 1）模块导出的代码： \"use strict\"; export default class { constructor(name, age) { this.name = name; this.age = age; } get info() { return `your name : ${this.name}`; } } 2）模块导入的代码： \"use strict\"; import demoPerson from \"./demo.js\"; let ins = new demoPerson(\"Jack\", 18); console.log(ins.info); 混合导入 当一个模块中导出的又有默认导出的接口，又有其他的导出接口时，我们可以使用混合导入。 先为默认导出的接口取一个名字，然后在使用{}来接收其他的导出接口，注意{}中导入的接口名称应当和模块中非默认导出的接口名称一致，如下所示。 1）模块导出的代码： \"use strict\"; let moduleName = \"demo\"; function show() { console.log(\"hello demo\"); } class Person { constructor(name, age) { this.name = name; this.age = age; } get info() { return `your name : ${this.name}`; } } export { moduleName, show, Person as default }; 2）模块导入的代码： \"use strict\"; import demoPerson, { moduleName, show } from \"./demo.js\"; console.log(moduleName); show(); let ins = new demoPerson(\"Jack\", 18); console.log(ins.info); 别名导入 为了防止多个模块下接口名相同，我们可以使用as进行别名导入，在使用时也将按照别名的方式进行使用，如下所示。 1）模块导出的代码： \"use strict\"; let moduleName = \"demo\"; function show() { console.log(\"hello demo\"); } class Person { constructor(name, age) { this.name = name; this.age = age; } get info() { return `your name : ${this.name}`; } } export { moduleName, show, Person as default }; 2）模块导入的代码： \"use strict\"; import demoPerson, { moduleName as demoModuleName, show as demoShow } from \"./demo.js\"; console.log(demoModuleName); demoShow(); let ins = new demoPerson(\"Jack\", 18); console.log(ins.info); 动态导入 使用import/form的方式属于静态导入，必须将导入语句防止在最顶层，否则则抛出异常。 但在有些时候，我们想在某段特定代码执行后再导入某个模块的功能时，静态导入就不能完成需求了，此时你需要利用import()函数来实现动态导入按需加载，它将返回一个Promise对象，我们可以使用解构语法将模块中的接口一个一个全拿出来。 如下所示。 1）模块内容，demo.js代码： \"use strict\"; let n = Math.floor(Math.random() * (90 - 65 + 1)) + 65; function getStr() { return String.fromCharCode(n); } function getNumber() { return n; } export { getStr, getNumber }; 2）使用模块，在条件为真的情况下导入并使用模块的getStr()功能，在条件为假的情况下导入并使用模块的getNumber()功能： \"use strict\"; let condition = Math.floor((Math.random() * 100) + 1) % 2 === 0; if(condition){ import(\"./demo.js\").then( // 解构语法 ({ getStr }) => { console.log(getStr()); } ) } else{ import(\"./demo.js\").then( // 解构语法 ({ getNumber }) => { console.log(getNumber()); } ) } 合并封装 如果有多个小模块都需要被使用，我们可以将其合成一个大模块。 在使用时只需要导入大模块即可，如： login.js：包含登录相关的接口 register.js：包含注册相关的接口 user.js：包含登录和注册相关的所有接口 下面是整体结构： ├── index.html └── user ├── login.js ├── register.js └── user.js 接下来开始合并封装。 1）子模块，login.js： \"use strict\"; function verifyCodeLogin() { return \"Verification code login...\"; } function passwordLogin() { return \"Password login ...\"; } export { verifyCodeLogin, passwordLogin }; 2）子模块，register.js： \"use strict\"; function phoneRegister() { return \"phone register ...\" } function wechatRegister() { return \"wechat register ...\" } export { phoneRegister, wechatRegister } 3）总模块，user.js： import * as login from \"./login.js\"; import * as register from \"./register.js\"; export { login, register } 4）使用，index.html： \"use strict\"; import { login, register } from \"./user/user.js\"; // 登录 console.log( login.verifyCodeLogin() ); console.log( login.passwordLogin() ); // 注册 console.log( register.phoneRegister() ); console.log( register.wechatRegister() ); Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-08-13 23:20:28 "},"前端专栏/JavaScript/综合练习.html":{"url":"前端专栏/JavaScript/综合练习.html","title":"综合练习","keywords":"","body":"正反向 使用JavaScript完成正反向的效果： 实现如下： Document body { justify-content: center; align-items: center; display: flex; width: 100vw; height: 100vh; } main { justify-content: center; align-items: center; display: flex; flex-flow: column; border: 1px solid #ddd; padding: 10px; } 全选 取消 反选 爱好 篮球 足球 排球 \"use strict\"; window.onload = (event) => { bind(); } function bind() { document.querySelectorAll(\"button\").forEach((element) => { element.addEventListener(\"click\", select) }); } function select() { let choice = event.target.dataset.select; let inputList = document.getElementsByName(\"hobby\"); inputList.forEach((element) => { if (choice == \"all\") { // 全选 element.checked = true; } else if (choice == \"cancel\") { // 取消 element.checked = false; } else { // 反选 element.checked = !element.checked; } }); } 二级联动 使用JavaScript完成二级联动： 实现如下： Document 请选择省份 请选择城市 window.onload = (event) => { init(); } function init() { let data = { 浙江省: [\"杭州\", \"宁波\", \"嘉兴\"], 四川省: [\"成都\", \"绵阳\", \"德阳\"], 江苏省: [\"南京\", \"苏州\", \"无锡\"] }; // 模拟后台数据 let province = document.querySelector(\"[name='province']\"); let city = document.querySelector(\"[name='city']\"); for (let name of Object.keys(data)) { let option = document.createElement(\"option\"); option.value = name; option.innerText = name; province.append(option); } province.addEventListener(\"change\", function () { // 不用箭头函数，箭头函数指向window或undefined city.length = 1; // 每次更新内容,只留下 请选择城市 let provinceName = this.options[this.selectedIndex].value; // options所有的option标签，selectedIndex当前选中的option索引 let cityData = data[provinceName]; cityData.forEach((cityName) => { let option = document.createElement(\"option\"); option.value = cityName; option.innerText = cityName; city.append(option); }); }) } 如果联动过多，则可以使用async+await来优化层次结构，避免死亡嵌套。 元素拖动 有的时候，一些弹出的登录框是允许我们拖动的。 所以在这里我们也可以利用空间坐标等信息来实现一次元素拖动。 实现如下： main { width: 100px; height: 100px; background-color: red; position: absolute; z-index: 10; } main:hover { cursor: pointer; } \"use strict\"; let mainNode = document.querySelector(\"main\"); class MoveElement { constructor(node) { this.element = node; this.x = null; this.y = null; } handleEvent(event) { this[event.type](event); } mousedown(event) { // 要移动的距离 = 鼠标位置 - 元素位于文档的位置 this.x = event.clientX - this.element.offsetLeft; this.y = event.clientY - this.element.offsetTop; // 注意，这里移动一定要绑定在document上，如果绑定在要拖动元素上则会造成拖动卡顿的现象 document.addEventListener(\"mousemove\", this) } mouseup(event) { document.removeEventListener(\"mousemove\", this); } mousemove(event) { // 不断的计算新位置 let X = event.clientX - this.x; let Y = event.clientY - this.y; // 边界限制 X 水平轴 switch (true) { case X document.documentElement.clientWidth - this.element.offsetWidth: X = document.documentElement.clientWidth - this.element.offsetWidth; break } // 边界限制 Y 垂直轴 switch (true) { case Y document.documentElement.clientHeight - this.element.offsetHeight: Y = document.documentElement.clientHeight - this.element.offsetHeight; break } this.element.style.cssText = `left: ${X}px; top: ${Y}px`; } } // 传入要移动的元素 let move = new MoveElement(mainNode); mainNode.addEventListener(\"mousedown\", move); mainNode.addEventListener(\"mouseup\", move); 模态对话框 在有的场景中，当点击登录或者注册的按钮后整个页面会弹出登录和注册的一个窗口。其他部分均变为灰色，我们可以利用calss的增删改查来实现这一需求和功能。 模态对话框一般分为三层 第一层显示层，显示其他主要的信息，如页面主题等 第二层遮罩层，当点击某一特定按钮后触发 第三层功能层，登录或注册功能的功能均在此层 实现如下： Document * { margin: 0; padding: 0; } body { width: 100vw; height: 100vh; position: relative; } main { width: 100%; height: 100%; background: deeppink; } main button { position: absolute; right: 2%; top: 2%; } aside { width: 100%; height: 100%; background: darkslategray; opacity: .3; position: absolute; top: 0; z-index: 2; } article { padding: 10px; background-color: deepskyblue; position: fixed; left: 50%; top: 50%; transform: translate(-50%, -50%); z-index: 10; } article form * { margin: 5px; } .hidden { display: none; } 登录 欢迎登录 提交 取消 window.onload = (event) => { init(); } function init() { let showBTN = document.querySelector(\"main button\"); // 登录按钮 let hiddenBTN = document.querySelector(\"article.hidden form button[type='button']\"); // 取消按钮 let cover = document.querySelector(\"aside.hidden\"); let login = document.querySelector(\"article.hidden\"); showBTN.addEventListener(\"click\", () => { cover.classList.toggle(\"hidden\"); // 若有hidden则取消，没有则添加 login.classList.toggle(\"hidden\"); }); hiddenBTN.addEventListener(\"click\", () => { cover.classList.toggle(\"hidden\"); login.classList.toggle(\"hidden\"); }); } 左侧菜单栏 左侧三个菜单栏，点击任何一个隐藏另外两个。 用WeakMap来做一个容器，让其与对应的菜单标签建立联系 当点击一个标题时循环容器，将非事件目标的对应标签设置为隐藏，将事件目标的对应标签设置为显示 实现如下： Document * { margin: 0; padding: 0; list-style: none; } body { width: 100vw; height: 100vh; display: flex; } header { width: 30%; height: 100%; display: flex; flex-flow: column; justify-content: start; align-items: center; background-color: deeppink; cursor: pointer; } header nav { width: 95%; margin: 10px 0; } header nav h1 { display: flex; justify-content: center; background-color: #fff; box-shadow: 10px 10px 5px rgba(100, 100, 100, .5); } header nav ul li { display: flex; justify-content: center; color: #fff; margin: 5px 0; } header nav ul li:hover { text-decoration: underline; } main { width: 70%; height: 100%; background-color: deepskyblue; display: flex; justify-content: center; align-items: center; color: #fff; font-size: 50px; } .hidden { display: none; } HTML学习 HTML基础 HTML进阶 HTML高级 CSS学习 CSS基础 CSS进阶 CSS高级 JavaScript学习 JavaScript基础 JavaScript进阶 JavaScript高级 \"use strict\"; let h1NodeList = document.querySelectorAll(\"h1\"); let ulList = document.querySelectorAll(\"ul\"); let mainNode = document.querySelector(\"main\"); let wMap = new Map(); h1NodeList.forEach((ele, index, array) => { // 将h1和下面的ul标签做联系 wMap.set(ele, ele.nextElementSibling); ele.addEventListener(\"click\", (event) => { for (let [h1, ul] of wMap) { if (h1 === event.target) { ul.classList.remove(\"hidden\"); } else { ul.classList.add(\"hidden\"); } } }) }) ulList.forEach((ele, index, array) => { // 事件代理 ele.addEventListener(\"click\", (event) => { if (event.target.tagName === \"LI\") { mainNode.innerText = `您选择了 : ${event.target.innerText}`; } }); }) 滚动轮播图 滚动轮播图是最常见的由JavaScript实现的效果，这里我们将其做成一个插件的形式，方便日后使用。 实现如下： Document \"use strict\"; class Carousel { constructor(imageAndPathArray, parentElement, seconds = 1500) { if (!imageAndPathArray) { throw new Error(\"param error : imageAndPathArray\"); } if (imageAndPathArray.length > 12) { throw new Error(\"number error : Too many pictures\") } this.imageAndPathArray = imageAndPathArray; this.parentElement = parentElement ? document.querySelector(parentElement) : document.body; this.width = this.parentElement.clientWidth; this.height = this.parentElement.clientHight; this.seconds = seconds; this.frame = null; this.scrollDiagramUl = null; this.scrollBarUl = null; this.prev = null; this.next = null; // 导航图与导航按钮的关系容器 this.elementArray = new Array(); // 当前显示的元素 this.showElementIndex = 0; // 计时器 this.tag = null; // 生成样式 this.initStyle(); // 生成标签 this.initElements(); // 开始滚动 this.autoScroll(); // 按钮事件绑定 this.btnBindEvent(); } initElements() { // 整体标签，采用nav进行包裹 this.frame = document.createElement(\"nav\"); this.frame.id = \"container\"; // 添加轮播图时要放在同步任务后添加，这样可以避免渲染不及时出现错了 setTimeout(() => { this.parentElement.append(this.frame); }, 300) // 添加image滚动图ul this.scrollDiagramUl = document.createElement(\"ul\"); this.scrollDiagramUl.id = \"scroll_diagram\"; this.frame.append(this.scrollDiagramUl); // 添加下方滚动条ul this.scrollBarUl = document.createElement(\"ul\"); this.scrollBarUl.id = \"scroll_bar\"; this.scrollBarUl.className = \"clearfix\"; this.frame.append(this.scrollBarUl); // 添加上一页，下一页 this.prev = document.createElement(\"aside\"); this.next = document.createElement(\"aside\"); this.prev.innerHTML = \"\"; this.next.innerHTML = \"\"; this.prev.id = \"prev_diagram\"; this.next.id = \"next_diagram\"; this.frame.append(this.prev); this.frame.append(this.next); this.imageAndPathArray.forEach((obj, index, array) => { let { imagePath, targetURL } = obj; // 生成滚动图相关 let imageLi = document.createElement(\"li\"); let imageLink = document.createElement(\"a\"); let imageNode = document.createElement(\"img\"); imageLink.href = obj.targetURL || \"#\"; imageLink.target = imageLink.href.match(\"#\") ? \"_self\" : \"_blank\"; imageNode.src = obj.imagePath; imageLink.append(imageNode); imageLi.append(imageLink); this.scrollDiagramUl.append(imageLi); // 生成滚动条li let barLi = document.createElement(\"li\"); this.scrollBarUl.append(barLi); // 绑定关系 this.elementArray.push({ imageLi, barLi }) }); } initStyle() { let linkNode = document.createElement(\"link\"); linkNode.rel = \"stylesheet\"; linkNode.href = \"//at.alicdn.com/t/font_1953712_kcy11tbqhi.css\"; document.head.append(linkNode); let styleNode = document.createElement(\"style\"); document.head.append(styleNode); styleNode.append(` nav#container, nav#container * { box-sizing: border-box; padding: 0; margin: 0; } nav#container { position: relative; } nav#container ul#scroll_diagram { list-style: none; cursor: pointer; overflow:hidden; } nav#container ul#scroll_diagram li { display:none; } nav#container ul#scroll_diagram li a { display: inline-block; } nav#container ul#scroll_diagram li a img { width: 100%; } nav#container ul#scroll_bar { list-style: none; cursor: pointer; } nav#container ul#scroll_bar { position: absolute; left: 50%; top: 90%; transform: translate(-50%, -50%); z-index: 1; } nav#container ul#scroll_bar li { float: left; margin-right: ${this.width * 0.02}px; background-color: #eee; width: ${this.width * 0.04}px; height: ${this.width * 0.01}px; border-radius: 40px; transition: ${this.seconds * 0.3}ms; } nav#container aside#prev_diagram, nav#container aside#next_diagram { display: inline-block; position: absolute; top: 50%; z-index: 1; align-items: center; } nav#container aside#prev_diagram { left: 0; transform: translate(0, -50%); } nav#container aside#next_diagram { right: 0; transform: translate(0, -50%); } nav#container aside#prev_diagram i, nav#container aside#next_diagram i { background: #eee; opacity:.3; font-size: ${this.width * 0.04}px !important; text-align: center; cursor: pointer; } nav#container aside#prev_diagram i { border-top-right-radius: .6rem; border-bottom-right-radius: .6rem; } nav#container aside#next_diagram i { border-top-left-radius: .6rem; border-bottom-left-radius: .6rem; } nav#container aside#prev_diagram i:hover, nav#container aside#next_diagram i:hover { opacity:.6; } .clearfix::after { content: \"\"; display: block; clear: both; } .current_show_image_li { display: block !important; } .current_show_bar_li { background-color: #FF0000 !important; } `) } autoScroll() { // 先展示首页 if (this.tag === null) { this.show(this.elementArray[this.showElementIndex]); } this.tag = setInterval(() => { this.hidden(this.elementArray[this.showElementIndex]); this.showElementIndex { if (event.target.tagName === 'LI') { this.hidden(this.elementArray[this.showElementIndex]); this.showElementIndex = Array.prototype.indexOf.call(this.scrollBarUl.childNodes, event.target); this.clearScroll(); } }); this.prev.addEventListener(\"click\", (event) => { this.hidden(this.elementArray[this.showElementIndex]); this.showElementIndex = this.showElementIndex !== 0 ? this.showElementIndex - 1 : this.elementArray.length - 1; this.clearScroll(); }) this.next.addEventListener(\"click\", (event) => { this.hidden(this.elementArray[this.showElementIndex]); this.showElementIndex = this.showElementIndex !== this.elementArray.length - 1 ? this.showElementIndex + 1 : 0; this.clearScroll(); }) } clearScroll() { clearInterval(this.tag); this.tag = null; this.autoScroll(); } } let imageAndPathArray = [ { id: 1, \"imagePath\": \"./1.jpeg\", targetURL: \"http://www.baidu.com\" }, { id: 2, \"imagePath\": \"./2.jpeg\", targetURL: \"http://www.biying.com\" }, { id: 3, \"imagePath\": \"./3.jpeg\", targetURL: \"http://www.google.com\" }, ] // 在main下生成 new Carousel(imageAndPathArray, \"main\"); 头像预览 在注册时，我们应当让用户看见自己选择的头像。 那么实现这个需要借助JavaScript内置对象文件阅读器（FileReader），除此之外还需要准备一个默认头像。 最简单的实现过程： 创建一个img标签，默认头像放进去 创建一个input:file标签，并设置为隐藏 点击img标签时，将input:file设为选择状态，选择文件 上传头像后通过文件阅读器阅读出文件内容，并将它写在img标签中以替换默认头像 实现代码： Document img { width: 3rem; border-radius: 50%; border: 1px solid #ddd; } \"use strict\"; let imgNode = document.getElementById(\"upload-avatar\"); let inputFileNode = document.getElementById(\"avatar\"); imgNode.addEventListener(\"click\", event => { // 单击文件上传按钮 inputFileNode.click(); }) inputFileNode.addEventListener(\"change\", event => { if (inputFileNode.files.length > 0) { // 获取头像 let avatar = inputFileNode.files[0]; // 通过文件阅读器拿出头像 let fileReader = new FileReader(); // 异步操作，读取上传的图片 fileReader.readAsDataURL(avatar); // 当文件阅读器可读时，替换默认头像，它会将图像替换为base64位数据流格式 fileReader.addEventListener(\"load\", event => { imgNode.src = fileReader.result; }); } }) Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-08-14 22:53:02 "},"前端专栏/jQuery/summary.html":{"url":"前端专栏/jQuery/summary.html","title":"jQuery","keywords":"","body":" 基础介绍 选择器 筛选器 属性内容 文档操作 样式操作 事件操作 空间坐标 动画效果 插件扩展 网络请求 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-08-21 15:17:56 "},"前端专栏/jQuery/基础介绍.html":{"url":"前端专栏/jQuery/基础介绍.html","title":"基础介绍","keywords":"","body":"jQuery简介 jQuery是由美国大神John Resig基于JavaScript开发，旨在用更少的代码完成更多的事情。 jQuery是一个非常快速简洁的JavaScript第三方库，它能够让用户更加方便的选择DOM、处理事件、实现动画效果与前后端交互 jQuery十分的轻量级，这是其他的JavaScript框架所不及的，除此之外它还兼容CSS3，相较于原生的JavaScript来说对各种版本的浏览器都具有更好的兼容性 jQuery的官方文档特别齐全，各种应用说明十分详细，同时还具有很多成熟的插件可供选择 官方网站 官方文档 其实自从ES6版本发布以来，原生的JavaScript和jQuery的开发效率已经差不了多少了，随之而来的是jQuery的使用变的越来越少，甚至互联网上一度有人认为jQuery是一项过时的技术，这也是一个不争的实时，现在的主流框架都是Vue和React，但jQuery依然有它的用武之地，特别是维护或者翻新一些老旧项目时，如果你不了解jQuery，你可能会看的一头雾水。 总而言之，jQuery学习周期短，学习成本低，后期回报也不错，还是非常建议前端开发人员去研究的。 jQuery版本 jQuery主要分为1、2、3版本，先已更新到jQuery3.6。 1.x：兼容IE678，使用最为广泛的，官方只做BUG维护，功能不再新增。因此一般项目来说，使用1.x版本就可以了，最终版本：1.12.4 (2016年5月20日) 2.x：不兼容IE678，很少有人使用，官方只做BUG维护，功能不再新增。如果不考虑兼容低版本的浏览器可以使用2.x，最终版本：2.2.4 (2016年5月20日) 3.x：不兼容IE678，只支持最新的浏览器。需要注意的是很多老的jQuery插件不支持3.x版。目前该版本是官方主要更新维护的版本 在学习时推荐使用3.x版本，因为一些老旧的浏览器使用的人也越来越少了，如果有特殊的需求那么还是建议使用1.x版本进行开发。 jQuery引入 离线文件 jQuery离线版本可在官网中自行下载，在学习时推荐使用未压缩版本，正式的生产环境中则应该使用压缩版本。 下载完成后直接通过标签进行引入即可。 点我进入下载页： 在线引入 使用bootCDN提供的在线jQuery引入，能够省去下载步骤。 点我进入下载页： vscode代码片段 为了方便后期更加快速的导入jQuery，我们可以用vscode为其做一个代码片段。 \"jQueryImport\": { \"prefix\": \"$\", \"body\": [ \"\" ], \"description\": \"快速引入jQuery\" }, 当你在HTML文件中输入$的时候，将会自动提示是否快速输入body中的内容。 jQuery对象 基本介绍 如何使用jQuery呢？实际上我们只需要导入jQuery库，然后再使用$或者jQuery选择出想要的DOM节点即可。 $是jQuery的别名，直接使用$就相当于使用了jQuery对象 通过jQuery选择出的DOM节点，在命名时应当加上$的前缀 如下示例： Document HELLO WORLD \"use strict\"; let $div = $(\"div\"); // 也可通过jQuery(\"div\")达到相同的效果 console.log($div.text()); // HELLO WORLD 元素集合 使用jQuery提供的选择器选择出的DOM节点会被包装为jQuery对象，它是一个类似于NodeList的容器类型。 哪怕jQuery选择器只选择出了一个元素节点，它也会返回一个jQuery对象元素集合体。 你可以将它当做是始终使用了document.querySelectorAll()来选择的元素，无论怎样都不会返回一个具体的元素节点，只会返回NodeList元素集合。 此外，jQuery对象下所提供的方法和DOM节点所提供的方法并不互通，所以在变量命名时，一定要使用$来标识这到底是通过jQuery选择器选择出的结果还是原生JavaScript选择器选择出的结果。 如下所示，我们通过jQuery选择器选择到了2个，打印它们的innerText，在jQuery中，打印innerText需要使用text()方法： Document im a first div im a last div \"use strict\"; let $div = $(\"div\"); console.log($div.text()); // im a first divim a last div 注意它的打印结果，也就是说对jQuery对象使用任何方法其结果都会作用到jQuery对象内部所有的DOM元素节点身上。 它相当于下面这段由原生JavaScript所编写的代码： Document im a first div im a last div \"use strict\"; let divNodeList = document.querySelectorAll(\"div\"); let result = Array.prototype.reduce.call(divNodeList, (pre, cur, index, array) => { return pre + cur.innerText; }, \"\"); console.log(result); // im a first divim a last div 节点提取 如果你想从jQuery对象中提取某个DOM节点，可通过[]或者get()方法来进行提取，jQuery对象是具有length属性的，所以可以通过索引来对其进行操作。 Document im a first div im a last div \"use strict\"; let $div = $(\"div\"); let divNode = $div.get(0); console.log(divNode.innerText); // im a first div 它相当于对NodeList对象使用[]或者item()进行提取DOM节点一样。 Document im a first div im a last div \"use strict\"; let divNodeList = document.querySelectorAll(\"div\"); let divNode = divNodeList.item(0); console.log(divNode.innerText); // im a first div 布尔判定 jQuery对象属于引用对象，它是一个容器类型，所以在if判断时不管内部是否有内容都会返回true。 当你想要判断jQuery是否成功选择了某个元素节点时，如果单纯的用!!jQuery来进行判断，得到的结果总是true。 正确的判定方式应该是判断它的长度，!!jQuery.length才对。 如下所示： Document \"use strict\"; let $span = $(\"span\"); console.log(!!$span); console.log(!!$span.length); // true // false Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-08-15 17:25:24 "},"前端专栏/jQuery/选择器.html":{"url":"前端专栏/jQuery/选择器.html","title":"选择器","keywords":"","body":"基本选择器 * 通用选择器 使用*可以匹配所有元素。 它将返回一个jQuery对象，即包含所有被选中元素的集合容器。 body { padding: 1rem; } header main footer \"use strict\"; let $elements = $(\"*\"); $elements.css(\"color\", \"#aaa\"); console.log($elements); // jQuery.fn.init(10) [html, head, style, body, header, main, footer, script, script, script, prevObject: jQuery.fn.init(1)] E 名字选择器 根据tagName来匹配多个元素。 它将返回一个jQuery对象，即包含所有被选中元素的集合容器。 body { padding: 1rem; } header 1 2 3 footer \"use strict\"; let $elements = $(\"li\"); $elements.css(\"color\", \"#aaa\"); console.log($elements); // jQuery.fn.init(3) [li, li, li, prevObject: jQuery.fn.init(1)] # ID选择器 使用#可根据id属性来匹配一个元素。 它将返回一个jQuery对象，即包含所有被选中元素的集合容器。 body { padding: 1rem; } header 1 2 3 footer \"use strict\"; let $elements = $(\"#top\"); $elements.css(\"color\", \"#aaa\"); console.log($elements); // jQuery.fn.init [header#top] . 类选择器 使用.可根据class属性来匹配多个元素。 它将返回一个jQuery对象，即包含所有被选中元素的集合容器。 body { padding: 1rem; } header 1 2 3 A B C footer \"use strict\"; let $elements = $(\".odd_li\"); $elements.css(\"color\", \"#aaa\"); console.log($elements); // jQuery.fn.init(4) [li.odd_li, li.odd_li, li.odd_li, li.odd_li, prevObject: jQuery.fn.init(1)] 组合选择器 Feature 交集选择器 根据元素不同的特征进行高精度的匹配出一个或多个元素。 它将返回一个jQuery对象，即包含所有被选中元素的集合容器。 如下示例，仅返回第一个下的class为odd-li的标签： body { padding: 1rem; } header 1 2 3 A B C footer \"use strict\"; let $elements = $(\"ul:first-of-type() .odd_li\"); $elements.css(\"color\", \"#aaa\"); console.log($elements); // jQuery.fn.init(2) [li.odd_li, li.odd_li, prevObject: jQuery.fn.init(1)] E, F 并集选择器 使用逗号进行分割可一次性匹配多个元素。 它将返回一个jQuery对象，即包含所有被选中元素的集合容器。 如下示例，同时匹配标签和标签： body { padding: 1rem; } header 1 2 3 A B C footer \"use strict\"; let $elements = $(\"header, footer\"); $elements.css(\"color\", \"#aaa\"); console.log($elements); // jQuery.fn.init(2) [header, footer, prevObject: jQuery.fn.init(1)] E F 后代选择器 使用空格进行分隔可匹配某个元素所有后代的元素。 它将返回一个jQuery对象，即包含所有被选中元素的集合容器。 如下所示，返回标签的所有后代： body { padding: 1rem; } header 1 2 3 A B C footer \"use strict\"; let $elements = $(\"body *\"); $elements.css(\"color\", \"#aaa\"); console.log($elements); // jQuery.fn.init(14) [header, main, ul, li.odd_li, li, li.odd_li, ul, li.odd_li, li, li.odd_li, footer, script, script, script, prevObject: jQuery.fn.init(1)] E > F 子代选择器 使用>进行分割可匹配某个元素直系后代的元素。 它将返回一个jQuery对象，即包含所有被选中元素的集合容器。 如下所示，返回标签的直系后代： body { padding: 1rem; } header 1 2 3 A B C footer \"use strict\"; let $elements = $(\"body>*\"); $elements.css(\"color\", \"#aaa\"); console.log($elements); // jQuery.fn.init(6) [header, main, footer, script, script, script, prevObject: jQuery.fn.init(1)] E + F 同级毗邻选择器 使用+进行分割可匹配某个元素紧随其后的一个元素。 它将返回一个jQuery对象，即包含所有被选中元素的集合容器。 如下所示，返回标签的后一个标签： body { padding: 1rem; } header 1 2 3 A B C footer \"use strict\"; let $elements = $(\"header+*\"); $elements.css(\"color\", \"#aaa\"); console.log($elements); // jQuery.fn.init [main, prevObject: jQuery.fn.init(1)] E ~ F 同级多跨选择器 使用~进行分割可匹配某个元素紧随其后的所有元素。 它将返回一个jQuery对象，即包含所有被选中元素的集合容器。 如下所示，返回标签的后面所有标签： body { padding: 1rem; } header 1 2 3 A B C footer \"use strict\"; let $elements = $(\"header~*\"); $elements.css(\"color\", \"#aaa\"); console.log($elements); // jQuery.fn.init(5) [main, footer, script, script, script, prevObject: jQuery.fn.init(1)] 属性选择器 [attribute] 用于选取带有指定属性的元素。 它将返回一个jQuery对象，即包含所有被选中元素的集合容器: body { padding: 1rem; } header 1 2 3 A B C footer \"use strict\"; let $elements = $(\"[data-id]\"); $elements.css(\"color\", \"#aaa\"); console.log($elements); // jQuery.fn.init(6) [li, li, li, li, li, li, prevObject: jQuery.fn.init(1)] [attribute=value] 用于选取带有指定属性和值的元素。 它将返回一个jQuery对象，即包含所有被选中元素的集合容器:: body { padding: 1rem; } header 1 2 3 A B C footer \"use strict\"; let $elements = $(\"[data-id=li-1]\"); $elements.css(\"color\", \"#aaa\"); console.log($elements); // jQuery.fn.init [li, prevObject: jQuery.fn.init(1)] [attribute!=value] 用于选取不带有指定属性和值的元素，必须配合交集选择器使用。 它将返回一个jQuery对象，即包含所有被选中元素的集合容器:: body { padding: 1rem; } header 1 2 3 A B C footer \"use strict\"; let $elements = $(\"li[data-id!=li-1]\"); $elements.css(\"color\", \"#aaa\"); console.log($elements); // jQuery.fn.init(5) [li, li, li, li, li, prevObject: jQuery.fn.init(1)] [attribute^=value] 匹配属性值以指定值开头的每个元素。 它将返回一个jQuery对象，即包含所有被选中元素的集合容器:: body { padding: 1rem; } header 1 2 3 A B C footer \"use strict\"; let $elements = $(\"[data-id^=li]\"); $elements.css(\"color\", \"#aaa\"); console.log($elements); // jQuery.fn.init(6) [li, li, li, li, li, li, prevObject: jQuery.fn.init(1)] [attribute$=value] 匹配属性值以指定值结尾的每个元素。 它将返回一个jQuery对象，即包含所有被选中元素的集合容器: body { padding: 1rem; } header 1 2 3 A B C footer \"use strict\"; let $elements = $(\"[data-id$=C], [data-id$=3]\"); $elements.css(\"color\", \"#aaa\"); console.log($elements); // jQuery.fn.init(2) [li, li, prevObject: jQuery.fn.init(1)] [attribute*=value] 匹配属性值中包含指定值的每个元素。 它将返回一个jQuery对象，即包含所有被选中元素的集合容器: body { padding: 1rem; } header 1 2 3 A B C footer \"use strict\"; let $elements = $(\"[data-id*=B]\"); $elements.css(\"color\", \"#aaa\"); console.log($elements); // jQuery.fn.init [li, prevObject: jQuery.fn.init(1)] 结构伪类选择器 :root 匹配文档根元素，即标签。 它将返回一个jQuery对象，其中包含所有被选中的元素节点： body { padding: 1rem; } header 1 2 3 A B C footer \"use strict\"; let $elements = $(\":root\"); $elements.css(\"color\", \"#aaa\"); console.log($elements); // jQuery.fn.init [html, prevObject: jQuery.fn.init(1)] :header 匹配h~系列的标题元素。 它将返回一个jQuery对象，其中包含所有被选中的元素节点： body { padding: 1rem; } h1 element h2 element h3 element header 1 2 3 A B C footer \"use strict\"; let $elements = $(\":header\"); $elements.css(\"color\", \"#aaa\"); console.log($elements); // jQuery.fn.init(3) [h1, h2, h3, prevObject: jQuery.fn.init(1)] :parent 匹配含有后代的父元素，不论该后代是元素节点还是其他节点。 它将返回一个jQuery对象，其中包含所有被选中的元素节点： body { padding: 1rem; } header 1 2 3 A B C footer \"use strict\"; let $elements = $(\"header:parent\"); $elements.css(\"color\", \"#aaa\"); console.log($elements); // jQuery.fn.init [header, prevObject: jQuery.fn.init(1)] :empty 匹配不含有子元素或文本的元素。 它将返回一个jQuery对象，其中包含所有被选中的元素节点： body { padding: 1rem; } header 1 2 3 A B C footer \"use strict\"; let $elements = $(\":empty\"); $elements.css(\"color\", \"#aaa\"); console.log($elements); // jQuery.fn.init(2) [aside, script, prevObject: jQuery.fn.init(1)] :first 匹配第一个元素，只选一个。 它将返回一个jQuery对象，其中包含所有被选中的元素节点： body { padding: 1rem; } header 1 2 3 A B C footer \"use strict\"; let $elements = $(\"ul li:first\"); $elements.css(\"color\", \"#aaa\"); console.log($elements); // jQuery.fn.init [li, prevObject: jQuery.fn.init(1)] :last 匹配最后一个元素，只选一个。 它将返回一个jQuery对象，其中包含所有被选中的元素节点： body { padding: 1rem; } header 1 2 3 A B C footer \"use strict\"; let $elements = $(\"ul li:last\"); $elements.css(\"color\", \"#aaa\"); console.log($elements); // jQuery.fn.init [li, prevObject: jQuery.fn.init(1)] :first-of-type 按照类型匹配第一个元素，可选多个。 它将返回一个jQuery对象，其中包含所有被选中的元素节点： body { padding: 1rem; } header 1 2 3 A B C footer \"use strict\"; let $elements = $(\"ul li:first-of-type\"); $elements.css(\"color\", \"#aaa\"); console.log($elements); // jQuery.fn.init(2) [li, li, prevObject: jQuery.fn.init(1)] :last-of-type 按照类型匹配第一个元素，可选多个。 它将返回一个jQuery对象，其中包含所有被选中的元素节点： body { padding: 1rem; } header 1 2 3 A B C footer \"use strict\"; let $elements = $(\"ul li:last-of-type\"); $elements.css(\"color\", \"#aaa\"); console.log($elements); // jQuery.fn.init(2) [li, li, prevObject: jQuery.fn.init(1)] :first-child 匹配第一个子元素，可选多个。 它将返回一个jQuery对象，其中包含所有被选中的元素节点： body { padding: 1rem; } header 1 2 3 A B C footer \"use strict\"; let $elements = $(\"ul li:first-child\"); $elements.css(\"color\", \"#aaa\"); console.log($elements); // jQuery.fn.init(2) [li, li, prevObject: jQuery.fn.init(1)] :last-child 匹配最后一个子元素，可选多个。 它将返回一个jQuery对象，其中包含所有被选中的元素节点： body { padding: 1rem; } header 1 2 3 A B C footer \"use strict\"; let $elements = $(\"ul li:last-child\"); $elements.css(\"color\", \"#aaa\"); console.log($elements); // jQuery.fn.init(2) [li, li, prevObject: jQuery.fn.init(1)] :nth-child(n) 按照位置正序匹配父元素下第N个子元素： 参数N可以是从1开始的数字 可以是公式，如（2n+1） 可以是odd，它将匹配所有奇数项（从1开始计数） 可以是even，它将匹配所有的偶数项（从1开始计数） 它将返回一个jQuery对象，其中包含所有被选中的元素节点： body { padding: 1rem; } header 1 2 3 A B C footer \"use strict\"; let $elements = $(\"ul:nth-child(1) li:nth-child(odd)\"); $elements.css(\"color\", \"#aaa\"); console.log($elements); // jQuery.fn.init(2) [li, li, prevObject: jQuery.fn.init(1)] :nth-last-child(n) 按照位置倒序匹配父元素下第N个子元素： 参数N可以是从1开始的数字 可以是公式，如（2n+1） 可以是odd，它将匹配所有奇数项（从1开始计数） 可以是even，它将匹配所有的偶数项（从1开始计数） 它将返回一个jQuery对象，其中包含所有被选中的元素节点： body { padding: 1rem; } header 1 2 3 A B C footer \"use strict\"; let $elements = $(\"ul:nth-last-child(1) li:nth-last-child(odd)\"); $elements.css(\"color\", \"#aaa\"); console.log($elements); // jQuery.fn.init(2) [li, li, prevObject: jQuery.fn.init(1)] :nth-of-type(n) 按照类型正序匹配父元素下第N个子元素 参数N可以是从1开始的数字 可以是公式，如（2n+1） 可以是odd，它将匹配所有奇数项（从1开始计数） 可以是even，它将匹配所有的偶数项（从1开始计数） 它将返回一个jQuery对象，其中包含所有被选中的元素节点： body { padding: 1rem; } header 1 2 3 A B C footer \"use strict\"; let $elements = $(\"ul li:nth-of-type(odd)\"); $elements.css(\"color\", \"#aaa\"); console.log($elements); // jQuery.fn.init(4) [li, li, li, li, prevObject: jQuery.fn.init(1)] :nth-last-of-type(n) 按照类型倒序匹配父元素下第N个子元素 参数N可以是从1开始的数字 可以是公式，如（2n+1） 可以是odd，它将匹配所有奇数项（从1开始计数） 可以是even，它将匹配所有的偶数项（从1开始计数） 它将返回一个jQuery对象，其中包含所有被选中的元素节点： body { padding: 1rem; } header 1 2 3 A B C footer \"use strict\"; let $elements = $(\"ul li:nth-last-of-type(odd)\"); $elements.css(\"color\", \"#aaa\"); console.log($elements); // jQuery.fn.init(4) [li, li, li, li, prevObject: jQuery.fn.init(1)] :only-child 匹配出一个没有任何兄弟姐妹的子元素，即独生子元素。 它将返回一个jQuery对象，其中包含所有被选中的元素节点： body { padding: 1rem; } hello jQuery 1 2 3 A B C footer \"use strict\"; let $elements = $(\"h1:only-child\"); $elements.css(\"color\", \"#aaa\"); console.log($elements); // jQuery.fn.init [h1, prevObject: jQuery.fn.init(1)] :only-of-type 匹配出一个没有同类型兄弟姐妹的子元素。 它将返回一个jQuery对象，其中包含所有被选中的元素节点： body { padding: 1rem; } h1 h2 h2 1 2 3 A B C footer \"use strict\"; let $elements = $(\"header nav h1:only-of-type, header nav h2:only-of-type\"); $elements.css(\"color\", \"#aaa\"); console.log($elements); // jQuery.fn.init [h1, prevObject: jQuery.fn.init(1)] 索引伪类选择器 :odd 匹配所有索引值为奇数的元素，从0开始计数。 它将返回一个jQuery对象，其中包含所有被选中的元素节点： body { padding: 1rem; } header 1 2 3 A B C footer \"use strict\"; let $elements = $(\"ul li:odd\"); $elements.css(\"color\", \"#aaa\"); console.log($elements); // jQuery.fn.init(3) [li, li, li, prevObject: jQuery.fn.init(1)] :even 匹配所有索引值为偶数的元素，从0开始计数。 它将返回一个jQuery对象，其中包含所有被选中的元素节点： body { padding: 1rem; } header 1 2 3 A B C footer \"use strict\"; let $elements = $(\"ul li:even\"); $elements.css(\"color\", \"#aaa\"); console.log($elements); // jQuery.fn.init(3) [li, li, li, prevObject: jQuery.fn.init(1)] :eq(index) 匹配出等于索引值的元素。 它将返回一个jQuery对象，其中包含所有被选中的元素节点： body { padding: 1rem; } header 1 2 3 A B C footer \"use strict\"; let $elements = $(\"ul li:eq(2)\"); $elements.css(\"color\", \"#aaa\"); console.log($elements); // jQuery.fn.init [li, prevObject: jQuery.fn.init(1)] :gt(index) 匹配出大于索引值的元素。 它将返回一个jQuery对象，其中包含所有被选中的元素节点： body { padding: 1rem; } header 1 2 3 A B C footer \"use strict\"; let $elements = $(\"ul li:gt(2)\"); $elements.css(\"color\", \"#aaa\"); console.log($elements); // jQuery.fn.init(3) [li, li, li, prevObject: jQuery.fn.init(1)] :lt(index) 匹配出小于索引值的元素。 它将返回一个jQuery对象，其中包含所有被选中的元素节点： body { padding: 1rem; } header 1 2 3 A B C footer \"use strict\"; let $elements = $(\"ul li:lt(2)\"); $elements.css(\"color\", \"#aaa\"); console.log($elements); // jQuery.fn.init(2) [li, li, prevObject: jQuery.fn.init(1)] 表单元素选择器 测试代码 接下来的表单伪类选择器将在此代码上进行试验： CSS代码： * { padding: 0; margin: 0; box-sizing: border-box; } body { display: flex; width: 100vw; height: 100vh; justify-content: center; align-items: center; } form { min-width: 30%; border: 1px solid #ddd; padding: 1rem; } form div { margin-top: 0.5rem; } form div:nth-child(1) { display: flex; justify-content: center; align-items: center; } form div:nth-child(1) input[type=file] { display: none; } form div:nth-child(1) input[type=image] { border: 1px solid #ddd; border-radius: 50%; } form div:nth-child(2), form div:nth-child(3), form div:nth-child(4) { display: flex; justify-content: space-between; align-items: center; } form div:nth-child(2) input, form div:nth-child(3) input, form div:nth-child(4) input { flex-basis: 65%; } form div:nth-child(2) label, form div:nth-child(3) label, form div:nth-child(4) label { flex-basis: 35%; } form div:nth-child(5) :nth-child(even), form div:nth-child(6) :nth-child(even) { margin-right: 1rem; } form div:nth-child(7) select { margin-left: 1rem; width: 25%; } form div:nth-child(8) textarea { width: 100%; height: 12rem; resize: none; } HTML代码： username: password: confirm password: male: female: basketball football volleyball city BeiJing ShangHai TianJin ChongQing submit reset JavaScript代码： \"use strict\"; let $form = $(\"form\"); let $elements = $(\"要测试的选择器\"); $(\"input:image\").on(\"click\", jQEvent => { jQEvent.preventDefault(); $(\"input:file\").click(); }); $(\"input:file\").on(\"change\", jQEvent => { let $inputFileNode = $(\"input:file\"); let $inputImageNode = $(\"input:image\"); if ($inputFileNode.prop(\"files\").length > 0) { // 获取头像 let avatar = $inputFileNode.prop(\"files\")[0]; // 通过文件阅读器拿出头像 let fileReader = new FileReader(); // 异步操作，读取上传的图片 fileReader.readAsDataURL(avatar); // 当文件阅读器可读时，替换默认头像，它会将图像替换为base64位数据流格式 $(fileReader).on(\"load\", jQevent => { $inputImageNode.prop(\"src\", fileReader.result); }); } }); $(\"button:submit\").on(\"click\", jQEvent => { jQEvent.preventDefault(); SelectorTest(); }); $(\"button:reset\").on(\"click\", jQEvent => { $elements.css(\"outline\", \"none\"); }) function SelectorTest() { $elements.css(\"outline\", \"1px solid #ff0000\"); console.log($elements); } 当定义好选择器后，点击submit按钮将会以最直观的方式看见被匹配的元素项，如匹配默认选中的checked的元素： :input 匹配所有的、、、元素。 它将返回一个jQuery对象，其中包含所有被选中的元素节点： let $elements = $(\":input\"); // ... function SelectorTest() { $elements.css(\"outline\", \"1px solid #ff0000\"); console.log($elements); } // jQuery.fn.init(14) [input, input#avatar, input#username, input#password, input#re_password, input#male, input#female, input#baketball, input#football, input#volleyball, select#city, textarea, button, button, prevObject: jQuery.fn.init(1)] :text 匹配所有的单行文本框。 它将返回一个jQuery对象，其中包含所有被选中的元素节点： let $elements = $(\":text\"); // ... function SelectorTest() { $elements.css(\"outline\", \"1px solid #ff0000\"); console.log($elements); } // jQuery.fn.init [input#username, prevObject: jQuery.fn.init(1)] :password 匹配所有的密码框。 它将返回一个jQuery对象，其中包含所有被选中的元素节点： let $elements = $(\":password\"); // ... function SelectorTest() { $elements.css(\"outline\", \"1px solid #ff0000\"); console.log($elements); } // jQuery.fn.init(2) [input#password, input#re_password, prevObject: jQuery.fn.init(1)] :radio 匹配所有的单选框。 它将返回一个jQuery对象，其中包含所有被选中的元素节点： let $elements = $(\":radio\"); // ... function SelectorTest() { $elements.css(\"outline\", \"1px solid #ff0000\"); console.log($elements); } // jQuery.fn.init(2) [input#male, input#female, prevObject: jQuery.fn.init(1)] :checkbox 匹配所有的复选框。 它将返回一个jQuery对象，其中包含所有被选中的元素节点： let $elements = $(\":checkbox\"); // ... function SelectorTest() { $elements.css(\"outline\", \"1px solid #ff0000\"); console.log($elements); } // jQuery.fn.init(3) [input#baketball, input#football, input#volleyball, prevObject: jQuery.fn.init(1)] :submit 匹配所有的提交按钮，包括、。 而大多数浏览器中，默认的type就是submit，故也会匹配到。 它将返回一个jQuery对象，其中包含所有被选中的元素节点： let $elements = $(\":submit\"); // ... function SelectorTest() { $elements.css(\"outline\", \"1px solid #ff0000\"); console.log($elements); } // jQuery.fn.init [button, prevObject: jQuery.fn.init(1)] :reset 匹配所有的重置按钮，包括、。 它将返回一个jQuery对象，其中包含所有被选中的元素节点： let $elements = $(\":reset\"); // ... function SelectorTest() { $elements.css(\"outline\", \"1px solid #ff0000\"); console.log($elements); } // jQuery.fn.init [button, prevObject: jQuery.fn.init(1)] :button 匹配所有的按钮。 它将返回一个jQuery对象，其中包含所有被选中的元素节点： let $elements = $(\":button\"); // ... function SelectorTest() { $elements.css(\"outline\", \"1px solid #ff0000\"); console.log($elements); } // jQuery.fn.init(2) [button, button, prevObject: jQuery.fn.init(1)] :image 匹配所有的图像域。 它将返回一个jQuery对象，其中包含所有被选中的元素节点： let $elements = $(\":image\"); // ... function SelectorTest() { $elements.css(\"outline\", \"1px solid #ff0000\"); console.log($elements); } // jQuery.fn.init [input, prevObject: jQuery.fn.init(1)] :file 匹配所有的文件域。 它将返回一个jQuery对象，其中包含所有被选中的元素节点。 示例中的文件域是隐藏的，故看不见效果。 let $elements = $(\":file\"); // ... function SelectorTest() { $elements.css(\"outline\", \"1px solid #ff0000\"); console.log($elements); } // jQuery.fn.init [input#avatar, prevObject: jQuery.fn.init(1)] 表单状态选择器 :enabled 匹配所有默认可用的元素。 它将返回一个jQuery对象，其中包含所有被选中的元素节点： let $elements = $(\":enabled\"); // ... function SelectorTest() { $elements.css(\"outline\", \"1px solid #ff0000\"); console.log($elements); } // jQuery.fn.init(18) [input, input#avatar, input#username, input#password, input#re_password, input#male, input#female, input#baketball, input#football, input#volleyball, select#city, option, option, option, option, textarea, button, button, prevObject: jQuery.fn.init(1)] :disabled 匹配所有默认被禁用的元素。 它将返回一个jQuery对象，其中包含所有被选中的元素节点。 由于示例中没有默认被禁用的元素，故看不见效果。 let $elements = $(\":disabled\"); // ... function SelectorTest() { $elements.css(\"outline\", \"1px solid #ff0000\"); console.log($elements); } // jQuery.fn.init [prevObject: jQuery.fn.init(1)] :checked 匹配所有默认被选中的元素，包括checkbox、radio、以及，如果只想要匹配，建议使用:selected。 它将返回一个jQuery对象，其中包含所有被选中的元素节点： let $elements = $(\":checked\"); // ... function SelectorTest() { $elements.css(\"outline\", \"1px solid #ff0000\"); console.log($elements); } // jQuery.fn.init(3) [input#male, input#baketball, option, prevObject: jQuery.fn.init(1)] :selected 匹配所有默认被选中的元素。 它将返回一个jQuery对象，其中包含所有被选中的元素节点。 由于元素被放置在元素中，故看不见效果。 let $elements = $(\":selected\"); // ... function SelectorTest() { $elements.css(\"outline\", \"1px solid #ff0000\"); console.log($elements); } // jQuery.fn.init [option, prevObject: jQuery.fn.init(1)] 其他伪类选择器 :lang 语言 匹配出指定语言的所有元素。 :lang选择器，匹配有一个语言值等于所提供的语言代码，或以提供的语言代码开始，后面马上跟一个“- ”的元素。 例如，选择器$(\"div:lang(en)\")将匹配 and （和他们的后代），但不包括 对于HTML元素，语言值由lang属性决定，也可能由来自meta元素或HTTP头信息决定。 由于使用的较少，故在此不再举例。 它将返回一个jQuery对象，其中包含所有被选中的元素节点。 :target 锚点 匹配由文档URI的格式化识别码表示的目标元素。 如果文档的URI包含一个格式化的标识符，或hash， 然后:target选择器将匹配id和标识符相匹配的元素。 例如，给定的URI https://example.com/#foo，$( \"p:target\" )，将匹配元素。 它将返回一个jQuery对象，其中包含所有被选中的元素节点： link target click me $(\"a\").on(\"click\", (jQEvent) => { $(\":target\").css(\"background-color\", \"#aaa\"); }); :has(selector) 包含元素 匹配含有特定子元素的父元素，它将返回一个jQuery对象，其中包含所有被选中的元素节点： body { padding: 1rem; } ??? div \"use strict\"; // div的子标签必须是div let $elements = $(\"div:has(div)\"); $elements.css(\"color\", \"#aaa\"); console.log($elements); // jQuery.fn.init [div, prevObject: jQuery.fn.init(1)] :contains(text) 包含文本 匹配含有特定文本内容的父元素，它将返回一个jQuery对象，其中包含所有被选中的元素节点： body { padding: 1rem; } ??? div \"use strict\"; // div的文本内容必须是div let $elements = $(\"div:contains(div)\"); $elements.css(\"color\", \"#aaa\"); console.log($elements); // jQuery.fn.init [div, prevObject: jQuery.fn.init(1)] :hidden 隐藏 匹配所有不可见元素，或者type为hidden的元素。 它将返回一个jQuery对象，其中包含所有被选中的元素节点： :visible 可见 匹配所有可见元素。 它将返回一个jQuery对象，其中包含所有被选中的元素节点。 :not(seletctor) 反向 匹配所有不被(selector)选择到的元素。 它将返回一个jQuery对象，其中包含所有被选中的元素节点。 :focus 焦点 匹配正在被获取焦点的元素。 它将返回一个jQuery对象，其中包含所有被选中的元素节点。 :animated 动画 匹配所有正在执行动画的元素 它将返回一个jQuery对象，其中包含所有被选中的元素节点。 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-08-19 13:27:14 "},"前端专栏/jQuery/筛选器.html":{"url":"前端专栏/jQuery/筛选器.html","title":"筛选器","keywords":"","body":"获取子对象 first() 获取jQuery对象中的第一个DOM元素。 它将被包装成一个新的jQuery对象并返回。 body { padding: 1rem; } A B C D E \"use strict\"; let $elements = $(\"main div ul li\").first(); $elements.css(\"color\", \"#aaa\"); console.log($elements); // jQuery.fn.init [li, prevObject: jQuery.fn.init(5)] last() 获取jQuery对象中的最后一个DOM元素。 它将被包装成一个新的jQuery对象并返回。 body { padding: 1rem; } A B C D E \"use strict\"; let $elements = $(\"main div ul li\").last(); $elements.css(\"color\", \"#aaa\"); console.log($elements); // jQuery.fn.init [li, prevObject: jQuery.fn.init(5)] eq(index) 根据索引位置获取jQuery对象中指定的一个DOM元素，从0开始计数。 它将被包装成一个新的jQuery对象并返回。 body { padding: 1rem; } A B C D E \"use strict\"; let $elements = $(\"main div ul li\").eq(2); $elements.css(\"color\", \"#aaa\"); console.log($elements); // jQuery.fn.init [li, prevObject: jQuery.fn.init(5)] odd() 根据索引位置获取jQuery对象中奇数项的所有DOM元素，从0开始计数。 它将被包装成一个新的jQuery对象并返回。 body { padding: 1rem; } A B C D E \"use strict\"; let $elements = $(\"main div ul li\").odd(); $elements.css(\"color\", \"#aaa\"); console.log($elements); // jQuery.fn.init(2) [li, li, prevObject: jQuery.fn.init(5)] even() 根据索引位置获取jQuery对象中偶数项的所有DOM元素，从0开始计数。 它将被包装成一个新的jQuery对象并返回。 body { padding: 1rem; } A B C D E \"use strict\"; let $elements = $(\"main div ul li\").even(); $elements.css(\"color\", \"#aaa\"); console.log($elements); // jQuery.fn.init(2) [li, li, prevObject: jQuery.fn.init(5)] slice() 根据索引对jQuery对象进行切片，顾头不顾尾。 它将被包装成一个新的jQuery对象并返回。 body { padding: 1rem; } A B C D E \"use strict\"; let $elements = $(\"main div ul li\").slice(1, 4); $elements.css(\"color\", \"#aaa\"); console.log($elements); // jQuery.fn.init(3) [li, li, li, prevObject: jQuery.fn.init(5)] 增加子对象 add() 添加一个DOM元素至jQuery对象中，这将返回一个新的jQuery对象。 也可以添加一个jQuery对象至另一个jQuery对象中，它内部会遍历所有的DOM元素并进行添加，这将返回一个新的jQuery对象。 body { padding: 1rem; } A B C D E \"use strict\"; let $jQ = $(); let $jQAddDiv = $jQ.add(document.createElement(\"div\")); let $jQAddJQ = $jQ.add($(\"main div ul li\")); console.log($jQAddDiv); console.log($jQAddJQ); // jQuery.fn.init [div, prevObject: j…y.fn.init] // jQuery.fn.init(5) [li, li, li, li, li, prevObject: j…y.fn.init] 删除子对象 not() 删除一个与指定表达式匹配的DOM元素，并且返回一个新的jQuery对象。 body { padding: 1rem; } A B C D E \"use strict\"; let $elements = $(\"main div ul li\"); let $new_elements = $elements.not($(\"main div ul li:nth-child(1)\")); console.log($new_elements); // jQuery.fn.init(4) [li, li, li, li, prevObject: jQuery.fn.init(5)] 对象检测 is() 检测一个元素，或者一个jQuery对象是否被另一个jQuery对象所包含，返回Boolean类型： body { padding: 1rem; } A B C D E \"use strict\"; let $elements = $(\"main div ul li\"); // 检测DOM元素是否被jQuery对象所包含 console.log( $elements.is(document.querySelector(\"main div ul li:nth-child(2)\")) ); // 检测jQuery对象是否被另一个jQuery对象所包含 console.log( $elements.is($(\"main div ul li\").slice(1, 3)) ); // true // true 对象遍历 each() each()用于递归的操作DOM元素，并根据操作修改原jQuery中的DOM元素。 使用该方法时需要绑定一个回调函数，该回调函数没有返回结果。 注意与map()方法的区别，该方法是对jQuery对象进行原地操作，不会生成新的jQuery对象。 回调函数共有3个参数： index：被遍历的DOM元素索引值 value：被遍历的DOM元素本身 array：被遍历的原jQuery对象本身 此外，在普通回调函数中可使用this，这代表当前被遍历的DOM元素，如果是箭头回调函数，则会指向undefined。 如下所示，为原jQuery对象中每个DOM元素添加上特征属性data-order： body { padding: 1rem; } A B C D E \"use strict\"; let $elements = $(\"main div ul li\"); $elements.each((index, element, array) => { element.setAttribute(\"data-order\", Math.floor(Math.random() * 5) + 1); }) console.log($elements); // jQuery.fn.init(5) [li, li, li, li, li, prevObject: jQuery.fn.init(1)] filter() filter()用于递归的检测DOM元素，所有检测结果为true的DOM元素添加至新的jQuery对象中，检测结果为false的DOM元素丢弃。 当检测完毕后会返回新的jQuery对象。 使用该方法时需要绑定一个回调函数，该回调函数必须返回true或者false。 回调函数共有3个参数： index：被遍历的DOM元素索引值 value：被遍历的DOM元素本身 array：被遍历的原jQuery对象本身 此外，在普通回调函数中可使用this，这代表当前被遍历的DOM元素，如果是箭头回调函数，则会指向undefined。 如下示例，我们需要检测innerText为A的DOM被返回。 body { padding: 1rem; } A B C D E \"use strict\"; let $elements = $(\"main div ul li\"); let $conditionTrue = $elements.filter((index, element, array) => { return element.innerText === \"A\"; }) console.log($conditionTrue); // jQuery.fn.init [li, prevObject: jQuery.fn.init(5)] map() map()用于递归的操作DOM元素，并将操作完成后的DOM元素添加进jQuery对象中。 当操作完毕后会返回新的jQuery对象。 使用该方法时需要绑定一个回调函数，该回调函数可有返回结果，也可以没有返回结果，若没返回结果则新生成的jQuery则为空。 注意与each()方法的区别，该方法不会对原jQuery对象造成任何改变，只会生成新的jQuery对象。 回调函数共有3个参数： index：被遍历的DOM元素索引值 value：被遍历的DOM元素本身 array：被遍历的原jQuery对象本身 此外，在普通回调函数中可使用this，这代表当前被遍历的DOM元素，如果是箭头回调函数，则会指向undefined。 如下示例，遍历原jQuery对象中的所有DOM元素，提取其innerText并返回组成一个新的jQuery对象： body { padding: 1rem; } A B C D E \"use strict\"; let $elements = $(\"main div ul li\"); let $elementsText = $elements.map((index, element, array) => { return element.innerText; }) console.log($elementsText); // jQuery.fn.init(5) [\"A\", \"B\", \"C\", \"D\", \"E\", prevObject: jQuery.fn.init(5)] 层级关系获取 children() 子代 从子代元素筛选出符合条件的元素，返回一个新的jQuery对象： body { padding: 1rem; } A B C D E \"use strict\"; let $elements = $(\"main\"); let $li3 = $elements.children(\"div\").children(\"ul\").children(\"li\").eq(3); $li3.css(\"color\", \"#aaa\"); console.log($li3); // jQuery.fn.init [li, prevObject: jQuery.fn.init(5)] find() 后代 从后代元素筛选出符合条件的元素，返回一个新的jQuery对象： body { padding: 1rem; } A B C D E \"use strict\"; let $elements = $(\"main\"); let $li3 = $elements.find(\"div ul li\").eq(3); $li3.css(\"color\", \"#aaa\"); console.log($li3); // jQuery.fn.init [li, prevObject: jQuery.fn.init(5)] parent() 父级 获取或筛选父级元素，返回一个新的jQuery对象： body { padding: 1rem; } A B C D E \"use strict\"; let $elements = $(\"main div ul\"); let $parent = $elements.parent(); console.log($parent); // jQuery.fn.init [div, prevObject: jQuery.fn.init(1)] parents() 祖先 获取或筛选祖先级元素，返回一个新的jQuery对象： body { padding: 1rem; } A B C D E \"use strict\"; let $elements = $(\"main div ul\"); let $parents = $elements.parents(); console.log($parents); // jQuery.fn.init(4) [div, main, body, html, prevObject: jQuery.fn.init(1)] parentsUntill() 祖先区间 从当前对象开始，查找直系的所有祖先级标签，直到找到指定的祖先标签结束。 返回一个新的jQuery对象，若没有指定截止条件，将会一直向上查找到标签为止。 不会获取自身，不会获取符合指定条件的祖先标签 相当于孙子问爷爷，你的后代除了我还有谁，爷爷当然不会把自己算进去 示例如下： body { padding: 1rem; } A B C D E \"use strict\"; let $elements = $(\"main div ul\"); let $parentsUntil = $elements.parentsUntil(\"body\"); console.log($parentsUntil); // jQuery.fn.init(2) [div, main, prevObject: jQuery.fn.init(1)] closest() 条件祖先 查找最近的符合选择器的祖先元素（包括自身），返回一个新的jQuery对象。 找祖先，看最近的祖先能不能被选择器选中，如果不能继续向上找。 这与JavaScript中的closest()方法基本相同，但JavaScript中返回的是单个DOM元素，而jQuery中返回一个jQuery对象。 body { padding: 1rem; } A B C D E \"use strict\"; let $elements = $(\"main div ul\"); let $closest = $elements.closest(\"body\"); console.log($closest); // jQuery.fn.init [body, prevObject: jQuery.fn.init(1)] prev() 哥哥 获取或筛选当前元素同级中的前一个元素，返回一个新的jQuery对象。 body { padding: 1rem; } A B C D E \"use strict\"; let $elements = $(\"main div li\").eq(2).text(\"me\"); let $prev = $elements.prev().css({ \"color\": \"#aaa\" }); console.log($prev); // jQuery.fn.init [li, prevObject: jQuery.fn.init(1)] prevAll() 所有哥哥 获取或筛选当前元素同级中的前面所有元素，返回一个新的jQuery对象。 body { padding: 1rem; } A B C D E \"use strict\"; let $elements = $(\"main div li\").eq(2).text(\"me\"); let $prevAll = $elements.prevAll().css({ \"color\": \"#aaa\" }); console.log($prevAll); // jQuery.fn.init(2) [li, li, prevObject: jQuery.fn.init(1)] prevUntil() 哥哥区间 从当前对象开始，查找同级向前的所有标签，直到指定标签结束，返回一个新的jQuery对象。 返回一个新的jQuery对象，若没有指定截止条件，则相当于使用prevAll()方法。 不会获取自身，不会获取符合指定条件的哥哥标签 相当于弟弟问某一个哥哥，你的弟弟除了我还有谁，哥哥当然不会把自己算进去 示例如下： body { padding: 1rem; } A B C D E \"use strict\"; let $elements = $(\"main div li\").eq(4).text(\"me\"); let $prevUntil = $elements.prevUntil(\":contains(A)\").css({ \"color\": \"#aaa\" }); console.log($prevUntil); // jQuery.fn.init(3) [li, li, li, prevObject: jQuery.fn.init(1)] next() 弟弟 获取或筛选当前元素同级中的后一个元素，返回一个新的jQuery对象。 body { padding: 1rem; } A B C D E \"use strict\"; let $elements = $(\"main div li\").eq(2).text(\"me\"); let $next = $elements.next().css({ \"color\": \"#aaa\" }); console.log($next); // jQuery.fn.init [li, prevObject: jQuery.fn.init(1)] nextAll() 所有弟弟 获取或筛选当前元素同级中的后面所有元素，返回一个新的jQuery对象。 body { padding: 1rem; } A B C D E \"use strict\"; let $elements = $(\"main div li\").eq(2).text(\"me\"); let $nextAll = $elements.nextAll().css({ \"color\": \"#aaa\" }); console.log($nextAll); // jQuery.fn.init(2) [li, li, prevObject: jQuery.fn.init(1)] nextUntil() 弟弟区间 从当前对象开始，查找同级向后的所有标签，直到指定标签结束，返回一个新的jQuery对象。 返回一个新的jQuery对象，若没有指定截止条件，则相当于使用nextAll()方法。 不会获取自身，不会获取符合指定条件的弟弟标签 相当于哥哥问某一个弟弟，你的哥哥除了我还有谁，弟弟当然不会把自己算进去 示例如下： body { padding: 1rem; } A B C D E \"use strict\"; let $elements = $(\"main div li\").eq(0).text(\"me\"); let $nextUntil = $elements.nextUntil(\":contains(E)\").css({ \"color\": \"#aaa\" }); console.log($nextUntil); // jQuery.fn.init(3) [li, li, li, prevObject: jQuery.fn.init(1)] siblings() 所有兄弟 获取或筛选当前元素同级中的前面以及后面所有元素，返回一个新的jQuery对象。 body { padding: 1rem; } A B C D E \"use strict\"; let $elements = $(\"main div li\").eq(2).text(\"me\"); let $siblings = $elements.siblings().css({ \"color\": \"#aaa\" }); console.log($siblings); // jQuery.fn.init(4) [li, li, li, li, prevObject: jQuery.fn.init(1)] has() 必须有儿子 检测一个元素是否包含另一个元素，如果包含则返回一个新的jQuery对象，该jQuery对象中存有被检测的DOM元素。 以下示例将演示如果一个中包含则该的背景色变为红色。 ??? !!! ??? \"use strict\"; $(\"div\").has(\"span\").css(\"background-color\", \"red\"); 定位关系获取 offsetParent() 匹配出用于当前元素定位的祖先级节点元素，返回一个新的jQuery对象。 body { padding: 1rem; } main { position: relative; } main div ul { /* ul将按照main进行定位 */ position: absolute; } A B C D E \"use strict\"; let $elements = $(\"main div ul\"); let $offsetParent = $elements.offsetParent(); console.log($offsetParent); // jQuery.fn.init [main, prevObject: jQuery.fn.init(1)] 其他方法 addBack() 回链操作 addBack()方法将先前一次所选择的jQuery对象与最近一次所选择的jQuery对象中的元素进行合并，返回一个新的jQuery对象。 在jQuery1.8版本以下，该方法名为andSelf()。 jQuery对象中有一个prevObject属性，指向上一个链式操作的jQuery对象，如我先获取了包含的jQuery对象、再获取了包含的jQuery对象。 那么包含的jQuery对象的prevObject属性就指向包含标签的jQuery对象。 body { padding: 1rem; } A B C D E \"use strict\"; let $currentJq = $(\"main div ul\").find(\"li\"); let $prevjQ = $currentJq.prevObject; console.log($prevjQ); // jQuery.fn.init [ul, prevObject: jQuery.fn.init(1)] 回链操作addBack()方法的意思在于，同时操作当前的jQuery对象和上一个jQuery对象。 如我想为当前包含的jQuery对象和上一个包含的jQuery对象中的DOM元素都添加一个class属性，就可以使用到该方法： body { padding: 1rem; } A B C D E \"use strict\"; let $currentJq = $(\"main div ul\").find(\"li\"); $currentJq.addBack().addClass(\"ul_family\"); 最终的效果： A B C D E end() 回溯操作 对jQuery对象进行回溯，当我们操作完一组jQuery对象中的元素后又想拿到操作之前的原本jQuery对象就可使用此方法。 以下示例将展示选取所有的元素，查找并将子元素颜色，然后再使用end()回过来选取元素： Hello,how are you? \"use strict\"; console.log($(\"p\").find(\"span\").css(\"color\", \"red\").end()) // jQuery.fn.init [p, prevObject: jQuery.fn.init(1)] Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-08-17 15:37:00 "},"前端专栏/jQuery/属性内容.html":{"url":"前端专栏/jQuery/属性内容.html","title":"属性内容","keywords":"","body":"属性操作 标准属性 prop() 标准属性即为HTML标签中自带的一些常见属性。 如：id、class、的name、value、readonly、disabled等。 一言以蔽之，只要不是自定义的标签属性都被称之为标准属性。 prop()方法用于获取或者设置jQuery对象中DOM元素的标准属性与值。 一个参数：获取标准属性 两个参数：设置标准属性 一个字典：设置多个标准属性 示例如下： click me \"use strict\"; let $a = $(\"a\"); // 获取一个 console.log($a.prop(\"href\")); // 设置多个 console.log($a.prop( { href: \"http://www.google.com\", title: \"谷歌搜索\", target: \"_self\", } )); 特征属性 attr() 特征属性即我们为HTML标签自定义的一些属性。 一言以蔽之，只要不是自带的标签属性都被称之为特征属性。 attr()方法用于获取或者设置jQuery对象中DOM元素的特征属性与值。 一个参数：获取特征属性 两个参数：设置特征属性 一个字典：设置多个特征属性 示例如下： click me \"use strict\"; let $a = $(\"a\"); // 获取一个 console.log($a.attr(\"help\")); // 设置多个 console.log($a.attr( { help: \"help message\", fontSize: \"32px\" } )); 删除属性 removeAttr() removeAttr()方法用于删除jQuery对象中DOM元素的一个标准或特征属性，被删除的属性值将被置为undefined： click me \"use strict\"; let $a = $(\"a\"); // 删除标准属性 $a.removeAttr(\"href\"); $a.removeAttr(\"title\"); $a.removeAttr(\"target\"); // 删除特征属性 $a.removeAttr(\"help\"); $a.removeAttr(\"fontSize\"); 特征属性集 data() 我们自定义的特征属性在某些时候很容易和标准属性名字发生冲突。 针对这种情况，我们只需要在特征属性定义时前面加上data-的前缀即可。 要获取这些特征属性时，可直接通过$(selector).data()属性集进行获取。 通过属性集去获取特征属性时，忽略data-的前缀 仅能进行获取，不能进行设置，即使设置完成后也将不会被DOM渲染到标签上，但是属性集会进行更新 示例如下： click me \"use strict\"; let $a = $(\"a\"); // 设置一个特征属性集中的属性 $a.data(\"help\", \"help message\"); // 设置多个特征属性集中的属性 $a.data( { \"help\": \"i can help you\", \"font-size\": \"32px\" } ) // 获取一个特征属性集中的属性 console.log($a.data(\"help\")); // i can help you // 获取所有特征属性集中的属性 console.log($a.data()); // {help: \"i can help you\", fontSize: \"32px\"} // 属性集虽然更新了，但DOM节点元素本身并不会更新属性： // click me // 所以jQuery的data()方法仅能获取属性集中的特征属性，不要去进行设置，因为设置了也没用 removeData() 删除属性集中的一个属性。 不能是在HTML文档上设置的特征属性，必须由data()所设置。 click me \"use strict\"; let $a = $(\"a\"); // 目前的a标签属性集包括自带的：help和font-size console.log($a.data()); // {fontSize: \"2rem\", help: \"帮助信息\"} // 自己设置一个，它将不会被DOM渲染到标签上 $a.data(\"set\", \"attribute\"); console.log($a.data()); // {fontSize: \"2rem\", help: \"帮助信息\", set: \"attribute\"} // 只能删除自己设置的，不能删除自带的，即使你删除了自带的，也不会被DOM渲染到标签上 $a.removeData(\"set\"); $a.removeData(\"font-size\"); console.log($a.data()); // {help: \"帮助信息\"} // click me 节点内容 html() 获取或设置jQuery对象DOM元素中的HTML内容，并且也可以向标签中添加HTML内容，同时触发浏览器的解析器重绘DOM。 与JavaSctip中的innerHTML属性效果相同。 没有参数：获取内容 一个参数：设置内容 如下所示： HELLO WORLD \"use strict\"; // 获取 console.log($(\"main\").html()); // HELLO WORLD // 设置 $(\"main\").html(\"HELLO WORLD\") text() 获取或设置jQuery对象DOM元素中的文本内容，并且也可以向标签中添加文本内容，同时触发浏览器的解析器重绘DOM。 与JavaSctip中的innerText属性效果相同。 没有参数：获取内容 一个参数：设置内容 如下所示： HELLO WORLD \"use strict\"; // 获取 console.log($(\"main\").text()); // HELLO WORLD // 设置 $(\"main\").text(\"HELLO JavaScript\") 表单内容 val() 获取或设置jQuery对象DOM元素（常指input）的value值： 没有参数：获取value值 一个参数：设置value值 如下所示： \"use strict\"; // 设置 $(\":text\").val(\"learn\") // 获取 console.log($(\":text\").val()); // learn Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-08-17 18:35:30 "},"前端专栏/jQuery/文档操作.html":{"url":"前端专栏/jQuery/文档操作.html","title":"文档操作","keywords":"","body":"创建标签 $() 使用$()可创建出一个DOM元素，它将返回一个jQuery对象。 支持标签的嵌套创建 支持属性、内容的定义 如果创建的标签没有内容，且是闭合标签，则可以不用写后面的闭合部分 示例演示： \"use strict\"; // 1.支持标签的嵌套创建，支持属性、内容的定义 let $elements = $( ` HELLO WORLD ` ); // 2.如果创建的标签没有内容，且是闭合标签，则可以不用写后面的闭合部分 let $div = $(\"\"); console.log($elements); console.log($div); // jQuery.fn.init [main.demo] // jQuery.fn.init [div] 子级插入 prepend() 向jQuery对象中的每一个DOM元素内部的末尾插入新的内容，返回新的jQuery对象。。 let $div = $(\"\"); let $main = $(\"main\"); $main.prepend($div); console.log($main.get(0)); /* */ append() 向jQuery对象中的每一个DOM元素内部的开头插入新的内容，返回新的jQuery对象。。 let $div = $(\"\"); let $main = $(\"main\"); $main.append($div); console.log($main.get(0)); /* */ prependTo() 将新的内容插入至jQuery对象中的每一个DOM元素内部的末尾，返回新的jQuery对象。 注意与prepend()的区别： prepend()：在A的内部插入B prependTo()：把B插入至A的内部 如下所示： let $div = $(\"\"); let $main = $(\"main\"); $div.prependTo($main); console.log($main.get(0)); /* */ appendTo() 将新的内容插入至jQuery对象中的每一个DOM元素内部的开头，返回新的jQuery对象。 注意与append()的区别： append()：在A的内部插入B appendTo()：把B插入至A的内部 如下所示： let $div = $(\"\"); let $main = $(\"main\"); $div.appendTo($main); console.log($main.get(0)); /* */ 同级插入 before() 向jQuery对象中的每一个DOM元素同级的前面插入新的内容，返回新的jQuery对象。 let $div = $(\"\"); let $main = $(\"main\"); $main.before($div); /* */ after() 向jQuery对象中的每一个DOM元素同级的后面插入新的内容，返回新的jQuery对象。 let $div = $(\"\"); let $main = $(\"main\"); $main.after($div); /* */ insterBefer() 将新的内容插入至jQuery对象中的每一个DOM元素同级的前面，返回新的jQuery对象。 注意与befer()的区别： befer()：在A的前面插入B insterBeferTo()：把B插入至A的前面 如下所示： let $div = $(\"\"); let $main = $(\"main\"); $div.insertBefore($main); /* */ insertAfter() 将新的内容插入至jQuery对象中的每一个DOM元素同级的后面，返回新的jQuery对象。 注意与after()的区别： after()：在A的后面插入B insterAfterTo()：把B插入至A的后面 如下所示： let $div = $(\"\"); let $main = $(\"main\"); $div.insertAfter($main); /* */ 外部包裹 wrap() 将jQuery对象中的每一个标签外部包裹上另一个标签： HELLO HELLO HELLO let $span = $(\"span\"); $span.wrap(\"\"); /* HELLO HELLO HELLO */ wrapAll() 将jQuery对象中的所有标签外部包裹上另一个标签： HELLO HELLO HELLO let $span = $(\"span\"); $span.wrapAll(\"\"); /* HELLO HELLO HELLO */ wrapInner() 将每一个匹配的元素的内容（包括文本节点）用一个HTML结构包裹起来： HELLO HELLO HELLO let $span = $(\"span\"); $span.wrapInner(\"\") /* HELLO HELLO HELLO */ 外部移除 unwrap() 将jQuery对象中的每一个标签外部父级标签进行移除： HELLO HELLO HELLO let $span = $(\"span\"); $span.unwrap(); /* HELLO HELLO HELLO */ 替换操作 replaceWith() 将jQuery对象中的每一个标签替换为任意元素，可以是文本，也可以是标签： HELLO HELLO HELLO let $span = $(\"span\"); $span.replaceWith(`文本${$span.html()}文本`); /* 文本HELLO文本 文本HELLO文本 文本HELLO文本 */ replaceAll() 用一个任意元素，可以是文本将jQuery对象中的每一个标签替换： 注意与replaceWith()的区别： replaceWith()：把A替换为B replaceAll()：用B来替换A 如下所示： HELLO HELLO HELLO let $span = $(\"span\"); let $mark = $(`${$span.html()}`); $mark.replaceAll($span); /* HELLO HELLO HELLO */ 删除操作 empty() 删除jQuery对象中每个元素的子节点（不会删除自己），这个只属于清空操作。 HELLO HELLO HELLO let $span = $(\"span\"); $span.empty(); /* */ remove() 删除jQuery对象中的元素（连同自己和子类一同删除）。 HELLO HELLO HELLO let $span = $(\"span\"); $span.remove(); /* */ detach() 删除HTML文档中的标签元素，但会保留jQuery对象中的元素。 因为将来有可能再用到，保留所有子级标签，事件绑定，属性等。 HELLO HELLO HELLO let $span = $(\"span\"); $span.detach(); // 依旧保留jQuery对象中的元素，而remove()是全部删除干净 console.log($span); // S.fn.init(3) [span, span, span, prevObject: S.fn.init(1)] /* */ 克隆拷贝 clone() 用于拷贝节点，与JavaScript中的cloneNode()效果相同。 参数为true时会递归复制子节点即深拷贝，包括将原标签的事件等也一同进行拷贝。 function show(ele, jQevent) { ele.style.backgroundColor = \"blue\"; document.body.append($(\"div\").eq(0).clone(true).get(0)); } // 必须要取出单独DOM元素，否则每次都会成倍添加。 // 第一次 2个 第二次 4个 第三次 8个 // 因为jQuery对象是一个集合，而不是单独元素，每一次的克隆都会对jQuery对象进行遍历克隆。所以会成倍添加 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-08-19 13:27:56 "},"前端专栏/jQuery/样式操作.html":{"url":"前端专栏/jQuery/样式操作.html","title":"样式操作","keywords":"","body":"单一样式 css() CSS()方法用于获取或者设置jQuery对象中DOM元素的style。 一个参数：获取某个样式 两个参数：设置某个样式 一个字典：设置多个样式 注意，如果样式名称由多个单词组成，在设置或者获取的时候对样式名称的书写可以使用驼峰式，也可使用分割式，如： backgourndColor background-color 示例如下： main { font-size: 1rem; background-color: #ff0000; } main element \"use strict\"; let $main = $(\"main\"); // 获取一个 console.log($main.css(\"background-color\")); // 设置一个 $main.css(\"background-color\", \"#aaa\"); // 设置多个 $main.css({ \"font-size\": \"2rem\", \"border\": \"1px solid #ddd\", \"box-shadow\": \"rgba(100, 100, 100, .5) 10px 10px 5px\" }); 批量样式 hasClass() 检测jQuery对象中的任意一个DOM元素是否具有某一个class，返回boolean类型。 .demo { background: #ff0000; } 1 2 \"use strict\"; let $div = $(\"div\"); console.log($div.hasClass(\"demo\")); // true addClass() 统一为jQuery对象中的DOM元素添加一个或多个class： .demo { background: #ff0000; } 1 2 \"use strict\"; let $div = $(\"div\"); // 添加一个class $div.addClass(\"learn\"); // 添加多个class $div.addClass(\"jQ focus\"); // 1 // 2 removeClass() 统一为jQuery对象中的DOM元素删除一个或多个class： .demo { background: #ff0000; } 1 2 \"use strict\"; let $div = $(\"div\"); // 删除一个class $div.removeClass(\"demo\"); // 删除多个class $div.removeClass(\"learn jQ focus\"); // 1 // 2 toggleClass() 检测jQuery中的DOM元素里某个class属性是否存在。 如果存在、则删除掉该class 如果不存在，则添加该class .demo { background: #ff0000; } no have class demo no have class demo \"use strict\"; let $div = $(\"div\"); $div.on(\"click\", jQevent => { let $ele = $(jQevent.target); $ele.toggleClass(\"demo\"); $ele.hasClass(\"demo\") ? $ele.text(\"add class demo\") : $ele.text(\"remove class demo\"); }); Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-08-19 13:26:48 "},"前端专栏/jQuery/事件操作.html":{"url":"前端专栏/jQuery/事件操作.html","title":"事件操作","keywords":"","body":"事件对象 jQevent jQuery中的事件对象和原生JavaScript中的事件对象有所不同，它是在原生事件对象的基础上做了一次封装。 所以在绑定回调函数的参数上更推荐使用jQevent这个形参名来接收jQuery事件对象，而不是使用event。 属性方法 以下是jQevent中可调用的属性，仅例举常见属性： 属性 描述 jQevent.type 该属性保存此次事件的类型 jQevent.target 该属性指向引起本次事件发生的源对象 jQevent.currentTarget 该属性指向当前正在执行事件处理的对象 jQevent.timeStamp 该属性保存事件发生时的时间 jQevent.result 该属性保存最后一个回调函数的返回结果 jQevent.pageX 针对鼠标事件、鼠标相对于文档X轴的位置 jQevent.pageY 针对鼠标事件、鼠标相对于文档Y轴的位置 jQevent.which 针对键鼠事件、获取按下的按键编号 以下是jQevent中可调用的方法，仅例举常见方法： 方法 描述 jQevent.preventDefault() 阻止默认事件 jQevent.isDefaultPrevented() 判断是否阻止了默认事件 jQevent.stopPropagation() 阻止事件的冒泡传递 jQevent.isPropagationStopped() 判断是否阻止了事件的冒泡传递 jQevent.stopImmediatePropagation() 阻止事件的传播及冒泡 jQevent.isImmediatePropagationStopped() 判断是否阻止了事件的传播及冒泡 两者区别： jQevent.stopPropagation()：防止事件冒泡到DOM树上，也就是不触发的任何父级元素上的事件处理函数 jQevent.stopImmediatePropagation()：阻止剩余相同事件的处理函数执行，并且防止事件冒泡到DOM树上 如果有疑问，请前往JavaScript中Event操作查看详情。 事件监听 常用事件 以下例举常见的可用于监听的事件。 事件 描述 ready 文档准备就绪。不需要等待外部资源的加载 resize 浏览器窗口调整时 click 鼠标左键单击（同时触发mousedown以及mouseup） dblclick 鼠标左键双击 mousedown 鼠标左键、右键按下 mouseup 鼠标左键、右键松开 mouseover 鼠标移入时 mousemove 鼠标移动时 mouseout 鼠标移出时 mouseenter 鼠标移入时，不产生冒泡行为 copy 拷贝时 scroll 滚动时 focus 元素获取焦点后触发 blur 元素失去焦点后触发 input 元素内容发生改变后触发 click 单击了某个表单项 change 元素内容发生改变并且失去焦点时触发 submit 提交表单时触发 keydown 按下某个键、长按时将重复触发 keyup 松开某个键 keypress 按下并松开某个键、长按时将重复触发 on() 委托绑定 我们可以使用on()方法绑定事件的处理程序，它不仅仅可以为自身做绑定，也可以为未来元素做事件委托。 同addEventListener()方法一样，jQuery.fn.on()方法允许对同一个元素监听多次相同的事件 注意this指向问题，如果处理程序的回调函数是普通函数，那么this指向事件源jQevent.target，如果处理程序的回调函数是箭头函数，那么this指向undefined，此时可使用jQevent.target来指向事件源对象 如果我们的jQuery对象中有多个DOM元素，那么一次事件监听将作用到所有的DOM元素身上。 1）普通的事件绑定： ul li { margin-top: 1rem; height: 20px; width: 200px; background: #ddd; } \"use strict\"; let $li = $(\"ul li\"); // 绑定的元素 监听的事件 回调函数 $li.on(\"click\", jQevent => { let r = Math.floor(Math.random() * (255 + 1)); let g = Math.floor(Math.random() * (255 + 1)); let b = Math.floor(Math.random() * (255 + 1)); let a = Math.random().toFixed(1); $(jQevent.target).css(\"background\", `rgba(${r},${g},${b},${a})`); }); 2）为未来元素进行事件的委托代理： ul li { margin-top: 1rem; height: 20px; width: 200px; background: #ddd; } \"use strict\"; let $ul = $(\"ul\"); // 委托的元素 代理的事件 事件目标 事件目标的回调函数 $ul.on(\"click\", \"li\", jQevent => { let r = Math.floor(Math.random() * (255 + 1)); let g = Math.floor(Math.random() * (255 + 1)); let b = Math.floor(Math.random() * (255 + 1)); let a = Math.random().toFixed(1); $(jQevent.target).css(\"background\", `rgba(${r},${g},${b},${a})`); }); off() 解除绑定 使用off()方法解除被监听的或者被委托的事件。 1）解绑监听事件： ul li { margin-top: 1rem; height: 20px; width: 200px; background: #ddd; } Cancel binding \"use strict\"; let $li = $(\"ul li\"); let $btn = $(\"button\"); // 绑定的元素 监听的事件 回调函数 $li.on(\"click\", jQevent => { let r = Math.floor(Math.random() * (255 + 1)); let g = Math.floor(Math.random() * (255 + 1)); let b = Math.floor(Math.random() * (255 + 1)); let a = Math.random().toFixed(1); $(jQevent.target).css(\"background\", `rgba(${r},${g},${b},${a})`); }); $btn.on(\"click\", jQevent => { $li.off(\"click\"); }) 2）解除委托事件 ul li { margin-top: 1rem; height: 20px; width: 200px; background: #ddd; } Cancel binding \"use strict\"; let $ul = $(\"ul\"); let $btn = $(\"button\"); // 委托的元素 代理的事件 事件目标 事件目标的回调函数 $ul.on(\"click\", \"li\", jQevent => { let r = Math.floor(Math.random() * (255 + 1)); let g = Math.floor(Math.random() * (255 + 1)); let b = Math.floor(Math.random() * (255 + 1)); let a = Math.random().toFixed(1); $(jQevent.target).css(\"background\", `rgba(${r},${g},${b},${a})`); }); $btn.on(\"click\", jQevent => { $ul.off(\"click\", \"li\"); }) 其他绑定 方法示例 下面的这些接口不太常用，了解即可： 接口名称 描述 bind() 单独绑定，不支持事件代理 one() 绑定一次性事件，不支持事件代理 toggle() 用于绑定多个事件处理函数，在事件触发时依次执处理函数 trigger() 主动触发某个事件，它会触发默认行为与冒泡行为 triggerHandler() 主动触发某个事件，它不会触发默认行为与冒泡行为 bind() 以下示例将展示使用单独绑定根据点击来改变元素随机色： div { background-color: red; color: white; height: 100px; width: 100px; text-align: center; line-height: 100px; cursor: pointer; } 点我随机变色 \"use strict\"; $(\"div\").bind(\"click\", function (jQevent) { const r = Math.floor(Math.random() * (255 + 1)); const g = Math.floor(Math.random() * (255 + 1)); const b = Math.floor(Math.random() * (255 + 1)); const a = Math.random().toFixed(1); this.style.backgroundColor = `rgba(${r},${g},${b},${a})`; }); one() 以下示例将展示使用单次绑定第一次点击时改变元素随机色： div { background-color: red; color: white; height: 100px; width: 100px; text-align: center; line-height: 100px; cursor: pointer; } 点我随机变色 \"use strict\"; $(\"div\").one(\"click\", function (jQevent) { const r = Math.floor(Math.random() * (255 + 1)); const g = Math.floor(Math.random() * (255 + 1)); const b = Math.floor(Math.random() * (255 + 1)); const a = Math.random().toFixed(1); this.style.backgroundColor = `rgba(${r},${g},${b},${a})`; }); trigger() 以下示例将展示使用trigger()使input获得焦点，并且输入内容： 它不会阻止默认行为的发生 它不会阻止冒泡行为的传递 也就是说，当你点击按钮的时候，它会执行浏览默认的动作，也会执行你为input:focus绑定的动作。 所以你会观察到、先获取焦点、再改变了input的value值。 示例如下： get focus \"use strict\"; let $btn = $(\"button\"); let $input = $(\"input\"); $btn.on(\"click\", jQevent => { $input.eq(0).trigger(\"focus\"); }); $input.on(\"focus\", jQevent=>{ jQevent.target.value = \"OK\"; }); triggerHandler() 以下示例将展示使用triggerHandler()使input获得焦点，并且输入内容： 它将阻止默认行为的发生 它将阻止冒泡行为的传递 也就是说，当你点击按钮的时候，它不会执行浏览默认的动作，只会执行你为input:focus绑定的动作。 所以你会观察到、它不会获取焦点、而是直接改变input的value值。 示例如下： get focus \"use strict\"; let $btn = $(\"button\"); let $input = $(\"input\"); $btn.on(\"click\", jQevent => { $input.eq(0).triggerHandler(\"focus\"); }); $input.on(\"focus\", jQevent=>{ jQevent.target.value = \"OK\"; }); 入口函数 完整写法 jQuery的入口函数window.ready相当于window.addEventListener(\"DOMContentLoaded\", fn) 。 该事件会在文档解析完成时触发，它不需要等待所有外部资源加载完成。 而原生JavaScript中的window.onload(fn)则会等待所有外部资源加载完成后才触发。 如下所示： \"use strict\"; $(window).ready(function (jQevet) { console.log(\"文档加载完成\"); }); 简便写法 简写形式： \"use strict\"; $((jQevet) => { console.log(\"文档加载完成\"); }) Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-08-19 13:25:04 "},"前端专栏/jQuery/空间坐标.html":{"url":"前端专栏/jQuery/空间坐标.html","title":"空间坐标","keywords":"","body":"位置获取 视口位置 offset()方法可用于获取或者设置当前元素位于视口中的距离。 * { padding: 0; margin: 0; } div { width: 100px; height: 100px; border: 1px solid #ddd; transform: translate3d(100px, 100px, 0); } \"use strict\"; // 设置 $(\"div\").offset( { top: 120, left: 200 } ) // 获取 console.log($(\"div\").offset()); // {top: 120, left: 200} 父级位置 position()方法可用于获取当前元素对于已定位的父级元素的位置信息。ew56666 main { height: 400px; width: 400px; border: 1px solid #ddd; position: relative; } main div { height: 200px; width: 200px; border: 1px solid #eee; position: absolute; top: 20px; left: 20px; height: 20px; } \"use strict\"; // 获取 console.log( $(\"main div\").position() ); // {top: 20, left: 20} 元素尺寸 height() \\ width() height()和width()方法用于获取元素内容区域的宽高： div { height: 100px; width: 100px; padding: 5px; border: 5px solid #5da; } \"use strict\"; console.log( \"\".concat(\"height:\", $(\"div\").height(), \"px \", \"width:\", $(\"div\").width(), \"px\") ); // height:100px width:100px innerHeight() \\ innerWidth() innerHeight()和innerWidth()方法用于获取元素内容区域以及内边距之内的补白区域的宽高： div { height: 100px; width: 100px; padding: 5px; border: 5px solid #5da; } \"use strict\"; console.log( \"\".concat(\"innerHeight:\", $(\"div\").innerHeight(), \"px \", \"innerWidth:\", $(\"div\").innerWidth(), \"px\") ); // innerHeight:110px innerWidth:110px outerHeight() \\ outerWidth() outerHeight()和outerWidth()方法用于获取元素内容区域以及内边距之内的补白区域和边框区域的宽高： div { height: 100px; width: 100px; padding: 5px; border: 5px solid #5da; } \"use strict\"; console.log( \"\".concat(\"outerHeight:\", $(\"div\").outerHeight(), \"px \", \"outerWidth:\", $(\"div\").outerWidth(), \"px\") ); // outerHeight:120px outerWidth:120px 滚动条相关 scrollTop() 获取或设置当前对象的纵向滚动条的位置： main { height: 200px; width: 200px; overflow: scroll; border: 1px solid #ddd; } main div { height: 1000px; width: 1000px; background: linear-gradient(90deg, #feac5e 0%, #c779d0 50%, #4bc0c8 100%); } \"use strict\"; let x = $(\"main\").scrollLeft(); let y = $(\"main\").scrollTop(); setInterval(() => { x += 50; y += 50; // 每一秒X轴滚动条向右移动50 $(\"main\").scrollLeft(x); // 每一秒Y轴滚动条向下移动50 $(\"main\").scrollTop(y); }, 1000); scroolLeft() 获取或设置当前对象的横向滚动条的位置： main { height: 200px; width: 200px; overflow: scroll; border: 1px solid #ddd; } main div { height: 1000px; width: 1000px; background: linear-gradient(90deg, #feac5e 0%, #c779d0 50%, #4bc0c8 100%); } \"use strict\"; let x = $(\"main\").scrollLeft(); let y = $(\"main\").scrollTop(); setInterval(() => { x += 50; y += 50; // 每一秒X轴滚动条向右移动50 $(\"main\").scrollLeft(x); // 每一秒Y轴滚动条向下移动50 $(\"main\").scrollTop(y); }, 1000); Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-08-19 21:36:16 "},"前端专栏/jQuery/动画效果.html":{"url":"前端专栏/jQuery/动画效果.html","title":"动画效果","keywords":"","body":"基本效果 show()\\hide() 从左上角开始，向右下方渐变的进行显示和隐藏。 show()：显示 hide()：隐藏 参数释义： duration：动画执行完成所需的总毫秒数 complete：动画执行完毕后的回调函数 注意，元素隐藏后，是不占据文档流空间位置的，同级排列在后的元素会进行跟进补白。 示例如下： body div:nth-child(2) { margin-top: 1rem; } hide \"use strict\"; let $div = $(\"div\").eq(0); let $btn = $(\"div button\"); $btn.on(\"click\", event => { if ($btn.text() === \"hide\") { $div.hide(1000, () => { $btn.text(\"show\"); }) } else { $div.show(1000, () => { $btn.text(\"hide\"); }) } }) slideDown()\\slideUp() 自上而下渐变的进行显示和隐藏。 slideDown()：显示 slideUp()：隐藏 参数释义： duration：动画执行完成所需的总毫秒数 complete：动画执行完毕后的回调函数 注意，元素隐藏后，是不占据文档流空间位置的，同级排列在后的元素会进行跟进补白。 示例如下： body div:nth-child(2) { margin-top: 1rem; } slideUp \"use strict\"; let $div = $(\"div\").eq(0); let $btn = $(\"div button\"); $btn.on(\"click\", event => { if ($btn.text() === \"slideUp\") { $div.slideUp(1000, () => { $btn.text(\"slideDown\"); }) } else { $div.slideDown(1000, () => { $btn.text(\"slideUp\"); }) } }) slideToggle() 如果元素已隐藏，就显示，如果已显示，就隐藏。 它的表现效果和slideDown()&slideUp()相同。 参数释义： duration：动画执行完成所需的总毫秒数 complete：动画执行完毕后的回调函数 注意，元素隐藏后，是不占据文档流空间位置的，同级排列在后的元素会进行跟进补白。 如下所示： body div:nth-child(2) { margin-top: 1rem; } slideToggle-hide \"use strict\"; let $div = $(\"div\").eq(0); let $btn = $(\"div button\"); $btn.on(\"click\", event => { $div.slideToggle(1000, () => { $btn.text() === \"slideToggle-hide\" ? $btn.text(\"slideToggle-show\") : $btn.text(\"slideToggle-hide\"); }) }) 淡入淡出 fadeIn()\\fadeOut() 渐变的改变元素透明度，实现淡入淡出效果。 fadeIn()：透明度渐变为100%，即淡入 fadeOut()：透明度渐变为0%，即淡出 参数释义： duration：动画执行完成所需的总毫秒数 complete：动画执行完毕后的回调函数 注意，元素透明度为100%后，是不占据文档流空间位置的，同级排列在后的元素会进行跟进补白。 示例如下： body div:nth-child(2) { margin-top: 1rem; } fadeIn \"use strict\"; let $div = $(\"div\").eq(0); let $btn = $(\"div button\"); $btn.on(\"click\", event => { if ($btn.text() === \"fadeIn\") { $div.fadeIn(1000, () => { $btn.text(\"fadeOut\"); }) } else { $div.fadeOut(1000, () => { $btn.text(\"fadeIn\"); }) } }) fadeToggle() 如果元素已淡出，就淡入，如果已淡入，就淡出。 它的表现效果和fadeIn()&fadeOut()相同。 参数释义： duration：动画执行完成所需的总毫秒数 complete：动画执行完毕后的回调函数 注意，元素透明度为100%后，是不占据文档流空间位置的，同级排列在后的元素会进行跟进补白。 示例如下： body div:nth-child(2) { margin-top: 1rem; } fadeToggle-out \"use strict\"; let $div = $(\"div\").eq(0); let $btn = $(\"div button\"); $btn.on(\"click\", event => { $div.fadeToggle(1000, () => { $btn.text() === \"fadeToggle-out\" ? $btn.text(\"fadeToggle-in\") : $btn.text(\"fadeToggle-out\"); }) }) 自定义动画 animate() 使用animate()可对元素设置自定义动画。 参数释义： properties：一个Object，接收CSS自定义的CSS样式 duration：动画执行完成所需的总毫秒数 complete：动画执行完毕后的回调函数 示例如下： main { width: 250px; height: 250px; border: 1px solid #ddd; border-radius: 50%; position: relative; } \"use strict\"; setInterval(() => { let h = Math.floor(Math.random() * 256) + \"px\"; let w = Math.floor(Math.random() * 256) + \"px\"; let bw = Math.floor(Math.random() * 20) + \"px\"; $(\"main\").animate( // 动画执行后的最终样式 // border-width这种分割线形式的要变成小驼峰形式进行书写 { \"width\": w, \"height\": h, \"borderWidth\": bw }, // 动画执行时间 1000, // 动画执行完成后的回调函数 () => { console.log(\"callback run\"); }); }, 1000) Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-08-20 19:45:42 "},"前端专栏/jQuery/插件扩展.html":{"url":"前端专栏/jQuery/插件扩展.html","title":"插件扩展","keywords":"","body":"$的扩展 $.extend()用于为jQuery本身做扩展。 比如我们书写了一个插件，就可以使用$.extend()方法来合并该插件。 合并后的插件仅有$或者jQuery本身能够调用，jQuery的实例对象不能进行调用。 简而言之，jQuery.extend()相当于书写一个新的类方法，我们都知道类方法仅能由类本身调用： \"use strict\"; // 编写功能 function carousel() { console.log(\"generate carousel image\"); }; // 相当于jQuery.carousel = carousel $.extend({ carousel }); // 后续只有$或者jQuery能够调用该方法 $.carousel(); jQuery.carousel(); jQuery实例对象的扩展 jQuery.fn指向jQuery的原型，它里面存储的方法均能被jQuery实例对象所调用。 我们如果对jQuery.fn使用extend()方法，那么后续的jQuery实例对象都能够使用该方法，但jQuery对象本身不能使用。 简而言之，jQuery.fn.extend()相当于书写一个新的实例方法，我们都知道实例方法仅能由实例调用： 1 2 3 \"use strict\"; // 编写功能 function every(callback) { // this指向jQuery实例对象 for (let i = 0; i { return element.classList.contains(\"demo\"); }); console.log(result); Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-08-21 13:50:36 "},"前端专栏/jQuery/网络请求.html":{"url":"前端专栏/jQuery/网络请求.html","title":"网络请求","keywords":"","body":"后端代码 jQuery中的Ajax是对XmlHttpRequest的一层高级封装，使其使用更加简单。 为了方便后续前后端交互的代码测试，我们后端采用Python-flask框架来完成。 IP：localhost PORT：5700 代码如下： from flask import Flask from flask import request from flask import make_response from flask import jsonify app = Flask(__name__) @app.after_request # 解决CORS跨域请求 def cors(response): response.headers['Access-Control-Allow-Origin'] = \"*\" if request.method == \"OPTIONS\": # 允许的请求头 response.headers[\"Access-Control-Allow-Headers\"] = \"Origin,Content-Type,Cookie,Accept,Token,authorization,user_head\" return response @app.route(\"/get\", methods=[\"get\"]) def get(): user_head = request.headers.get(\"user_head\") user_params = request.args print(user_params) return jsonify(user_params, user_head) @app.route(\"/post\", methods=[\"post\"]) def post(): user_head = request.headers.get(\"user_head\") user_params = request.form print(user_params) return jsonify(user_params, user_head) @app.route(\"/json\", methods=[\"post\"]) def json(): user_head = request.headers.get(\"user_head\") user_params = request.json return jsonify(user_params, user_head) @app.route(\"/file\", methods=[\"post\"]) def file(): file_obj = request.files.get(\"avatar\") if file_obj is None: return make_response(jsonify(\"unload avatar\"), 400) file_name = file_obj.filename file_obj.save(file_name) return jsonify(\"upload avatar success!!\") if __name__ == \"__main__\": app.run(host=\"localhost\", port=5700, debug=True) 基本使用 以下是基本使用： $.ajax({ url: \"http://localhost:5700/get\", method: \"GET\", dataType: \"JSON\", headers: { \"user_head\": \"Hello World\" }, data: { name: \"Jack\", age: 18, gender: \"male\" }, success: (data, textStatus) => { console.log(\"成功\"); console.log(data); console.log(textStatus); }, error: (jqXHR, textStatus) => { console.log(\"失败\"); console.log(jqXHR); console.log(textStatus); }, complete: (jqXHR, textStatus) => { console.log(\"总是执行\"); console.log(jqXHR); console.log(textStatus); }, }) 参数释义： url：请求的地址 method：请求的方式，亦可使用type来进行定义 dataType：是否对后端返回的数据做JSON反序列化处理 headers：需要定制的请求头 data：需要发送的内容 success：请求成功后自动执行的回调函数 error：请求失败后自动执行的回调函数 complete：无论请求成功或者失败后都会执行自动执行的回调函数 在使用时的注意事项： 仅支持上传k-v的对象，不支持上传数组（仅针对非JSON数据格式的发送） 前端上传的数据中，不允许出现对象对象嵌套的形式。如{\"k1\":{\"k1-1\":v1}}，这样只会得到{“k1” : “object”} 如果前端传递的对象中键是一个Array，如 {\"k1\":[1, 2, 3, 4]} 则需要添加一个属性 traditional:true，否则后端将接收不到该参数。（实际上接受的时候要使用request.POST.get(\"k1[]\")）来进行接受，这是有问题的 jQuery.ajax在发送一次网络请求时，可指定以下5个回调钩子函数，它们会在适当的时候自动执行： beforeSend 在发送请求之前调用，并且传入一个XMLHttpRequest作为参数 dataFilter 在请求成功之后调用。传入返回的数据以及\"dataType\"参数的值。并且必须返回新的数据（可能是处理过的）传递给success回调函数，也就是说它会在success与error之前调用 success 在请求成功之后调用。传入返回后的数据，以及包含成功代码的字符串 error 在请求出错时调用。传入XMLHttpRequest对象，描述错误类型的字符串以及一个异常对象（如果有的话） complete 当请求完成之后调用这个函数，无论成功或失败。传入XMLHttpRequest对象，以及一个包含成功或错误代码的字符串 发送JSON JSON格式的数据只能由POST请求发起，除此之外还需要手动指定contentType为application/json和手动的对上传数据进行序列化。 如果你发送JSON格式的数据，是支持上传数组格式的数据的： $.ajax({ url: \"http://localhost:5700/json\", method: \"POST\", // 必须是POST dataType: \"JSON\", headers: { \"user_head\": \"Hello World\" }, contentType: \"application/json\", // 1.手动指定请求头中contentType的格式 data: JSON.stringify([1, 2, 3, 4, 5]), // 2.手动的对上传数据进行JSON序列化 success: (data, textStatus) => { console.log(\"成功\"); console.log(data); console.log(textStatus); }, error: (xhr, textStatus) => { console.log(\"失败\"); console.log(xhr); console.log(textStatus); }, complete: (xhr, textStatus) => { console.log(\"总是执行,此处可获取响应头\"); console.log(xhr); console.log(textStatus); } }) 获取表单 针对form表单提交的数据，我们可以使用jQuery对象的serialize()和serializeArray()方法。 serialize()：提取form表单中的数据项，并对其做url编码处理，返回一个字符串，注意，它不会提取文件选择框 serializeArray()：提取form表单中的数据，并将其构建为一个name：value的数组，注意，它不会提取文件选择框，最终格式为 [{name : “attribute”, value : “input”}, {name : “attribute”, value : “input”}] 示例如下，如果是serialize()则直接提交即可： 用户名 密码 男 女 篮球 足球 排球 城市 北京 上海 深圳 上传头像 提交 document.querySelector(\"button\").addEventListener(\"click\", (event) => { $.ajax({ url: \"http://localhost:5700/post\", method: \"POST\", headers: { \"user_head\": \"Hello World\" }, data: $(\"#register\").serialize(), dataType: \"JSON\", success: (data, textStatus) => { console.log(\"成功\"); console.log(data); console.log(textStatus); }, error: (xhr, textStatus) => { console.log(\"失败\"); console.log(xhr); console.log(textStatus); }, complete: (xhr, textStatus) => { console.log(\"总是执行,此处可获取响应头\"); console.log(xhr); console.log(textStatus); } }) console.log($(\"#register\").serialize()); // username=%E4%BA%91%E5%B4%96&password=123&gender=male&hobby=basketball&hobby=football&city=shanghai&city=shenzhen }) 如果是serializeArray()，需要使用appliction/json的方式进行提交，因为该方法返回的是一个数组： 用户名 密码 男 女 篮球 足球 排球 城市 北京 上海 深圳 上传头像 提交 document.querySelector(\"button\").addEventListener(\"click\", (event) => { $.ajax({ url: \"http://localhost:5700/json\", method: \"POST\", headers: { \"user_head\": \"Hello World\" }, contentType: \"application/json\", // 1.手动指定请求头中contentType的格式 data: JSON.stringify($(\"#register\").serializeArray()), // 2.手动的对上传数据进行JSON序列化 dataType: \"JSON\", success: (data, textStatus) => { console.log(\"成功\"); console.log(data); console.log(textStatus); }, error: (xhr, textStatus) => { console.log(\"失败\"); console.log(xhr); console.log(textStatus); }, complete: (xhr, textStatus) => { console.log(\"总是执行,此处可获取响应头\"); console.log(xhr); console.log(textStatus); } }) console.log($(\"#register\").serializeArray()); // Array(7) // 0: {name: \"username\", value: \"云崖\"} // 1: {name: \"password\", value: \"123\"} // 2: {name: \"gender\", value: \"male\"} // 3: {name: \"hobby\", value: \"basketball\"} // 4: {name: \"hobby\", value: \"football\"} // 5: {name: \"city\", value: \"shanghai\"} // 6: {name: \"city\", value: \"shenzhen\"} }) 发送文件 如果要发送文件，我们需要借助FormData对象进行数据提交，以下是注意事项。 在表单中上传文件，必须要将enctype设置为multipart/form-data。 但是在使用Ajax上传文件时，并不需要指定contentType为multipart/form-data，所以不添加contentType请求头。 contentType应设置为false，即不使用任何数据格式，不使用任何编码 processData应设置为false，不让浏览器做任何数据格式的编码 示例如下，我们使用FormData搭配serializeArray()方法实现一个真正意义上的异步提交表单： 用户名 密码 男 女 篮球 足球 排球 城市 北京 上海 深圳 上传头像 提交 document.querySelector(\"button\").addEventListener(\"click\", (event) => { // 获取上传的文件对象 let $fileNode = $(\"#avatar\"); let fileObj = $fileNode.get(0).files[0]; // 使用FormData用于伪造form表单提交的数据 let fd = new FormData(); // 添加文件 fd.append($fileNode.prop(\"name\"), fileObj); // 添加其他表单项 $(\"#register\").serializeArray().forEach((obj, index, array) => { fd.append(obj.name, obj.value); }); // 发送json格式数据 $.ajax({ url: \"http://localhost:5700/file\", method: \"POST\", headers: { \"user_head\": \"Hello World\" }, data: fd, // 直接发送ForData对象即可 dataType: \"JSON\", contentType: false, // 必须设置为false processData: false, // 必须设置为false success: (data, textStatus) => { console.log(\"成功\"); console.log(data); console.log(textStatus); }, error: (xhr, textStatus) => { console.log(\"失败\"); console.log(xhr); console.log(textStatus); }, complete: (xhr, textStatus) => { console.log(\"总是执行,此处可获取响应头\"); console.log(xhr); console.log(textStatus); } }) }) JSONP 如果你不了解JSONP，那么请参照JavaScript一章节中所介绍的JSONP相关知识。 jQuery中也对JSONP做好了封装，使用非常简单： click me \"use strict\"; let $btn = $(\"button\"); let $span = $(\"p span\") $btn.on(\"click\", (event) => { $.ajax({ url: \"http://localhost:5700/\", type: \"GET\", dataType: \"JSONP\", // 指定是一次JSONP的响应 jsonp: \"callback\", // 指定回调函数 }) }) function callbackfn(result) { $span.text(result); } 后端代码如下： from logging import debug, error from flask import Flask import random app = Flask(__name__) @app.route(rule=\"/\", methods=[\"GET\"], strict_slashes=False) def publicAPI(): number = random.randint(1, 100) return f\"callbackfn({number})\" if __name__ == \"__main__\": app.run(host=\"localhost\", port=5700, debug=True) 运行结果： Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-08-21 15:15:02 "},"前端专栏/TypeScript/summary.html":{"url":"前端专栏/TypeScript/summary.html","title":"TypeScript","keywords":"","body":" 基本介绍 类型相关 配置文件 面向对象 抽象基类 定义接口 泛型介绍 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-09-01 13:50:10 "},"前端专栏/TypeScript/基本介绍.html":{"url":"前端专栏/TypeScript/基本介绍.html","title":"基本介绍","keywords":"","body":"基础介绍 语言介绍 TypeScript出生名门，由大名鼎鼎的微软公司于2012年10月首次公开发布0.8版本。 它是一门基于JavaScript的静态、弱类型的扩展语言，在TypeScript中有一句非常出名的话，叫做TypeScript是JavaScript的一个超集。 这意味着，熟悉JavaScript的人不难上手TypeScript，你甚至可以将它理解为一个更优秀的JavaScript。 为什么要学习TypeScript？我之前也有过这种困惑，直至vue 3.x的发布坚定了我要学习它的想法。 众所周知，JavaScript是一门非常“随便”的语言，Thanks for inventing JavaScript这张图甚至可以排列到编程领域最出名的图片TOP10，由于JavaScript的随便，故项目后期的维护会变的非常困难。撸码一时爽，维护火葬场，几乎所有用过动态类型语言的程序员都会发出这种感叹。 在此环境下，微软公司推出了TypeScript、它相较于JavaScript增加了类型限制、类型检查、类型批注、类型推断、接口、枚举、元组、泛型、命名空间等特性，大大增强了项目的可维护性。 TypeScript的学习成本几乎可以忽略不计，如果你掌握了JavaScript并且接触过某些静态语言，如Java、Golang等，那么上手他将变得十分迅速。 发展历史 以下是TypeScript发展中的历史大事件： 2012-10：微软发布了 TypeScript 第一个版本（0.8），此前已经在微软内部开发了两年。 2014-04：TypeScript 发布了 1.0 版本。 2014-10：Angular 发布了 2.0 版本，它是一个基于 TypeScript 开发的前端框架。 2015-01：ts-loader 发布，webpack 可以编译 TypeScript 文件了。 2015-04：微软发布了 Visual Studio Code，它内置了对 TypeScript 语言的支持，它自身也是用 TypeScript 开发的。 2016-05：@types/react 发布，TypeScript 可以开发 React 应用了。 2016-05：@types/node 发布，TypeScript 可以开发 Node.js 应用了。 2016-09：TypeScript 发布了 2.0 版本。 2018-06：TypeScript 发布了 3.0 版本。 2019-02：TypeScript 宣布由官方团队来维护 typescript-eslint，以支持在 TypeScript 文件中运行 ESLint 检查。 2020-05：Deno 发布了 1.0 版本，它是一个 JavaScript 和 TypeScript 运行时。 2020-08：TypeScript 发布了 4.0 版本。 2020-09：Vue 发布了 3.0 版本，Vue 官方开始支持 TypeScript。 发展趋势 TypeScript适用于大型项目，虽然JavaScript拥有严格模式static，但它相较于TypeScript来说还是比较稀松的，TypeScript由于加入了类型限制，故可以规避掉很多由JavaScript语言特性所带来的坑。 从vue 3.x的发布可以看出TypeScript是未来前端发展的一个必然趋势，从Stack Overflow上看，TypeScript成为前端领域2021年最受欢迎的脚本编程语言，甚至已经远远的将JavaScript甩在了后面： Ts & Js TypeScript是基于JavaScript的，它会通过一个编译器将TypeScript代码编译为JavaScript代码，然后再交由JavaScript解析器进行解析和渲染。 默认情况下TypeScript编译器以ECMAScript 3（ES3）为目标，这意味着经过编译后的JavaScript代码为ES3标准，后续你也可以对其编译出的Js版本进行修改配置。 运行于任何平台上的任何网页浏览器都可以运行TypeScript。由于它仅仅是被编译为标准的JavaScript，一个脚本既可以被预编译为JavaScript，也可以通过为TypeScript包含JavaScript编译器实时编译。 Ts小结 什么是 TypeScript？ TypeScript 是添加了类型系统的 JavaScript，适用于任何规模的项目 TypeScript 是一门静态类型、弱类型的语言 TypeScript 是完全兼容 JavaScript 的，它不会修改 JavaScript 运行时的特性 TypeScript 可以编译为 JavaScript，然后运行在浏览器、Node.js 等任何能运行 JavaScript 的环境中 TypeScript 拥有很多编译选项，类型检查的严格程度由你决定 TypeScript 可以和 JavaScript 共存，这意味着 JavaScript 项目能够渐进式的迁移到 TypeScript TypeScript 增强了编辑器（IDE）的功能，提供了代码补全、接口提示、跳转到定义、代码重构等能力 TypeScript 拥有活跃的社区，大多数常用的第三方库都提供了类型声明 TypeScript 与标准同步发展，符合最新的 ECMAScript 标准（stage 3） 简单使用 安装node TypeScript的编译器基于Node.js开发，因此第一步你需要下载Node.js。 官方网站 下载完安装包后基本无脑下一步即可，直至安装完成后使用以下代码测试Node.js是否成功安装： $ node -v 下载TypeScript 接下来我们需要基于Node.js的npm来安装TypeScript，输入以下命令即可： $ npm -g install typescript 它会在全局环境中安装tsc命令，在安装完成后，只需输入tsc命令即可查看到一些TypeScript所提供的功能选项： $ tsc 现在让我们新建一个文件，以.ts结尾，在其中输入你的TypeScript代码： console.log(\"hello world\"); 可以发现我们输入的是JavaScript代码，这样做并不会有任何问题，因为TypeScript是JavaScript的一个超集。 编译JavaScript 下面，打开终端后输入以下命令即可，即可将TypeScript代码编译为JavaScript代码： $ tsc yourTypeScriptFilePath.ts 它会生成一个同名文件，但是以.js为后缀名结束的，后续你可以在文档中引入该JavaScript脚本文件。 使用ts-node 如果我们想直接运行TypeScript文件，则可以先下载一个ts-node，然后通过ts-node来直接运行TypeScript文件。 $ npm -g install ts-node 下载完成后你需要在当前ts项目根目录中新建tsconfig.json文件，并填入以下内容，以便支持console.log的打印： { \"compilerOptions\": { \"lib\": [ \"es6\", \"dom\", ], } } 使用ts-node运行ts文件： $ ts-node yourTypeScriptFilePath.ts Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-08-25 21:37:10 "},"前端专栏/TypeScript/类型相关.html":{"url":"前端专栏/TypeScript/类型相关.html","title":"类型相关","keywords":"","body":"类型声明 类型声明是静态语言的一大特性，同时也是TypeScript优于JavaScript最重要的一个点。 我们都知道，JavaScript是动态类型的语言，所谓动态就是指变量的类型是不确定的，是根据值的变化而变化的。 如果将变量比作一个房间，值比作一个人，那么就会出现一个很形象的比喻： JavaScript中的房间本身是没有任何限制的，不管是男生还是女生都可以入住，因此房间的属性是随入驻人员的性别变化而变化的 TypeScript中的房间是有限制的，如一个房间只能让女生住或者让男生住，因此房间在一开始投入使用时就有了严格的规范，不会根据入驻人员性别变化而变化 在TypeScript中，如何声明一个变量的类型？语法如下： let 变量 : 类型; // 仅声明 let 变量 : 类型 = 值; // 声明并赋值 这两者非常常用，如下所示我们声明了一个变量，它必须存入boolean类型的值： let bool: boolean; bool = true; 若后续值发生改变，新的值也必须是boolean类型，否则将出现编译错误： let bool: boolean; bool = \"string\"; // error TS2322: Type 'string' is not assignable to type 'boolean'. 基本类型 boolean 1）使用boolean定义一个布尔类型的变量，它只能存储boolean类型的值： let bool: boolean; bool = true; 2）注意，new Boolean()返回的是一个Boolean对象，并不是一个boolean类型的值，所以编译会出错： let bool: boolean; bool = new Boolean(1); // error TS2322: Type 'Boolean' is not assignable to type 'boolean'. // 'boolean' is a primitive, but 'Boolean' is a wrapper object. Prefer using 'boolean' when possible. 3）直接使用Boolean()是行得通的，因为它会返回一个boolean类型的值： let bool: boolean; bool = Boolean(\"string\"); number 1）使用number定义一个数值类型的变量，它只能存储number类型的值： let binaryLiteral: number = 0b1010; // 二进制 let octalLiteral: number = 0; // 八进制 let decLiteral: number = 10; // 十进制 let hexLiteral: number = 0xf00d; // 十六进制 let notANumber: number = NaN; // 非数字 let infinityNumber: number = Infinity; // 无穷大 let floatNumber: number = 3.14; // 浮点数 2）注意，new Number()返回的是一个Number对象，并不是一个number类型的值，所以编译会出错： let binaryLiteral: number = new Number(0b1010); // error TS2322: Type 'Number' is not assignable to type 'number'. // 'number' is a primitive, but 'Number' is a wrapper object. Prefer using 'number' when possible. 3）直接使用Number()是行得通的，因为它会返回一个number类型的值： let binaryLiteral: number = Number(\"0b1010\"); string 1）使用string定义一个字符串类型的变量，它只能存储string类型的值：： // 普通字符串 let userName: string = \"Jack\"; let userAge: number = 25; // 模板字符串 let userMessage: string = `my name is ${userName}\\nmy years old is${userAge}`; 2）注意，new String()返回的是一个String对象，并不是一个string类型的值，所以编译会出错： let userName: string = new String(\"Jack\"); // error TS2322: Type 'String' is not assignable to type 'string'. // 'string' is a primitive, but 'String' is a wrapper object. Prefer using 'string' when possible. 3）直接使用String()是行得通的，因为它会返回一个string类型的值： let userName: string = String([\"Jack\"]); null和undefined 1）使用null或者undefined定义空的、未表示的变量： let u: undefined = undefined; let n: null = null; 2）null和undefined是所有类型的子类型，也就是说这2种类型的值可以赋给任意类型的变量，这样做并不会产生编译错误： let u: number = undefined; let n: string = null; 引用类型 Array JavaScript中的数组能够存入任意类型的值，这在实际开发中是很少用到的，它可能降低数组的查找性能。 因此TypeScript中规定了数组在使用时，仅能存入同一个类型的值。 1）通过类型+方括号的形式来表示一个数组： let numberAry: number[]; numberAry = [1, 2, 3, 4, 5]; let strAry: string[]; strAry = [\"A\", \"B\", \"C\", \"D\"]; 2）我们也可以使用数组泛型（Array geneic）的形式来表示一个数组： let numberAry: Array; numberAry = [1, 2, 3, 4, 5]; let strAry: Array; strAry = [\"A\", \"B\", \"C\", \"D\"]; 3）下面是二维数组的表示： let ary: Array; ary = [[1, 2, 3], [4, 5, 6]]; let ary2:number[][]; ary2 = [[1, 2, 3], [4, 5, 6]]; 函数 JavaScript中函数形参数量和实参传入数量是没有任何限制的，你可以少传参数、也可以多传参数，这在TypeScript中是绝对不允许的。 1）TypeScript中允许对函数参数和返回值做出限制，如下所示，x和y所接收的参数必须是number类型，并且将返回一个number类型： function func(x: number, y: number): number { return x + y } 2）TypeScript中还可以使用函数表达式形式来表示一个函数，如下所示，注意不要将其与ES6中的箭头函数搞混了，=>number指的是该函数必须返回一个number类型： let func: (x: number, y: number) => number = function (x, y) { return x + y }; 3）有一些参数我们不确定需不需要每次都必须传递，因此可以在该参数后面加上?号，代表可选参数，可选参数必须在位置参数的后面： function func(x: number, y: number, z?: number): number { return z ? x + y + z : x + y } console.log(func(11, 22)); console.log(func(11, 22, 33)); // 33 // 66 4）ES6中的默认参数在TypeScript中依旧被支持，如下所示： function func(x: number, y: number, z: number = 33): number { return x + y + z } console.log(func(11, 22)); console.log(func(11, 22, 44)); // 66 // 77 5）ES6中的…扩展参数在TypeScript中也依旧被支持，如下所示： // 注意，args将是一个数组 function func(x: number, y: number, ...args: any[]): string { return `x : ${x}\\ny : ${y}\\nargs : ${args}` } console.log(func(1, 2, \"A\", \"B\", \"C\")); // x : 1 // y : 2 // args : A,B,C 对象 TypeScript中的对象用{}来进行表示，你可以规定对象中属性的名称以及属性值的类型。 1）使用{}定义对象，该对象中必须包含属性userName、userAge、getInfo： let userObject: { userName: string, userAge: number, getInfo: () => string }; userObject = { userName: \"Jack\", userAge: 18, getInfo: function() { return `name : ${this.userName}\\nage : ${this.userAge}` } } console.log(userObject.getInfo()); // name : Jack // age : 18 2）一些属性并不是必须要包含的，可以使用?将其变为可选： let userObject: { userName: string, userAge: number, hobby?: string[] }; userObject = {userName : \"Jack\", userAge : 19, hobby : [\"Basketball\", \"Football\", \"Volleyball\"]}; userObject = {userName : \"Ken\", userAge : 18}; 3）某些时候我们不确定一个对象中有哪些属性，因此可以使用[attrName: string] : any来表示所有出现的属性，其中[attrName: string]代表可以出现无限多的属性、any代表这些可能会出现的属性的值可以是任意类型： // 必须包含userName和userAge属性、其他的属性随意 let userObject: { userName: string, userAge: number, [attrName: string]: any }; userObject = { userName: \"Jack\", userAge: 19, gender: 1, city: \"BeiJing\" }; userObject = { userName: \"Ken\", userAge: 18 }; 4）使用readonly来定义只读属性，只读属性一经赋值后便不允许再次更改： let userObject: { userName: string, userAge: number, readonly userGender : string }; userObject = { userName: \"Jack\", userAge: 19, userGender: \"male\"}; userObject.userGender = \"female\"; // error TS2540: Cannot assign to 'userGender' because it is a read-only property. TypeScript独有类型 any any可以定义一个允许存储任意类型的变量，后续该变量在修改值时即使类型不同也不会出现编译错误。 1）定义一个能够存储任意类型的数组： let ary: any[] = [1, \"A\", new Map([[\"k1\", \"v1\"], [\"k2\", \"v2\"]])]; 2）变量如果在声明时未指定类型，它将默认识别为any类型： let o; o = 1; o = \"string\"; // 等价于 let o: any; o = 1; o = \"string\"; 3）o的类型是any，它可以将值间接赋给其他任意类型的变量： let o: any = 1; let s: string = o; console.log(s); console.log(typeof s); // 1 // number unknown unknown代表是存储了未知值类型的变量，后续修改值时即使类型不同也不会出现编译错误。但是一个unknown类型的变量不支持间接将值赋给其他类型的变量。 1）unknown同any类似，可以存储任意类型的值，并不会出现编译错误的情况： let un: unknown; un = 1; un = \"string\"; un = function (x: number, y: number): number { return x + y }; 2）但它不允许进行间接赋值操作，而any是允许的，故可以将unknown认为是一个安全的any，： let un: unknown = 1; let s: string = un; // error TS2322: Type 'unknown' is not assignable to type 'string'. union types 联合类型（Union types）代表该变量可被赋予众多选项类型或值中的任意一种。 1）多种类型的设置、使用|分割每种待选的类型： let sn: number | string; sn = 1; sn = \"string\"; 2）多种值的设置、使用|分割每个待选的值（不建议使用，更推荐使用enum枚举）： let gender: \"male\" | \"female\"; gender = \"male\"; gender = \"female\"; enum 枚举（Enum）代表了一种类型，该类型提供了众多值可供用户选择。 1）基本的使用，枚举类型中的值总是从0开始计数： enum Gender { male, // 0 female, // 1 unknown, // 2 } let userMessage: { userName: string, userAge: number, userGender: Gender }; userMessage = { userName: \"Jack\", userAge: 18, userGender: Gender.male }; // userGender = 0 console.log(userMessage); // { userName: 'Jack', userAge: 18, userGender: 0 } 2）自定义枚举类型中的生成值，如1男2女3未知更符合大多数人的思维： enum Gender { male = 1, female = 2, unknown = 3, } let userMessage: { userName: string, userAge: number, userGender: Gender }; userMessage = { userName: \"Jack\", userAge: 18, userGender: Gender.male }; // userGender = 1 console.log(userMessage); // { userName: 'Jack', userAge: 18, userGender: 1 } 3）枚举类型的实现原理，以下是经过编译后的JavaScript文件： var Gender; (function (Gender) { Gender[Gender[\"male\"] = 1] = \"male\"; Gender[Gender[\"female\"] = 2] = \"female\"; Gender[Gender[\"unknown\"] = 3] = \"unknown\"; })(Gender || (Gender = {})); var userMessage; userMessage = { userName: \"Jack\", userAge: 18, userGender: Gender.male }; // userGender = 1 console.log(userMessage); /* Gender： { '1': 'male', '2': 'female', '3': 'unknown', male: 1, female: 2, unknown: 3 } */ void void代表一个必须存储空值的变量，该变量仅能存储null和undefined。 void常用于表示一个没有返回值的函数： function func(ary: string[]): void { for (let i = 65; i never never代表一个永远没有值的变量，该变量不能存储任何值。 never常用于表示一个绝对会抛出异常的函数： function func(): never { throw new Error(\"error\"); } func(); tuple TypeScript中的数组中通常只会存放一种类型，并且数组的长度不是固定的。 而元组（Tuple）可以存放多种类型，且在定义时长度必须固定，后续不可进行修改，你可以理解为元组是一个不可变的数组，这句话不适用于Python但非常适用于TypeScript。 1）通过方括号包裹类型的形式来表示一个元组： let tpl: [number, string, number]; tpl = [1, \"string\", -1]; 2）不建议对元组使用push()等方法，虽然说这样是可行的但违背了元组这个数据类型出现的初衷。当push()时，元组定义的类型将变更为联合类型，这意味着你只能push()进number或者string类型的值： let tpl: [number, string, number]; tpl = [1, \"string\", -1]; // 不建议对元组进行修改 tpl.push(...[\"A\", \"B\", \"C\"]); console.log(tpl); // [ 1, 'string', -1, 'A', 'B', 'C' ] 其他知识 类型推导 如果一个变量在定义时没有指定类型，但是赋值了，TypeScript会自动对其进行类型推导： let ary = [1, 2, 3]; // 等价于 // let ary: array = [1, 2, 3]; console.log(ary instanceof Array); // true 注意与any的区别，any是在变量定义时没有指定类型并且没有赋值的时候才会出现： let o; // 等价于 // let o: any; o = 1; o = \"string\"; 类型断言 类型断言常用于联合类型或者any类型的判定中，在某些时候我们需要判断这个变量的具体类型时就可以使用类型断言。 使用方式是 变量 as 类型，如果断言不准确将会抛出异常，如果断言准确将会返回1，如下所示： let x: number | string; x = 1; x as number; // 会执行 console.log(\"x typeof number!\"); 如果类型断言不准确，将会抛出异常： let x: number | string; x = 1; x as string; // error TS2352: Conversion of type 'number' to type 'string' may be a mistake because neither type sufficiently overlaps with the other. If this was intentional, convert the expression to 'unknown' first. // 不会执行 console.log(\"x typeof number!\"); 注意，如果断言一个变量类型是any或者unknown，那么它将永远是成功的： let x: number | string; x = 1; x as any; console.log(\"x typeof any !\"); x as unknown; console.log(\"x typeof unknown !\"); x as string; // 不执行 console.log(\"x typeof string !\"); 类型别名 使用type为类型取一个别名，这样做方便了重复定义相同类型的变量： // 二维数组 type TwoDimensionArray = Array; let ary1: TwoDimensionArray; // 实际上就是指向 Array; ary1 = [[1, 2, 3], [4, 5, 6]]; let ary2: TwoDimensionArray; ary2 = [[7, 8, 9], [10, 11, 12]]; 内置对象 ECMAScript中提供的内置对象在TypeScript中也是支持定义的。 如：Boolean对象，Error对象、Date对象、RegExp对象等： let b: Boolean = new Boolean(1); let e: Error = new Error('Error occurred'); let d: Date = new Date(); let r: RegExp = /[a-z]/; 更多的内置对象，可以查看 MDN 的文档。 而他们的定义文件，则在 TypeScript 核心库的定义文件中。 除此之外，DOM和BOM中提供的内置对象在TypeScript中也是能够进行定义的。 如：document、HTMLElement、Event、NodeList、HTMLCollection等： let body: HTMLElement = document.body; let allDiv: NodeList = document.querySelectorAll('div'); document.addEventListener('click', function(e: MouseEvent) { // Do something }); Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-08-31 15:22:30 "},"前端专栏/TypeScript/配置文件.html":{"url":"前端专栏/TypeScript/配置文件.html","title":"配置文件","keywords":"","body":"项目目录 一个最基本的TypeScript项目，应当包含2个目录与一个文件： ./TypeScript/ ├── dist ├── src └── tsconfig.json dist：存放编译后的JavaScript脚本文件 src：存放源代码TypeScript脚本文件 tsconfig.json：存放TypeScript编译时所采用的配置文件 tsc编译命令 获取帮助 使用tsc --help命令获取帮助。以下例举常用选项： --init：在当前目录下自动创建一个tsconfig.json文件 -h：获得tsc命令的帮助信息 -w：观察被输入的ts文件，当有内容变更时它将自动完成编译 -v：打印编译器的版本信息 整个tsc命令可跟上的可选参数非常多，但这些参数我们都可以将它配置在tsconfig.json文件中，避免每次需要编译时的重复输入。 编译单个文件 在项目中使用以下命令来编译单个文件： $ tsc ./src/fileName.ts 编译完成后的js文件会位于被编译的ts文件目录下，也就是src目录中： ./TypeScript/ ├── dist ├── src │ ├── demo1.js │ └── demo1.ts └── tsconfig.json 编译整个项目 若直接使用tsc命令，它将编译该项目中所有的ts文件。 $ tsc 编译完成后的js文件会位于被编译的ts文件目录下，也就是src目录中： ./TypeScript/ ├── dist ├── src │ ├── demo1.js │ ├── demo1.ts │ ├── demo2.js │ ├── demo2.ts │ ├── demo3.js │ └── demo3.ts └── tsconfig.json 自动进行编译 如果你使用了tsc -w命令，它将开始检测当前项目中所有ts文件内容的改动，若有ts文件内容发生变更则将自动的进行编译。 $ tsc -w tsconfig.json 基本介绍 tsconfig.json是TypeScript文件在使用tsc命令编译时所依赖的配置文件。 它的内容格式为JSON，但是这个JSON格式文件中可以利用//来输入注释，这是与其他的JSON配置文件不同的地方。 我们可以在项目根目录下使用tsc --init命令来生成该文件，或者你可以选择手动创建该文件。 以下是我自己的配置文件，在下面会对配置项进行详细说明： { \"include\": [ \"./src/**/*\", // 仅编译src目录下的所有ts文件 ], \"exclude\": [ \"./src/test/**/*\", // 不编译src目录中test目录下所有的ts文件 ], \"compilerOptions\": { \"target\": \"ES6\", // 编译后生成的js版本为es6 \"module\": \"ES6\", // 模块使用规范为es6 \"lib\": [ // node环境中测试ts代码所需要使用的库 \"ES6\", \"DOM\" ], \"outDir\": \"./dist\", // 编译后生成的js文件存放路径 \"allowJs\": true, // 二次编译js文件 \"checkJs\": true, // 验证js文件语法 \"removeComments\": false, // 编译后的js文件删除注释信息 \"noEmitOnError\": true, // 如果编译时出现错误，编译将终止 \"strict\": true, // 启用TypeScript的严格模式 \"alwaysStrict\": true, // 启用JavaScript的严格模式 \"noFallthroughCasesInSwitch\": true, // 检测switch语句块是否正确的使用了break \"noImplicitReturns\": true, // 检测函数是否具有隐式的返回值 \"noUnusedLocals\": false, // 检测是否具有未使用的局部变量 \"noUnusedParameters\": false, // 检测是否具有未使用的函数参数 \"allowUnreachableCode\": true, // 检测是否具有永远不会运行的代码 } } 如果你想查看官方的说明，请移步官方文档 include 一级配置项，include。 在直接使用tsc命令编译整个项目的ts文件时，默认会将该项目下所有的以ts为后缀名的文件进行编译。 若指定了include，那么tsc命令则只编译指定目录下的ts文件： { \"include\": [ \"./src/**/*\", // 可跟上多个路径 ], } 默认：当前路径下所有的文件 **/* 路径：**代指所有目录，*代指所有文件 exclude 一级配置项，exclude。 指定不会被编译的文件目录： { \"exclude\": [ \"./src/test/**/*\", // 可跟上多个路径 ], } 默认值： [\"node_modules\", \"bower_components\", \"jspm_packages\", \"./dist\"] extends 一级配置项，extends。 使该配置文件继承某个配置文件中的配置项，一般情况下不会用到： { // \"extends\": \"/configs/base\", } files 一级配置项，files。 只编译指定的文件，只有在需要编译的文件较少时才会用到，一般情况下不会用到： { \"files\": [ \"./src/demo1.ts\", \"./src/demo2.ts\", ], } compilerOptions 一级配置项，compilerOptions。 它可以来指定编译器的选项，比如编译器编译后的js文件版本、编译器编译时所使用的模块化规范等等。 target 二级配置项，位于compilerOptions中。 用于指定ts文件编译为那个版本的js文件： { \"compilerOptions\": { \"target\": \"ES3\", } } 默认是ES3，你可以对其进行指定： \"ES3\", \"ES5\", \"ES6\", \"ES2015\", \"ES2016\", \"ES2017\", \"ES2018\", \"ES2019\", \"ES2020\", \"ES2021\", \"ESNext\" 释义： ES3：默认 ESNext：总是为最新的ECMAScript版本 module 二级配置项，位于compilerOptions中。 用于指定需要使用的模块化规范： { \"compilerOptions\": { \"module\": \"ES6\", } } 你可以指定的值如下所示： \"CommonJS\", \"AMD\", \"System\", \"UMD\", \"ES6\", \"ES2015\", \"ES2020\", \"ESNext\", \"None\" 推荐使用，ES6。 lib 二级配置项，位于compilerOptions中。 用于指定需要在项目中使用到的库： { \"compilerOptions\": { \"lib\": [ \"ES6\", \"DOM\" ], } } 一般情况下，如果在浏览器中直接进行代码测试的话，该配置项可以不选。 如果在node环境下，如在ts-node中进行代码测试时，通常需要指定加载DOM库，因为console系列的函数，包括document等都是由DOM库进行提供的，浏览器环境下这些库是内置的，而在node环境中，则没有这些库，所以需要我们手动加载。 outDir 二级配置项，位于compilerOptions中。 用于指定编译后文件所在的目录： { \"compilerOptions\": { \"outDir\": \"./dist\", } } 默认情况下编译后生成的js文件会和被编译的ts文件在同一个目录中，这是十分不理想的，而通过outDir的配置，能够让我们的项目层次结构更加分明，管理更加方便。 outFile 二级配置项，位于compilerOptions中。 用于指定将所有ts全局作用域下的代码编译到一个js文件中，默认是false： { \"compilerOptions\": { \"outFile\": \"./dist/all.js\", } } 如果配置了该选项，那么多个ts文件的代码会同时合并到一个js文件中，通常我们并不会这样进行设置。因为它可能导致一些意外情况的发生。 allowJs 二级配置项，位于compilerOptions中。 是否对js文件进行二次编译？默认为false： { \"compilerOptions\": { \"allowJs\": false, } } 也就是说，如果你没有写ts文件而是写了一个js文件，是否还需要重新生成一个js文件到指定的outDir目录中去？ 保持默认值即可。 checkJs 二级配置项，位于compilerOptions中。 检查js代码是否符合规范？默认为false： { \"compilerOptions\": { \"checkJs\": true, } } 建议修改为true。 removeComments 二级配置项，位于compilerOptions中。 是否在编译后的js文件中移除ts文件中的注释？默认为false： { \"compilerOptions\": { \"removeComments\": false, } } noEmit 二级配置项，位于compilerOptions中。 在编译完成后，需要禁止生成js文件吗？默认为false： { \"compilerOptions\": { \"noEmit\": false, } } 如果修改为true，则代表编译时仅验证ts语法是否正确，常用于测试中，不建议对其进行修改。 noEmitOnError 二级配置项，位于compilerOptions中。 在编译时，如果遇到错误，需要禁止生成js文件吗？默认为false： { \"compilerOptions\": { \"noEmitOnError\": true, } } 建议修改为true，也就是说你的ts代码有问题时将不会生成js文件。 strict 二级配置项，位于compilerOptions中。 是否采用TypeScript中的严格模式，如果为true，它将意味着alwaysStrict、noImplicitAny、noImplicitThis、strictNullChecks、strictBindCallApply、strictFunctionTypes、strictPropertyInitialization这些配置项均设置为true。 { \"compilerOptions\": { \"strict\": true, } } 推荐修改为true，良好的编码习惯是一个优秀的程序工程师所具备的基本素养。 alwaysStrict 二级配置项，位于compilerOptions中。 编译后的js文件是否开启严格模式？默认为false： { \"compilerOptions\": { \"alwaysStrict\": true, } } 推荐修改为true。 noImplicitAny 是否不允许ts代码中出现隐式的any类型？默认为false： { \"compilerOptions\": { \"noImplicitAny\": true, } } 推荐修改为true。 noImplicitThis 是否不允许ts代码中出现隐式的this使用？默认为false： { \"compilerOptions\": { \"noImplicitThis\": true, } } 推荐修改为true。 strictNullChecks 是否严格的检查ts代码中所出现的空值？默认为false： { \"compilerOptions\": { \"strictNullChecks\": true, } } 推荐修改为true。 strictFunctionTypes 是否严格的检查ts代码中函数类型？默认为false： { \"compilerOptions\": { \"strictFunctionTypes\": true, } } 推荐修改为true。 strictBindCallApply 是否严格的检查ts代码中bind、call和apply的参数列表？默认为false： { \"compilerOptions\": { \"strictBindCallApply\": true, } } 推荐修改为true。 strictPropertyInitialization 是否严格的检查ts代码中属性是否初始化？默认为false： { \"compilerOptions\": { \"strictPropertyInitialization\": true, } } 推荐修改为true。 noFallthroughCasesInSwitch 是否检查ts代码中switch是否包含了正确的break？默认为false： { \"compilerOptions\": { \"noFallthroughCasesInSwitch\": true, } } 推荐修改为true。 noImplicitReturns 是否检查ts代码中函数是否具有隐式的返回值？默认为false： { \"compilerOptions\": { \"noImplicitReturns\": true, } } 推荐修改为true。 noUnusedLocals 是否检查ts代码中具有未使用的局部变量？默认为false： { \"compilerOptions\": { \"noUnusedLocals\": true, } } 推荐修改为true。 noUnusedParameters 是否检查ts代码中具有未使用的函数参数？默认为false： { \"compilerOptions\": { \"noUnusedParameters\": true, } } 推荐修改为true。 allowUnreachableCode 是否检查ts代码中具有永远运行不到的代码？默认为false，它将忽略不可达的代码，如果为true时，不可达代码将引起异常： { \"compilerOptions\": { \"allowUnreachableCode\": true, } } 推荐修改为true。 allowSyntheticDefaultImports 允许对不包含默认导出的模块使用默认导入。这个选项不会影响生成的代码，只会影响类型检查。 { \"compilerOptions\": { \"allowSyntheticDefaultImports\": false, } } 默认是false，不建议进行修改。 这个选项很有意思，在ts中如果你要导入CommonJs的模块，向下面这样导入是最符合语法规范的： // CommonJs const http = require(\"http\") // EsMoudle import * as http from \"http\" 如果它为true，你可以直接这样进行导入： import http from \"http\" Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-10-05 21:40:48 "},"前端专栏/TypeScript/面向对象.html":{"url":"前端专栏/TypeScript/面向对象.html","title":"面向对象","keywords":"","body":"class 类的定义 我们直接开始介绍TypeScript中关于类的定义，其实它和JavaScript中差不多但是有一些差别。 我们先看JavaScript中的代码示例： \"use strict\"; class Person { constructor(name, age, gender) { this.name = name; this.age = age; this.gender = gender; } } 而TypeScript中由于变量具有类型，故在声明实例属性前必须先进行类型声明： enum UserGender { male = 1, female = 2, unknown = 3 } class Person { // 类型声明 public name: string; public age: number; public gender: UserGender; constructor(name: string, age: number, gender: UserGender) { this.name = name; this.age = age; this.gender = gender; } } public 公开属性 public指不受保护的、公开的属性。类的内部或外部及其子类均可访问或者修改该属性。 默认所有的属性都是public，使用public关键字定义公开属性即可，或者也可以不写： enum UserGender { male = 1, female = 2, unknown = 3 } class Person { // public可以不写，但是建议还是写上 public name: string; public age: number; public gender: UserGender; constructor(name: string, age: number, gender: UserGender) { this.name = name; this.age = age; this.gender = gender; } getInfo(): string { // ❶ 类的内部可以进行访问，也可以进行修改 return `name : ${this.name}\\nage : ${this.age}\\ngender : ${this.gender}` } setAge(age: number): void { this.age = age; } } let person = new Person(\"Jack\", 18, UserGender.male); // ❷ 类的外部也可以进行访问和修改 console.log(person.getInfo()); person.setAge(22); person.name = \"--Jack--\"; console.log(person.name); // ❸ 被继承的子类中也可以进行访问和修改 class Child extends Person { constructor(name: string, age: number, gender: UserGender) { super(name, age, gender) this.name = \"Mary\"; // 可以访问和修改 } } let child = new Child(\"Tom\", 12, UserGender.male); console.log(child.getInfo()); private 绝对私有 private指受保护的、私有的属性。仅能在当前类的内部访问或修改，外部的访问和修改是做不到的，但可通过类内部暴露的接口方法进行访问。 private属性经常与属性代理一起使用，使用private关键字定义私有属性即可： enum UserGender { male = 1, female = 2, unknown = 3 } class Person { // private必须写上 private name: string; private age: number; private gender: UserGender; constructor(name: string, age: number, gender: UserGender) { this.name = name; this.age = age; this.gender = gender; } getInfo(): string { // ❶ 类的内部可以进行访问，也可以进行修改 return `name : ${this.name}\\nage : ${this.age}\\ngender : ${this.gender}` } setAge(age: number): void { this.age = age; } } let person = new Person(\"Jack\", 18, UserGender.male); // ❷ 类的外部仅能通过类内部暴露的接口方法访问，直接访问是访问不到的 console.log(person.getInfo()); person.setAge(22); // person.name = \"--Jack--\"; // console.log(person.name); // ❸ 被继承的子类中不能进行访问和修改，但可以通过类内部暴露的接口方法进行访问和修改 class Child extends Person { constructor(name: string, age: number, gender: UserGender) { super(name, age, gender) // this.name = \"Mary\"; // 不可以访问和修改 抛出异常 } } let child = new Child(\"Tom\", 12, UserGender.male); console.log(child.getInfo()); child.setAge(10); protected 半私有的 protected是指受保护的，半私有的属性。仅能在类的内部访问和修改，外部的访问和修改是做不到的，但它允许在子类中进行访问和修改。 使用protected关键字定义半私有属性即可，注意半私有属性我们一般都会在它前面加上一个单下划线，表明这是一个半私有属性： enum UserGender { male = 1, female = 2, unknown = 3 } class Person { // protected必须写上 protected _name: string; protected _age: number; protected _gender: UserGender; constructor(name: string, age: number, gender: UserGender) { this._name = name; this._age = age; this._gender = gender; } getInfo(): string { // ❶ 类的内部可以进行访问，也可以进行修改 return `name : ${this._name}\\nage : ${this._age}\\ngender : ${this._gender}` } setAge(age: number): void { this._age = age; } } let person = new Person(\"Jack\", 18, UserGender.male); // ❷ 类的外部仅能通过类内部暴露的接口方法访问和修改，直接访问是访问不到的 console.log(person.getInfo()); person.setAge(22); // person._name = \"--Jack--\"; // console.log(person._name); // ❸ 被继承的子类中可以进行访问和修改 class Child extends Person { constructor(name: string, age: number, gender: UserGender) { super(name, age, gender) this._name = \"Mary\"; // 可以访问和修改 } } let child = new Child(\"Tom\", 12, UserGender.male); console.log(child.getInfo()); child.setAge(10); Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-08-23 21:38:32 "},"前端专栏/TypeScript/抽象基类.html":{"url":"前端专栏/TypeScript/抽象基类.html","title":"抽象基类","keywords":"","body":"抽象基类 抽象基类（abstract base class）是专门用来被其他类所继承的类，它智能被其他类所继承不能用来创建实例。 抽象基类的作用在于： 约束子类实现，子类必须实现抽象基类中的所有抽象方法才能被实例化，否则将不可被实例化 举个例子，羊（Sheep）和狼（Wolf）都属于哺乳类（Breastfeeding），那么它们都至少具有1个方法名为哺乳（feeding），如果没有该方法，则该类不能被实例化。 其实说白了，抽象基类的作用就是规范子类实现，所以： 抽象基类仅用于被继承，不必对其进行实例化 抽象基类内部方法不必实现 如何使用 我们可以使用abstract关键字定义抽象基类和抽象方法。 抽象方法没有方法实现，只有方法名，且它只能定义在抽象基类中，子类继承抽象基类时抽象方法必须要实现： abstract class Breastfeeding { // 定义抽象方法 abstract feeding(): void; } class Sheep extends Breastfeeding { // 子类必须实现抽象方法 feeding(): string { return \"sheep feeding\"; } } let ins = new Sheep(); console.log(ins.feeding()); Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-08-23 21:56:16 "},"前端专栏/TypeScript/定义接口.html":{"url":"前端专栏/TypeScript/定义接口.html","title":"定义接口","keywords":"","body":"认识接口 接口（interface）和抽象基类（abstract base class）是非常相似的。 抽象基类的作用是规范子类实现，而接口则是为了规范所有类的实现。 接口是针对所有类的实现的 接口规定了类的用途，举个例子，如果你这个类提供了支付方法和退款方法，那么就可以将其视为一个支付接口类，该类可用作支付功能，否则该类将不能用于支付功能 而抽象基类只是针对子类的实现的 抽象基类规定了子类的形状，你想继承我，就必须拥有我的一些特点，否则就不能算我的子类 接口使用 我们可以使用interface关键字定义一个接口。 定义接口时不需要实现具体的方法逻辑，而是只需要指定方法名即可，属性同理。 在实现接口时，可以使用implements来进行实现。 如下所示： // 定义接口 interface PayInterface { balance: number; // 余额 pay(target: string): void; // 支付 refund(target: string): void; // 退款 } // 实现接口 class OrangePay implements PayInterface { public balance: number; constructor(balance: number) { this.balance = balance; } pay(target: string): void { console.log(`Paying for the ${target}`); } refund(target: string): void { console.log(`Refund for the ${target}`); } } interface & type 接口和类型别名有些相似，接口也可以用来规定对象的属性组成，但是仅针对对象： enum UserGender { male = 1, female = 2, unknown = 3 } interface user { name: string; age: number; gender: UserGender; } let userMessage: user = { name: \"Jack\", age: 19, gender: UserGender.male } 它和类型别名的区别在于，类型别名一次只能定义一个，不能重名，而接口可以重名： enum UserGender { male = 1, female = 2, unknown = 3 } // user01已经定义了，不能在重复定义 type user02 = { name: string; age: number; gender: UserGender; hobby: Array; } // user02是接口，可以重复定义，它相当于将2个接口进行合并 interface user01 { name: string; age: number; gender: UserGender; } interface user01 { hobby: Array; } 个人推荐，对于类的实现使用接口、对于对象的实现使用类型别名。 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-08-24 13:18:46 "},"前端专栏/TypeScript/泛型介绍.html":{"url":"前端专栏/TypeScript/泛型介绍.html","title":"泛型介绍","keywords":"","body":"什么是泛型 在静态语言中，有一个非常重要的名词叫做泛型（Generic），泛型的意思就是指一个宽泛的类型。 比如我们的函数不确定要接收什么类型的值时，你可能想用any来进行参数接收，那么返回值也必定是any。 此时就会造成一个问题，使用者不明白这个返回的any到底是什么类型，any表示的范围太宽了，如下图所示，它的返回结果依旧还是any： 我们更想需要的是传入一个什么类型，就返回一个什么类型，但是返回的这个类型不是固定的，而是按照传入的参数类型变化而变化。 这个时候我们就可以使用泛型，泛型的定义如下所示，你需要为这个范围的类型取一个名字，如\\，那么返回值也必然是T： 泛型函数 定义泛型函数，你可以同时指定多个泛型，如下所示，当随机数为2时返回x，当随机数为1时返回y： function func(x: T, y: K): T | K { let n = Math.floor(Math.random() * 2) + 1; console.log(n); if (n == 2) { return x; } else { return y; } } 使用的时候，你可以不传入指定类型，而是让TypeScript编译器自动进行类型推导： let result = func(1, \"A\"); 更加推荐在使用时传入类型，这样在后期代码维护时更加的方便： let result = func(1, \"A\"); 泛型类 在类中也同样可以使用泛型，如下所示： class Demo{ public attribute: T; public property: K; constructor(attribute: T, property: K) { this.attribute = attribute; this.property = property; } } let ins1 = new Demo(100, []); let ins2 = new Demo(\"??\", {}); 泛型约束 除此之外，泛型也可以对具体类型进行严格的约束。 如下所示，泛型函数func collection必须传入一个具有length属性的对象： interface ContainerInterface { length: number; [key: string]: any } // 泛型T继承ContainerInterface接口，要求必须具有length属性 function Iterative(container: T): any[] { let ary = []; for (let i: number = 0; i ([\"A\", \"B\", \"C\"])); console.log(Iterative(document.querySelectorAll(\"main\"))); console.log(Iterative(document.getElementsByTagName(\"div\"))); 如果你传入了一个没有length属性的对象，它将引发错误： Iterative>(new Map([[\"k1\", \"v1\"], [\"k2\", \"v2\"]])) // 类型“Map”不满足约束“ContainerInterface”。 // 类型\"Map\"中缺少属性 \"length\"，但类型 \"ContainerInterface\" 中需要该属性 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-09-01 13:36:42 "},"前端专栏/Node.js/summary.html":{"url":"前端专栏/Node.js/summary.html","title":"Node.js","keywords":"","body":" 基础介绍 模块系统 包管理器 Ts+Node process 事件操作 定时器 路径处理 文件操作 Buffer Stream Web开发 Koa框架 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-10-09 17:23:12 "},"前端专栏/Node.js/模块系统.html":{"url":"前端专栏/Node.js/模块系统.html","title":"模块系统","keywords":"","body":"CommonJS 基本介绍 JavaScript这门语言最早是单纯的为网页添加行为功能而问世的，所以在诞生之初并没有模块这一个概念。 到了ES6之后，JavaScript提供了module语法用于组织模块关系。 而在ES6之前，最主要的模块解决方案为CommonJS和AMD两种，由于Node.js的出现早于ES6，故其模块解决方案采用了CommonJs，它主要遵从以下3个原则： 一个文件被视为一个模块、文件内变量的作用域均在模块内 使用module.exports对象导出模块中的功能，对外暴露接口 使用require引入其他模块 在Node.js中，模块文件仅限于： js文件 JSON文件 编译过的C/C++ 扩展文件 除此之外的文件均不被认为是模块文件。 模块分类 在Node.js中模块的分类主要有3大类： 内置模块：Node.js自带的 自定义模块：自己编写的文件 第三方模块：npm命令下载的 Node.js对于内置模块或者第三方模块来说，在导入时并不需要加入任何路径，直接书写模块名即可。 而对于第三方模块而言，在导入时需要加入文件所在路径，除此之外，如果是JSON文件则还需要添加上.json的后缀，而JavaScript脚本文件则不用添加这种后缀。 基本使用 目录展示 以下是代码demo的目录展示： . ├── main.js # 导入模块的文件 ├── moduleJson.json # 自定义模块文件 └── moduleScript.js # 自定义模块文件 module.exports module.exports拥有3种导出模块的方式，如下所示。 1）一个一个的导出： // moduleScript.js let moduleName = __filename; function area(w, h) { return w * h; } module.exports.moduleName = moduleName; module.exports.area = area; 2）使用默认导出，一个模块中只能有一个默认导出： // moduleScript.js module.exports = function area(w, h) { return w * h; } 3）使用多个导出： // moduleScript.js let moduleName = __filename; function area(w, h) { return w * h; } module.exports = { moduleName, area }; 除此之外，你也可以省略module.exports的前缀module，直接使用exports进行导出，但是个人不建议这么做，因为它不支持多个导出的方式，只能支持一个一个导出或者默认导出，如下所示： // moduleScript.js let moduleName = __filename; function area(w, h) { return w * h; } exports.moduleName = moduleName; exports.area = area; 具体原因是因为exports本身指向了module.exports对象，如果将exports赋值了一个新的对象，那么它将和module.exports失去链接关系、而require()则只会导入module.exports对象中的属性。 require 使用require()来导入模块中被导出的功能，它其实是moudle.require()的简写形式，但使用简写形式并不会有任何问题。 1）导入整个模块，针对一个个的导出和多个导出，在使用其下功能时需要加上模块名字： // main.js const m1 = require(\"./moduleScript\"); console.log(m1.area(2, 2)); console.log(m1.moduleName); 2）导入默认导出的功能，直接使用接收的名字对功能进行调用即可，仅针对默认导出： // main.js const area = require(\"./moduleScript\"); console.log(area(2, 2)); 导入JSON 我们先在JSON文件中输入内容： // moduleJson.js { \"userName\": \"Jack\", \"userAge\": \"18\", \"userGender\": \"male\" } 然后在main.js中进行导入： // main.js const userMessage = require(\"./moduleJson.json\"); for (let [k, v] of Object.entries(userMessage)) { console.log(k, \":\", v); } // userName : Jack // userAge : 18 // userGender : male 可以发现，被导入的JSON文件变成了一个Object。 导入内置模块 以下示例将演示如何导入内置模块http，在导入内置模块或者第三方模块时，并不需要输入模块路径： const http = require('http'); const server = http.createServer((request, response) => { response.setHeader('Content-Type', 'application/json'); response.statusCode = 200; response.end(JSON.stringify(request.method === \"GET\" ? \"GET OK!!!\" : \"POST OK!!!\")); }) server.listen(5700, \"localhost\", 256, () => { console.log(\"server running success! http://localhost:3000\"); }); 模块搜索路径 Node.js中每一个文件都是一个模块，模块内的变量均属于局部变量，故不会出现全局变量污染的问题。 在执行模块代码前，Node.js会使用如下的一个函数封装器将模块进行封装： (function(exports, require, module, __filename, __dirname) { // 模块的代码实际上在这里 }); 参数释义： exports：加载其他模块的方法，指向了module.exports对象 require：导出模块功能的方法，执行了module.require对象 module：当前模块的实例 __filename：当前模块文件的绝对路径 __dirname：当前模块文件所在目录的绝对路径 在搜索一个模块时，如果出现多个导入模块同名的情况下，Node.js会优先导入内置或第三方模块。 这与模块的搜索路径有关，它会根据module.paths所提供的路径进行搜索，如下所示： > module.paths [ '/Users/yunya/Project/nodeProject/repl/node_modules', '/Users/yunya/Project/nodeProject/node_modules', '/Users/yunya/Project/node_modules', '/Users/yunya/node_modules', '/Users/node_modules', '/node_modules', '/Users/yunya/.node_modules', '/Users/yunya/.node_libraries', '/Users/yunya/.nvm/versions/node/v14.17.5/lib/node' ] 仔细观察搜索路径，会发现它会按照就近原则进行逐层上溯，直至根目录NODE_PATH中。 然后会额外搜索以下3个目录： $HOME/.node_modules $HOME/.node_libraries $PREFIX/lib/node 其中$HOME是用户的主目录，$PREFIX是 Node.js 里配置的node_prefix。 强烈建议将所有的依赖放在本地的node_modules目录，这样将会更快地加载，且更可靠。 ES6 Module Node.js现已支持ES6 Module语法进行模块管理，主要有2种方式。 1）通过第三方模块babel进行构建，在v12版本以前较为常用： { \"presets\": [ [\"@babel/preset-env\", { \"targets\": { \"node\": \"8.9.0\", \"esmodules\": true } }] ] } 2）直接使用ES6 Module语法，适用于v12版本之后。 需要开启 --experimental-modules 模块名修改为.mjs或者在package.json中设置\"type\": module，推荐使用后者 当设置完成后，Node.js会将所有的js文件当做ES Module进行处理，更多详情参考官方文档 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-08-27 18:17:52 "},"前端专栏/Node.js/包管理器.html":{"url":"前端专栏/Node.js/包管理器.html","title":"包管理器","keywords":"","body":"基础介绍 npm npm是Node.js中标准的软件包管理器，它类似于Python中的pip，能够更加方便的让我们进行下载和管理第三方模块。 除此之外，Node.js中也提供了Yarn软件包管理器，它作为npm的替代品更加的优秀。但在npm5.0更新之后，两者的差距并不大，开发者可自行选择。 cnpm 由于npm的镜像站是在国外，因此更加推荐安装cnpm来进行第三方模块下载，它采用国内淘宝的镜像源，淘宝镜像源每10分钟便会同步npm镜像源一次，因此速度更快。 你只需要在CIL中输入以下命令即可： $ npm i -g cnpm --registry=https://registry.npm.taobao.org 在下载第三方模块时，只需将npm替换为cnpm命令即可，如： $ cnpm install jquery 不过这里推荐，能用npm的还是尽量用npm，因为cnpm可能会出现某些令人意外的情况，尽管这种概率很小但依然存在。 常用命令 以下是npm的常用命令： 命令 描述 npm -v 查看npm版本 npm i npm -g 更新npm至最新版 npm install 模块名@版本号 本地安装一个模块，若不指定@版本号，则自动安装最新版，若加上-g则是全局安装 npm install 模块1 模块2 模块3 本地安装n个模块，若加上-g则是全局安装 npm uninstall 模块1 模块2 模块3 卸载本地n个模块，若加上-g则是全局卸载 npm uninstall 模块名 卸载本地一个模块，若加上-g则是全局卸载 npm update 模块名@版本号 更新本地一个模块，若不指定@版本号，则自动更新到最新版，若加上-g则是全局更新 npm ls 查询本地已安装的所有模块，若加上-g则是查询全局 npm ls 模块名 查询本地已安装的某个模块信息，若加上-g则是查询全局 npm search 模块名 从镜像站搜索某个模块 npm cache clear --force 清除npm的缓存 npm init 创建一个package.json文件，用于管理项目中多个模块 npm install --save 根据文件package.json下载所有适用于生产环境下的模块，等同于npm install npm install --save-dev 根据文件package.json下载所有适用于开发环境下的模块，等同于npm install -D 安装方式 当使用npm安装第三方模块时，会有2种安装方式： 全局安装 本地安装 默认情况下，当输入npm install命令后它将进行本地安装。 被下载的第三方模块会安装至当前目录树中的node_modules子目录下，如果该目录不存在，将自动进行创建。 除此之外，如果当前目录中存在package.json文件，它还会在package.json文件的dependencies属性中添加lodash条目。 使用-g标志可执行全局安装。 全局安装时，被下载的第三方模块会安装至全局位置中，可使用npm root -g来查看全局安装的位置。 在macOS或Linux上，此位置可能是 /usr/local/lib/node_modules。 在Windows上，可能是C:\\Users\\YOU\\AppData\\Roaming\\npm\\node_modules。 但是，如果使用nvm管理 Node.js 版本，则该位置会有所不同。 例如，使用nvm，则软件包的位置可能为/Users/joe/.nvm/versions/node/v8.9.0/lib/node_modules。 一句话总结，本地安装的第三方模块只有当前项目能使用，而全局安装的第三方模块则所有项目都能使用，如果不是特殊情况，如下载cnpm这种全局可用的模块时，一定要确保使用了本地安装。 package.json 文件作用描述 package.json是当前项目中所依赖第三方模块的清单，除此之外它还是整个项目的管理中心。 你可以在package.json中查看到当前项目下所使用的全部第三方模块、还可以自定义shell命令更加轻松的管理当前项目。 只需要在项目根目录中输入npm init命令，即可在当前目录中生成package.json文件，输入命令后一路回车即可（也可以输入npm init -y命令直接确认），以下是生成的文件内容： { \"name\": \"nodeproject\", \"version\": \"1.0.0\", \"description\": \"\", \"main\": \"main.js\", \"scripts\": { \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\" }, \"author\": \"\", \"license\": \"ISC\" } 文件释义： name：当前项目的名称 version：当前项目的版本 description：当前项目的描述 main：当前项目的入口文件 scripts：当前项目中自定义的npm脚本命令 author：当前项目的作者名称 license：当前项目的许可证 除此之外，它可能还拥有更多的内容： dependencies：生产环境下，该项目运行所依赖的所有模块 devDependencies：开发环境下，该项目运行所依赖的所有模块 engines：当前项目适用于在哪个版本的Node.js中进行运行 contributors：该项目的其他贡献者 keywords：关键字 bugs：链接到当前项目的问题跟踪器，最常用的是 GitHub 的 issues 页面 homepage：当前项目的主页 browserslist：当前项目所支持的浏览器列表，在使用Babel等构建工具时，它将产生作用 生产环境依赖 当直接使用以下命令时，第三方模块安装后将会把lodash信息添加至dependencies属性中： $ npm install jquery bootstrap axios 它相当于在执行命令时加上了--save的后缀： $ npm install jquery bootstrap axios --save 可以看到package.json的dependencies属性已经更新了： \"dependencies\": { \"axios\": \"^0.21.1\", \"bootstrap\": \"^5.1.0\", \"jquery\": \"^3.6.0\" } 当要下载一个项目中所有的用于生产环境的依赖模块时，你只需要在package.json同级目录下执行以下命令即可： $ npm install --save 开发环境依赖 当使用以下命令时，第三方模块安装后将会把lodash信息添加至devDependencies属性中： $ npm install jquery bootstrap axios --save-dev 或者你也可以使用-D的后缀： $ npm install jquery bootstrap axios --D 可以看到package.json的devDependencies属性已经更新了： \"devDependencies\": { \"axios\": \"^0.21.1\", \"bootstrap\": \"^5.1.0\", \"jquery\": \"^3.6.0\" } 当要下载一个项目中所有的用于开发环境的依赖模块时，你只需要在package.json同级目录下执行以下命令即可： $ npm install --save-dev 项目版本规范 任何npm能够下载的第三方模块，实际上都是一个独立的项目。 包括我们自定义的项目，在广义上来说它被称之为包更加合适，当你需要指定项目版本version时需要注意以下一些规则。 所有版本号均有3个数字组成 第一个数字是主版本号 第二个数字是次版本号 第三个数字是补丁版本 package.json中依赖模块版本中夹杂的符号用于在npm install下载时规定下载模块的版本区间，以下是常见符号释义： ^：只能在当前主版本区间中下载依赖模块，如^3.6.0，它不会下载到4.0.0的模块，但支持下载到3.0.0至3.99.9999之间的模块 ~：高低一个补丁号区间，如^3.6.1，它可能下载到^3.6.0或者^3.6.2，但不会下载到4.0.0 >：接受高于指定版本的任何版本 >=：接受等于或高于指定版本的任何版本 =：接受确切的版本 -：接受一定范围的版本。例如：2.1.0 - 2.6.2 ||：组合集合。例如 2.6 npm脚本命令 一般来说，npm脚本由用户提供。但是，npm对两个脚本提供了默认值。也就是说，这两个脚本不用定义，就可以直接使用。 \"start\": \"node server.js\"， \"install\": \"node-gyp rebuild\" 上面代码中，npm run start的默认值是node server.js，前提是项目根目录下有server.js这个脚本；npm run install的默认值是node-gyp rebuild，前提是项目根目录下有binding.gyp文件。 通过package.json中的scripts属性，我们也可以定制一些自定义的npm脚本命令。 如指定一个自定义的npm脚本命令serve： \"scripts\": { \"serve\" : \"node ./main.js\" }, 在CIL中输入npm run serve，它实际上将执行node ./main.js命令： $ npm run serve > nodeproject@1.0.0 serve /Users/yunya/Project/nodeProject > node ./main.js server running localhost:5700 使用npm run，查看所有自定义的脚本命令。 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-10-11 15:35:04 "},"前端专栏/Node.js/Ts+Node.html":{"url":"前端专栏/Node.js/Ts+Node.html","title":"Ts+Node","keywords":"","body":"基本介绍 TypeScript现在已经开始逐渐的取代JavaScript，因此在我们的后端上也推荐使用TypeScript进行代码编写。 它拥有严格的类型检查，让你的错误能够及时发现，最大限度的规范你的代码。 关于TypeScript的使用，可以查看之前关于TypeScript内容进行学习。 下载安装 下载安装TypeScript： $ npm install typescript 在项目根目录中运行以下命令，生成tsconfig.json： $ tsc --init 填入TypeScript的配置文件： { \"include\": [ \"./src/**/*\", // 仅编译src目录下的所有ts文件 ], \"exclude\": [ \"./src/test/**/*\", // 不编译src目录中test目录下所有的ts文件 ], \"compilerOptions\": { \"target\": \"ES6\", // 编译后生成的js版本为es6 \"module\": \"CommonJS\", // 编译后的模块使用规范为CommonJs \"lib\": [ // node环境中测试ts代码所需要使用的库 \"ES6\" ], \"outDir\": \"./dist\", // 编译后生成的js文件存放路径 \"allowJs\": true, // 二次编译js文件 \"checkJs\": true, // 验证js文件语法 \"removeComments\": false, // 编译后的js文件删除注释信息 \"noEmitOnError\": true, // 如果编译时出现错误，编译将终止 \"strict\": true, // 启用TypeScript的严格模式 \"alwaysStrict\": true, // 启用JavaScript的严格模式 \"noFallthroughCasesInSwitch\": true, // 检测switch语句块是否正确的使用了break \"noImplicitReturns\": true, // 检测函数是否具有隐式的返回值 \"noUnusedLocals\": true, // 检测是否具有未使用的局部变量 \"noUnusedParameters\": true, // 检测是否具有未使用的函数参数 \"allowUnreachableCode\": true, // 检测是否具有永远不会运行的代码 } } 相关依赖 node解释器并不认识TypeScript，我们可以下载一个ts-node，让我们能够更加方便的调试TypeScript代码。 $ npm install ts-node 其次，需要下载一个@types/node，让我们的Node.js在TypeScript中能够支持ES Module语法： $ npm install @types/node 还需要下载3个依赖包： $ npm install peer dependencies yourself 简单使用 项目目录如下： . ├── dist # 存放编译后的JavaScript代码 ├── node_modules │ └── ... ├── package-lock.json ├── package.json ├── src # ts源代码存放目录 │ └── server.ts └── tsconfig.json 此外你还需要对package.json做修改，主要是main和scripts属性： { ... \"main\": \"./dist/server.js\", \"scripts\": { \"serve\": \"node ./dist/server.js\" }, ... } 下面编写一个HTTP服务，注意，我们在利用TypeScript编写代码的时候也将采用ES Module标准，而不是使用CommonJS： import * as http from 'http'; const hostname: string = \"localhost\"; const port: number = 3000; const server: http.Server = http.createServer((request: http.IncomingMessage, response: http.ServerResponse): void => { response.setHeader('Content-Type', 'application/json'); response.statusCode = 200; response.end(JSON.stringify(request.method === \"GET\" ? \"GET OK!!!\" : \"POST OK!!!\")); }); server.listen(port, hostname, (): void => { console.log(`server running success! http://${hostname}:${port}`); }) 在代码编写完成后，使用ts-node命令进行代码测试： $ ts-node ./src/server.ts server running success! http://localhost:3000 代码测试无误后，使用tsc命令将ts文件编译为js文件，编译完成后的js文件将位于dist目录中： $ tsc 由于我们的npm脚本命令serve指向了node ./dist/server.js，故可以直接使用npm run serve来运行服务： $ npm run serve > nodeproject@1.0.0 serve /Users/yunya/Project/nodeProject > node ./dist/server.js server running success! http://localhost:3000 最后可以查看一下编译完成的JavaScript文件，它使用的是CommonJS标准，因为我们已经在tsconfig.json文件中对其进行了配置： \"use strict\"; Object.defineProperty(exports, \"__esModule\", { value: true }); const http = require(\"http\"); const hostname = \"localhost\"; const port = 3000; const server = http.createServer((request, response) => { response.setHeader('Content-Type', 'application/json'); response.statusCode = 200; response.end(JSON.stringify(request.method === \"GET\" ? \"GET OK!!!\" : \"POST OK!!!\")); }); server.listen(port, hostname, () => { console.log(`server running success! http://${hostname}:${port}`); }); Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-10-05 20:27:24 "},"前端专栏/Node.js/process.html":{"url":"前端专栏/Node.js/process.html","title":"process","keywords":"","body":"process process对象是一个全局变量，同时它也是EventEmitter对象的实例，提供了当前Node.js进程的信息和操作方法。 由于process对象是EventEmitter对象的实例，故可以对其进行事件监听。 常用属性 属性一览 以下是process对象中常用的属性： 属性 描述 title 返回进程名称，默认为node pid 返回进程pid号 platform 返回当前运行进程的操作系统名称 version 返回当前的Node.js版本号 env 返回当前shell中所有的环境变量 execPath 返回执行当前脚本的Node二进制文件的绝对路径 argv 返回从命令行接收到用户输入命令的数组，它包含了执行当前脚本的Node二进制文件的绝对路径以及当前被执行文件的绝对路径 execArgv 如果用户在命令行输入的命令携带了Node.js的内置参数，如--inspect时，那么--inspect将添加到该数组中 argv process.argv属性是一个比较常用的属性。 我们可以在命令行中输入一些参数，并且让JavaScript脚本进行接收。 如下所示： $ npm start localhost:5700 脚本文件： ts-node ./src/server.ts 127.0.0.1:5500 argv数组： [ '/Users/yunya/.nvm/versions/node/v14.17.5/bin/ts-node', '/Users/yunya/Project/nodeProject/src/server.ts', '127.0.0.1:5500' ] 它有什么作用呢？比如我们想由使用者来决定HTTP服务的port和hostname时，它就派上了用处： import * as http from 'http'; const argv: string[] = process.argv.slice(2); const hostname: string = argv.length ? argv[0].split(\":\")[0] : \"localhost\"; const port: number = argv.length ? Number(argv[0].split(\":\")[1]) : 3000; const server: http.Server = http.createServer((request: http.IncomingMessage, response: http.ServerResponse): void => { response.setHeader('Content-Type', 'application/json'); response.statusCode = 200; response.end(JSON.stringify(request.method === \"GET\" ? \"GET OK!!!\" : \"POST OK!!!\")); }); server.listen(port, hostname, (): void => { console.log(`server running success! http://${hostname}:${port}`); }) 常用方法 方法一览 以下是process对象中常用的方法： 方法 描述 chidr() 切换工作目录到指定目录 cwd() 返回当前工作目录 exit() 退出当前进程 memoryUsage() 返回Node.js进程的内存使用情况 进程事件 exit 当Node.js进程因以下原因之一即将退出时，则会触发exit事件： 显式调用process.exit()方法 Node.js事件循环不再需要执行任何其他工作 此时无法阻止退出事件循环，并且一旦所有exit事件的监听器都已完成运行时，Node.js进程将终止 process.on('exit', (code: number) => { console.log(`退出码: ${code}`); }); uncaughtException 当前进程抛出一个没有被捕捉的错误时，会触发uncaughtException事件： process.on('uncaughtException', function (err: NodeJs.ErrnoException) { console.error(err.stack); }); beforeExit 当Node.js清空其事件循环并且没有其他工作要安排时，会触发beforeExit事件。通常Node.js进程将在没有调度工作时退出，但是在beforeExit事件上注册的监听器可以进行异步调用使Node.js进程继续： process.on('beforeExit', (code: number) => { console.log('进程 beforeExit 事件的代码: ', code); }); process.on('exit', (code: number) => { console.log('进程 exit 事件的代码: ', code); }); console.log('此消息最新显示'); // 打印: // 此消息最新显示 // 进程 beforeExit 事件的代码: 0 // 进程 exit 事件的代码: 0 message 如果使用IPC通道fork Node.js进程，子进程收到父进程使用childprocess.send()发送的消息，就会触发message事件： process.on('message', (m: string) => { console.log('子进程收到消息', m); }); process.nextTick(callback) process.nextTick()方法将callback添加到下一个时间点的队列执行。 也就是说它会将一个任务提升为异步微任务。 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-08-27 18:22:58 "},"前端专栏/Node.js/事件操作.html":{"url":"前端专栏/Node.js/事件操作.html","title":"事件操作","keywords":"","body":"监听事件 监听对象 所有EventEmitter类的实例，均可对其进行事件监听。 on() Node.js中使用on()进行事件监听，如下所示，我们为EventEmitter实例对象ev绑定了一个custom自定义事件，并且每3s主动触发一次该事件： import * as events from \"events\"; const ev: events.EventEmitter = new events.EventEmitter(); ev.on(\"custom\", (): void => { console.log(\"custom event trigger\"); }) setInterval((): void => { ev.emit(\"custom\") }, 3000); once() once()见名知意，由它监听的事件只会触发一次： import * as events from \"events\"; const ev: events.EventEmitter = new events.EventEmitter(); ev.once(\"custom\", (): void => { console.log(\"custom event trigger\"); }) setInterval((): void => { ev.emit(\"custom\") }, 3000); prependListener() 注意，EventEmitter实例对象内部会维护一个已监听事件的数组，每次添加新的监听事件时都会将被监听事件追加该数组尾部。重复的监听同一事件并不会产生任何问题。 如果你想将新的监听事件插入到该数组的头部，可使用prependListener()进行事件监听： import * as events from \"events\"; const ev: events.EventEmitter = new events.EventEmitter(); ev.prependListener(\"custom\", (): void => { console.log(\"custom event trigger\"); }) setInterval((): void => { ev.emit(\"custom\") }, 3000); 触发事件 emit() EventEmitter实例对象可调用emit()方法主动的触发一个事件，并且还可以传入一些参数给事件处理程序： import * as events from \"events\"; const ev: events.EventEmitter = new events.EventEmitter(); ev.on(\"custom\", (...ary: any[]): void => { console.log(ary); console.log(\"custom event trigger\"); }) setInterval((): void => { ev.emit(\"custom\", 1, 2, 3, 4) }, 3000); 取消监听 off() 使用off()方法或者removeListener()方法来取消某个事件的监听。 每次至多只能取消一个，若要取消多个则必须调用多次该方法： import * as events from \"events\"; const ev: events.EventEmitter = new events.EventEmitter(); function callback(): void { console.log(\"custom event trigger\"); } ev.on(\"custom\", callback); ev.emit(\"custom\"); ev.off(\"custom\", callback); ev.emit(\"custom\"); 以上代码中，第二次的emit()并不会被执行，因为事件已被取消监听。 removeAllListeners() 使用removeAllListeners()方法来取消所有事件的监听，它也可以用来取消某一个事件的监听。 import * as events from \"events\"; const ev: events.EventEmitter = new events.EventEmitter(); function callback(): void { console.log(\"custom event trigger\"); } ev.on(\"custom\", callback); ev.emit(\"custom\"); // ev.removeAllListeners(\"custom\"); // 取消一个 ev.removeAllListeners(); // 取消全部 ev.emit(\"custom\"); Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-08-27 14:05:36 "},"前端专栏/Node.js/定时器.html":{"url":"前端专栏/Node.js/定时器.html","title":"定时器","keywords":"","body":"事件循环 Node.js JavaScript代码运行在单个线程上。 每次只处理一件事。 这个限制实际上非常有用，因为它大大简化了编程方式，而不必担心并发问题。 如果你之前不了解JavaScript事件循环，可参照之前JavaScript中Promise章节。 const bar = () => console.log('异步宏任务 bar'); const baz = () => console.log('同步任务 baz'); const foo = () => { console.log('同步任务 foo') setTimeout(bar, 0) new Promise((resolve, reject) => { console.log(\"同步任务 Promise executor\"); resolve(); } ).then(() => console.log(\"异步微任务 then\")); baz(); }; foo(); // 同步任务 foo // 同步任务 Promise executor // 同步任务 baz // 异步微任务 then // 异步宏任务 bar 定时器 Node.js中可用的定时器函数如下所示： setTimeout(callback, delay[, ...args]) setInterval(callback[, ...args]) setImmediate(callback[, ...args]) process.nextTick(callback[, ...args]) 前2个和WEB端是一致的，后2个有略微的差异。 setImmediate()用于将任务添加至宏任务队列，它晚于微任务执行 process.nextTick()用于将任务添加至微任务队列，它早于宏任务执行 在Node.js中，setImmediate()以及process.nextTick()是会被经常使用的，与之相比前2个setTimeout()以及setInterval()使得场景较少。 Node.js 不保证回调被触发的确切时间，也不保证它们的顺序，回调会在尽可能接近指定的时间被调用。setTimeout 当 delay 大于 2147483647 或小于 1 时，则 delay 将会被设置为 1， 非整数的 delay 会被截断为整数 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-08-27 14:42:14 "},"前端专栏/Node.js/路径处理.html":{"url":"前端专栏/Node.js/路径处理.html","title":"路径处理","keywords":"","body":"path模块 Node.js中关于路径的处理，统一采用内置模块path进行解决。 path模块对不同的操作系统会有不同的处理方案，如果在Windows操作系统上，path会使用Windows风格的路径，即（C:\\\\temp\\\\index.html），而在POSIX操作系统上会默认使用POSIX的路径风格，即(/temp/index.html)。路径风格和操作系统不一致会出现意外的结果。 PS：POSIX，Portable Operating System Interface，是UNIX系统的一个设计标准，很多类UNIX系统也在支持兼容这个标准，如Linux和Mac OS所基于的FreeBSD 指定系统 如果你想获取某一个平台下的路径，可通过以下方式运行方法： path.win32.方法名() path.posix.方法名() 示例如下： import * as path from 'path'; let winDirName: string = path.win32.dirname(\"C://temp//index.html\"); let posixDirName: string = path.posix.dirname(\"/temp/index.html\"); console.log(winDirName); console.log(posixDirName); // C://temp/ // /temp 如果直接使用path.方法名()则Node.js解析器会自动判断操作系统，从而返回该平台风格的路径内容。 常用属性 以下是path模块中所提供的常用属性： 属性 描述 sep 返回路径分隔符，Windows返回反斜杠、POSIX返回正斜杠 delimiter 获取操作系统路径界定符，Windows返回分号、POSIX返回冒号 示例演示： > path.sep '/' > path.delimiter ':' 常用方法 以下是path模块中所提供的常用方法： 方法 描述 dirname() 获取文件的父文件夹 basename() 获取文件名部分 extname() 获取文件扩展名部分 join() 拼接一个完整路径 resolve() 返回文件绝对路径 isAbsolute() 检测路径是否是绝对路径 normalize() 当出现.或者..时，它会自动计算文件实际路径 parse() 解析文件路径信息，返回一个文件路径信息对象 format() 根据文件路径信息对象拼接出文件路径信息，相当于parse()的反操作 示例演示： > const posixPath = \"/Users/yunya/Project/server.js\" undefined > path.dirname(posixPath) '/Users/yunya/Project' > path.basename(posixPath) 'server.js' > path.extname(posixPath) '.js' > path.join(\"/\", \"Users\", \"Jack\", \"Demo\") '/Users/Jack/Demo' > path.isAbsolute(posixPath) true > path.normalize(\"/Users/yunya/../jack/./Demo\") '/Users/jack/Demo' > let pathObject = path.parse(posixPath) undefined > pathObject { root: '/', dir: '/Users/yunya/Project', base: 'server.js', ext: '.js', name: 'server' } > path.format(pathObject) '/Users/yunya/Project/server.js' Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-08-27 15:13:08 "},"前端专栏/Node.js/文件操作.html":{"url":"前端专栏/Node.js/文件操作.html","title":"文件操作","keywords":"","body":"fs模块 fs模块提供了对文件、文件夹读写操作的同步、异步方法。 个人比较喜欢使用该模块下的同步方法，异步方法编写起来比较麻烦，而且大多数常见下作用不明显。 但是本章节还是着重介绍异步方法，因为同步方法相对来说比较简单。 操作风格 回调风格 Node.js中基本上所有的异步操作都是回调函数的风格，这就造成了ES6标准没出来之前令人闻风丧胆的回调地狱现象，如读取一个文件时，就需要指定1个回调函数，用于读取完成后做处理。 绝大多数异步操作的fs方法基本都具有2个参数，极少数方法除外： err：操作失败，err为错误信息 returnValue：操作成功，returnValue为操作成功后的内容，err为null 我们以读取文件为示例进行演示： import * as fs from 'fs'; fs.readFile(\"./src/testFile.txt\", \"utf-8\", (err: NodeJS.ErrnoException | null, data: string) => { if (err) { throw err; } console.log(data); }) fs promise API fs.promise API提供了一组和callback风格对应的方法，它让原本的方法返回Promise对象而不使用回调，避免出现callback嵌套的回调地狱问题。 API可通过require('fs').promises 或 require('fs/promises')访问，这个模块下没有同步方法，只有Promise封装好的异步方法。 注意！require('fs/promises')仅在v14后可用。 示例演示，这里采用第二种方式： import * as pfs from 'fs/promises'; pfs.readFile(\"./src/testFile.txt\", \"utf-8\") .then((data: string) => { console.log(data); }).catch((err: NodeJS.ErrnoException) => { console.log(err); }) 同步读取 除此之外，你也可进行同步操作，它在某些时候显得更加适用。 如你必须将文件读取完成后才能返回，fs模块下大部分的方法都提供了一个同步版本，只需要在方法名称后面加上Sync后缀即可，如fs.readFile需要变更为fs.readFileSync。 同步方法不需要指定回调，如下所示： import * as fs from 'fs'; try { const data: string = fs.readFileSync(\"./src/testFile.txt\", \"utf-8\"); console.log(data); } catch (e: unknown) { console.log(e); } stat 获取基本信息 fs.stat()方法用于异步的获取文件基本信息，如下所示： import * as fs from 'fs'; fs.stat(\"./src/testFile.txt\", (err: NodeJS.ErrnoException | null, currentFile: fs.Stats) => { if (err) { throw err; } console.log(currentFile); }) 除此之外你也可以使用fs.statSync()来同步的获取文件基本信息： import * as fs from 'fs'; try { let currentFile: fs.Stats = fs.statSync(\"./src/testFile.txt\"); console.log(currentFile); } catch (e: unknown) { console.log(e); } 基本信息如下： Stats { dev: 16777220, mode: 33188, nlink: 1, uid: 501, gid: 20, rdev: 0, blksize: 4096, ino: 15414257, size: 11, blocks: 8, atimeMs: 1630053255000, mtimeMs: 1630048964000, ctimeMs: 1630048964000, birthtimeMs: 1630048960000, atime: 2021-08-27T08:34:15.000Z, mtime: 2021-08-27T07:22:44.000Z, ctime: 2021-08-27T07:22:44.000Z, birthtime: 2021-08-27T07:22:40.000Z } isDirectory() 判断当前对象是否是一个目录： import * as fs from 'fs'; fs.stat(\"./src/testFile.txt\", (err: NodeJS.ErrnoException | null, currentFile: fs.Stats) => { if (err) { throw err; } console.log(currentFile.isDirectory()); // false }) isFile() 判断当前对象是否是一个普通文件： import * as fs from 'fs'; fs.stat(\"./src/testFile.txt\", (err: NodeJS.ErrnoException | null, currentFile: fs.Stats) => { if (err) { throw err; } console.log(currentFile.isFile()); // false }) isSymbolicLink() 判断当前对象是否是一个软链接： import * as fs from 'fs'; fs.stat(\"./src/testFile.txt\", (err: NodeJS.ErrnoException | null, currentFile: fs.Stats) => { if (err) { throw err; } console.log(currentFile.isSymbolicLink()); // false }) size 获取当前对象的字节数大小： import * as fs from 'fs'; fs.stat(\"./src/testFile.txt\", (err: NodeJS.ErrnoException | null, currentFile: fs.Stats) => { if (err) { throw err; } console.log(currentFile.size); // 11 }) 文件读取 fs.readFile() 使用fs.readFile()异步的读取文件。 path：需要读取的文件路径 encoding：文件字符编码格式，若不指定则返回Buffer格式数据 callback：回调函数 示例演示： import * as fs from 'fs'; fs.readFile(\"./src/testFile.txt\", \"utf-8\", (err: NodeJS.ErrnoException | null, data: string) => { if (err) { throw err; } console.log(data); }) fs.readFileSync() 使用fs.readFileSync()同步的读取文件： path：需要读取的文件路径 encoding：文件字符编码格式，若不指定则返回Buffer格式数据 示例演示： import * as fs from 'fs'; try { const data: string = fs.readFileSync(\"./src/testFile.txt\", \"utf-8\"); console.log(data); } catch (e: unknown) { console.log(e); } fs.createReadStream() 使用fs.createReadStream()流来读取大文件，它具有6个可用于监听的事件： open：文件已打开完成 ready：文件已准备完成 data：文件已正在读取 end：文件已读取完毕 close：文件已经关闭 error：读取发生异常 示例演示： import * as fs from 'fs'; const fd: fs.ReadStream = fs.createReadStream(\"./src/testFile.txt\"); let content: string = \"\"; fd.on(\"open\", () => { console.log(`已经打开`); }); fd.on(\"ready\", () => { console.log(`准备就绪`); }); fd.on(\"data\", (chunk: NodeJS.ReadStream) => { console.log(\"开始读取\"); content += chunk.toString(); }); fd.on(\"end\", () => { console.log(`读取完成`); console.log(content); }); fd.on(\"close\", () => { console.log(`已经关闭`); }); fd.on(\"error\", () => { console.log(`发生错误`); }); 文件写入 fs.writeFile() 使用fs.writeFile()异步的将内容写入文件中。 path：需要写入的文件路径 data：需要写入文件的内容 callback：回调函数，仅有一个err参数 注意，当文件已存在，它将清空文件源内容后再写入新内容，若文件不存在则自动创建并写入。 示例演示： import * as fs from 'fs'; const content = \"Hello Node.js\" fs.writeFile(\"./src/testFile.txt\", content, (err: NodeJS.ErrnoException | null) => { if (err) { throw err; } console.log(\"write to file success!\"); }) fs.writeFileSync() 使用fs.writeFile()同步的将内容写入文件中。 path：需要写入的文件路径 data：需要写入文件的内容 注意，当文件已存在，它将清空文件源内容后再写入新内容，若文件不存在则自动创建并写入。 示例演示： import * as fs from 'fs'; const content = \"Hello Node.js\" try { fs.writeFileSync(\"./src/testFile.txt\", content); console.log(\"write to file success!\"); } catch (e: unknown) { console.log(e); } fs.appendFile() 使用fs.appendFile()异步的将内容追写进文件中。 path：需要写入的文件路径 data：需要写入文件的内容 callback：回调函数，仅有一个err参数 注意，当文件已存在，它将在源文件已有内容的后面追写新的内容，若文件不存在则自动创建并写入。 示例演示： import * as fs from 'fs'; const content = \"Hello Node.js\" fs.appendFile(\"./src/testFile.txt\", content, (err: NodeJS.ErrnoException | null) => { if (err) { throw err; } console.log(\"write to file success!\"); }) fs.appendFileSync() 使用fs.appendFileSync()同步的将内容追写进文件中。 path：需要写入的文件路径 data：需要写入文件的内容 注意，当文件已存在，它将在源文件已有内容的后面追写新的内容，若文件不存在则自动创建并写入。 示例演示： import * as fs from 'fs'; const content = \"Hello Node.js\" try { fs.appendFileSync(\"./src/testFile.txt\", content); console.log(\"write to file success!\"); } catch (e: unknown) { console.log(e); } fs.createWriteStream() 使用fs.createWriteStream()流来写入大文件，它具有5个可用于监听的事件： open：文件已打开完成 ready：文件已准备完成 finish：文件已写入完毕 close：文件已经关闭 error：写入发生异常 通过write()方法，可指定写入内容并指定编码格式。 示例演示，我们可以自定义一个write作为可写事件，并在文件准备完成后手动触发该事件，当文件内容写入完成后你应当调用end()方法通知文件以写入完毕，它将自动执行finish回调函数： import * as fs from 'fs'; const fd: fs.WriteStream = fs.createWriteStream(\"./src/testFile.txt\"); let content: string = \"Hello Node.js\"; fd.on(\"open\", () => { console.log(`已经打开`); }); fd.on(\"ready\", () => { console.log(`准备就绪`); fd.emit(\"write\"); // 手动触发可写事件，注意可写事件是自定义的 }); fd.on(\"write\", () => { console.log(\"开始写入\"); fd.write(content, \"utf-8\"); fd.end(); // 宣告写入结束，自动触发finish事件 }); fd.on(\"finish\", () => { console.log(`写入完成`); }); fd.on(\"close\", () => { console.log(`已经关闭`); }); fd.on(\"error\", () => { console.log(`发生错误`); }); 文件夹操作 fs.Dir与fs.Dirent fs.Dir是可迭代的目录流，你可以将它认为是目录项。 fs.Dirent是遍历fs.Dir得到的子内容，可以是文件或者子目录。 以下是fs.Dir中可调用的属性或方法： path：获取目录的只读路径 read()：若不传入callback、则返回一个Promise，读取迭代器中下一个目录项，resolve后得到fs.Dirent或null close()：若不传入callback、则返回一个Promise，关闭目录的底层资源句柄 以下是fs.Dirent中可调用的属性或方法： name：返回文件名 isDirectory()：判断是否是一个目录 isFile()：判断是否是一个文件 isSymbolicLink()：判断是否是一个软链接 fs.opendir() fs.opender()方法用于打开一个目录，它将返回一个fs.Dir对象。 path：需要打开的目录路径 ?options：一个对象，用于传入字符编码和缓冲区大小 callback：回调函数 示例如下： import * as pfs from \"fs/promises\"; import * as fs from \"fs\"; async function dirMap(path: string): Promise { let dir: fs.Dir = await pfs.opendir(path); let dirent: fs.Dirent; for await (dirent of dir) { console.log(dirent.name); } } dirMap(\"./\"); 实现遍历目录下所有文件： import * as pfs from \"fs/promises\"; import * as fs from \"fs\"; import * as ph from \"path\"; async function dirMap(path: string): Promise { let dir: fs.Dir = await pfs.opendir(path); let dirent: fs.Dirent; console.log(path); for await (dirent of dir) { if (dirent.isDirectory()) { dirMap(ph.join(path, dirent.name)) } else { console.log(ph.join(path, dirent.name)); } } } dirMap(\"./src\"); fs.readdir() fs.readdir()方法用于返回目录下所有的内容。 path：需要打开的目录路径 ?options：一个对象，用于传入字符编码和缓冲区大小 callback：回调函数 示例演示： import * as pfs from \"fs/promises\"; async function dirMap(path: string): Promise { let dir: string[] = await pfs.readdir(path); console.log(dir); } dirMap(\"./src\"); // [ 'demo.ts', 'pf.py', 'server.ts', 'test', 'testFile.txt' ] fs.mkdir() fs.mkdir()方法用于创建目录。 path：需要创建的目录路径 ?options：一个对象，如果其中的recursive为true的话，则相当于mkdir -p，默认为false callback：回调函数 示例演示： import * as pfs from \"fs/promises\"; import * as fs from \"fs\"; let path: string = \"/tmp/1/2/3/4/5\"; try { // 相当于 mkdir -p /tmp/1/2/3/4/5 pfs.mkdir(path, { recursive: true }); } catch (e: unknown) { console.log(e); } finally { console.log(fs.existsSync(path)); } fs.redir() fs.mkdir()方法用于删除目录。 path：需要删除的目录路径 ?options：一个对象，如果其中的recursive为true的话，则递归的进行目录删除，即使目录不存在也不会抛出异常，默认为false callback：回调函数 示例演示： import * as pfs from \"fs/promises\"; import * as fs from \"fs\"; let path: string = \"/tmp/1\"; try { pfs.rmdir(path, { recursive: true }); } catch (e: unknown) { console.log(e); } finally { // 注意，由于rmdir是一个异步方法，而existsSync是个同步方法 // 所以判断目录是否存在会先执行而后删除，使用setImmediate()将existsSync()提升到宏任务队列中 // 保证判断不会出现在删除之前 setImmediate(() => { console.log(fs.existsSync(path)); }) } 其他常用 API fs.existsSync() fs.existsSync()用于同步的判断文件是否存在。 返回布尔值。 import * as fs from \"fs\"; console.log(fs.existsSync(\"/Users\")); 该方法存在异步版本。但是不推荐使用。 copyFileSync() copyFileSync()用于同步的拷贝文件。 import * as fs from \"fs\"; // fs.constants.COPYFILE_EXCL选项的意思是，如果文件已存在，将会抛出异常 fs.copyFileSync(\"源文件.txt\", \"目标文件.txt\", fs.constants.COPYFILE_EXCL); 该方法存在异步版本。 fs.renameSync() fs.renameSync()方法用于同步的为文件进行重命名。 import * as fs from \"fs\"; fs.renameSync(\"旧名字\", \"新名字\"); 该方法存在异步版本。 fs.unlinkSync() fs.unlinkSync()方法只能同步的删除文件或软链接，不能删除目录。 import * as fs from \"fs\"; fs.unlinkSync(\"文件路径\"); 该方法存在异步版本。 fs.chmodSync() fs.chmodSync()方法用于同步的修改文件读写执行权限。 import * as fs from \"fs\"; fs.chmodSync(\"文件路径\", 0o775); 该方法存在异步版本。 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-08-28 15:23:20 "},"前端专栏/Node.js/Buffer.html":{"url":"前端专栏/Node.js/Buffer.html","title":"Buffer","keywords":"","body":"基本介绍 我们都知道，如果数据想在网络中进行传播，那么必须传输二进制字节流。但遗憾的是JavaScript中并没有实现类似的直观数据类型。 所幸，Node.js中支持了Buffer格式、Buffer类似于Python中的bytes类型、Go中的byte类型，它能够作用于数据网络传输和文件系统操作等场景。 我们都知道1个Byte等于8个bit，而Buffer则等于256个Byte。 Buffer类的实例实际上是一个0-255之间的数组，它是一个由JavaScript和C++结合的模块，其对象内存不经过V8引擎分配，而是通过C++进行申请、JavaScript 分配。缓冲区的大小在创建时确定，不能调整。 因Buffer对象实在过于常用，故被直接内置到全局变量中，使用时候无需 require 引入。 创建Buffer Buffer.form(string , encoding) 返回一个包含给定字符串的Bufferr： let bf: Buffer = Buffer.from(\"hello world\", \"utf-8\"); console.log(bf); // Buffer目前支持以下几种编码格式 ascii utf8 utf16le base64 binary hex Buffer.form(array) 返回一个内容包含所提供的字节副本的Buffer，数组中每一项是一个表示八位字节的数字，所以值必须在0 ~ 255之间，否则会取模： let bf: Buffer = Buffer.from([256, 2444, 3]); console.log(bf); // 超过 255 会取模，相当于 number % 256 // Buffer.form(object) 取object的valueOf()或Symbol.toPrimitive()初始化Buffer： let bf: Buffer = Buffer.from({ valueOf() { return \"hello world\"; } }); // 自动调用对象的valueOf()方法 console.log(bf); // Buffer.form(buffer) 返回一个给定Buufer的副本Buffer： let firstBf: Buffer = Buffer.from(\"hello world\", \"utf-8\"); let lastBf : Buffer = Buffer.from(firstBf); console.log(lastBf); // 转换为字符串 字符串转Buffer需要使用Buffer.form()方法，而Buffer转字符串只需要调用其下的toString()方法即可： let bf: Buffer = Buffer.from(\"hello world\", \"utf-8\"); console.log(bf); let str = bf.toString(); console.log(str); // // hello world Buffer拼接 使用Buffer.concat()方法将多个Buffer进行拼接： let firstBf: Buffer = Buffer.from(\"hello\", \"utf-8\"); let lastBf: Buffer = Buffer.from(\"world\", \"utf-8\"); console.log(Buffer.concat([firstBf, lastBf])); 常用方法 isBuffer() 判断一个对象是否是Buffer类型： console.log(Buffer.isBuffer(\"1\")); // false isEncoding() 判断Buffer对象的默认编码格式： console.log(Buffer.isEncoding(\"utf-8\")); // true length 获取Buffer对象的长度： let bf: Buffer = Buffer.from(\"hello world\", \"utf-8\"); console.log(bf.length); // 11 indexOf 获取某字符在Buffer中的位置，如果不存在则返回-1： let bf: Buffer = Buffer.from(\"hello world\", \"utf-8\"); console.log(bf.indexOf(\"w\")); // 6 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-08-27 23:53:06 "},"前端专栏/Node.js/Stream.html":{"url":"前端专栏/Node.js/Stream.html","title":"Stream","keywords":"","body":"基础介绍 什么是流 流是一种高效的信息传输手段，实际上早在几十年前的Unix操作系统中就已经存在了这一概念。 如下命令： ls . | grep \"test\" 它有个最大的特点就能是对数据进行分段处理，第一个阶段该怎么做、第二个阶段该怎么做。 例如，在传统方式中，当告诉程序需要读取文件时，它会将文件从头到尾读入内存后再进行处理，而使用流的话则可以逐个分段的读取并处理数据，意味着不必一次读完所有数据后再进行处理。 一个通俗的例子，我们在线观看视频时，缓冲进度条总是随着当前观看进度不断的增加，它并不是一开始就立马请求完整个完整的视频后再进行播放，这就是一个非常典型的流式传输案例。 相较于使用其他的数据处理方法，流提供了2个主要优点： 内存效率：无需加载大量的数据到内存中即可进行处理 时间效率： 当获得数据之后即可立即开始处理数据，这样所需的时间更少，而不必等到整个数据有效负载可用才开始 Node.js 的 stream模块提供了构建所有流 API 的基础。 所有的流都是EventEmitter的实例。 流可以分为4种类型： Readable：可读流，不可写入数据 Writable：可写流，不可读取数据 Duplex：双工流，可读可写 Transform：类似于双工流、但其输出是其输入的转换的转换流 流的传输 流的数据传输必须依赖一个管道，例如，下面的示例将从可读流中读取数据，并通过管道将它交由HTTP客户端： import * as http from 'http'; import * as fs from 'fs'; const hostname: string = \"localhost\"; const port: number = 3000; const server: http.Server = http.createServer((request: http.IncomingMessage, response: http.ServerResponse): void => { console.log(request.url); response.setHeader('Content-Type', 'text/html; charset=utf-8'); response.statusCode = 200; const stream = fs.createReadStream(__dirname + \"/testFile.txt\"); stream.pipe(response); // 通过管道发送给response }); server.listen(port, hostname, (): void => { console.log(`server running success! http://${hostname}:${port}`); }) 这样做的好处就是如果要读取的文件太大，那么我们可以不必等待文件被完全读取后再进行返回，而是读取一部分返回一部分。 实际上pipe()方法可以进行链式操作，它将不断的对数据进行传输，如下所示： src.pipe(dest1).pipe(dest2) 此构造相对于： src.pipe(dest1) dest1.pipe(dest2) 可读流 基本创建 通过stream模块创建一个可读流，对其进行初始化的同时并实现_read()方法即可。 this.push()方法用于为当前的可读流中新增数据，如下所示我们创建了一个不断产生随机数的可读流。 this.push()的内容只能是字符串或者Buffer，不能是数字 this.push()方法有第二参数encoding，用于第一个参数是字符串时指定encoding 如下所示： import * as stream from \"stream\"; const readableStream: stream.Readable = new stream.Readable() readableStream._read = function (): void { // 模拟数据的产生，每1s产生一个数据 setTimeout(() => { this.push(String(Math.round(Math.random() * 20)) + \"\\n\"); }, 1000); } // 进行读取，将数据输出到stdout上 readableStream.pipe(process.stdout) 或者你也可以通过类继承的方式进行实现： import * as stream from \"stream\"; class ReadableStream extends stream.Readable { constructor() { super(); } _read(): void { setTimeout(() => { this.push(String(Math.round(Math.random() * 20)) + \"\\n\"); }, 1000); } } const readableStream = new ReadableStream(); readableStream.pipe(process.stdout); 停止读取 如何停止可读流呢？实际上只要this.push()一个null即可，如下所示只要随机数为20就停止读取： import * as stream from \"stream\"; class ReadableStream extends stream.Readable { constructor() { super(); } _read(): void { setTimeout(() => { let n: number = Math.round(Math.random() * 20); n != 20 ? this.push(String(n) + \"\\n\") : this.push(null); }, 1000); } } const readableStream = new ReadableStream(); readableStream.pipe(process.stdout); 工作模式 细心的朋友可能会发现，我们的_read()方法中关于随机数的生成使用了setTimeout()，而没有使用setInterval()，但是当readableStream.pipe()时依旧会源源不断的产生随机数，这是为什么呢？ 其实流分为2种工作模式： 流动模式：由pipe()方法进行触发 暂停模式：由read()方法进行触发（默认的） 可以这么理解，当我们调用read()方法时，相当于把水龙头拧开之后马上关掉，每次只会流出一股水。 而当调用pipe()方法时，它内部会源源不断的调用readableStream._read()方法，相当于直接把水龙头拧开，直至蓄水池中的水被全部放掉后才会关闭水龙头，也就是说只有可读流不再产生新的数据后，pipe()方法才算运行完成，否则便会一直运行。 相关事件 我们可以对可读流进行事件监听： data事件：当可读流已经产生了数据时，将自动触发该事件并启用流动模式读取产生的数据 end事件：数据已经读取完成 error事件：数据读取失败了 如下示例演示： import * as stream from \"stream\"; class ReadableStream extends stream.Readable { constructor() { super(); } _read(): void { setTimeout(() => { let n: number = Math.round(Math.random() * 20); n != 20 ? this.push(String(n) + \"\\n\") : this.push(null); }, 1000); } } const readableStream = new ReadableStream(); readableStream.on(\"data\", (chunk: Buffer) => { // chunk = 本次被读取的数据 console.log(chunk.toString()); }) readableStream.on(\"end\", () => { console.log(\"读取完毕\"); }) readableStream.on(\"error\", () => { console.log(\"读取失败\"); }) 此外还有一个readable事件，它代表可读流已经产生了新的数据。 常用于和read()方法搭配使用，用于启用暂停模式的读取数据： import * as stream from \"stream\"; class ReadableStream extends stream.Readable { constructor() { super(); } _read(): void { setTimeout(() => { let n: number = Math.round(Math.random() * 20); n != 20 ? this.push(String(n) + \"\\n\") : this.push(null); }, 1000); } } const readableStream = new ReadableStream(); readableStream.on(\"readable\", () => { console.log(\"有数据了\"); let chunk: Buffer = readableStream.read(); if(chunk !== null){ console.log(chunk.toString()); } }) 可写流 基本创建 通过stream模块创建一个可写流，对其进行初始化的同时并实现_write()方法即可。 在进行可写流初始化时，可指定options，它是一个对象，以下是常用的设置项： objectMode：Boolean类型，默认是 false， 设置成true后writable.write()方法除了写入string和buffer外，还可以写入任意 JavaScript对象。 highWaterMark：Number类型，每次最多写入的数据量， Buffer的时候默认值16kb decodeStrings：Boolean类型，是否把传入的数据转成Buffer，默认是true 若想使用可写流，则需要调用write()方法，它指向了内部的_write()，共接收3个参数： chunk：写入的数据，默认是Buffer类型 encoding：如果数据是字符串，可以设置编码，buffer或者object模式会忽略 done：回调函数 如下所示，我们往自己的可写流中写入数据，然后将数据再写入到process.stdout的可写流中： import * as stream from \"stream\"; class WriteableStream extends stream.Writable { constructor(options?: { [key: string]: any }) { super(options); } _write(chunk: string | Buffer, encoding?: Buffer | string, done?: (err?: NodeJS.ErrnoException) => void): void { try { // Ts避免错误 encoding; process.stdout.write(chunk.toString()); if (done !== undefined) { done(); } } catch (e) { if (done !== undefined) { done(e); } } } } const writeableStream = new WriteableStream({ objectMode: false, highWaterMark: 16, decodeStrings: true }); writeableStream.write(\"hello\"); // buffer // hello 停止写入 数据写入完成后，应当调用end()方法，表示数据已经写入完成了： writeableStream.write(\"hello\"); writeableStream.end(); 它将会触发一系列的事件完成操作。 相关事件 我们可以对可写流进行事件监听： finish事件：数据已经写入完成 error事件：数据写入失败了 如下示例演示： import * as stream from \"stream\"; class WriteableStream extends stream.Writable { constructor(options?: { [key: string]: any }) { super(options); } _write(chunk: string | Buffer, encoding?: Buffer | string, done?: (err?: NodeJS.ErrnoException) => void): void { try { // Ts避免错误 encoding; process.stdout.write(chunk.toString()); if (done !== undefined) { done(); } } catch (e) { if (done !== undefined) { done(e); } } } } const writeableStream = new WriteableStream({ objectMode: false, highWaterMark: 16, decodeStrings: true }); writeableStream.write(\"hello world\"); writeableStream.end(); writeableStream.on(\"finish\", () => { console.log(\"写入完成\"); }) writeableStream.on(\"error\", () => { console.log(\"写入失败\"); }) Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-09-01 13:40:36 "},"前端专栏/Node.js/Web开发.html":{"url":"前端专栏/Node.js/Web开发.html","title":"Web开发","keywords":"","body":"http模块 简单使用 Node.js中内置的http模块可用于搭建HTTP服务器。 如下所示： import * as http from \"http\"; const hostname: string = \"localhost\"; const port: number = 3000; const server = http.createServer((request: http.IncomingMessage, response: http.ServerResponse) => { response.setHeader('Content-Type', \"text/http charset=utf-8\"); response.statusCode = 200; if (request.method === \"GET\") { response.end(\"/GET OK!\"); } else { response.end(\"/POST OK!\"); } }); server.listen(port, hostname, 128, () => { console.log(`server running success! http://${hostname}:${port}`); }); 代码释义： http.createServer()：创建一个HTTP服务器，需要指定一个callback，它将在请求来临时自动调用，callback具有2个参数req和res分别代指请求对象和响应对象 listen()：用于启动服务并监听指定端口，必须传入port、host，可选传入backlog和callback，callback会在服务器成功启动后自动调用 请求相关 以下是关于请求对象req的常用API，req是一个可读流的对象： api 描述 req.headers 返回请求头对象 req.method 返回本次请求的方式（GET、POST、DELETE、PUT 等） req.url 返回本次请求的地址 req.httpVersion 返回本次请求的HTTP版本 响应相关 以下是关于请求对象响应对象res的常用API，res是一个可写流的对象： api 描述 res.statusCode 用于设置响应的HTTP状态码 res.setHeader(name, value) 用于设置响应头 res.writeHead(statusCode [, StatusMessage[, headers]]) 发送响应首部，包含状态码、状态信息、响应头 res.getHeaders() 获取已设置的响应头副本 res.getHeaderNames() 获取已设置的HTTP响应头名称的列表 res.getHeader(name) 获取已设置的响应头 res.removeHeader(name) 删除已设置的响应头 res.hasHeader(name) 如果响应已设置该消息头，则返回true res.write(chunk) 用于向响应体中写入字符串或者buffer res.end(chunk) 用于结束本次响应，若指定chunk则相当于同时调用了write()方法 返回文件 如下示例将演示如何返回一个普通的资源文件，如HTML、CSS、JS文件： import * as http from \"http\"; import * as path from \"path\"; import * as fs from \"fs\"; const hostname: string = \"localhost\"; const port: number = 3000; const baseDir: string = path.join(__dirname, \"..\"); const templatesDir: string = path.join(baseDir, \"templates\"); const server = http.createServer((request: http.IncomingMessage, response: http.ServerResponse) => { if (request.method === \"GET\") { response.writeHead(200, { \"Content-Type\": \"text/html; charset=utf-8\", }); const indexPath: string = path.join(templatesDir, \"index.html\"); fs.createReadStream(indexPath).pipe(response); } else { response.writeHead(405); response.end(\"Method Not Allowed\"); } }); server.listen(port, hostname, 128, () => { console.log(`server running success! http://${hostname}:${port}`); }); 返回视频 如下示例将演示如何返回视频文件： import * as http from \"http\"; import * as path from \"path\"; import * as fs from \"fs\"; const hostname: string = \"localhost\"; const port: number = 3000; const baseDir: string = path.join(__dirname, \"..\"); const templatesDir: string = path.join(baseDir, \"templates\"); const staticsDir: string = path.join(baseDir, \"static\"); function index(request: http.IncomingMessage, response: http.ServerResponse) { console.log(request.httpVersion); response.writeHead(200, { \"Content-Type\": \"text/html; charset=utf-8\", }); const indexPath: string = path.join(templatesDir, \"index.html\"); fs.createReadStream(indexPath).pipe(response); } function getVideo(request: http.IncomingMessage, response: http.ServerResponse) { // 前端代码： // 与本地的staticDir路径做拼接，获取static目录下的/video/apple.mp4 const videoPath = path.join(staticsDir, (request.url || \"\").split(\"/static/\")[1]); const stat: fs.Stats = fs.statSync(videoPath); const fileSize = stat.size; const range: string = request.headers.range || \"\"; if (range) { // 后续的请求视频，浏览器会自动携带range请求头，包含当前播放的部分 const parts = range.replace(/bytes=/, \"\").split(\"-\"); const start = parseInt(parts[0], 10); const end = parts[1] ? parseInt(parts[1], 10) : fileSize - 1; // 计算新返回的视频流长度 const chunkSize: number = (end - start) + 1; // 根据视频流长度进行截取 const file: fs.ReadStream = fs.createReadStream(videoPath, { start, end }); // 返回当前响应的视频流长度，并且请求状态要置为206 response.writeHead(206, { 'Content-Type': 'video/mp4', 'Content-Range': `bytes ${start}-${end}/${fileSize}`, 'Accept-Ranges': 'bytes', 'Content-Length': chunkSize }); file.pipe(response); } else { // 第一次请求视频，请求头只返回请求视频的总长度，和一些数据 response.writeHead(200, { 'Accept-Ranges': 'bytes', 'Content-Length': fileSize, }); fs.createReadStream(videoPath).pipe(response); } } const server = http.createServer((request: http.IncomingMessage, response: http.ServerResponse) => { if (request.method === \"GET\") { const reqUrl: string = request.url || \"\"; switch (true) { case reqUrl === \"/\": index(request, (response)); break case reqUrl.includes(\"video\"): getVideo(request, response); break default: response.writeHead(404); response.end(\"Not Found\"); } } else { response.writeHead(405); response.end(\"Method Not Allowed\"); } }); server.listen(port, hostname, 128, () => { console.log(`server running success! http://${hostname}:${port}`); }); url模块 GET请求参数 推荐使用内置模块url对GET请求参数做出解析，如下所示，我们需要将request.url转成一个url对象，然后获取其中的URLSearchParams对象： import * as http from \"http\"; import * as url from \"url\"; const hostname: string = \"localhost\"; const port: number = 3000; const server = http.createServer((request: http.IncomingMessage, response: http.ServerResponse) => { if (request.method === \"GET\") { const urlIns: url.URL = new url.URL(request.url || \"\", `http://${hostname}:${port}`); const getParams: url.URLSearchParams = urlIns.searchParams; console.log(getParams); response.writeHead(200, { \"Content-Type\": \"text/plain;\" }); response.end(\"ok\"); } else { response.writeHead(405); response.end(\"Method Not Allowed\"); } }); server.listen(port, hostname, 128, () => { console.log(`server running success! http://${hostname}:${port}`); }); 以下是urlIns对象的结构： # requestURL : http://localhost:3000/?getParams1=v1&getParams2=v2 URL { href: 'http://localhost:3000/?getParams1=v1&getParams2=v2', origin: 'http://localhost:3000', protocol: 'http:', username: '', password: '', host: 'localhost:3000', hostname: 'localhost', port: '3000', pathname: '/', search: '?getParams1=v1&getParams2=v2', searchParams: URLSearchParams { 'getParams1' => 'v1', 'getParams2' => 'v2' }, hash: '' } POST请求参数 注意！如果前端发送的是POST请求可能请求体的内容一次性接受不完，此时后端需要监听可读流request对象进行接收。 请求体接收完成之后直接调用url模块下的URLSearchParams方法得到一个参数对象： import * as http from \"http\"; import * as url from \"url\"; const hostname: string = \"localhost\"; const port: number = 3000; const server = http.createServer((request: http.IncomingMessage, response: http.ServerResponse) => { if (request.method === \"POST\") { let data: string = \"\"; request.on(\"data\", (chunk: Buffer) => { data += chunk.toString(); }) request.on(\"end\", () => { const postParams: url.URLSearchParams = new url.URLSearchParams(data); console.log(postParams); response.writeHead(200, { \"Content-Type\": \"text/plain;\" }); response.end(\"ok\"); }) } else { response.writeHead(405); response.end(\"Method Not Allowed\"); } }); server.listen(port, hostname, 128, () => { console.log(`server running success! http://${hostname}:${port}`); }); 以下是postParams对象的结构： # requestURL : http://localhost:3000/ # requestBody : postParams1=v1 postParams2=v2 URLSearchParams { 'postParams1' => 'v1', 'postParams2' => 'v2' } 合并两者请求 有的时候在发送POST请求时，可能也会在地址栏中带入一些GET请求的参数。 此时我们就需要获取POST+GET的所有参数，可以将2个URLSearchParams对象进行合并，如下所示： import * as http from \"http\"; import * as url from \"url\"; const hostname: string = \"localhost\"; const port: number = 3000; const server = http.createServer((request: http.IncomingMessage, response: http.ServerResponse) => { let data: string = \"\"; request.on(\"data\", (chunk: Buffer) => { data += chunk.toString(); }) request.on(\"end\", () => { const getParams: url.URLSearchParams = new url.URL(request.url || \"\", `http://${hostname}:${port}`).searchParams; const postParams: url.URLSearchParams = new url.URLSearchParams(data); const queryParams: { [key: string]: any } = {}; getParams.forEach((v: string, k: string) => { queryParams[k] = v; }) postParams.forEach((v: string, k: string) => { queryParams[k] = v; }) console.log(queryParams); response.writeHead(200, { \"Content-Type\": \"text/plain;\" }); response.end(\"ok\"); }) }); server.listen(port, hostname, 128, () => { console.log(`server running success! http://${hostname}:${port}`); }); 如下，发送一次POST请求，并在地址栏中携带参数： # requestURL : http://localhost:3000/?getParams1=v1&getParams2=v2 # requestBody : postParams1=v1 postParams2=v2 { getParams1: 'v1', getParams2: 'v2', postParams1: 'v1', postParams2: 'v2' } mime模块 基本使用 我们可以安装一个mime模块，用于动态的获取请求中的MIME类型，判断所请求的是静态资源还是动态资源。 也可以自动的书写响应头Content-Type： $ npm install mime --save $ npm install --save @types/mime // 适用于TypeScript导包 示例演示： import * as http from \"http\"; import * as url from \"url\"; import * as mime from \"mime\"; const hostname: string = \"localhost\"; const port: number = 3000; const server = http.createServer((request: http.IncomingMessage, response: http.ServerResponse) => { // 获取请求的MIME类型 let urlIns: url.URL = new url.URL(request.url || \"\", `http://${hostname}:${port}`); console.log(mime.getType(urlIns.pathname)); let mimeType: string = mime.getType(urlIns.pathname) || \"\"; response.writeHead(200, { \"Content-Type\": mimeType }); response.end(\"ok\"); }); server.listen(port, hostname, 128, () => { console.log(`server running success! http://${hostname}:${port}`); }); 常见mime类型 以下例举常见的mime类型： 类型/字类型 扩展名 text/plain *.txt 或 其他文本文件 text/html .html 或 .htm text/css *.css text/javascript *.js application/json *.json image/gif *.gif image/png *.png image/jpeg .jpg 或 .jpeg image/bmp *.bmp image/webp *.webp image/svg+xml *.svg(矢量图) image/x-icon *.ico audio/wav *.wav audio/webm *.webm audio/ogg *.ogg audio/mpeg *.mp3 video/webm *.webm video/ogg *.ogg video/mp4 *.mp4 application/octet-stream .*（ 二进制流，不知道下载文件类型） EJS模块 模板渲染 下载EJS模块，生成模板文件： $ npm install ejs --save $ npm install @types/ejs // 适用于TypeScript导包 官方文档：点我跳转 模板文件如下，注意模板文件用ejs进行结尾，在模板文件中你可以输入任何JavaScript代码： // index.ejs Document { %> 后端渲染的视图函数如下： import * as http from \"http\"; import * as path from \"path\"; import * as ejs from \"ejs\"; const hostname: string = \"localhost\"; const port: number = 3000; const baseDir: string = path.join(__dirname, \"..\"); const templatesDir: string = path.join(baseDir, \"templates\"); const server = http.createServer((request: http.IncomingMessage, response: http.ServerResponse) => { if (request.method === \"GET\") { response.writeHead(200, { \"Content-Type\": \"text/html; charset=utf-8\", }); const indexPath: string = path.join(templatesDir, \"index.ejs\"); ejs.renderFile(indexPath, { unOrderList: [\"热门新闻\", \"热门评论\", \"实时资讯\"] }, (err: Error | null, str: string) => { if (err) throw err; response.end(str); }) } else { response.writeHead(405); response.end(\"Method Not Allowed\"); } }); server.listen(port, hostname, 128, () => { console.log(`server running success! http://${hostname}:${port}`); }); 相关语法 脚本标签： # 它将作用在后端服务器上 输出标签： 导入模板： 自定义分隔符： // 单个模板文件，将 改为 ejs.render('', {user: 'Jack'}, {delimiter: '?'}); // 全局，将 改为 ejs.delimiter = '$'; ejs.render('', {user: 'Jack'}); mysql模块 基本使用 如果想操纵mysql数据库，需要依赖第三方模块mysql： $ npm install mysql --save $ npm install @types/mysql --save // 适用于TypeScript导包 然后我们需要链接数据库： import * as mysql from \"mysql\"; const connection: mysql.Connection = mysql.createConnection({ host: \"localhost\", user: \"root\", password: \"\", database: \"db1\" }) connection.connect(); console.log(\"connection success\"); connection.end(); console.log(\"close connection\"); 新增记录 示例如下，我们的数据库db1中有一张空的userInfo表，在此基础上做操作。 import * as mysql from \"mysql\"; const connection: mysql.Connection = mysql.createConnection({ host: \"localhost\", user: \"root\", password: \"\", database: \"db1\" }) connection.connect(); console.log(\"connection success\"); // 使用 ? 进行占位 const sql: string = \"INSERT INTO db1.userInfo (name, age, gender) VALUES (?, ?, ?);\"; // 与 ? 一一对应，防止SQL注入 const params = [\"Jack\", \"18\", \"male\"]; connection.query(sql, params, (err: mysql.MysqlError | null, result: any) => { if (err) { console.log(err.message); throw err; } console.log(`Affected line: ${result.affectedRows}`); if (result.affectedRows > 0) { console.log(`Insert success, id: ${result.insertId}`); } else { console.log(`Insert fail`); } }) connection.end(); console.log(\"close connection\"); 删除记录 删除记录示例： import * as mysql from \"mysql\"; const connection: mysql.Connection = mysql.createConnection({ host: \"localhost\", user: \"root\", password: \"\", database: \"db1\" }) connection.connect(); console.log(\"connection success\"); // 使用 ? 进行占位 const sql: string = \"DELETE FROM db1.userInfo WHERE id=?\"; // 与 ? 一一对应，防止SQL注入 const params = 1; connection.query(sql, params, (err: mysql.MysqlError | null, result: any) => { if (err) { console.log(err.message); throw err; } console.log(`Affected line: ${result.affectedRows}`); if (result.affectedRows > 0) { console.log(`delete success`); } else { console.log(`delete fail`); } }) connection.end(); console.log(\"close connection\"); 更新记录 更新记录示例，以下是原有的数据： mysql> select * from userInfo; +----+------+-----+--------+---------------------+ | id | name | age | gender | create_time | +----+------+-----+--------+---------------------+ | 1 | Jack | 18 | male | 2021-08-30 17:23:44 | | 2 | Mary | 21 | female | 2021-08-30 17:24:53 | | 3 | Tom | 17 | male | 2021-08-30 17:24:53 | +----+------+-----+--------+---------------------+ 进行更新： import * as mysql from \"mysql\"; const connection: mysql.Connection = mysql.createConnection({ host: \"localhost\", user: \"root\", password: \"\", database: \"db1\" }) connection.connect(); console.log(\"connection success\"); // 使用 ? 进行占位 const sql: string = `UPDATE db1.userInfo SET name = ?, age = ? WHERE id = ?; `; // 与 ? 一一对应，防止SQL注入 const params = [\"Ken\", 22, 1]; connection.query(sql, params, (err: mysql.MysqlError | null, result: any) => { if (err) { console.log(err.message); throw err; } console.log(`Affected line: ${result.affectedRows}`); if (result.affectedRows > 0) { console.log(`update success`); } else { console.log(`update fail`); } }) connection.end(); console.log(\"close connection\"); 查询记录 查询记录示例： import * as mysql from \"mysql\"; const connection: mysql.Connection = mysql.createConnection({ host: \"localhost\", user: \"root\", password: \"\", database: \"db1\" }) connection.connect(); console.log(\"connection success\"); // 使用 ? 进行占位 const sql: string = `SELECT * FROM db1.userInfo WHERE id > ? `; // 与 ? 一一对应，防止SQL注入 const params = 1; connection.query(sql, params, (err: mysql.MysqlError | null, result: any) => { if (err) { console.log(err.message); throw err; } console.log(`select success! a total of ${result.length} records`); for (let row of result) { console.log(row.id, row.name, row.age, row.gender); } }) connection.end(); console.log(\"close connection\"); 模块封装 项目前瞻 http模块最大的缺点是在路由系统以及静态文件管理系统上。 它只提供了最基本的HTTP服务器所需要的功能，并未对此进行更高层次的封装，所以在此我们可以对其进行更高程度的封装，着重以下3个方面： 路由系统：用户可自己定义路由匹配规则，并限制视图函数处理的请求方式 参数获取：用户可以直接从req.queryParams中获取GET请求以及POST请求所发送的所有参数 静态资源响应：自动响应所请求的静态资源，并且如果请求的是一个视频文件，那么它会自动使用流返回该视频文件 以下是整个项目的目录结构： . ├── dist # 编译代码目录 │ ├── ... ├── node_modules │ ├── ... ├── package-lock.json ├── package.json ├── src # 源代码目录 │ └── server.ts ├── common # 公用组件，自定义模块 │ ├── advancedHttp.ts ├── static # 静态文件目录 │ ├── css │ │ └── index.css │ ├── img │ │ └── avatar.jpg │ ├── js │ │ └── index.ts │ └── video │ └── apple.mp4 ├── templates # 模板文件目录 │ └── index.ejs └── tsconfig.json 其次我们需要修改一下tsconfig.json文件： { \"include\": [ \"./src/**/*\", // 编译src目录下的所有ts文件 \"./static/js/**/*\", // 编译static/js/目录下的所有ts文件 \"./common/**/*\" // 编译common目录下的所有ts文件 ], \"exclude\": [ \"./src/test/**/*\", // 不编译src目录中test目录下所有的ts文件 ], \"compilerOptions\": { \"target\": \"ES6\", // 编译后生成的js版本为es6 \"module\": \"CommonJS\", // 模块使用规范为es6 \"lib\": [ // node环境中测试ts代码所需要使用的库 \"ES6\" ], \"outDir\": \"./dist\", // 编译后生成的js文件存放路径 \"allowJs\": true, // 二次编译js文件 \"checkJs\": true, // 验证js文件语法 \"removeComments\": true, // 编译后的js文件删除注释信息 \"noEmitOnError\": true, // 如果编译时出现错误，编译将终止 \"strict\": true, // 启用TypeScript的严格模式 \"alwaysStrict\": true, // 启用JavaScript的严格模式 \"noFallthroughCasesInSwitch\": true, // 检测switch语句块是否正确的使用了break \"noImplicitReturns\": true, // 检测函数是否具有隐式的返回值 \"noUnusedLocals\": true, // 检测是否具有未使用的局部变量 \"noUnusedParameters\": true, // 检测是否具有未使用的函数参数 \"allowUnreachableCode\": true, // 检测是否具有永远不会运行的代码 \"allowSyntheticDefaultImports\": false, // 允许从没有设置默认导出的模块中默认导入，仅用于提示，不影响编译结果 \"esModuleInterop\": false // 允许编译生成文件时，在代码中注入工具类 } } 具体实现 我们将所有的代码都写在./common/advancedHttp.ts文件中，为了尽量的简单，仅定义一个类： import * as http from 'http'; import * as url from 'url'; import * as mime from 'mime'; import * as path from 'path'; import * as fs from 'fs'; interface ServerRequest extends http.IncomingMessage { queryParams: { [key: string]: any }, } interface ServerResponse extends http.ServerResponse { mimeType: string; } type ViewType = (req: ServerRequest, res: ServerResponse) => void; interface RouterStructure { method: string[]; rule: string; view: ViewType; } type RequestRouter = RouterStructure[]; class HttpServer { public hostname: string; public port: number; public backlog: number; public router: RequestRouter; public baseDir: string; public templatesDir: string; public staticsDir: string; public server: http.Server; public addr: string; public request: ServerRequest | null; public response: ServerResponse | null; public pathName: string; constructor(hostname: string, port: number, router: RequestRouter, baseDir: string = \".\", templatesDir: string = \"./templates\", staticsDir: string = \"./static\", backlog?: number) { this.hostname = hostname; this.port = port; this.router = router; this.backlog = backlog || 128; this.baseDir = baseDir; this.templatesDir = templatesDir; this.staticsDir = staticsDir; this.server = http.createServer(this.handleRequestParams.bind(this)); this.addr = `http://${this.hostname}:${this.port}`; this.request = null; this.response = null; this.pathName = \"\"; } // 参数处理 handleRequestParams(req: http.IncomingMessage, res: http.ServerResponse): void { let data: string = \"\"; req.on(\"data\", (chunk: Buffer) => { data += chunk.toString(); }) req.on(\"end\", () => { let urlIns: url.URL = new url.URL(req.url || \"\", this.addr); const postParams: url.URLSearchParams = new url.URLSearchParams(data); const getParams: url.URLSearchParams = urlIns.searchParams; const queryParams: { [key: string]: any } = {}; getParams.forEach((v: string, k: string) => { queryParams[k] = v; }) postParams.forEach((v: string, k: string) => { queryParams[k] = v; }) // 封装request对象和response对象 this.pathName = urlIns.pathname; this.request = Object.assign(req, { queryParams }); this.response = Object.assign(res, { mimeType: mime.getType(this.pathName) || \"\" }); this.handleRequestRouter(this.request, this.response) }) } // 路由解析 handleRequestRouter(req: ServerRequest, res: ServerResponse) { let tag: boolean = false; // 匹配静态资源 if (this.pathName.includes(\"static\")) { tag = this.handleStaticRequest(req, res); } // 匹配动态资源 else { tag = this.handleDynamicRequest(req, res); } // 没有匹配到 if (!tag) { res.writeHead(404); res.end(\"Not Fund\"); } } // 静态请求处理 handleStaticRequest(req: ServerRequest, res: ServerResponse): boolean { const requestPath: string = this.pathName.split(\"/static/\")[1]; // 注意！如果是js文件，那么它存放的目录是./dist下，因为ts文件会先进行编译，不能直接在网页中进行使用 const realPath = res.mimeType.includes(\"application/javascript\") ? path.join(this.baseDir, \"dist\", path.basename(this.staticsDir), requestPath) : path.join(this.staticsDir, requestPath); if (fs.existsSync(realPath)) { switch (true) { // 请求的是视频文件 case res.mimeType.includes(\"audio\"): case res.mimeType.includes(\"video\"): const stat: fs.Stats = fs.statSync(realPath); const fileSize = stat.size; const range: string = req.headers.range || \"\"; if (range) { // 后续的请求视频，浏览器会自动携带range请求头，包含当前播放的部分 const parts = range.replace(/bytes=/, \"\").split(\"-\"); const start = parseInt(parts[0], 10); const end = parts[1] ? parseInt(parts[1], 10) : fileSize - 1; // 计算新返回的视频流长度 const chunkSize: number = (end - start) + 1; // 根据视频流长度进行截取 const file: fs.ReadStream = fs.createReadStream(realPath, { start, end }); // 返回当前响应的视频流长度，并且请求状态要置为206 res.writeHead(206, { 'Content-Type': 'video/mp4', 'Content-Range': `bytes ${start}-${end}/${fileSize}`, 'Accept-Ranges': 'bytes', 'Content-Length': chunkSize }); file.pipe(res); } else { // 第一次请求视频，请求头只返回请求视频的总长度，和一些数据 res.writeHead(200, { 'Accept-Ranges': 'bytes', 'Content-Length': fileSize, }); fs.createReadStream(realPath).pipe(res); } break // 请求的是其他文件，CSS、img、js等 default: res.writeHead(200, { \"Content-type\": res.mimeType, }); fs.createReadStream(realPath).pipe(res); } return true; } // 没找到静态文件 return false; } // 动态请求处理 handleDynamicRequest(req: ServerRequest, res: ServerResponse): boolean { for (let match of this.router) { if (this.pathName === match.rule) { if (match.method.includes(req.method || \"\")) { match.view(req, res); } else { res.writeHead(406); res.end(\"Method Not Allowed\"); } return true; } } return false; } // 启动服务 start(callback: () => void) { this.server.listen(this.port, this.hostname, this.backlog, callback.bind(this)); } } export { ServerResponse, ServerRequest, ViewType, RouterStructure, RequestRouter, HttpServer } 使用案例： import * as path from 'path'; import * as ejs from \"ejs\"; import * as advHttp from \"../common/advancedHttp\"; const baseDir: string = path.join(__dirname, \"..\"); const templateDir: string = path.join(baseDir, \"templates\"); const staticDir: string = path.join(baseDir, \"static\"); const host: string = \"localhost\"; const port: number = 3000; function index(req: advHttp.ServerRequest, res: advHttp.ServerResponse) { console.log(req.queryParams); console.log(res.statusCode); res.writeHead(200, { 'Content-Type': 'text/html charset=utf-8' }); ejs.renderFile(path.join(templateDir, \"index.ejs\"), { unOrderList: [\"first\", \"second\", \"third\"] }, (err: Error | null, str: string) => { if (err) throw err; res.end(str); }) } const router: advHttp.RequestRouter = [ { method: [\"GET\", \"POST\"], rule: \"/\", view: index }, ] const server: advHttp.HttpServer = new advHttp.HttpServer(host, port, router, baseDir, templateDir, staticDir); server.start(() => { console.log(`server running success! http://${host}:${port}`); }) Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-09-01 13:59:06 "},"前端专栏/Node.js/Koa框架.html":{"url":"前端专栏/Node.js/Koa框架.html","title":"Koa框架","keywords":"","body":"Koa 基本介绍 Koa是Node.js中非常出名的一款WEB框架，其特点是短小精悍性能强。 它由Express原版人马打造，同时也是Egg框架的设计蓝图，可以说Koa框架的学习性价比是非常高的。 官方文档 项目搭建 我们先初始化一个项目： $ npm init TypeScript可以让项目更加容易维护，所以安装TypeScript是不可或缺的一部分： $ npm install typescript ts-node @types/node peer dependencies yourself --save 当安装完成后，需要在根目录中新建src目录以及server.ts文件： $ mkdir ./src $ touch ./src/server.ts 下一步是填入TypeScript的配置文件： $ tsc --init 配置文件内容如下： { \"include\": [ \"./src/**/*\", // 仅编译src目录下的所有ts文件 ], \"exclude\": [ \"./src/test/**/*\", // 不编译src目录中test目录下所有的ts文件 ], \"compilerOptions\": { \"target\": \"ES6\", // 编译后生成的js版本为es6 \"module\": \"CommonJS\", // 编译后的模块使用规范为CommonJs \"lib\": [ // node环境中测试ts代码所需要使用的库 \"ES6\" ], \"outDir\": \"./dist\", // 编译后生成的js文件存放路径 \"allowJs\": true, // 二次编译js文件 \"checkJs\": true, // 验证js文件语法 \"removeComments\": false, // 编译后的js文件删除注释信息 \"noEmitOnError\": true, // 如果编译时出现错误，编译将终止 \"strict\": true, // 启用TypeScript的严格模式 \"alwaysStrict\": true, // 启用JavaScript的严格模式 \"noFallthroughCasesInSwitch\": true, // 检测switch语句块是否正确的使用了break \"noImplicitReturns\": true, // 检测函数是否具有隐式的返回值 \"noUnusedLocals\": false, // 检测是否具有未使用的局部变量 \"noUnusedParameters\": false, // 检测是否具有未使用的函数参数 \"allowUnreachableCode\": true, // 检测是否具有永远不会运行的代码 } } 由于Koa是第三方框架，所以你应该先安装它： $ npm install koa --save $ npm install @types/koa --save 快速上手 使用Koa框架搭建一个HTTP服务器非常的简单，你只需要以下几行代码即可搞定。 import * as Koa from \"koa\" const server: Koa = new Koa() server.use(async (ctx: Koa.Context) => { ctx.response.body = \"HELLO KOA!\"; }) server.listen(3000, \"localhost\", 128, (): void => { console.log(\"server started at http://localhost:3000\"); }) 级联操作 每一个视图函数中，都具有2个参数ctx和next，而通过next你可以实现级联操作。 如下所示，它将按顺序打印1、2、3、4、5： import * as Koa from \"koa\" const server: Koa = new Koa() server.use(async (ctx: Koa.Context, next: Koa.Next) => { const start: number = Date.now() console.log(\"1\"); await next() console.log(\"5\"); ctx.response.body = \"HELLO KOA!\" }) server.use(async (ctx: Koa.Context, next: Koa.Next) => { console.log(\"2\"); await next(); console.log(\"4\"); }) server.use(async (ctx: Koa.Context, next: Koa.Next) => { console.log(\"3\"); console.log(\"hello middleware\"); }) server.listen(3000, \"localhost\", 128, (): void => { console.log(\"server started at http://localhost:3000\"); }) 路由系统 koa-router 默认的Koa框架路由系统不是很完善，对此你可以使用koa-router插件，官方所提供的文档非常齐全，你可以自行前往查看，包括嵌套路由、动态路由等知识在官方文档里面都有详细的示例，这里不再阐述。 首先需要进行下载： $ npm install koa-router --save $ npm install @types/koa-router --save 然后就可以进行使用了，注意现在Middleware View Function的编写不再是通过server.use()进行注册了而是通过router.requestMethod()进行注册，代码如下： import * as Koa from \"koa\" import * as Router from 'koa-router' const server: Koa = new Koa() const router: Router = new Router() // 1. 装载插件 server.use(router.routes()) // 2.书写视图，注意后面都是编程router.requestMethod() router.get(\"/api/get\", async (ctx: Koa.Context, next: Koa.Next) => { // 3.等待之前的插件处理完成后再运行Middleware View Function await next() ctx.response.body = \"HELLO KOA!\" }) server.listen(3000, \"localhost\", 128, (): void => { console.log(\"server started at http://localhost:3000\"); }) 请求方式 koa-router能够限制请求方式，如下所示，其中all()方法能支持所有的请求： router .get('/', (ctx, next) => { ctx.body = 'Hello World!'; }) .post('/users', (ctx, next) => { // ... }) .put('/users/:id', (ctx, next) => { // ... }) .del('/users/:id', (ctx, next) => { // ... }) .all('/users/:id', (ctx, next) => { // ... }); 请求相关 ctx.request ctx是一个上下文对象，你可以通过ctx.request获得本次HTTP服务的请求对象。 在请求对象中它提供了很多属性可供我们使用，以下只例举一些比较常见的： 属性 简写 描述 ctx.request.header ctx.header 可获取或者设置请求头对象 ctx.request.headers ctx.headers 同上 ctx.request.method ctx.method 可获取或者设置请求方式 ctx.request.href ctx.href 可获取完整的href ctx.request.origin ctx.origin 仅获取协议、主机、端口号 ctx.request.host ctx.host 仅获取主机、端口号 ctx.request.hostname ctx.hostname 仅获取主机 ctx.request.url ctx.url 仅获取url部分 ctx.request.path ctx.path 仅获取path部分 ctx.request.query ctx.query 仅获取query部分 ctx.request.ip ctx.ip 获取请求的ip 结果如下： ctx.request.href http://localhost:3000/api/get?name=Jack ctx.request.origin http://localhost:3000 ctx.request.host localhost:3000 ctx.request.hostname localhost ctx.request.url /api/get?name=Jack ctx.request.path /api/get ctx.request.query { name: 'Jack' } params 对于动态的URL params，可以使用ctx.params获取，注意！这是vue-router所提供的一个方法，它并不存在于ctx.request对象中： import * as Koa from \"koa\" import * as Router from 'koa-router' const server: Koa = new Koa() const router: Router = new Router() server.use(router.routes()) router.get(\"/api/get/:id?\", async (ctx: Koa.Context, next: Koa.Next) => { await next() // http://localhost:3000/api/get/8?k1=v1 console.log(ctx.params.id); // 8 ctx.response.body = \"HELLO KOA!\" }) server.listen(3000, \"localhost\", 128, (): void => { console.log(\"server started at http://localhost:3000\"); }) get请求参数 对于URL中的query请求参数来说，你可以直接通过ctx.request.query进行获取： import * as Koa from \"koa\" import * as Router from 'koa-router' const server: Koa = new Koa() const router: Router = new Router() server.use(router.routes()) router.get(\"/api/get/:id?\", async (ctx: Koa.Context, next: Koa.Next) => { await next() // http://localhost:3000/api/get/8?k1=v1 console.log(ctx.request.query); // { k1: 'v1' } ctx.response.body = \"HELLO KOA!\" }) server.listen(3000, \"localhost\", 128, (): void => { console.log(\"server started at http://localhost:3000\"); }) post请求参数 对于请求体中的data请求参数来说，我们可以通过第三方插件koa-body来让它的获取更加的方便。 因为默认的ctx.request对象中没有获取请求体的方法，但是使用koa-body插件后它会向ctx.request中封装一个body属性，调用它你将会获得data请求参数对象。 要想使用koa-body插件，需要对其进行安装： $ npm install koa-body --save $ npm install @types/koa__cors --save 示例如下： import * as Koa from \"koa\" import * as Router from 'koa-router' import * as koaBody from \"koa-body\" const server: Koa = new Koa() const router: Router = new Router() server.use(router.routes()) server.use(koaBody({ // 是否支持 multipart-formdata 的表单 multipart: true, })) router.post('/api/post', async (ctx, next) => { // 等待之前的插件处理完成后再运行Middleware View Function // 否则你必须将server.use()的插件应用语句放在 // Middleware View Function的下面 await next() console.log(ctx.request.body); ctx.response.body = \"HELLO KOA!\" }); server.listen(3000, \"localhost\", 128, (): void => { console.log(\"server started at http://localhost:3000\"); }) 上传文件 koa-body插件同样支持对文件自动上传，如下所示，我们在使用之前需要对其进行一些小小的配置，在获取文件后它将自动进行上传。 我们可通过ctx.request.files参数获取文件对象，与ctx.request.body一样，它也是koa-body所封装的方法： import * as fs from \"fs\" import * as path from \"path\" import * as Koa from \"koa\" import * as Router from 'koa-router' import * as koaBody from \"koa-body\" const server: Koa = new Koa() const router: Router = new Router() server.use(router.routes()) server.use(koaBody({ // 是否支持 multipart-formdata 的表单 multipart: true, formidable: { // 上传的目录 uploadDir: path.join(__dirname, 'upload'), // 保持文件的后缀 keepExtensions: true, // 最大支持上传8M的文件 maxFieldsSize: 8 * 1024 * 1024, // 文件上传前的设置 onFileBegin: (name: string, file: any): void => { const filePath: string = path.join(__dirname, \"upload\"); // 检查是否有upload目录 if (!fs.existsSync(filePath)) { fs.mkdirSync(filePath); console.log(\"mkdir success!\"); } } } })) router.post('/api/upload', async (ctx, next) => { // 等待之前的插件处理完成后再运行Middleware View Function // 否则你必须将server.use()的插件导入语句放在 // Middleware View Function的下面 await next() // 获取文件对象avatar const avatar: any | null = ctx.request.files[\"avatar\"] // 自动写入... // 将上传后的信息自动返回 ctx.response.set(\"Content-Type\", \"application/json\") ctx.response.body = JSON.stringify(avatar) }); server.listen(3000, \"localhost\", 128, (): void => { console.log(\"server started at http://localhost:3000\"); }) 文件对象中包含的属性如下： { \"size\": 文件大小, \"path\": \"上传路径\", \"name\": \"文件原本的名字\", \"type\": \"image/jpeg\", \"mtime\": \"文件最后修改时间\" } koa-body配置 以下是koa-body在进行使用时的一级配置项： 参数名 描述 类型 默认值 patchNode 将请求体打到原生 node.js 的ctx.req中 Boolean false patchKoa 将请求体打到 koa 的 ctx.request 中 Boolean true jsonLimit JSON 数据体的大小限制 String / Integer 1mb formLimit 限制表单请求体的大小 String / Integer 56kb textLimit 限制 text body 的大小 String / Integer 56kb encoding 表单的默认编码 String utf-8 multipart 是否支持 multipart-formdate 的表单 Boolean false urlencoded 是否支持 urlencoded 的表单 Boolean true text 是否解析 text/plain 的表单 Boolean true json 是否解析 json 请求体 Boolean true jsonStrict 是否使用 json 严格模式，true 会只处理数组和对象 Boolean true formidable 配置更多的关于 multipart 的选项 Object {} onError 错误处理 Function function(){} stict 严格模式,启用后不会解析 GET, HEAD, DELETE 请求 Boolean true 以下是koa-body在进行使用时的二级（formidable）配置项： 参数名 描述 类型 默认值 maxFields 限制字段的数量 Integer 1000 maxFieldsSize 限制字段的最大大小 Integer 2 1024 1024 uploadDir 文件上传的文件夹 String os.tmpDir() keepExtensions 保留原来的文件后缀 Boolean false hash 如果要计算文件的 hash，则可以选择 md5/sha1 String false multipart 是否支持多文件上传 Boolean true onFileBegin 文件上传前的一些设置操作 Function function(name,file){} ctx.req ctx.request是Koa框架所封装的请求对象，而ctx.req则是原生的http库的请求对象。 我们不建议对其进行使用，具体所包含的属性可以参照http库中的req对象。 响应相关 ctx.response ctx是一个上下文对象，你可以通过ctx.response获得本次HTTP服务的响应对象。 在响应对象中它也提供了很多属性或者方法可供我们使用，以下只例举一些比较常见的： 属性/方法 简写 描述 ctx.response.header 无 可获取或者设置响应头对象 ctx.response.headers 无 同上 response.get() ctx.get() 可获取某个响应头字段 response.has() ctx.has() 可检测某个响应头字段是否存在 response.set() ctx.set() 用来设置单个响应头字段与值，也可用一个对象来设置多个响应头字段与值 response.remove() ctx.remove() 可删除某个响应头字段 ctx.response.body ctx.body 可获取或者设置响应体，可设置string、Buffer、Stream、Object或者Array的JSON字符串以及null ctx.response.status ctx.status 可获取或者设置响应码 ctx.response.message ctx.message 可获取或者设置响应信息，它与响应码相关联 ctx.response.redirect ctx.redirect 可进行重定向跳转 ctx.response.type ctx.type 获取或者设置响应的mime-type类型 设置响应码 响应码一般来说不需要我们手动设置，它的默认值大多数情况下总是200或者204. 如果你想手动进行设置，可参照下面这个示例： router.get(\"/api/get\", async (ctx: Koa.Context, next: Koa.Next) => { ctx.response.status = 403; ctx.response.message = \"Reject service\"; }) 设置响应头 如果你没有使用TypeScript来规范你的项目代码，则可以直接对响应头做出结构改变的操作： router.get(\"/api/get\", async (ctx: Koa.Context, next: Koa.Next) => { ctx.response.headers = { \"Content-Type\": \"text/plain; charset=utf-8\" }; ctx.response.body = \"HELLO KOA!\"; }) 如果你使用了TypeScript来规范你的项目代码，则必须通过ctx.response.set()方法来设置响应头： // 设置一个 ctx.response.set(k, v) ctx.response.set(\"Content-Type\", \"text/plain; charset=utf-8\"); // 设置多个 ctx.response.set({k1 : v1, k2 : v2, ...}) ctx.response.set({ \"Content-Type\": \"text/plain; charset=utf-8\", \"Token\" : \"=fdss9d9k!-=f23\" }); 重定向 对于需要跳转的路由，可以使用ctx.response.redirect()方法来进行跳转： import * as Koa from \"koa\" import * as Router from 'koa-router' const server: Koa = new Koa() const router: Router = new Router() server.use(router.routes()) router.get(\"/\", async (ctx: Koa.Context, next: Koa.Next) => { ctx.redirect(\"/index\"); ctx.response.status = 302; }) router.get(\"/index\", async (ctx: Koa.Context, next: Koa.Next) => { ctx.response.body = \"HELLO KOA!\"; }) server.listen(3000, \"localhost\", 128, (): void => { console.log(\"server started at http://localhost:3000\"); }) CORS跨域 利用第三方插件@koa/cors解决跨域问题： $ npm install @koa/cors 它的使用非常简单，直接server.use()即可，当然你也可以对其进行详细配置，这里不再进行配置举例： import * as Koa from \"koa\" import * as cors from \"@koa/cors\" const server: Koa = new Koa() server.use(cors()) 静态资源 利用第三方插件koa-static实现静态资源的下发： $ npm install koa-static 在使用时，你必须配置当前项目下的静态资源文件目录，当用户访问这个目录中的文件时就会直接将资源进行返回了： import * as static from \"koa-static\" import * as path from \"path\" const server: Koa = new Koa() // 静态资源目录对于相对入口文件index.js的路径 const staticPath = './static' app.use(static( path.join( __dirname, staticPath) )) 例如，我们想要获取./static/avatar.jpg，只需要用GET请求下面的url即可： GET http://localhost:3000/avatar.jpg ctx.res ctx.response是Koa框架所封装的响应对象，而ctx.res则是原生的http库的响应对象。 我们不建议对其进行使用，具体所包含的属性可以参照http库中的res对象。 jsonwebtoken 基本介绍 Koa框架中提供了Cookie相关的操作，但是Cookie在目前的项目开发中使用的比较少，故这里不再进行例举，而是推荐使用第三方插件jsonwebtoken来生成JWT进行验证。 如果你不了解JWT，我之前也有写过相关的技术文章，你可以搜索并进行参考。 现在我假设你已经了解过了JWT相关的知识，让我开始第一步，安装jsonwebtoken这个插件吧。 $ npm install jsonwebtoken --save 安装后之后我们需要在src目录中新建一个JWT目录以及一个index.js文件，用来JWT存放相关的代码： $ mkdir ./src/jwt $ touch ./src/jwt/index.ts 封装使用 一般的手动签发token我们需要用到下面3种类型的数据： header：头部信息，可定义加密类型、加密方式 playload：荷载信息，可定义token过期时间、签发者、接受者以及私有声明信息，但不建议存放敏感信息 secret：密钥，该密钥只能由服务端所知晓 但是jsonwebtoken对其进行封装，直接使用config来配置即可，以下是签发和验证token的案例，默认它将采用HASH256算法进行JWT格式封装： import * as JWT from \"jsonwebtoken\" // 服务端的字符串，绝对保密 const secret = \"=937dce32&?f99\" function issueToken(userID: number, userName: string, expiration: number = 86400 * 14) { // 定义荷载信息，不要存放敏感的诸如用户密码之类的数据 const playLoad = { id: String(userID), name: userName, } // 定义配置文件，下面有一些选项也是属于荷载信息的一部分，如过期时间、签发时间、面向谁签发的 const config = { // 定义头部信息 header: {}, // 过期时间、按秒计算，也可以是字符串，如1day、1min等 expiresIn: expiration, // 在签发后多久之前这个token是无用的，如果是数字则是按秒计算 notBefore: `120ms`, // 面向谁签发的 audience: userName, // 发行者是谁 issuer: \"Node.js KOA\", // 该token的发布主题 subject: \"demo\", // 不使用时间戳 noTimestamp: true, } // 第一个对象中也可以添加额外的属性，它将作为荷载信息被格式化 return JWT.sign(playLoad, secret, config) } function verifyToken(token: string | string[]): { verify: boolean, playLoad: { id: string, name: string, nbf: number, exp: number, aud: string, iss: string, sub: string } | null } { // 如果没有抛出异常，则验证成功 try { return { playLoad: JWT.verify(token, secret), verify: true } } // 如果抛出了异常，则验证失败 catch { return { playLoad: null, verify: false } } } export { issueToken, verifyToken } 使用案例： // 手动传入用户ID以及用户姓名还有token过期时间 const token = issueToken(19, \"Jack\", 7); // 传入token验证是否成功 console.log(verifyToken(token)); 验证成功返回的结果： { playLoad: { id: '19', name: 'Jack', nbf: 1633537512, exp: 1633537519, aud: 'Jack', iss: 'Node.js KOA', sub: 'demo' }, verify: true } 实战演示 我们以一个简单的案例来进行说明，后端有2个api接口，分别是index和login。 若用户第一次访问主页，则必须先进行登录后才能访问主页，此后的20s内用户不用再重新登录： import * as Koa from \"koa\" import * as Router from 'koa-router' import * as koaBody from 'koa-body' import * as cors from \"@koa/cors\" import * as JWT from \"./jwt/index\" // 模拟数据库 const userDataBase: { id: number, username: string, password: string, age: number }[] = [ { id: 1, username: \"Jack\", password: \"123456\", age: 18 } ] const server: Koa = new Koa() const router: Router = new Router() server.use(cors()) server.use(koaBody({ // 是否支持 multipart-formdata 的表单 multipart: true, })) server.use(router.routes()) server.use(async (ctx: any, next: any) => { await next() // 由于所有返回的数据格式都是JSON，故这里直接进行生命 ctx.response.set(\"Content-Type\", \"application/json\"); }) router.get(\"/api/index\", async (ctx: Koa.Context, next: Koa.Next) => { await next() const token: string | string[] = ctx.request.get(\"JWT\"); // 如果能获取token就进行验证，判断是否是伪造请求 if (token) { const { verify, playLoad } = JWT.verifyToken(token) if (verify) { // 验证通过，直接返回playLoad给前端 ctx.response.body = JSON.stringify({ code: 200, message: playLoad }) } else { // 验证未通过，token无效或者已过期 ctx.response.body = JSON.stringify({ code: 403, message: \"Please do not forgery information\" }) } } // 获取不到token，你应该先进行登录 else { ctx.response.body = JSON.stringify({ code: 401, message: \"please log in first\" }) } }) router.post(\"/api/login\", async (ctx: Koa.Context, next: Koa.Next) => { await next() const name: string = ctx.request.body.name; const pwd: string = ctx.request.body.pwd; // 如果用户存在于数据库中，就签发token，并且设置在响应头中返回 for (const row of userDataBase) { if (row.username === name && row.password === pwd) { const token = JWT.issueToken(row.id, row.username, 20); // 设置响应头JWT ctx.response.set(\"JWT\", token); ctx.response.body = JSON.stringify({ code: 200, message: \"login successful\" }); return } } // 用户不存在 ctx.response.body = JSON.stringify({ code: 406, message: \"Login error, username or password is incorrect\" }) }) server.listen(3000, \"localhost\", 128, (): void => { console.log(\"server started at http://localhost:3000\"); }) 代码测试 下面我们使用postMan来测试一下这个功能过程。 首先是用户第一次到我们的网站尝试访问主页，此时会提示它应该先进行登录： 然后我们进行登录，下面是登录错误的情况，数据库没有这个用户： 下面是登录成功后的情况，它会返回给你一个JWT的响应字段： 我们需要复制这个JWT响应字段的value值，并且将它添加到访问index时的请求头里，注意请求头的字段也必须是JWT，因为我们的后端做了限制，那么接下来的20s内你对index的访问都将是正常的： 如果token过期或者被伪造，它将提示你不要伪造token，其实这里有心的朋友可以处理的更细节一点： 其他插件推荐 好了，关于Koa框架的基本使用目前就到此结束了。 下面推荐一些Koa框架中可能会被使用到的插件： koa-compress：用于压缩内容，以便更快的完成HTTP响应 koa-logger：提供日志输出 koa-view：提供视图模板渲染，适用于前后端混合开发 koa-jwt：也是一款提供JWT认证的插件，不同于jsonwebtoken，它的局限性比较清 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-10-09 17:21:56 "},"前端专栏/Vue3/summary.html":{"url":"前端专栏/Vue3/summary.html","title":"Vue3","keywords":"","body":" 基础知识 mustache 基本指令 v-bind操作属性样式 methods和computed v-on事件监听 v-for和v-if v-model双向绑定 watch数据侦听 数组响应 组件化开发 组件中通信 组件化插槽 生命周期函数 动画效果 自定义指令 Mixins teleport传送门 CompositionAPI Vue-CLI Vue-Router Vue-X axios 其他资源 一个案例 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-10-13 15:31:26 "},"前端专栏/Vue3/基础知识.html":{"url":"前端专栏/Vue3/基础知识.html","title":"基础知识","keywords":"","body":"基本介绍 Vue.js Vue是一款优秀的前端开源框架，也是现在WEB工程师必备的一项技能。 它是一个渐进式的框架，所谓渐进式是指你可以对你的项目代码进行分批次的重构，比如最开始你的项目中所有页面的代码全部是由jQuery构建的，如果想将其重构为Vue的话则可以对某一些页面进行重写，这并不会影响其他页面的正常使用。 目前，Vue3正式版已经推出了有一些时间了，那么本专栏就是基于Vue3开始的一个新系列，希望能对大家带来帮助，案例统一采用Vue3新语法进行演示，从Options API（选项式API）逐渐过渡到Composition API（组合式API），在此期间如遇见2个版本之间常见的差异，也会指出来。 安装方式 如果你构建的是一个工程化项目，推荐使用npm进行Vue的安装： # 最新稳定版 $ npm install vue 如果你正在学习Vue3，推荐使用非工程化的脚本引入式开始Vue的探究： 下面再放上一个Vue2的CDN引入： Vue特点 声明式编程 使用Vue开发和jQuery开发是两种截然不同的体验，Vue是声明式的编程语言，而jQuery是命令式的编程语言。 使用jQuery你可能会经常想，下一步我该怎么做，从细节到全局。 但是使用Vue则是会有一个很良好的全局观，是由全局到细节的。 这里不多说明，后续将会慢慢体会。 单页面开发 Vue是单页面开发，即页面用不刷新，用一个页面来展示不同的内容。 在Vue中有一个组件的概念。一个页面上有一个根组件，并且其中包含很多子组件，通过用户不同的操纵状态由Vue决定展示或隐藏哪些其内部的子组件。 这其实就是单页面开发的概念，如图所示，子组件是可以自由替换的，但是根组件是不变的，这样就能达到不刷新页面也能更新内容的方式，像这样的单页富应用程序也被称为SPA： 简单体验 初次上手 下面是使用Vue3打印hello world的一个案例，通过这个小案例你可以简单体会声明式编程与命令式编程两种截然不同的风格。 首先要创建一个Vue应用 使用mount()来挂载元素，mount()中支持通过CSS选择器来拿到原生的DOM元素，注意！它不支持挂载或者 将需要展示的数据定义在data中，data必须是一个函数，且返回一个对象 使用Vue的mustache语法对data中返回对象的数据进行渲染，将其展示到被挂载元素的模板上 示例如下： {{message}} \"use strict\"; const app = Vue.createApp({ data() { return { message: \"hello world\" } } }).mount(\"#app\"); 如果你使用的是Vue2版本，则运行上面的小案例可能会出现一些问题，Vue2中虽然标签全局导入了Vue对象，但它是一个构造函数，你必须通过new来实例化该对象，并且通过mount()方法的元素挂载要变为通过el的属性元素挂载： {{message}} \"use strict\"; const app = new Vue({ el: \"#app\", data() { return { message: \"hello world\" } } }); data data我们可以将其理解为数据仓库，它存储了页面中需要用到的所有数据。 大体可分为2类： 需要展示的数据 需要提交的数据 在Vue3中，data必须是一个函数，且返回一个对象： const app = Vue.createApp({ data() { return { message: \"hello world\" } } }).mount(\"#app\"); 但是在Vue2中，它可以直接定义成一个对象，这在Vue3中是不被支持的： const app = new Vue({ el: \"#app\", data: { message: \"hello world\" } }); 当然Vue2中也支持Vue3里对data的定义形式： const app = new Vue({ el: \"#app\", data(){ return { message: \"hello world\" } } }); 为什么Vue2和Vue3会有这2种差别呢？其实这里涉及到后面要学习的一个组件化开发的知识，Vue2中将data定义成一个对象的方式虽然是允许的，但是会出现一些问题，所以干脆Vue3中不支持这种定义方法了，算是一个小小的改动。 在后面组件化开发中会详细提到。 代理器 Vue中大量使用了对象代理Proxy，如下所示，message明明是data函数中返回的对象属性，但是我们却可以通过Vue应用app对其进行访问： 对象代理不光在此处得以体现，在其他地方也会见到。 如下示例，我们为按钮增加了一个事件，当点击按钮后，的文本数值会发生变化： 仔细观察下面的代码我们也可以看到，当事件触发后，在methods对象的事件回调方法中调用this，也会被代理到data函数中返回的对象： body { display: flex; justify-content: center; align-items: center; } p { text-align: center; } {{number}} + - \"use strict\"; const app = Vue.createApp({ data() { return { number: 0 } }, methods: { add(event) { this.number++; }, sub(event) { this.number--; } } }).mount(\"#app\"); MVVM MVVM是Model-View-ViewModel的缩写，它是一种软件设计思想。 View：视图层（UI界面） ViewModel：业务逻辑层（一切JavaScript代码均可视为存在于该层中） Model：数据层（存储数据及的数据的处理相关的地方） 当Vue通过对DOM元素进行事件监听后，则可以动态的从后端服务器获取数据，同时被监听的DOM元素当状态发生改变时，也将通过Vue把信息传递给后端服务器。 对于上述代码来说，我们可以进行如下的划分： View视图层：被挂载元素的模板，即#app中的内容均属于视图层 ViewModel模型层：整个标签中的内容，均可属于模型层 Model数据层：Vue应用中data返回的对象可属于数据层 开发工具 devtool 学习Vue时，推荐安装Vue.js devtools工具，能高效的让我们更加探究Vue的变化。 Vue3和Vue2都支持的版本，推荐安装。 点我跳转至Chrome商店 仅支持Vue2的版本。 点我跳转至Chrome商店 在下载安装完成后，我们需要重新打开Chrome，然后按下F12在控制台即可看到它的选项： vscode 如果你使用vscode进行开发，那么下面的这个插件是我强烈推荐的： Vetur – 支持语法高亮、智能感知、Emmet等功能 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-10-09 22:30:50 "},"前端专栏/Vue3/mustache.html":{"url":"前端专栏/Vue3/mustache.html","title":"mustache","keywords":"","body":"mustache 名称由来 mustache本意为胡子的意思，因其Vue中模板渲染语法格式长的比较像2片胡子，故便有了这样的名字： {{变量}} 当使用mustache语法对模板进行渲染操作时，Vue内部会查找数据层中是否具有该变量，如果有则将该变量的值替换到模板上。 它与后端语言中的模板渲染非常的相似，如果你有前后端混合式开发的经验，那么掌握它应该再轻松不过了。 初学者应当注意一点，只有在被挂载的元素下才可使用mustache语法，如果在被挂载元素之外使用mustache语法是不生效的。 内容渲染 如下所示，我们通过mustache渲染出一个基本的个人信息： name : {{information.name}} age : {{information.age}} gender : {{information.gender}} \"use strict\"; const app = Vue.createApp({ data() { return { information: { name: \"Jack\", age: 19, gender: \"male\" } } } }).mount(\"#app\"); 四则运算 在mustache语法中，可以进行四则运算，如下所示： {{x + y}} \"use strict\"; const app = Vue.createApp({ data() { return { x : 100, y : 200 } } }).mount(\"#app\"); 调用方法 mustache语法中也能够调用方法，总之{{}}中可以进行任何操作，他都会向当前Vue应用去请求获取这些属性或方法： {{show()}} \"use strict\"; const app = Vue.createApp({ methods: { show() { return \"Yes\"; } } }).mount(\"#app\"); 响应式渲染 当Vue中的属性发生更改时，会响应到页面中，此时Vue会重新渲染DOM，响应式的前端框架也是Vue的一大特色： 代码如下： {{ name }} \"use strict\"; const app = Vue.createApp({ data(){ return { name : \"Jack\" } } }).mount(\"#app\"); 版本差异 废弃的过滤器 在Vue2的版本中提供了过滤器的选项，旨在让模板的渲染具有更多的可能性。 但由于功能过于鸡肋，于是在Vue3版本中移除了。 全局过滤器 全局过滤器可以由所有的的Vue组件使用。它应当定义在Vue.filter()中，且是一个函数，使用mustache语法时加上|即可主动完成调用。 {{currentTime | timeFormat}} \"use strict\"; Vue.filter(\"timeFormat\", value => { // value就是 | 左边的值 return moment(value).format(\"YYYY-MM-DD HH:mm:ss\"); }) const app = new Vue({ el: \"#app\", data() { return { currentTime: new Date() } } }) 局部过滤器 局部过滤器仅能由当前的的Vue组件使用。它应当定义在Vue示例中，关键字为filters，且是一个对象，使用mustache语法时加上|即可主动调用filters下的方法。 {{currentTime | timeFormat}} \"use strict\"; const app = new Vue({ el: \"#app\", data() { return { currentTime: new Date() } }, filters: { timeFormat(value) { // value就是 | 左边的值 return moment(value).format(\"YYYY-MM-DD HH:mm:ss\"); } } }) 过滤器参数 过滤器函数中的第一个参数固定死为|左边的值。 当我们有多个参数时，可以进行如下的传递方式，下面的示例将计算七天后的时间是多久： {{currentTime | addTime(7,\"days\")}} \"use strict\"; const app = new Vue({ el: \"#app\", data() { return { currentTime: new Date() } }, filters: { addTime(value, ...arg) { // value就是 | 左边的值,arg是右边的两个值 return moment(value).add(...arg).format(\"YYYY-MM-DD HH:mm:ss\"); } } }) Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-09-15 20:28:12 "},"前端专栏/Vue3/基本指令.html":{"url":"前端专栏/Vue3/基本指令.html","title":"基本指令","keywords":"","body":"什么是指令 指令 (Directives)是指带有v-开头的元素属性，这些属性都是由Vue所提供的，具有特殊的含义及用途。 在Vue解析模板时，如果发现某个DOM元素上具有Vue指令，则会对其进行特殊处理。 v-once 当标签中添加v-once指令时，标签渲染的内容将是固定的，页面不会随着数据层数据的动态改变而进行响应式的改变。 代码示例： div:not([v-once]) span { font-style: normal; } div[v-once] span { font-style: italic; } {{number}} {{number}} \"use strict\"; const app = Vue.createApp({ data() { return { number: 100 } } }).mount(\"#app\"); v-text 使用v-text指令和mustache语法渲染内容并无太大差异，它们的渲染结果都是相同的，唯一区别在于一个是通过指令渲染内容，一个是通过mustache语法渲染内容： {{message}} 注意，无论是mustache语法还是v-text指令，如果被渲染的内容是一个HTML字符串，它们将不会进行解析操作，而是将 这样做的意义在于防范XSS攻击： 代码示例： {{content}} \"use strict\"; const app = Vue.createApp({ data() { return { content : \"hello world\" } } }).mount(\"#app\"); v-html 如果被渲染的内容是一个HTML字符串，我们想让它生效则可使用v-html指令进行渲染。 使用方式和v-text一致，但是渲染结果会有不同： 代码示例： \"use strict\"; const app = Vue.createApp({ data() { return { content : \"hello world\" } } }).mount(\"#app\"); v-show v-show指令的值为false时，相当于将该标签添加上display:none的样式： 代码示例： {{message}} \"use strict\"; const app = Vue.createApp({ data() { return { message: \"hello world\", status: true } } }).mount(\"#app\"); v-pre 当一个标签添加上该指令后，该标签的内容将不会被Vue进行渲染，即使你在该标签内部使用了mustache语法。 代码示例： {{message}} {{message}} \"use strict\"; const app = Vue.createApp({ data() { return { message: \"hello world\" } } }).mount(\"#app\"); v-cloak 在网络情况较差的环境下，可能会出现模板渲染不及时的问题。 使用v-cloak指令搭配css样式可挡住{{}}模板语法，使用户获得更好的体验。 注意，在工程化的Vue项目中，v-clock默认是手动开启的，并不需要我们额外的做单独的配置 这也侧面说明v-clock实际上在真正生产开发时使用的很少 代码示例，你可以通过取消#app的v-cloak指令来查看不同的效果： [v-cloak]{ display: none; } {{message}} \"use strict\"; setTimeout(() => { const app = Vue.createApp({ data() { return { message: \"hello world\" } } }).mount(\"#app\"); }, 3000); Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-09-25 20:10:30 "},"前端专栏/Vue3/v-bind操作属性样式.html":{"url":"前端专栏/Vue3/v-bind操作属性样式.html","title":"v-bind操作属性样式","keywords":"","body":"属性绑定 v-bind 通过v-bind指令可以单向的为模板元素的属性动态绑定一个属性值，在使用时应当注意以下2点： 被双引号包裹的属性值没有被任何其他引号包裹时，该值将会被认为是Vue应用中数据层的某一个数据，会在Vue应用中先查找该数据再进行赋值 被双引号包裹的属性值同时还被其他引号所包裹时，该属性值将会被认为是一个普通的字符串，会直接进行赋值 如下示例。 1）被双引号包裹的属性值没有被任何其他引号包裹时，将访问data方法中返回的对象里的desc属性： ??? --> ??? \"use strict\"; const app = Vue.createApp({ data() { return { desc: \"this is a div\" } } }).mount(\"#app\"); 2）被双引号包裹的属性值同时还被其他引号所包裹时，该属性值将被当做普通字符串处理： ??? --> ??? \"use strict\"; const app = Vue.createApp({ data() { return { desc: \"this is a div\" } } }).mount(\"#app\"); 简写形式 我们可以省略v-bind的前缀，直接采用:进行绑定，如下所示： ??? ??? 样式操作 :class对象操作 将:class的属性值定义为一个对象，若key的value为true，则将该key进行应用，反之则不进行应用。 除此之外，你也可以定义class属性，用于设置一些永远不会改变的样式。 语法格式如下： 内容 在下面的例子中，我们定义了.red、.italic、.opacity三个类，通过:class对象中不同key的状态切换，可以达到不同的样式效果： 代码示例： .red { color: red; } .italic { font-style: italic; } .opacity { opacity: 0.5; } hello world \"use strict\"; const app = Vue.createApp({ data() { return { redStatus: true, italicStatus: true, opacityStatus: true, } } }).mount(\"#app\"); :class数组操作 将:class的属性值定义为一个数组，数组中的元素将被当做类名进行应用。 使用场景一般较少，语法格式如下： 内容 我更喜欢将它这样进行使用： 代码示例： .red { color: red; } .italic { font-style: italic; } .opacity { opacity: 0.5; } hello world \"use strict\"; const app = Vue.createApp({ data() { return { styleClass: [\"red\", \"opacity\", \"italic\"] } } }).mount(\"#app\"); :style对象操作 将:style的属性值定义为一个对象，key为css的样式名，value为css的设置值。 除此之外，你也可以定义style属性，用于设置一些永远不会改变的样式。 注意它的格式是这样的，:style中的key必须为小驼峰式命名法，如果你对key进行了引号包裹，则可以使用-分割命名： 内容 示例演示： 代码示例： hello world \"use strict\"; const app = Vue.createApp({ data() { return { bgStyle:\"linear-gradient(90deg, #667eea 0%, #764ba2 100%)\" } } }).mount(\"#app\"); :style数组操作 除开可以使用对象语法绑定:style属性，也可以通过数组语法进行绑定。 数组中的元素必需是能够从Vue实例中获取到的数据。 示例演示： 代码示例： hello world \"use strict\"; const app = Vue.createApp({ data() { return { fontStyle: { \"font-size\": \"24px\", \"font-style\": \"italic\" }, ColorStyle: { \"color\": \"red\", \"background-color\": \"green\" }, } } }).mount(\"#app\"); Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-09-25 21:12:36 "},"前端专栏/Vue3/methods和computed.html":{"url":"前端专栏/Vue3/methods和computed.html","title":"methods和computed","keywords":"","body":"methods 基本使用 methods中定义的方法通常都是搭配事件监听做回调的，当然我们也可以主动的对其进行调用。在使用时需要注意以下2点： methods下所定义的方法必须加括号才能完成调用 methods对象内部的方法如果想调用同一Vue应用下的方法或者属性，可使用this进行调用，Vue内部会通过代理器进行查找 如下示例，我们将计算书籍的总价格： 代码示例： books total price: {{getTotalPrice()}} \"use strict\"; const app = Vue.createApp({ data() { return { bookList: [ { name: \"JavaScript\", price: 69 }, { name: \"HTML5\", price: 43 }, { name: \"CSS3\", price: 58 } ], } }, methods: { getTotalPrice() { return this.bookList.reduce((pre, cur, index, ary) => { return pre + cur.price; }, 0); } } }).mount(\"#app\"); computed 基本使用 总价格更像是一个属性，而并非是一个方法，所以针对需要有复杂计算的数据结果，我们可以在Vue应用中定义computed计算属性，再交由mustache进行渲染。 在使用时需要注意以下2点： computed下所定义的方法在mustache渲染时不需要加括号就能调用，因此它更像是一个方法 computed对象内部的方法如果想调用同一Vue应用下的方法或者属性，可使用this进行调用，Vue内部会通过代理器进行查找 如下示例，我们将计算书籍的总价格： 代码示例： books total price: {{totalPrice}} \"use strict\"; const app = Vue.createApp({ data() { return { bookList: [ { name: \"JavaScript\", price: 69 }, { name: \"HTML5\", price: 43 }, { name: \"CSS3\", price: 58 } ], } }, computed: { totalPrice(){ return this.bookList.reduce((pre, cur, index, ary)=>{ return pre + cur.price }, 0) } } }).mount(\"#app\"); 实现原理 computed的内部实现原理是定义了getter方法实现的，我们可以对它进行复现： \"use strict\"; let bookShop = { bookList: [ { book_name: \"JavaScript\", price: 99 }, { book_name: \"CSS3\", price: 80 }, { book_name: \"HTML5\", price: 72 }, ], get total() { return this.bookList.reduce((prev, cur, index, array) => { return prev + cur.price; }, 0) } }; console.log(bookShop.total); // 251 其实使用Proxy全局对象代理可能会更好一些，如下所示： \"use strict\"; const Vue = { data() { return { bookList: [ { name: \"JavaScript\", price: 69 }, { name: \"HTML5\", price: 43 }, { name: \"CSS3\", price: 58 } ], } }, computed: { totalPrice() { return this.bookList.reduce((pre, cur, index, ary) => { return pre + cur.price }, 0) } }, methods: { getTotalPrice() { return this.bookList.reduce((pre, cur, index, ary) => { return pre + cur.price }, 0) } } } const app = new Proxy(Vue, { // 包含属性和方法以及计算属性 dataObject: Object.assign(Vue.data(), Vue.methods, Vue.computed), get(obj, attribute) { // 如果访问的是属性和方法，则直接返回 if (attribute in obj.data() || attribute in obj.methods) { return this.dataObject[attribute] } // 如果是计算属性，则自动调用 else if (attribute in obj.computed) { return this.dataObject[attribute]() } }, set(_, attribute, value) { dataObject[attribute] = value; return true; } }); app.bookList[0].price = 100; console.log(app.bookList); console.log(app.totalPrice); console.log(app.getTotalPrice()); // [ // { name: 'JavaScript', price: 100 }, // { name: 'HTML5', price: 43 }, // { name: 'CSS3', price: 58 } // ] // 201 // 201 指定get/set computed中可以指定一个对象，该对象必须提供get和set方法。 get：当获取该computed时自动触发 set：当设置该computed时自动触发，value属性为设置的新值 示例如下，当获取number时实际上获取的是_n，当设置number时实际上是设置的_n： {{number}} \"use strict\"; const app = Vue.createApp({ data() { return { _n: 100 } }, computed: { number: { get() { return this._n }, set(value) { this._n = value } } } }).mount(\"#app\"); 两者异同 同-响应特性 如果修改了数据源，那么计算属性和方法都会重新进行页面渲染。 如下所示，书籍总价本来为170，当我们修改其中任意一本书的价格后，书籍总价格也将发生改变： 代码示例： computed price: {{totalPrice}} methods price: {{getTotalPrice()}} \"use strict\"; const app = Vue.createApp({ data() { return { bookList: [ { name: \"JavaScript\", price: 69 }, { name: \"HTML5\", price: 43 }, { name: \"CSS3\", price: 58 } ], } }, computed: { totalPrice() { return this.bookList.reduce((pre, cur, index, ary) => { return pre + cur.price }, 0) } }, methods: { getTotalPrice() { return this.bookList.reduce((pre, cur, index, ary) => { return pre + cur.price }, 0) } } }).mount(\"#app\"); 异-缓存特性 computed具有缓存特性，即多次调用只会调用一次，只有当数据源发生改变时才会自行调用一次。 而methods没有缓存特性，调用几次就执行几次，并且当数据源发生改变时也会自动调用之前的次数。 如下所示，下面模板中3次调用了computed，实际上它只执行了1次，而methods同样也是3次调用，但是执行了3次，当数据源发生改变后computed会多加1次，而methods会每一个都重新执行1次，总计为新增3次： 代码示例： computed total : {{total}} computed total : {{total}} computed total : {{total}} computed call count : {{ccc}} methods getTotal : {{getTotal()}} methods getTotal : {{getTotal()}} methods getTotal : {{getTotal()}} methods call count : {{mcc}} \"use strict\"; let computedCallCount = 0; let methodsCallCount = 0; const app = Vue.createApp({ data() { return { num1: 100, num2: 100, ccc: computedCallCount, mcc: methodsCallCount, } }, computed: { total() { computedCallCount++; this.ccc = computedCallCount; return this.num1 + this.num2; } }, methods: { getTotal() { methodsCallCount++; this.mcc = methodsCallCount; return this.num1 + this.num2; } } }).mount(\"#app\"); Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-09-25 21:20:44 "},"前端专栏/Vue3/v-on事件监听.html":{"url":"前端专栏/Vue3/v-on事件监听.html","title":"v-on事件监听","keywords":"","body":"事件监听 v-on 通过v-on可对DOM元素进行事件监听，当用户某一行为触发后将自动执行mthods中定义的方法。 语法格式如下，当无参数进行传递时，可省略括号的书写： 点我 下面是一个小案例： 代码示例： + &nbsp;{{number}}&nbsp; - \"use strict\"; const app = Vue.createApp({ data() { return { number: 0 } }, methods: { add() { this.number++; }, sub() { this.number--; } } }).mount(\"#app\"); 简写形式 我们可以省略v-on:的前缀，使用@来进行代替，如下所示： 点我 注意区分与v-bind的区别： 点我 ??? 事件对象 无参调用与事件对象 当没有参数进行传递时，回调函数默认接收一个形参即Event事件对象： click me \"use strict\"; const app = Vue.createApp({ methods: { callback(event) { console.log(event); } } }).mount(\"#app\"); $event与事件对象 当有参数进行传递时，我们必须手动传入事件对象，且事件对象必须定义为$event： click me \"use strict\"; const app = Vue.createApp({ methods: { callback(event, ...args) { console.log(event); console.log(args); } } }).mount(\"#app\"); 事件修饰符 .once 使用.once修饰符后，该事件只会监听一次。当执行完这一次动作后将取消监听： click me \"use strict\"; const app = Vue.createApp({ methods: { callback(event, str) { console.log(str); } } }).mount(\"#app\"); .prevent 使用.prevent修饰符来阻止默认事件的发生： go to google search \"use strict\"; const app = Vue.createApp({ methods: { callback(event, str) { console.log(str); } } }).mount(\"#app\"); .stop 使用.stop修饰符阻止事件冒泡： .father { width: 200px; height: 200px; background-color: #ddd; } .son { width: 100px; height: 100px; background-color: #ccc; } \"use strict\"; const app = Vue.createApp({ methods: { fatherCallback(event) { console.log(\"father callback\"); }, sonCallback(event) { console.log(\"son callback\"); } } }).mount(\"#app\"); .self 使用.self修饰符，也可以防止事件冒泡。只有点击到自己时才触发，不会通过冒泡触发： .father { width: 200px; height: 200px; background-color: #ddd; } .son { width: 100px; height: 100px; background-color: #ccc; } \"use strict\"; const app = Vue.createApp({ methods: { fatherCallback(event) { console.log(\"father callback\"); }, sonCallback(event) { console.log(\"son callback\"); } } }).mount(\"#app\"); .captrue 使用.capture，开启事件捕获。当子元素点击事件后，事件被派发到父元素时，会先执行完父元素监听事件的回调函数，再执行子元素监听事件的回调函数。 注意区分事件冒泡与事件捕获： 事件捕获：在子元素事件发生后先运行父元素的同事件回调函数、再运行子元素的事件回调函数 事件冒泡：在子元素事件发生后先运行子元素的事件回调函数、再运行父元素的同事件回调函数 代码示例： .father { width: 200px; height: 200px; background-color: #ddd; } .son { width: 100px; height: 100px; background-color: #ccc; } \"use strict\"; const app = Vue.createApp({ methods: { fatherCallback(event) { console.log(\"father callback\"); }, sonCallback(event) { console.log(\"son callback\"); } } }).mount(\"#app\"); 鼠标修饰符 鼠标操作也有常见的修饰符，如下所示： .left：按下左键 .right：按下右键 .middle：按下中间 案例释义： .area { width: 200px; height: 200px; display: inline-block; background-color: #ddd; margin-left: 1rem; text-align: center; line-height: 200px; } 1 2 3 4 \"use strict\"; const app = Vue.createApp({ methods: { callback(event) { console.log(\"mouse callback\"); } } }).mount(\"#app\"); 键盘修饰符 使用keyup和keydown来进行键盘事件的监听。 keyup：按键按下 keydown：按键松开 键盘操作也有常见的修饰符，如下所示： .enter：按下回车 .tab：按下制表符 .delete：按下删除或者退格 .esc：按下退出 .ctrl：按下CTRL按键 .alt：按下ALT按键 .shift：按下SHIFT按键 除此之外，你也可以使用其他的修饰符，由于键盘按键较多这里不再进行例举。 如下示例： \"use strict\"; const app = Vue.createApp({ methods: { callback(event) { console.log(\"keyboard callback\"); } } }).mount(\"#app\"); 修饰符连用 修饰符可以连用，但是连用时一定要注意它们的顺序。 如下所示： 点我 这个例子的意思非常明显，只执行一次，阻止默认事件。 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-09-15 15:37:24 "},"前端专栏/Vue3/v-for和v-if.html":{"url":"前端专栏/Vue3/v-for和v-if.html","title":"v-for和v-if","keywords":"","body":"流程控制 v-for 通过v-for可快速的进行循环，从而能够使开发人员更方便的构建HTML结构。 如下示例，我们通过v-for指令迅速的生成了一份学生名单： 代码示例： table, table * { border: 1px solid #aaa; border-collapse: collapse; width: 400px; text-align: center; } table caption { background-color: #ddd; font-weight: bold; font-size: 1.2rem; } table tbody tr:nth-of-type(odd) { background-color: #ddd; } table tbody tr td { cursor: pointer; } table tfoot tr td { text-align: right; padding-right: 1rem; } student message name age gender {{row.name}} {{row.age}} {{row.gender}} statistics time:1998-08-02 \"use strict\"; const app = Vue.createApp({ data() { return { studentMessage: [ { id: 1, name: \"Jack\", age: 18, gender: \"male\" }, { id: 2, name: \"Tom\", age: 21, gender: \"male\" }, { id: 3, name: \"Mary\", age: 17, gender: \"female\" }, { id: 4, name: \"Anna\", age: 18, gender: \"female\" } ] } } }).mount(\"#app\"); 遍历数组 对数组的遍历，可使用for/in来进行操作，如下所示： {{value}} - {{index}} 也可以进行for/of操作，效果同for/in相同： {{value}} - {{index}} 除此之外，你也可以先对数组创建出一个迭代器后再对其进行遍历操作，如kes()、values()、entries()等这些方法都是可行的： {{value}} - {{index}} 遍历对象 对对象的遍历，可使用for/in来进行操作，如下所示： {{value}} - {{key}} - {{index}} 也可以进行for/of操作，效果同for/in相同： {{value}} - {{key}} - {{index}} 除此之外，你也可以先对对象创建出一个迭代器后再对其进行遍历操作，如Object.kes()、Object.values()、Object.entries()等这些方法都是可行的： {{value}} - {{index}} key属性 在使用v-for指令时，你应当同时为元素指定一个key属性，并且该属性必须和被渲染的值具有一对一的关系，这样做可以提升后期的操作效率。 其实Vue并不会直接操纵DOM对象，在Vue与真实DOM之间存在着一层虚拟DOM，Vue的操作会先映射到虚拟DOM上，然后再由虚拟DOM映射到真实DOM上。 我们以操纵数组为例： {{value}} - {{index}} 如果你在使用v-for渲染数组时指定了key属性，它将会依照diff算法将生成的标签在虚拟DOM中直接进行插入，这是非常高效的，它不会引起后面元素的位置后移： 如果你未在使用v-for渲染数组时指定key属性，那么在插入新元素时将会引起后面元素的位置后移，在元素较多时会拉低操纵效率： 我们用一个简单的例子来进行举例，下面有4个radio单选框，我们先选中值为D的单选框，然后再D的前面插入一个值为C的单选框。 首先是未指定key属性的情况，可以发现这个时候出现了一个BUG，本来我们选中的是D，但是插入C后它选中的变成了C： 接下来我们指定key属性，就可以避免这个BUG了： 代码如下： add radio C {{value}} \"use strict\"; const app = Vue.createApp({ data() { return { ary: [\"A\", \"B\", \"D\", \"E\"] } }, methods: { addElement(event) { this.ary.splice(2, 0, \"C\") } } }).mount(\"#app\"); 因此，在使用v-for进行循环时我们一定要注意添加key属性，推荐使用id作为key的值，不推荐使用index，因为index总是能够发生变化，不够稳定。 分支循环 v-if v-if指令的条件如果为true，那么将渲染该标签及其内部的子标签，如果为false时则不会进行渲染。 它类似于v-show，但是实际上两者之前还有很大的差别，可以暂时先这么认为： {{condition}} {{condition}} \"use strict\"; const app = Vue.createApp({ data() { return { condition: true } } }).mount(\"#app\"); v-else v-else指令应该和v-if指令连用。效果与v-if相反。 这两组指令一个代表如果怎样就渲染，一个代表否则怎样就渲染。 {{condition}} {{condition}} \"use strict\"; const app = Vue.createApp({ data() { return { condition: true } } }).mount(\"#app\"); v-else-if v-else-if是额外的判断条件，当有v-if/v-else/v-else-if在时，只会执行其中的一条。 = 80\">成绩优秀 = 60\">成绩及格 = 40\">成绩一般 90\">成绩较差 \"use strict\"; const app = Vue.createApp({ data() { return { grades: 80 } } }).mount(\"#app\"); v-if和v-show v-if和v-show的关键区别如下： v-if在条件为false时，标签会进行销毁，条件为true时会重新进行创建，整个过程会重新渲染DOM v-show在条件为false时，标签不会进行销毁而是通过css进行隐藏，整个过程不会重新渲染DOM 综合来看，v-show的性能要高于v-if，但是当出现多个组件频繁互相切换的常见，还是推荐使用v-if，因为它的代码逻辑会更清晰。 版本差异 Vue2中的key 在Vue2中，我们的真实DOM在某些情况下的渲染结果与我们料想之中的渲染结果存在一些偏差。 如下所示，我们定义了2个框，用户可以自己选择进行手机登录还是邮箱登录。 但是当用户在一个框中输入值后再进行切换，就会出现窜值的情况（即不同的输入框切换会保留一样的值）： 造成这种结果的原因是由于虚拟DOM的渲染复用，虚拟DOM进行渲染时会尽量复用已存在的组件，而不是创建新的组件。 上述示例中看起来写了两个，其实是被复用了，所以导致窜值问题的出现，使用key属性可解决这个问题： 手机 邮箱 \"use strict\"; const app = new Vue({ el: \"#app\", data() { return { type: \"phone\", } }, }); 在Vue3中，v-if已经不需要再手动的添加key了，因为Vue内部会自动的为每个添加了v-if指令的标签生成一个key属性。但是v-for指令中的key依旧是必须的，不要将两者搞混淆了。 优先级更改 Vue中允许同时在一个元素上使用v-if和v-for指令。 Vue2：v-for的优先级高于v-if，它会先进行渲染，再决定要不要将渲染结果映射到真实DOM Vue3：v-if的优先级高于v-for，它会先查看条件是否满足，再决定要不要进行渲染 我们并不推荐在同一个元素上使用v-if和v-for，这并不是一个良好的编码习惯。 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-09-14 14:43:02 "},"前端专栏/Vue3/v-model双向绑定.html":{"url":"前端专栏/Vue3/v-model双向绑定.html","title":"v-model双向绑定","keywords":"","body":"双向绑定 v-model v-model指令常用于与from表单元素做绑定使用。 当表单内容发生改变时，数据层的数据也会发生改变 当数据层的数据发生改变时，表单内容也会发生改变 这种绑定关系是双向的，因此v-model也被称之为双向绑定： 代码示例： phone: \"use strict\"; const app = Vue.createApp({ data() { return { phoneNumber: \"\" } }, }).mount(\"#app\"); v-bind和v-model的区别 很多初学者可能疑惑v-bind和v-model的区别，这里特别指出一下： v-bind常用于与元素的属性做绑定，并且这个绑定关系是单向的，只有当数据层的数据发生改变时，元素的属性才会发生变更 v-model常用于与表单元素做绑定，并且这个绑定关系是双向的，无论哪一方的数据发生改变，都会影响另一方数据的改变 举个例子，我们在之前没有学习Vue时要通过AJAX提交表单数据时只有从元素身上获取value属性值后再进行提交，但是有了Vue的双向绑定之后这一切都变的非常简单，如下示例，我们只需要将需要提交的表单元素和数据层中的提交数据做绑定，然后就可以快速的进行提交了： name password login \"use strict\"; const app = Vue.createApp({ data() { return { username: \"\", password: \"\" } }, methods: { login(event) { const url = \"http://localhost:3000/\"; axios.post( url, { username: this.username, password: this.password } ).then(response => { switch (response.status) { case 200: console.log(response.data); break default: console.log(\"login fail!\"); } }) } } }).mount(\"#app\"); 后端代码，采用Node.js完成： const http = require('http'); const server = http.createServer((req, res) => { res.setHeader(\"Access-Control-Allow-Origin\", \"*\"); if (req.method === \"OPTIONS\") { res.setHeader(\"Access-Control-Allow-Headers\", \"*\"); } let data = \"\"; req.on(\"data\", chunk => { data += chunk.toString(); }) req.on(\"end\", () => { res.writeHead(200, { \"content-type\": \"text/plain\" }); console.log(data); res.end(\"login success!\"); }) }) server.listen(3000, \"localhost\"); 表单操作 input&textarea v-model指令直接用于以及上时，当他们的value发生改变后数据层被绑定的数据也会发生改变。 注意，v-model指令直接用于以及上时数据层的绑定对象可以是任意类型： username introduction \"use strict\"; const app = Vue.createApp({ data() { return { username: \"\", introduction: \"\", } } }).mount(\"#app\"); checkbox v-model绑定input:checkbox时，数据层的绑定对象必须是一个数组类型，因为checkbox是多选： basketball football volleyball \"use strict\"; const app = Vue.createApp({ data() { return { hobby: [] } } }).mount(\"#app\"); radio v-model绑定input:radio时，元素身上可以不用指定name属性，只要v-model相同，就会产生互斥效果，此外checked属性也不需要做指定，只要元素的value和数据层的数据一致，默认就会进行选中。 注意，v-model指令绑定在input:radio时数据层的绑定对象可以是任意类型： male female \"use strict\"; const app = Vue.createApp({ data() { return { gender: \"male\", } } }).mount(\"#app\"); select单选&复选 v-model绑定时，需要区分单选还是多选。 如果是单选，那么数据层的绑定对象可以是任意类型 如果是多选，那么数据层的绑定对象必须是数组类型 单选示例： beijing shanghai chongqing \"use strict\"; const app = Vue.createApp({ data() { return { address: 'beijing', } } }).mount(\"#app\"); 多选示例： beijing shanghai chongqing \"use strict\"; const app = Vue.createApp({ data() { return { choice: [] } } }).mount(\"#app\"); v-model修饰符 .lazy 使用该修饰符时，数据层的绑定对象不会进行实时刷新，而是等到表单元素失去焦点后才会更新： 代码示例： \"use strict\"; const app = Vue.createApp({ data() { return { content:\"\" } } }).mount(\"#app\"); .number 使用该修饰符时，当你输入的内容为纯数字时将会自动转为int类型后再存储到数据层的绑定对象身上。 如果不使用该修饰符，则数据层绑定对象存储的string类型的数据： 代码示例： \"use strict\"; const app = Vue.createApp({ data() { return { number: null, string: null } } }).mount(\"#app\"); .trim 使用该修饰符时，将会自动移除表单元素输入内容的两侧空白： 代码示例： \"use strict\"; const app = Vue.createApp({ data() { return { trimString: \"\", noTrimString: \"\" } } }).mount(\"#app\"); Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-09-14 17:31:02 "},"前端专栏/Vue3/watch数据侦听.html":{"url":"前端专栏/Vue3/watch数据侦听.html","title":"watch数据侦听","keywords":"","body":"基本使用 我们可以使用watch来监听数据层数据的变化。 watch应当是一个对象，且在内部定义了一些方法，这些方法必须与被监听的数据（可以是计算属性）名字相同，它具有2个参数，分别是newValue和oldValue。 watch中的方法只能被动调用，当被侦听的属性发生改变时，将会自动调用侦听器中的同名方法。 下面是一个简单的例子： 代码示例： + &nbsp;{{number}}&nbsp; - \"use strict\"; const app = Vue.createApp({ data() { return { number: 0 } }, watch: { number(newValue, oldValue) { console.log(`${oldValue} => ${newValue}`); } } }).mount(\"#app\"); 适用场景 watch中的方法是支持异步操作的，所以特别适用于在某些特定场景下进行网络请求。 如页面无刷新的进行前后端交互、表单数据项格式认证等。 测试案例 人员筛选 以下是demo.css的代码： body { margin: 0; padding: 0; box-sizing: border-box; } body main { width: 400px; display: flex; flex-flow: column nowrap; justify-content: center; align-items: center; padding: 2rem; } body main>div:nth-child(1) { width: 50%; display: flex; justify-content: space-around; margin-bottom: 0.5rem; } body main>div:nth-child(2) { width: 100%; } body main>div:nth-child(2) table { width: 100%; } body main>div:nth-child(2) table, body main>div:nth-child(2) table * { border: 1px solid #aaa; border-collapse: collapse; text-align: center; } body main>div:nth-child(2) table caption { background-color: #ddd; font-weight: bold; font-size: 1.2rem; } body main>div:nth-child(2) table tbody tr:nth-of-type(odd) { background-color: #ddd; } body main>div:nth-child(2) table tbody tr:nth-of-type(odd) td { cursor: pointer; } body main>div:nth-child(2) table tfoot tr td { text-align: right; padding-right: 1rem; } body main>div:nth-child(3) { width: 70%; display: flex; justify-content: center; margin-top: 0.5rem; } 以下是demo.html中的代码： id age 升序 降序 id name age gender {{row.id}} {{row.name}} {{row.age}} {{row.gender}} \"use strict\"; const app = Vue.createApp({ data() { return { orderRule: \"id\", keyword: \"\", studentMessage: [ { id: 1, name: \"Jack\", age: 18, gender: \"male\" }, { id: 2, name: \"Tom\", age: 19, gender: \"male\" }, { id: 3, name: \"Ken\", age: 21, gender: \"male\" }, { id: 4, name: \"Anna\", age: 17, gender: \"female\" }, { id: 5, name: \"Mary\", age: 22, gender: \"female\" } ] } }, methods: { order(event, type) { // studentMessage发生改变,studentArray重新计算 if (type === \"asc\") { this.studentMessage.sort((a, b) => { return a[this.orderRule] - b[this.orderRule] }) } else { this.studentMessage.sort((a, b) => { return b[this.orderRule] - a[this.orderRule] }) } }, }, computed: { studentArray() { if (!this.keyword) { return this.studentMessage; } return this.studentMessage.filter((row, index, ary) => { for (let v of Object.values(row)) { if (row.name.match(this.keyword)) { return row; } } }) } }, watch: { keyword(newValue, oldValue) { // 重新计算 this.studentArray; } } }).mount(\"#app\"); 最终呈现的效果如下： 登录验证 以下是demo.css的代码： body { margin: 0; padding: 0; box-sizing: border-box; position: relative; } body main { position: absolute; left: 50%; top: 50%; transform: translate(-50%, -50%); } body main form { display: flex; flex-flow: column nowrap; justify-content: center; align-items: center; padding: 0.8rem; width: 250px; border: 2px solid #ddd; position: relative; } body main form>div { margin-bottom: 0.8rem; } body main form>div:first-of-type { height: 1rem; } body main form>div:first-of-type span { font-size: 0.3rem; color: red; } body main form>div:last-of-type button:nth-of-type(1) { width: 6rem; margin-right: 0.5rem; } body main form>div:last-of-type button:nth-of-type(2), body main form>div:last-of-type button:nth-of-type(3) { width: 6rem; margin-left: 0.5rem; } 以下是demo.html中的代码： {{error}} 手机号: 验证码: 登录 发送验证码 已发送 ({{waitSecond}}) \"use strict\"; const app = Vue.createApp({ data() { return { phone: null, phoneCheck: false, verify: null, verifyCheck: false, timer: null, waitSecond: 5, error: null, testVerifyCode: null, } }, methods: { sendVerify($event) { // 请求后端，模拟验证码的到来 this.testVerifyCode = \"\"; for (let i = 0; i { if (this.waitSecond 最终呈现的效果如下： Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-09-15 13:46:24 "},"前端专栏/Vue3/数组响应.html":{"url":"前端专栏/Vue3/数组响应.html","title":"数组响应","keywords":"","body":"响应渲染 在Vue中，大部分的数据渲染都是响应式的，即Vue应用中数据发生改变页面中的显示效果也会发生改变。 代码示例： + &nbsp;{{number}}&nbsp; - \"use strict\"; const app = Vue.createApp({ data() { return { number: 0 } }, methods: { add() { this.number++; }, sub() { this.number--; } } }).mount(\"#app\"); 数组响应 在Vue2中，如果数据源是一个数组的话，它有一些操作并不是响应式的，如通过索引来操纵数组。 如下所示，当我点击按钮使用索引修改元素后，数组中的元素确实发生了改变，但是页面的渲染效果并未发生改变，所以Vue2中数组的索引操作是非响应式的： 代码如下： * { margin: 0; padding: 0; } main { display: flex; flex-flow: column nowrap; align-items: center; } ul { list-style: none; margin-bottom: 1rem; } {{index}} - {{value}} change array \"use strict\"; const app = new Vue({ el: \"#app\", data() { return { ary: [\"A\", \"B\", \"C\", \"D\"] } }, methods: { changeArray(event) { this.ary.forEach((value, index, ary) => { ary[index] = value.toLowerCase(); }) console.log(this.ary); } } }); 但是在Vue3中，关于数组的索引操作已经变更为了响应式，这是一个非常好的改进： \"use strict\"; const app = Vue.createApp({ data() { return { ary: [\"A\", \"B\", \"C\", \"D\"] } }, methods: { changeArray(event) { this.ary.forEach((value, index, ary) => { ary[index] = value.toLowerCase(); }) console.log(this.ary); } } }).mount(\"#app\"); 变异方法 下面这些方法都是经过Vue封装后的方法。使用方式与原生Js相同，但是他们是响应式的。 方法 描述 push() 追加末尾，将元素压入数组尾部 unshift 追加头部，将元素压入数组头部 pop() 弹出末尾，将数组中最后一个元素弹出 shift() 弹出头部，将数组中第一个元素弹出 splice() 可以添加、删除、替换数组中的元素 sort() 排序 reverse() 翻转 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-09-15 14:53:50 "},"前端专栏/Vue3/组件化开发.html":{"url":"前端专栏/Vue3/组件化开发.html","title":"组件化开发","keywords":"","body":"基础知识 基本概念 在开始的时候，已经大概的聊了聊Vue是单页面开发，用户总是在一个页面上进行操作，看到的不同内容也是由不同组件构成的。 通过用户的操作，Vue将会向用户展示某些组件，也会隐藏某些组件，可以说Vue中一切皆组件。 一个Vue的项目其实就是一个Vue的应用对象，即createApp()所创建出的实例。而用户看到的页面则是在这个Vue应用中注册的不同的组件。 组件其实说白了就是将一些复用性高的内容进行单独封装，如导航栏、搜索框、版权信息等等，我们可以在页面中的任何地方对其进行引用，避免了重复创建所带来的代码冗余。 组件是Vue的核心、但是本章节不会讨论Vue如何实现组件的显示、隐藏，而是聊一聊如何使用组件。 组件分类 组件之间允许嵌套，如下所示： 根据组件与组件的关系，大体可分为4种组件： 根组件：即createApp()所创建出的Vue实例，通常情况下一个项目中只会有一个根组件 父组件：相对于子组件而言，包裹在外部的组件被称之为父组件 子组件：相当于父组件而言，放置在内部的组件被称之为子组件 兄弟组件：相当于其他组件而言，处于同级且没有嵌套关系的组件被称之为兄弟组件 组件使用 基本声明 普通的组件和根组件一样，都具有诸如data()、methods、computed、watch等子对象。 除此之外，它还具有一个template的选项，该选项存放的是该组件的HTML结构。 如下所示，我们定义了一个header头部组件，为了后面方便演示，我们将会对该子组件的内容进行变更让它更精简，这个例子只是让你知道所有的组件都和根组件一样能拥有某些属性及方法： const cpnHeader = { template: \"{{content}}\", data() { return { content: \"this is header component\", style: { \"color\": \"rgba(0,0,0,1)\", \"border\": \"1px solid #ddd\", \"padding\": \".5rem\", \"background\": \"#eee\", \"cursor\": \"pointer\" } } }, methods: { callback(event) { const r = Math.floor(Math.random() * (255 + 1)); const g = Math.floor(Math.random() * (255 + 1)); const b = Math.floor(Math.random() * (255 + 1)); const a = Math.random().toFixed(1); this.style.backgroundColor = rgba(${r},${g},${b},${a}); } } } 全局注册 我们可以将该组件注册到全局中，这样任何组件都能够去调用它。 如下所示我们在根组件中多次使用了该全局组件： 代码示例： #app { border: 1px solid #ddd; padding: 1rem; } {{content}} \"use strict\"; // step01：创建根组件，注意此时先不要进行挂载 const app = Vue.createApp({ data() { return { content: \"root component\" } } }); // step02：创建子组件 const cpnHeader = { template: \"{{content}}\", data() { return { content: \"header component\", style: { border: \"1px solid #ddd\", padding: \".5rem\" } } } } // step03：在根组件上调用component()方法进行注册，该组件就会变更为全局组件 // 注意命名风格，可以是驼峰式，也可以是kebab-case风格，它决定了如何在HTML结构中使用该组件 app.component('cpnHeader', cpnHeader); // step04：必须先注册组件，然后再进行元素挂载 app.mount(\"#app\") 局部注册 我们可以再书写一个cpnNav组件，将它注册在cpnHeader中，注册时需要在cpnHeader里定义components对象进行注册。 局部组件只能够在其注册的父组件作用域中进行使用，不能由根组件进行调用： 代码示例： #app { border: 1px solid #ddd; padding: 1rem; } {{content}} \"use strict\"; // step01：创建根组件，注意此时先不要进行挂载 const app = Vue.createApp({ data() { return { content: \"root component\" } } }); // step02：创建局部子组件cpnNav const cpnNav = { template: \"{{content}}\", data() { return { content: \"nav component\", style: { border: \"1px solid #ddd\", padding: \".5rem\", fontSize: \".3rem\" } } } } // step03：创建全局父组件cpnHeader，注册并使用局部子组件cpnNav，注意cpnNav只能在cpnHeader中使用，因为我们只在cpnHeader中注册了它 const cpnHeader = { template: {{content}} , data() { return { content: \"header component\", style: { border: \"1px solid #ddd\", padding: \".5rem\" } } }, components: { cpnNav, // ES6新语法，相当于 cpnNav : cpnNav } } // step04.全局注册cpnHeader组件 app.component('cpnHeader', cpnHeader); // step05：必须先注册组件，然后再进行元素挂载 app.mount(\"#app\") 命名风格 细心的朋友可能会发现，我们在注册组件时均使用了驼峰式命名风格： app.component('cpnHeader', cpnHeader); 但是在使用时却变成了短横线分隔命名风格： 为什么要这样做呢？其实如果你是通过Vue CIL创建的项目，则没必要这么麻烦，可以在使用时也通过驼峰式命名风格应用组件，但是非工程化的项目中必须在使用时更改组件命名风格为短横线分隔式，这是因为HTML文档在渲染时会将驼峰全部变为小写，所以就找不到该组件了。 我们来做一个简单的例子，现在我们是非工程化的Vue项目，将第一次使用组件的风格变为驼峰式，其他不变： {{content}} 打开控制台后会发现，浏览器会自动的将驼峰全部变为小写，该组件就找不到了，因此也不能生效： 组件模板 抽离写法 如果定义组件时在template属性中写HTML代码，是不太友好的，你可以将模板抽离出来，有2种方式进行抽离： 使用script标签，并添加type=\"text/x-template\"以及id属性 使用template标签，并添加id属性 后期子组件定义时template属性可以直接通过元素id挂在该模板，如下所示： {{content}} \"use strict\"; const app = Vue.createApp({ data() { return {} } }); // 子组件挂载模板 const cpn = { template: \"#cpn-tpl\", data() { return { content: \"cpn\", } } } app.component('cpn', cpn); app.mount(\"#app\") 重复渲染 注意！模板进行抽离写法时必须采用浏览器所不识别的标签，否则会造成重复渲染问题，即渲染次数比组件调用次数多一次。 这是因为如果你的模板标签是浏览器所识别的，浏览器会预先对其进行一次渲染： 代码示例： {{content}} \"use strict\"; const app = Vue.createApp({ data() { return {} } }); // 子组件挂载模板 const cpn = { template: \"#cpn-tpl\", data() { return { content: \"cpn\", } } } app.component('cpn', cpn); app.mount(\"#app\") 其他组件 动态组件 有的时候我们需要根据用户的行为来动态的切换某个组件，此时可以利用:is属性。 如下所示，我们定义了2个header组件，一款是红色背景的，一款是黑色背景的，用户可自行选择样式： 代码示例： 切换 hot news home \"use strict\"; const blackHeaderCpn = { template: #header-cpn, data() { return { style: { background: \"#2b0c09\" } } } } const redHeaderCpn = { template: #header-cpn, data() { return { style: { background: \"#dd1e1d\" } } } } const app = Vue.createApp({ data() { return { // 指定需要显示的组件名字，这里的组件名字和注册时一致 choice: \"redHeaderCpn\" } }, methods: { modifyHeaderCpn(event) { this.choice = this.choice === \"redHeaderCpn\" ? \"blackHeaderCpn\" : \"redHeaderCpn\" console.log(this.choice); } }, components: { // 组件注册 redHeaderCpn, blackHeaderCpn, } }) app.mount(\"#app\") 异步组件 在大型应用中，我们可能需要将应用分割成小一些的代码块，并且只在需要的时候才从服务器加载一个模块。为了简化，Vue有一个defineAsyncComponent方法： const { createApp, defineAsyncComponent } = Vue const app = createApp({}) const AsyncComp = defineAsyncComponent( () => new Promise((resolve, reject) => { resolve({ template: 'I am async!' }) }) ) app.component('async-example', AsyncComp) 如你所见，此方法接受返回Promise的工厂函数。从服务器检索组件定义后，应调用Promise的resolve回调。你也可以调用reject(reason)，来表示加载失败。 你也可以在工厂函数中返回一个Promise，把webpack2和ES2015语法相结合后，我们就可以这样使用动态地导入： import { defineAsyncComponent } from 'vue' const AsyncComp = defineAsyncComponent(() => import('./components/AsyncComponent.vue') ) app.component('async-component', AsyncComp) 7 当在局部注册组件时，你也可以使用defineAsyncComponent import { createApp, defineAsyncComponent } from 'vue' createApp({ // ... components: { AsyncComponent: defineAsyncComponent(() => import('./components/AsyncComponent.vue') ) } }) 版本差异 模板根元素 在Vue2中，下必须具有1个根元素，否则将会抛出警告： header main footer 但是在Vue3中，可以不加这个根元素，但是推荐还是添加上，因为这样会避免一些可能出现的问题，如$emit自定义事件的根标签不能是文本节点： header main footer Vue2的警告如下： vue.js:634 [Vue warn]: Error compiling template: Component template should contain exactly one root element. If you are using v-if on multiple elements, use v-else-if to chain them instead. 1 | 2 | header 3 | main | ^^^^^^^^^^^^^^^^^ 4 | footer | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 5 | | ^^^^ found in ---> 全局组件 Vue2中的全局组件是通过Vue对象本身进行注册，而不再是Vue应用，即Vue实例本身： \"use strict\"; // 子组件挂载模板 const cpn = { template: \"#cpn-tpl\", data() { return { content: \"cpn\", } } } // 注册全局组件 Vue.component('cpn', cpn); const app = new Vue({ el: \"#app\", // 挂载根元素 data() { return {} } }); 下面是Vue3的全局组件注册： \"use strict\"; const app = Vue.createApp({ data() { return {} } }); // 子组件挂载模板 const cpn = { template: \"#cpn-tpl\", data() { return { content: \"cpn\", } } } // 注册全局组件 app.component('cpn', cpn); // 挂载根元素 app.mount(\"#app\") data差异 在开篇的时候我们说过，Vue2中的data可以是一个对象，也可以是一个函数且返回一个对象，但是Vue3中的data必须是一个函数且返回一个对象。 如下示例： {{message}} \"use strict\"; const app = new Vue({ el: \"#app\", data: { message: \"hello world\" } }); 为什么Vue3会更改这种设置呢？我们可以从下图中寻找答案，如果data直接是一个对象，那么多次应用组件的时候每个组件引用的实际上还是同一个data对象，如下图所示： 这会造成一个问题，任何一个组件对于数据的修改都会造成其他组件数据的变更，完全没有了丝毫数据隔离性。 相当于下面这个案例： 代码示例： + &nbsp;{{number}}&nbsp; - \"use strict\"; const dataStore = { number: 0 } const app = Vue.createApp({}); app.component(\"cpn\", { template: \"#cpn-tpl\", data() { return dataStore } }) app.mount(\"#app\") 因此Vue3将data设计成了一个函数，且必须返回一个对象，这样每次组件应用的时候都会调用一次data()函数，从而得到不同的数据对象，已完全隔离组件多次应用之间的数据影响，如下图所示： Vue3的这个设计对于Vue老用户老说没什么特别的影响，但针对Vue新用户确实是友好了许多，但是Vue2中的data设计缺陷还是一定了解的。 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-09-16 20:54:40 "},"前端专栏/Vue3/组件中通信.html":{"url":"前端专栏/Vue3/组件中通信.html","title":"组件中通信","keywords":"","body":"通信的意义 组件之间的通信是非常有必要的。 例如当Vue项目启动后，父组件从后端获取到了一些信息，那么它该如何将这些信息分发给不同的子组件呢？ 再比如当用户在某一个子组件上产生了新的数据，子组件该如何将数据交由父组件进行前后端交互呢？ 学习组件通信前，我们要明白一点，数据的流动必须是单向的，只能子传父、或者父传子，而兄弟组件之间的通信也需要依赖父组件进行，并且传递过程中子组件不能修改源数据，源数据只能由产生该数据的组件进行修改。 如下图所示： 组件通信的方案有很多种，我们本章节主要介绍原生Vue自带的通信方案。 父传子 props props 基本使用 父组件向子组件传递数据时，需要通过props进行传递。整个传递过程如下图所示： 代码示例： {{recvMessage}} \"use strict\"; const cpn = { // JavaScript层面全部采用驼峰式命名 // 由于HTML层面是recv-message，故这里书写成recvMessage props: [\"recvMessage\"], template: \"#cpn-tpl\" } const app = Vue.createApp({ data() { return { sendMessage: \"hello world\" } }, components: { cpn } }) app.mount(\"#app\") 传递图示： props 数据检查 我们可以让子组件props对父组件传递的数据进行验证，避免一些渲染错误。 可以验证的项目如下所示： 验证项目 描述 type 一个Array，允许的类型 required 一个Boolen，是否必须传递 default 一个Any，当父组件没有传递数据时，当采用default进行填充 validator 一个Function，用于自定义的验证设置 type可支持验证的类型有： String Number Boolean Array Object Date Function Symbol 你可以仅验证类型，如下所示： const cpn = { props: { recvMessage1: String, recvMessage2: Array, recvMessage3: Object }, template: \"#cpn-tpl\" } 或者可以进行更详细的验证，示例如下： {{recvMessage}} \"use strict\"; const cpn = { // JavaScript层面全部采用驼峰式命名 // 由于HTML层面是recv-message，故这里书写成recvMessage // 数据验证 // 01.props必须是一个Object props: { // 02.指定要验证的数据项， 必须是一个Object recvMessage: { // 允许传递的类型 type: [String, Array, Object, Function], // 是否必须传递 required: true, // 自定义验证函数，若返回false则验证失败 validator(v) { if (typeof v == 'string') { return v.match(\"hello\") } return true }, // 如果父组件没有传递数据时，采用的默认值 default() { return \"default\" }, } }, template: \"#cpn-tpl\" } const app = Vue.createApp({ data() { return { sendMessage: \"hello world\", } }, components: { cpn } }) app.mount(\"#app\") 继承属性 在子组件进行应用时，我们可以为子组件绑定一些属性，这些属性会被继承到子组件模板根标签上，这种策略也被称为no_props： ... --> hello world 最终生成的结果为： hello world 我们可以禁用这种继承机制，只需要在子组件中添加inheritAttrs:false即可： const cpn = { inheritAttrs:false, template: \"#cpn-tpl\" } 这样生成的结果为： hello world 通过$attrs可拿到使用组件时所绑定的所有属性，以此来为子组件中的元素动态绑定属性： hello world --> hello world hello attrs --> hello attrs ... --> {{this.$attrs}} \"use strict\"; const cpn = { inheritAttrs: true, template: \"#cpn-tpl\" } const app = Vue.createApp({ components: { cpn } }) app.mount(\"#app\") 大小写问题 HTML中的attribute名是大小写不敏感的，所以浏览器会把所有大写字符解释为小写字符。这意味着当你使用 DOM 中的模板时，camelCase (驼峰命名法) 的 prop名需要使用其等价的 kebab-case (短横线分隔命名) 命名： Vue.component('blog-post', { // 在 JavaScript 中是 camelCase 的 props: ['postTitle'], template: '{{ postTitle }}' }) 重申一次，如果你使用字符串模板，那么这个限制就不存在了。 子传父 $emit 自定义事件通信 当子组件的数据发生改变后，我们希望子组件将这个数据传递给父组件，继而让父组件发送网络请求进行前后端交互该怎么做？ 这个时候我们可以自定义一个事件让父组件进行监听，当子组件数据改变后便手动的触发该事件，然后将数据通过这个自定义事件传递给父组件即可，整个流程如下图所示： 代码示例，当用户的数据发生改变后，父组件便会接收到该数据。 + &nbsp;{{number}}&nbsp; - \"use strict\"; const cpn = { template: \"#cpn-tpl\", data() { return { number: 0 } }, watch: { number(newValue, oldValue) { // 当number发生改变后，发射这个事件 // JavaScript层面全部采用驼峰式命名 // 由于HTML层面是number-change，故这里书写成numberChange this.$emit(\"numberChange\", newValue, oldValue); } } } const app = Vue.createApp({ data() { return { sendMessage: \"hello world\", } }, methods: { // 自定义事件没有$event事件对象 callback(newValue, oldValue) { console.log(`${oldValue}=>${newValue}`); } }, components: { cpn } }) app.mount(\"#app\") 组件访问 父访子 $refs 我们希望父组件在某些时候能够调用子组件下的某些方法或者查看某些属性，此时可以使用$refs来进行，示例如下： show cpn1 name show cpn2 name {{name}} \"use strict\"; const cpn1 = { template: \"#cpn-tpl\", data() { return { name: \"cpn1\" } } } const cpn2 = { template: \"#cpn-tpl\", data() { return { name: \"cpn2\" } } } const app = Vue.createApp({ methods: { showCPN1(event) { // 通过ref别名来访问cpn1的name属性 console.log(this.$refs.firstCPN.name); }, showCPN2(event) { // 通过ref别名来访问cpn2的name属性 console.log(this.$refs.lastCPN.name); } }, components: { cpn1, cpn2 } }) app.mount(\"#app\") 子访父 $parent 我们希望子组件在某些时候能够调用父组件下的某些方法或者查看某些属性，此时可以使用$parent来进行，示例如下： show parent name \"use strict\"; const cpn = { template: \"#cpn-tpl\", methods:{ // 通过$parent来访问父组件 showParent(event){ console.log(this.$parent.name); } } } const app = Vue.createApp({ data() { return { name: \"parent cpn\" } }, components: { cpn, } }) app.mount(\"#app\") 访问根 $root 如果存在3级以上的嵌套，我们可以直接利用$root来拿到根组件，这样就能调用根组件下的某些方法或者属性了，示例如下，当然下面这个示例中只有2层嵌套： show root name \"use strict\"; const cpn = { template: \"#cpn-tpl\", // 通过$root来访问根组件 methods:{ showRoot(event){ console.log(this.$root.name); } } } const app = Vue.createApp({ data() { return { name: \"root cpn\" } }, components: { cpn, } }) app.mount(\"#app\") 单向数据流 独立修改 上面我们提到过数据的传递必须是单向的，且相互独立的组件不应该由自身去修改正在流动的数据。 如果某个组件想要修改流动的数据，则应当进行一次拷贝操作，必须保证这一修改操作不会影响到其他的组件对该数据的使用。 如下所示，我们有一个三层嵌套的组件： 根组件：下发数据 父组件：需要修改数据后再展示数据 子组件：需要修改数据后再展示数据 对此情形而言，我们必须在父组件和子组件上都进行一次拷贝，让父组件的数据修改不会影响到子组件的数据。 代码如下： root {{number}} son {{sonNumber}} father {{fatherNumber}} \"use strict\"; const son = { props: { number: { type: Number, required: true } }, template: \"#son-cpn-tpl\", data() { return { // 不能直接修改props中的数据，必须自定义 sonNumber: this.number + 200 } } } const father = { props: { number: { type: Number, required: true } }, template: \"#father-cpn-tpl\", data() { return { // 不能直接修改props中的数据，必须自定义 fatherNumber: this.number + 100 } }, components: { son } } const app = Vue.createApp({ data() { return { number: 0 } }, components: { father } }) app.mount(\"#app\") 同源修改 更多的场景下，我们的一份数据可能被多个组件使用，并且我们希望当一份组件中该数据发生变化后，其他组件中的这份数据也会发生变化。 这个时候我们必须在该数据的产生地上定义一系列操纵数据的方法，并且下发给子组件们。 也就是说，产生该数据的组件上你不仅要向下传递数据、并且还需要传递操纵数据的方法。 如下示例： {{ary.length}} {{v}} push random pop \"use strict\"; const cpn = { // 由于我们想在子组件上操纵父组件传递的数据 // 所以必须接收由父组件提供的操纵方法来进行数据操纵 // 否则直接操纵props的数据是不被允许的 props: { ary: Array, push: Function, pop: Function, }, template: \"#cpn-tpl\", } const app = Vue.createApp({ data() { return { ary: [1, 2, 3] } }, methods: { push(event) { this.ary.push(Math.floor(Math.random() * 20) + 1) }, pop(event) { this.ary.pop() } }, components: { cpn } }) app.mount(\"#app\") 版本差异 已废弃的$children 在Vue2中，我们可以在父组件上使用$children来访问所有的子组件，它将返回一个列表，包含当前父组件下注册的所有子组件。 但是Vue3中已经将它废弃了，废弃的原因是因为它严格依赖数组的索引才能精确定位某个子组件，因此非常鸡肋，还是建议使用$ref来访问子组件。 以下是Vue2中的示例： show children cpn {{name}} \"use strict\"; const cpn1 = { template: \"#cpn-tpl\", data() { return { name: \"cpn1\" } } } const cpn2 = { template: \"#cpn-tpl\", data() { return { name: \"cpn2\" } } } const app = new Vue({ el: \"#app\", methods: { showChildren(event) { console.log(this.$children); // (2) [VueComponent, VueComponent] } }, components: { cpn1, cpn2 } }) 已废弃的.sync 如果子组件的数据来自于父组件，当子组件中的数据发生改变时我们也想让父组件中的数据发生同样的改变。 则可以使用.sync修饰符（尽量少用，会破坏单一性，Vue3已废弃），如下所示： 代码示例： 父组件的值:{{num}} 子组件的值:{{sonNum}} \"use strict\"; var cpn = { props: [\"sonNum\",], template: \"#cpn-template\", data: function () { return { newValue: this.sonNum, } }, methods: { changeValue() { this.$emit(\"update:sonNum\", this.newValue) } } } const app = new Vue({ el: \"#app\", data: { num: 100, }, components: { // Vue实例内部进行注册 cpn, }, }) 流程图示： Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-09-25 21:56:40 "},"前端专栏/Vue3/组件化插槽.html":{"url":"前端专栏/Vue3/组件化插槽.html","title":"组件化插槽","keywords":"","body":"认识插槽 插槽是干什么用的？它其实是配合组件一起使用的，让一个组件能够更加的灵活多变，如下图所示，你可以将组件当作一块电脑主板，将Vue中的插槽当作电脑主板上的插槽，你可以随意的更换该主板上的零件。 我们举个例子，如YouTube上的左侧导航栏，我们可以将它视作一个组件，但是被重复引用了3次。 注意，示例中组件的每次使用其内容都不相同，这是如何做到的呢？实际上就是通过插槽来完成的。 基本使用 我们可以在组件模板中使用来定义一个插槽，当父组件模板中引用子组件时，可通过标签以及v-slot指令来向该插槽中插入内容。 如下所示，我们在2个地方使用了一个相同的组件，但是填入了不同的内容： 代码示例： \"use strict\"; const cpn = { template: \"#cpn\" } const app = Vue.createApp({ components: { // 组件注册 cpn } }) app.mount(\"#app\") 具名插槽 插槽可以定义多个，但要在定义时必须通过name属性为这些插槽取一个名字，这种插槽被称为具名插槽。 具名插槽在插入内容时，必须通过标签来进行插入，并且指定v-slot属性为插槽名称。 代码示例： header main footer \"use strict\"; const cpn = { template: \"#cpn\" } const app = Vue.createApp({ components: { // 组件注册 cpn } }) app.mount(\"#app\") 默认插槽 若一个插槽没有名字，那么Vue会指定给它一个默认的名字default，因此这种插槽也被称之为默认插槽。 默认插槽一个组件中至多只有一个，我们推荐在为默认插槽插入内容时，也指定好default的名称。 代码示例： default slot demo header main footer \"use strict\"; const cpn = { template: \"#cpn\" } const app = Vue.createApp({ components: { // 组件注册 cpn } }) app.mount(\"#app\") 编译作用域 编译作用域的意思是，在哪个组件的模板中使用数据时，就在哪个组件的数据层中区寻找，如下图所示： 我们在根组件模板的子组件身上绑定了v-show:condition指令，并且在子组件和根组件数据层都定义了condition，那么它到底是用根组件的condition还是用子组件的condition呢？ 答案是根组件的，因为根组件的模板就是根组件的渲染作用域，所有在此模板中对数据的使用都会寻找根组件数据层。 代码示例： cpn \"use strict\"; const cpn = { template: \"#cpn\", data() { return { condition: true } }, } const app = Vue.createApp({ data() { return { condition: false } }, components: { // 组件注册 cpn } }) app.mount(\"#app\") 作用域插槽 作用域插槽的作用是，通过子组件的内容来填充子组件中的插槽，这个应用场景比较少。 主要实现思路就是在子组件模板中将数据发送到根组件的作用域内再进行渲染，代码实现如下所示： {{row.id}}-{{row.name}}-{{row.age}}-{{row.gender}} \"use strict\"; const cpn = { template: \"#cpn\", data() { return { userList: [ { id: 1, name: \"Jack\", age: 18, gender: \"male\" }, { id: 2, name: \"Mary\", age: 16, gender: \"female\" }, { id: 3, name: \"Tom\", age: 18, gender: \"male\" } ] } }, } const app = Vue.createApp({ components: { // 组件注册 cpn } }) app.mount(\"#app\") 它的意义在于，同一份数据我们可以使用不同的样式进行多次渲染，如上述示例中是使用了列表渲染，当然也可以在我们再次使用该组件时进行表格渲染。 默认内容 我们可以在插槽中定义一个默认值，当外部没有向该插槽传递内容时，Vue将会使用默认值来填充该插槽。 代码示例： 自定义的头部 自定义的底部 默认的头部 默认的主体 默认的底部 \"use strict\"; const cpn = { template: \"#cpn\" } const app = Vue.createApp({ components: { // 组件注册 cpn } }) app.mount(\"#app\") v-slot缩写形式 v-slot:default可以简写为#default，如下所示： content 版本差异 整个Vue2和Vue3中关于插槽的改动非常大，我们一个一个来例举。 首先对于具名插槽而言，填入内容时不需要使用标签，直接填入内容即可，并且指定填入插槽的方式也有所不同。 1）Vue3的代码示例，指定插槽通过v-slot指令进行指定： demo slot fill content 2）Vue2的代码示例，指定插槽通过slot属性进行指定： demo slot fill content 其次是关于作用域插槽，它们在父组件接收子组件所传递的值时应用方法有所不同。 1）Vue3的代码示例，Vue3中父组件模板接收子组件中传递过来的信息时子组件必须使用v-bind进行发送，父组件必须使用v-slot属性进行接收： {{row.id}}-{{row.name}}-{{row.age}}-{{row.gender}} 2）Vue2的代码示例，Vue2中父组件模板接收子组件中传递过来的信息时子组件必须使用v-bind进行发送，父组件必须使用slot-scope（Vue2.5以下使用scope）属性进行接收： {{row.id}}-{{row.name}}-{{row.age}}-{{row.gender}} Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-09-17 15:50:58 "},"前端专栏/Vue3/生命周期函数.html":{"url":"前端专栏/Vue3/生命周期函数.html","title":"生命周期函数","keywords":"","body":"钩子函数是什么 钩子函数是指在某些时刻必定会运行的一些函数。 Vue组件在从创建至销毁的过程中，官方为我们预留了许多的钩子函数让我们能够在其中进行一些自定义操作。 如发送网络请求，处理业务逻辑等前置或后置性工作。 生命周期函数 以下例举一些常见的Vue3中组件生命周期钩子函数，这里以简写形式举例： beforeCreate：组件创建前 created：组件创建时（推荐在此时发送只请求一次的网络请求） beforeMount：组件挂载模板前 mounted：组件挂载模板时（推荐在此时发送会请求多次的网络请求） beforeUpdate：组件数据更新前 update：组件数据更新时 beforeUnmount：卸载组件前 unmounted：卸载组件时 renderTracked：每次浏览器刷新页面时 renderTriggered：每次Vue重新渲染页面时 详情参见官方文档。 点我跳转 代码示例如下： {{count}} \"use strict\"; const app = Vue.createApp({ data() { return { count: 0 } }, beforeCreate() { console.log(\"beforeCreate\"); }, created() { console.log(\"created\"); }, beforeMount() { console.log(\"beforeMount\"); }, mounted() { console.log(\"mounted\"); }, beforeUpdate() { console.log(\"beforeUpdate\"); }, updated() { console.log(\"updated\"); } }).mount(\"#app\") setInterval(() => { app.count++; console.log(app.count); }, 1000) 官方图示 官方图示如下所示： Vue2.x Vue2中的生命周期函数和Vue3中有一些不一样，但总体逻辑都差不多。 值得一提的是，Vue3中不建议开发人员手动对Vue生命周期进行管理，所以对于beforeUnmount()和unmounted()方法来说不太好验证，但对于Vue2来说则没有这种顾虑，我们可以手动的去卸载一个Vue组件。 Vue2的beforeDestroy相当于Vue3的beforeUnmount Vue2的destroyed相当于Vue3的unmounted 代码示例： {{count}} \"use strict\"; const app = new Vue({ el: \"#app\", data() { return { count: 0 } }, beforeCreate() { console.log(\"beforeCreate\"); }, created() { console.log(\"created\"); }, beforeMount() { console.log(\"beforeMount\"); }, mounted() { console.log(\"mounted\"); }, beforeUpdate() { console.log(\"beforeUpdate\"); }, updated() { console.log(\"updated\"); }, beforeDestroy(){ console.log(\"beforeDestroy\"); }, destroyed(){ console.log(\"destroyed\"); } }) setInterval(() => { app.count++; console.log(app.count); }, 1000) // 通过cpn.destroyed()可卸载组件，根组件无法卸载故不再进行演示 Vue2的生命周期函数图示： Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-09-29 23:45:26 "},"前端专栏/Vue3/动画效果.html":{"url":"前端专栏/Vue3/动画效果.html","title":"动画效果","keywords":"","body":"CSS动画 全元素动画 使用标签对需要执行切换动画的内容进行包裹。 然后定义下面这些内置类，所有的标签都会在元素切换时作用到这些动画效果： 时机 描述 v-enter-from 定义进入过渡的开始状态 v-enter-active 定义进入过渡生效时的状态 v-enter-to 定义进入过渡的结束状态 v-leave-from 定义离开过渡的开始状态 v-leave-active 定义离开过渡生效时的状态 v-leave-to 定义离开过渡的结束状态 我们定义一个过渡动画，下面例子中的2个都会生效： 代码示例： /* 动画进入前 */ .v-enter-from { transform: translate(3rem); opacity: 0; } /* 动画进入时 */ /* 动画退出时 */ .v-enter-active, .v-leave-active { transition: all 2s ease-out; opacity: .5; } /* 动画进入完 */ /* 动画退出前 */ .v-enter-to, .v-leave-from { opacity: 1; } /* 动画退出完 */ .v-leave-to { transform: translate(3rem); opacity: 0; } use HELLO Vue3 use 1 2 3 \"use strict\"; const app = Vue.createApp({ data() { return { spanCondition: false, ulCondition: false } } }).mount(\"#app\") 单元素动画 我们可以为标签定义一个name属性，然后将动画执行的时机类中的v切换成的name属性，即可为一个单一的元素做动画效果。 时机 描述 name-enter-from 定义进入过渡的开始状态 name-enter-active 定义进入过渡生效时的状态 name-enter-to 定义进入过渡的结束状态 name-leave-from 定义离开过渡的开始状态 name-leave-active 定义离开过渡生效时的状态 name-leave-to 定义离开过渡的结束状态 我们定义了两个帧动画，一个用于进场切换，一个用于出场切换，但它们仅对生效： 代码示例： @keyframes moveIn { from { transform: translate(3rem); opacity: 0; } to { transform: translate(0); opacity: 1; } } @keyframes moveOut { from { transform: translate(0); opacity: 1; } to { transform: translate(3rem); opacity: 0; } } /* 动画进入时 */ .span_move-enter-active { animation: moveIn 1.5s ease-in; } /* 动画退出时 */ .span_move-leave-active { animation: moveOut 1.5s ease-out; } use HELLO Vue3 use 1 2 3 \"use strict\"; const app = Vue.createApp({ data() { return { spanCondition: false, ulCondition: false } } }).mount(\"#app\") 帧/过渡动画 如果想同时使用帧动画和过渡动画，可在标签上利用下面2个属性进行配置： type属性：值可以是animation或者transition，如果帧动画和过渡动画的执行时长不一样，你可以指定采取谁的执行时长 duration属性：值是一个number或者Object，定义帧动画和过渡动画的总执行时长，它的优先级最高 下面这个例子中，我们为的切换定义了2组帧动画以及一组过渡动画，执行时长通过duration属性指定为3000毫秒： 代码示例，帧动画负责元素的移动，过渡动画负责透明度的变化： @keyframes moveIn { from { transform: translate(3rem); } to { transform: translate(0); } } @keyframes moveOut { from { transform: translate(0); } to { transform: translate(3rem); } } .v-enter-from { opacity: .2; } /* 过渡动画 */ .v-enter-from { opacity: 0; } .v-enter-active, .v-leave-active { transition: all 2s ease-out; opacity: .5; } .v-enter-to, .v-leave-from { opacity: 1; } .v-leave-to { opacity: 0; } /* 帧动画 */ .v-enter-active { animation: moveIn 10s ease-in; } .v-leave-active { animation: moveOut 10s ease-out; } use HELLO Vue3 \"use strict\"; const app = Vue.createApp({ data() { return { condition: false, } } }).mount(\"#app\") JavaScript动画 transition的钩子方法 我们可以在标签中定义一些属性，这些属性均指向其组件中的方法，依次来做JavaScript动画。 可定义的属性如下。 注意，在enter和leave钩子函数中必须使用done进行回调。 由于JavaScript动画应用比较少，故不再进行详细举例，官方示例： body { margin: 30px; } .box { width: 30px; height: 30px; background: teal; margin-top: 20px; } Toggle \"use strict\"; const app = Vue.createApp({ data() { return { show: false } }, methods: { beforeEnter(el) { gsap.set(el, { scaleX: 0.8, scaleY: 1.2 }) }, enter(el, done) { gsap.to(el, { duration: 1, scaleX: 1.5, scaleY: 0.7, opacity: 1, x: 150, ease: 'elastic.inOut(2.5, 1)', onComplete: done }) }, leave(el, done) { gsap.to(el, { duration: 0.7, scaleX: 1, scaleY: 1, x: 300, ease: 'elastic.inOut(2.5, 1)', }) gsap.to(el, { duration: 0.2, delay: 0.5, opacity: 0, onComplete: done }) } } }).mount(\"#app\") 元素切换的动画 当我们有多组元素需要进行切换显示时，可以为其添加一个切换动画，让切换过程看起来更美观。 在标签中可指定以下2个属性： mode属性：值可以是in-out或者是out-in，意味切换动画时先进先出亦或是先进后出 appear属性：无值，让页面开始时就执行动画 演示效果： 代码示例： .v-leave-active { transition: opacity .3s } .v-enter-from, .v-leave-to { opacity: 0 } .btn { background-color: #00ae80; width: 4rem; height: 2rem; line-height: 2rem; text-align: center; padding: .5rem; color: #fff; border-radius: 20px; cursor: pointer; } NO OFF \"use strict\"; const app = Vue.createApp({ data() { return { condition: true } } }).mount(\"#app\") 组件切换的动画 组件的切换过程也可以添加动画效果，如下所示： 代码示例： .v-leave-active { transition: opacity .3s } .v-enter-from, .v-leave-to { opacity: 0 } switch cpn \"use strict\"; const app = Vue.createApp({ data() { return { choiceCpn: \"cpn1\" } }, components: { cpn1: { template: `cpn1`, data() { return { style: { background: \"red\", padding: \".2rem\", display: \"inline-block\", color: \"#fff\" } } } }, cpn2: { template: `cpn2`, data() { return { style: { background: \"blue\", padding: \".2rem\", display: \"inline-block\", color: \"#fff\" } } } } }, methods: { switchCpn(event) { this.choiceCpn = this.choiceCpn === \"cpn1\" ? \"cpn2\" : \"cpn1\"; } } }).mount(\"#app\") 列表组动画 使用标签对需要切换动画的元素组进行包裹，元素组通常是指由v-for定义的一系列元素。 效果如下，我们定义了一个组，当点击add或者remove时，组的内容会发生变更，于此同时会搭配上一些动画效果。 注意，这里的动画是为组内的每一个元素项进行作用，而非整个组。 代码示例： .list-item { display: inline-block; margin-right: 10px; } .list-enter-active, .list-leave-active { transition: all 1s ease; } .list-enter-from, .list-leave-to { opacity: 0; transform: translateY(30px); } Add Remove {{ item }} \"use strict\"; const Demo = { data() { return { items: [1, 2, 3, 4, 5, 6, 7, 8, 9], nextNum: 10 } }, methods: { randomIndex() { return Math.floor(Math.random() * this.items.length) }, add() { this.items.splice(this.randomIndex(), 0, this.nextNum++) }, remove() { this.items.splice(this.randomIndex(), 1) } } } Vue.createApp(Demo).mount('#list-demo') 使用第三方库 在实际开发中，我们更多的是选用第三方动画库，如animate.css进行动画切换。 你只需要指定动画类即可，可指定的动画类有： 属性 描述 enter-active-class 开始的动画类 leave-active-class 结束的动画类 示例如下： 代码示例： 切换 const app = Vue.createApp({ data() { return { status: false } } }).mount(\"#app\") Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-09-18 18:24:10 "},"前端专栏/Vue3/自定义指令.html":{"url":"前端专栏/Vue3/自定义指令.html","title":"自定义指令","keywords":"","body":"全局指令 使用app.directive注册全局指令，全局指令在所有组件的模板作用域中都能使用。 如下所示我们定义了一个v-focus指令，当页面刷新后自动获取表单元素的焦点： \"use strict\"; const app = Vue.createApp({}); // 注册全局指令v-focus app.directive('focus', { // 绑定指令的钩子函数 mounted(el) { el.focus(); } }) app.mount(\"#app\") 局部指令 在组件内部定义directives对象，注册局部指令，局部指令只有在其注册组件的模板作用域中才能使用。 如下所示我们定义了一个v-focus指令，当页面刷新后自动获取表单元素的焦点： \"use strict\"; const app = Vue.createApp({ directives: { // 注册局部指令v-focus focus: { // 绑定指令的钩子函数 mounted(el) { el.focus() } } } }); app.mount(\"#app\") 指令钩子 一个指令定义对象可以提供如下几个钩子函数 (均为可选)，它们会在不同的时期让指令进行生效： created：指令创建时调用 beforeMount：指令绑定了但组件未被挂载时调用 mounted：指令绑定了且组件已被挂载时调用 beforeUpdate：需要更新组件内容时时调用 updated：组件内容已更新时调用 beforeUnmount：卸载组件前调用 unmounted：卸载组件时调用 钩子参数 在一个指令的钩子函数中，我们可以利用以下的一些参数来获取元素标签以及被绑定的值： el：获取元素标签 binding：获取绑定的值 比如： 它们获取的值是： el : binding.arg : \"left\" binding.value : 200 如果你的指令更加复杂，那么binding应该能满足你的需求，你可以在官方文档中找到关于binding的更多attribute。 完整代码示例： \"use strict\"; const app = Vue.createApp({ directives: { position: { // 绑定指令的钩子函数 mounted(el, binding) { console.log(el); console.log(binding); } } } }); app.mount(\"#app\") Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-09-19 15:59:14 "},"前端专栏/Vue3/Mixins.html":{"url":"前端专栏/Vue3/Mixins.html","title":"Mixins","keywords":"","body":"基本介绍 Mixins机制是Vue2中经常使用的一种手段，Vue3中也同样支持，但是使用的场景越来越少了。 它意在将多个组件中具有相同内容的地方进行提炼，如下所示，我们的cpn1和cpn2的data以及methods都是相同的，因此可以将这些共有的部分提炼成一个Mixin对象： 代码示例： \"use strict\"; const common = { data() { return { message: \"hello world\" } }, methods: { change(event) { this.message = this.message.toUpperCase() } } } const app = Vue.createApp({ components: { cpn1: { mixins: [common,], template: \"cpn1-{{message}}\" }, cpn2: { mixins: [common,], template: \"cpn2-{{message}}\" } } }).mount(\"#app\") 属性覆盖 如果组件中拥有和Mixin对象中的同名属性或方法，那么只会运行组件中的属性或方法。 代码示例： \"use strict\"; const common = { data() { return { message: \"hello mixin\" } } } const app = Vue.createApp({ components: { cpn1: { mixins: [common,], template: \"{{message}}\", data() { return { message: \"hello cpn1\" } } } } }).mount(\"#app\") 钩子函数 如果Mixin对象中定义了生命周期钩子函数，而组件中也定义了同名的生命周期钩子函数，那么会先运行Mixin对象的生命周期钩子函数，再运行组件自己的生命周期钩子函数。 代码示例： \"use strict\"; const common = { created(){ console.log(\"mixin created running\"); } } const app = Vue.createApp({ components: { cpn1: { mixins: [common,], template: \"cpn\", created(){ console.log(\"cpn created running\"); } } } }).mount(\"#app\") 普通属性 如果Mixin对象中定义了一个普通属性，那么在组件中想要使用这个普通属性时需要加上$options的前缀符进行访问，因为它不会将Mixin的普通属性放入到data中： \"use strict\"; const common = { message : \"hello mixin\" } const app = Vue.createApp({ components: { cpn1: { mixins: [common,], template: \"{{this.$options.message}}\", } } }).mount(\"#app\") 实际上$options会将所有的组件中的普通属性进行存入，如下所示： \"use strict\"; const common = { message : \"hello mixin\" } const app = Vue.createApp({ components: { cpn1: { mixins: [common,], template: \"{{this.$options.message}}\", cpnName : \"cpn1\", mounted(){ console.log(this.$options.cpnName); // cpn1 } } } }).mount(\"#app\") 如果Mixin对象和组件都定义了同名的普通属性，那么会优先选择组件中的同名属性。 我们可以通过配置项来更改这个优先级，用于决定组件到底使用哪一个普通属性，如下所示： \"use strict\"; const common = { message: \"hello mixin\" } const app = Vue.createApp({ components: { cpn1: { mixins: [common,], template: \"{{this.$options.message}}\", message: \"hello cpn\" } } }) // 这会作用到内部所有组件中 app.config.optionMergeStrategies.message = (mixinValue, cpnValue) => { // 先返回mixin的，如果没有再返回cpn的 return mixinValue || cpnValue; } app.mount(\"#app\") 全局注册 上面的Mixin对象的注册方式为局部注册，只能在cpn1中生效： const app = Vue.createApp({ components: { cpn1: { mixins: [common,], template: \"{{this.$options.message}}\", } } }) 我们可以将Mixin对象改为全局注册，这样所有的组件中都能访问Mixin对象中的属性以及方法了： \"use strict\"; const app = Vue.createApp({ components: { cpn1: { template: \"{{this.$options.message}}\", } } }) // 全局注册 app.mixin({ message: \"hello mixin\" }) app.mount(\"#app\") Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-09-24 22:25:28 "},"前端专栏/Vue3/teleport传送门.html":{"url":"前端专栏/Vue3/teleport传送门.html","title":"teleport传送门","keywords":"","body":"需求场景 在某些情况下，我们需要让一个组件的作用发生到另一个组件上，此时就需要teleport传送门进行实现。 举个例子，我们有3个组件： 登录框组件（子组件） 主内容组件（父组件） 遮罩层组件（全局组件） 我们希望在主内容组件上点击登录按钮时，会触发登录框组件以及遮罩层组件的显示，同时遮罩层组件将作用在主内容组件上。 整体逻辑如下图所示： 这个过程就是将遮罩层组件作用在主内容组件身上。 代码实现 通过teleport来实现这一个需求： 登录 欢迎登录 提交取消 \"use strict\"; const maskCpn = { template: \"#mask-tpl\" } const loginCpn = { template: \"#login-tpl\", methods: { // 监听退出事件按钮 close(event) { this.$emit(\"close\"); } } } const contentCpn = { template: \"#content-tpl\", data() { return { status: false } }, components: { loginCpn } } const app = Vue.createApp({ data() { return { maskStatus: false } }, components: { contentCpn } }) app.component(\"maskCpn\", maskCpn); app.mount(\"#app\"); CSS代码如下： * { margin: 0; padding: 0; box-sizing: border-box; } body #content { width: 400px; height: 400px; border: 1px solid #ddd; display: flex; flex-flow: column nowrap; position: relative; } body #content > header { display: flex; justify-content: flex-end; align-items: center; padding-right: 0.2rem; height: 10%; background-color: #aaa; } body #content > main { background: #bbb; height: 90%; } body #content > main #login { background: #fff; position: absolute; left: 50%; top: 50%; transform: translate(-50%, -50%); padding: 0.5rem; z-index: 1; } body #content > main #login div { margin: 0.2rem; } body #content > #mask { position: absolute; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0, 0, 0, 0.5); } Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-09-19 20:01:44 "},"前端专栏/Vue3/CompositionAPI.html":{"url":"前端专栏/Vue3/CompositionAPI.html","title":"CompositionAPI","keywords":"","body":"Composition API Composition API是Vue3中推荐的组件代码书写方式，相较于传统的Options API来说，它能让业务逻辑处理和后期代码维护变的更加简单。 首先我们来看Options API的优缺点，在Options API中，一个组件通常由data()、methods、watch、computed来组成，在这些选项里我们可以将数据和功能进行完美的划分。 但是这样会出现一个问题，随着代码量越来越大，我们对一个功能的追踪也变的越来越困难，因为该功能的不同部分总是分割在了不同的选项中，如我们要追踪关于数据A的所有代码时，需要从data()到methods再至watch中寻找所有数据A出现的地方，这十分的麻烦： 而Composition API从根本上解决了这种问题，它针对一个数据开展一条业务线，当你需要寻找与该数据相关的逻辑代码时，它总是一目了然的展现在你的面前，如下图所示，关于数据A的处理都被封装在了一个函数中，不管是data()、methods亦或是watch的逻辑代码都书写在这一个函数中，这对后期维护来讲非常的方便： setup 基本使用 在Composition API中有一个setup()，该函数能够去代替data()、methods、以及watch和computed，你可以将所有该组件能应用到的代码逻辑都写在这个里面，它具有2个参数，props以及context。 让我们通过Composition API书写一个最简单的例子，现在在setup()函数中你不光可以书写属性，还可以书写方法： {{message}} \"use strict\"; const app = Vue.createApp({ setup(props, context) { const message = \"hello composition api\" function callbackfn(event) { console.log(\"why do you point me?\"); } return { message, callbackfn } } }) app.mount(\"#app\") this的支持 Composition API和Options API两者可以同时使用，它们是不冲突的。 但是需要注意的是，setup()函数取代了Options API中beforeCreate以及created这2个生命周期钩子函数，在官方文档中你可以找到这一则说明： 这意味着，在setup()函数中你不能使用this访问到data中的数据项，但是可以在data()中通过$options拿到setup()返回的对象： {{dataMessage}} {{setupMessage}} \"use strict\"; const app = Vue.createApp({ setup(props, context) { const setupMessage = \"hello composition api\" // console.log(this.dataMessage); // Cannot read properties of undefined return { setupMessage } }, data() { const dataMessage = \"hello options api\" console.log(this.$options.setup()); // {setupMessage: 'hello composition api'} return { dataMessage } } }) app.mount(\"#app\") 响应式数据 非响应式支持 Options API中data()返回的数据均是响应式的： + &nbsp;{{number}}&nbsp; - \"use strict\"; const app = Vue.createApp({ data() { let number = 0 return { number } } }) app.mount(\"#app\") 而Composition API中setup()返回的数据并不是响应式的： + &nbsp;{{number}}&nbsp; - \"use strict\"; const app = Vue.createApp({ setup(props, context) { let number = 0 return { number } } }) app.mount(\"#app\") ref ref能够让值类型的数据在Composition API中具有响应式特征，使用前你需要引入它： const { ref } = Vue; let number = ref(0) 它本质上是将这个数据进行了proxy包装，格式如下： proxy({value:0}) 当我们需要在setup()函数内部修改该值时，必须使用该代理器的value属性进行修改，如： number.value++ 但是在模板中需要修改该值则可直接进行修改： number++ 示例如下： + + &nbsp;{{number}}&nbsp; - - \"use strict\"; const app = Vue.createApp({ setup(props, context) { const { ref } = Vue; let number = ref(0) const add = event => { number.value++; } const sub = event => { number.value--; } return { number, add, sub } } }) app.mount(\"#app\") reactive reactive能够让引用类型的数据在Composition API中具有响应式特征，使用前你需要引入它： const { reactive } = Vue; let ary = reactive([1, 2, 3, 4, 5]) 它本质上是将这个数据进行了proxy包装，格式如下： Proxy {0: 1, 1: 2, 2: 3, 3: 4, 4: 5} 如果是Object，则包装后的格式如下： Proxy {name: 'Jack', age: 18, gender: 'male'} 我们不管是在模板中，还是在setup()函数中，都可以直接对其进行操作。 示例如下： + + &nbsp;{{ary}}&nbsp; - - \"use strict\"; const app = Vue.createApp({ setup(props, context) { const { reactive } = Vue; let ary = reactive([1, 2, 3, 4, 5]) const push = event => { const lastValue = ary[ary.length - 1] ary.push(lastValue + 1) } const pop = event => { ary.pop() } return { ary, push, pop } } }) app.mount(\"#app\") toRefs 有时候我们并不需要return一个完整的对象，而是return一个对象中单独的某个值，这个时候我们必须通过toRefs对对象进行解构赋值，才能够获得响应对象： {{name}} {{age}} {{gender}} \"use strict\"; const app = Vue.createApp({ setup(props, context) { const { reactive, toRefs } = Vue; let message = reactive({ name: \"Jack\", age: 18, gender: \"male\" }) const { name, age, gender } = toRefs(message) return { name, age, gender } } }) app.mount(\"#app\") 它相当于使用ref对每个值进行包裹，所以说在setup()函数内部修改这些被解构出来的值时，需要使用proxy的value属性进行修改： setup(props, context) { const { reactive, ref } = Vue; let message = reactive({ name: \"Jack\", age: 18, gender: \"male\" }) return { name: ref(message.name), age: ref(message.age), gender: ref(message.gender) } } toRef 在我们对对象进行解构赋值时，有可能出现没有的值，这个时候我们得到的结果是undefined。 如果后续对该值进行修改，让其进行变更时也需要进行响应式支持的话，则必须使用toRef进行解构赋值，如下所示： {{name}} {{age}} {{gender}} {{score}} \"use strict\"; const app = Vue.createApp({ setup(props, context) { const { reactive, toRefs, toRef, ref } = Vue; let message = reactive({ name: \"Jack\", age: 18, gender: \"male\" }) let { name, age, gender } = toRefs(message) // 现在获取的对象是undefined，因为message中没有score属性 let score = toRef(message, \"score\") // 3s后将它修改为100，如果没有使用toRefs对其进行包裹，那么这种变更则不是响应式的 // 它相当于 let score = ref(message.score) || ref(undefined); setTimeout(() => { score.value = 100 }, 3000) return { name, age, gender, score } } }) app.mount(\"#app\") 本节陈述 这一小结主要针对Composition API对数据非响应式支持做出的介绍，Vue3中提供了很多种解决方案，最常用的就是上面举例的4种： ref：让值类型的数据能够支持响应式操作 reactive：让引用类型的数据能够支持响应式操作 toRefs：让解构赋值出的对象和源容器对象之间具备响应式操作 toRef：针对解构赋值没有的对象支持响应式操作 除开reactive，其他诸如ref、toRefs以及toRef的数据变更都需要使用proxy.value属性进行操作。 组件化开发 props参数 我们都知道，在setup()函数中不能使用this，因此在父子通信时父组件传递给子组件的信息需要子组件使用setup()的props参数进行接收，以下是使用方法： {{childRecvData}} \"use strict\"; const { ref, reactive, toRefs, toRef } = Vue const app = Vue.createApp({ setup(props, context) { const fatherData = ref(\"father data\") return { fatherData } } }) app.component(\"cpn\", { template: \"#cpn-tpl\", props: { childRecvData: { required: true, type: String } }, setup(props, context) { // 这里的props等同于上面的props const { childRecvData } = props return { childRecvData } } }) app.mount(\"#app\") context参数 context参数有3个属性可供调用： attrs：相当于no_props的属性继承 slots：能够获取组件中的插槽 emit：能够进行自定义事件 首先是context.attrs，如同no_props一样，它能获取组件使用时所元素身上所绑定的非动态属性： cpn \"use strict\"; const { ref, reactive, toRefs, toRef } = Vue const app = Vue.createApp({}) app.component(\"cpn\", { template: \"#cpn-tpl\", setup(props, context) { console.log(context.attrs[\"data-font-size\"]); // font-size:16px console.log(context.attrs[\"data-font-color\"]); // color:#fff return {} } }) app.mount(\"#app\") 其次是context.slots，它能获取组件中的槽位信息： default slot \"use strict\"; const { ref, reactive, toRefs, toRef, h } = Vue const app = Vue.createApp({}) app.component(\"cpn\", { template: \"#cpn-tpl\", setup(props, context) { // {__v_isVNode: true, __v_skip: true, type: 'span', props: null, key: null, …} console.log(context.slots.default()[0]); // 修改槽位中元素样式 return () => h(\"div\", { style: \"color:#aaa\" }, [context.slots.default()]) } }) app.mount(\"#app\") 最后是context.emit，它能发送自定义事件，可用于子组件向父组件传递信息，这个是最常用的属性： cpn \"use strict\"; const { ref, reactive, toRefs, toRef, h } = Vue const app = Vue.createApp({ setup(props, context) { function callbackfn(...params) { console.log(params); // ['child data'] } return { callbackfn } } }) app.component(\"cpn\", { template: \"#cpn-tpl\", setup(props, context) { const childData = \"child data\" context.emit(\"readEvent\", childData) return {} } }) app.mount(\"#app\") readonly 通过readonly让对象不可更改，这种不可更改是更深层次的限定，比如数组嵌套对象时，你既不能修改外部数组中的内容，也不能修改内部对象中的内容。 下面是readonly简单的使用例子，我们可将它用于组件通信当中，对于一些只能看不能修改的数据非常方便： {{message}} \"use strict\"; const { ref, reactive, toRefs, toRef, readonly } = Vue const app = Vue.createApp({ setup(props, context) { // 只能看，不能改 const message = readonly( reactive( [ { id: 1, name: \"Jack\", age: 19 }, { id: 1, name: \"Tom\", age: 18 }, { id: 1, name: \"Mary\", age: 21 } ] ) ) return { message } } }) app.mount(\"#app\") inject与provide 令人激动的消息，相信在之前学习组件通信时，你对props和emit的通信方式心存怨念，认为这样太麻烦了。 不错，有许许多多的人和你具有同样的想法，这不，在Vue3中迎来了更简单好用的组件通信方式，即inject()和provide()。 使用它们就像是使用消息发布订阅系统一样，你只需要在某一个组件上通过provide()发送出一则数据，那么该Vue应用下所有的组件都可以使用inject()来对该数据进行接收。 这意味着兄弟组件、爷孙组件等都可以直接的进行通信了，而不再是将数据一层一层的进行传递。 下面是一个简单的使用案例： {{message}} \"use strict\"; const { ref, reactive, toRefs, toRef, readonly, inject, provide } = Vue const app = Vue.createApp({ setup(props, context) { const message = readonly( reactive( [ { id: 1, name: \"Jack\", age: 19 }, { id: 1, name: \"Tom\", age: 18 }, { id: 1, name: \"Mary\", age: 21 } ] ) ) // 发布数据，指定key和value provide(\"message\", message) return {} } }) app.component(\"cpn\", { template: \"#cpn-tpl\", setup(props, context) { // 订阅数据，指定key和defaultValue，如果没有该数据则采用defaultValue const message = inject(\"message\", \"default value\") return { message } } }) app.mount(\"#app\") 计算属性 computed Composition API中的computed使用与Options API中computed的使用已经不同了。 你必须先导入它然后再到setup()中进行定义，示例如下，computed()参数可以是一个function： {{number1}} {{number2}} number1 + 1 number1 - 1 \"use strict\"; const { ref, reactive, computed } = Vue; const app = Vue.createApp({ setup(props, context) { let number1 = ref(100); let number2 = computed(() => { return number1.value * 2 }) return { number1, number2 } } }) app.mount(\"#app\") get和set Composition API中的computed()参数也可以是一个Object，该Object允许定义get和set方法，这意味着你可以对computed attribute进行重新赋值。 示例如下： + &nbsp;{{number}}&nbsp; - \"use strict\"; const { ref, reactive, computed } = Vue; const app = Vue.createApp({ setup(props, context) { let _n = ref(100); let number = computed({ get() { console.log(\"computed get()\"); return _n.value; }, set(newValue) { console.log((\"computed set()\")); _n.value = newValue; } }) return { number } } }) app.mount(\"#app\") 数据侦听 watch 同computed一样，如果你想在Composition API中使用watch进行数据监听，则必须先导入后使用。 以下是关于watch最基本的使用，当点击元素时，会触发watch侦听： count \"use strict\"; const { ref, reactive, watch } = Vue; const app = Vue.createApp({ setup(props, context) { let count = ref(0); // 要监听的属性，回调函数(新值，旧值) watch(count, (newValue, oldValue) => { console.log(`count ${oldValue} => ${newValue}`); }) return { count } } }) app.mount(\"#app\") Compostion API中的watch允许监听对象的某一个属性，这非常的便捷，如下所示我们只侦听ary中最后一位数据项的变化： \"use strict\"; const { ref, reactive, watch } = Vue; const app = Vue.createApp({ setup(props, context) { let ary = reactive( [\"A\", \"B\", \"C\", \"D\"] ); function callbackfn(index, event) { ary[index] = event.target.value } // 第一个参数必须是一个函数，返回你要侦听的对象属性 // 第二个参数是回调函数(新值，旧值) // 如下所示，只侦听ary的最后一个元素变更 watch(() => ary[ary.length - 1], (newValue, oldValue) => { console.log(`ary last element change : ${oldValue} => ${newValue}`); }) return { ary, callbackfn } } }) app.mount(\"#app\") Composition API中的watch现在可以更加方便的实现监听多个属性的变化了，相对于Options API中的watch这一点十分强大。 下面这个例子中不管是number1发生改变还是number2发生改变，都将触发watch的回调函数： {{number1}} {{number2}} \"use strict\"; const { ref, reactive, watch } = Vue; const app = Vue.createApp({ setup(props, context) { let number1 = ref(100); let number2 = ref(100); // watch(数组, 回调函数(数组, 数组)=>{}) watch([number1, number2], ( ( [number1NewValue, number1OldValue], [number2NewValue, number2OldValue] ) => { console.log(`number1 change ${number1NewValue} ${number1OldValue}`) console.log(`number2 change ${number2NewValue} ${number2OldValue}`) } )) return { number1, number2 } } }) app.mount(\"#app\") watch中允许传入第三个参数配置对象，如下示例: {{message}} \"use strict\"; const { ref, reactive, watch } = Vue; const app = Vue.createApp({ setup(props, context) { let message = reactive( [ { id: 1, name: \"Jack\", age: 19 }, { id: 1, name: \"Tom\", age: 18 }, { id: 1, name: \"Mary\", age: 21 } ] ) watch(message, ((newValue, oldValue) => { console.log(`message change ${oldValue} => ${newValue}`); } ), { // 及早侦听，默认为false，如果为true，它将会在页面一打开就触发callbackfn，而不是在数据发生变更时才触发callbackfn // 默认的watch为false，即惰性侦听，只有在在数据发生变更时才触发callbackfn immediate: true, // 深度侦听，默认为true， 即当多层对象嵌套时它会侦听所有对象内部的变化，而不仅仅是一层 deep: true }) return { message, } } }) app.mount(\"#app\") watchEffect Composition API中新增了watchEffect侦听。 它与watch侦听的区别在于： watchEffect是对当前setup()函数下所有数据的全局侦听，而watch只能侦听一个或者多个，需要我们手动进行配置 watchEffect的侦听回调函数是没有参数的，而watch侦听的回调函数是具有参数的 watchEffect的侦听是及早侦听，而watch的侦听默认是惰性侦听（可通过配置项配置为及早侦听） 如下示例，我们使用watchEffect侦听当前setup()函数中所有数据的变化： name age gender male female \"use strict\"; const { ref, reactive, watchEffect } = Vue; const app = Vue.createApp({ setup(props, context) { let name = ref(\"\"); let age = ref(0); let gender = ref(\"male\"); // 会监听name、age、gender。 // 只能拿到当前的值，不能拿到之前的值 watchEffect(() => { console.log(\"start watchEffect\"); console.log(name.value); console.log(age.value); console.log(gender.value); }) return { name, age, gender } } }) app.mount(\"#app\") 其他知识 钩子函数变更 在Options API中如果你需要定义生命周期钩子函数，则只需要新增对应的选项即可，如： \"use strict\"; const app = Vue.createApp({ beforeCreate(){ console.log(\"beforeCreate\"); }, created(){ console.log(\"created\"); } }) app.mount(\"#app\") 而在Composition API中，你必须先导入这些钩子函数，然后在setup()函数中对它们进行使用，注意导入时需要加上前缀on，如下所示： \"use strict\"; const { onBeforeMount, onMounted } = Vue; const app = Vue.createApp({ setup(props, context) { onBeforeMount(() => { console.log(\"beforeMount\"); }) onMounted(() => { console.log(\"mounted\"); }) } }) app.mount(\"#app\") 官方例举了它们详细的变更记录，如下表所示： Options API Composition API beforeCreate 没有了，被setup()函数取代了 created 没有了，被setup()函数取代了 beforeMount onBeforeMount mounted onMounted beforeUpdate onBeforeUpdate updated onUpdated beforeUnmount onBeforeUnmount unmounted onUnmounted errorCaptured onErrorCaptured renderTracked onRenderTracked renderTriggered onRenderTriggered activated onActivated deactivated onDeactivated 辅助性函数 setup()中可以定义任何数据或者对象，当你的业务非常复杂时，我们也可以定义多个辅助性函数来让代码结构更清晰，如下所示： {{aData.a}} {{bData.b}} \"use strict\"; const { ref, reactive, computed } = Vue; // 数据A相关逻辑 function logicA() { const _a = ref(\"a\"); const a = computed({ get() { return _a.value } }) const callbackfn = () => { console.log(\"hello a\"); } return { a, callbackfn } } // 数据B相关逻辑 function logicB() { const _b = ref(\"b\"); const b = computed({ get() { return _b.value } }) const callbackfn = () => { console.log(\"hello b\"); } return { b, callbackfn } } const app = Vue.createApp({ setup(props, context) { // 调用辅助性函数 const aData = reactive(logicA()); console.log(aData); const bData = reactive(logicB()); return { aData, bData } } }) app.mount(\"#app\") 获取真实DOM对象 在某些时候我们需要获取真实的一个DOM对象，该如何做呢？ 其实你可以为这个元素绑定一个ref属性，该ref属性指向setup()函数中的一个变量。 然后我们可以通过这个变量的value属性拿到真实的DOM对象，它同样也适用于为组件进行绑定。等同于Vue2中的this.$refs的用法。 整体流程如下所示： span div \"use strict\"; const { ref, reactive, onMounted } = Vue; const app = Vue.createApp({ setup(props, context) { // 2. 绑定的变量必须通过ref进行包裹 let spanNode = ref(null); let divNode = ref(null); // 3.接下来你就可以通过value属性拿到DOM元素或者组件本身 onMounted(() => { { console.log(spanNode.value); // span console.log(divNode.value); // div } }) // 你必须将它们返回出去 return { spanNode, divNode } } }) app.mount(\"#app\") Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-10-12 16:55:48 "},"前端专栏/Vue3/Vue-CLI.html":{"url":"前端专栏/Vue3/Vue-CLI.html","title":"Vue-CLI","keywords":"","body":"Vue-cli 安装cli Vue-cli是Vue官方发布的构建Vue项目的脚手架，通过Vue-cli我们可以快速的生成Vue项目以及构建开发环境。 一言以蔽之，使用Vue-cli能让你的Vue项目搭建更加轻松，测试更加方便。 首先先全局安装最新版的Vue-cli： $ npm install -g @vue/cli 安装完成后使用以下命令查看版本，注意Vue-cli版本号必须大于4.5才能运行Vue3项目： $ vue -V 如果你之前安装过Vue-cli，可通过以下命令进行升级： $ npm update -g @vue/cli 如果你习惯使用yarn而不是npm，则输入以下命令即可： $ yarn global add @vue/cli -- 安装 $ yarn global upgrade --latest @vue/cli -- 升级 创建项目 在Vue3版本后，对于项目的构建我们推荐使用Vite来进行，在Vue2时期，你可以通过直接通过Vue-cli来构建你的项目，Vite相比于直接通过Vue-cli创建项目来说更加的简单也更容易上手。 下面让我们构建自己的第一个Vue工程化项目，注意项目的命名风格必须是kebab-case风格： $ npm init @vitejs/app 在运行完上面的命令后，它会让你输入构建项目的框架framework，选择vue即可，另外会让你选择语言类型，如果不用TypeScript，则选用vue即可： ✔ Package name: … demo-project ✔ Select a framework: › vue ✔ Select a variant: › vue 下一步我们需要进入到刚刚创建的项目中： $ cd 运行以下命令安装package.json中所有的依赖： $ npm install 接下来你就可以启动这个Vue项目了，默认项目的端口是3000： $ npm run dev 如果你习惯使用yarn而不是npm，则输入以下命令即可： $ yarn create @vitejs/app $ cd $ yarn $ yarn dev 注意！如果你的Node版本是V7及以上，则需要在启动项目之前运行下面这一条命令来重新安装esbuild，否则项目将不能启动： $ node node_modules/esbuild/install.js 以下是启动后的界面，这个count是可以点击的，算是一个小demo吧： 目录解析 以下是整个Vue初始化项目的目录结构： ├── node_modules │ ├── ... ├── public │ └── favicon.ico ├── src │ ├── App.vue │ ├── assets │ │ └── logo.png │ ├── components │ │ └── HelloWorld.vue │ └── main.js ├── index.html ├── package-lock.json ├── package.json ├── README.md ├── .gitignore └── vite.config.js 当前根目录下子目录说明： node_modules：项目所需要的模块安装目录 public：存放公共的静态资源文件 src：源代码文件 *dist：当运行npm run build命令后会生成该目录，存放打包后的资源文件 当前根目录下的文件说明： index.html：由于Vue更多的是单页面开发，所以index.html也就是这个项目的单页面，你可以将它理解为根组件模板，可在此中引入css-reset等文件 package-lock.json：项目中固定版本的依赖包清单文件 package.json：项目中非固定版本的依赖包清单文件，npm脚本存储的文件 README.md：项目的详细信息描述文件 .gitgnore：git管理时忽略的目录或文件清单 vite.config.js：项目配置文件，在Vue2时期该文件名为vue.config.js src目录中的子目录与文件说明： assets：项目中组件的静态资源目录，可创建imgs、video等目录存放静态资源 components：项目中组件的存放目录，可在内创建更详细的子目录用于区分不同功能的组件 App.vue：根组件，即index.html中#div所挂载的组件 main.js：项目入口文件，用于将App.vue和index.html进行挂载联系 *router：存放路由文件的目录，通常情况下需要使用Vue-router插件后方可具备 *store：存放数据文件的目录，通常情况下需要使用VueX插件后方可具备 npm脚本 使用Vite构建Vue项目后，它默认的会添加3个npm脚本，我们可以在package.json中查看到： { \"scripts\": { \"dev\": \"vite\", // 启动开发服务器 \"build\": \"vite build\", // 为生产环境构建产物 \"serve\": \"vite preview\" // 本地预览生产构建产物 } } 运行npm脚本，你需要通过以下方式执行上面的3个命令： $ npm run 脚本名称 我们还可以指定额外的命令行选项，如 --port或 --https。运行npx vite --help获得完整的命令行选项列表。 启动流程 当我们执行了npm run dev后，它内部会做哪些事情呢？我们可以从index.html文件中入手，首先它的结构其实很简单，就是一个普普通通的HTML文件，只不过在标签内部加入了根组件模板元素div#app以及导入了main.js： 接下来我们可以看一下main.js，可以很清晰的看到它就是通过App.vue创建了一个Vue应用： import { createApp } from 'vue' import App from './App.vue' createApp(App).mount('#app') 而关于App.vue，仔细看以及标签的内容，它的标签内部其实采用了Vue3的语法，下面我们会对其进行详细介绍，至于中的内容你目前可以将它看成下面这一段代码： import HelloWorld from \"./components/HelloWorld.vue\"; export default { components: { HelloWorld, }, }; 这一段代码的意思是说，导出了一个默认的组件，并且该组件中注册了一个HelloWorld的子组件，而且还在模板中进行了使用，至于为什么App.vue中这个导出的组件没有定义template属性呢，实际上它内部已经定义好了，就是指向下面这个template。 然后我们需要看一下，HelloWorld组件，也是关注一下标签就好，你可能现在看不懂这个文件（你电脑上的），没关系，我们可以参照下面这个代码： export default { name : \"HelloWorld\", props : { msg : String }, data(){ return { count : 0 } } } 很简单，它通过props接收了一个msg，就是App.vue中传递的那个。 然后内部的data()中返回了一个count，这个count计数为0。其他就没什么了，至此我们的启动流程算是跑完了，以下是关于初始化项目中组件的划分： 一些细节 @符号 在Vue2的组件中当你需要通过import语句导入其他组件或资源时，可通过@符号代指src目录，如下示例： import HelloWorld from \"@/components/HelloWorld.vue\"; 但是在Vue3中需要我们自己来进行配置，打开vite.config.json文件，粘贴一下内容即可： import { resolve } from 'path' import { defineConfig } from 'vite' import vue from '@vitejs/plugin-vue' // https://vitejs.dev/config/ export default defineConfig({ plugins: [vue()], resolve: { alias: { \"@\": resolve(__dirname, \"src\") } } }) 如果你熟悉webpack，那么上面的操作对你来说肯定不会陌生，如果你不熟悉webpack也没关系，它其实就是为src目录取一个别名而已。 vue文件 vue文件你可以将它认为是一个独立的组件，通常情况下该文件的命名风格均采用大驼峰式命名法。 我们以App.vue来进行举例，每个vue文件都有3部分组成，且在中书写组件时不需要指定template属性，它内部会自动的进行挂载： // 组件内容 // 组件模板 // 组件样式 下面我们可以自己书写一个组件，并在App.vue中进行注册： # src/components/Test.vue export default { name: \"test\", data() { return { message: \"test component\", }; }, }; {{ message }} div { display: inline-block; background: #fff; padding: 1rem; } 然后再到App.vue中导入并注册： # src/components/App.vue import Test from \"@/components/Test.vue\" export default { components: { Test, }, }; #app { font-family: Avenir, Helvetica, Arial, sans-serif; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; text-align: center; color: #2c3e50; margin-top: 60px; } 注意在导入一个vue文件时必须要添加上后缀名： import Test from \"./components/Test.vue\"; 如果你不想添加后缀名，也可以通过vite.config.js来进行设置，总体配置和webpack差不多： import { resolve } from 'path' import { defineConfig } from 'vite' import vue from '@vitejs/plugin-vue' // https://vitejs.dev/config/ export default defineConfig({ plugins: [vue()], resolve: { alias: { \"@\": resolve(__dirname, \"src\") }, extensions: [\".vue\",] // 忽略后缀名，自动匹配 } }) 当配置完成后，在导入vue文件时就不需要加上后缀了： import Test from \"@/components/Test\"; style - scoped 通过观察可以发现，除了根组件App.vue外的其他组件中，标签会多一个属性scoped。 添加了该属性的的样式只会在当前组件中生效。 这意味着App.vue的全局生效的，你可以在此引入一些公共的样式资源，如reset-css： @import url(\"./assets/css/css-reset.css\"); script - setup Vue3的工程化项目中，几乎所有的标签都会有一个setup属性，这正是Composition API所带来的变化。 它的意思在于，在这个标签中你可以直接书写之前在setup()中的代码，且不用再进行return暴露接口的操作。 除此之外，它内部会自动进行export将该组件进行导出，如下所示： 我们以HelloWorld组件来进行举例，下面是它原本的代码，实际上就是Composition API的setup()简写： // 不用return {msg} ，内部会自动进行 // 也不用return export， 内部会自动进行 import { ref } from 'vue' defineProps({ msg: String }) const count = ref(0) 将它修改成完整的Composition API，效果一致，代码量增加： import { ref } from \"vue\"; export default { name: \"HelloWorld\", props: { msg: String, }, setup(props, context) { return { count: ref(0), }; }, }; 将它修改成Options API，效果一致，代码量增加： export default { name : \"HelloWorld\", props : { msg : String }, data(){ return { count : 0 } } } setup中的API 实际上是实验的功能，不排除后期会全部进行应用。 在中编写代码时，需要注意以下API的变更。 如果想注册组件，直接import即可，它会自动进行注册： import Cpn from \"@/components/Cpn.vue\" 使用defineProps替代props： const props = defineProps({ foo: String }) 使用defineEmits代替context.emit()： // 先注册 const emit = defineEmits(['change', 'delete']) // 再使用 emit(\"change\", \"Hello\") emit(\"delete\", 1) 其他更多API请参阅官方文档 项目上手 项目一览 我们以一个todolist来作为Vue-cli的熟悉项目，最终效果如下： 上面这个例子由1个大组件和3个小组件构成，分别是： main-cpn：整体组件 header-cpn：头部组件 left-cpn：左侧日程选择组件 right-cpn：右侧日程展示组件 我们需要在components目录中新建一个toListCpn的子目录，并且将这些组件放进去，再次提醒，vue文件的命名要以大驼峰式命名法进行： src/components/ └── toListCpn ├── Header.vue ├── Left.vue ├── Main.vue └── Right.vue 选项式API演示 首先需要从App.vue中引入Main.vue，并且定义一些全局样式： import Main from \"./components/toListCpn/Main.vue\"; export default { components: { Main, }, }; * { margin: 0; padding: 0; box-sizing: border-box; } #app { display: flex; justify-content: center; align-items: center; height: 100vh; } 其次是Main.vue的代码，我们定义了事件列表eventList与一系列修改事件列表的方法，因为该组件所产生的数据对象eventList会分发给其他组件，所以当其他组件需要修改事件列表时也必须依赖该组件所提供的方法： import Header from \"./Header.vue\"; import Left from \"./Left.vue\"; import Right from \"./Right.vue\"; export default { name: \"Main\", data() { return { eventList: [], }; }, methods: { registerEvent(time, event) { this.eventList.push({ time, event, finish: false }); }, unRegisterEvent(index) { this.eventList.splice(index, 1); }, changeEventStatus(index) { this.eventList[index].finish = !this.eventList[index].finish; }, }, components: { Header, Left, Right, }, }; main { border: 1px solid #ddd; background: #4ca64c; } main:before { clear: both; content: \"\"; display: block; } 接下来是Header.vue的代码，Header组件只需要获取eventList即可，因为它仅展示eventList中的已注册事件和已完成事件： {{ currentTime }} 已完成({{ getFinishEvent }})/今日事件({{ getTotalEvent }}) export default { name: \"Header\", props: { eventList: Array, }, computed: { getTotalEvent() { return this.eventList.length; }, getFinishEvent() { return this.eventList.reduce((pre, cur, idx, ary) => { return (pre += cur.finish ? 1 : 0); }, 0); }, currentTime() { const date = new Date(); let format = \"YYYY年MM月DD日\"; const config = { YYYY: date.getFullYear(), // 获取年份 MM: date.getMonth() + 1, // 获取月份，月份+1是因为Js中的月份是0-11 DD: date.getDate(), // 获取天数 HH: date.getHours(), // 获取小时 mm: date.getMinutes(), // 获取分 ss: date.getSeconds(), // 获取秒 }; for (const key in config) { format = format.replace(key, config[key]); } return format; }, }, }; #header { width: 400px; height: 80px; padding: 0.5rem; margin-bottom: 0.5rem solid #ddd; border-bottom: 1px solid #ddd; } #header div:first-of-type { font-size: 1.6rem; } #header div:last-of-type { font-size: 0.8rem; } 然后是Left.vue的代码，Left组件中只需要接收注册事件的方法即可： {{ time }} export default { name: \"Left\", props: { registerEvent: Function, }, data() { return { eventDescribe: \"\", eventTime: null, }; }, computed: { timeList() { let time = []; for (let i = 0; i #left { width: 200px; height: 200px; padding: 0.5rem; float: left; border-right: 1px solid #ddd; background: #4cd66a; } #left input { width: 100%; height: 18%; margin-bottom: 2%; outline: none; } #left ul { list-style: none; text-align: center; height: 80%; overflow-y: scroll; background: #fff3fe; } #left ul li:hover { background-color: #ddd; font-size: 1.4rem; cursor: pointer; } 最后是Right.vue的代码，Right组件中所做的工作比较多，需要注销事件、修改事件状态、删除事件，但是代码量很少，因为这些方法都在Main组件中定义好了，直接调用即可，如下所示： {{ row.time }} {{ row.event }} 删除 export default { name: \"Right\", props: { eventList: Array, unRegisterEvent: Function, changeEventStatus: Function, }, }; #right { width: 200px; height: 200px; padding: 0.5rem; float: left; overflow-y: scroll; background: #fff3fe; } #right > ul { height: 100%; margin-bottom: 2%; } #right > ul li:after { clear: both; content: \"\"; display: block; } #right > ul li:hover button { display: inline-block; } #right > ul li { border: 1px solid #aaa; padding: 0 0.5rem; height: 1.5rem; } #right > ul li > input[type=\"checkbox\"] { margin-right: 5%; } #right > ul li > time { width: 3rem; display: inline-block; margin-right: 5%; text-align: left; } #right > ul li > span { width: 70%; } #right > ul li > button { float: right; } #right > ul li > button { display: none; } 组合式API演示 我们基于上面选项式API来将所有的JavaScript代码改装成Vue3的组合式API。 首先是App.vue，它只需要直接导入Main组件即可，内部会自动将该组件注册成为App的子组件： import Main from \"./components/toListCpn/Main.vue\"; 其次是Main.vue，在它里面我们需要使用reactive将eventList修改为响应式的，且还需要使用provide将数据分发给子组件们： import { reactive } from \"vue\"; import { provide } from \"vue\"; import Header from \"./Header.vue\"; import Left from \"./Left.vue\"; import Right from \"./Right.vue\"; const eventList = reactive([]); const registerEvent = (time, event) => { eventList.push({ time, event, finish: false }); }; const unRegisterEvent = (index) => { eventList.splice(index, 1); }; const changeEventStatus = (index) => { eventList[index].finish = !eventList[index].finish; }; provide(\"eventList\", eventList); provide(\"registerEvent\", registerEvent); provide(\"unRegisterEvent\", unRegisterEvent); provide(\"changeEventStatus\", changeEventStatus); 下面是Header.vue的代码，Header组件只需要通过inject接收Main组件中provide过来的eventList即可： {{ currentTime }} 已完成({{ getFinishEvent }})/今日事件({{ getTotalEvent }}) import { inject } from \"vue\"; import { computed } from \"vue\"; let eventList = inject(\"eventList\"); let getTotalEvent = computed(() => { return eventList.length; }); let getFinishEvent = computed(() => { return eventList.reduce((pre, cur, idx, ary) => { return (pre += cur.finish ? 1 : 0); }, 0); }); let currentTime = computed(() => { const date = new Date(); let format = \"YYYY年MM月DD日\"; const config = { YYYY: date.getFullYear(), // 获取年份 MM: date.getMonth() + 1, // 获取月份，月份+1是因为Js中的月份是0-11 DD: date.getDate(), // 获取天数 HH: date.getHours(), // 获取小时 mm: date.getMinutes(), // 获取分 ss: date.getSeconds(), // 获取秒 }; for (const key in config) { format = format.replace(key, config[key]); } return format; }); 然后是Left.vue的代码，这里面需要借助inject、computed以及ref，注意在timeClickfn()的回调函数中eventDescribe等经过ref包裹的属性设置值时一定要通过proxy.value属性进行： import { inject } from \"vue\"; import { computed } from \"vue\"; import { ref } from \"vue\"; const registerEvent = inject(\"registerEvent\"); const eventDescribe = ref(\"\"); const eventTime = ref(null); const timeList = computed(() => { let time = []; for (let i = 0; i { if (!eventDescribe.value) { alert(\"您还未输入日程信息\"); return; } eventTime.value = time; registerEvent(eventTime.value, eventDescribe.value); eventDescribe.value = \"\"; }; 最后是Right.vue，它的改造最简单，只需要将props接收的属性通过inject接收即可： import { inject } from \"vue\"; const eventList = inject(\"eventList\"); const unRegisterEvent = inject(\"unRegisterEvent\"); const changeEventStatus = inject(\"changeEventStatus\"); Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-10-03 20:26:10 "},"前端专栏/Vue3/Vue-Router.html":{"url":"前端专栏/Vue3/Vue-Router.html","title":"Vue-Router","keywords":"","body":"Vue-Router 基本介绍 Vue-Router是Vue全家桶中至关重要的一个扩展化插件，使用它能够让我们的组件切换更加的方便，更加容易的开发前后端分离项目，目前Vue-Router版本已更新到4.x，我们就以4.x为例了解它的用法。 官方文档 后端路由 学习Vue-Router之前，我们有必要了解一下什么是后端路由。 在早期前后端混合开发时，前端具体所展示的内容是由后端负责的，也就是说用户在浏览器中的一次请求操作会直接传递到后端服务器上，后端服务器会根据这个请求内容返回给浏览器不同的页面，如下所示： 前端路由 现在的项目越来越大，前后端混合的开发模式并不适用于大型项目，于是出现了前后端分离的开发模式，即用户在页面上所有静态资源请求大部分都是面向前端服务器发起的，然后再由前端服务器动态请求后端服务器的API接口获得所需要展示的数据最终结合前端服务器中的静态资源反馈给浏览器： 前置知识 简单认识url 用户与Web服务器之间是经由浏览器通过url打交道的，因此在学习Vue-Router插件之前你应该掌握一些必要的url相关知识。 下面是url的组成部分，截图自Node.js官网中对url的描述： 值得注意的是，auth部分是对身份权限的认证，目前在绝大多数应用中已经极少看到了，因此这里不再进行介绍。 我们以下面这个url进行说明： https://localhost/book/1?page=2#caption_01 释义如下： https：代指请求协议，最常见的有http与https协议 localhost：为host主机部分，其实完整写法应该是localhost:80，但是浏览器会自动为我们填上一个80的端口号，所以上面没有显式的写出来 /book/1：这一段是path即请求的资源路径（服务器上不一定真实存在），通常情况下/book这一段是固定的。而/1这个只是一个书籍编号而已，它不是固定的，因此对于1来说他可以作为查询的params，即查询参数，这在RestAPI设计风格中极为常见 ?page=2：这一段是请求的具体参数，即query部分，指的是我们请求book1这本书从第2页开始 #caption_01：一个锚点的跳转，用于定位具体的内容，当打开这个url后它会直接跳转到第二章节，注意该部分绝大多数情况下都不会被路由系统所处理 单页面原理 Vue单页面开发的原理实际上就是利用标签的锚点切换来完成的，举个例子。 访问下面的这个url就是主页： http://loclhost/#/index 跳转时只需要修改锚点的定位即可，如从首页跳转到新闻页面： http://loclhost/#/news 下面我们基于此原理利用原生的HTML+CSS来实现一个单页面应用： 代码示例： * { margin: 0; padding: 0; box-sizing: border-box; list-style: none; } .components { display: none; } :target { display: block; } body header { background-color: #565656; height: 48px; } body header ul { height: 100%; display: flex; flex-flow: row wrap; align-items: center; padding: 1rem; } body header ul li:first-of-type, body header ul li:nth-of-type(2) { margin-right: 2rem; } body header ul li:last-of-type { margin-left: auto; } body header ul li a { color: #fff; text-decoration: none; } body main { display: flex; justify-content: center; align-items: center; margin-top: 68px; font-size: 5rem; } 主页 新闻 后台 HELLO INDEX HELLO NEWS HELLO BACKEND hash与history Vue-Router中对于组件的切换有2种模式，分别是hash模式和history模式。 当使用hash模式时，若你访问/index页面则浏览器地址栏中的url是这个样子的： http://loclhost/#/index 而使用history模式时，url看起来会正常许多： http://loclhost/index 使用hash模式的优缺点如下： 优点是#后面的信息永远不会被发送到Vue服务器的路由上，因此不会出现请求错误的情况 缺点是对SEO会有不好的影响，以及看起来不是那么美观 而使用history模式的优缺点如下： 优点是组件的切换看起来不再是锚点定位了，更加的美观了 缺点是如果用户在浏览器中直接访问某个嵌套的子组件时，会报404错误，并且我们还需要在服务器上加上一个回退路由，所以配置比较麻烦 hash模式是我们在开发时建议使用的，尽管history模式让url看起来美观了许多，但是你需要做一些额外的配置，过程比较繁琐，你可以参阅官方文档寻找这部分的资料。 hash和history其实都是window的2个子对象，使用location.hash可修改当前url中#后的部分，比如我们在浏览器的控制台中输入以下命令： location.hash = \"/index\" 你会发现浏览器的地址栏中url会变更为： http://localhost:5500/#/index 同理，history模式也提供了一些链接跳转的方法支持。 如，在浏览器的控制台中输入以下命令： history.pushState({}, \"\", \"/index\") 你会发现浏览器的地址栏中url会变更为： http://localhost:5500/index 如果你想了解更多，请参照之前JavaScript中的widnow对象章节。 历史记录栈 当浏览一个网页时，只要地址栏中的url发生改变都会被浏览器记录到一个“栈”中。 如下所示，我们先浏览了index.html、然后又浏览了news.html、最后浏览了backend.html： 当你点击back按钮或者调用router.back()以及history.back()方法后，它会向后回退一格，同时图中左侧的计数器也会发生变化： 同理，当你点击forward按钮或者调用router.forward()以及history.forward()方法后，它又会向前推进一格，回到图1的状态： 如果你通过router.go()或者history.go()方法，并且填入的参数是-2时，那么它会向后回退2格，变成下面这种状态： 而router.replace()的意思是，跳转至新的页面，并且清空整个栈，如下所示，它等同于history.replaceState()方法： 基本使用 初始化项目 使用Vite生成项目，跟随指引一步一步的进行初始化： $ npm init @vitejs/app 进入到项目根目录下，安装Vue-Router插件，输入以下命令后它将会安装Vue-Router 4.x的最新版本： $ npm install vue-router@4 在src下新建一个router目录，并在其中新建一个index.js文件，该文件将作为Vue-Router插件的入口文件存在： $ mkdir ./src/router $ touch ./src/router/index.js 删除.src/components/HelloWorld.vue： $ rm -rf ./src/components/HelloWorld.vue 清空.src/App.vue中的代码，并粘贴下面的代码： hello world 接下来你就可以启动这个Vue项目了，默认项目的端口是3000： $ npm run dev 快速的上手 我们需要先准备3个组件、分别是Index、Book、Hot，代码基本一致： Hello Index h1 { font-size: 8rem; } 要想使用Vue-Router插件，我们就必须在.src/router/index.js文件中对其进行引入： // 1. 导入使用hash模式、使用history模式、以及创建全局路由对象的方法 import { createWebHashHistory, createWebHistory, createRouter } from \"vue-router\"; // 2. 导入组件 import Index from \"../components/Index.vue\" import Book from \"../components/Book.vue\" import Hot from \"../components/Hot.vue\" // 3.配置路由映射表 const routes = [ { path: \"/index\", component: Index }, { path: \"/book\", component: Book }, { path: \"/hot\", component: Hot }, ] // 4.创建全局路由对象，并且使用hash模式初始化这个全局路由对象 const router = createRouter({ routes, history: createWebHashHistory() }) // 5.导出全局路由对象 export default router 然后需要到.src/main.js中为当前的Vue应用加载这个插件： import { createApp } from 'vue' import App from './App.vue' import router from \"./router/index\" const app = createApp(App); // 加载插件 app.use(router); app.mount('#app'); 最后修改一下App.vue的代码，我们要在App.vue中使用以及组件来做路由的入口和出口，注意以及组件都是Vue-Router所自带的组件，内部已完成全局注册，可以直接使用： 主页 书籍 热门 后，路由表中的组件会在此处显示 --> // 注册组件 import Index from \"./components/Index.vue\"; import Book from \"./components/Book.vue\"; import Hot from \"./components/Hot.vue\"; /* 全局样式设置 */ * { margin: 0; padding: 0; box-sizing: border-box; list-style: none; } header#header { height: 50px; padding: 1rem; background: #565656; display: flex; justify-content: flex-start; align-items: center; box-shadow: #aaa 0 5px 5px; } header#header a { text-decoration: none; margin-right: 2rem; color: #fff; } main#main { display: flex; flex-flow: column; justify-content: center; align-items: center; height: 80vh; } 实际上中的to属性也可以不用进行动态绑定，而是直接填入path，但是我们并不推荐这样使用： 主页 主页 name具名路由 对.src/index.js里routes中每一条rule对象，我们都可以为它们加上一个name属性： const routes = [ { path: \"/index\", name: \"index\", component: Index }, { path: \"/book\", name: \"book\", component: Book }, { path: \"/hot\", name: \"hot\", component: Hot }, ] 这样在为模板中的设置to属性时，可以动态的绑定一个对象并指定需要跳转的rule的name属性即可： 主页 书籍 热门 alias路由别名 对.src/index.js里routes中每一条rule对象，我们都可以为它们加上一个alias属性： const routes = [ { path: \"/index\", name: \"index\", alias: [\"/index.htm\", \"/index.html\"], component: Index } ] 配置好之后不管你访问下面那个url，它都会跳转至Index组件中： http://localhost:3000/index http://localhost:3000/index.htm http://localhost:3000/index.html redirect重定向 如果想在路由中定义重定向，则只需要配置redirect属性即可： const routes = [ { path: \"/\", redirect: { name: \"index\" } }, { path: \"/index\", name: \"index\", alias: [\"/index.htm\", \"/index.html\"], component: Index }, ] 这样当你访问 localhost:3000 时，它会自动跳转到Index中。 meta定义路由元信息 对.src/index.js里routes中每一条rule对象，我们都可以为它们加上一个meta属性： const routes = [ { path: \"/index\", name: \"index\", alias: [\"/index.htm\", \"/index.html\"], meta: { title: \"主页\", verify: false }, component: Index } ] 在后续开发时，我们能通过一些方式拿到这些内容，因此你可以将meta属性定义成这个route的附加信息： import { onMounted } from \"vue\"; import { useRoute } from \"vue-router\"; const route = useRoute(); onMounted(() => { console.log(route.meta.verify); console.log(route.meta.title); }); router-link的点按效果 默认的点击后没有任何样式，我们可以在App.vue中配置一个全局的style，它的作用在于所有的点击后都会应用这个样式类，如下所示： .router-link-active { text-shadow: #ddd 2px 5px 5px !important; } 最终结果： 你也可以为每个单独添加active-class属性，然后定义属性值的class style，它的优先值高于.router-link-active： // template 主页 // style .choice_index{ color : red !important; } 路由对象 Router介绍 useRouter()是Vue-Router中提供的一个构造方法，调用它可以得到一个全局的Router对象，即整个routes路由映射表。 如果想在模板中使用这个全局路由对象，你可以直接像下面这样操作： {{ $router }} 要想在脚本中使用这个全局路由对象你必须先对其进行导入： import { useRouter } from \"vue-router\"; 接下来需要进行实例化操作： const router = useRouter(); 而后你就可以使用这个全局路由对象了，全局路由对象中可以调用很多方法、如push()、back()等，如下表所示： 方法 描述 push() 等同于window.history.pushState()，打开一个新的url replace() 等同于window.history.replaceState()，打开一个新的url，并清空当前活动窗口的历史记录 back() 等同于window.history.back()，执行页面回退操作 forward() 等同于window.history.forward()，执行页面前进操作 go(±n) 等同于window.history.go()，执行页面回退或前进n个操作 Route介绍 useRoute()是Vue-Router中提供的一个构造方法，调用它可以得到一个当前活动的Route对象，即当前所匹配到的rule。 如果想在模板中使用这个活动路由对象，你可以直接像下面这样操作： {{ $route }} 要想在脚本中使用这个活动路由对象你必须先对其进行导入： import { useRoute } from \"vue-router\"; 接下来需要进行实例化操作： const route = useRoute(); 而后你就可以使用这个活动路由对象了，活动路由对象中可以调用很多属性、如path、name等，如下表所示： 属性 描述 path 获取当前活动路由的path name 获取当前活动路由的name params 获取当前活动路由的params query 获取当前活动路由的query meta 获取当前活动路由的meta hash 获取当前活动路由的hash redirectedFrom 获取当前活动路由的前一个跳转链接 在脚本中进行跳转 如果你想在进行路由跳转，可以调用router.push()或者router.replace()方法，如下所示： import { onMounted } from \"vue\"; import { useRouter } from \"vue-router\"; const router = useRouter(); onMounted(() => { router.push({ name: \"book\" }); }); 获取路由的元信息 如果你想在中获取当前路由的meta元信息，可以调用route.meta获得整个meta对象，如下所示： import { onMounted } from \"vue\"; import { useRoute } from \"vue-router\"; const route = useRoute(); onMounted(() => { console.log(route.meta); }); 路由视图 嵌套视图 组件是允许嵌套的，当然也同样支持嵌套，举个例子，我们的Index中有2个子组件分别是login和register，当点击这2个组件中任何一个时我们希望在Index中展示这2个组件，而不是单独进行跳转。 首先我们需要在routes中为rule配置children选项，如下所示，注意第2层rule的path必须加上前缀： const routes = [ { path: \"/index\", name: \"index\", alias: [\"/index.htm\", \"/index.html\"], meta: { title: \"主页\", verify: false }, component: Index, children: [ { path: \"/index/login\", name: \"login\", meta: { title: \"登录\" }, component: Login }, { path: \"/index/register\", name: \"register\", meta: { title: \"注册\" }, component: Register }, ] }, ] 其次是需要在Index组件中开放和，此外还需要在Index组件中对Login和Register组件进行注册： 注册 登录 import Register from \"./Register.vue\"; import Login from \"./Login.vue\"; import { onMounted } from \"vue\"; import { useRoute } from \"vue-router\"; const route = useRoute(); onMounted(() => { console.log(route.meta); }); #index-header { height: 2rem; border: 1px solid #ddd; display: flex; align-items: center; padding: 0.5rem; background: #6b6b6b; } #index-header a { color: #fff; text-decoration: none; } #index-header a:first-of-type { margin-right: 0.5rem; } #index-main { width: 200px; height: 100px; border: 1px solid #ddd; display: flex; justify-content: center; align-items: center; } 下面是Login和Register组件的代码，它们的结构基本一致： login 效果展示，首先最外部的App.vue中具有一个，它主要作用于主页、书籍以及热门的切换，而在Index.vue中也具有一个，它则只用于登录或者注册的切换，于是这个嵌套关系就出来了： 命名视图 嵌套视图是具有层级的，而命名视图没有层级，即可以在一个组件模板中多次使用，它是一种扁平化的设计。 如，头部导航栏，左侧菜单栏，右边内容块三个组件，都显示在一个页面上，就可以使用命名视图，换而言之，命名视图是由多个组件构成一个页面的。 核心代码如下，由于命名视图使用较少，这里不再进行具体演示： // template // .src/router/index.js const routes = [ { path: \"/index\", name: \"index\", alias: [\"/index.htm\", \"/index.html\"], meta: { title: \"主页\", verify: false }, // 由于这个页面是由3个组件构成的，所以这里要使用components而不是component components: { // 如果没有name属性，则用default default: header, menu: menu, show: show, } }, ] 参数相关 params 从restAPI设计规范来看，url的路径不可能全部由routes进行配置，因为params总是动态变化的。 如下所示： GET localhost:3000/#/book // 查询所有书籍 GET localhost:3000/#/book/1 // 查询编号为1的书籍 GET localhost:3000/#/book/2 // 查询编号为2的书籍 我们需要有一个动态的路由机制，在rule中匹配时的代码如下： { path: \"/book/:id?\", name: \"book\", alias: [\"/book.htm\", \"/book.html\"], component: Book } // id代表接收的这个params名称是id // ?代表这个params可以有也可以没有 而则需要向下面这样设置： {{book.name}} 当你需要在模板中取得这个params时，需要通过当前路由对象route获得： {{ $route.params.id }} 当你需要在脚本中取得这个params时，也需要通过当前路由对象route获得： import { useRoute } from \"vue-router\"; const route = useRoute(); route.params.id 我们以Book组件为例，默认它将使用AllBook组件展示所有图书，当你选中一本图书后它将使用BookDetails组件展示书籍详情： Book组件代码如下： import AllBook from \"./AllBook.vue\"; import BookDetails from \"./BookDetails.vue\"; import { provide } from \"vue\"; import { reactive } from \"vue\"; import { useRoute } from \"vue-router\"; const route = useRoute(); const bookAry = reactive([ { id: 1, name: \"红楼梦\", author: \"曹雪芹\", chapter: [ \"第一回 甄士隐梦幻识通灵 贾雨村风尘怀闺秀\", \"第二回 贾夫人仙逝扬州城 冷子兴演说荣国府\", \"第三回 开生面梦演红楼梦 立新场情传幻境情\", ], }, { id: 2, name: \"西游记\", author: \"吴承恩\", chapter: [ \"第一回 灵根育孕源流出 心性修持大道生\", \"第二回 悟彻菩提真妙理 断魔归本合元神\", \"第三回 四海千山皆拱伏 九幽十类尽除名\", ], }, { id: 3, name: \"三国演义\", author: \"罗贯中\", chapter: [ \"第一回 宴桃园豪杰三结义 斩黄巾英雄首立功\", \"第二回 张翼德怒鞭督邮 何国舅谋诛宦竖\", \"第三回 议温明董卓叱丁原 馈金珠李肃说吕布\", ], }, { id: 4, name: \"水浒传\", author: \"施耐庵\", chapter: [ \"第一回 张天师祈禳瘟疫 洪太尉误走妖魔\", \"第二回 王教头私走延安府 九纹龙大闹史家村\", \"第三回 史大郎夜走华阴县 鲁提辖拳打镇关西\", ], }, ]); provide(\"bookAry\", bookAry); AllBook组件代码如下： {{ book.name }} import { inject } from \"vue\"; const bookAry = inject(\"bookAry\"); BookDetails组件代码如下： {{ book.name }} {{ book.author }} {{ chapter }} import { inject } from \"vue\"; const bookAry = inject(\"bookAry\"); query 在发送具有条件筛选的请求、或者提交具有数据的请求时query是非常常用的。 如下这个例子： GET localhost:3000/#/book/1?chapter=2 // 查询编号为1的书籍的第二章 而对于则需要向下面这样设置： {{book.name}} 当你需要在模板中取得这个query时，需要通过当前路由对象route获得： {{ $route.query.chapter }} 当你需要在脚本中取得这个params时，也需要通过当前路由对象route获得： import { useRoute } from \"vue-router\"; const route = useRoute(); route.query.chapter 这里我们不再进行演示，因为它和params是非常相似的。 导航守卫 基本概念 每个组件切换都需要经历两个阶段，你可以将它理解为2个保安。 前置守卫：对切换前的行为进行检查，检查通过后必须调用next()方法才能继续进行切换 后置守卫：对切换后的工作进行善后，可以理解为路由切换组件时最后运行的一个钩子函数 一般来说前置守卫使用较多，后置守卫使用较少。 全局守卫 在router全局路由对象中设置的导航守卫为全局守卫，如下所示我们希望组件在切换时能够获取当前活动路由对象的meta元信息中的title属性，以设置document的title。 下面这段代码可以放在./src/router/index.js中： router.beforeEach((to, from, next) => { // from为当前活动路由对象 // to为即将活动的下一个路由对象 console.log(`from : ${from.path} => to : ${to.path}`); next(); }) router.afterEach((to, from)=>{ document.title = to.meta.title || \"Web Site\" }) 路由守卫 我们也可以对某个route单独的配置守卫，当然这很少使用到： const routes = [ { path: \"/\", redirect: { name: \"index\" } }, { path: \"/index\", name: \"index\", component: Index, beforeEnter: (to, from) => { // false拦截、true通过 return false }, } ] 组件守卫 我们也可以单独的为某一个组件添加以下守卫，当然这也很少使用到： import { onBeforeRouteLeave, onBeforeRouteUpdate } from 'vue-router' export default { setup() { onBeforeRouteLeave((to, from, next) => { next() }) onBeforeRouteUpdate((to, from, next) => { next() }) }, } keep-alive 组件缓存 的时候我们希望当组件发生切换后，再次back回来时之前被切换的组件仍然保留被切换之前的状态，当出现这种需求时就可以采用进行组件缓存。 如下示例，我们缓存了Register组件和Login组件，这样在用户输入过程中切换组件会保留组件的状态： 代码如下： 钩子函数 Vue3中提供了2个生命周期钩子函数： onActivated：被 keep-alive 缓存的组件激活时调用 onDeactivated：被 keep-alive 缓存的组件失活时调用 常用属性 以下是上可添加的一些属性： include : string | RegExp | Array 只有名称匹配的组件会被缓存。 exclude : string | RegExp | Array 任何名称匹配的组件都不会被缓存。 max : number | string 最多可以缓存多少组件实例。 示例演示: 其他知识 资源懒加载 在使用Vite进行项目打包后，所有的资源文件都会整合到一起，最终输出一个chunk。 这样做会带来一个问题，当你的项目过大时用户打开页面首次加载chunk会显得非常慢，因为它会将所有的组件、第三方库一次性加载出来。 这种情况下，我们就需要进行按需加载了，对于没有展示的组件或没有使用的第三方库暂时不进行加载，当进行路由跳转时才进行加载，如下所示： // 将 // import UserDetails from './views/UserDetails' // 替换成 const UserDetails = () => import('./views/UserDetails') const router = createRouter({ // ... routes: [{ path: '/users/:id', component: UserDetails }], }) 修改完成后再次打包，你会发现它将输出多个chunk。 组件切换动画 想要在你的路径组件上使用转场，并对导航进行动画处理，你需要使用 v-slot API： Transition 的所有功能 在这里同样适用。 上面的用法会对所有的路由使用相同的过渡。如果你想让每个路由的组件有不同的过渡，你可以将元信息和动态的name 结合在一起，放在上： const routes = [ { path: '/custom-transition', component: PanelLeft, meta: { transition: 'slide-left' }, }, { path: '/other-transition', component: PanelRight, meta: { transition: 'slide-right' }, }, ] 也可以根据目标路由和当前路由之间的关系，动态地确定使用的过渡。使用和刚才非常相似的片段： 我们可以添加一个 after navigation hook，根据路径的深度动态添加信息到meta字段。 router.afterEach((to, from) => { const toDepth = to.path.split('/').length const fromDepth = from.path.split('/').length to.meta.transitionName = toDepth 版本区别 Route和Router 在Options API中，如果想要在中获取Route或者Router需要使用this进行调用： export default { name : \"Index\", data(){ return {} }, mounted(){ console.log(this.$route); console.log(this.$router); } } 组件守卫 在Options API中，组件守卫多了一个钩子函数，尽管很少使用，但是还是要列出来，如下所示： const UserDetails = { template: `...`, beforeRouteEnter(to, from) { // 在渲染该组件的对应路由被验证前调用 // 不能获取组件实例 `this` ！ // 因为当守卫执行时，组件实例还没被创建！ }, beforeRouteUpdate(to, from) { // 在当前路由改变，但是该组件被复用时调用 // 举例来说，对于一个带有动态参数的路径 `/users/:id`，在 `/users/1` 和 `/users/2` 之间跳转的时候， // 由于会渲染同样的 `UserDetails` 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。 // 因为在这种情况发生的时候，组件已经挂载好了，导航守卫可以访问组件实例 `this` }, beforeRouteLeave(to, from) { // 在导航离开渲染该组件的对应路由时调用 // 与 `beforeRouteUpdate` 一样，它可以访问组件实例 `this` }, } keep-alive&transition 在Vue2中，keep-alive和transition调用很简单，如下所示： Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-10-11 14:54:10 "},"前端专栏/Vue3/Vue-X.html":{"url":"前端专栏/Vue3/Vue-X.html","title":"Vue-X","keywords":"","body":"Vue-X 基本介绍 Vue-X是Vue全家桶中非常重要的一环，它能够使我们更加方便的集中管理组件中的数据，在大型项目中Vue-X的使用频率非常之高，因此Vue-X的学习是必不可少的。 目前Vue-X版本已更新到4.x，我们就以4.x为例了解它的用法。 官方文档 优势对比 在之前我们通过props与$emit()亦或是provide()和inject()的方式进行组件通信时，所有的数据都是绑定在某个组件内部的，如果其他组件想要使用以及修改这些数据，则必须由数据源组件将数据与修改方法进行下发。 对于props与$emit()通信来说，它的数据传递过程会显得十分繁琐，必须由父组件通过props一层一层的将数据向下进行传递，或者通过$emit()将数据一层一层往上进行传递，如果组件层级过多，则会导致后期代码维护困难的问题出现。 而Vue-X则将公用数据与组件进行剥离，你可以将它理解为是一个数据仓库，组件树中所有的组件都能从这个数据仓库中获得想要的数据、同时组件树中任何一个组件对仓库中数据的修改均可以影响到其它的组件。 工作流程 每一个Vux-X你都可以将它理解为一个仓库，而在仓库中，有3个重要的概念： actions：行为 mutations：变化 state：状态 我们可以看一下这张图： 释义如下： vue components可以通过dispatch或者commit直接发生行为（actions）或者触发变化（mutations） actions只能是由vue components通过dipatch引起的，且它的作用只能是通过commit触发变化（mutations） state只能由mutations进行改变，并且改变后会及时的将数据进行响应并渲染在所有vue components中 devtools只能监听mutations 换而言之，仓库store中的数据状态（state）会发放给vue components，而当我们想要修改这些数据状态时则必须先通过dispatch发起行为（actions），然后行为会通过commit触发变化（mutations），由变化（mutations）来对仓库中数据的状态（state）进行改变。 或者你可以直接在vue components中通过commit触发变化（mutations），再由变化（mutations）来对仓库中数据的状态（state）进行改变。 不论如何，这是一个单向的工作流程，你不能直接在vue components中修改仓库store中的数据状态（state），因为devtools不会检测这一环节，如果这样做，则会造成数据不可预测的情况发生。 主要组成 以下是整个Vue-X中store的组成部分： state：一个对象，内部可以包含任意类型的数据，是真正存储数据的地方，而对数据的修改只能通过mutations中定义的方法进行 mutations：一个对象，内部能包含一系列的方法，这些方法必须是同步的，它主要的作用在于对state中的数据修改提供接口 actions：一个对象，内部能包含一系列的方法，这些方法可以是同步的或者是异步的，常用于与后端API进行交互，但这些方法不能直接修改state中的数据，必须间接的通过mutations修改state中的数据 getters：一个对象，内部能包含一系列的方法，这些方法必须是同步的，它类似于computed计算属性，当使用getters对象中的方法时不需要加括号即可完成调用 modules：一个对象，主要用于在业务复杂时对数据进行模块化分类 现在我们再来看看下面这张图，你就能完全明白它们的功能了： 基本使用 初始化项目 使用Vite生成项目，跟随指引一步一步的进行初始化： $ npm init @vitejs/app 进入到项目根目录下，安装Vue-X插件，输入以下命令后它将会安装Vue-X 4.x的最新版本： $ npm install vuex@next --save 在src下新建一个store目录，并在其中新建一个index.js文件，该文件将作为Vue-X插件的入口文件存在： $ mkdir ./src/store $ touch ./src/store/index.js 删除.src/components/HelloWorld.vue： $ rm -rf ./src/components/HelloWorld.vue 清空.src/App.vue中的代码，并粘贴下面的代码： hello world 接下来你就可以启动这个Vue项目了，默认项目的端口是3000： $ npm run dev 快速上手 要想使用Vue-X插件，我们就必须在.src/store/index.js文件中对其进行引入： // 1.导入创建仓库的方法 import { createStore } from \"vuex\" // 2.创建仓库并进行配置 const store = createStore({ strict: process.env.NODE_ENV !== \"production\", // 定义数据 state: { counter: 65, }, // 定义多样化展示数据的方法 getters: { char(state) { return String.fromCharCode(state.counter); } }, // 定义修改数据的方法 mutations: { MODIFY(state, playload) { state.counter = playload.number; } }, // 定义请求后端数据的方法 actions: { }, // 对数据进行模块化分类 modules: { } }) // 3.导出仓库 export default store 然后需要到.src/main.js中为当前的Vue应用加载这个插件： import { createApp } from 'vue' import App from './App.vue' import vueX from \"./store/index\" const app = createApp(App); // 加载插件 app.use(vueX); app.mount('#app'); 严格模式 根据第一章中的Vue-X工作流程我们可以得知，state的改变只能通过mutations进行，但是这个条件默认情况下并不是严格限制的，所以我们可以对此开启严格模式进行限制。 注意！因为严格模式在项目上线后会造成性能损失，所以这里采用了一个if条件作为判断，如果是开发模式则开启严格模式、如果是生产模式则关闭严格模式： import { createStore } from \"vuex\" // 开启严格模式 const store = createStore({ strict: process.env.NODE_ENV !== \"production\", state: { ... }, ... }) // 3.导出仓库 export default store 仓库对象 想在组件中使用Vue-X中的数据，我们必须先拿到这个仓库对象。 你可以在组件的模板中直接进行获取： {{ $store }} 要想在组件的脚本中使用这个仓库对象你必须先对其进行导入： import { useStore } from \"vuex\"; 接下来需要进行实例化操作： const store = new useStore(); 而后你就可以使用这个仓库对象了，在仓库对象中的任意数据、方法你都可以拿到。 如，拿到store.state下的counter： // template {{ $store.state.counter }} // script console.log(store.state.counter) state store.state根据图示可以发现，在组件内部它可以直接进行使用，但是当要修改store.state中的数据时必须通过store.mutations中定义的方法进行。 如，我们可以在直接在模板中拿到store.state.counter： {{ $store.state.counter }} 这个时候页面上将显示65，因为在store.state中我们定义的counter为65： state: { counter: 65, }, getters store.getters本质和store.state差不多，store.getters与store.state的关系就如同data与computed的关系，它内部所包含的方法必须是同步的。 我们在组件内部可以直接使用store.getters的方法，但是当要修改store.getters中方法所展示的数据时就必须先通过store.mutations修改store.state中的数据，而一旦store.state中的数据发生变化，那么store.getters中方法所展示的数据会也自动进行更新。 如，我们可以在直接在模板中拿到store.getters.char： {{ $store.state.counter }} -&gt; {{ $store.getters.char }} 这个时候页面上将显示65 -> A，因为store.getters.char方法我们定义的是返回该数字的Unicode字符表现形式： getters: { char(state) { return String.fromCharCode(state.counter); } }, 注意，store.getters中的方法均可定义一个名为state的形参，它指向了当前的store.state。 mutations store.mutations中定义的方法主要是作为修改store.state中所定义的数据而存在的，它内部所包含的方法必须是同步的。 它可以在组件中或者store.actions通过store.commit(type, playload)的方式传递新的数据进入仓库，以便于修改store.state中的数据。 store.commit(type, playload) // type为store.mutations中定义的方法名 // playload可以为store.mutations中定义的方法传递参数，通常情况下它应该是一个对象 如下所示： {{ $store.state.counter }} -&gt; {{ $store.getters.char }} change import { useStore } from \"vuex\"; const store = new useStore(); const generateRandomNumber = () => { const number = Math.floor(Math.random() * (90 - 65 + 1)) + 65; store.commit(\"modify\", { number }); }; 当我们点击按钮后，将触发组件的generateRandomNumber方法，该方法会生成一个65-90之间的随机数，而后会对store进行通知。 当store接到commit()通知后，会在store.mutations中寻找符合type的方法： mutations: { modify(state, playload) { state.counter = playload.number; } }, 注意，store.getters中的方法均可定义一个名为state的形参，它指向了当前的store.state。 而playload形参则接受store.commit()所提交的参数，通常情况下我们希望它传递的是一个对象。 actions store.actions中定义的方法主要是作为获取backend API中的数据而存在的，它内部所包含的方法可以是同步的，也可以是异步的。 它只能在组件中通过store.dispatch(type, playload, ?options)进行调用。 store.dispatch(type, playload, ?option) // type为store.dispatch中定义的方法名 // playload可以为store.dispatch中定义的方法传递参数，通常情况下它应该是一个对象 // options能够为store.dispatch中定义的方法提供一些选项，通常情况下它的使用较少，可以不必关注 注意，store.actions只能获取backend API中的数据，而不能直接修改store.state中定义的数据，我们必须通过store.commit()触发store.mutations下定义的方法，再由它来修改store.state中的数据。 我们用一个最简单的案例来进行说明，下面是一个后端接口，它可以返回一些数据： const Koa = require('koa') const router = require('koa-router')() const koaBody = require(\"koa-body\") const cors = require('@koa/cors') const server = new Koa() server.use(cors()) server.use(router.routes()) server.use(koaBody({ multipart: true })) server.use(async (ctx, next) => { await next(); ctx.response.set(\"Content-Type\", \"application/json\") }) router.post(\"/api/books\", async (ctx, next) => { await next(); const bookList = [ { id: 1, name: \"红楼梦\", price: 199 }, { id: 2, name: \"西游记\", price: 159 }, { id: 3, name: \"三国演义\", price: 149 }, { id: 4, name: \"水浒传\", price: 129 } ] ctx.response.body = JSON.stringify( { code: 200, message: bookList } ) }) server.listen(3001, \"localhost\", 128, () => { console.log(\"server started to http://localhost:3001\"); }) 我们可以在store.actions中定义一个getBooks的方法，它将会对后端/api/books发起请求，然后将bookList通过store.mutations下的addBooks方法添加到store.state中： // 1.导入创建仓库的方法 import { createStore } from \"vuex\" import axios from \"axios\" // 2.创建仓库并进行配置 const store = createStore({ strict: process.env.NODE_ENV !== \"production\", // 定义数据 state: { bookList: [], }, // 定义修改数据的方法 mutations: { addBooks(state, playload) { state.bookList = playload.bookList } }, // 定义请求后端数据的方法 actions: { getBooks(store, playload) { axios({ url: \"/api/books\", baseURL: \"http://localhost:3001\", method: \"POST\", responseType: \"json\" }).then((response) => { if (response.data.code === 200) { const bookList = response.data.message store.commit(\"addBooks\", { bookList }) } }) } }, }) // 3.导出仓库 export default store 在组件中，我们必须使用store.dispatch()方法才能对actions下的方法发起调用。 而对于网络的请求，一般情况下我们会将其放在onCreated()钩子函数（只获取一次的数据）或者onMounted()钩子函数（每次刷新页面都重新获取的数据）中： {{ book.name }} import { useStore } from \"vuex\"; import { onMounted } from \"vue\"; const store = new useStore(); onMounted(() => { store.dispatch(\"getBooks\", {}); }); modules 在之前我们总是将所有的数据存放在一个仓库中，这样管理起来比较杂乱： 其实每个不同类别的数据你都可以将它们做成一个独立的模块，你可以将它理解为一个小仓库，最后再汇总到大仓库中： 示例如下： // 1.导入创建仓库的方法 import { createStore } from \"vuex\" // 2.定义小仓库 const cart = { state: {}, getters: {}, mutations: {}, actions: {}, } // 3.定义大仓库 const store = createStore({ strict: process.env.NODE_ENV !== \"production\", modules: { cart } }) // 4.导出大仓库 export default store 当在使用小仓库下的方法时，你必须加上小仓库的名字： // 获取小仓库中的内容 {{ $store.state.小仓库名字.内容 }} // 调用小仓库的mutations下的方法 store.commit(\"小仓库名字/方法名\", playload) // 调用小仓库的actions下的方法 store.dispatch(\"小仓库名字/方法名\", playload) 实战演示 项目一览 现在我们可以用一个小的demo案例来加深对Vue-X的使用影响。 一个简单的购物车案例，当你在主页中选择商品后，它会将商品添加到购物车中并且计算支付总价。 我们需要2个组件： Index：展示商品信息、勾选商品 Shop：展示购物车信息与购物总价格 以下是项目的成品效果： 后端代码 后端还是采用Node.js + Koa框架进行搭建，一共只有1个API接口，返回一些商品信息： const Koa = require('koa') const router = require('koa-router')() const static = require(\"koa-static\") const path = require('path') const koaBody = require(\"koa-body\") const cors = require('@koa/cors') const server = new Koa() const protocol = \"http\" const hostname = \"localhost\" const port = 3001 const serverAddr = protocol.concat(\":\", \"//\", hostname, \":\", port); server.use(cors()) server.use(router.routes()) server.use(static( path.join(__dirname, \"./static\") )) console.log(path.join(__dirname, \"./static\")); server.use(koaBody({ multipart: true })) server.use(async (ctx, next) => { await next(); ctx.response.set(\"Content-Type\", \"application/json\") }) router.post(\"/api/goods\", async (ctx, next) => { await next(); const goodsList = [ { id: 1, name: \"北京烤鸭\", price: 98, img: serverAddr + \"/1.jpg\" }, { id: 2, name: \"窝窝头\", price: 24, img: serverAddr + \"/2.jpg\" }, { id: 3, name: \"烤山药\", price: 67, img: serverAddr + \"/3.jpg\" }, { id: 4, name: \"小米儿\", price: 18, img: serverAddr + \"/4.jpg\" } ] ctx.response.body = JSON.stringify( { code: 200, message: goodsList } ) }) server.listen(port, hostname, 128, () => { console.log(`server started to ${serverAddr}`); }) 插件代码 对于Vue-X的store目录下的index.js文件，我们可以进行更加详细的拆分。 如将state、getters、mutations、actions、mutations_type以及actions_type还有modules拆分成不同的文件： ./src/store ├── actions.js ├── actions_type.js ├── getters.js ├── index.js ├── modules.js ├── mutations.js ├── mutations_type.js └── state.js 以下各个文件中的代码，首先是./src/store/index.js： import { createStore } from \"vuex\" import state from \"./state\" import getters from \"./getters\" import mutations from \"./mutations\" import actions from \"./actions\" import modules from \"./modules\" export default createStore({ state, getters, mutations, actions, modules }) 下面是./src/store/state.js： export default { // 所有商品信息 /* [ {id : 1, name : \"phone\", price : 98, img : \"http://localhost:30001/x.jpg\"} ] */ goodsList: [], // 当前购物车信息 /* [ {id : 1, name : \"phone\", price : 98, img : \"http://localhost:30001/x.jpg\", number : 1} ] */ shopList: [] } 其次是./src/store/getters.js： export default { // 计算购物车总价 totalPrice(state) { return state.shopList.reduce((pre, goods) => { return pre + goods.price * goods.number }, 0) } } 然后是./src/store/mutations_type.js： export default { // 初始化所有商品数据 loadAllGoods: \"loadAllGoods\", // 向购物车新增一个商品 incrShopList: \"incrShopList\", // 移除购物车中的一个商品 decrShopList: \"decrShopList\", // 修改购物车中的商品数量 changeShopGoodsNumber: \"changeShopGoodsNumber\" } 下面是./src/store/mutations.js： import mutationsType from \"./mutations_type\" export default { // 初始化所有商品数据 [mutationsType.loadAllGoods](state, playload) { state.goodsList = playload.goodsList }, // 先购物车中新增一个商品 [mutationsType.incrShopList](state, playload) { for (const goods of state.shopList) { // 如果存在就数量+1 if (goods.name === playload.goods.name && goods.id === playload.goods.id) { goods.number += 1 return } } // 不存在、直接添加 state.shopList.push(playload.goods) }, // 移除购物车中的一个商品 [mutationsType.decrShopList](state, playload) { state.shopList.splice(playload.goodsIndex, 1) }, // 修改购物车中的商品数量 [mutationsType.changeShopGoodsNumber](state, playload) { // 这里始终是用的加法运算，假如你的购物车中有1个商品，那么 1 + -1 就等于 1 - 1 state.shopList[playload.goodsIndex].number += playload.number } } 以及./src/store/actions_type.js： export default { // 请求所有商品 getAllGoods: \"getAllGoods\" } 还有./src/store/actions.js： import actionsType from \"./actions_type\" import mutationsType from \"./mutations_type\" import axios from \"axios\" export default { // 发送请求，并且将请求后的商品信息添加至 [actionsType.getAllGoods](store, playload) { axios({ baseURL: \"http://localhost:3001\", url: \"api/goods\", method: \"POST\", responseType: \"json\" }).then((response) => { if (response.data.code === 200) { const goodsList = response.data.message; store.commit(mutationsType.loadAllGoods, { goodsList }) } }) } } 最后是modules.js： export default { } 组件代码 定义好Index.vue以及Shop.vue，并在App.vue中进行引入。 下面是./src/App.vue的代码： import Index from \"./components/Index.vue\"; import Shop from \"./components/Shop.vue\"; * { margin: 0; padding: 0; box-sizing: border-box; list-style: none; } #app-tpl { display: flex; flex-flow: column nowrap; padding: 2rem; } Index.vue的代码： {{ goods.name }} ￥{{ goods.price }} import { onMounted } from \"vue\"; import { useStore } from \"vuex\"; import actionsType from \"../store/actions_type\"; import mutationsType from \"../store/mutations_type\"; const store = new useStore(); onMounted(() => { store.dispatch(actionsType.getAllGoods, {}); }); const addShopGoods = (goods, event) => { store.commit(mutationsType.incrShopList, { goods: { ...goods, number: 1 } }); }; #index-tpl { width: 100vw; height: 50vh; display: flex; justify-content: center; align-items: center; } #index-tpl ul { display: flex; justify-content: center; align-items: center; } #index-tpl ul li { display: flex; flex-flow: column nowrap; justify-content: space-between; align-items: center; border: 1px solid #ddd; } #index-tpl ul li .goods_name, #index-tpl ul li .goods_price { background-color: red; width: 100%; text-align: center; color: #fff; font-size: 1.2rem; } #index-tpl ul li .goods_img:hover { cursor: pointer; } 还有Shop的代码： 名称 价格 数量 {{ goods.name }} ￥{{ goods.price * goods.number }} + {{ goods.number }} - 总结 : ￥{{ $store.getters.totalPrice }} import { useStore } from \"vuex\"; import mutationsType from \"../store/mutations_type\"; const store = useStore(); const addGoodsNumber = (goodsIndex, event) => { const number = +1; store.commit(mutationsType.changeShopGoodsNumber, { goodsIndex, number }); }; const subGoodsNumer = (goodsIndex, event) => { const number = -1; // 如果商品购物车中已添加的数量大于1，就不用移除该商品 if (store.state.shopList[goodsIndex].number > 1) { store.commit(mutationsType.changeShopGoodsNumber, { goodsIndex, number }); } // 否则就需要将该商品移除至购物车 else { store.commit(mutationsType.decrShopList, { goodsIndex }); } }; #shop-tpl { width: 100vw; height: 50vh; display: flex; justify-content: center; align-items: flex-start; } #shop-tpl table { border-collapse: collapse; width: 880px; } #shop-tpl table tr td, #shop-tpl table tr th { border: 1px solid #aaa; text-align: center; padding: 0.2rem; } #shop-tpl table thead tr { background: #dddd; } #shop-tpl table tbody tr td:last-of-type span { margin: 0 0.5rem; } #shop-tpl table tbody tr td:last-of-type button { width: 2rem; } #shop-tpl table tr:nth-child(even) { background: #dddd; } 版本区别 创建仓库 在Vue-X4.0之前，创建仓库并不是通过下面的方式创建： import { createStore } from \"vuex\" 而是通过VueX.store()进行创建： import Vue from 'vue' import Vuex from 'vuex' Vue.use(Vuex) const store = new Vuex.Store({ state: { count: 0 }, mutations: { increment (state) { state.count++ } } }) 获取仓库 在Options API中，如果想要在中获取store仓库对象，则需要使用this进行调用： this.$store.state.data; this.$store.commit('mutationsType', playload); this.$store.dispatch('actionsType', playload); Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-10-09 16:55:48 "},"前端专栏/Vue3/axios.html":{"url":"前端专栏/Vue3/axios.html","title":"axios","keywords":"","body":"axios 基本介绍 axios是一个基于Promise的网络请求库，它可以在Node.js与浏览器中运行。 在Node.js中运行axios，它将依赖于http库。 在浏览器中运行axios，它将依赖于XMLHttpResponse。 axios可以说是目前应用最广泛的一款网络请求库，它所提供的接口非常简洁易懂，其名称来源于ax（ajax）io（io）s（system）。 相较于jQuery.ajax()，它更加的智能，比如在上传JSON数据、或者上传文件时你甚至可以直接忽略contentType的设置而直接上传数据。 安装方式 在工程化项目中，推荐使用npm或者yarn进行安装： $ npm install axios $ yarn add axios 在非工程化项目中，你可以使用Boot CDN进行引入： 后端代码 为了方便后续前后端交互的代码测试，我们后端采用Node.js+Koa框架来完成。 IP：localhost PORT：3001 代码如下： const path = require('path'); const fs = require('fs'); // npm install koa --save const Koa = require('koa'); // npm install koa-router --save ： 用于为Koa框架添加路由功能 const router = require('koa-router')(); // npm install koa-body --save : 用于获取POST请求体参数，以及获取文件对象 const koaBody = require('koa-body'); // npm install @koa/cors --save : 用于解决前后端跨域问题 const cors = require('@koa/cors'); const server = new Koa(); server.use(cors()); server.use(koaBody( { // 是否支持 multipart-formdata 的表单 multipart: true, formidable: { // 上传的目录 uploadDir: path.join(__dirname, 'upload'), // 保持文件的后缀 keepExtensions: true, // 最大支持上传8M的文件 maxFieldsSize: 8 * 1024 * 1024, // 文件上传前的设置 onFileBegin: (name, file) => { const filePath = path.join(__dirname, \"upload\"); // 检查是否有upload目录 if (!fs.existsSync(filePath)) { fs.mkdirSync(filePath); console.log(\"mkdir success!\"); } } } } )) server.use(async (ctx, next) => { await next(); ctx.response.set(\"Content-Type\", \"application/json\"); ctx.response.statusCode = 200; }) router.get('/get', async (ctx, next) => { await next(); ctx.response.body = JSON.stringify(ctx.request.query); }); router.post('/post', async (ctx, next) => { await next(); ctx.response.body = JSON.stringify(ctx.request.body); }); router.post(\"/upload\", async (ctx, next) => { await next(); const file = ctx.request.files[\"img\"]; ctx.response.body = JSON.stringify(file); }) server.use(router.routes()); server.listen(3001, \"localhost\"); console.log('server started at http://localhost:3001'); 快速上手 全局配置 在axios中可以配置一些全局设置，如baseUrl或者timeout，如下所示： baseUrl：默认的request host，如当前缀设置为“http://localhost:3001”后，当你发送网络请求时它会自动添加上该前缀 timeout：请求超时时间，默认为0，即永不超时 示例如下，对于这些全局配置我们可以直接书写在一个配置文件当中： import axios from \"axios\"; axios.defaults.baseURL = \"http://localhost:3001\"; axios.defaults.timeout = 2000; GET 以下是发送GET请求的案例，若想携带参数你必须带上params： get import axios from \"axios\"; axios.defaults.baseURL = \"http://localhost:3001\"; axios.defaults.timeout = 2000; const callbackfn = (event) => { axios({ method: \"GET\", url: \"/get\", headers: {}, params: { getParams1: \"v1\", getParams2: \"v2\" }, responseType: \"json\", }) .then((response) => { console.log(response.data); }) .catch((error) => { throw error; }); }; * { margin: 9; padding: 9; } #app { height: 100vh; width: 100vw; display: flex; justify-content: center; align-items: center; } POST 以下是发送POST请求的案例，若想携带参数你必须带上data： post import axios from \"axios\"; axios.defaults.baseURL = \"http://localhost:3001\"; axios.defaults.timeout = 2000; const callbackfn = (event) => { axios({ method: \"POST\", url: \"/post\", headers: {}, data: { postParams1: \"v1\", postParams2: \"v2\" }, responseType: \"json\", }) .then((response) => { console.log(response.data); }) .catch((error) => { throw error; }); }; * { margin: 9; padding: 9; } #app { height: 100vh; width: 100vw; display: flex; justify-content: center; align-items: center; } 上传文件 上传文件必须是POST请求，我们可以利用formData对象来进行上传，如下所示： import axios from \"axios\"; axios.defaults.baseURL = \"http://localhost:3001\"; axios.defaults.timeout = 2000; const callbackfn = (event) => { // 1.封装formData const fd = new FormData(); const file = event.target.files[0]; fd.append(\"img\", file); // 2.发送请求 axios({ method: \"POST\", url: \"/upload\", headers: {}, data: fd, responseType: \"json\", }) .then((response) => { console.log(response.data); }) .catch((error) => { throw error; }); }; * { margin: 9; padding: 9; } #app { height: 100vh; width: 100vw; display: flex; justify-content: center; align-items: center; } 并发请求 如果想一次性发送多个请求，则可以使用all()方法，all()方法应当传入一个Array，并且这个Array中可以包含任意个axios请求，当： all import axios from \"axios\"; axios.defaults.baseURL = \"http://localhost:3001\"; axios.defaults.timeout = 2000; const callbackfn = (event) => { axios .all([ axios({method: \"GET\",url: \"/get\",params: { getParams1: \"v1\", getParams2: \"v2\" }}), axios({method: \"POST\",url: \"/post\", data: { postParams1: \"v1\", postParams2: \"v2\" }}), ]) .then((responseArray) => { responseArray.forEach((response) => { console.log(response.status); console.log(response.data); }); }) .catch((error) => { throw error; }); }; * { margin: 9; padding: 9; } #app { height: 100vh; width: 100vw; display: flex; justify-content: center; align-items: center; } 请求响应 请求配置 以下是请求相关的config，摘自axios官网： { // `url` 是用于请求的服务器 URL url: '/user', // `method` 是创建请求时使用的方法 method: 'get', // 默认值 // `baseURL` 将自动加在 `url` 前面，除非 `url` 是一个绝对 URL。 // 它可以通过设置一个 `baseURL` 便于为 axios 实例的方法传递相对 URL baseURL: 'https://some-domain.com/api/', // `transformRequest` 允许在向服务器发送前，修改请求数据 // 它只能用与 'PUT', 'POST' 和 'PATCH' 这几个请求方法 // 数组中最后一个函数必须返回一个字符串， 一个Buffer实例，ArrayBuffer，FormData，或 Stream // 你可以修改请求头。 transformRequest: [function (data, headers) { // 对发送的 data 进行任意转换处理 return data; }], // `transformResponse` 在传递给 then/catch 前，允许修改响应数据 transformResponse: [function (data) { // 对接收的 data 进行任意转换处理 return data; }], // 自定义请求头 headers: {'X-Requested-With': 'XMLHttpRequest'}, // `params` 是与请求一起发送的 URL 参数 // 必须是一个简单对象或 URLSearchParams 对象 params: { ID: 12345 }, // `paramsSerializer`是可选方法，主要用于序列化`params` // (e.g. https://www.npmjs.com/package/qs, http://api.jquery.com/jquery.param/) paramsSerializer: function (params) { return Qs.stringify(params, {arrayFormat: 'brackets'}) }, // `data` 是作为请求体被发送的数据 // 仅适用 'PUT', 'POST', 'DELETE 和 'PATCH' 请求方法 // 在没有设置 `transformRequest` 时，则必须是以下类型之一: // - string, plain object, ArrayBuffer, ArrayBufferView, URLSearchParams // - 浏览器专属: FormData, File, Blob // - Node 专属: Stream, Buffer data: { firstName: 'Fred' }, // 发送请求体数据的可选语法 // 请求方式 post // 只有 value 会被发送，key 则不会 data: 'Country=Brasil&City=Belo Horizonte', // `timeout` 指定请求超时的毫秒数。 // 如果请求时间超过 `timeout` 的值，则请求会被中断 timeout: 1000, // 默认值是 `0` (永不超时) // `withCredentials` 表示跨域请求时是否需要使用凭证 withCredentials: false, // default // `adapter` 允许自定义处理请求，这使测试更加容易。 // 返回一个 promise 并提供一个有效的响应 （参见 lib/adapters/README.md）。 adapter: function (config) { /* ... */ }, // `auth` HTTP Basic Auth auth: { username: 'janedoe', password: 's00pers3cret' }, // `responseType` 表示浏览器将要响应的数据类型 // 选项包括: 'arraybuffer', 'document', 'json', 'text', 'stream' // 浏览器专属：'blob' responseType: 'json', // 默认值 // `responseEncoding` 表示用于解码响应的编码 (Node.js 专属) // 注意：忽略 `responseType` 的值为 'stream'，或者是客户端请求 // Note: Ignored for `responseType` of 'stream' or client-side requests responseEncoding: 'utf8', // 默认值 // `xsrfCookieName` 是 xsrf token 的值，被用作 cookie 的名称 xsrfCookieName: 'XSRF-TOKEN', // 默认值 // `xsrfHeaderName` 是带有 xsrf token 值的http 请求头名称 xsrfHeaderName: 'X-XSRF-TOKEN', // 默认值 // `onUploadProgress` 允许为上传处理进度事件 // 浏览器专属 onUploadProgress: function (progressEvent) { // 处理原生进度事件 }, // `onDownloadProgress` 允许为下载处理进度事件 // 浏览器专属 onDownloadProgress: function (progressEvent) { // 处理原生进度事件 }, // `maxContentLength` 定义了node.js中允许的HTTP响应内容的最大字节数 maxContentLength: 2000, // `maxBodyLength`（仅Node）定义允许的http请求内容的最大字节数 maxBodyLength: 2000, // `validateStatus` 定义了对于给定的 HTTP状态码是 resolve 还是 reject promise。 // 如果 `validateStatus` 返回 `true` (或者设置为 `null` 或 `undefined`)， // 则promise 将会 resolved，否则是 rejected。 validateStatus: function (status) { return status >= 200 && status 响应结构 以下是响应对象response对象的相关结构，摘自axios官网： { // `data` 由服务器提供的响应 data: {}, // `status` 来自服务器响应的 HTTP 状态码 status: 200, // `statusText` 来自服务器响应的 HTTP 状态信息 statusText: 'OK', // `headers` 是服务器响应头 // 所有的 header 名称都是小写，而且可以使用方括号语法访问 // 例如: `response.headers['content-type']` headers: {}, // `config` 是 `axios` 请求的配置信息 config: {}, // `request` 是生成此响应的请求 // 在node.js中它是最后一个ClientRequest实例 (in redirects)， // 在浏览器中则是 XMLHttpRequest 实例 request: {} } 拦截器 axios中可添加请求或者响应拦截器来对请求或者响应做2次处理： // 添加请求拦截器 axios.interceptors.request.use(function (config) { // 在发送请求之前做些什么 return config; }, function (error) { // 对请求错误做些什么 return Promise.reject(error); }); // 添加响应拦截器 axios.interceptors.response.use(function (response) { // 2xx 范围内的状态码都会触发该函数。 // 对响应数据做点什么 return response; }, function (error) { // 超出 2xx 范围的状态码都会触发该函数。 // 对响应错误做点什么 return Promise.reject(error); }); Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-10-07 23:45:46 "},"前端专栏/Vue3/其他资源.html":{"url":"前端专栏/Vue3/其他资源.html","title":"其他资源","keywords":"","body":"typescript 如果想让你的Vue项目支持TypeScript，你可以在vite新建项目时选择ts： $ npm init @vitejs/app demo-project @vitejs/create-app is deprecated, use npm init vite instead ? Select a framework: › - Use arrow-keys. Return to submit. ❯ vanilla ? Select a framework: › - Use arrow-keys. Return to submit. vanilla ✔ Select a framework: › vue ✔ Select a variant: › vue-ts ts.config.js有一些配置需要我们手动的进行更改，下面是我常用的配置项： { \"compilerOptions\": { \"target\": \"esnext\", \"useDefineForClassFields\": true, \"module\": \"esnext\", \"moduleResolution\": \"node\", \"strict\": true, \"jsx\": \"preserve\", \"sourceMap\": true, \"resolveJsonModule\": true, \"esModuleInterop\": true, \"lib\": [\"esnext\", \"dom\"], \"alwaysStrict\": true, // 启用JavaScript的严格模式 \"noFallthroughCasesInSwitch\": true, // 检测switch语句块是否正确的使用了break \"noImplicitReturns\": true, // 检测函数是否具有隐式的返回值 \"noUnusedLocals\": false, // 检测是否具有未使用的局部变量 \"noUnusedParameters\": false, // 检测是否具有未使用的函数参数 \"allowUnreachableCode\": true, // 检测是否具有永远不会运行的代码 }, \"include\": [\"src/**/*.ts\", \"src/**/*.d.ts\", \"src/**/*.tsx\", \"src/**/*.vue\"] } 在编辑组件的代码时，添加上lang=”ts”属性即可： + {{ counter }} - import { ref, Ref } from \"vue\" let counter: Ref = ref(0); type callbackfn = (event: Event | undefined) => void const add: callbackfn = (e: Event | undefined): void => { counter.value++ } const sub: callbackfn = (e: Event | undefined): void => { counter.value-- } less 如果想让你的Vue项目支持Less，你可以在上添加属性less。 然后安装less即可： $ npm install less --save 其他的诸如scss同理，这里不再演示。 element-ui element-ui是Vue中最受欢迎的UI库，使用它能够更方便的让我们搭建出炫酷的内容。 element-ui的官方文档非常齐全，你可以进行参阅。 注意element-ui的文档有2个版本，分别针对Vue2和Vue3： Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-10-11 11:28:42 "},"前端专栏/Vue3/一个案例.html":{"url":"前端专栏/Vue3/一个案例.html","title":"一个案例","keywords":"","body":"准备工作 ts项目准备 我们准备用Vue3+TypeScript+less+element-ui构建一个非常简单的网站首页。 首先全局安装最新版的Vue-cli： $ npm install -g @vue/cli 再进行项目初始化，语言选择TypeScript： $ npm init @vitejs/app 我们现在可以进入这个目录中了： $ cd ./ $ npm install 编辑ts.config.js，在compilerOptions中新增以下配置项： \"compilerOptions\": { \"alwaysStrict\": true, // 启用JavaScript的严格模式 \"noFallthroughCasesInSwitch\": true, // 检测switch语句块是否正确的使用了break \"noImplicitReturns\": true, // 检测函数是否具有隐式的返回值 \"noUnusedLocals\": false, // 检测是否具有未使用的局部变量 \"noUnusedParameters\": false, // 检测是否具有未使用的函数参数 \"allowUnreachableCode\": true, // 检测是否具有永远不会运行的代码 } 在package.json中新增项目的browserslist： \"browserslist\": { \"development\": [ \"last 1 chrome version\", \"last 1 firefox version\", \"last 1 safari version\" ], \"production\": [ \">0.2%\", \"not dead\", \"not op_mini all\" ] } 在package.json中设置npm脚本： \"scripts\": { \"dev\": \"vite --mode development\", \"build:beta\": \"vite build --mode beta\", \"build:production\": \"vite build --mode production\", \"serve\": \"vite preview\" }, 添加less依赖 下载less即可： $ npm install less --save 安装vue-router 安装vue-router插件： $ npm install vue-router@4 --save 在src下新建一个router目录，并在其中新建一个index.ts文件，该文件将作为Vue-Router插件的入口文件存在： $ mkdir ./src/router $ touch ./src/router/index.ts 在./src/router/index.ts文件中添加以下代码： import { createWebHashHistory, createWebHistory, createRouter, } from \"vue-router\"; const routes: any[] = []; const router = createRouter({ routes, history: createWebHashHistory(), }); export default router; 在.src/main.ts中导入并加载该插件： import { createApp } from \"vue\"; import App from \"./App.vue\"; import router from \"./router/index\"; const app = createApp(App); app.use(router); app.mount(\"#app\"); 安装vue-x 安装vue-x插件： $ npm install vuex@next --save 创建store目录以及index.ts、state.ts、getters.ts、mutations.ts、mutations_type.ts、actions.ts、actions_type.ts、modules.ts。 $ mkdir ./src/store $ touch ./src/store/{index.ts,state.ts,getters.ts,mutations.ts,mutations_type.ts,actions.ts,actions_type.ts,modules.ts} ./src/store/Index.ts代码如下： import { createStore } from \"vuex\"; import state from \"./state\"; import getters from \"./getters\"; import mutations from \"./mutations\"; import actions from \"./actions\"; import modules from \"./modules\"; export default createStore({ state, getters, mutations, actions, modules, }); 此路径下其他的所有文件代码如下： export default {}; 在.src/main.ts中导入并加载该插件： import { createApp } from \"vue\"; import App from \"./App.vue\"; import router from \"./router/index\"; import store from \"./store/index\"; const app = createApp(App); app.use(router); app.use(store); app.mount(\"#app\"); 安装axios 使用npm安装axios： $ npm install axios --save 在.src目录下新建axios目录，并且新增index.ts文件： $ mkdir ./src/axios $ touch ./src/axios/index.ts ./src/axios/index.ts代码如下： import axios from \"axios\"; const baseURL: string = \"http://localhost:3001\"; const responseType: string = \"JSON\"; const timeout: number = 2000; axios.defaults = Object.assign(axios.defaults, { baseURL, responseType, timeout, }); 安装element-ui 下载element-ui-plus： $ npm install element-plus --save 在./src/main.ts中导入element-ui： import { createApp } from \"vue\"; import App from \"./App.vue\"; import router from \"./router/index\"; import store from \"./store/index\"; // 插件本身 import ElementPlus from \"element-plus\"; // 基础样式 import \"element-plus/dist/index.css\"; const app = createApp(App); app.use(router); app.use(store); app.use(ElementPlus); app.mount(\"#app\"); css-reset 在./src/assets中新建一个style目录和css-reset.css文件： $ mkdir ./src/assets/style $ touch ./src/assets/style/css-reset.css 粘贴进以下代码： /* http://meyerweb.com/eric/tools/css/reset/ v2.0 | 20110126 License: none (public domain) */ html, body, div, span, applet, object, iframe, h1, h2, h3, h4, h5, h6, p, blockquote, pre, a, abbr, acronym, address, big, cite, code, del, dfn, em, img, ins, kbd, q, s, samp, small, strike, strong, sub, sup, tt, var, b, u, i, center, dl, dt, dd, ol, ul, li, fieldset, form, label, legend, table, caption, tbody, tfoot, thead, tr, th, td, article, aside, canvas, details, embed, figure, figcaption, footer, header, hgroup, menu, nav, output, ruby, section, summary, time, mark, audio, video { margin: 0; padding: 0; border: 0; font-size: 100%; font: inherit; vertical-align: baseline; } /* HTML5 display-role reset for older browsers */ article, aside, details, figcaption, figure, footer, header, hgroup, menu, nav, section { display: block; } body { line-height: 1; } ol, ul { list-style: none; } blockquote, q { quotes: none; } blockquote:before, blockquote:after, q:before, q:after { content: ''; content: none; } table { border-collapse: collapse; border-spacing: 0; } 在./src/main.ts中进行引入： import \"./assets/style/css-reset.css\"; 项目清理 删除./src/components/HelloWorld组件、删除./src/assets/logo.png图片： $ mv ./src/components/HelloWorld.vue /tmp $ mv ./src/assets/logo.png /tmp 删除./src/App.vue中所有代码，并且填入以下内容： hello world 输入命令，npm run dev，查看项目启动是否正常。 代码书写 组件创建 首先我们的思路是做一个上下分栏的结构，其中Header部分是固定不变的，而Main部分会随着用户的点击根据Vue-Router的路由系统进行跳转。 一共需要5个组件： Index.vue：主页 Other.vue：其它页，其实这里已经不重要了，你可以有任意个其它页组件 LoginRegister.vue：登录和注册组件，它内部会嵌套登录和注册组件 Login.vue：登录组件 Register.vue：注册组件 以下是成品展示： 路由系统 路由系统的代码非常简单，只有主页和其他页的跳转： import { createWebHashHistory, createWebHistory, createRouter, } from \"vue-router\"; import Index from \"../components/Index.vue\"; import Other from \"../components/Other.vue\"; const routes: any[] = [ { path: \"/\", redirect: { name: \"index\" } }, { path: \"/index\", name: \"index\", alias: [\"/index.html\"], meta: { title: \"主页\" }, component: Index, }, { path: \"/other\", name: \"other\", alias: [\"/other.html\"], meta: { title: \"其他页\" }, component: Other, }, ]; const router = createRouter({ routes, history: createWebHashHistory(), }); router.afterEach((to, from) => { let title: any = to.meta.title; document.title = title; }); export default router; App.vue App.vue中主要就是做整体布局，包括和的放置，以及模态框的显示隐藏： 主页 登录 | 注册 import LoginRegister from \"./components/LoginRegister.vue\"; import { ref, Ref } from \"vue\"; export default { setup() { const dialogVisible: Ref = ref(false); return { dialogVisible, }; }, components: { LoginRegister, }, }; :root { font-family: \"Helvetica Neue\", Helvetica, \"PingFang SC\", \"Hiragino Sans GB\", \"Microsoft YaHei\", \"微软雅黑\", Arial, sans-serif; color: #303133; a { color: #303133; text-decoration: none; } } #app-tpl { #global-header { background: #aaa; color: #fff; box-shadow: 0 2px 4px rgba(0, 0, 0, 0.12), 0 0 6px rgba(0, 0, 0, 0.04); .el-row { height: 100%; .el-col:last-of-type { text-align: right; cursor: pointer; span:hover { color: #606266; } } } a { color: #fff; } } } Index.vue Index.vue中主要就是轮播图与吐司信息框的弹出，注意这里的轮播图资源理应是由后端进行返回的： 去其他页看看 import { ElMessage } from \"element-plus\"; import { useRouter } from \"vue-router\"; export default { setup() { const router = useRouter(); const callbackfn = (event: Event) => { ElMessage({ message: \"别点了，跳转不了\", type: \"warning\", }); }; const jump = (event: Event) => { router.push({ name: \"other\" }); }; return { callbackfn, jump, }; }, }; img { height: 400px; } .el-col { margin-bottom: 5rem; } Other.vue Other.vue是用作其他页显示的，这里只是一个模板： 其他页面 LoginRegister.vue LoginRegister.vue中主要是Login组件和Register组件的动态切换： 登录 注册 import { ref, Ref } from \"vue\"; import Login from \"./Login.vue\"; import Register from \"./Register.vue\"; export default { setup() { const component: Ref = ref(\"Login\"); return { component, }; }, components: { Login, Register, }, }; #login-reg-tpl { .el-row:first-of-type { margin-bottom: 1rem; } } Login.vue Login组件中包含了element-ui的表单和验证： 登录 import { reactive, ref } from \"vue\"; export default { setup() { // form表单验证字段 const ruleForm = reactive({ username: null, password: null, }); // form表单验证规则 const rules = reactive({ username: [ { required: true, message: \"必须填入用户名\", }, { min: 3, max: 8, message: \"格式错误，用户名必须大于3且小于8个字符\", }, ], password: [ { required: true, message: \"必须填入密码\" }, { min: 6, max: 16, message: \"格式错误，密码必须大于6且小于16个字符\" }, ], }); // 待验证的form表单 const from = ref(null); const submitForm = (event: Event) => { const cpn: any = from.value; if (cpn !== null) { cpn.validate((valid: boolean): boolean => { // 验证通过 if (valid) { console.log(\"success\"); return true; } // 验证失败 else { console.log(\"fail\"); return false; } }); } }; return { ruleForm, rules, submitForm, from, }; }, }; Register.vue Register组件中包含了element-ui的表单和自定义验证： {{ sendBtnValue }} 注册 import { ref, reactive } from \"vue\"; export default { setup() { let phoneCheckStatus = ref(false); let sendBtnValue = ref(\"发送验证码\"); let tag = 0; let waitSecond = 60; // form表单验证字段 const ruleForm = reactive({ phone: null, code: null, }); // 自定义验证规则 const checkPhoneIsNumber = ( rule: { [attr: string]: any }, value: string, callback: Function ) => { if (!Number.isInteger(Number(value))) { callback(new Error(rule.message)); } else { phoneCheckStatus.value = true; callback(); } }; // form表单验证规则 const rules = reactive({ phone: [ { required: true, message: \"必须填入手机号\" }, { len: 11, message: \"格式错误，手机号必须保证11位\" }, { validator: checkPhoneIsNumber, message: \"手机号必须是纯数字\" }, ], code: [ { required: true, message: \"必须填入验证码\" }, { len: 4, message: \"格式错误，验证码必须保证4位\" }, ], }); // 待验证的form表单 const from = ref(null); const submitForm = (event: Event) => { const cpn: any = from.value; if (cpn !== null) { cpn.validate((valid: boolean): boolean => { // 验证通过 if (valid) { console.log(\"success\"); return true; } // 验证失败 else { console.log(\"fail\"); return false; } }); } }; const sendVerifycode = (event: Event) => { if (tag) { return; } tag = setInterval(() => { if (waitSecond > 1) { waitSecond--; sendBtnValue.value = `请等待${waitSecond}秒`; } else { sendBtnValue.value = \"发送验证码\"; waitSecond = 60; clearTimeout(tag); tag = 0; } }, 1000); sendBtnValue.value = `请等待${waitSecond}秒`; }; return { from, ruleForm, rules, submitForm, sendBtnValue, sendVerifycode, phoneCheckStatus, }; }, }; Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-10-13 15:30:16 "},"前端专栏/Webpack5/summary.html":{"url":"前端专栏/Webpack5/summary.html","title":"Webpack5","keywords":"","body":" 基础介绍 常用配置 devServer 优化配置 配置整理 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-09-09 20:37:08 "},"前端专栏/Webpack5/基础介绍.html":{"url":"前端专栏/Webpack5/基础介绍.html","title":"基础介绍","keywords":"","body":"基本介绍 webpack是前端目前最热门的打包方式，它将所有资源文件当做模块进行处理，并且根据模块的依赖关系进行静态分析和打包处理以便生成对应的静态资源文件，减少页面请求次数。 为什么要使用webpack？可以从以下几点看出它的优势： 模块化：前端拥有各种各样的模块化规则，如ES Module、CommonJs、AMD，如果要将不同的模块化规则所书写的JavaScript文件整合到一起，无疑是一项繁琐的工作，webpack可以自动对其进行转换 预处理：less、scss等这些css预处理文件是不被浏览器所识别的，通过webpack打包过后，可以自动的将其转换为css文件以供浏览器使用，极大提升了开发效率 兼容性：不同的浏览器之间存在兼容性问题，通过webpack可以让你的ES6代码在较低版本的浏览器中进行运行 webpack实际上就是一个模块打包机，它所做的事情无外乎是分析项目、找到浏览器不能运行的扩展语言，将其进行打包和处理并生成新的浏览器能识别的文件。 webpack能做的事情非常多，并且学习难度不大，是非常值得学习的一门技术，本系列基于webpack5来进行探究。 相关概念 配置文件 webpack需要有一个配置文件，用来指定如何对项目进行打包。 例如，当打包时遇到非js、json等模块文件的导入时该怎么做？从哪个文件开始进行打包？打包后的文件放在哪个地方？等等。 它常位于项目根目录下，名为webpack.config.js。 以下是最基本的格式： const { resolve } = require('path'); // node.js模块，用于路径拼接 module.exports = { mode: \"打包模式\", entry: \"入口文件\", output: {}, // 输出设置 module: {}, // 碰见非模块资源该怎么做 plugins: [], // webpack插件相关 } 关于内部的使用，在接下来会进行详细介绍。 entry 在使用webpack对项目进行打包时，我们需要为项目指定一个入口文件（js脚本），webpack会从该入口文件开始寻找当前项目中所有的依赖文件，从而生成一个依赖图。 当遇到非JavaScript模块资源时，webpack会根据用户配置的loader将该资源转变为JavaScript可识别的模块，最终所有的依赖文件都将会被打包处理成bundels文件。 这意味着我们可以在JavaScript代码里导入任意的资源文件，只要有对应的loader将其与JavaScript进行转换即可： import \"./static/css/demo.less\" import \"./static/js/demo.js\" import \"./static/imgs/demo.png\" 常用属性 在webpack.config.js中配置entry属性的值时，可有3种定义方式。 1）值是string，只有一个入口文件，适用于单页面应用，只输出一个chunk（默认为main.js）： const { resolve } = require('path'); module.exports = { mode: \"development\", entry: \"./src/entry.js\", output: { filename: \"main.js\", path: resolve(__dirname, \"dist\") } } 2）值是array，可以有多个入口文件，适用于单页面应用，只输出一个chunk（默认为main.js），它表示的含义是数组最后一个文件是资源的入口文件，数组其余文件会预先构建到入口文件中： const { resolve } = require('path'); module.exports = { mode: \"development\", entry: [\"./src/login.js\", \"./src/index.js\", \"./src/entry.js\"], output: { filename: \"main.js\", path: resolve(__dirname, \"dist\") } } # 上面的代码等同于直接在entry.js中导入login.js和index.js，一般情况下用的很少： import \"./login.js\" import \"./index.js\" 3）值是object，可以有多个入口文件，适用于多页面应用，会输出多个chunk，chunk的名字为对象中key，注意，由于它会输出多个chunk，所以chunk的名字必须要自己定义为不一样的： const { resolve } = require('path'); module.exports = { mode: \"development\", entry: { pageOne: './src/app01/entry.js', pageTwo: './src/app02/entry.js', pageThree: './src/app03/entry.js', }, output: { filename: \"[name].js\", path: resolve(__dirname, \"dist\") } } 目录一览： . ├── dist │ ├── pageOne.js │ ├── pageThree.js │ └── pageTwo.js ├── src │ ├── app01 │ │ └── entry.js │ ├── app02 │ │ └── entry.js │ └── app03 │ └── entry.js └── webpack.config.js output output是出口的意思，用于指定webpack在哪里输出以及如何命名这些被打包后的bundels文件。 它的默认值为./dist，当然你也可对其进行配置。 常用配置 以下是output在webpack.config.js中常见的配置项。 const { resolve } = require('path'); module.exports = { ... output: { filename: \"[name].js\", // 输出后的文件名称 path: resolve(__dirname, \"dist\"), // 输出到那个目录下 publicPath: \"/\", // 输出后的http或者file协议访问路径，不建议设置 } } 注意，可使用的[]如下所示： [name] 源文件名 [hash] 根据源文件内容生成的hash值 [contentHash] 同上 [hash:] 只取多少位的hash [path] 源文件路径 [ext] 源文件扩展名 loader loader的主要功能是让webpack如何去处理那些非JavaScript文件（webpack自身只理解JavaScript）。 loader可以将所有类型的文件转换为webpack能够处理的有效模块，然后你就可以利用webpack的打包能力，对它们进行处理。 本质上，webpack loader将所有类型的文件，转换为应用程序的依赖图（和最终的bundle）可以直接引用的模块。 注意，由于有loader的存在，故我们能够在代码中import导入任何类型的模块（例如 .css 文件）。 这是webpack特有的功能，其他打包程序或任务执行器的可能并不支持。我们认为这种语言扩展是有很必要的，因为这可以使开发人员创建出更准确的依赖关系图。 注意，loader一般都是第三方的，所以我们需要对其进行npm安装，并且将其安装在生产环境下。 遍历规则 loader在webpack.config.js中配置还是有一些注意事项的。 首先它们必须全部定义在module中，然后用rules与test来匹配资源文件，最后添加loader来处理这些资源文件。 如下所示，我们针对不同的资源文件给出了不同的loader处理方案： const { resolve } = require('path'); module.exports = { ... module: { // rules：指定所有可能会被应用的loader rules: [ // test：识别出哪些文件会被转换 // use：将使用那些loader对该文件做转换 { test: /\\.js$/, use: [\"babel-loader\"] }, { test: /\\.css$/, use: [\"style-loader\", \"css-loader\"] }, { test: /\\.html$/, use: [\"html-loader\"] } ] } } 默认情况下，它会不断的去遍历整个rules列表，来处理资源文件，整个流程相当于如下语句，即整个rules列表中的loader都会被匹配一次： for (let rule of rules) { if (fileName.match(rule.test)) { // 调用loader处理资源文件 rule.use?.map(loader => { loader(fileName) }) || rule.loader(filename); } } 我们可以在rules中添加一个具有oneOf属性的对象，这样它在遍历时当一个loader生效后其他的loader将不再进行遍历，类似于else if语句： const { resolve } = require('path'); module.exports = { ... module: { rules: [ { oneOf: [ // 只匹配一个，匹配完成后立刻跳出 { test: /\\.js$/, use: [\"babel-loader\"] }, { test: /\\.css$/, use: [\"style-loader\", \"css-loader\"] }, { test: /\\.html$/, use: [\"html-loader\"] } ] } ] } } 若你想让一个文件被多个loader进行处理，可以使用如下的配置： const { resolve } = require('path'); let fileName = \"demo.css\" for (let rule of rules) { if (fileName.match(rule.test)) { // 调用loader处理资源文件 rule.use?.map(loader => { loader(fileName) }) || rule.loader(filename); } } module.exports = { ... module: { rules: [ // js文件会先执行这个loader { test: /\\.js$/, use: [\"xxx-loader\"], enforce: \"pre\", }, { oneOf: [ // 然后再执行这个loader { test: /\\.js$/, use: [\"babel-loader\"] }, // 跳出，不匹配下面的loader { test: /\\.css$/, use: [\"style-loader\", \"css-loader\"] }, { test: /\\.html$/, use: [\"html-loader\"] } ] } ] } } 书写方式 如果一个资源文件只需要用一个loader来进行处理，那么你可以直接在rules子对象中指定loader为一个string，并且在下面可以跟随options属性： const { resolve } = require('path'); module.exports = { ... module: { rules: [ { test: /\\.html$/, loader: 'html-loader', options:{ // 配置项 } }, ] } } 如果一个资源文件需要有多个loader来进行处理，那么你可以使用数组use来存放多个loader。 注意！use中loader的加载顺序是至下而上，自右而左的，所以下面示例中当css后缀名的文件被匹配时会先使用css-loader进行处理，然后再使用style-loader进行处理： const { resolve } = require('path'); module.exports = { ... module: { rules: [ { test: /\\.css$/, use: [ \"style-loader\", \"css-loader\" ] }, ] } } 如果use中的某些loader需要有一些详细的配置，你也可以将它指定为一个对象，如下所示： const { resolve } = require('path'); module.exports = { ... module: { rules: [ { test: /\\.css$/, use: [ \"style-loader\", { loader: \"css-loader\", options: { // 配置项 } } ] }, ] } } 常用配置 在一个具体的loader中，你也可以使用以下的配置项，来进行更加详细的定制，如eslint-loader会检查js文件的语法是否符合规范，但对于一些内置或第三方库来说我们并不需要对它们做重复的检查，因此可以将它们进行排除。 如下所示： const { resolve } = require('path'); module.exports = { ... module: { rules: [ { test: /\\.js$/, use: [\"eslint-loader\"], exclude: /node_modules/, // 不需要检测该目录下的语法 include: resolve(__dirname, \"src\"), // 仅检查该目录下的语法 enforce: \"pre\", // 优先于所有loader执行，此外你也可以设置post，即最后执行该loader } ] } } plugins 插件（plugins）可以用于执行范围更广的任务。 插件的范围包括，从打包优化和压缩，一直到重新定义环境中的变量。 插件接口功能极其强大，可以用来处理各种各样的任务。 想要使用一个插件，你只需要require()它，然后把它添加到plugins数组中。 多数插件可以通过选项(option)自定义。你也可以在一个配置文件中因为不同目的而多次使用同一个插件，这时需要通过使用new操作符来创建它的一个实例。 换而言之，loader是规定webpack如何处理非JavaScript模块的转换，它只针对一些特定类型，如.less、.css、.ts等。 而plugin是贯穿整个webpack打包生命周期的，依照插件的类型，它会在不同时期进行调用，丰富webpack打包过程，如压缩css、js等操作。 配置方式 每个plugin都是一个独立的类，因此你可以直接在plugins中对它进行实例化： const { resolve } = require('path'); const HtmlWebpackPlugin = require('html-webpack-plugin'); module.exports = { ... plugins: [ new HtmlWebpackPlugin(), ] } 注意，有些plugin是webpack内置的，你可以直接使用它们，而有些plugin则需要通过npm进行下载安装。 一般来说我们会根据plugin的功能不同将它们区别安装在开发环境或生产环境中。 mode 模式(Mode)指示webpack使用相应模式的配置。 它有2个选项： development：开发模式 production：生产模式 不同的模式选择，会触发webpack不同的优化机制。 选项 描述 特点 development 会将 DefinePlugin 中 process.env.NODE_ENV 的值设置 为 development。启用 NamedChunksPlugin 和 NamedModulesPlugin。 能让代码本地调试 运行的环境 production 会将 DefinePlugin 中 process.env.NODE_ENV 的值设置 为 production。启用 FlagDependencyUsagePlugin, FlagIncludedChunksPlugin, ModuleConcatenationPlugin, NoEmitOnErrorsPlugin, OccurrenceOrderPlugin, SideEffectsFlagPlugin 和 TerserPlugin。 能让代码优化上线 运行的环境 最常见的是production下会压缩打包后的JavaScript代码，而development下不会压缩打包后的JavaScript代码。 配置方式 我们只需要在webpack.config.js中配置mode即可，如下所示： module.exports = { mode: \"development\", ... } 其他概念 webpack依赖图 现如今的主流框架都是单页面开发，那么我们知道webpack在打包时必须有一个入口文件，在入口文件下可以导入各式各样的资源文件，只要你有对应的loader将其进行处理成浏览器可识别的资源都是可行的，如下代码： // entry.js import \"./static/js/index.js\" import \"./static/js/login.js\" import \"./static/js/register.js\" // 入口文件中引入了js文件，js文件是浏览器所认识的并不需要特别的loader进行转换，可以直接引用，但如果需要压缩代码或者提高兼容性，那么就需要loader进行处理了 // index.js import \"../css/index.less\" // index.js中引入了less文件，less文件是不被浏览器所认识的，所以需要有特别的loader对其进行转换，否则打包将产生错误 // index.less body { background-img: url(\"../imgs/background.jpeg\"); } // index.less中引入了图片资源，在打包时我们需要对其进行处理，将图片压缩或者变为base64数据流的格式以减少请求次数，因此也需要有特别的loader进行转换，否则将产生显示错误 那么上面三个简单的文件，就可以引出一份webpack依赖图，关于login.js或者register.js中的依赖我们并没有进行详细的说明，但整体逻辑都差不多： browserslist 在package.json中有一项配置名为browserslist，它规定了当前项目所支持的浏览器列表，在使用babel等构建工具时，它将产生作用。 也就是说，我们需要为项目做一些兼容性的支持时，就必须先定义它，然后再将它与loader结合使用，在打包时以提高css、js文件代码的兼容性，如何配置browserslist呢？ 其实他有2种模式，一种是生产模式，一种是开发模式（默认的）。 注意这2种模式和webpack的2种模式是不一样的，两者没有任何关系。 以下是定义它的规则： \"browserslist\": { \"development\": [ \"last 1 chrome version\", // 兼容最后一个chrome版本 \"last 1 firefox version\", // 兼容最后一个firefox版本 \"last 1 safari version\" // 兼容最后一个safari版本 ], \"production\": [ \">0.2%\", // 兼容市面上所有大于百分之2的浏览器 \"not dead\", // 不兼容已废弃的浏览器 \"not op_mini all\" // 不兼容所有版本的op_mini浏览器 ] } 如果，你想使用browserslist开发环境下的配置时，就需要在webpack.config.js中对其进行设置： const { resolve } = require('path'); process.env.NODE_ENV = \"development\" // 加载browserslist的development兼容性列表 module.exports = { mode: \"development\", entry: \"./src/entry.js\", output: { filename: \"main.js\", path: resolve(__dirname, \"dist\") }, module: { rules: [ { test: /\\.css$/, use: [ \"style-loader\", \"css-loader\", // 将依照browserslist处理兼容性 { loader: \"postcss-loader\", options: { postcssOptions: { plugins: [\"postcss-preset-env\"] } } } ] } ] } } reslove reslove是webpack.config.js中能够更加方便我们模块查找的一个配置项，我们知道在vue中，它将src目录设置成了@，因此在导入src目录下的文件时，我们可以直接使用下面的语法格式： import \"@/static/index.js\" 它是如何做到的呢？其实内部就是和webpack的reslove原理一致，如下所示： const { resolve } = require('path'); process.env.NODE_ENV = development; module.exports = { mode: \"development\", resolve: { alias: { \"@\": resolve(__dirname, \"src\"), } }, ... } 除此之外，reslove也可以用于设置文件扩展名的省略缩写，众所周知Node.js的模块只支持js文件和json文件，如果想导入一个其他类型的文件该怎么做？ 你只需要如下设置即可： const { resolve } = require('path'); process.env.NODE_ENV = development; module.exports = { mode: \"development\", resolve: { alias: { \"@\": resolve(__dirname, \"src\"), }, extensions: [\".js\", \".ts\", \".json\", \".less\", \".css\", \".scss\", \".vue\"] }, entry: \"./src/entry.js\", output: { filename: \"main.js\", path: resolve(__dirname, \"dist\") }, ... } 这样在导入时，我们可以不加后缀名，它会自动的匹配extensions列表中的后缀与文件名进行拼接，如下所示： import \"@/static/css/index\" // 自动匹配 index.js -> index.json -> index.less -> index.css -> index.scss -> index.vue webpack初体验 项目目录 以下是整个webpack处体验的项目目录，我们打算将js文件进行打包： . ├── dist ├── src │ ├── entry.js // 打包的入口文件 │ ├── index.html // 主页面 │ └── static // 静态资源目录 │ └── js │ └── index.js // index.js脚本文件 ├── package.json └── webpack.config.js 以下是index.html文件的内容： webpack初体验 HELLO WORLD 然后是index.js，主要工作就是点击hello world字样时改变字体颜色： document.querySelector(\"h1\").addEventListener(\"click\", event => { const r = Math.round(Math.random() * 256).toFixed(); const g = Math.round(Math.random() * 256).toFixed(); const b = Math.round(Math.random() * 256).toFixed(); event.target.setAttribute(\"onselectstart\", \"return false\"); event.target.style.cssText = `color : rgb(${r}, ${g}, ${b})`; }) webpack.json中也没什么好配置的，因为不需要处理兼容性的问题，只需要指定入口文件和输出文件即可： const { resolve } = require('path'); // node.js模块，用于路径拼接 module.exports = { mode: \"development\", entry: \"./src/entry.js\", output: { filename: \"main.js\", path: resolve(__dirname, \"dist\") }, devtool: false, // devtool为false时，不会压缩打包后的代码，推荐在学习过程中添加 } 最后别忘记在入口文件entry.js中导入index.js： import \"./static/js/index.js\" 安装webpack 然后是安装webpack，只需要使用npm命令即可，由于webpack是开发环境下使用的，所以我们要使用--save-dev的后缀将webpack安装在项目的开发环境中： $ npm install webpack webpack-cli --save-dev 这2个包的作用在于： webpack：提供打包服务 webpack-cli：提供命令行操纵方式 资源打包 现在我们就可以使用webpack对其进行打包了，只需要输入以下命令即可，它会自动在项目根目录中寻找webpack.config.js： $ npx webpack # npx命令用于在本地的node_modules中执行命令，并不会使用全局npm下安装的包命令。 打包后dist目录会生成一个main.js文件，那么我们可以利用live server打开index.html，查看打包的结果是否顺利。 资源检测 当被打包的资源文件内容发生变更时，我们希望webpack会自动对其进行打包。 可以使用以下命令对被打包的资源文件进行监听： $ npx webpack --watch 这样当我们改变index.js文件代码时，webpack会自动的重新打包。 指定配置 webpack.config.js文件通常来说会有2份，一份用于生产环境，一份用于开发环境。 我们可以在webpack打包命令后指定所需要选择的配置文件，如下所示： $ npx webpack --config ./webpack_config/webpack.dev.config.js $ npx webpack --config ./webpack_config/webpack.pro.config.js 更推荐在package.json中自定义npm脚本命令： \"scripts\": { \"dev-build\": \"npx webpack --config ./webpack_config/webpack.dev.config.js\", \"pro-build\": \"npx webpack --config ./webpack_config/webpack.pro.config.js\" }, 这样在打包时就非常方便了： $ npm run dev-build $ npm run pro-build Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-10-11 15:44:32 "},"前端专栏/Webpack5/常用配置.html":{"url":"前端专栏/Webpack5/常用配置.html","title":"常用配置","keywords":"","body":"基本插件 clean-webpack-plugin 我们每次打包后都需要手动删除dist目录下的打包资源，这样做会很麻烦。 为了方便后面的学习，因此推荐安装clean-webpack-plugin，它会在每次打包之前自动删除dist目录下的所有资源。 由于它是一个第三方插件，故我们需要使用npm进行下载： $ npm install clean-webpack-plugin --save-dev 在webpack.config.js中进行插件导入之后直接在plugins中使用即可： const { CleanWebpackPlugin } = require('clean-webpack-plugin') const { resolve } = require('path') module.exports = { mode: \"development\", devtool: false, entry: \"./src/entry.js\", output: { filename: \"main.js\", path: resolve(__dirname, \"dist\") }, plugins: [ new CleanWebpackPlugin(), ] } 你可以在dist目录下新建一个文件，然后执行webpack打包，打包完成后会发现你新建的文件已经被清理掉了。 html-webpack-plugin 在之前的webpack初体验中，我们需要在主页面index.html文件中手动引入打包后的main.js文件，这样做非常的麻烦。 因此推荐使用html-webpack-plugin插件，它会自动的在dist目录下生成一个html文件，你只需要在插件中配置该html文件所继承的模板是谁即可，当打包完成后，该插件所生成的html文件会自动引入被打包后的main.js资源，可以让我们将注意力更加专注的放在代码的编写上，而不是放在资源的引入上。 由于它是一个第三方插件，故我们需要使用npm进行下载： $ npm install html-webpack-plugin --save-dev 在webpack.config.js中进行插件导入之后直接在plugins中使用即可： const { CleanWebpackPlugin } = require('clean-webpack-plugin') const HtmlWebpackPlugin = require('html-webpack-plugin') const { resolve } = require('path'); module.exports = { mode: \"development\", devtool: false, entry: \"./src/entry.js\", output: { filename: \"main.js\", path: resolve(__dirname, \"dist\") }, plugins: [ new CleanWebpackPlugin(), new HtmlWebpackPlugin({ // 指定模板文件 template: \"./src/index.html\", minify:{ // 移除模板文件中的空格 collapseWhitespace: true, // 移除模板文件中的注释 removeComments: true, } }), ] } 此时，在index.html文件中就可以删除掉我们所手动引入的打包后的资源： html-webpack-plugin --> HELLO WORLD 注意，现在我们的dist目录下并没有index.html文件，当执行webpack打包后，html-webpack-plugin插件会自动创建一个html文件，注意对比两者之间的差距： html-webpack-plugin --> HELLO WORLD DefinePlugin 在index.html中我们可以书写一些EJS的语法，然后通过DefinePlugin插件对其进行渲染。 DefinePlugin是一个自带的插件，不用下载，直接使用即可，我们使用该插件定义了一个模板变量title，值是一个字符串： const { CleanWebpackPlugin } = require('clean-webpack-plugin') const HtmlWebpackPlugin = require('html-webpack-plugin') const { DefinePlugin } = require('webpack') const { resolve } = require('path'); module.exports = { mode: \"development\", devtool: false, entry: \"./src/entry.js\", output: { filename: \"main.js\", path: resolve(__dirname, \"dist\") }, plugins: [ new CleanWebpackPlugin(), new HtmlWebpackPlugin({ template: \"./src/index.html\", }), new DefinePlugin({ title: \"'Welcome home!'\" // 注意，这里如果你想使用字符串必须再包裹一层，否则将会在打包时出现语法错误 }) ] } index.html文件中使用EJS语法，引入该模板变量： DefinePlugin 进行打包后打开dist/index.html文件后会发现他会显示，Welcome home!的字样。 这里我们需要注意一个小问题，上面也提到过，使用该插件定义模板变量时如果模板变量的值是一个字符串，那么必须使用双层引号将它进行包裹，否则将产生语法问题，造成这个问题的原因主要是由于它内部原因所导致的，如下所示： new DefinePlugin({ title: \"Welcome home!\" # --> 等同于 const title = Welcome home 意外的标识符，Welcome未定义 }) new DefinePlugin({ title: \"'Welcome home!'\" # --> 等同于 const title = 'Welcome home' 成功 }) 处理CSS文件 前言概述 我们有这样的一个项目： ├── dist ├── node_modules ├── src │ ├── entry.js │ ├── index.html │ └── static │ ├── css │ │ └── index.css │ └── js │ └── index.js ├── package-lock.json ├── package.json └── webpack.config.js 入口文件entry.js中导入了index.js，而index.js中又导入了index.css，但是css文件是不被浏览器识别的文件，因此需要一个loader来对其进行解决。 # index.html CSS # entry.js import \"./static/js/index.js\" # index.js import \"../css/index.css\" document.querySelector(\"h1\").addEventListener(\"click\", event => { const r = Math.round(Math.random() * 256).toFixed(); const g = Math.round(Math.random() * 256).toFixed(); const b = Math.round(Math.random() * 256).toFixed(); event.target.setAttribute(\"onselectstart\", \"return false\"); event.target.style.cssText = `color : rgb(${r}, ${g}, ${b})`; }) # index.css body { height: 100vh; width: 100vw; display: flex; flex-flow: row nowrap; justify-content: center; align-items: center; } css-loader + style-loader 我们可以使用css-loader配合style-loader来让webpack处理css文件。 首先这2个loader都需要通过npm进行下载： $ npm install css-loader style-loader --save-dev 它们的作用在于： css-loader：将css文件内容加载出来 style-loader：创建标签，并且将css文件内容添加进来，最后将标签添加至html文件的标签中 以下是在配置文件中配置如何处理css文件的代码，在指派loader时需要注意loader定义的顺序，use中的加载顺序是自下而上，自右而左的： const { CleanWebpackPlugin } = require('clean-webpack-plugin') const HtmlWebpackPlugin = require('html-webpack-plugin') const { DefinePlugin } = require('webpack') const { resolve } = require('path'); module.exports = { mode: \"development\", devtool: false, entry: \"./src/entry.js\", output: { filename: \"main.js\", path: resolve(__dirname, \"dist\") }, module: { rules: [ { test: /\\.css$/, use: [ \"style-loader\", \"css-loader\", ] } ] }, plugins: [ ... ] } 然后你就可以执行打包命令了，如果加载正确的话标签应该位于页面的正中心。 此时你可以观察dist目录，发现他并没有生成单独的css文件，这是由于style-loader导致的。但是在main.js文件中，你可以找到css文件的引入代码。 postcss-loader 我们需要让我们的css代码兼容不同版本的浏览器，这个时候就需要借助postcss-loader以及在之前一章节中提到过的browserslist中的配置了。 首先postcss-loader只是一个能够提高兼容性的工具，如何提高代码兼容性还需要另外一个插件postcss-preset-env，我们来简单分析一下3者之间的关系： browserslist：老板，只告诉你要达到什么样的效果 postcss-preset-env：策划，告诉你这个效果应该怎么做才能达到老板的需求 postcss-loader：员工，真正干活的人，通过策划给定的方案进行执行 现在让我们下载postcss-loader以及postcss-preset-env插件： $ npm install postcss-loader postcss-preset-env --save-dev 安装完成之后就可以进行使用了，首先我们可以在package.json中指定browserslist： \"browserslist\": { \"development\": [ \">1%\", \"not dead\", \"not op_mini all\" ], \"production\": [ \">0.2%\", \"not dead\", \"not op_mini all\" ] }, 然后在webpack.config.js中进行配置，注意loader的定义顺序，postcss-loader应该位于css-loader之前进行执行： const { CleanWebpackPlugin } = require('clean-webpack-plugin') const HtmlWebpackPlugin = require('html-webpack-plugin') const { DefinePlugin } = require('webpack') const { resolve } = require('path'); process.env.NODE_ENV = \"development\" // 加载browserslist的development兼容性列表 module.exports = { mode: \"development\", devtool: false, entry: \"./src/entry.js\", output: { filename: \"main.js\", path: resolve(__dirname, \"dist\") }, module: { rules: [ { test: /\\.css$/, use: [ \"style-loader\", \"css-loader\", { loader: \"postcss-loader\", options: { postcssOptions: { plugins: [\"postcss-preset-env\"] } } } ] } ] }, plugins: [ ... ] } css回溯问题 如果我们再新建一个css文件，并且在index.css文件中对其引入，就会导致一个问题，新的css文件不能被postcss-loader进行兼容性处理。 # index.css @import url(\"./other.css\"); body { height: 100vh; width: 100vw; display: flex; flex-flow: row nowrap; justify-content: center; align-items: center; } # other.css h1 { transform: rotate(-3deg); } 当你webpack打包过后，你会发现在旧版本浏览器下的旋转的样式并没有加任何前缀处理兼容性，导致这个的原因其实非常简单： use列表中postcss-loader是第一个被执行的，它将处理index.css，但是index.css中有一个@import()语句，这是postcss-loader所处理不了的 当index.css被postcss-loader处理完成后，会将代码交由use列表中的下一个loader，即css-loader继续进行处理，我们的css-loader可以处理index.css文件中导入的other.css，但是注意！这个other.css在之前并没有被postcss-loader处理过！ 我们所需要做的就是让other.css再重头让postcss-loader处理一遍，该怎么做呢？其实你只需要指定该css文件被第几个loader重新处理即可，如postcss-loader目前在use列表中的执行排序为1，就将importLoaders属性指定为1即可： module: { rules: [ { test: /\\.css$/, use: [ \"style-loader\", { loader: \"css-loader\", options: { importLoaders: 1 // 交由第1个loader重新处理 } }, { loader: \"postcss-loader\", options: { postcssOptions: { plugins: [\"postcss-preset-env\"] } } } ] } ] }, 同理，如果postcss-loader在use列表中第二个执行位置，那么importLoaders就需要指定为2。 less-loader 如果想处理less文件，则只需要安装less-loader插件即可： $ npm install less-loader --save-dev 配置时，它需要在use列表中第一个执行位置，那么postcss-loader的执行位置就变成了2，同理，css-loader的importLoaders属性也需要改变为2： const { CleanWebpackPlugin } = require('clean-webpack-plugin') const HtmlWebpackPlugin = require('html-webpack-plugin') const { DefinePlugin } = require('webpack') const { resolve } = require('path'); process.env.NODE_ENV = \"development\" module.exports = { mode: \"development\", devtool: false, entry: \"./src/entry.js\", output: { filename: \"main.js\", path: resolve(__dirname, \"dist\") }, module: { rules: [ ... { test: /\\.less$/, use: [ \"style-loader\", { loader: \"css-loader\", options: { importLoaders: 2 } }, { loader: \"postcss-loader\", options: { postcssOptions: { plugins: [\"postcss-preset-env\"] } } }, \"less-loader\" ] } ] }, plugins: [ ... ] } 单独拆分CSS文件 style-loader会将css文件内容全部与main.js一起打包，如果我们想对其进行拆分，可使用MiniCssExtractPlugin中的loader来代替它。 首先需要进行安装： $ npm install mini-css-extract-plugin --save-dev 它是一款插件，所以要先对其进行引入： const MiniCssExtractPlugin = require('mini-css-extract-plugin') 然后是使用方式，直接看配置文件： const MiniCssExtractPlugin = require('mini-css-extract-plugin') const { resolve } = require('path'); process.env.NODE_ENV = \"development\" module.exports = { mode: \"development\", devtool: false, entry: \"./src/entry.js\", output: { filename: \"main.js\", path: resolve(__dirname, \"dist\") }, module: { rules: [ { test: /\\.css$/i, use: [ // 代替style-loader MiniCssExtractPlugin.loader, { loader: \"css-loader\", options: { // 解决css中的图片引入问题 esModule: false, // 设置兼容性，回溯层级为1 importLoaders: 1 } }, { loader: \"postcss-loader\", options: { postcssOptions: { plugins: [\"postcss-preset-env\"] } } } ] }, ] }, plugins: [ ... new MiniCssExtractPlugin({ // 指定需要输出的文件名，它会在dist/css文件中进行输出 filename: \"css/[name].css\" }) ] } 压缩CSS文件 在项目部署上线之前，我们一般都会对css文件进行压缩处理，将它压缩为一行。 使用插件css-minimizer-webpack-plugin来进行这项工作非常的方便，首先还是需要对其进行安装： $ npm install css-minimizer-webpack-plugin --save-dev 使用方式： const CssMinimizerPlugin = require(\"css-minimizer-webpack-plugin\"); const { resolve } = require('path'); process.env.NODE_ENV = \"development\" module.exports = { mode: \"development\", devtool: false, entry: \"./src/entry.js\", output: { filename: \"main.js\", path: resolve(__dirname, \"dist\") }, module: { rules: [ ... ] }, plugins: [ ... ], optimization: { minimizer: [ new CssMinimizerPlugin(), ], // 默认只有在生产环境下才会生效，通过该属性的添加让它在开发环境下也生效 minimize: true }, } 处理JS文件 babel-loader 同postcss-loader一样，babel-loader也是用于提高js兼容性而产生的。 它不仅可以让ES6的代码在较低版本的浏览器环境中运行，还能使ts、jsx等文件转换为js文件。 首先babel-loader只是一个能够提高兼容性的工具，如何提高代码兼容性还需要另外几个插件@babel/preset-env以及core-js，我们来简单分析一下4者之间的关系： browserslist：老板，只告诉你要达到什么样的效果 @babel/preset-env：主策划，指定主体方案，如何提高兼容性（能提高的兼容性有限） core-js：策划助理，负责为主策划的方案做填充，让主策划的方案兼容性更高 bebel-loader：员工，真正干活的人，通过策划给定的方案进行执行 首先我们需要安装这几个插件： $ npm install babel-loader core-js regenerator-runtime @babel/preset-env --save-dev # regenerator-runtime同core-js的作用一样，也是用于填充主策划方案而存在的策划助理 然后是配置项： { test: /\\.js$/, exclude: /node_modules/, loader: \"babel-loader\", options: { presets: [ [ \"@babel/preset-env\", { // 指定corejs的版本 corejs: 3, // 选择corejs的填充模式 // false : 不填充 // usage : 按需填充，使用到那个功能再兼容那个功能 // entry : 全部填充，不管有没有使用到那个功能都填充进去 // 注意，如果填充模式为entry，则需要在全局导入 import \"core-js/stable\" 以及 import \"regenerator-runtime/runtime\" useBuiltIns: \"usage\", } ] ] } } 处理TS文件 我们也可以通过babel-loader来处理ts文件，值得注意的是babel-loader不能检测ts语法是否合格。 因此在编译ts项目之前，我们需要使用tsc --noEmit命令来检查ts文件内容是否书写合法。需要使用一个第三方插件@babel/preset-typescript： $ npm install @babel/preset-typescript --save-dev 以下是babel-loader处理ts文件的配置： { test: /\\.ts$/, exclude: /node_modules/, loader: \"babel-loader\", options: { presets: [ [ \"@babel/preset-env\", { corejs: 3, useBuiltIns: \"usage\", } ], [\"@babel/preset-typescript\"], ] } } 在打包项目之前，请先输入tsc --noEmit确认没有ts语法错误后再进行打包： $ tsc --noEmit # 获取全局未安装typescript，请使用npx tsc --noEmit $ npx webpack 压缩JS文件 当你的webpack打包模式设置为production后，打包过后的js文件会自动压缩成一行，不需要再额外的单独进行设置。 其他资源处理 处理CSS中引入的图片资源 webpack5中新增了asset来处理图片资源，用于取代之前的file-loader和url-loader。 使用asset处理图片时，它具有2种模式： asset/resource：直接将图片拷贝到dist目录下，相当于之前的file-loader asset/inline：将图片转换为base64格式的数据流，内联在html的的src属性中 如何使用？如下图所示： const { CleanWebpackPlugin } = require('clean-webpack-plugin') const HtmlWebpackPlugin = require('html-webpack-plugin') const { DefinePlugin } = require('webpack') const MiniCssExtractPlugin = require('mini-css-extract-plugin') const CssMinimizerPlugin = require(\"css-minimizer-webpack-plugin\"); const { resolve } = require('path'); process.env.NODE_ENV = \"development\" // 加载browserslist的development兼容性列表 module.exports = { mode: \"development\", devtool: false, entry: \"./src/entry.js\", output: { filename: \"main.js\", path: resolve(__dirname, \"dist\") }, module: { rules: [ ... { test: /\\.(png|svg|gif|jpe?g)/, // 自动选择模式 type: \"asset\", // 配置asset/resource时图片的保存路径 generator: { filename: \"img/[name][hash:4][ext]\" }, // 当图片大小小于8kb时，将启用asset/inline模式 parser: { dataUrlCondition: { maxSize: 8 * 1024, } } } ] }, plugins: [ ... ], optimization: { ... }, } 需要注意一点，当需要处理css中的图片资源时，你必须指定css-loader的options属性中esModule为false，否则将产生令人意外的情况： { loader: \"css-loader\", options: { importLoaders: 1, esModule: false } }, 在index.less中引入nginx.jpeg： body div { width: 400px; height: 400px; background-image: url(\"../imgs/nginx.jpeg\"); } 打包后查看效果。 处理HTML中引入的图片资源 asset的设置只能用于处理在CSS中引入的图片资源，如果你在index.html中引入了一张图片，那么asset是处理不了的。如： # index.html 此时我们需要下载一个html-loader来对html文件内容作出解析，然后再交由asset进行处理。 首先安装该loader： $ npm install html-loader --save-dev 使用该loader： { test: /\\.html$/, loader: \"html-loader\", options: { esModule: false, } } 注意，该loader和DefinePlugin有所冲突，因此两者选其一即可，其实DefinePlugin插件实际生产中很少使用，几乎用不到，因此可以直接放弃它。 打包完成后，可以发现生成的index.html文件中src的路径指向已被改变： 处理字体文件及其他资源 如果想处理字体文件或者其他资源，通过asset也可以进行解决，这里不再进行演示： { test: /\\.(ttf|woff2?)$/, type: \"asset/resource\", generator: { filename: \"font/[name][hash:4][ext]\" } } copy_webpack_plugin copy_webpack_plugin插件用于对资源进行拷贝，被该插件选中的目录不会进行打包。 我们可以利用该插件来将一些不需要打包的文件放置在dist目录下，如favicon图标： $ npm install copy-webpack-plugin --save-dev 使用案例： const { CleanWebpackPlugin } = require('clean-webpack-plugin') const HtmlWebpackPlugin = require('html-webpack-plugin') const { DefinePlugin } = require('webpack') const MiniCssExtractPlugin = require('mini-css-extract-plugin') const CssMinimizerPlugin = require(\"css-minimizer-webpack-plugin\"); const CopyWebpackPlugin = require(\"copy-webpack-plugin\"); const { resolve } = require('path'); process.env.NODE_ENV = \"development\" // 加载browserslist的development兼容性列表 module.exports = { mode: \"development\", devtool: false, entry: \"./src/entry.js\", output: { filename: \"main.js\", path: resolve(__dirname, \"dist\") }, module: { ... }, plugins: [ ... new CopyWebpackPlugin({ patterns: [ { // 拷贝那个目录下的内容 from: resolve(__dirname, \"src\", \"resource\"), // 拷贝到那个目录下，可不写，如果不写则按照output中的path进行输出 to: resolve(__dirname, \"dist\", \"resource\"), globOptions: { // 忽略的文件 ignore: [\"**/reboots.text\",], } } ] }) ], optimization: { ... } } Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-09-29 22:06:12 "},"前端专栏/Webpack5/devServer.html":{"url":"前端专栏/Webpack5/devServer.html","title":"devServer","keywords":"","body":"基本介绍 在通过webpack开发时我们期望拥有一款更加高效的工具来提高我们的开发效率。 如果你使用vscode进行开发，那么可以通过webpack的--watch搭配live server来进行实时加载，但是这样做并不是最完美的解决方案，它依然存在以下几点问题： 每次源代码更新后所有的模块资源都会重新打包，即使你只修改了上百个模块中的其中一个 每次的编译打包操作都会引起磁盘的读写，因为打包后的资源文件会放置在磁盘上 为了解决这些问题，webpack中提供了一个server服务器，名为devServer，使用它来进行开发是我们最佳的选择。 它支持热更新、同时打包后的文件是放置在内存中，并不会写入磁盘，因此打包的速度非常快。 在进行代码编写时，devServer能够让我们更快的预览结果。 devServer配置 要想使用devServer，先要对其进行下载，devServer只在开发环境下使用，所以需要加上-dev的后缀： $ npm install webpack-dev-server --save-dev 要想启用devServer，推荐使用npm脚本进行操作，你只需要在package.json中的script中写入以下命令即可： \"scripts\": { \"dev-build\": \"npx webpack --config ./webpack_config/webpack.dev.config.js\", \"pro-build\": \"npx webpack --config ./webpack_config/webpack.pro.config.js\", \"dev-server\": \"npx webpack serve --config ./webpack.config.js\" }, 然后再命令行终端中敲入以下命令即可成功开启服务： $ npm run dev-server 它的端口号默认为8080，你可以对其进行访问。 相关配置 以下是devServer中的相关配置，我们要将其书写在webpack.config.js中： const { CleanWebpackPlugin } = require('clean-webpack-plugin') const HtmlWebpackPlugin = require('html-webpack-plugin') const { DefinePlugin } = require('webpack') const MiniCssExtractPlugin = require('mini-css-extract-plugin') const CssMinimizerPlugin = require(\"css-minimizer-webpack-plugin\"); const CopyWebpackPlugin = require(\"copy-webpack-plugin\"); const { resolve } = require('path'); process.env.NODE_ENV = \"development\" // 加载browserslist的development兼容性列表 module.exports = { mode: \"development\", devtool: false, entry: \"./src/entry.js\", output: { filename: \"main.js\", path: resolve(__dirname, \"dist\") }, // 在开发环境下，我们需要屏蔽掉browserslist的兼容性设置 // 只需要将target设置为web即可，否则热更新将失效 target: \"web\", devServer: { // 指定devServer的域名 host: 'localhost', // 指定devServer的端口号 port: 8080, // 是否开启热更新(一个模块更新后，并不重复打包其他的模块) hot: true, // 服务启动成功后是否自动打开浏览器 open: false, // 自动通过gzip压缩打包后的文件（在内存中），提升性能，推荐设置为true compress: true, // 在H5中（常见于单页面应用路由跳转里），当路由页面跳转后点击刷新页面时可能会发生404的情况，通过设置为true以进行解决 historyApiFallback: true, // 服务器代理 --> 解决开发环境跨域问题（推荐使用Chrome插件CORS进行解决，更方便省力） proxy: { // 一旦devServer(5000)服务器接受到 /api/xxx 的请求，就会把请求转发到另外一个服务器(3000) '/api': { target: 'http://localhost:3000', // 发送请求时，请求路径重写：将 /api/xxx --> /xxx （去掉/api） pathRewrite: { '^/api': '' } } } }, ... } HMR 如果想使用热更新的功能，我们除开需要在devServer中配置hot为true，还需要在入口文件entry.js中配置支持热更新的模块： import \"./static/js/index.js\" // 背后导入了index.css import \"./static/js/login.js\" // 背后导入了login.css if (module.hot) { module.hot.accept( // 支持热更新功能的模块 [ \"./static/js/index.js\", \"./static/js/login.js\", ], // 热更新后执行的回调函数 ()=>{ console.log(\"模块更新了\"); } ) } 上述这样配置的意思是： 当更新了login.js模块内容时，不会影响其他模块 当更新了index.js模块内容时，不会影响其他模块 一个项目中有多少个小组件，就配置多少个热更新即可。 我们来看一下它的效果，首先我在login.js中添加了一个输入框： console.log(\"login\"); document.body.append( document.createElement(\"input\") ) 然后当我更新index.js文件内容时，login.js输入框中输入的内容并不会被清除掉： 如果你想让Vue支持热更新，请参阅官方教程，点我跳转： Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-10-11 15:30:42 "},"前端专栏/Webpack5/优化配置.html":{"url":"前端专栏/Webpack5/优化配置.html","title":"优化配置","keywords":"","body":"代码映射 代码映射（source-map）是webpack中非常重要的一门技术，我们知道打包过后的代码和打包前的代码是不一样的，尤其是做了兼容性处理的时候。 如果运行打包后的代码产生了错误，我们需要依据source-map找到源代码中报错语句并对其进行修改，换而言之source-map技术就是在打包后的代码出现错误时，能够定位源代码中报错位置的一门技术。 在使用时，只需要设置devtool即可，它有以下一些设置项： source-map：会生成source-map文件，能够捕捉错误代码的报错信息，以及源代码中的错误位置 inline-source-map：生成内联的source-map文件，能够捕捉错误代码的报错信息，以及源代码中的错误位置 hidden-source-map：不会生成source-map文件，它只有错误代码的错误原因，只能提示到构建后代码的错误位置，没有源代码中的错误位置， eval-source-map：会为每一个文件都生成一个对应的source-map并放置在eval()函数中，能够捕捉错误代码的报错信息，以及源代码中的错误位置 nosources-source-map：会生成source-map文件，能够捕捉错误代码的报错信息，但不能提示源代码中的错误位置 cheap-source-map：会生成source-map文件，能够捕捉错误代码的报错信息，以及源代码中的错误位置，但只能精确到行，不包含loader的 sourcemap（譬如babel的sourcemap） cheap-module-source-map：会生成source-map文件，能够捕捉错误代码的报错信息，以及源代码中的错误位置，能够精确到行，同时loader的 sourcemap也被简化为只包含对应行的。 推荐设置，其实[inline-|hidden-|eval-][nosources-][cheap-[module-]]source-map可以任意组合： 开发环境：eval-source-map或者eval-cheap-module-source-map 生产环境：hidden-source-map或者nosources-source-map 使用示例： # index.js import \"../css/index.less\" throw new Error(\"this is error\") 配置文件： const { CleanWebpackPlugin } = require('clean-webpack-plugin') const HtmlWebpackPlugin = require('html-webpack-plugin') const { DefinePlugin } = require('webpack') const MiniCssExtractPlugin = require('mini-css-extract-plugin') const CssMinimizerPlugin = require(\"css-minimizer-webpack-plugin\"); const CopyWebpackPlugin = require(\"copy-webpack-plugin\"); const { resolve } = require('path'); process.env.NODE_ENV = \"development\" // 加载browserslist的development兼容性列表 module.exports = { mode: \"development\", devtool: \"source-map\", entry: \"./src/entry.js\", output: { filename: \"main.js\", path: resolve(__dirname, \"dist\") }, target: \"web\", devServer: { ... }, module: { rules: [ ... ] }, plugins: [ ... ], optimization: { ... } } 测试结果： # source-map # 会生成main.js.map # 能定位源代码中出错的位置 Uncaught Error: this is error at Module../src/static/js/index.js (index.js:3) # inline-source-map # 不会生成main.js.map # 能定位源代码中出错的位置 Uncaught Error: this is error at Object../src/static/js/index.js (index.js:3) # hidden-source-map # 会生成main.js.map # 不能定位源代码中出错的位置 Uncaught Error: this is error at Object../src/static/js/index.js (main.js:14) # eval-source-map # 不会生成main.js.map # 能定位源代码中出错的位置 Uncaught Error: this is error at eval (index.js?2127:3) at Object../src/static/js/index.js (main.js:30) # nosources-source-map # 会生成main.js.map # 能定位源代码中出错的位置，但不能进行查看 Uncaught Error: this is error at Object../src/static/js/index.js (index.js:3) # cheap-source-map # 会生成main.js.map # 能定位源代码中出错的位置，并且具有出错行的波浪线提示 Uncaught Error: this is error at Object../src/static/js/index.js (index.js:2) # cheap-module-source-map # 会生成main.js.map # 能定位源代码中出错的位置，并且具有出错行的波浪线提示 index.js:3 Uncaught Error: this is error at Object../src/static/js/index.js (index.js:3) 树摇 树摇（tree shaking）的意思即为把一颗书上的枯叶摇下来，对应到代码中即为删除无效代码。 开启树摇的前提有2个： 必须使用ES6 Module 必须开启Node.js的protected生产环境 只要满足这2个条件，webpack会自动开启树摇，但是开启树摇也有可能出现一些问题。 比如你的css、less文件等没有第一时间被使用时，可能被摇下来，除此之外babel-loader填充的资源也有可能被摇下来，针对这些现象我们可以在loader中配置sideEffects: true，告诉webpack不要树摇这些loader： process.env.NODE_ENV = \"protected\" module.exports = { mode: \"protected\", module: { rules: [ { test: /\\.css$/i, use: [\"style-loader\", \"css-loader\"], sideEffects: true } ] }, }; 多进程打包 当webpack需要处理的项目十分庞大时，我们可以开启多进程打包。 多进程打包是一把双刃剑，针对大项目的打包会有效提高打包效率，但是项目较小时打包的速度反而会更慢。 你需要先下载thread-loader： $ npm install thread-loader --save-dev 在打包过程中，babel是耗时最久的，所以我们可以为它加上该loader： { test: /\\.js$/, exclude: /node_modules/, use: [ { loader: \"thread-loader\", options: { // 开启4个进程,每个进程的启动大约是600毫秒 worker: 4, } }, { loader: \"babel-loader\", options: { presets: [ [ \"@babel/preset-env\", { corejs: 3, useBuiltIns: \"usage\", } ] ] } } ], } Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-09-09 18:53:20 "},"前端专栏/Webpack5/配置整理.html":{"url":"前端专栏/Webpack5/配置整理.html","title":"配置整理","keywords":"","body":"需要的包 项目中需要的包比较多，如下所示： $ npm install clean-webpack-plugin --save-dev $ npm install html-webpack-plugin --save-dev $ npm install css-loader style-loader --save-dev $ npm install postcss-loader postcss-preset-env --save-dev $ npm install less-loader --save-dev $ npm install mini-css-extract-plugin --save-dev $ npm install css-minimizer-webpack-plugin --save-dev $ npm install babel-loader core-js regenerator-runtime @babel/preset-env @babel/preset-typescript --save-dev $ npm install html-loader --save-dev $ npm install copy-webpack-plugin --save-dev $ npm install webpack-dev-server --save-dev $ npm install thread-loader --save-dev 开发环境配置 以下是开发环境下的推荐配置。 首先是package.json中的browserslist： \"browserslist\": { \"development\": [ \">1%\", \"not dead\", \"not op_mini all\" ], \"production\": [ \">0.2%\", \"not dead\", \"not op_mini all\" ] }, 然后配置npm脚本，我们就直接将配置文件放置在项目根目录下，方便路径的填写，如果你的项目中没有使用TypeScript，则删除tsc --noEmit即可： \"scripts\": { \"dev-build\": \"tsc --noEmit && npx webpack --config ./webpack.dev.config.js\", \"dev-server\": \"tsc --noEmit && npx webpack serve --config ./webpack.dev.config.js\" }, 然后是webpack.dev.config.js文件，在开发环境下我们并不需要做任何兼容性处理，所以配置项较少： const { CleanWebpackPlugin } = require('clean-webpack-plugin') const HtmlWebpackPlugin = require('html-webpack-plugin') const CopyWebpackPlugin = require(\"copy-webpack-plugin\") const { resolve } = require('path') // 配置Node.js的运行环境：打包时不进行树摇 process.env.NODE_ENV = 'development'; module.exports = { // 配置webpack的运行环境 mode: \"development\", // 配置代码映射方式，能够查看源代码错误 devtool: \"eval-source-map\", // 配置入口文件 entry: \"./src/entry.js\", // 由于不需要做兼容性处理，target改为web即可 target: \"web\", // 配置输出的文件名称 output: { filename: \"main.js\", path: resolve(__dirname, \"dist\") }, // 详细配置 module: { rules: [ { // 所有的规则只匹配一次就跳出，不进行重复匹配 oneOf: [ // 处理css { test: /\\.css$/i, use: [ \"style-loader\", { loader: \"css-loader\", options: { // 解决css中的图片引入问题 esModule: false } } ] }, // 处理less { test: /\\.less$/i, use: [ \"style-loader\", { loader: \"css-loader\", options: { // 解决css中的图片引入问题 esModule: false } }, \"less-loader\" ] }, // 处理ts { test: /\\.ts$/i, // 不处理node_modules下的ts文件 exclude: /node_modules/, // 使用babel-loader处理ts文件 loader: \"babel-loader\", options: { presets: [ [\"@babel/preset-typescript\"], ] } }, // 处理html图片 { test: /\\.html$/i, loader: \"html-loader\", // 关闭esModule options: { esModule: false, } }, // 处理css图片 { test: /\\.(png|svg|gif|jpe?g)/i, type: \"asset\", generator: { // 如果图片的大小大于8kb，将把图片拷贝到dist目录下的img目录中 filename: \"img/[name][hash:4][ext]\" }, parser: { dataUrlCondition: { // 如果图片的大小小于8kb，将转换为base64的数据流格式 maxSize: 8 * 1024, } } }, // 处理字体资源 { test: /\\.(ttf|woff2?)$/i, // 将字体资源拷贝至dist目录下的font目录中 type: \"asset/resource\", generator: { filename: \"font/[name][hash:4][ext]\" } }, // 处理其他资源依赖图中被引入的资源 { exclude: /\\.(css|less|js|ts|vue|jpe?g|png|gif|svg|ico|ttf|woff2?)$/i, // 将其他被引入的资源拷贝至dist目录下的other目录中 type: \"asset/resource\", generator: { filename: \"other/[name][hash:4][ext]\" } } ] } ] }, plugins: [ // 每次执行npx webpack时将会自动清除dist目录下的文件 new CleanWebpackPlugin(), // 避免我们手动的在index.html中引入打包后的资源文件 new HtmlWebpackPlugin({ // 指定模板文件 template: \"./src/index.html\", minify: { // 移除模板文件中的空格 collapseWhitespace: true, // 移除模板文件中的注释 removeComments: true, } }), // 拷贝一些未在资源图中引入的文件 new CopyWebpackPlugin({ patterns: [ { // 拷贝那个目录下的内容 from: resolve(__dirname, \"src\", \"resource\"), // 拷贝到那个目录下，可不写，如果不写则按照output中的path进行输出 to: resolve(__dirname, \"dist\", \"resource\"), globOptions: { // 忽略的文件 ignore: [\"**/reboots.text\",] } } ] }) ], // 设置路径别名，@代指src目录 resolve: { alias: { \"@\": resolve(__dirname, \"src\"), }, extensions: [\".js\", \".ts\", \".json\", \".less\", \".css\", \".scss\", \".vue\"] }, // 配置开发服务器 devServer: { // 开启热更新 hot: true, // 自动通过gzip压缩打包后的文件（在内存中），提升性能，推荐设置为true compress: true, // 在H5中（常见于单页面应用路由跳转里），当路由页面跳转后点击刷新页面时可能会发生404的情况，通过设置为true以进行解决 historyApiFallback: true }, } 生产环境配置 以下是生产环境下的推荐配置。 首先是package.json中的browserslist： \"browserslist\": { \"development\": [ \">1%\", \"not dead\", \"not op_mini all\" ], \"production\": [ \">0.2%\", \"not dead\", \"not op_mini all\" ] }, 然后配置npm脚本，我们就直接将配置文件放置在项目根目录下，方便路径的填写，如果你的项目中没有使用TypeScript，则删除tsc --noEmit即可： \"scripts\": { \"dev-build\": \"tsc --noEmit && npx webpack --config ./webpack.dev.config.js\", \"pro-build\": \"tsc --noEmit && npx webpack --config ./webpack.pro.config.js\", \"dev-server\": \"tsc --noEmit && npx webpack serve --config ./webpack.dev.config.js\" }, 然后是webpack.pro.config.js文件，在生产环境我们不需要devServer，但是需要做css以及js的兼容性处理，所以配置项较多，此外还有树摇等优化配置： const { CleanWebpackPlugin } = require('clean-webpack-plugin') const HtmlWebpackPlugin = require('html-webpack-plugin') const CopyWebpackPlugin = require(\"copy-webpack-plugin\") const MiniCssExtractPlugin = require('mini-css-extract-plugin') const CssMinimizerPlugin = require(\"css-minimizer-webpack-plugin\") const { resolve } = require('path') // 配置Node.js的运行环境：打包时会进行树摇 process.env.NODE_ENV = 'production'; module.exports = { // 配置webpack的运行环境 mode: \"production\", // 配置代码映射方式，不能够查看源代码错误 devtool: \"hidden-source-map\", // 配置入口文件 entry: \"./src/entry.js\", // 配置输出的文件名称 output: { filename: \"main.js\", path: resolve(__dirname, \"dist\") }, // 详细配置 module: { rules: [ { // 所有的规则只匹配一次就跳出，不进行重复匹配 oneOf: [ // 处理css { test: /\\.css$/i, // 不对css文件进行树摇 sideEffects: true, use: [ MiniCssExtractPlugin.loader, { loader: \"css-loader\", options: { // 解决css中的图片引入问题 esModule: false, // 设置兼容性，回溯层级为1 importLoaders: 1 } }, { loader: \"postcss-loader\", options: { postcssOptions: { plugins: [\"postcss-preset-env\"] } } } ] }, // 处理less { test: /\\.less$/i, // 不进行树摇 sideEffects: true, use: [ MiniCssExtractPlugin.loader, { loader: \"css-loader\", options: { // 解决css中的图片引入问题 esModule: false, // 设置兼容性，回溯层级为2 importLoaders: 2 } }, { loader: \"postcss-loader\", options: { postcssOptions: { plugins: [\"postcss-preset-env\"] } } }, \"less-loader\" ] }, // 处理js { test: /\\.js$/i, // 不对js文件进行树摇 sideEffects: true, // 不处理node_modules下的js文件 exclude: /node_modules/, // 使用babel-loader处理js文件 use: [ { // 多进程打包 loader: \"thread-loader\", options: { // 开启4个进程,每个进程的启动大约是600毫秒 worker: 4, } } , { loader: \"babel-loader\", options: { presets: [ [ \"@babel/preset-env\", { // 指定corejs的版本 corejs: 3, // 选择corejs的填充模式 // usage : 按需填充，使用到那个功能再兼容那个功能 useBuiltIns: \"usage\", } ] ] } } ] }, // 处理ts { test: /\\.ts$/i, // 不对ts文件进行树摇 sideEffects: true, // 不处理node_modules下的ts文件 exclude: /node_modules/, // 使用babel-loader处理ts文件 use: [ { // 多进程打包 loader: \"thread-loader\", options: { // 开启4个进程,每个进程的启动大约是600毫秒 worker: 4, } } , { loader: \"babel-loader\", options: { presets: [ [ \"@babel/preset-env\", { // 指定corejs的版本 corejs: 3, // 选择corejs的填充模式 // usage : 按需填充，使用到那个功能再兼容那个功能 useBuiltIns: \"usage\", } ], [\"@babel/preset-typescript\"] ] } } ] }, // 处理html图片 { test: /\\.html$/i, loader: \"html-loader\", // 关闭esModule options: { esModule: false, } }, // 处理css图片 { test: /\\.(png|svg|gif|jpe?g)/i, type: \"asset\", generator: { // 如果图片的大小大于8kb，将把图片拷贝到dist目录下的img目录中 filename: \"img/[name][hash:4][ext]\" }, parser: { dataUrlCondition: { // 如果图片的大小小于8kb，将转换为base64的数据流格式 maxSize: 8 * 1024, } } }, // 处理字体资源 { test: /\\.(ttf|woff2?)$/i, // 将字体资源拷贝至dist目录下的font目录中 type: \"asset/resource\", generator: { filename: \"font/[name][hash:4][ext]\" } }, // 处理其他资源依赖图中被引入的资源 { exclude: /\\.(css|less|js|ts|vue|jpe?g|png|gif|svg|ico|ttf|woff2?)$/i, // 将其他被引入的资源拷贝至dist目录下的other目录中 type: \"asset/resource\", generator: { filename: \"other/[name][hash:4][ext]\" } } ] } ] }, plugins: [ // 每次执行npx webpack时将会自动清除dist目录下的文件 new CleanWebpackPlugin(), // 避免我们手动的在index.html中引入打包后的资源文件 new HtmlWebpackPlugin({ // 指定模板文件 template: \"./src/index.html\", minify: { // 移除模板文件中的空格 collapseWhitespace: true, // 移除模板文件中的注释 removeComments: true, } }), // 拷贝一些未在资源图中引入的文件 new CopyWebpackPlugin({ patterns: [ { // 拷贝那个目录下的内容 from: resolve(__dirname, \"src\", \"resource\"), // 拷贝到那个目录下，可不写，如果不写则按照output中的path进行输出 to: resolve(__dirname, \"dist\", \"resource\"), globOptions: { // 忽略的文件 ignore: [\"**/reboots.text\",] } } ] }), // 单独拆分css文件 new MiniCssExtractPlugin({ // 指定需要输出的文件名，它会在dist/css文件中进行输出 filename: \"css/[name].css\" }) ], // 设置路径别名，@代指src目录 resolve: { alias: { \"@\": resolve(__dirname, \"src\"), }, extensions: [\".js\", \".ts\", \".json\", \".less\", \".css\", \".scss\", \".vue\"] }, optimization: { minimizer: [ // 压缩css代码 new CssMinimizerPlugin(), ] }, } 如何使用 项目目录一览： ├── dist │ ├── ... ├── node_modules │ ├── ... ├── src │ ├── entry.js │ ├── index.html │ ├── resource │ │ └── readme.md │ └── static │ ├── css │ │ └── index.less │ ├── imgs │ │ ├── avatar.jpg │ │ └── nginx.jpeg │ └── js │ ├── index.ts │ └── login.ts ├── tsconfig.json ├── package-lock.json ├── package.json ├── webpack.dev.config.js └── webpack.pro.config.js 在开发环境下使用时，只需要注意开启热更新模块功能即可： import \"@/static/js/index.ts\" import \"@/static/js/login.ts\" if (module.hot) { module.hot.accept( // 支持热更新功能的模块 [ \"./static/js/index.ts\", \"./static/js/login.ts\", ], // 热更新后执行的回调函数 () => { console.log(\"module update!\"); } ) } 此外，css文件中对于图片的引入，也支持@的方式，这是因为我们配置了webpack.config.json中的reslove： background-image : url(@/static/imgs/nginx.jpeg); 在开发环境下，使用以下命令打开webpack开发服务器： $ npm run dev-server 在生成环境下，使用以下命令进行打包： $ npm run pro-build Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-09-09 20:19:04 "}}