{"./":{"url":"./","title":"Introduction","keywords":"","body":"专题阅读 我从2016年开始系统学习编程之后，便一直零零散散的记录着各种各样的笔记。 其中收集过很多相关资料，但是一直没有汇集成册。 刚好最近比较有空闲，就将自己的学习笔记汇聚成册，希望能够给大家提供帮助。 整体笔风可能不是特别面向新手，但是也应该能够对你有所帮助。 涵盖3大编程语言：Python\\Golang\\JavaScript 涵盖4大数据库产品：MySQL\\Redis\\Elasticsearch\\MongoDB 关于系统着重使用MacOS 10.14.6以及CentOS 7.3，暂时不提供Windows的相关文章。 系统配置是Core i5 4核心4线程、16G RAM、256SSD，也算是比较老的配置了。 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:46 "},"杂谈专栏/summary.html":{"url":"杂谈专栏/summary.html","title":"杂谈专栏","keywords":"","body":"Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:48 "},"杂谈专栏/编程语言区别.html":{"url":"杂谈专栏/编程语言区别.html","title":"编程语言区别","keywords":"","body":"低级语言 语言的高级和低级之分并不是说语言本身的层次高低，而是指的是与底层硬件的密切程度。 就如同机器语言与汇编语言就是直接与底层硬件打交道的语言，故也被称为低级语言。 机器语言 机器语言是不通过任何操作系统就可以直接与底层硬件打交道的语言，说白了就是计算机能读懂的二进制。 想要使用机器语言就得充分的了解计算机底层硬件的各个知识。 虽然这可能会花上你半生的时间，但是机器语言的执行效率却是无与伦比的高，计算机不需要通过任何编译就能直接运行。 与之相反的是机器语言的开发效率却是慢到令人发指，除了你需要去学习底层硬件相关的知识外还需要对每一条二进制指令烂熟于心，更加恐怖的是面对满屏的010101如果敲错一个字符就全部推倒重来，显然这已经超出了普通人所能承受的极限。 #指令部份的示例 0000 代表 加载（LOAD） 0001 代表 存储（STORE） ... ​ #暂存器部份的示例 0000 代表暂存器 A 0001 代表暂存器 B ... ​ #存储器部份的示例 000000000000 代表地址为 0 的存储器 000000000001 代表地址为 1 的存储器 000000010000 代表地址为 16 的存储器 100000000000 代表地址为 2^11 的存储器 ​ #集成示例 0000,0000,000000010000 代表 LOAD A, 16 0000,0001,000000000001 代表 LOAD B, 1 0001,0001,000000010000 代表 STORE B, 16 0001,0001,000000000001 代表 STORE B, 1[1] 名词 描述 执行效率 极高 开发效率 极低 跨平台性 极差（由于必须依赖具体的硬件，故移植性极差） 汇编语言 汇编语言仅仅是用一个英文标签代表一组二进制指令，毫无疑问，比起机器语言，汇编语言是一种进步，但汇编语言的本质仍然是直接操作硬件，因此汇编语言仍是比较低级/底层的语言、因为它十分的贴近计算机硬件。 汇编的中打印一句hello world，需要写十多行，如下： ; hello.asm section .data ; 数据段声明 msg db \"Hello, world!\", 0xA ; 要输出的字符串 len equ $ - msg ; 字串长度 section .text ; 代码段声明 global _start ; 指定入口函数 _start: ; 在屏幕上显示一个字符串 mov edx, len ; 参数三：字符串长度 mov ecx, msg ; 参数二：要显示的字符串 mov ebx, 1 ; 参数一：文件描述符(stdout) mov eax, 4 ; 系统调用号(sys_write) int 0x80 ; 调用内核功能 ; 退出程序 mov ebx, 0 ; 参数一：退出代码 mov eax, 1 ; 系统调用号(sys_exit) int 0x80 ; 调用内核功能 名词 描述 执行效率 极高 开发效率 低 跨平台性 极差（由于必须依赖具体的硬件，故移植性极差） 高级语言 高级语言并不关心底层硬件到底怎么样，因为高级语言是在和操作系统打交道。 而操作系统又是管控硬件的软件，所以高级语言相较于低级语言来说它的开发效率肯定是要快上不少，但是在执行效率上却有所损失。 对于语言的好坏一味的按照执行效率来区分并非是正确的，语言本身只是一种工具，使用语言的人才是真正的操纵者。 语言的对比只应场景适不适用，其本身并无强弱之分。 比如要对底层硬件进行开发，那么无疑汇编语言是最佳的选择，它能与本机硬件打交道所以能充分发挥自己执行效率高的特性，再比如要做一款网络爬虫相关的软件，由于网络具有延迟性会拖慢程序整体的运行速度，故使用汇编语言来编写爬虫便成了弱势（开发周期长，网络环境让汇编语言的高执行效率也体现不出来）。 高级语言中按照翻译方式的不同又大体可分为两类，分别是编译型语言与解释型语言。 编译型语言 如Golang，C语言等均为编译型语言。 编译型语言特点： 执行效率高：生成的目标文件可以脱离语言环境独立执行（因为都是存的二进制指令） 开发效率低：如果程序需要修改某一功能则必须修改源程序中的代码后再次生成目标程序，倘若只有目标程序而没有源程序的话则修改原本的功能是一件很困难的事情，这样做的好处是保证了代码的安全性，除开通过反编译技术手段否则看不见源代码 跨平台性差：大多数编译型语言的代码只针对某一个平台下进行编译，前平台下的编译结果（目标程序）无法拿到不同的平台上使用 其他：现在大多数的编程语言都是编译型的。编译程序（GCC）将源程序翻译成目标程序后保存在另一个文件中，该目标程序可脱离编译程序直接在计算机上多次运行。大多数软件产品都是以目标程序形式发行给用户的，不仅便于直接运行提升执行效率，同时又使他人难于盗用其中的技术 解释型语言 如Python，JavaScript均为解释型语言。 解释型语言特点： 执行效率低：在解释型语言的实现中，解释器并不产生目标机器代码，而是产生易于执行的中间代码。这种中间代码与机器代码是不同的，中间代码的解释是由软件支持的，不能直接使用硬件，软件解释器通常会导致执行效率偏低 开发效率高：用解释型语言编写的程序是由另一个可以理解中间代码的解释程序执行的，与编译程序不同的是，解释程序的任务是逐一将源程序的语句解释成可执行的机器指令，不需要将源程序翻译成目标代码再执行。解释程序的优点是当语句出现语法错误时，可以立即引起程序员的注意。让程序员在程序开发期间就能进行校正，故开发效率高于编译性语言 跨平台性强：代码运行是依赖于解释器，不同平台有对应版本的解释器，所以解释型语言的跨平台性更强 其他：对于解释型Basic语言，需要一个专门的解释器解释执行Basic程序，每条语句只有在执行时才被翻译，这种解释型语言每执行一次就翻译一次，因而效率低下。一般地，动态语言都是解释型的，例如：Tcl、Perl、Ruby、VBScript、JavaScript等 除此之外，还有一种混合型语言，如Java：Java语言首先会生成Java汇编，然后通过虚拟机进一步转换成计算机可以识别的二进制汇编语言。 动态与静态 动态类型：如果一门语言可以在运行时改变变量的类型，那我们称之为动态类型语言（如Python） 静态类型：相反，如果一门语言不可以在运行时改变变量的类型，则称之为静态类型语言（如Golang） 动态类型示例（Python演示）： >>> string = str(\"hello,world\") >>> type(string) >>> string = b\"\" >>> type(string) >>> 静态类型示例（Golang演示）： func main() { var str string str = \"hello,world\" fmt.Printf(\"%T\",str) str = 't' // 编译出现异常，不允许改变类型 } 强类型与弱类型 强类型：如果一门语言不倾向于对变量的类型做隐式转换，那我们将其称之为强类型语言（如Python） 弱类型：相反，如果一门语言倾向于对变量的类型做隐式转换，那我们则称之为弱类型语言（如JavaScript） 强类型示例（Python演示）： >>> 1 == \"1\" False 弱类型示例（JavaScript演示）： \"use strict\"; console.log(1 == \"1\"); // true Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:48 "},"杂谈专栏/详解字符编码.html":{"url":"杂谈专栏/详解字符编码.html","title":"详解字符编码","keywords":"","body":"字符编码 计算机使用计算机语言（2进制）表示数据，人类使用自然语言表示数据。 人类若想和计算机进行无障碍沟通，必须要通过一本记载着计算机语言与自然语言关系的词典。 而通过这本词典与计算机进行沟通交互的过程即可被称为字符的编码、解码的过程： 编码是指将自然语言转换为计算机语言的过程。 解码是指将计算机语言转换为自然语言的过程。 ASCII 计算机由西方世界发明，所以第一个字符编码表仅记录了一些英文与符号，该表也被称为ASCII码表。 它仅支持一些英文字符与特殊符号，不支持其他国家的语言字符。 实际上ASCII码表在设计之初，就预留了一些位置，最初的ASCII码表中每一个字符仅占用7bit的位置，也就最多表示128个字符。 最初的ASCII码表仅有128个字符，后来经过扩展，又新增了128个字符，此时的ASCII码表中，一个字符占用1Bytes（8bit）的位置。： GBK 随着计算机在世界范围内高速发展，ASCII码表已经不满足广大用户的需求了。 此时，各个国家开始推出自己的字符编码表，如： 日本的Shift-JIS表等 韩国的Euc-Kr表等 中国的gb2312、GBK表等 ... 这些表都有一个特点，即除了包含原本的ASCII码表之外还包含了本国的通用语言。 在GBK编码表中，一个英文字符占用1Bytes(8bit)，而一个中文字符则占用2Bytes(16bit)。 此时，出现了1个严重的问题，即跨国的通信问题，如下图所示： Unicode 为了解决这个问题，在1990年的时候推出了Unicode表，并且在1994年正式使用。 它详细的记录了所有自然语言与计算机语言的对应关系，在（usc2标准）中每一个字符不管是英文还是中文都占用2个Bytes（16bit），而在（usc4标准）中则统一占用4个Bytes（32bit），这样就解决了跨国通信的问题。 对比ASCII码表英文字符仅占用1个Bytes而言，如果直接使用Unicode编码进行文件存储则存储空间会直接翻倍，因此Unicode表仅存在于内存之中，而在网络传输以及文件存储上则采用了另外的编码格式。 换句话说，Unicode仅作为翻译词典存在于计算机内部，Unicode因为包含了所有自然语言与计算机语言的关系，因此作为翻译词典是最合适不过的。 UTF8 如下图，中文网站由GBK编码存储，国内的计算机中应该都有GBK编码，所以访问该网站非常轻松，而在日本计算机上若想访问该网站则必须要先下载GBK后方能以GBK的解码形式打开该网站，否则会产生乱码问题。 那么有没有一种编码，能够统一整个互联网，让所有计算机都用这种编码进行文件存储、网络传输呢？ 此时，出现了UTF8编码，全称为Unicode Transformation Format，即Unicode的转换格式，它是一种可变长的编码格式。 在UTF8编码格式中，英文字符统一占用1Bytes(8bit)的位置，而中文字符则占用3Bytes(24bit)或者4Bytes(32Bytes)的位置。 UTF8编码是未来的发展趋势，它与Unicode对比的唯一区别在于它不包含其他字符编码表。 在依然存在以GBK编码格式、Shift-JIS编码格式进行文件存储的环境下，使用UTF8作为翻译词典并不合适。 但是如果有一天所有人都统一使用UTF8进行文件存储网络传输的话，那么就不再需要包含其他字符编码表了，此时UTF8将会真正代替Unicode入驻内存中成为翻译词典，当然这是后话，目前还没有达到这样的理想情况。 UTF8的编解码 UTF8与Unicode的关系如下： 编码过程 如我们要将“云”字根据UTF8格式存储到磁盘中： 1.通过Python3中的hex()和ord()函数先得出该字符Unicode的16进制表现形式： >>> hex(ord(\"云\")) '0x4e91' 2.再将这个16进制的Unicode字符转换为2进制，那么这个2进制就是“云”字在内存中存储的样子： >>> bin(int(\"4e91\",base=16)) '0b100111010010001' 3.现在，计算机要把“云”字写入磁盘中，由于是使用的UTF8编码格式，所以先确定它的占用空间是3Bytes还是4Bytes，规则如下，套用表即可： 码位范围（Unicode十六进制） utf-8 0000 ~ 007F 用1个Bytes表示 0080 ~ 07FF 用2个Bytes表示 0800 ~ FFFF 用3个Bytes表示 4e91 在这里，第3分区 10000 ~ 10FFFF 用4个Bytes表示 4.确定了“云”字占用3Bytes，我们可以通过一个模板，将Unicode的2进制转换为UTF8的2进制： 码位范围（十六进制） 转换模板 0000 ~ 007F 0XXXXXXX 0080 ~ 07FF 110XXXXX 10XXXXXX 0800 ~ FFFF 1110XXXX 10XXXXXX 10XXXXXX 10000 ~ 10FFFF 11110XXX 10XXXXXX 10XXXXXX 10XXXXXX 5.根据分区信息，选用3Bytes的模板，进行转换，从右至左依次填充，不够的使用0进行填充： 1110XXXX 10XXXXXX 10XXXXXX 100 111010 010001 1110XXXX 10XXXXXX 10XXXXXX 0100 111010 010001 # 填充0 11100100 10111010 10010001 # 结果 所以最后得出的结果，“云”用UTF8格式保存至磁盘的话，2进制格式为11100100 10111010 10010001。 解码过程 如果要将“云”字UTF8的2进制格式转换为字符，则还是需要通过Unicode进行解码过程。 当计算机读取到这个文件是以UTF8格式进行存储后，内部已经做好了通过UTF8进行解码的准备。 开始读取后，计算机会将硬盘中存储的UTF8的2进制格式文字信息加载至内存中： 11100100 10111010 10010001 现在，Unicode会参照模板，通过UTF8分区信息提取出该文字Unicode的2进制格式： 码位范围（十六进制） 转换模板 0000 ~ 007F 0XXXXXXX 0080 ~ 07FF 110XXXXX 10XXXXXX 0800 ~ FFFF 1110XXXX 10XXXXXX 10XXXXXX 10000 ~ 10FFFF 11110XXX 10XXXXXX 10XXXXXX 10XXXXXX 11100100 10111010 10010001 “云”字的二进制信息格式刚好对应第3分区，那么我们按照第3分区的模板格式对UTF8的2进制表现形式进行掐头工作，将它转变为Unicode的2进制表现格式。 1110XXXX 10XXXXXX 10XXXXXX 11100100 10111010 10010001 0100 111010 010001 # 掐头 100111010010001 # 结果 得到了结果为100111010010001，现在可以通过一系列Python3函数将它转换为Unicode字符，转换过程如下所示： >>> int(\"100111010010001\",base=2) 20113 >>> hex(20113) '0x4e91' >>> \"\\u4e91\" '云' Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:48 "},"杂谈专栏/放一些常见题目.html":{"url":"杂谈专栏/放一些常见题目.html","title":"常见问题大全","keywords":"","body":"常见问题 Python 基础知识 %accordion%解释器版本升级%accordion% py2项目如何迁移成py3? 答案： six模块 使用py3自带的2to3.py工具将py2转换为py3 %/accordion% %accordion%值比较与引用比较%accordion% 聊聊is和==的区别？ 答案： is会判断2个对象是否来自同一引用 ==仅2个对象的判断表现形式是否相同 %/accordion% %accordion%内存管理%accordion% Python是如何进行内存管理的? Python的程序会内存泄漏吗?说说有没有什么方面阻止或检测内存泄漏 答案： python是使用私有堆进行内存管理的，我们无法访问，只能通过接口进行一些相关操作，python程序存在内存泄漏，主要是由于python是使用的引用计数的方式进行内存管理的，而如果重写__del__方法时声明了变量，因为计数还未变为0，所以会存在内存泄露。 阻止或检测的方法： 1. 程序员管理好每个python对象的引用，尽量在不需要使用对象的时候，断开所有引用 2. 尽量少通过循环引用组织数据，可以改用weakref做弱引用或者用id之类的句柄访问对象 3. 通过gc模块的接口可以检查出每次垃圾回收有哪些对象不能自动处理，再逐个逐个处理 %/accordion% %accordion%深浅拷贝%accordion% 简述Python深浅拷贝？ 答案： 不可变类型没有深浅拷贝，所有对不可变类型的深浅拷贝均是引用 所以深浅拷贝仅针对容器类型： 浅拷贝：仅拷贝容器的第一层，将不是不可变类型的对象都复制一份 深拷贝：递归的拷贝容器中所有层，将不是不可变类型的对象都复制一份 %/accordion% %accordion%循环打印乘法表%accordion% 用Python实现99乘法表(用两种不同的方法实现) 答案1： for i in range(1, 10): for j in range(1, 1 + i): print(\"{} * {} = {}\".format(i, j, i * j), end=\"\\t\") print(\"\") 答案2： i = 1 j = 1 while i %/accordion% %accordion%文件读取%accordion% 一个大小为100G的文件etl_log.txt, 要读取文件中的内容, 写出具体过程代码？ 答案： with open(\"fileName\", mode=\"rt\", encoding=\"utf8\") as f: for item in f: print(item) # file对象就是一个迭代器，具有惰性求值的功能 %/accordion% %accordion%计数器实现%accordion% 有一个数组[3, 4, 1, 2, 5, 6, 6, 5, 4, 3, 3] 请写一个函数, 找出该数组中没有重复的数的总和 ，例如上面数据的没有重复的总和为1+2=3。 答案： def add(seq): result = 0 saveTable = {} for item in seq: if item not in saveTable: saveTable[item] = 1 else: saveTable[item] += 1 for sumNumber in saveTable: if saveTable[sumNumber] == 1: result += sumNumber return result print(add([3, 4, 1, 2, 5, 6, 6, 5, 4, 3, 3])) %/accordion% 数据类型 %accordion%布尔类型判断%accordion% 下列哪种说法是错误的 除字典类型外, 所有标准对象均可用于布尔测试 空字符串的布尔值是False 空列表对象的布尔值是False 值为0的任何数字对象的布尔值是False 答案： 1 字典类型也能用于布尔测试 %/accordion% %accordion%字典的hash%accordion% 选择代码的运行结果： country_counter ={} def addone(country): if country in country_counter: country_counter[country ]+=1 else: country_counter[country ]= 1 addone(\"China\") addone(\"Japan\") addone(\"china\") print len(country_counter ) A:0 B:1 C:2 D:3 E:4 答案：D，China和china的hash值不同 %/accordion% %accordion%字典的key是否存在？%accordion% 如何判断一个字典中的key是否存在？方法越多越好 答案： dic = {chr(i):i for i in range(65, 65 + 26)} # 1 print(dic.get(\"A\")) # 2 print(\"A\" in dic) # 3 print(dic[\"A\"]) # 4 print(dic.pop(\"A\")) %/accordion% %accordion%列表推导式%accordion% 如何用一行代码生成[1, 4, 9, 16, 25, 36, 49, 64, 81, 100] ? 答案： print( [i ** 2 for i in range(1, 11)] ) %/accordion% %accordion%序列翻转%accordion% 翻转1个字符串，如”1234“翻转为”4321“： 答案： string = \"1234\" print(string[::-1]) print(str.join(\"\", list(reversed(string)))) %/accordion% %accordion%字典的setdefault()方法%accordion% 将列表内的元素,根据位数合并成字典，列表如下： lst = [1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 32769, 65536, 4294967296] 答案： lst = [1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 32769, 65536, 4294967296] dic = {} for i in lst: k = len(str(i)) # 如果不存在该键，这该键等同于一个空列表 dic.setdefault(k, []) dic[k].append(i) print(dic) %/accordion% 函数相关 %accordion%形参类型必须为不可变%accordion% 写出程序运行结果： def add_end(l=[]): l.append(\"end\") return l add_end() add_end() 答案： [\"end\"] [\"end\", \"end\"] %/accordion% %accordion%命名空间%accordion% 全局变量和局部变量的区别, 如何给function里面的一个全局变量赋值? 答案： 全局变量是指存放在global namespace中的变量，它允许在任何命名空间中访问 全局有效，全局存活 局部变量是指存放在local namespace中的变量，它仅允许在当前函数的运行时访问，同时，也允许该函数中嵌套定义的子函数在运行时访问 局部有效，局部存活。 function里面如果要对1个全局变量进行赋值，可使用global关键字，如： x = 1 def func(): global x x += 1 %/accordion% %accordion%标识符命名冲突问题%accordion% 请写出下面程序的运行结果： a = 1 def fun(a): a = 2 fun(a) print(a) a = [] def fun(a): a.append(1) fun(a) print(a) 答案： 1 [1] %/accordion% %accordion%lambda表达式？%accordion% 简述lambda表达式格式以及应用场景。 答案： 格式如下： lambda x, y : x + y 形参可以没有，不必显式return 常与内置函数搭配使用，如filter，map，sorted，max等 %/accordion% %accordion%多装饰器嵌套%accordion% 请给出下面代码片段的输出： def say_hi(func): def wrapper(*args, **kwargs): print(\"HI\") ret = func(*args, **kwargs) print(\"BYE\") return ret return wrapper def say_yo(func): def wrapper(*args, **kwargs): print(\"YO\") return func(*args, **kwargs) return wrapper @say_hi @say_yo def func(): print(\"ROCK & ROLL\") func() 答案： print(\"HI\") print(\"YO\") print(\"ROCK & ROLL\") print(\"BYE\") %/accordion% %accordion%生成器与普通函数的区别？%accordion% 解释生成器与函数的不同, 并实现和简单使用generator 答案： 当一个函数中具有yield关键字时，此函数即为生成器函数 区别如下： 普通函数加括号是立即调用函数，执行函数体内部代码 生成器函数加括号是返回一个生成器对象，必须通过for循环或者手动使用send(None)或者调用其下的next()方法进行启动 生成器函数比普通函数的运行栈帧会多一个保存当前函数挂起状态的C语言结构体，因为yield关键字之后会将函数状态进行挂起，而return直接会返回并将函数栈帧从系统调用栈中踢出来 生成器对象可以通过send()方法与生成器函数体中yield进行数据交互，而普通的函数则不行，一经return直接结束函数运行 值得一提的是低版本中，yield和return不能同时出现 def genFunc(): yield 1 yield 2 yield 3 genObject = genFunc() for item in genObject: print(item) %/accordion% %accordion%递归打印%accordion% 有一个多层嵌套的列表A=[1,2,[3,4,[\"434\",...]]], 请写一段代码遍历A中的每一个元素并打印出来 答案： def func(li): for item in li: if isinstance(item, list): func(item) else: print(item) func([1, 2, [3, 4, [\"434\"]]]) %/accordion% %accordion%sorted()函数中key参数的使用%accordion% 将以下字典按照value的大小进行排序： d = {\"a\": 26, \"g\": 20, \"e\": 20, \"c\": 24, \"d\": 23, \"f\": 21, \"b\": 25} 答案： d = {\"a\": 26, \"g\": 20, \"e\": 20, \"c\": 24, \"d\": 23, \"f\": 21, \"b\": 25} print(sorted(d, key=lambda k:d[k])) %/accordion% %accordion%zip的使用%accordion% 写代码 tupleA = (\"a\",\"b\",\"c\",\"d\",\"e\") tupleB = (1,2,3,4,5) RES = {\"a\":1,\"b\":2,\"c\":3,\"d\":4,\"e\":5} 写出由tupleA和tupleB得到res的及具体实现过程 答案： dict(zip(tupleA, tupleB)) %/accordion% %accordion%ord()和chr()使用%accordion% 写一个base62encode函数，实现62进制解码。 范围0-10，a-z，A-Z def base62encode(number): if number 61: raise ValueError(\"Must be between 0 - 61\") encodeTable = ( *[i for i in range(10)], *[chr(i) for i in range(97, 123)], *[chr(i) for i in range(65, 91)],) return encodeTable[number] print(base62encode(61)) # Z %/accordion% %accordion%生成器编写斐波拉契数列%accordion% 使用生成器编写fib函数，函数声明为fib(max)，输入一个参数max值，使得该函数可以这样调用： for i in range(0,100): print fib(1000) 并产生如下结果(斐波那契数列) 1, 1, 2, 3, 5, 8, 13, 21... 答案： def fib(max): count, currentValue, nextValue = 0, 0, 1 while count %/accordion% %accordion%IP地址转换%accordion% 请编写一个函数实现将IP地址转换成一个整数。 如 10.3.9.12 转换规则为： 10 00001010 3 00000011 9 00001001 12 00001100 再将以上二进制拼接起来计算十进制结果：00001010 00000011 00001001 00001100 = ？ 答案： def transformIpAddr(ip): bitIpList = list(map(lambda x: str(bin(int(x)))[ 2:].rjust(8, \"0\"), ip.strip().split(\".\"))) return int(\"\".join(bitIpList), base=2) print(transformIpAddr(\"10.3.9.12\")) %/accordion% %accordion%计时装饰器实现%accordion% 请实现一个装饰器, 限制该函数被调用的频率, 如10秒一次 答案： import datetime import time def warpper(s=10): def outer(func): nextRunTime = None def inner(*args, **kwargs): nonlocal nextRunTime nowTime = datetime.datetime.now() if nextRunTime is None or nowTime > nextRunTime: result = func(*args, **kwargs) nextRunTime = datetime.timedelta(seconds=s) + nowTime return result print(nextRunTime - nowTime) return inner return outer @warpper(10) def func(): print(\"run...\") for i in range(10): time.sleep(2) func() %/accordion% %accordion%可迭代对象%accordion% 下列数据结构中,哪一种是不可迭代的 A. dict B. object C. set D. str 答案： B %/accordion% 算法与数构 %accordion%哈希冲突回避算法有哪几种, 分别有什么特点？%accordion% 开放定址法： 所谓的开放定址法就是一旦发生了冲突，就去寻找下一个空的散列地址，只要散列表足够大，空的散列地址总能找到，并将记录存入 再哈希法： 再哈希法又叫双哈希法，有多个不同的Hash函数，当发生冲突时，使用第二个，第三个，….，等哈希函数 计算地址，直到无冲突。虽然不易发生聚集，但是增加了计算时间。 链地址法： 链地址法的基本思想是：每个哈希表节点都有一个next指针，多个哈希表节点可以用next指针构成一个单向链表，被分配到同一个索引上的多个节点可以用这个单向链表向后排列。 建立公共溢出区： 这种方法的基本思想是：将哈希表分为基本表和溢出表两部分，凡是和基本表发生冲突的元素，一律填入溢出表 %/accordion% 模块相关 %accordion%pip命令的使用%accordion% 如何安装第三方模块？ 答案： pip install module name %/accordion% %accordion%datetime模块%accordion% 输入某年某日, 判断这是这一年的第几天?(可以用Python的内置模块) 答案： import datetime def dayofyear(): year = input(\"请输入年份：\") month = input(\"请输入月份：\") day = input(\"请输入天：\") date1 = datetime.date(year=int(year),month=int(month),day=int(day)) date2 = datetime.date(year=int(year),month=1,day=1) return (date1 - date2).days + 1 print(dayofyear()) %/accordion% %accordion%random使用%accordion% 如何生成一个随机数？ 答案： random.random() 生成0-1之间的随机小数。 %/accordion% %accordion%sys与模块路径查找%accordion% sys.path.append(\"/root/mods\")的作用？ 答案： 添加/root/mods路径至硬盘模块查找中 %/accordion% %accordion%os模块应用%accordion% 如何用Python删除1个文件？ os.remove() %/accordion% %accordion%文件递归%accordion% 写代码实现查看一个目录下的所有文件。 答案： import os def pathRecursion(path): print(path) if os.path.isdir(path): for subPath in os.listdir(path): pathRecursion(os.path.join(path, subPath)) pathRecursion(os.path.abspath(os.getcwd())) %/accordion% %accordion%JSON转中文%accordion% json序列化时，默认遇到中文会转换成unicode，如果想要保留中文怎么办？ 答案： 序列化时添加参数： ensure_ascii=False %/accordion% %accordion%JSON扩展%accordion% json序列化时，可以处理的数据类型有哪些？如何定制支持datetime类型？ 答案: json序列化只能序列化Python基本数据类型。 如果要想序列化非Python基本数据类型，则可以使用参数cls进行定制，详情参见Python模块一章。 json.dumps(data, cls=自己写的类) %/accordion% %accordion%简述logging模块作用%accordion% logging模块的作用？以及应用场景？ 答案： 日志记录 %/accordion% %accordion%正则表达式贪婪匹配%accordion% 什么是正则的贪婪匹配？或 正则匹配中的贪婪模式与非贪婪模式的区别？ 答案： *+?{n, m}都是贪婪模式，即有多个的时候匹配多个。 通过?可取消贪婪模式，即及时有多个也取最少的 %/accordion% %accordion%正则表达式%accordion% 请写出以字母或下划线开始, 以数字结束的正则表达式 答案： import re result = re.search(pattern=r\"^[A-Za-z0-9_].*\\d$\", string=\"321\") print(result.group()) %/accordion% %accordion%re模块中search和match的区别？%accordion% 请问re模块中search()和match()有什么区别？ 答案： search和match都有1个共同点，即只会成功匹配1次 不同点在于match只会匹配开头，相当于search基础上加了^ %/accordion% %accordion%如何判断一个邮箱是否合法？%accordion% 如何判断一个邮箱是否合法？ 答案： ^[a-zA-Z0-9_-]+@[a-zA-Z0-9_-]+(\\.[a-zA-Z0-9_-]+)+$ %/accordion% %accordion%itertools模块%accordion% 写代码：用户输入一个字符串，打印该字符串的所有不重复排列组合。 答案： from itertools import permutations a = input() for i in permutations(a, len(a)): print(''.join(i)) %/accordion% 面向对象 %accordion%简述oop三大特性%accordion% 请简述oop三大特性。 答案： 封装：将代码封装起来，只留下接口，通过接口访问对象 继承：实现多复用，子类的公用方法和属性可以从父类继承，减少代码冗余 多态，面向对象最灵活的地方，可以动态绑定，一种事物，多种形态，也称鸭子类型 %/accordion% %accordion%类变量和实例变量的区别%accordion% 请简述类变量和实例变量的区别。 答案： 实例变量仅存在实例对象的内存空间，类是无法调用实例变量。 类变量 存在整个类对象的内存空间，所有该类实例化出来的对象都可以调用到这些变量 %/accordion% %accordion%类与实例作用域%accordion% 以下代码输出是什么? 请给出答案并解释： class Parent(object): x = 1 class Child1(Parent): pass class Child2(Parent): pass print Parent.x, Child1.x, Child2.x Child1.x = 2 print Parent.x, Child1.x, Child2.x Parent.x = 3 print Parent.x, Child1.x, Child2.x 答案： 1 1 1 1 2 1 3 2 3 详情参见类与对象一篇，类与实例命名空间和标识符查找顺序。 %/accordion% %accordion%类方法与静态方法%accordion% 请简单解释Python中的static method(静态方法)和class method(类方法),并将以下代码填写完整 class A(object): def foo(self,x) print 'executing foo(%s, %s)'%(self,x) @classmethod def class_foo(cls,x): print 'executing class_foo(%s, %s)'%(cls,x) @staticmethod def static_foo(x): print 'executing static_foo(%s)'%(x) a= A() # 调用foo函数,参数传入1 ____________________ # 调用class_foo函数,参数传入1 ____________________ # 调用static_foo函数,参数传入1 答案： @classmethod：类的绑定方法，只能由类调用 @staticmethod：类的静态方法，类和instance都能调用 a.foo(1) A.class_foo(1) A.static_foo(1) a.static_foo(1) %/accordion% %accordion%上下文管理机制%accordion% 有用过with statement（语句）吗？它的好处是什么？ 答案： 上下文管理，with完成后自动调用__exit__(). 故可以在__exit__()中关闭系统占用资源 %/accordion% %accordion%上下文管理器实现%accordion% 参考下面代码片段 class Context: pass with Content() as ctx: ctx.do_something() 请在Context类下添加代码完成该类的实现 答案： class Context: def __enter__(self): print(\"run .. enter\") return self def __exit__(self,exc_type,exc_val,exc_tb): print(\"run .. exit\") return self def do_something(self): print(\"run .. do something\") return self with Context() as ctx: ctx.do_something() %/accordion% %accordion%super()方法%accordion% super()的作用？ 答案： 根据mro属性查找顺序列表来依次访问父类、超类、基类。 达到方法借用的目的。 %/accordion% %accordion%单例模式%accordion% 实现一个Singleton单例类, 要求遵循基本语言编程规范（用尽量多的方式）。 方式1，元类实现： class MetaClass(type): def __call__(self, *args, **kwargs): \"\"\" self : class Singleton \"\"\" if not hasattr(self, \"ins\"): insObject = super(__class__, self).__call__(*args, **kwargs) setattr(self, \"ins\", insObject) return getattr(self, \"ins\") class Singleton(object, metaclass=MetaClass): pass if __name__ == \"__main__\": ins = Singleton() print(id(ins)) ins = Singleton() print(id(ins)) 方式2，继承实现： class ParentClass: def __new__(cls, *args, **kwargs) -> object: \"\"\" cls : class Singeton \"\"\" if not hasattr(cls, \"ins\"): insObject = super(__class__, cls).__new__(cls, *args, **kwargs) setattr(cls, \"ins\", insObject) return getattr(cls, \"ins\") class Singleton(ParentClass): pass if __name__ == \"__main__\": ins = Singleton() print(id(ins)) ins = Singleton() print(id(ins)) 方式3，装饰器实现： def warpper(clsObject): def inner(*args, **kwargs): if not hasattr(clsObject, \"ins\"): insObject = clsObject(*args, **kwargs) setattr(clsObject, \"ins\", insObject) return getattr(clsObject, \"ins\") return inner @warpper class Singleton: pass if __name__ == \"__main__\": ins = Singleton() print(id(ins)) ins = Singleton() print(id(ins)) 方式4，模块实现： - foo.py --> ins = Singleton() - bar.py --> from foo import ins 方式5，@classmethod实现单例模式： class Singleton: @classmethod def getSingletonInstanceObject(cls, *args, **kwargs): if not hasattr(cls, \"ins\"): insObject = cls(*args, **kwargs) setattr(cls, \"ins\", insObject) return getattr(cls, \"ins\") if __name__ == \"__main__\": ins = Singleton.getSingletonInstanceObject() print(id(ins)) ins = Singleton.getSingletonInstanceObject() print(id(ins)) %/accordion% %accordion%双下方法举例%accordion% 列举面向对象中带双下划线的特殊方法。 答案： __getitem__ __setitem__ __delitem__ __getattr__ __setattr__ __delattr__ __continar__ .. %/accordion% %accordion%isinstance和type%accordion% 简述isinstance()和type()的区别。 答案： isinstance判断一个对象是否来自于一个类的实例，返回布尔值 type用于返回指定实例的类型，返回类对象本身 %/accordion% %accordion%简述duke type%accordion% 什么是鸭子类型？ 答案： 如果它走起来像鸭子，而且叫起来像鸭子，那么它就是鸭子 也就是说，我们只关注对象行为而不关注对象本身 %/accordion% %accordion%单下划线和双下划线的区别？%accordion% 简述单下划线开头的变量名和双下滑先开的变量名有什么区别？ 答案： 单下划线开头的变量名逻辑上是私有变量，即不推荐外部进行访问，但是外部仍然可以访问到，并未对变量名本身做任何处理。 双下划线开头的变量名逻辑上是私有变量，即禁止外部进行访问，会将变量名重命名，规则为 _类名.__变量名 %/accordion% %accordion%简述mro%accordion% mro是什么？有什么作用？如何获取？ 答案： mro是属性查找顺序列表，由c3算法生成。 仅新式类具有该属性，经典类没有。 调用方式： className.mro() or className.__mro__ %/accordion% %accordion%可调用对象%accordion% python中如何判断一个对象是否可调用? 那些对象可以是可调用对象?如何定义一个类, 使其对象本身就是可调用对象? 答案： 使用callable(Object)判断一个对象是否可调用 函数，类都是可调用对象 如果想 className() ，则需要在其metaclass中定义 __call__() 方法， 如果想instanceName()， 则需要在其实现类中定义 __call__() 方法 %/accordion% 格式 %accordion%Some title here%accordion% Any content here %/accordion% Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:48 "},"杂谈专栏/一些常见软件的安装目录.html":{"url":"杂谈专栏/一些常见软件的安装目录.html","title":"常见软件安装目录","keywords":"","body":"brew brew install下载的软件，安装在： /usr/local/Cellar/* Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:48 "},"杂谈专栏/HTTP服务相关.html":{"url":"杂谈专栏/HTTP服务相关.html","title":"HTTP服务相关","keywords":"","body":"常见状态码 HTTP状态码由三个十进制数字组成，第一个十进制数字定义了状态码的类型，后两个数字没有分类的作用。HTTP状态码共分为5种类型： 分类 分类描述 1** 信息，服务器收到请求，需要请求者继续执行操作 2** 成功，操作被成功接收并处理 3** 重定向，需要进一步的操作以完成请求 4** 客户端错误，请求包含语法错误或无法完成请求 5** 服务器错误，服务器在处理请求的过程中发生了错误 HTTP状态码列表: 状态码 状态码英文名称 中文描述 100 Continue 继续。客户端应继续其请求 101 Switching Protocols 切换协议。服务器根据客户端的请求切换协议。只能切换到更高级的协议，例如，切换到HTTP的新版本协议 200 OK 请求成功。一般用于GET与POST请求 201 Created 已创建。成功请求并创建了新的资源 202 Accepted 已接受。已经接受请求，但未处理完成 203 Non-Authoritative Information 非授权信息。请求成功。但返回的meta信息不在原始的服务器，而是一个副本 204 No Content 无内容。服务器成功处理，但未返回内容。在未更新网页的情况下，可确保浏览器继续显示当前文档 205 Reset Content 重置内容。服务器处理成功，用户终端（例如：浏览器）应重置文档视图。可通过此返回码清除浏览器的表单域 206 Partial Content 部分内容。服务器成功处理了部分GET请求 300 Multiple Choices 多种选择。请求的资源可包括多个位置，相应可返回一个资源特征与地址的列表用于用户终端（例如：浏览器）选择 301 Moved Permanently 永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替 302 Found 临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI 303 See Other 查看其它地址。与301类似。使用GET和POST请求查看 304 Not Modified 未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源 305 Use Proxy 使用代理。所请求的资源必须通过代理访问 306 Unused 已经被废弃的HTTP状态码 307 Temporary Redirect 临时重定向。与302类似。使用GET请求重定向 400 Bad Request 客户端请求的语法错误，服务器无法理解 401 Unauthorized 请求要求用户的身份认证 402 Payment Required 保留，将来使用 403 Forbidden 服务器理解请求客户端的请求，但是拒绝执行此请求 404 Not Found 服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置\"您所请求的资源无法找到\"的个性页面 405 Method Not Allowed 客户端请求中的方法被禁止 406 Not Acceptable 服务器无法根据客户端请求的内容特性完成请求 407 Proxy Authentication Required 请求要求代理的身份认证，与401类似，但请求者应当使用代理进行授权 408 Request Time-out 服务器等待客户端发送的请求时间过长，超时 409 Conflict 服务器完成客户端的 PUT 请求时可能返回此代码，服务器处理请求时发生了冲突 410 Gone 客户端请求的资源已经不存在。410不同于404，如果资源以前有现在被永久删除了可使用410代码，网站设计人员可通过301代码指定资源的新位置 411 Length Required 服务器无法处理客户端发送的不带Content-Length的请求信息 412 Precondition Failed 客户端请求信息的先决条件错误 413 Request Entity Too Large 由于请求的实体过大，服务器无法处理，因此拒绝请求。为防止客户端的连续请求，服务器可能会关闭连接。如果只是服务器暂时无法处理，则会包含一个Retry-After的响应信息 414 Request-URI Too Large 请求的URI过长（URI通常为网址），服务器无法处理 415 Unsupported Media Type 服务器无法处理请求附带的媒体格式 416 Requested range not satisfiable 客户端请求的范围无效 417 Expectation Failed 服务器无法满足Expect的请求头信息 500 Internal Server Error 服务器内部错误，无法完成请求 501 Not Implemented 服务器不支持请求的功能，无法完成请求 502 Bad Gateway 作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到了一个无效的响应 503 Service Unavailable 由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的Retry-After头信息中 504 Gateway Time-out 充当网关或代理的服务器，未及时从远端服务器获取请求 505 HTTP Version not supported 服务器不支持请求的HTTP协议的版本，无法完成处理 常见MIME 以下例举常见的mime类型： 类型/字类型 扩展名 text/plain *.txt 或 其他文本文件 text/html .html 或 .htm text/css *.css text/javascript *.js application/json *.json image/gif *.gif image/png *.png image/jpeg .jpg 或 .jpeg image/bmp *.bmp image/webp *.webp image/svg+xml *.svg(矢量图) image/x-icon *.ico audio/wav *.wav audio/webm *.webm audio/ogg *.ogg audio/mpeg *.mp3 video/webm *.webm video/ogg *.ogg video/mp4 *.mp4 application/octet-stream .*（ 二进制流，不知道下载文件类型） Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:48 "},"杂谈专栏/推荐电子书.html":{"url":"杂谈专栏/推荐电子书.html","title":"推荐电子书","keywords":"","body":" koa2框架学习 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:48 "},"Python/summary.html":{"url":"Python/summary.html","title":"Python专栏","keywords":"","body":" Python快速入门 Python基础知识 Python函数相关 Python模块与包 Python面向对象 Python数算基础 Python设计模式 Python网络编程 Python并发编程 Python驱动程序 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:46 "},"Python/Python快速入门/summary.html":{"url":"Python/Python快速入门/summary.html","title":"Python快速入门","keywords":"","body":" Python简介 Python安装 pip简单使用 Python虚拟环境 Python常用工具 PEP8规范说明 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:46 "},"Python/Python快速入门/Python简介.html":{"url":"Python/Python快速入门/Python简介.html","title":"Python简介","keywords":"","body":"Python简述 Python诞生于1989年圣诞节，由仁慈的独裁者（Benevolent Dictator For Life，缩写BDFL）吉多·范罗苏姆（Guido van Rossum）基于C语言开发。 Python的名字来源于龟叔（Guido van Rossum在Python界的爱称）十分喜欢的一部名为Monty Python's Flying的电视剧，一想到这个风靡全球的编程语言名字居然来的这么随意，不禁让人哑然失笑。 作为一门解释性的动态强类型语言，Python的开发效率奇高，因此在Python界流传着这样一句至理名言： 人生苦短，我用Python Python并不是毫无缺点的孩子，作为一门动态语言，它的执行效率是偏低的。 作为80年代的产物，它的并发性支持也可能不太好，但是这并不妨碍我们对它的热爱，相信只要拥入Python的怀抱你一定会爱上这一门优雅的语言。 Python解释器 由于是动态语言，Python在代码执行时必须先将代码转换为字节码，然后通过字节码再转换为机器可读的机器码。 而解释器就是负责这一切工作的小蜜蜂。 我们常说的Python是基于C语言开发而来的CPython，除此之外还有基于Java开发而来的Jython、以及基于C#开发而来的IronPython。 不论是Jython还是IronPython，我们在学习时都不会去考虑，而是统一选择CPython，因为它们相较于传统的CPython多了一个转换环节所以会导致执行效率的降低。 低效率的执行 动态语言是逐行翻译，我们可以将它理解为一种边跑边看的策略。 这样做的后果是方便代码排查，缺点是拉低执行效率。 常见的Python解释器（包括CPython）等都是采用这种策略，故Python的执行效率一直被人诟病。 PyPy解释器 熟悉Python的朋友都知道，有一款Python解释器打破了人们对于Python低执行效率的印象。 它就是PyPy解释器，PyPy是另一个Python解释器，它的目标是执行速度。 PyPy采用JIT技术，对Python代码进行动态编译（注意不是解释），所以可以显著提高Python代码的执行速度。 绝大部分Python代码都可以在PyPy下运行，但是PyPy和CPython有一些是不同的，这就导致相同的Python代码在两种解释器下执行可能会有不同的结果。 如果你的代码要放到PyPy下执行，就需要了解PyPy和CPython的不同点。 你可以简单的这么理解： 代码第一次运行时：进行动态编译，生成目标文件 代码第二次运行时：使用目标文件进行运行，没必要再进行逐行翻译，故执行效率提升 如果你需要较高的执行效率，可以选用该解释器，但是本专题中不会使用它。 因为PyPy终究不是正统，所以对很多第三方库的依赖性和兼容性不如CPython。 版本介绍 由于我们平常讲的Python实际上都为CPython，故我们接下来的学习也是围绕CPython（以下简称Python）展开的。 目前Python版本已经更迭到了3.9。 以下是Python的发展历程： 1989年，Guido开始写Python语言的解释器。 1991年，第一个Python解释器诞生，它是用C语言实现的，并能够调用C语言的库文件。 从一出生，Python已经具有了：类，函数，异常处理，包含表和词典在内的核心数据类型，以及模块为基础的拓展系统。 Granddaddy of Python web frameworks, Zope 1 was released in 1999 Python 1.0 - January 1994 增加了 lambda, map, filter and reduce. Python 2.0 - October 16, 2000，加入了内存回收机制，构成了现在Python语言框架的基础 Python 2.4 - November 30, 2004, 同年目前最流行的WEB框架Django诞生 Python 2.5 - September 19, 2006 Python 2.6 - October 1, 2008 Python 2.7 - July 3, 2010 In November 2014, it was announced that Python 2.7 would be supported until 2020, and reaffirmed that there would be no 2.8 release as users were expected to move to Python 3.4+ as soon as possible Python 3.0 - December 3, 2008 Python 3.1 - June 27, 2009 Python 3.2 - February 20, 2011 Python 3.3 - September 29, 2012 Python 3.4 - March 16, 2014 Python 3.5 - September 13, 2015 Python 3.6 - 2016-12 Python 3.7 - 2018 Python 3.8 - 2019 ... 细心的读者会发现，08年时就推出了3.0，2010年反而又推出了2.7？ 这是因为3.0不向下兼容2.0，而很多公司已经基于2.0版本开发出了大量程序，公司已然投入了大量的人财物力，这就导致大家都拒绝升级3.0，无奈官方只能推出2.7过渡版本，之后我们都应该采用3.0解释器开发程序，但为了方便读者维护2.0版本的软件，在遇到两种版本的差异时会专门指出来。 应用方向 Python的应用领域十分广泛，如：人工智能，数据处理，爬虫，金融量化，云计算，WEB开发，自动化运维/测试，游戏开发，网络服务，图像处理等众多领域。 并且国内外很多知名的企业也都在使用Python，如：Youtube、DropBox、BT、Quora（中国知乎）、豆瓣、知乎、Google、Yahoo、FaceBook、NASA、百度、腾讯、汽车之家、美团等等。 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:46 "},"Python/Python快速入门/Python安装.html":{"url":"Python/Python快速入门/Python安装.html","title":"Python安装","keywords":"","body":"本机示例 虽然目前的Python版本已经更迭到了3.9，但是在这里将会使用Python3.6.8来进行开发。 Python3.6系列应该是目前使用最为广泛的一个版本系列，相较于最新版的3.9来说它支持的库更多、兼容性更好。 需要注意的是在类Unix平台中，Python2版本已经自带，所以我们只需安装Python3.6即可。 MAC安装 MAC下有源码安装Source，和界面化.pkg安装，我们选择pkg安装。 第一步：打开Python官网，点我跳转： 第二步，下载对应版本的pkg安装程序： 第三步，一直点击下一步即可： 上述的安装方式会自动将Python安装至以下目录： /Library/Frameworks/Python.framework/Versions/3.6/ 安装完成之后系统会自动的将常用软件ln -s到/usr/local/bin中： $ ls /usr/local/bin/ | grep p.*3 pip3 pip3.6 pydoc3 pydoc3.6 python3 python3-config python3.6 python3.6-config python3.6m python3.6m-config pyvenv-3.6 Linux安装 Linux下有源码安装Source，和免编译安装Binary，我们选择免编译安装。 第一步，下载gcc工具： $ yum install gcc gcc-c++ -y 第二步，下载wget工具： $ yum install wget -y 第三步，下载Python3.6.8的Binary版本： $ cd ~ $ wget https://www.python.org/ftp/python/3.6.8/Python-3.6.8.tgz 第五步，将归档文件tgz解压至当前目录： $ > tar xvf Python-3.6.8.tgz -C ./ $ > ls anaconda-ks.cfg Python-3.6.8 Python-3.6.8.tgz 第六步，进入解压的目录中，进行编译安装（由于CPython基于C语言，而C语言又是编译性语言，故需要进行编译后安装）： $ > cd Python-3.6.8 $ > ./configure --prefix=/usr/local/Python36 $ > make $ > make install 第七步，添加环境变量： $ vim /etc/profile # 写入内容 export PATH=/usr/local/Python36/bin:$PATH $ source /etc/profile 交互测试 安装完成之后，分别在shell中输入python（自带的版本）以及python3，查看是否能进入交互式环境中。 如果能成功进入则按照成功，如果不能请谷歌排查原因。 若想退出交互式环境，输入exit()即可： $ python Python 2.7.10 (default, Feb 22 2019, 21:55:15) [GCC 4.2.1 Compatible Apple LLVM 10.0.1 (clang-1001.0.37.14)] on darwin Type \"help\", \"copyright\", \"credits\" or \"license\" for more information. >>> exit() $ python3 Python 3.6.8 (v3.6.8:3c6b436a57, Dec 24 2018, 02:04:31) [GCC 4.2.1 Compatible Apple LLVM 6.0 (clang-600.0.57)] on darwin Type \"help\", \"copyright\", \"credits\" or \"license\" for more information. >>> exit() Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:46 "},"Python/Python快速入门/pip简单使用.html":{"url":"Python/Python快速入门/pip简单使用.html","title":"pip简单使用","keywords":"","body":"pip工具 pip是Python的包管理工具，该工具提供了对Python第三方包的查找、下载、安装、卸载等功能。 Python 2.7.9+ 或 Python 3.4+ 以上版本都自带pip工具，在安装Python时会一并安装。 如果你安装了两个版本的Python，则对应的pip命令就是pip2或者pip3。 $ ls /usr/local/bin/pip* /usr/local/bin/pip /usr/local/bin/pip2 /usr/local/bin/pip2.7 /usr/local/bin/pip3 /usr/local/bin/pip3.6 Ps：类似于NodeJS的NPM 常用命令 在shell中可使用的pip常用命令如下： 命令 描述 pip --version 显示版本和路径 pip --help 获取帮助 pip install -U pip pip升级 pip install 包名 安装包 pip install --upgrade 包名 升级包 pip uninstall 包名 卸载包 pip search 包名 搜索包 pip list 查看所有已安装的包 pip list -o 查看所有可升级的包 pip升级 使用以下命令进行pip工具进行升级： Windows平台： $ python -m pip install -U pip # python2.x $ python -m pip3 install -U pip # python3.x Linux&Mac平台： $ pip install --upgrade pip # python2.x $ pip3 install --upgrade pip # python3.x 换源配置 pip下载的包默认是从国外源下载，速度较慢，因此可以为其设置为国内源（阿里云）。 下面介绍类Unix平台与Windows平台的换源方式。 Windows 直接在user目录中创建一个pip目录，如：C:\\Users\\username\\pip，新建文件pip.ini，然后填入以下内容： [global] index-url = https://mirrors.aliyun.com/pypi/simple Unix 类Unix平台需要依次运行如下命令： $ cd ~ # 进入用户家目录 $ mkdir .pip # 创建隐藏文件夹 $ vim .pip/pip.conf # 创建pip3的配置文件 然后在配置文件pip.conf中填入以下内容： [global] index-url = https://mirrors.aliyun.com/pypi/simple Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:46 "},"Python/Python快速入门/Python虚拟环境.html":{"url":"Python/Python快速入门/Python虚拟环境.html","title":"Python虚拟环境","keywords":"","body":"虚拟环境 虚拟环境是真实的Python解释器的一份拷贝。 由于真实的Python解释器可能在不断的添加各种第三方库，而我们的项目中又没有用到这些库所以就会造成一个环境的污染，可能会造成打包exe文件后体积过大等问题。 一个项目的环境干净是十分重要的，而虚拟环境就是为了净化项目环境而生的一种措施。 我们在这里使用virtualenv与virtualenvwrapper这两个第三方模块来更加方便的管理我们的虚拟环境。 Windows 需要使用两个第三方模块，在终端中使用pip3命令下载安装： $ pip3 install virtualenv $ pip3 install virtualenvwrapper-win 创建虚拟环境工作目录，新建一个文件夹，从此之后所有的虚拟环境都会存放至该文件夹下： $ D: mkdir .virtualenvs 然后需要配置虚拟环境工作目录： 打开环境变量，在用户变量中新建，变量名为WORKON_HOME，值为虚拟环境的配置路径，即.virtualenvs的路径 打开原本的Python3环境安装目录，找到Scripts文件夹，双击执行其下的virtualenvwrapper.bat Linux&Mac 需要使用两个第三方模块，在shell中使用pip3命令下载安装： $ pip3 install -i https://pypi.douban.com/simple virtualenv $ pip3 install -i https://pypi.douban.com/simple virtualenvwrapper 创建虚拟环境工作目录，新建一个文件夹，从此之后所有的虚拟环境都会存放至该文件夹下： $ mkdir ~/.virtualenvs 配置环境变量，编辑userHome/.bash_profile文件，如果是Mac用户且终端为zsh，则配置userHome/.zshrc文件，新增以下内容： # Setting virtual environment save path # 填入你的虚拟环境存放目录 export WORKON_HOME=\"~/.virtualenvs\" # Setting virtual environment copy python path # 填入你的真实Python3解释器路径，用于虚拟环境的拷贝 export VIRTUALENVWRAPPER_PYTHON=/Library/Frameworks/Python.framework/Versions/3.6/bin/python3.6 # Setting virtualenvwrapper.sh run path # 填入virtualenvwrapper.sh的脚本路径 source /Library/Frameworks/Python.framework/Versions/3.6/bin/virtualenvwrapper.sh 最后刷新一下该文件的配置： $ source ~/.bash_profile 命令概览 shell中可指定的命令如下： 命令 描述 workon 列出所有虚拟环境 mkvirtualenv -p python3 虚拟环境名字 创建新的虚拟环境 rmvirtualenv 虚拟环境名字 删除指定的虚拟环境 workon 虚拟环境名字 使用指定的虚拟环境 示例演示，创建一个LearnPython的虚拟环境： $ mkvirtualenv -p python3 LearnPython $ workon 现在你会发现，shell的提示符改变了： (LearnPython) YunYadeMacBook-Pro:~ yunya$ Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:46 "},"Python/Python快速入门/Python常用工具.html":{"url":"Python/Python快速入门/Python常用工具.html","title":"Python常用工具","keywords":"","body":"运行方式 REPL交互式 REPL名为交互式解释器（Read Eval Print Loop），提供了一个CLI(command-line interface:命令行界面)下读取值、求值、输出值、循环代码的环境。 这种交互式的方式会经常用到，适用于快速的进行一些功能测试，如函数传参、求值测试等。 现在让我们以REPL交互式来运行第一条Python代码，在shell中进行执行： $ python3 >>> print(\"hello world\") hello world >>> 如果要退出REPL环境，则使用exit()即可。 脚本调用式 外部调用 在一个文件中，书写好Python代码后进行调用的方式被称为脚本调用式。 也是非常常用的一种方式，通常文件后缀名以py结尾，标识这是一个Python脚本文件。 使用Python调用脚本时，其实并不关心文件后缀名是什么，后缀名更多的作用是给使用者看的，便于区分不同类型的文件 $ echo \"print('hello world')\" > helloWorld.py $ python3 helloWorld.py hello world 在此示例中我们使用Python3的解释器在外部对其进行调用，并执行了其中的代码打印了hello world。 内部调用 除开外部调用，我们也可以在脚本内部指定Python解释器，并通过./进行代码执行，对上述文件内容进行修改： #!/usr/bin/env python3 print('hello world') 修改完成并保存，再修改文件的执行权限： $ chmod 775 helloWorld.py 直接使用./进行代码执行： $ ./helloWorld.py hello world 使用内部调用需要注意：指定Python解释器的语句一定要放在文件头部，因此该代码也被称为头文件代码。 常见的头文件代码除开指定Python解释器以外，还有指定解释器解码格式、声明作者和日期等，如下所示： #!/usr/bin/env python3 # -*- coding:utf-8 -*- # author: YunYa # date: 2017-01-28 头文件代码调用说明：env是类Unix平台的环境变量别称，当我们在头文件代码中指定/usr/bin/env python3的时候，它内部会运行env | grep python3，找到python3解释器，并对文件进行执行，前提是该文件必须具有可执行权限。 $ env | grep python3 VIRTUALENVWRAPPER_PYTHON=/Library/Frameworks/Python.framework/Versions/3.6/bin/python3.6 执行过程 一个Python程序被解释器解释并执行，可粗略的分为三个步骤： 启动Python解释器 Python解释器发起系统调用，将脚本内容载入内存，此时并不会做任何处理 Python解释器开始识别Python语法，解释并执行内存中存储的脚本文件内容 IDE介绍 IDE简介 IDE的全称是Integrated Development Environment，即集成开发环境。 它是一种辅助程序开发人员开发软件的应用软件，在开发工具内部就可以辅助编写源代码文本、并编译打包成为可用的程序，有些甚至可以设计图形接口。 如果单纯的touch出一个文本，并在其内部书写代码是很容易出现问题的。 没有语法高亮，这意味着某个字符少打了、某个单词拼错了都不能被及时发现，并且这样学习对新手难度极大 没有debug功能，当业务逻辑越来越复杂时，程序不可避免的会出现一些bug，此时如果没有debug程序来检测出现问题的原因，整个排查的过程将变的异常艰难 而使用IDE开发则可以完全避免这些问题。 Python IDLE Python自带了一款类似的工具，名为Python IDLE，是Python的集成开发和学习环境。 官方文档：https://docs.python.org/3/library/idle.html 它自带了2种模式，一种是REPL交互模式，一种是脚本调用模式。 当你打开它后默认会进入REPL交互模式，此时只需要新建一个文件即可开始编写我们的代码。 CTRL+N：新建文件 CTRL+S：保存文件 F5：运行程序 可以发现，当我们想使用print()功能时，它会提示该功能需要哪些参数： 当编写完代码后，即可使用F5来进行文件的保存与运行，如下所示： IDLE适用于刚入门起步学习Python的同学，但对于大的项目构建来说还是十分的不方便。 推荐指数：⭐️⭐️⭐️ PyCharm PyCharm是由JetBrains公司开发，也是最受欢迎的Python IDE工具。 官方网站：https://www.jetbrains.com/pycharm/ 优点是功能强大，你能想到的不能想到的它都给你提供了。 缺点是收费，并且软件本身比较臃肿，但是比起它的优秀来说这些缺点可以忽略不计。 推荐指数：⭐️⭐️⭐️⭐️⭐️ VsCode VsCode是由Microsoft Corporation开发，是近年来最火的一款轻量级编辑器。 官方网站：https://code.visualstudio.com/ 优点是支持多语言，Golang、C、Python等手到擒来，此外它是完全免费的。 缺点是配置比较繁琐，对新手不太友好。 推荐指数：⭐️⭐️⭐️⭐️ 个人使用 我自己平常写一些小的脚本，会首选VsCode，若是要搭建一些比较大型的项目，则会选择PyCharm。 在这里并没有详细指出每种工具的安装，因为互联网上类似的教程太多了。 推荐在初次接触Python时，建议统一使用Python IDLE，因为PyCharm本身会对Python许多地方做出优化，而恰好这些优化对新手并不友好。 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:46 "},"Python/Python快速入门/PEP8规范说明.html":{"url":"Python/Python快速入门/PEP8规范说明.html","title":"PEP8规范说明","keywords":"","body":"PEP8规范 每种语言都有其一种特定的书写规范，而PEP8规范则是Python中的书写规范。 以下的内容对于初学者来说可能会显得有些超纲，但是我为什么要将它放在第一章呢？就是为了警示你书写规范其实很重要。 尽管现在你可能看不懂，但是没有关系，你看得懂的时候就一定要去学会遵守它。 Ps：其实我自己就是一个不太遵守规范的家伙... 缩进与续行 每一级缩进使用4个空格，而不是使用table def main(): print(\"hello,world\") # --- def main(): print(\"hello,world\") 续行应该与其包裹元素对齐，要么使用圆括号、方括号和花括号内的隐式行连接来垂直对齐，要么使用挂行缩进对齐 def main( param1, param2, param3, param4 ): print(\"hello,world\") # --- def main(param1, param2, param3, param4 ): print(\"hello,world\") 分割与宽度 每行最大的字符数不可超过79，文档字符或者注释每行不可超过72 def main(): # this is a test function ... # this is a test function ... # this is a test function ... print(\"hello,world\") # --- def main(): # this is a test function ... this is a test function ... this is a test function ... print(\"hello,world\") 顶层函数和类的定义，前后用两个空行隔开，类里的方法定义用一个空行隔开 模块的导入 导入不同模块，应当进行分行 导入模块的位置应当总是位于文件顶部，且在头文件代码之后 标准库导入放最前、相关第三方库导入放其次，而后是本地库导入 每一组导入语句之间加入空行分割，以区分是内置库、三方库、还是自建库 推荐使用绝对导入 import sys import os # --- import sys, os 注释 在更改代码之前，推荐先更改注释 释应该是完整的句子。如果一个注释是一个短语或句子，它的第一个单词应该大写，除非它是以小写字母开头的标识符(永远不要改变标识符的大小写！) 如果注释很短，结尾的句号可以省略。块注释一般由完整句子的一个或多个段落组成，并且每句话结束有个句号 在句尾结束的时候应该使用两个空格 当用英文书写时，遵循Strunk and White （译注：《Strunk and White, The Elements of Style》）的书写风格 在非英语国家的Python程序员，请使用英文写注释，除非你120%的确信你的代码不会被使用其他语言的人阅读 块注释通常适用于跟随它们的某些（或全部）代码，并缩进到与代码相同的级别。块注释的每一行开头使用一个#和一个空格（除非块注释内部缩进文本）。 块注释内部的段落通过只有一个#的空行分隔 有节制地使用行内注释 行内注释是与代码语句同行的注释。行内注释和代码至少要有两个空格分隔。注释由#和一个空格开始 文档字符串 要为所有的公共模块，函数，类以及方法编写文档说明 非公共的方法没有必要，但是应该有一个描述方法具体作用的注释。这个注释应该在def那一行之后 PEP 257描述了写出好的文档说明相关的约定。特别需要注意的是，多行文档说明使用的结尾三引号应该自成一行，例如： \"\"\"Return a foobang Optional plotz says to frobnicate the bizbaz first. \"\"\" 对于单行的文档说明，尾部的三引号应该和文档在同一行 命名规范 应该避免的名字 永远不要使用字母‘l’（小写的L），‘O’（大写的O），或者‘I’（大写的I）作为单字符变量名 在有些字体里，这些字符无法和数字0和1区分，如果想用‘l’，用‘L’代替 类名 类名一般使用首字母大写的约定 在接口被文档化并且主要被用于调用的情况下，可以使用函数的命名风格代替 注意，对于内置的变量命名有一个单独的约定：大部分内置变量是单个单词（或者两个单词连接在一起），首字母大写的命名法只用于异常名或者内部的常量 函数名 函数名应该小写，如果想提高可读性可以用下划线分隔 大小写混合仅在为了兼容原来主要以大小写混合风格的情况下使用（比如 threading.py），保持向后兼容性 函数和方法参数 始终要将 self 作为实例方法的的第一个参数 始终要将 cls 作为类静态方法的第一个参数 如果函数的参数名和已有的关键词冲突，在最后加单一下划线比缩写或随意拼写更好。因此 class_ 比 clss 更好（也许最好用同义词来避免这种冲突） 编程建议 代码应该用不损害其他Python实现的方式去编写（PyPy，Jython，IronPython，Cython，Psyco 等） 比如，不要依赖于在CPython中高效的内置字符连接语句 a += b 或者 a = a + b 这种优化甚至在CPython中都是脆弱的（它只适用于某些类型）并且没有出现在不使用引用计数的实现中。在性能要求比较高的库中，可以用“”.join() 代替 这可以确保字符关联在不同的实现中都可以以线性时间发生 和像None这样的单例对象进行比较的时候应该始终用 is 或者 is not，永远不要用等号运算符 另外，如果你在写 if x 的时候，请注意你是否表达的意思是 if x is not None。举个例子，当测试一个默认值为None的变量或者参数是否被设置为其他值的时候。这个其他值应该是在上下文中能成为bool类型false的值 使用 is not 运算符，而不是 not … is 虽然这两种表达式在功能上完全相同，但前者更易于阅读，所以优先考虑 推荐： if foo is not None 不推荐： if not foo is None: Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:46 "},"Python/Python基础知识/summary.html":{"url":"Python/Python基础知识/summary.html","title":"Python基础知识","keywords":"","body":" 代码与注释 变量与常量 整形与浮点型 列表类型 元组类型 字符串类型 字典类型 集合类型 布尔类型 单例None 内存管理 深浅拷贝 输入与输出 运算符相关 分支结构 流程控制 推导式 字符编码 文件操作 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:46 "},"Python/Python基础知识/代码与注释.html":{"url":"Python/Python基础知识/代码与注释.html","title":"代码与注释","keywords":"","body":"代码注释 学习任何一门语言首要的就是学习它的注释。注释就是说你的脚本程序在运行过程中不会被解释器解释与执行的一部分，它的功能主要是给人阅读方便代码的后期维护。 在Python中（Python2和Python3均可），主要有3种注释方式，其中单行注释1种，多行注释2种。 #号注释 单个#号注释是属于单行注释，如下示例： # This is a single line comment 要注意的是，我们一般会在#后面添加上一个空格，如果#号前面有代码，一般会间隔两个空格。 print(\"HELLO,WORLD\") # 它将打印HELLO,WORLD -- - 三单引号注释 ''' '''三个单引号可以进行跨行注释，如下示例： def func(): ''' 用于进行一个功能的描述与说明 ''' pass 三双引号注释 \"\"\" \"\"\"三个双引号的注释与三个单引号的注释语义相同，基本上在能够使用三个单引号的地方都可以使用三个双引号： def func(): \"\"\" 用于进行一个功能的描述与说明 \"\"\" pass Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:46 "},"Python/Python基础知识/变量与常量.html":{"url":"Python/Python基础知识/变量与常量.html","title":"变量与常量","keywords":"","body":"标识符与对象 在Python中有一个核心的概念，叫做一切皆对象。 我们定义的数据、资源等皆可称之为对象，对象均存放在内存中。 而如果要使用这个对象，则必须通过标识符与对象进行绑定，说的通俗一点就是，为对象取一个名字。 一般来讲，一次绑定分为三部分操作： 创建资源对象（值） 创建标识符（名字） 建立绑定关系（赋值符号） 如下所示： 整个绑定的过程，被称为常量\\变量赋值或者对象定义，用=号将标识符与对象进行链接。 如下所示，我们用多个对象表示一个人的信息： name = \"yunya\" age = 18 height = 1.92 print(\"name : %s\\nage : %s\\nheight : %s\\n\" % (name, age, height)) # name : yunya # age : 18 # height : 1.92 先定义后使用 对象必须先定义，后使用，如果未定义就使用则会抛出异常。 print(\"My name is :\", name) name = \"yunya\" # NameError: name 'name' is not defined 命名风格 下面介绍几种常用的标识符命名方式： Camel-Case之小驼峰式：个人比较喜欢的风格，但是Python中并不建议使用小驼峰。 单词开头的字母小写，而后每个单词的分割首字母采用大写形式： userAge = 18 Camel-Case之大驼峰式：大驼峰式在Python中比较常见，一般定义类名时使用，不要滥用大驼峰。 每个单词都首字母都大写 UserInfo = {} 匈牙利类型标记法：前面的小写字母为变量类型，如，i代表int类型、s代表str类型： iUserAge = 18 蛇形命名法：小写+下划线，是Python中更推荐使用的标识符命名方式： user_age = 18 命名规范 标识符的命名需要遵从以下规范： 标识符应当见名知意 标识符由数字，字母，下划线组成。并且开头不能为数字 标识符不能使用Python中的关键字 错误的示范： $name = 'yunya' # 具有特殊字符 1year = 365 # 数字开头 *_size = 1024 # 具有特殊字符 and = 123 # 使用了关键字 年级 = 3 # 强烈不建议使用中文（占用内存大） (color) = 'red' # 虽然这种命名方式可行但是也极为不推荐 正确的示范： name = 'yunya' __age = 18 # Python中双下划线开头的标识符一般有隐私的这种说法，因此一般不建议使用 page_1 = 'home page' 同时，个人十分不推荐在标识符中加上任何的数字，这样的做法显得很莽撞。如item1，item2等... 绑定映射 Python中所有的数据均被称之为对象（object），对象存放至堆（heap）区内存中。 在对象存入堆区内存时，会为对象开辟一块内存空间并保存。 而在栈（stack）区内存中，则存放对象的引用（reference），即对象在堆区内存中的地址。 当一个对象被赋值给一个标识符后，在栈区内存中会创建一种映射（mapping）关系，此时标识符和对象就建立了联系，并且标识符本身也会被存放至栈区内存中。 name = \"yunya\" age = 18 height = 1.92 盒子声明 在很多其他的编程语言中，声明一个数据的过程可以被称作盒子声明，当遇到赋值操作时，它会进行如下的流程： 创建一个具体的盒子（开辟内存，创建盒子，并且为盒子打上标识） 放入具体的数据（将对象放入盒子中） 而在Python中，则没有盒子声明这种说法，我更喜欢将它称作贴纸声明，当遇到赋值操作时，它会进行如下的流程： 先创建一个对象（自动的在遇到=符号时，开辟内存并创建对象，如果该对象已存在，则进行引用） 将=符号左侧的标识符与对象绑定（像贴纸一样） 两者对比一下： 其他编程语言中总是先进行标识符盒子的初始化，再之后将数据对象放入盒子中 Python中总是先创建对象，并且再将标识符与对象做绑定 如下图所示： 引用传递 Python中所有的标识符与对象的绑定均为引用，不论是函数传参，单纯赋值等，标识符都与对象的内存地址做绑定，而不和对象本身的值做绑定。 Python中一个对象可以被多个标识符所引用，而一个标识符仅能引用一个对象。 你可以理解为Python中所有数据类型均为引用类型，没有值类型。 如下所示，我们将声明2个不同的标识符，标识符都指向了同一个int对象： oldAge = 18 newAge = oldAge print(id(oldAge)) print(id(newAge)) # 4550527568 # 4550527568 如下图所示： 在Golang中，如果进行上面的操作，因为盒子声明的缘故新的标识符newAge会创建出一片新的内存空间，并且将oldAge的值进行一次拷贝后存放至新内存空间中： package main import \"fmt\" func main() { var oldAge int = 18 var newAge int = oldAge fmt.Println(oldAge, &oldAge) fmt.Println(newAge, &newAge) } // 18 0xc42008e168 // 18 0xc42008e190 如下图所示： 变量 变量指的是该标识符所绑定的对象允许在运行时刻发生变化，是用来记录事物变化状态的一种东西。 举个例子： 进入游戏：等级为0 一天之后：等级为10 一月之后：等级为100 标识符（等级）与表示等级的对象所绑定，并且该等级在不断的变化，那么这个标识符可以称为变量标识符，与变量标识符绑定的对象是可以随意改变的： # 进入游戏 level = 0 # 一天后 level = 10 # 一月后 level = 100 # 现在的等级 print(level) # 100 变量命名 变量标识符的命名一般以蛇形命名法和小驼峰命名法为准。 不可使用大驼峰式命名法，同时全大写命名法也不要进行使用。 匿名变量 如果一个变量标识符为_，则代表该变量为匿名变量。 匿名变量的作用是当做一个垃圾桶，对于一些不会用到的对象可以命名为_，仅做到一个占位的作用，这在解构赋值中经常会被使用到。 其实官方没有匿名变量的定义，这也是Python社区中一条不成文的规定，因为实在是懒得对一个不用的对象想名字，干脆就用_进行命名。 常量 常量指的是该标识符所绑定的对象不允许在运行时刻发生变化，表示一个恒定的数据。 举个例子： 圆周率PI是恒定的，不能因为程序的运行而改变 人的性别是恒定的，不能因为程序的运行而改变 很遗憾，在应用领域来说Python并未提供常量的定义，但是在Python社区中有一个不成文的规定。 如果一个标识符所有字母都是大写的话，则认为该标识符是常量标识符： PI = 3.1415926535897 SEX = \"男\" 常量池 上面说过，尽管在应用领域中Python并未提供常量的定义，但是在内部实现中处处可见常量的影子。 如小整数常量池就是一个很好的例子。 在其他的编程语言，类似Golang、JavaScript中，常量定义的关键词为const，很快你也会在Python中见到这个单词。 相关方法 id() 使用id()函数可拿到标识符所对应对象在堆区内存中的地址号。 name = \"yunya\" print(id(name)) # 2933298725640 type() 使用type()函数可获取到该标识符对应对象的数据类型，返回类本身。 name = \"yunya\" print(type(name)) # del 使用del跟上标识符名字，将对该标识符所关联的对象进行解绑操作，同时也会取消该标识符的定义，将其从栈区内存中抹去。 name = \"yunya\" del name print(name) # NameError: name 'name' is not defined Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:46 "},"Python/Python基础知识/整形与浮点型.html":{"url":"Python/Python基础知识/整形与浮点型.html","title":"整形与浮点型","keywords":"","body":"整形 整形概述 Python中对于整形的划分非常简单，仅仅只有一个int类型。 整形是不可变类型，即对象本身的属性不会根据外部变化而变化 整形属于原子类型，即不可被分割 基本声明 以下是使用类实例化的形式进行对象声明： age = int(12) print(\"value : %r\\ntype : %r\" % (age, type(age))) # value : 12 # type : 也可以选择使用更方便的字面量形式进行对象声明： age = 12 print(\"value : %r\\ntype : %r\" % (age, type(age))) # value : 12 # type : 类型转换 整形可以与布尔型，浮点型，字符串等做转换，使用对应的工厂函数即可： num = 1 strNum = str(num) boolNum = bool(num) floatNum = float(num) print(\"value : %r\\ntype : %r\" % (strNum, type(strNum))) print(\"value : %r\\ntype : %r\" % (boolNum, type(boolNum))) print(\"value : %r\\ntype : %r\" % (floatNum, type(floatNum))) # value : '1' # type : # value : True # type : # value : 1.0 # type : 进制转换 使用以下三个内置函数，可进行进制转换： 函数名 描述 bin() 十进制转二进制 oct() 十进制转八进制 hex() 十进制转十六进制 示例如下： num = 100 print(bin(num)) print(oct(num)) print(hex(num)) # 0b1100100 # 0o144 # 0x64 如果想二进制、八进制、十六进制转换十进制，则可通过指定int()的第二参数base实现，如下所示： print(int(\"0b1100100\", base=2)) print(int(\"0o144\", base=8)) print(int(\"0x64\", base=16)) # 100 # 100 # 100 Unicode转换 使用以下两个内置函数，可进行整形与Unicode互转： 函数名 描述 chr() 传入0-1114111之间的整形，将其转换为Unicode字符 ord() 传入单个Unicode字符，将其转换为Unicode字符十进制整形 示例如下： >>> chr(65) 'A' >>> ord(\"A\") 65 long类型 在Python2中，如果整形后面加上L则代表长整型，在Python3中取消了这种设定。 >>> num = 100L >>> type(num) 浮点型 浮点型概述 Python中对于浮点型的划分非常简单，仅仅只有一个float类型。 浮点形是不可变类型，即对象本身的属性不会根据外部变化而变化 浮点形属于原子类型，即不可被分割 基本声明 以下是使用类实例化的形式进行声明： f = float(3.15) print(\"value : %r\\ntype : %r\" % (f, type(f))) # value : 3.15 # type : 也可以选择使用更方便的字面量形式： f = 3.15 print(\"value : %r\\ntype : %r\" % (f, type(f))) # value : 3.15 # type : 类型转换 浮点形可以与布尔型、整型、字符串等做转换，使用对应的工厂函数即可： num = 1.9 strNum = str(num) boolNum = bool(num) intNum = int(num) print(\"value : %r\\ntype : %r\" % (strNum, type(strNum))) print(\"value : %r\\ntype : %r\" % (boolNum, type(boolNum))) print(\"value : %r\\ntype : %r\" % (intNum, type(intNum))) # value : '1.9' # type : # value : True # type : # value : 1 # type : 四则运算 整形与浮点型均支持四则运算。 但是需要注意的是当整形与浮点型进行运算后，所得到的结果必然是浮点型： print(100 * 1.0) # 100.0 同时，整形也可以与字符串进行乘法运算： print(\"hello\" * 3) # hellohellohello 他两都支持与布尔型进行运算，布尔型的本质就是1和0，这里不再例举。 _的形式 在Python3中提供了对数字的_分割表现形式。 旨在更加方便阅读大数字： >>> a = 100_00 >>> a 10000 >>> b = 100_00.1 >>> b 10000.1 强类型 由于Python是强类型语言，故不会出现隐式转换的问题（Python2中是允许字符串与数字做比较的，且数字永远小于字符串）。 如下，使用整形与字符串做对比，返回的结果永远是False。 print(\"100\" == 100) # False 但是整形可以和浮点型做比较，因为它们同属于数值类型： print(100.00 == 100) # True 他两都支持与布尔型进行比较，布尔型的本质就是1和0，这里不再例举。 小整数池 Python解释器觉得有一些整数会经常被使用（-5到255之间），故当脚本程序运行前就将这些数字写入堆区内存中。 当用户定义int对象且使用到其中的数值时会直接将该数值的内存地址引用到存在于栈内存的变量标识符上，这样做极大节省了内存空间。 如：一个程序中使用了100000次1这个数值，那么如果没有Python的这个机制则会开辟出100000个内存空间用来存放相同的数值。 这么做显然极大的浪费了内存。 故Python的这种机制是十分高效且合理的，并且它的名字叫做小整数常量池，或简称为小整数池（范围：-5,255）： int_1 = 1 int_2 = 1 print(id(int_1)) # 1558801440 print(id(int_2)) # 1558801440 # 超出小整数池范围 int_3 = -6 int_4 = -6 print(id(int_3)) # 2264143854288 print(id(int_4)) # 2264143854448 绝对引用 数值拥有绝对引用的特性，无论是深拷贝还是浅拷贝，都不会获得其副本，而是直接对源对象进行引用： >>> import copy >>> oldN = 1_0000 >>> id(oldN) 4373791728 >>> n1 = copy.copy(oldN) >>> id(n1) 4373791728 >>> n2 = copy.deepcopy(oldN) >>> id(n2) 4373791728 声明速率 时间对比 对于所有的Python内置数据模型来说，字面量形式的对象声明永远要比类实例化的形式对象声明速度要快。 时间差大约3倍或者更多，我们可以做一个小实验来观察，使用timeit模块检测2者时间差： $ python3 -m timeit -n 1000000 -r 5 -v \"int(1)\" raw times: 0.138 0.136 0.135 0.152 0.16 1000000 loops, best of 5: 0.135 usec per loop $ python3 -m timeit -n 1000000 -r 5 -v \"1\" raw times: 0.00974 0.00961 0.0107 0.0107 0.00991 1000000 loops, best of 5: 0.00961 usec per loop ❶ -n 语句执行多少次 ❷ -r 重复计时器的次数，默认为5 可以看类实例化声明1百万次int类型时长为0.135秒。 而字面量形式声明1百万次int类型时长为0.00961秒。 整个差距居然有14倍！当然，如果是一些复杂的类型声明，这个差距会变小。 底层探究 为什么会出现这样的情况，可以使用dis模块来探索，该模块会通过反汇编来查看到语句执行情况的字节码。 $ echo \"int(1)\" > demo.py $ python3 -m dis demo.py 1 0 LOAD_NAME 0 (int) 2 LOAD_CONST 0 (1) 4 CALL_FUNCTION 1 6 POP_TOP 8 LOAD_CONST 1 (None) 10 RETURN_VALUE $ echo \"1\" > demo.py $ python3 -m dis demo.py 1 0 LOAD_CONST 0 (None) 2 RETURN_VALUE 使用类实例化声明对象时，必定会调用到底层函数__init__()，而调用函数的过程会发起系统调用栈的进出栈操作，故更加耗时。 此外，我们也从上面的LOAD_CONST可以观察出，int类型小整数1确实会从小整数常量池中加载数据。 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:46 "},"Python/Python基础知识/列表类型.html":{"url":"Python/Python基础知识/列表类型.html","title":"列表类型","keywords":"","body":"列表 Python中的列表（list）是最常用的数据类型之一。 Python中的列表可以存储任意类型的数据，这与其他语言中的数组（array）不同。 被存入列表中的内容可称之为元素（element）或者数据项（data item）亦或是值（value）。 虽然Python列表支持存储任意类型的数据项，但不建议这么做，事实上这么做的概率也很低。 列表特性 列表特性如下： 列表属于线性容器序列 列表属于可变类型，即对象本身的属性会根据外部变化而变化，例如长度 列表底层由顺序存储组成，而顺序存储是线性结构的一种 基本声明 以下是使用类实例化的形式进行对象声明： lst = list((1, 2, 3, 4, 5)) print(\"value : %r\\ntype : %r\" % (lst, type(lst))) # value : [1, 2, 3, 4, 5] # type : 也可以选择使用更方便的字面量形式进行对象声明，利用[]对数据项进行包裹，并且使用逗号将数据项之间进行分割： lst = [1, 2, 3, 4, 5] print(\"value : %r\\ntype : %r\" % (lst, type(lst))) # value : [1, 2, 3, 4, 5] # type : 多维列表 当一个列表中嵌套另一个列表，该列表就可以称为多维列表。 如下，定义一个2维列表： lst = [1, 2, [\"三\",\"四\"]] print(\"value : %r\\ntype : %r\" % (lst, type(lst))) # value : [1, 2, ['三', '四']] # type : 续行操作 在Python中，列表中的数据项如果过多，可能会导致整个列表太长，太长的列表是不符合PEP8规范的。 每行最大的字符数不可超过79，文档字符或者注释每行不可超过72 Python虽然提供了续行符\\，但是在列表中可以忽略续行符，如下所示： lst = [ 1, 2, 3, 4, 5 ] print(\"value : %r\\ntype : %r\" % (lst, type(lst))) # value : [1, 2, 3, 4, 5] # type : 类型转换 列表支持与布尔型、字符串、元组、以及集合类型进行类型转换： lst = [1, 2, 3] bLi = bool(lst) strLi = str(lst) tupLi = tuple(lst) setLi = set(lst) print(\"value : %r\\ntype : %r\" % (bLi, type(bLi))) print(\"value : %r\\ntype : %r\" % (strLi, type(strLi))) print(\"value : %r\\ntype : %r\" % (tupLi, type(tupLi))) print(\"value : %r\\ntype : %r\" % (setLi, type(setLi))) # value : True # type : # value : '[1, 2, 3]' # type : # value : (1, 2, 3) # type : # value : {1, 2, 3} # type : 如果一个2维列表遵循一定的规律，那么也可以将其转换为字典类型： lst = [[\"k1\", \"v1\"], [\"k2\", \"v2\"], [\"k3\", \"v3\"]] dictList = dict(lst) print(\"value : %r\\ntype : %r\" % (dictList, type(dictList))) # value : {'k1': 'v1', 'k2': 'v2', 'k3': 'v3'} # type : 四则运算 列表支持与元组，列表进行加法运算： +：合并2个列表并生成新列表： lst1 = [1, 2, 3] lst2 = [4, 5, 6] newLi = lst1 + lst2 print(newLi) # [1, 2, 3, 4, 5, 6] +=：扩展已有列表，相当于extend()方法： oldLi = [1, 2, 3] newLi = [4, 5, 6] oldLi += newLi print(oldLi) # [1, 2, 3, 4, 5, 6] 列表支持与数字进行乘法运算： *：生成一个重复旧列表数据项的新列表： oldLi = [1, 2, 3] newLi = oldLi * 3 print(newLi) # [1, 2, 3, 1, 2, 3, 1, 2, 3] *=：扩展已有列表，将已有列表的数据项进行重复添加： oldLi = [1, 2, 3] oldLi *= 3 print(oldLi) # [1, 2, 3, 1, 2, 3, 1, 2, 3] 索引切片 索引的概念 列表底层是以一种连续的顺序结构存储数据项，故可以使用索引（index）对数据项进行获取、删除、截取、替换等操作。 ----------------------------| | A | B | C | D | E | F | G | ----------------------------| | 0 | 1 | 2 | 3 | 4 | 5 | 6 | |-7 |-6 |-5 |-4 |-3 |-2 |-1 | 正向索引都是从0开始，负向索引都是从-1开始。 enumerate() 我们以一个内置函数enumerate()来举例，该函数返回一个迭代器，将其转换为list()后可以查看数据项以及正向索引： lst = [\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\"] print(list(enumerate(lst))) # [(0, 'A'), (1, 'B'), (2, 'C'), (3, 'D'), (4, 'E'), (5, 'F'), (6, 'G')] 更多的关于enumerate()函数的妙用，将会放在循环章节中进行探讨。 slice() slice()函数有三个参数： start：索引开始的位置 stop：索引结束的位置 step：步长间距，默认为1 如果为正数代表正取，如果为负数代表倒取 如果为1代表连续取，如果为2代表隔一个取一个，以此类推 使用方法如下示例，先使用slice()确定截取数据项的范围，然后再使用列表的[]操作形式取出指定范围的数据项。 注意：所有的切片都是顾头不顾尾： lst = [\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\"] # 取出A # 释义：从0开始取，取1个，步长为0 s = slice(0, 1, None) print(lst[s]) # ['A'] [::]形式 使用slice()函数会比较繁琐，直接使用[::]形式进行切片会比较简单。 签名如下： [start:stop:step] 参数描述和slice()相同，当某一参数不设置时可省略前面的参数。 增删改截操作演示： >>> # 获取第2个数据项 >>> lst = [\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\"] >>> lst[1] 'B' >>> # 删除第3个数据项 >>> del lst[2] >>> lst ['A', 'B', 'D', 'E', 'F', 'G'] >>> # 从第1个数据项开始向后替换2个数据项，替换内容为123 >>> lst[0:3] = 1,2,3 >>> lst [1, 2, 3, 'E', 'F', 'G'] >>> # 从第1个数据项开始获取2个数据项 >>> lst[0:3] [1, 2, 3] >>> # 试图访问一个超出索引之外的数据项，将引发异常 >>> lst[100] IndexError: lstst index out of range 需要注意的是，如果使用[:]则会创建一个新的列表，再将原有列表中的数据项全部引用至新的列表中，类似于浅拷贝的概念。 如下所示： lst1 = [\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\"] lst2 = lst1[:] print(\"value : %r\\naddr : %r\" % (lst1, id(lst1))) print(\"value : %r\\naddr : %r\" % (lst2, id(lst2))) # value : ['A', 'B', 'C', 'D', 'E', 'F', 'G'] # addr : 4307969608 # value : ['A', 'B', 'C', 'D', 'E', 'F', 'G'] # addr : 4308270792 正向切片 正向切片即使用正向索引进行切片，索引从0处开始进行切片。 如下示例： >>> lst = [\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\"] >>> lst[0:3] ['A', 'B', 'C'] 反向切片 反向切片即使用反向索引进行切片，索引从-1处开始进行切片。 如下示例： >>> lst = [\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\"] >>> lst[-3:] ['E', 'F', 'G'] 多维切片 列表是支持多维切片的，如下示例，拿出2维列表中的数据项A： >>> lst = [1, 2, [\"A\", \"B\"]] >>> lst[-1][0] 'A' 高级切片 反向和正向切片可以混合使用，下面是一些高级切片的用法： >>> lst = [\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\"] >>> lst[:] ❶ ['A', 'B', 'C', 'D', 'E', 'F', 'G'] >>> lst[2:4] ❷ ['C', 'D'] >>> lst[::2] ❸ ['A', 'C', 'E', 'G'] >>> lst[::-2] ['G', 'E', 'C', 'A'] ❹ >>> lst[::-1] ❺ ['G', 'F', 'E', 'D', 'C', 'B', 'A'] >>> lst[:-5:-2] ❻ ['G', 'E'] >>> lst[0::-1] ❼ ['A'] >>> lst[5::-2] ❽ ['F', 'D', 'B'] 如何一眼读懂高级切片，通过以下步骤判定： 第一步先观察step，是负数还是正数，负数代表倒着取 第二步观察start，确定切片的开始位置 第三步观察stop，确定切片的结束位置 上述示例演示的说明，带*的是比较重要的方式。 ❶：列表的[:]操作是创建一个新的列表，再将原有列表中的数据项全部引用一次至新的列表* ❷：步长为空，代表正着取，从第2号索引位置的数据项开始，到第4号索引位置的数据项结束，根据顾头不顾尾原则，取2，3号索引的数据项* ❸：步长为2，代表正着取，隔一个取一个，即从0号索引位置的数据项开始，每次往后数到2的时候再取* ❹：步长为-2，代表倒着取，隔一个取一个，即从-1号索引位置的数据项开始，每次向前数到2的时候再取* ❺：步长为-1，代表倒着取，即从-1号索引位置的数据项开始，取到索引0号位置结束* ❻：步长为-2，代表倒着取，隔一个位置取一个，取到-5索引位置结束，根据顾头不顾尾原则，不取-5索引位置的数据项 ❼：步长为-1，代表倒着取，开始位置为0，结束位置未标记，则取1个 ❽：步长为-2，代表倒着取，隔一个取一个，开始位置为5号索引，则从第5号索引开始向前取 解构方法 *语法 使用*语法可对列表进行解构，将列表中的数据项全部提取出来： lst = [1, 2, 3] print(*lst) # 1 2 3 我们可以利用*语法的特性，来达到两个列表进行合并产生新列表的效果，类似于+： lst1 = [1, 2, 3] lst2 = [4, 5, 6] result = [*lst1, *lst2] print(result) # [1, 2, 3, 4, 5, 6] 解构赋值 如果一个列表中的数据项需要赋值到变量中，可使用解构赋值，需要注意的是变量接收位置与列表中的数据项位置需要一一对应： lst = [\"A\", \"B\"] item1, item2 = lst print(item1, item2) # A B 我们只想取出列表中前2个数据项时，可使用*语法将剩下的数据项全部打包到一个变量中： lst = [\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\"] item1, item2, *otherItems = lst print(item1, item2) print(otherItems) # A B # ['C', 'D', 'E', 'F', 'G'] 如果只想取第1个后和最后2个，中间的都不想要怎么办？也可以通过*语法： lst = [\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\"] itemFirst, *_, itemLast1, itemLast2 = lst # ❶ print(itemFirst, itemLast1, itemLast2) print(_) # A F G # ['B', 'C', 'D', 'E'] ❶：_为匿名变量，参见变量与常量一章节中的释义 常用方法 方法一览 常用的list方法一览表： 方法名 返回值 描述 append() None 将数据项添加至列表的末尾 extend() None 通过附加来自可迭代对象的数据项来扩展列表 insert() None 在索引之前插入对象 pop() item 删除并返回索引处的项目（默认为-1）。如果列表为空或索引超出范围，则引发IndexError copy() list 返回L的浅拷贝 remove() None 删除列表中第一次出现的数据项。如果不存在该数据项，则引发ValueError clear() None 从L移除所有项目 count() integer 返回数据项在L中出现的次数 index() integer 返回第一个数据项在L中出现位置的索引，若值不存在，则抛出ValueError sort() None 对列表进行原地排序，可指定参数reverse，若不指定该参数则默认升序排列，指定该参数则为降序排列 基础公用函数： 函数名 返回值 描述 len() integer 返回容器中的项目数 enumerate() iterator for index, value of iterable 返回一个可迭代对象，其中以小元组的形式包裹数据项与正向索引的对应关系 reversed() ... 详情参见函数章节 sorted() ... 详情参见函数章节 获取长度 使用len()方法来获取列表的长度。 返回int类型的值。 lst = [\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\"] print(len(lst)) # 7 Python在对内置的数据类型使用len()方法时，实际上是会直接的从PyVarObject结构体中获取ob_size属性，这是一种非常高效的策略。 PyVarObject是表示内存中长度可变的内置对象的C语言结构体。 直接读取这个值比调用一个方法要快很多。 追加元素 使用append()方法为当前列表追加一个数据项。 返回None： lst = [\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\"] lst.append(\"H\") print(lst) # ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H'] 你也可以使用+=进行操作，但个人并不推荐这样使用。 lst = [\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\"] lst += \"H\" print(lst) # ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H'] 列表合并 使用extend()方法来让当前列表与另一个可迭代对象进行合并。 返回None： lst1 = [\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\"] lst2 = [\"H\", \"J\", \"K\", \"L\"] lst1.extend(lst2) print(lst1) # ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'J', 'K', 'L'] 你也可以使用+=进行操作，但个人并不推荐这样使用。 lst1 = [\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\"] lst2 = [\"H\", \"J\", \"K\", \"L\"] lst1 += lst2 print(lst1) # ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'J', 'K', 'L'] 插入元素 使用insert()方法将数据项插入当前列表中的指定位置。 返回None： lst = [\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\"] lst.insert(0, \"a\") print(lst) # ['a', 'A', 'B', 'C', 'D', 'E', 'F', 'G'] 列表拷贝 使用copy()方法将当前列表进行浅拷贝。 返回当前列表的拷贝对象： oldLi = [\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\"] newLi = oldLi.copy() print(oldLi) print(newLi) print(id(oldLi)) print(id(newLi)) print(id(oldLi[0])) print(id(oldLi[0])) # ['A', 'B', 'C', 'D', 'E', 'F', 'G'] # ['A', 'B', 'C', 'D', 'E', 'F', 'G'] # 4329305992 # 4329607688 # 4328383520 # 4328383520 弹出元素 使用pop()方法弹出当前列表中在此索引位置的数据项，列表中该数据项将被删除，并返回被弹出的数据项。 若不指定位置，则默认弹出-1号索引位置的数据项： lst = [\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\"] popItem1 = lst.pop() popItem2 = lst.pop(2) print(lst) print(popItem1) print(popItem2) # ['A', 'B', 'D', 'E', 'F'] # G # C 删除元素 使用remove()方法删除当前列表中的数据项，根据数据项的名字进行删除。 如果具有多个同名的数据项，则只会删除第一个。 返回None： lst = [\"A\", \"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\"] lst.remove(\"A\") print(lst) # ['A', 'B', 'C', 'D', 'E', 'F', 'G'] 我们也可以使用del lst[index]进行数据项的删除： lst = [\"A\", \"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\"] del lst[0] print(lst) # ['A', 'B', 'C', 'D', 'E', 'F', 'G'] 这种方式还可以删除多个： lst = [\"A\", \"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\"] del lst[0:3] print(lst) # ['C', 'D', 'E', 'F', 'G'] 清空元素 使用clear()方法将当前列表进行清空，即删除所有数据项。 返回None： lst = [\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\"] lst.clear() print(lst) # [] 我们也可以使用del lst[:]进行列表的清空： lst = [\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\"] del lst[:] print(lst) # [] 统计次数 使用count()方法统计数据项在该列表中出现的次数。 返回int： lst = [\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\", \"A\"] aInLiCount = lst.count(\"A\") print(aInLiCount) # 2 查找位置 使用index()方法找到数据项在当前列表中首次出现的位置索引值，如数据项不存在则抛出异常。 返回int。 lst = [\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\", \"A\"] aInLiIndex = lst.index(\"A\") print(aInLiIndex) # 0 顺序排列 使用sort()方法将当前列表中的数据项按照ASCII码顺序进行排列，默认从小到大。 可指定参数resverse，用于是否翻转列表，如翻转列表则代表从大到小。 返回None： lst = [\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\", \"A\"] lst.sort(reverse=True) print(lst) # ['G', 'F', 'E', 'D', 'C', 'B', 'A', 'A'] sort()方法内部采用timsort算法，这是一种非常优秀的算法，速度快且稳定。 底层探究 容器序列 这里引出一个新的概念，线性容器序列： 线性是指该对象内部是由连续的内存空间组成 容器中能存放不同类型的数据项，如list就是标准的一个容器 序列是指具有长度的对象，且该对象能使用index进行内部数据项的操作 容器序列存放的是它们所包含的任意类型的对象的引用，如下定义了一个列表： x = [“A”, “B”, “C”] 它的内部存储结构如下图所示： 在CPython源码中，列表数据项的引用为PyObject **ob_item属性，即指针的指针。 元素调整 列表中，pop()和insert()方法都具有指定索引值的功能。 如果使用pop(0)，或者insert(0)则都会引起整个列表中数据项的调整。 pop(0)会将队首的数据项弹出并删除，后面的所有数据项都要向前挪一个位置。1变成0，2变成1，以此类推 insert(0)会将新的数据项插入至队首，后面的所有数据项都要向后挪一个位置。0变成1，1变成2，以此类推 而单纯的使用pop()或者append()则不会发生数据项调整，因为它们总是在队尾做操作。 总而言之，任何一个方法只要不是操作的队尾数据项，都会引起该列表中其他所有数据项的调整。 图示如下： 扩容机制 在对列表进行添加数据项时，如果列表内部的容量已满则会触发扩容机制。 我们要理解2个概念： 容量：容量指的是列表底层在开辟内存时，开辟了多大的内存空间，能够容纳多少数据项，可以理解为一共有多少个槽位 大小：大小指的是当前列表中，数据项已占据的容量，可以理解为已用了多少个槽位 在CPython源码中，列表容量的属性为Py_ssize_t allocated，而列表大小的属性为Py_ssize_t ob_size 在初始化列表时，容量和大小总是等于数据项的总个数，如： 一个空列表，容量和大小都为0 有8个槽位的列表，容量和大小都为8 如果对一个已有的列表进行增加数据项的操作时会有以下2条判断，判定当前列表是否需要扩容： 当前列表容量 > 已有数据项个数+1 and 已有数据项个数 >= 当前列表容量的一半 则直接添加数据项，不进行扩容 并且新增数据项个数 Py_ssize_t ob_size + 1 当前列表容量 则先进行扩容后再添加数据项 扩容是一种线性增长，增长规律为：0、4、8、16、24、32、40、52、64、76 …，总是为4的倍数 在扩容时不必担心发生内存溢出，因为内部已经设置了最大值 为：PY_SSIZE_T_MAX *（9/8）+ 6 缩容机制 缩容机制建立在列表有空余空间的情况下。 我们如果使用pop()方法删除了最后一个数据项，其实并不会将最后一个列表槽位所占用的内存空间给释放掉而是进行保留，内部仅进行一次Py_ssize_t ob_size - 1的操作。 这样做的好处是，后面再添加数据项时，其实就不用再次进行扩容了。 但是在添加数据项之前，会判断整个列表的容量是否过大，如果过大即代表还有很多空的位置，此时要进行缩容机制： 如果数据项个数 + 1 则进行缩容，删除空的列表槽位 如果是clear()清空列表中的数据项，则直接非常干脆的将容量以及大小都重置为0，并且将该列表所有槽位占据的内存空间进行释放。 迁徙机制 因为列表底层是顺序存储，必须占用一个连续的内存空间。 如果在进行扩容时，发现后面连续的内存空间被其他对象所占据，则会将整个列表进行一次拷贝。 然后迁徙到新的位置开辟内存，确保所有的列表槽位都是连续的。 列表缓存 当删除一个列表之后，会将该列表中槽位引用的数据项地址全部清空。 并且将该列表的引用存放至一个叫做free_list的缓存中，下次如果再需要创建列表，则直接从free_list缓存中获取。 free_list最多可以缓存80个列表 示例，旧列表被删除后将空列表的引用存放至free_list缓存中，当再次创建一个新列表时，会直接从free_list缓存中获取旧列表，并且填入数据项： lst1 = [1, 2, 3] print(id(lst1)) del lst1 lst2 = [4, 5, 6, 7] print(id(lst2)) # 4405732936 # 4405732936 listobject.c源码 官网参考：点我跳转 源码一览：点我跳转 以下是截取了一些关键性源代码，并且做上了中文注释，方便查阅。 每一个列表都有几个关键性的属性： Py_ssize_t ob_refcnt; // 引用计数器 PyObject **ob_item; // 列表内部槽位的数据项指针，即指针的指针 Py_ssize_t ob_size; // 列表大小 Py_ssize_t allocated; // 列表容量 创建列表 PyObject * PyList_New(Py_ssize_t size) { // 空列表 if (size numfree != -1); #endif // 判断是否有free_list中是否有缓存 if (state->numfree) { // 有缓存，free_list缓存的列表个数减1 state->numfree--; op = state->free_list[state->numfree]; // 建立新的引用关系 _Py_NewReference((PyObject *)op); } else { // 无缓存，创建新列表，先开辟内存 op = PyObject_GC_New(PyListObject, &PyList_Type); if (op == NULL) { return NULL; } } if (size ob_item = NULL; } else { // 如果列表不是空的，则将每个槽位的数据项地址进行引用 op->ob_item = (PyObject **) PyMem_Calloc(size, sizeof(PyObject *)); if (op->ob_item == NULL) { Py_DECREF(op); return PyErr_NoMemory(); } } // 设置列表中数据项占据的容量大小 Py_SET_SIZE(op, size); // 设置列表的整体容量 op->allocated = size; // 将列表放入双向链表中以进行内存管理 _PyObject_GC_TRACK(op); // 返回列表的结构体指针 return (PyObject *) op; } 添加元素 static int app1(PyListObject *self, PyObject *v) { // 获取列表的大小（已占用容量） Py_ssize_t n = PyList_GET_SIZE(self); assert (v != NULL); assert((size_t)n + 1 static int list_resize(PyListObject *self, Py_ssize_t newsize) { PyObject **items; size_t new_allocated, num_allocated_bytes; Py_ssize_t allocated = self->allocated; /* Bypass realloc() when a previous overallocation is large enough to accommodate the newsize. If the newsize falls lower than half the allocated size, then proceed with the realloc() to shrink the list. */ // 扩容、缩容机制调用realloc()函数 // allocated = 容量 // newsize代表已存在的数据项个数 + 1 // 当前列表容量 > 已有数据项个数+1 and 已有数据项个数 >= 当前列表容量的一半 if (allocated >= newsize && newsize >= (allocated >> 1)) { assert(self->ob_item != NULL || newsize == 0); // 则直接添加数据项，不进行扩容 // 并新增数据项个数 Py_ssize_t ob_size + 1 Py_SET_SIZE(self, newsize); return 0; } /* This over-allocates proportional to the list size, making room * for additional growth. The over-allocation is mild, but is * enough to give linear-time amortized behavior over a long * sequence of appends() in the presence of a poorly-performing * system realloc(). * Add padding to make the allocated size multiple of 4. * The growth pattern is: 0, 4, 8, 16, 24, 32, 40, 52, 64, 76, ... * Note: new_allocated won't overflow because the largest possible value * is PY_SSIZE_T_MAX * (9 / 8) + 6 which always fits in a size_t. */ new_allocated = ((size_t)newsize + (newsize >> 3) + 6) & ~(size_t)3; /* Do not overallocate if the new size is closer to overallocated size * than to the old size. */ // 如果数据项个数 + 1 (Py_ssize_t)(new_allocated - newsize)) new_allocated = ((size_t)newsize + 3) & ~(size_t)3; // 全是空的 if (newsize == 0) new_allocated = 0; num_allocated_bytes = new_allocated * sizeof(PyObject *); // 基于realloc()进行扩容或者缩容，内部会包含数据项的位置调整 items = (PyObject **)PyMem_Realloc(self->ob_item, num_allocated_bytes); if (items == NULL) { PyErr_NoMemory(); return -1; } // 重新设置列表的 ob_item、obsize、allocated self->ob_item = items; Py_SET_SIZE(self, newsize); self->allocated = new_allocated; return 0; } 插入元素 static int ins1(PyListObject *self, Py_ssize_t where, PyObject *v) { // 获取数据项个数 Py_ssize_t i, n = Py_SIZE(self); PyObject **items; // 插入数据项确保不是NULL if (v == NULL) { PyErr_BadInternalCall(); return -1; } assert((size_t)n + 1 n) where = n; // 拿到列表中所有数据项的引用 items = self->ob_item; // 让插入位置之后的所有数据项开始向后挪动1个位置，腾出位置来插入新的数据项 for (i = n; --i >= where; ) // i + 1指的是数据项指针地址，每次 - 1 items[i+1] = items[i]; // 新增数据项的引用计数 + 1 Py_INCREF(v); // 新的数据项索引位置和值做绑定 items[where] = v; return 0; } int PyList_Insert(PyObject *op, Py_ssize_t where, PyObject *newitem) { // 传入列表的引用， 插入的位置，还有新的数据项引用，并且验证列表和数据项 if (!PyList_Check(op)) { PyErr_BadInternalCall(); return -1; } // 进行插入 return ins1((PyListObject *)op, where, newitem); } 移除元素 static PyObject * list_pop_impl(PyListObject *self, Py_ssize_t index) // 传入列表的引用，列表的弹出数据项索引位置 { PyObject *v; int status; // 如果是一个空列表，则抛出异常 if (Py_SIZE(self) == 0) { /* Special-case most common failure cause */ PyErr_SetString(PyExc_IndexError, \"pop from empty list\"); return NULL; } if (index ob_item[index]; // 如果弹出的数据项是列表中的最后一个 if (index == Py_SIZE(self) - 1) { // list_resize()内部只会做size - 1，而不会回收内存进行缩容 status = list_resize(self, Py_SIZE(self) - 1); if (status >= 0) return v; /* and v now owns the reference the list had */ else return NULL; } // 增加一次引用计数器 Py_INCREF(v); // 如果弹出的数据项不是列表中的最后一个，则需要进行位置调整 status = list_ass_slice(self, index, index+1, (PyObject *)NULL); if (status 清空元素 static int _list_clear(PyListObject *a) { Py_ssize_t i; PyObject **item = a->ob_item; if (item != NULL) { /* Because XDECREF can recursively invoke operations on this list, we make it empty first. */ i = Py_SIZE(a); // 重新设置大小为0 Py_SET_SIZE(a, 0); // 将列表中插槽引用的对象全部设置为None a->ob_item = NULL; // 重新设置容量为0 a->allocated = 0; // 循环列表中的数据项，令所有数据项的引用计数-1 while (--i >= 0) { Py_XDECREF(item[i]); } PyMem_Free(item); } /* Never fails; the return value can be ignored. Note that there is no guarantee that the list is actually empty at this point, because XDECREF may have populated it again! */ return 0; } 删除列表 static void list_dealloc(PyListObject *op) { Py_ssize_t i; // 内部会判断这个列表是否还有其他标识符引用，如果为0则代表没有其他标识符引用 // 可以通过内部GC机制将该列表所占据的内存空间进行释放 PyObject_GC_UnTrack(op); Py_TRASHCAN_BEGIN(op, list_dealloc) if (op->ob_item != NULL) { /* Do it backwards, for Christian Tismer. There's a simple test case where somehow this reduces thrashing when a *very* large list is created and immediately deleted. */ // 获取列表中已有数据项的个数（即大小） i = Py_SIZE(op); // 循环列表中的数据项，令所有数据项的引用计数-1 while (--i >= 0) { Py_XDECREF(op->ob_item[i]); } PyMem_Free(op->ob_item); } struct _Py_list_state *state = get_list_state(); #ifdef Py_DEBUG // list_dealloc() must not be called after _PyList_Fini() assert(state->numfree != -1); #endif // 判断free_list中的已缓存列表个数是否大于80，这里是没满 // 在free_list中添加空列表的引用即可 if (state->numfree free_list[state->numfree++] = op; } else { // 如果free_list的大小已达到容量限制 // 则直接在内存中销毁列表的结构体对象 Py_TYPE(op)->tp_free((PyObject *)op); } Py_TRASHCAN_END } Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:46 "},"Python/Python基础知识/元组类型.html":{"url":"Python/Python基础知识/元组类型.html","title":"元组类型","keywords":"","body":"元组 Python中的元组容器序列（tuple）与列表容器序列（list）具有极大的相似之处，因此也常被称为不可变的列表。 但是两者之间也有很多的差距，元组侧重于数据的展示，而列表侧重于数据的存储与操作。 它们非常相似，虽然都可以存储任意类型的数据，但是一个元组定义好之后就不能够再进行修改。 元组特性 元组特性如下： 元组属于线性容器序列 元组属于不可变类型，即对象本身的属性不会根据外部变化而变化 元组底层由顺序存储组成，而顺序存储是线性结构的一种 基本声明 以下是使用类实例化的形式进行对象声明： tpl = tuple((1, 2, 3, 4, 5)) print(\"value : %r\\ntype : %r\" % (tpl, type(tpl))) # value : (1, 2, 3, 4, 5) # type : 也可以选择使用更方便的字面量形式进行对象声明，使用逗号对数据项之间进行分割： tpl = 1, 2, 3, 4, 5 print(\"value : %r\\ntype : %r\" % (tpl, type(tpl))) # value : (1, 2, 3, 4, 5) # type : 为了美观，我们一般会在两侧加上()，但是要确定一点，元组定义是用逗号来分隔数据项，而并非是用()包裹数据项： tpl = (1, 2, 3, 4, 5) print(\"value : %r\\ntype : %r\" % (tpl, type(tpl))) # value : (1, 2, 3, 4, 5) # type : 多维元组 当一个元组中嵌套另一个元组，该元组就可以称为多维元组。 如下，定义一个2维元组： tpl = (1, 2, (\"三\", \"四\")) print(\"value : %r\\ntype : %r\" % (tpl , type(tpl))) # value : (1, 2, ('三', '四')) # type : 续行操作 在Python中，元组中的数据项如果过多，可能会导致整个元组太长，太长的元组是不符合PEP8规范的。 每行最大的字符数不可超过79，文档字符或者注释每行不可超过72 Python虽然提供了续行符\\，但是在元组中可以忽略续行符，如下所示： tpl = ( 1, 2, 3, 4, 5 ) print(\"value : %r\\ntype : %r\" % (tpl, type(tpl))) # value : (1, 2, 3, 4, 5) # type : 类型转换 元组支持与布尔型、字符串、列表、以及集合类型进行类型转换： tpl = (1, 2, 3) bTpl = bool(tpl) strTpl = str(tpl) lstTpl = list(tpl) setTpl = set(tpl) print(\"value : %r\\ntype : %r\" % (bTpl, type(bTpl))) print(\"value : %r\\ntype : %r\" % (strTpl, type(strTpl))) print(\"value : %r\\ntype : %r\" % (lstTpl, type(lstTpl))) print(\"value : %r\\ntype : %r\" % (setTpl, type(setTpl))) # value : True # type : # value : '(1, 2, 3)' # type : # value : [1, 2, 3] # type : # value : {1, 2, 3} # type : 如果一个2维元组遵循一定的规律，那么也可以将其转换为字典类型： tpl = ((\"k1\", \"v1\"), (\"k2\", \"v2\"), (\"k3\", \"v3\")) dictTuple = dict(tpl) print(\"value : %r\\ntype : %r\" % (dictTuple, type(dictTuple))) # value : {'k1': 'v1', 'k2': 'v2', 'k3': 'v3'} # type : 索引操作 元组由于是线性结构，故支持索引和切片操作 但只针对获取，不能对其内部数据项进行修改。 使用方法参照列表的索引切片一节。 绝对引用 元组拥有绝对引用的特性，无论是深拷贝还是浅拷贝，都不会获得其副本，而是直接对源对象进行引用。 但是列表没有绝对引用的特性，代码验证如下： >>> import copy >>> # 列表的深浅拷贝均创建新列表... >>> oldLi = [1, 2, 3] >>> id(oldLi) 4542649096 >>> li1 = copy.copy(oldLi) >>> id(li1) 4542648840 >>> li2 = copy.deepcopy(oldLi) >>> id(li2) 4542651208 >>> # 元组的深浅拷贝始终引用老元组 >>> oldTup = (1, 2, 3) >>> id(oldTup) 4542652920 >>> tup1 = copy.copy(oldTup) >>> id(tup1) 4542652920 >>> tup2 = copy.deepcopy(oldTup) >>> id(tup2) 4542652920 Python为何要这样设计？其实仔细想想不难发现，元组不能对其进行操作，仅能获取数据项。 那么也就没有生成多个副本提供给开发人员操作的必要了，因为你修改不了元组，索性直接使用绝对引用策略。 值得注意的一点：[:]也是浅拷贝，故对元组来说属于绝对引用范畴。 元组的陷阱 Leonardo Rochael在2013年的Python巴西会议提出了一个非常具有思考意义的问题。 我们先来看一下： >>> t = (1, 2, [30, 40]) >>> t[-1] += [50, 60] Traceback (most recent call last): File \"\", line 1, in TypeError: 'tuple' object does not support item assignment 现在，t到底会发生下面4种情况中的哪一种？ t 变成 (1, 2, [30, 40, 50, 60])。 因为 tuple 不支持对它的数据项赋值，所以会抛出 TypeError 异常。 以上两个都不是。 a 和 b 都是对的。 正确答案是4，t确实会变成 (1, 2, [30, 40, 50, 60])，但同时元组是不可变类型故会引发TypeError异常的出现。 >>> t (1, 2, [30, 40, 50, 60]) 如果是使用extend()对t[-1]的列表进行数据项的增加，则答案会变成1。 我当初在看了这个问题后，暗自告诉自己了1件事情： tuple中不要存放可变类型的数据，如list、set、dict等.. 元组更多的作用是展示数据，而不是操作数据。 举个例子，当用户根据某个操作获取到了众多数据项之后，你可以将这些数据项做出元组并返回。 用户对被返回的原对象只能看，不能修改，若想修改则必须创建新其他类型对象。 解构方法 元组的解构方法与列表使用相同。 使用方法参照列表的解构方法一节。 常用方法 方法一览 常用的tuple方法一览表： 方法名 返回值 描述 count() integer 返回数据项在T中出现的次数 index() integer 返回第一个数据项在T中出现位置的索引，若值不存在，则抛出ValueError 基础公用函数： 函数名 返回值 描述 len() integer 返回容器中的项目数 enumerate() iterator for index, value of iterable 返回一个可迭代对象，其中以小元组的形式包裹数据项与正向索引的对应关系 reversed() ... 详情参见函数章节 sorted() ... 详情参见函数章节 获取长度 使用len()方法来获取元组的长度。 返回int类型的值。 tpl = (\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\") print(len(tpl)) # 7 Python在对内置的数据类型使用len()方法时，实际上是会直接的从PyVarObject结构体中获取ob_size属性，这是一种非常高效的策略。 PyVarObject是表示内存中长度可变的内置对象的C语言结构体。 直接读取这个值比调用一个方法要快很多。 统计次数 使用count()方法统计数据项在该元组中出现的次数。 返回int： tpl = (\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\", \"A\") aInTupCount = tpl.count(\"A\") print(aInTupCount) # 2 查找位置 使用index()方法找到数据项在当前元组中首次出现的位置索引值，如数据项不存在则抛出异常。 返回int。 tpl = (\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\", \"A\") aInTupIndex = tpl.index(\"A\") print(aInTupIndex) # 0 底层探究 内存开辟 Python内部实现中，列表和元组还是有一定的差别的。 元组在创建对象申请内存的时候，内存空间大小便进行了固定，后续不可更改（如果是传入了一个可迭代对象，例如tupe(range(100))，这种情况会进行扩容与缩容，下面的章节将进行详细研究）。 而列表在创建对象申请内存的时候，内存空间大小不是固定的，如果后续对其新增或删除数据项，列表会进行扩容或者缩容机制。 元组创建 空元组 若创建一个空元组，会直接进行创建，然后将这个空元组丢到缓存free_list中。 元组的free_list最多能缓存 20 * 2000 个元组，这个在下面会进行讲解。 如图所示： 元组转元组 下面的代码会进行元组转元组： tup = tuple((1, 2, 3)) 首先内部的参数本身就是一个元组（1， 2， 3），所以会直接将内部的这个元组拿出来并返回引用，并不会再次创建。 代码验证： >>> oldTpl = (1, 2, 3) >>> id(oldTpl) 4384908128 >>> newTpl = tuple(oldTpl) >>> id(newTpl) 4384908128 >>> 列表转元组 列表转元组会将列表中的每一个数据项都拿出来，然后放入至元组中： tpl = tuple([1, 2, 3]) 所以你会发现，列表和元组中的数据项引用都是相同的： >>> lst = [\"A\", \"B\", \"C\"] >>> tpl = tuple(lst) >>> print(id(lst[0])) 4383760656 >>> print(id(tpl[0])) 4383760656 >>> 可迭代对象转元组 可迭代对象是没有长度这一概念的，如果是可迭代对象转换为元组，会先对可迭代对象的长度做一个猜想。 并且根据这个猜想，为元组开辟一片内存空间，用于存放可迭代对象的数据项。 然后内部会获取可迭代对象的迭代器，对其进行遍历操作，拿出数据项后放至元组中。 如果猜想的长度太小，会导致元组内部的内存不够存放下所有的迭代器数据项，此时该元组会进行内部的扩容机制，直至可迭代对象中的数据项全部被添加至元组中。 rangeObject = range(1, 101) tpl = tuple(rangeObject) // 假如猜想的是9 // 第一步：+ 10 // 第二步：+ (原长度+10) * 0.25 // 其实，就是增加【原长度*0.25 + 2.5】 // 即第一次新增4个槽位 如果猜想的长度太大，而实际上迭代器中的数据量偏少，则需要对该元组进行缩容。 切片取值 对元组进行切片取值的时候，会开辟一个新元组用于存放切片后得到的数据项。 tpl = (1, 2, 3) newSliceTpl = tpl[0:2] 当然，如果是[:]的操作，则参照绝对引用，直接返回被切片的元组引用。 代码验证： >>> id(tpl) 4384908416 >>> newSliceTpl = tpl[0:2] >>> id(newSliceTpl) 4384904392 缓存机制 free_list缓存 元组的缓存机制和列表的缓存机制不同。 元组的free_list会缓存0 - 19长度的共20种元组，其中每一种长度的元组通过单向链表横向扩展缓存至2000个，如下图所示： 当每一次del操作有数据项的元组时，都会将该元组数据项清空并挂载至free_list单向链表的头部的位置。 del (1, 2, 3) --> (None, None, None) \\ del (4, 5, 6) --> (None, None, None) -> free_list 长度3的元组 ... del (7, 8, 9) --> (None, None, None) / 如下图所示： 当要创建一个元组时，会通过创建元组的长度，从free_list单向链表的头部取出一个元组，然后将数据项存放进去。 前提是free_list单向链表中缓存的有该长度的元组。 tup = (1, 2, 3) # 长度为3，从free_list的长度为3的元组中取 空元组与非空元组的缓存 空元组的缓存是一经创建就缓存到free_list单向链表中。 而非空元组的缓存必须是del操作后才缓存到free_list单向链表中。 空元组的创建 第一次创建空元组后，空元组会缓存至free_list单向链表中。 以后的每一次空元组创建，返回的其实都是同一个引用，也就是说空元组在free_list单向链表中即使被引用了也不会被销毁。 >>> t1 = () >>> id(t1) 4511088712 >>> t2 = () >>> id(t2) 4511088712 非空元组的创建 创建非空元组时，先检查free_list，当free_list单向链表中有相同长度的元组时，会进行引用并删除。 这个在上图中已经示例过了，就是这个： 代码示例： $ python3 Python 3.6.8 (v3.6.8:3c6b436a57, Dec 24 2018, 02:04:31) [GCC 4.2.1 Compatible Apple LLVM 6.0 (clang-600.0.57)] on darwin Type \"help\", \"copyright\", \"credits\" or \"license\" for more information. >>> v1 = (None, None, None) >>> id(v1) 4384907696 >>> v2 = (None, None, None) >>> id(v2) 4384908056 >>> del v1 >>> del v2 # ❶ >>> v3 = (None, None, None) >>> id(v3) # ❷ 4384908056 >>> v4 = (None, None, None) >>> id(v4) # ❸ 4384907696 >>> ❶：free_list num_free=3 单向链表结构：v2 —> v1 ❷：创建了v3，拿出v2的空元组，填入v3数据项，故v2和v3的id值相等，证明引用同一个元组，此时free_list num_free=3 单向链表结构为：—> v1 ❸：创建了v4，拿出v1的空元组，填入v4数据项，故v1和v4的id值相等，证明引用同一个元组 tupleobject.c源码 官网参考：点我跳转 源码一览：点我跳转 以下是截取了一些关键性源代码，并且做上了中文注释，方便查阅。 每一个元组都有几个关键性的属性： Py_ssize_t ob_refcnt; // 引用计数器 Py_ssize_t ob_size; // 数据项个数，即元组大小 PyObject *ob_item[1]; // 存储元组中的数据项 [指针, ] 关于缓存free_list的属性： PyTuple_MAXSAVESIZE // 相当于图中的 free_num ，最大20，即纵向扩展的缓存元组长度 PyTuple_MAXFREELIST // 图中 free_list 的横向扩展缓存列表个数，最大2000 创建元组 空元组 PyObject * PyTuple_New(Py_ssize_t size) { PyTupleObject *op; // 缓存相关 Py_ssize_t i; // 元组的大小不能小于0 if (size 0 // 创建空元组，优先从缓存中获取 // size = 0 表示这是一个空元组，从free_list[0]中获取空元组 if (size == 0 && free_list[0]) { // op就是空元组 op = free_list[0]; // 新增空元组引用计数器 + 1 Py_INCREF(op); #ifdef COUNT_ALLOCS tuple_zero_allocs++; #endif // 返回空元组的指针 return (PyObject *) op; } // 如果创建的不是空元组，且这个创建的元组数据项个数小于20，并且free_list[size]不等于空，表示有缓存 // 则从缓存中去获取，不再重新开辟内存 if (size ob_item[0]; // num_free减1 numfree[size]--; #ifdef COUNT_ALLOCS fast_tuple_allocs++; #endif /* Inline PyObject_InitVar */ // 初始化，定义这个元组的长度为数据项个数 #ifdef Py_TRACE_REFS Py_SIZE(op) = size; // 定义类型为 tuple Py_TYPE(op) = &PyTuple_Type; #endif // 增加一次新的引用 _Py_NewReference((PyObject *)op); } // 如果是空元组 else #endif { // 检查内存情况，是否充足 /* Check for overflow */ if ((size_t)size > ((size_t)PY_SSIZE_T_MAX - sizeof(PyTupleObject) - sizeof(PyObject *)) / sizeof(PyObject *)) { return PyErr_NoMemory(); } // 开辟内存，并获得一个元组：op op = PyObject_GC_NewVar(PyTupleObject, &PyTuple_Type, size); if (op == NULL) return NULL; } // 空元组的每一个槽位都是NULL for (i=0; i ob_item[i] = NULL; #if PyTuple_MAXSAVESIZE > 0 // 缓存空元组 if (size == 0) { free_list[0] = op; ++numfree[0]; Py_INCREF(op); /* extra INCREF so that this is never freed */ } #endif #ifdef SHOW_TRACK_COUNT count_tracked++; #endif // 将元组加入到GC机制中，用于内存管理 _PyObject_GC_TRACK(op); return (PyObject *) op; } 可迭代对象转元组 这个不在tupleobject.c源码中，而是在abstract.c源码中。 官网参考：点我跳转 源码一览：点我跳转 PyObject * PySequence_Tuple(PyObject *v) { PyObject *it; /* iter(v) */ Py_ssize_t n; /* guess for result tuple size */ PyObject *result = NULL; Py_ssize_t j; if (v == NULL) { return null_error(); } /* Special-case the common tuple and list cases, for efficiency. */ // 如果是元组转换元组，如 tup = (1, 2, 3) 或者 tup = ((1, 2, 3))直接返回内存地址 if (PyTuple_CheckExact(v)) { Py_INCREF(v); return v; } // 如果是列表转换元组，则执行PyList_AsTuple()，将列表转换为元组 // 如 tup = ([1, 2, 3]) if (PyList_CheckExact(v)) return PyList_AsTuple(v); /* Get iterator. */ // 获取迭代器， tup = (range(1, 4).__iter__()) it = PyObject_GetIter(v); if (it == NULL) return NULL; /* Guess result size and allocate space. */ // 猜想迭代器长度，也就是猜一下有多少个数据项 n = PyObject_LengthHint(v, 10); if (n == -1) goto Fail; // 根据猜想的迭代器长度，进行元组的内存开辟 result = PyTuple_New(n); if (result == NULL) goto Fail; /* Fill the tuple. */ // 将迭代器中每个数据项添加至元组中 for (j = 0; ; ++j) { PyObject *item = PyIter_Next(it); if (item == NULL) { if (PyErr_Occurred()) goto Fail; break; } //如果迭代器中数据项比猜想的多，则证明开辟内存不足需要需要进行扩容 if (j >= n) { size_t newn = (size_t)n; /* The over-allocation strategy can grow a bit faster than for lists because unlike lists the over-allocation isn't permanent -- we reclaim the excess before the end of this routine. So, grow by ten and then add 25%. */ // 假如猜想的是9 // 第一步：+ 10 // 第二步：+ (原长度+10) * 0.25 // 其实，就是增加【原长度*0.25 + 2.5】 newn += 10u; newn += newn >> 2; // 判断是否超过了元组的数据项个数限制（sys.maxsize） if (newn > PY_SSIZE_T_MAX) { /* Check for overflow */ PyErr_NoMemory(); Py_DECREF(item); goto Fail; } n = (Py_ssize_t)newn; // 扩容机制 if (_PyTuple_Resize(&result, n) != 0) { Py_DECREF(item); goto Fail; } } // 将数据项放入元组之中 PyTuple_SET_ITEM(result, j, item); } /* Cut tuple back if guess was too large. */ // 如果猜想的数据项太多，而实际上迭代器中的数据量偏少 // 则需要对该元组进行缩容 if (j 列表转元组 这个不在tupleobject.c源码中，而是在listobject.c源码中。 官网参考：点我跳转 源码一览：点我跳转 PyObject * PyList_AsTuple(PyObject *v) { PyObject *w; PyObject **p, **q; Py_ssize_t n; // 例如：tup = ([1, 2, 3]) // 进行列表的验证 if (v == NULL || !PyList_Check(v)) { PyErr_BadInternalCall(); return NULL; } // 获取大小，即数据项个数 n = Py_SIZE(v); // 开辟内存 w = PyTuple_New(n); // 如果是空元组 if (w == NULL) return NULL; // 执行迁徙操作 p = ((PyTupleObject *)w)->ob_item; q = ((PyListObject *)v)->ob_item; // 将列表中数据项的引用，也给元组进行引用 // 这样列表中数据项和元组中的数据项都引用同1个对象 while (--n >= 0) { // 数据项引用计数 + 1 Py_INCREF(*q); *p = *q; p++; q++; } // 返回元组 return w; } 切片取值 PyObject * PyTuple_GetSlice(PyObject *op, Py_ssize_t i, Py_ssize_t j) // 切片会触发该方法 { // 如果对空元组进行切片，则会抛出异常 if (op == NULL || !PyTuple_Check(op)) { PyErr_BadInternalCall(); return NULL; } // 内部的具体实现方法 return tupleslice((PyTupleObject *)op, i, j); } static PyObject * tupleslice(PyTupleObject *a, Py_ssize_t ilow, Py_ssize_t ihigh) { PyTupleObject *np; PyObject **src, **dest; Py_ssize_t i; Py_ssize_t len; // 计算索引位置 if (ilow Py_SIZE(a)) ihigh = Py_SIZE(a); if (ihigh ob_item + ilow; dest = np->ob_item; // 对源元组中的数据项的引用计数+1 for (i = 0; i 缓存相关 static void tupledealloc(PyTupleObject *op) { Py_ssize_t i; Py_ssize_t len = Py_SIZE(op); PyObject_GC_UnTrack(op); Py_TRASHCAN_SAFE_BEGIN(op) // 如果元组的长度大于0，则不是一个非空元组 if (len > 0) { i = len; // 将内部的数据项引用计数都 - 1 while (--i >= 0) Py_XDECREF(op->ob_item[i]); #if PyTuple_MAXSAVESIZE > 0 // 准备缓存，判断num_free是否小于20，并且单向链表中的已缓存元组个数小于2000 if (len ob_item[0] = (PyObject *) free_list[len]; // 将num_free + 1 numfree[len]++; free_list[len] = op; goto done; /* return */ } #endif } // 内存中进行销毁 Py_TYPE(op)->tp_free((PyObject *)op); done: Py_TRASHCAN_SAFE_END(op) } Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:46 "},"Python/Python基础知识/字符串类型.html":{"url":"Python/Python基础知识/字符串类型.html","title":"字符串类型","keywords":"","body":"字符串 字符串（str）一般是指 Unicode 字符串，见名知意，字符串是由多个字符所构成的一个串。 它是 Python 中最常用的数据类型之一，因此十分重要。 字符串有一个最显著的特征，即不可变，也就是说你无法使用索引来改变字符串中的字符，仅限于获取。 字符串特性 字符串特性如下： 字符串属于线性扁平序列 字符串是不可变的，即对象本身的属性不会根据外部变化而变化 字符串底层是一段连续的内存空间 基本声明 以下是使用类实例化的形式进行对象声明： string = str(\"ABCDEFG\") print(\"value : %r\\ntype : %r\" % (string, type(string))) # value : 'ABCDEFG' # type : 也可以选择使用更方便的字面量形式进行对象声明，使用英文状态下的单引号、双引号、三单引号、三双引号将数据项进行包裹即可： string = \"ABCDEFG\" print(\"value : %r\\ntype : %r\" % (string, type(string))) # value : 'ABCDEFG' # type : 个人并不推荐常规的使用三单引号或三双引号进行字符串定义，因为除了字符串定义外它们还具有文档注释的功能。 续行操作 在 Python 中，如果一个字符串过长，可能会导致不符合 PEP8 规范的情况出现。 每行最大的字符数不可超过 79，文档字符或者注释每行不可超过 72 如果要定义这样的长字符串，推荐使用三单引号或者三双引号进行定义，这样即可进行换行（但会保留特殊字符，如\\n）: string = \"\"\" 江雪 柳宗元 千山鸟飞绝 万径人踪灭 孤舟蓑笠翁 独钓寒江雪 \"\"\" print(\"value : %r\\ntype : %r\" % (string, type(string))) # value : '\\n 江雪\\n 柳宗元\\n千山鸟飞绝\\n万径人踪灭\\n孤舟蓑笠翁\\n独钓寒江雪\\n' # type : 类型转换 字符串支持与布尔型、整形、以及浮点型进行转换，这是最常用的操作： string = \"100\" iStr = int(string) bStr = bool(string) fStr = float(string) print(\"value : %r\\ntype : %r\" % (iStr, type(iStr))) print(\"value : %r\\ntype : %r\" % (bStr, type(bStr))) print(\"value : %r\\ntype : %r\" % (fStr, type(fStr))) # value : 100 # type : # value : True # type : # value : 100.0 # type : 需要注意的是，如果一个字符串不是纯数字，那么将其转换为整形或浮点型时将会出现异常： string = \"Non-digital string: 100\" iStr = int(string) fStr = float(string) print(\"value : %r\\ntype : %r\" % (iStr, type(iStr))) print(\"value : %r\\ntype : %r\" % (fStr, type(fStr))) # ValueError: invalid literal for int() with base 10: 'Non-digital string: 100' 此外，字符串也支持转换为列表以及集合： string = \"①〇②④\" setStr = set(string) listStr = list(string) print(\"value : %r\\ntype : %r\" % (setStr, type(setStr))) print(\"value : %r\\ntype : %r\" % (listStr, type(listStr))) # value : {'①', '〇', '②', '④'} # type : # value : ['①', '〇', '②', '④'] # type : 特殊的\\ 在普通的声明字符串中，\\后面一般都会跟上一个特殊字符。 该字符具有特殊的意义，如\\n 代表换行，\\t 代表制表符等，这种具有特殊意义的\\char 组合被称为转义字符。 转义字符 意义 ASCII 码值（十进制） \\a 响铃(BEL) 007 \\b 退格(BS) ，将当前位置移到前一列 008 \\f 换页(FF)，将当前位置移到下页开头 012 \\n 换行(LF) ，将当前位置移到下一行开头 010 \\r 回车(CR) ，将当前位置移到本行开头 013 \\t 水平制表(HT) （跳到下一个 TAB 位置） 009 \\v 垂直制表(VT) 011 \\ 代表一个反斜线字符''' 092 \\' 代表一个单引号（撇号）字符 039 \\\" 代表一个双引号字符 034 ? 代表一个问号 063 \\0 空字符(NUL) 000 \\ddd 1 到 3 位八进制数所代表的任意字符 三位八进制 \\xhh 十六进制所代表的任意字符 十六进制 如果你还是不能理解，那么可看下面这个示例： 我想打印 hello”world，并且我的字符串字面量声明采用 “ 进行包裹。 我们必须进行“的转义，让它变为一个普通字符，而非 Python 中字符串字面量语法表示符： print(\"hello\\\"world\") # hello\"world r 字符串 如果在声明字符串的前面加上字符 r，则代表该字符串中不会存在转义字符，所有字符将按照普通的方式进行解读。 r 字符串也被称为原始字符串： s1 = r\"\\n\\t\\b\" print(s1) # \\n\\t\\b 字节串 字节串（bytes）是字符串的另一种表现形式。 它记录内存中的原始数据，你可以将它理解为 2 进制数据。 字节串可用于网络传输、多媒体持久化存储中，它和字符串拥有相同的特性，即不可变。 字节串仅在 Python3 中出现，Python2 中不存在该类型。 基本声明 以下是使用类实例化的形式进行对象声明，必须传入一个字符串及指定该字符串的编码格式，如不传入字符串，则默认生成空的 bytes 对象： bitStr = bytes(\"ABCDEFG\".encode(\"u8\")) print(\"value : %r\\ntype : %r\" % (bitStr, type(bitStr))) # value : b'ABCDEFG' # type : 也可以选择使用更方便的字面量形式进行对象声明，使用英文状态下的小写 b 加上单引号、双引号、三单引号、三双引号将数据项进行包裹即可，注意数据项必须位于 ASCII 码表之内： bitStr = b\"ABCDEFG\" print(\"value : %r\\ntype : %r\" % (bitStr, type(bitStr))) # value : b'ABCDEFG' # type : 个人并不推荐常规的使用三单引号或三双引号进行字节串定义，它们还具有文档注释的功能。 编码解码 一个非 ASCII 标准字符串要变为字节串，必须通过 encode()方法来做指定编码格式。 而一个字节串要想变为非 ASCII 标准字符串，也必须通过 decode()方式做指定解码格式。 s = \"你好，世界，hello，world!\" bitStr = bytes(s.encode(encoding=\"u8\")) print(bitStr) string = str(bitStr.decode(encoding=\"u8\")) print(string) # b'\\xe4\\xbd\\xa0\\xe5\\xa5\\xbd\\xef\\xbc\\x8c\\xe4\\xb8\\x96\\xe7\\x95\\x8c\\xef\\xbc\\x8chello\\xef\\xbc\\x8cworld!' # 你好，世界，hello，world! 如果直接使用 str.encode()则自动将 str 转变为 bytes 类型。 反之，如果直接使用 bytes.decode()时 bytes 也会自动转为 str 类型。 因此我们可以省略 bytes()和 str()在外部的包裹： s = \"你好，世界，hello，world!\" bitStr = s.encode(encoding=\"u8\") print(bitStr) string = bitStr.decode(encoding=\"u8\") print(string) # b'\\xe4\\xbd\\xa0\\xe5\\xa5\\xbd\\xef\\xbc\\x8c\\xe4\\xb8\\x96\\xe7\\x95\\x8c\\xef\\xbc\\x8chello\\xef\\xbc\\x8cworld!' # 你好，世界，hello，world! 四则运算 基本操作 字符串支持与字符串进行加法运算，做到拼接的效果，由于字符串是不可变的，所以会生成一个新的字符串： s1 = \"string1\" s2 = \"string2\" print(s1 + s2) # string1string2 字符串支持与整形进行乘法运算，做到重复打印的效果，由于字符串是不可变的，所以会生成一个新的字符串： s1 = \"*\" print(s1 * 3) # *** “可变”的字符串 str 可以使用+=操作，来使原本的字符串与新的字符串进行拼接。 +=是一种常见的操作，所以 CPython 内部为其做了优化。 一个 str 在初始化内存的时候，程序会为它留出额外的可扩展空间，因此进行增量操作的时候，并不会涉及复制原有字符串到新位置这类操作，而是在原有字符串位置的后面添加上新的字符串。 基于这个点，我们看一个有趣的问题： >>> a 'hello world !' >>> id(a) 140521043795728 >>> a+=\"d\" >>> id(a) 140521043795728 >>> a+=\"d\" >>> id(a) 140521043795728 >>> a 'hello world !dd' 乍看之下其实会发现字符串的+=操作并不会开辟额外的内存空间，但是事实并非如此。 CPython 的字符串在底层依旧是不可变的，当这个字符串被+=新的字符串时，会产生一个新的字符串，恰好该字符串会复用之前字符串的 id()值。 这个问题在 stackoverflow 上已经有人问过了，这里贴出原贴： 点我跳转 字符间隙 看一个有趣的例子： s1 = \"HELLO\" boolRET = \"\" in s1 print(boolRET) # True 下一个例子，使用 count()方法计算该字符串中空白字符的数量： s1 = \"HELLO\" print(s1.count(\"\")) # 6 小问号你是否充满了很多朋友？ 实际上，Python 内部进行 str 存储的时候会为每个字符之间留一个空隙，如下所示： 所以才会造成上述情况的发生。 intern 机制 intern 机制是 Python 解释器为了节省内存而做出的一种策略。 当第一次创建一个短字符串的时候，都会用一个全局的字典将该字符串进行存储，而短字符串的定义如下： 长度不超过 20 不含空格 当再次创建这个短字符串，会先查看全局字典中是否存在该短字符串，如果存在则不创建而是直接进行引用。 这种策略也被称之为短字符串驻留机制。 下面这个示例字符串是符合短字符串的，因此会进行驻留： >>> s1 = \"Python\" >>> s2 = \"Python\" >>> s1 is s2 True 由于字符串中含有空格，故该字符串不会触发驻留机制： >>> s1 = \"Pytho n\" >>> s2 = \"Pytho n\" >>> s1 is s2 False 字符串长度超过 20，也不会触发驻留机制： >>> s1 = \"Python\" * 10 >>> s2 = \"Python\" * 10 >>> s1 is s2 False 如果是空字符串，也会有驻留机制： >>> s1 = \"\" >>> s2 = \"\" >>> id(s1) 4360137392 >>> id(s2) 4360137392 绝对引用 字符串拥有绝对引用的特性，则无论是深拷贝还是浅拷贝，都不会获得其副本，而是直接对源对象进行引用： >>> import copy >>> oldStr = \"0\" * 100 >>> id(oldStr) 4373971144 >>> s1 = copy.copy(oldStr) >>> id(s1) 4373971144 >>> s2 = copy.deepcopy(oldStr) >>> id(s2) 4373971144 索引切片 字符串由于是线性结构，故支持索引和切片操作。 由于字符串是不可变类型，所以索引操作也仅支持获取数据项，不支持删改数据项。 使用方法参照列表的索引切片一节。 常用方法 方法一览 常用的 str 方法一览： 方法名 返回值 描述 strip() str 移除字符串两侧指定的字符，如不进行指定，则默认移除\\n、\\t 以及空格。 split() list 按照指定字符进行从左到右的分割，以列表形式返回。可指定 maxslipt 限制切分次数 rsplit() list 按照指定字符进行从右到左的分割，以列表形式返回。可指定 maxslipt 限制切分次数 join() str 将一个列表中的数据项以指定字符拼接成新的字符串 replace() str 将字符串中的指定子串替换成另一个子串 count() integer 统计子串在父串中出现的次数 title() str 令字符串中的每一个单词首字母大写 capitalize() Str 令字符串中的句首单词首字母变为大写 find() integer 查找子串首次出现在父串中的索引值，若存在则返回索引，若不存在则返回-1，从左至右查找 rfind() integer 同上，从右至左查找 upper() str 令字符串中所有的小写字母转换为大写 lower() str 令字符串中所有的大写字母转换为小写 startswith() bool 判断字符串是否以特定子串开头 endswith() bool 判断字符串是否以特定子串结束 isdigit() bool 判断该字符串是否是一个数字串 基础公用函数： 函数名 返回值 描述 len() integer 返回容器中的项目数 enumerate() iterator for index, value of iterable 返回一个可迭代对象，其中以小元组的形式包裹数据项与正向索引的对应关系 reversed() ... 详情参见函数章节 sorted() ... 详情参见函数章节 获取长度 使用 len()方法来进行字符串长度的获取。 返回 int 类型的值。 s1 = \"abcdefg\" print(len(s1)) # 7 Python 在对内置的数据类型使用 len()方法时，实际上是会直接的从 PyVarObject 结构体中获取 ob_size 属性，这是一种非常高效的策略。 PyVarObject 是表示内存中长度可变的内置对象的 C 语言结构体。 直接读取这个值比调用一个方法要快很多。 移除空白 使用 strip()方法移除字符串两侧指定的字符，如不进行指定，则默认移除\\n、\\t 以及空格。 返回 str 类型的值。 s1 = \" abcdefg $$$\" res = s1.strip(\" $\") print(res) # abcdefg 拆分列表 使用 split()方法按照指定字符进行从左到右的分割，以列表形式返回。可指定 maxslipt 限制切分次数。 返回 list 类型的值。 s1 = \"ab,cd,ef,gh\" res = s1.split(\",\",maxsplit=1) print(res) # ['ab', 'cd,ef,gh'] 使用 rsplit()方法按照指定字符进行从右到左的分割，以列表形式返回。可指定 maxslipt 限制切分次数。 返回 list 类型的值。 s1 = \"ab,cd,ef,gh\" res = s1.rsplit(\",\",maxsplit=1) print(res) # ['ab,cd,ef', 'gh'] 列表合并 使用 join()方法将一个列表中的数据项以指定字符拼接成新的字符串。 返回 str 类型的值。 l1 = [\"a\",\"b\",\"c\"] res = \"-\".join(l1) print(res) # a-b-c 替换操作 使用 replace()方法将字符串中的指定子串替换成另一个子串。 返回 str 类型的值。 s1 = \"ABCDEFG\" res = s1.replace(\"BCD\",\"bcd\") print(res) # AbcdEFG 次数统计 使用 count()方法统计子串在父串中出现的次数。 返回 int 类型的值。 s1 = \"HELLO\" res = s1.count(\"L\") print(res) # 2 词首大写 使用 title()方法令字符串中的每一个单词首字母大写。 返回 str 类型的值。 s1 = \"hello world\" res = s1.title() print(res) # Hello World 句首大写 使用 capitalize()方法令字符串中的句首单词变为大写。 返回 str 类型的值。 s1 = \"hello world\" res = s1.capitalize() print(res) # Hello world 索引位置 使用 find()方法查找子串首次出现在父串中的索引值，若存在则返回索引，若不存在则返回-1，这是从左至右查找，rfind()则是从右至左查找。 返回 int 类型的值。 s1 = \"hello world\" res = s1.find(\"w\") print(res) # 6 小写转大写 使用 upper()方法令字符串中所有的小写字母转换为大写。 返回 str 类型的值。 s1 = \"hello world\" res = s1.upper() print(res) # HELLO WORLD 大写转小写 使用 lower()方法令字符串中所有的大写字母转换为小写。 返回 str 类型的值。 s1 = \"HELLO WORLD\" res = s1.lower() print(res) # hello world 指定开头 使用 startswith()方法判断字符串是否以特定子串开头。 返回 bool 类型的值。 s1 = \"HELLO WORLD\" res = s1.startswith(\"HE\") print(res) # True 指定结尾 使用 endswith()方法判断字符串是否以特定子串结束。 返回 bool 类型的值。 s1 = \"HELLO WORLD\" res = s1.endswith(\"LD\") print(res) # False 数字串 使用 isdigit()方法判断该字符串是否是一个数字串。 返回 bool 类型的值。 s1 = \"100\" res = s1.isdigit() print(res) # True 其他方法 以下是一些其他不太常用的方法： 方法名 返回值 描述 index() integer 同 find()，唯一区别找不到抛出异常，find()是返回-1，从左至右查找 rindex() integer 同上，从右至左查找 swapcase() str 字符串中大小进行翻转。大写转小写，小写转大写。 expandtabs() str 指定字符串中的 tab 长度，\\t 代表制表符，默认长度为 8 center() str 指定宽度，指定字符。若字符串的长度不够则将字符串放在中间，两侧使用指定字符填充 ljust() str 指定宽度，指定字符。若字符串的长度不够则将字符串放在左边，右侧使用指定字符填充 rjust() str 指定宽度，指定字符。若字符串的长度不够则将字符串放在右边，左侧使用指定字符填充 zfill() str 同 rjust()，但是不可指定填充字符。按 0 进行填充 isdecimal() bool 判断字符串是否由数字组成。只支持 unicode 并且没有 bytes 的使用 isnumeric() bool 判断字符串是否由数字组成。只支持 unicode，中文数字，罗马数字并且没有 bytes 的使用 isalnum() bool 判断字符串是否仅由数字和字母构成 isalpha() bool 判断字符串是否仅由字母构成 isspace() bool 判断字符串是否仅由空格构成 islower() bool 判断字符串是否纯小写 isupper() bool 判断字符串是否纯大写 istitle() bool 判断字符串中的单词是否首字母大写 index()与 rindex()方法： s1 = \"Python\" s1.index(\"a\") s1.rindex(\"a\") # ValueError: substring not found 字符串翻转 swapcase()方法： s1 = \"Python\" print(s1.swapcase()) # pYTHON 指定制表符长度的 expandtabs()方法，默认制表符的长度为 8，下面指定为 4： s1 = \"P\\ty\\tt\\th\\to\\tn\" print(s1) print(s1.expandtabs(4)) # P y t h o n # P y t h o n 字符填充系列： s2 = \"H\" print(s2.center(20, \"+\")) print(s2.ljust(20, '+')) print(s2.rjust(20, '+')) print(s2.zfill(20)) # 0 填充，不可指定填充字符 # 其实总体来说就是将一个字符必须按照指定字符扩展为指定长度 # 区别在于源字符串的位置在指定填充符的中间、左侧、还是右侧 # +++++++++H++++++++++ # H+++++++++++++++++++ # +++++++++++++++++++H # 0000000000000000000H # 字符串填充可用在补位上 如将 int 1 转换为 str 001 >>> x = 1 >>> str(x).zfill(3) '001' 当 int 的值是三位数时，补位失效 >>> x = 100 >>> str(x).zfill(3) '100' 字符串判断系列之数字串检测： s1 = b\"4\" # 字节数字串 s2 = u\"4\" # unicode数字串，默认Python3的str就是unicode编码，可以不用加u s3 = \"四\" # 中文数字串 s4 = \"Ⅳ\" # 罗马数字串 # isdigt()检测是否为数字串，只支持bytes和unicode print(s1.isdigit()) # True print(s2.isdigit()) # True print(s3.isdigit()) # False print(s4.isdigit()) # False # isdecimal()检测是否为数字串，只支持unicode字符串，如果是bytes字节串则抛出异常 print(s2.isdecimal()) # True print(s3.isdecimal()) # False print(s4.isdecimal()) # False # isnumeric()检测是否为数字串，不支持bytes字节串，支持unicode字符串、中文数字串、罗马数字串 print(s2.isnumeric()) # True print(s3.isnumeric()) # True print(s4.isnumeric()) # True 字符串判断之成员检测： s1 = \"Python3.6.8\" # isalnum() 判断字符串是否仅由数字和字母构成 print(s1.isalnum()) # False # isalpha() 判断字符串是否仅由字母构成 print(s1.isalpha()) # False # isspace() 判断字符串是否仅由空格构成 print(s1.isspace()) # False 字符串判断之大小写检测： s1 = \"Python3.6.8\" # islower() 判断字符串是否纯小写 print(s1.islower()) # False # isupper() 判断字符串是否纯大写 print(s1.isupper()) # False # istitle() 判断字符串中的单词是否首字母大写 print(s1.istitle()) # True 版本区别 数字与字符串对比 在 Python2 中是支持字符串与数字进行比较的，字符串永远比数字大： >>> \"0\" > 1 True 但是在 Python3 中，这种比较会抛出异常： >>> \"0\" > 1 Traceback (most recent call last): File \"\", line 1, in TypeError: '>' not supported between instances of 'str' and 'int' 表现形式 Python2 的字符串表现形式为原始字节序列，也就是说 Python2 的 str 其实实际上是 Python3 的字节串，故仅支持在 ASCII 码表之内的字符： >>> s1 = \"你好，世界\" >>> s1 '\\xe4\\xbd\\xa0\\xe5\\xa5\\xbd\\xef\\xbc\\x8c\\xe4\\xb8\\x96\\xe7\\x95\\x8c' 但是在 Python3 中的字符串表现形式不是这样的，Python3 中的字符串统一都为 Unicode 字符串： >>> s1 = \"你好，世界\" >>> s1 '你好，世界' 底层探究 扁平序列 这里引出一个新的概念，线性扁平序列。 扁平序列其实更加紧凑，但是它里面只能存放诸如字符、字节和数值这种基础类型 扁平序列里存放的是值而不是引用 扁平序列不支持多维的说法，仅有一个维度 字符串为什么要设计成不可变类型？这是由于字符串内部是采用连续存储的方式。 因为字符串是连续的一块内存存放（在 c 语言体现中其实是一个数组，以\\0 结尾），被看做为一个整体，修改其中某一个数据项那么必定会导致后面的内存发生变化，链式反应滚起雪球需要处理的数据量很庞大，于是 Python 干脆不支持修改字符串。 strobject.c 源码 官网参考：点我跳转 源码一览：点我跳转 关于字符串的源码阅读，感兴趣的朋友可以看一下，这里不再进行延伸阅读。 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-08-16 17:26:46 "},"Python/Python基础知识/字典类型.html":{"url":"Python/Python基础知识/字典类型.html","title":"字典类型","keywords":"","body":"字典 Python中的字典（dict）也被称为映射（mapping）或者散列（hash），是支持Python底层实现的重要数据结构。 同时，它也是应用最为广泛的数据结构，内部采用hash存储，存储方式为键值对。 字典本身属于可变容器类型，但键（key）必须为不可变类型，而值（value）可以是任意类型。。 字典的优点是单点查找速度极快，但不能够支持范围查找，此外也比较占用内存。 字典特性 字典特性如下： 字典是一个可变的容器类型 字典内部由散列表组成 字典的单点读写速度很快，但是不支持范围查找 字典的key必须是不可变的，只有不可变对象才能被hash 字典在3.6之后变得有序了，这样做提升了遍历效率 基本声明 以下是使用类实例化的形式进行对象声明： userInfo = dict(name=\"YunYa\", age=18, hobby=[\"football, music\"]) print(\"value : %r\\ntype : %r\" % (userInfo, type(userInfo))) # value : {'name': 'YunYa', 'age': 18, 'hobby': ['football, music']} # type : 也可以选择使用更方便的字面量形式进行对象声明，使用{}对键值对进行包裹，键值对采用k:v的形式分割，多个键值对之间使用逗号进行分割： userInfo = {\"name\": \"YunYa\", \"age\": 18, \"hobby\": [\"football, music\"]} print(\"value : %r\\ntype : %r\" % (userInfo, type(userInfo))) # value : {'name': 'YunYa', 'age': 18, 'hobby': ['football, music']} # type : 声明字典时，千万注意key只能是不可变类型。 如字符串（str），整形（int），浮点型（float），布尔型（bool），元组类型（tuple）等等均可设置为字典的key，但使用可变类型作为key时则会抛出异常。 续行操作 在Python中，字典中的键值对如果过多，可能会导致整个字典太长，太长的字典是不符合PEP8规范的。 每行最大的字符数不可超过79，文档字符或者注释每行不可超过72 Python虽然提供了续行符\\，但是在字典中可以忽略续行符，如下所示： userInfo = { \"name\": \"YunYa\", \"age\": 18, \"hobby\": [\"football, music\"]} print(\"value : %r\\ntype : %r\" % (userInfo, type(userInfo))) # value : {'name': 'YunYa', 'age': 18, 'hobby': ['football, music']} # type : 多维嵌套 字典中可以进行多维嵌套，如字典套字典，字典套元组，字典套列表等： dic = { \"k1\": [1, 2, 3], \"k2\": (1, 2, 3), \"k3\": { \"k3-1\": 1, \"k3-2\": 2, }, } 类型转换 字典可以与布尔类型和字符串进行转换，这是最常用的： dic = {\"k1\": \"v1\", \"k2\": \"v2\"} boolDict = bool(dic) strDict = str(dic) print(\"value : %r\\ntype : %r\" % (boolDict, type(boolDict))) print(\"value : %r\\ntype : %r\" % (strDict, type(strDict))) # value : True # type : # value : \"{'k1': 'v1', 'k2': 'v2'}\" # type : 如果要将字典转换为列表、元组、集合类型，直接转换只会拿到键，并不会拿到值。 尤其注意这一点，但是其实这样用的场景十分少见，记住就行了： dic = {\"k1\": \"v1\", \"k2\": \"v2\"} listDict = list(dic) tupleDict = tuple(dic) setDict = set(dic) print(\"value : %r\\ntype : %r\" % (listDict, type(listDict))) print(\"value : %r\\ntype : %r\" % (tupleDict, type(tupleDict))) print(\"value : %r\\ntype : %r\" % (setDict, type(setDict))) # value : ['k1', 'k2'] # type : # value : ('k1', 'k2') # type : # value : {'k1', 'k2'} # type : 重复key 一个字典中的key必须是唯一的，若不是唯一的则value可能面临被覆盖的危险： dic = {\"name\": \"云崖\", \"age\": 18, \"name\": \"Yunya\"} print(dic) # {'name': 'Yunya', 'age': 18} 同理，True和1，False和0也会彼此进行覆盖： dic = {True: \"云崖\", \"age\": 18, 1: \"Yunya\"} print(dic) # {True: 'Yunya', 'age': 18} []操作字典 由于字典并非线性结构，故不支持索引操作。 但是字典也提供了[]操作语法，它是根据key来操作value的。 增删改查 以下示例展示了如何使用[]对字典中的value进行操纵： dic = {\"k1\": \"v1\", \"k2\": \"v2\"} # 增 dic[\"k3\"] = \"v3\" print(dic) # {'k1': 'v1', 'k2': 'v2', 'k3': 'v3'} # 删，如果没有该key，则抛出keyError del dic[\"k2\"] print(dic) # {'k1': 'v1', 'k3': 'v3'} # 改，如果没有该key，则抛出keyError dic[\"k3\"] = \"VV3\" print(dic) # {'k1': 'v1', 'k3': 'VV3'} # 查，如果没有该key，则抛出keyError result = dic[\"k1\"] print(result) # v1 多维操作 字典套列表的多维操作如下，首先需要拿到该列表： dic = {\"k1\": [1, 2, 3, 4]} # 取出3 result = dic[\"k1\"][2] print(result) # 3 # k1的列表，添加数据项 \"A\" dic[\"k1\"].append(\"A\") print(dic) # {'k1': [1, 2, 3, 4, 'A']} 字典套字典的多维操作如下，首先需要拿到被操纵的字典： dic = { \"k1\":{ \"k1-1\":{ \"k1-2\":{ \"k1-3\":\"HELLO,WORLD\", } } } } # 拿到 k1-3 对应的value result = dic[\"k1\"][\"k1-1\"][\"k1-2\"][\"k1-3\"] print(result) # HELLO,WORLD 解构语法 **语法 **语法用于将字典中的k:v全部提取出来。 我们可以利用该语法的特性来对字典进行合并，将两个旧字典合并成一个新字典： dic_1 = {\"d1k1\": \"A\", \"d1k2\": \"B\"} dic_2 = {\"d2k1\": \"C\", \"d2k2\": \"D\"} result = {**dic_1, **dic_2} print(result) # {'d1k1': 'A', 'd1k2': 'B', 'd2k1': 'C', 'd2k2': 'D'} 解构赋值 字典支持平行变量赋值操作吗？当然可以！但是这样只会拿到字典的key： dic = {\"k1\": \"v1\", \"k2\": \"v2\"} first, last = dic print(first) print(last) # k1 # k2 有办法拿到value么？借助字典的values()方法即可做到，它的本质是将value全部提取出来，组成一个可迭代对象： dic = {\"k1\": \"v1\", \"k2\": \"v2\"} first, last = dic.values() print(first) print(last) # v1 # v2 你可以理解为，将value全部提取出来组成一个列表，类似于[“v1”, “v2”]，在Python2中的确是这样，但是到了Python3中做法改变了，目前按下不表。 对于一些不想要的数据项，你也可以按照列表的解构赋值操作来进行，这里不再举例。 常用方法 方法一览 常用的dict方法一览： 方法名 返回值 描述 get() v or None 取字典key对应的value，如果key不存在返回None setdefault() v 获取字典key对应的value，如该字典中不存在被获取的key则会进行新增k:v，并返回v update() None 对原有的字典进行更新 pop() v 删除该字典中的键值对，如果不填入参数key或者key不存在则抛出异常 keys() Iterable 返回一个可迭代对象，该可迭代对象中只存有字典的所有key values() Iterable 返回一个可迭代对象，该可迭代对象中只存有字典的所有value items() Iterable 返回一个可迭代对象，该可迭代对象中存有字典中所有的key与value，类似于列表套元组 clear() None 清空当前字典 基础公用函数： 函数名 返回值 描述 len() integer 返回容器中的项目数 获取长度 使用len()方法来进行字典长度的获取。 返回int类型的值。 dic = {\"name\": \"云崖\", \"age\": 18} print(len(dic)) # 2 一组键值对被视为一个数据项，故2组键值对长度为2 Python在对内置的数据类型使用len()方法时，实际上是会直接的从PyVarObject结构体中获取ob_size属性，这是一种非常高效的策略。 PyVarObject是表示内存中长度可变的内置对象的C语言结构体。 直接读取这个值比调用一个方法要快很多。 get() 使用get()方法获取字典key对应的value，相比于[]操作更加的人性化，因为[]一旦获取不存在的key则会抛出异常，而该方法则是返回None。 dic = {\"name\": \"云崖\", \"age\": 18} username = dic.get(\"name\") userhobby = dic.get(\"hobby\") print(\"用户姓名:\",username) print(\"用户爱好:\",userhobby) # 用户姓名: 云崖 # 用户爱好: None setdefault() 使用setdefault()方法来获取字典key对应的value，如该字典中不存在被获取的key则会进行新增k:v，并返回v。 返回字典原有的value或者新设置的k:v。 dic = {\"name\": \"云崖\", \"age\": 18} # 字典有name，则取字典里的name username = dic.setdefault(\"name\",\"云崖先生\") # 字典没有hobby，则设置hobby的value为足球与篮球并返回 userhobby = dic.setdefault(\"hobby\",\"足球与篮球\") print(\"用户姓名:\",username) print(\"用户爱好:\",userhobby) # 用户姓名: 云崖 # 用户爱好: 足球与篮球 update() 使用update()方法对原有的字典进行更新。 返回None。 dic = {\"name\": \"云崖\", \"age\": 18} dic.update( {\"hobby\": [\"篮球\", \"足球\"]} ) print(dic) # {'name': '云崖', 'age': 18, 'hobby': ['篮球', '足球']} pop() 使用pop()方法删除该字典中的键值对，如果不填入参数key或者key不存在则抛出异常。 返回被删除的value。 dic = {\"name\": \"云崖\", \"age\": 18} result = dic.pop(\"age\") print(result) print(dic) # 18 # {'name': '云崖'} keys() 返回一个可迭代对象，该可迭代对象中只存有字典的所有key。 Python2中返回的是列表，Python3中返回的是可迭代对象。 dic = {\"name\": \"云崖\", \"age\": 18} key_iter = dic.keys() print(key_iter) # dict_keys(['name', 'age']) Python3中返回的对象被称为字典视图。它们提供了字典条目的一个动态视图，这意味着当字典改变时，视图也会相应改变。 values() 返回一个可迭代对象，该可迭代对象中只存有字典的所有value。 Python2中返回的是列表，Python3中返回的是可迭代对象。 dic = {\"name\": \"云崖\", \"age\": 18} value_iter = dic.values() print(value_iter) # dict_values(['云崖', 18]) Python3中返回的对象被称为字典视图。它们提供了字典条目的一个动态视图，这意味着当字典改变时，视图也会相应改变。 items() 返回一个可迭代对象，该可迭代对象中存有字典中所有的key与value，类似于列表套元组。 Python2中返回的是二维列表，Python3中返回的是可迭代对象。 dic = {\"name\": \"云崖\", \"age\": 18} items_iter = dic.items() print(items_iter) # dict_items([('name', '云崖'), ('age', 18)]) Python3中返回的对象被称为字典视图。它们提供了字典条目的一个动态视图，这意味着当字典改变时，视图也会相应改变。 clear() 清空当前字典。 返回None。 dic = {\"name\": \"云崖\", \"age\": 18} dic.clear() print(dic) # {} 其他方法 方法 返回值 描述 popitem() (k, v) 随机删除一组键值对,并将删除的键值放到元组内返回 fromkeys(iter,value) dict 第一个参数是可迭代对象，其中每一个数据项都为新生成字典的key，第二个参数为同一的value值 示例演示： dic1 = dict(k1=\"v1\", k2=\"v2\", k3=\"v3\", k4=\"v4\") print(dic1.popitem()) # ('k4', 'v4') dic2 = dict.fromkeys([1, 2, 3, 4], None) print(dic2) # {1: None, 2: None, 3: None, 4: None} 底层探究 高效查找 为什么要有字典这种数据结构？ 如果对一个无序的列表查找其中某一个value（前提是不能对列表进行排序），必须经过一个一个的遍历，速度会很慢。 [3, 2, 8, 9, 11, 13] # 如果要获取数据项11，必须经过5次查找 有没有一种办法，能够让速度加快？ 为了不违背不能排序的前提，我们只能在列表存入value的时候做文章。 我们可以为每个value都造一个独一无二的身份标识，根据这个身份标识符计算出value需要插入到列表的索引位置。 在取的时候同理，通过身份标识符直接就可以拿到value所在列表的索引值，无疑速度会快很多。 一个小总结： 有一个身份标识，身份标识必须是唯一的 提供一个根据身份标识计算出插入位置的算法 回到字典的本质，字典的key就是value的身份标识，而根据key计算出插入位置的算法被封装在了hash()函数中，这个算法也被称之为hash算法。 为什么key必须是唯一的，参照下面这个示例： [\"k1\", \"k2\", \"k3\", \"k4\", \"k5\", \"k6\"] ↓ ↓ ↓ ↓ ↓ ↓ [ 3, 2, 8, 9, 11, 13] 假如k5变成了k6，那么就有2个k6对应2个不同的value 这么做的后果就是，使用k6获取value的时候，根本不知道你需要的value是哪一个 所以，干脆Python规定，key必须是不可变类型！如果有重复则新的覆盖旧的。 或者说，只有不可变对象才能被hash。 hash过程 如何通过hash()函数，确定value的插入位置？ 实际上每个键值对在存入字典之前，都会通过hash()函数对key计算出一个hash值（也被称为散列值）： >>> hash(\"k1\") 7036545863130266253 而字典的底层结构是由一个2维数组嵌套组成的，也被称为散列表、hash表。 如下所示，每次创建字典的时候，字典都会初始化生成一个固定长度且内容全是空的2维数组，Python内部生成的散列表长度为8（可参见dictobject.c结构体源码）： [ ① ② ③ [空, 空, 空], index: 0 [空, 空, 空], index: 1 [空, 空, 空], index: 2 [空, 空, 空], index: 3 [空, 空, 空], index: 4 [空, 空, 空], index: 5 [空, 空, 空], index: 6 [空, 空, 空] index: 7 ] ❶：存放根据key计算出的hash值 ❷：存放key的引用 ❸：存放value的引用 现在，我们要存储name:yunya的键值对，对name计算hash值： >>> hash(\"name\") 3181345887314224636 用计算出的hash值与散列表长度进行求余运算： >>> 3181345887314224636 % 8 4 得到结果是4，就在散列表4的索引位置插入： [ ① ② ③ [空, 空, 空], index: 0 [空, 空, 空], index: 1 [空, 空, 空], index: 2 [空, 空, 空], index: 3 [3181345887314224636, \"name\"的引用, \"yunya\"], index: 4 [空, 空, 空], index: 5 [空, 空, 空], index: 6 [空, 空, 空] index: 7 ] 再次插入age:18，并用计算出的hash值与散列表长度进行求余运算: >>> hash(\"age\") 7064862892218627464 >>> 7064862892218627464 % 8 0 得到的结果是0，就在散列表0的索引位置插入： [ ① ② ③ [7064862892218627464, \"age\"的引用, 18], index: 0 [空, 空, 空], index: 1 [空, 空, 空], index: 2 [空, 空, 空], index: 3 [3181345887314224636, \"name\"的引用, \"yunya\"], index: 4 [空, 空, 空], index: 5 [空, 空, 空], index: 6 [空, 空, 空] index: 7 ] 可以看见，这个2维数组不是按照顺序进行插入的，总有一些空的位置存在，因此该数组也被称为稀松数组。 由于数组是稀松的，所以dict不支持范围获取（能获取到空值），但单点存取的速度很快。 读取的时候也同理，但是Python的hash函数底层实现是否真的利用hash值对稀松数组长度进行简单的求余运算，这个还有待商榷。 因为hash算法的实现有很多种，长度求余只是最为简单的一种而已，这里用作举例，如果想具体了解其算法可以查看Python源码，dictobject.c中的perturb。 散列冲突 现在，我们的这个散列表中0和4的索引位置都已经存在数据了。 如果现在存入一个teacher:wang，那么结果会是怎么样？ >>> hash(\"teacher\") 4789346189807557228 >>> 4789346189807557228 % 8 4 可以发现，teacher的hash值求余算结果也是4，这个时候就会发生散列冲突。 最常见的做法是，向后挪！因为索引5的位置是空的，我们可以将这个键值对插入到索引5的位置： [ ① ② ③ [7064862892218627464, \"age\"的引用, 18], index: 0 [空, 空, 空], index: 1 [空, 空, 空], index: 2 [空, 空, 空], index: 3 [3181345887314224636, \"name\"的引用, \"yunya\"], index: 4 [4789346189807557228, \"teacher\"的引用, \"wang\"], index: 5 [空, 空, 空], index: 6 [空, 空, 空] index: 7 ] 这种查找空位的方法叫做开放定址法（openaddressing），向后查找也被称为线性探测（linearprobing）。 如果此时又插入一个数据项，最后key的插入索引位置也是4，则继续向后查找空位，如果查找到7还是没有空位，又从0开始找。 上述方法是解决散列冲突的基础方案，当然也还有更多的其他解决方案，这里再说就过头了，放在后面数构一章中再进行介绍吧。 扩容机制 Python的dict会对散列表的容量做出判定。 当容量超过三分之二时，即进行扩容（resize）机制。 如果散列表大小为8，在即将插入第5个键值对时进行扩容，扩容策略为已有散列表键值对个数 * 2。 即散列表大小扩展为18 (5 * 2 + 8)。 如果整个散列表已有键值对个数达到了50000，则扩容策略为已有散列表键值对个数 * 4。 此外，dict只会进行扩容，不会进行缩容，如果删除了1个键值对，其内存空间占用的位置并不会释放。 不同key的优化 整形是其本身 整形的hash值是其本身： >>> hash(1) 1 >>> hash(2) 2 >>> hash(3) 3 >>> hash(10000) 10000 加盐策略 在Python3.3开始，str、bytes、datetime等对象在计算散列值的时候会进行加盐处理。 这个盐引用内部的一个常量，该常量在每次CPython启动时会生成不同的盐值。 所以你会发现每次重启Python3.3以后的解释器，对相同字符串进行hash()求散列值得出的结果总是不一样的： $ python3 Python 3.6.8 (v3.6.8:3c6b436a57, Dec 24 2018, 02:04:31) [GCC 4.2.1 Compatible Apple LLVM 6.0 (clang-600.0.57)] on darwin Type \"help\", \"copyright\", \"credits\" or \"license\" for more information. >>> hash(\"k1\") 8214688532022610754 >>> exit() $ python3 Python 3.6.8 (v3.6.8:3c6b436a57, Dec 24 2018, 02:04:31) [GCC 4.2.1 Compatible Apple LLVM 6.0 (clang-600.0.57)] on darwin Type \"help\", \"copyright\", \"credits\" or \"license\" for more information. >>> hash(\"k1\") -7444020267993088839 >>> exit() 再看Python2.7，由于没有加盐策略，所以每次重启Python解释器后相同key得到的hash结果是相同的： $ python Python 2.7.10 (default, Feb 22 2019, 21:55:15) [GCC 4.2.1 Compatible Apple LLVM 10.0.1 (clang-1001.0.37.14)] on darwin Type \"help\", \"copyright\", \"credits\" or \"license\" for more information. >>> hash(\"k1\") 13696082283123634 >>> exit() $ python Python 2.7.10 (default, Feb 22 2019, 21:55:15) [GCC 4.2.1 Compatible Apple LLVM 10.0.1 (clang-1001.0.37.14)] on darwin Type \"help\", \"copyright\", \"credits\" or \"license\" for more information. >>> hash(\"k1\") 13696082283123634 >>> exit() 有序字典 字典无序的观念似乎已经深入人心，但那已经都是过去式了。 在Python3.6之后，字典变的有序了。 2012年12月10日星期一的时候，R. David Murray向Python官方发送了一封邮件，提出建议让Python的字典变的有序。 这样的做法能够让Python字典的空间占用量更小，迭代速度更快，以下是邮件内容： https://mail.python.org/pipermail/python-dev/2012-December/123028.html 我们先看看2.7中的字典： >>> {chr(i) : i for i in range(10)} {'\\x01': 1, '\\x00': 0, '\\x03': 3, '\\x02': 2, '\\x05': 5, '\\x04': 4, '\\x07': 7, '\\x06': 6, '\\t': 9, '\\x08': 8} 再来看3.6中的字典： >>> {chr(i) : i for i in range(10)} {'\\x00': 0, '\\x01': 1, '\\x02': 2, '\\x03': 3, '\\x04': 4, '\\x05': 5, '\\x06': 6, '\\x07': 7, '\\x08': 8, '\\t': 9} 果然！它确实变的有序了，关于具体细节，可以参照这封邮件，已经表述的很清楚了，下面做一个简单的示例。 首先，以前的散列表就是一个单纯的稀松二维数组： [ [空, 空, 空], index: 0 [空, 空, 空], index: 1 [空, 空, 空], index: 2 ... ] 键值对的读取顺序来源与填加顺序。 索引靠前的会被先遍历拿到，索引靠后只能后被遍历出来。 如果这个散列表长度为8，前7个都没有数据项存入，仅有8才有，那么遍历完整个散列表需要8次： [ [空, 空, 空], index: 0 [空, 空, 空], index: 1 [空, 空, 空], index: 2 ... [hash值, key的引用, value的引用], index: 7 ] 而Python3.6之后，又新增了一个顺序数组，该数组与散列表的长度相等，初始均为8，并且会跟随散列表的扩容而进行扩容，如下示例初始状态： [None, None, None, ...] [ [空, 空, 空], index: 0 [空, 空, 空], index: 1 [空, 空, 空], index: 2 ... ] 如果说第1个键值对，被插入到散列表索引1的位置，那么在顺序数组中，则在索引0处记录下该键值对被插入在散列表中的位置(1)，如下图所示： [1, None, None, ...] [ [空, 空, 空], index: 0 [hash值, key的引用, value的引用], index: 1 [空, 空, 空], index: 2 ... ] 如果第2个键值对，被插入到散列表索引0的位置，那么在顺序数组中，则在索引1处记录下该键值对被插入在散列表中的位置(0)，如下图所示： [1, 0, None, ...] [ [hash值, key的引用, value的引用], index: 0 [hash值, key的引用, value的引用], index: 1 [空, 空, 空], index: 2 ... ] 再插入一个键值对，该键值对被插到了索引7的位置，那么在顺序数组中，则在索引2处记录下该键值对被插入在散列表中的位置(7)，如下图所示： [1, 0, 7, None, None, None, None, None] [ [hash值, key的引用, value的引用], index: 0 [hash值, key的引用, value的引用], index: 1 [空, 空, 空], index: 2 ... [hash值, key的引用, value的引用], index: 7 ] 在遍历的时候，会遍历这个顺序数组，然后通过索引值拿到散列表中对应位置的数据项，如果遍历到的值为None就结束遍历，而不用遍历完整个散列表： 类似于： hashTableOrderArray = [1, 0, 7, None, None, None, None, None] hashTable = [ [\"hash\", \"k2\", \"v2\"], [\"hash\", \"k1\", \"v1\"], [None, None, None], [None, None, None], [None, None, None], [None, None, None], [None, None, None], [\"hash\", \"k3\", \"v3\"], ] n = 0 while n 这样只需遍历3次即可，而如果没有这个顺序数组，则要完整遍历整个散列表，即8次才能拿出所有的键值对。 dictobject.c源码 官网参考：点我跳转 源码一览：点我跳转 关于字典的源码阅读，感兴趣的朋友可以看一下，这里不再进行延伸阅读。 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:46 "},"Python/Python基础知识/集合类型.html":{"url":"Python/Python基础知识/集合类型.html","title":"集合类型","keywords":"","body":"集合 Python中的集合（set）内部存储也采用hash存储，所以说它也可以归类为映射容器类型之中。 集合与字典有很多类似之处，你可以将集合理解为没有value的字典（仅有key）。 集合本身是可变的数据类型，但是其内部数据项必须是不可变的，能被hash()的对象，这与字典的key特性相同。 集合特性 集合特性如下： 集合是一个可变的容器类型 集合中的数据项必须是不可变类型 集合更多的是用来操纵数据，而不是存储数据 嗯，再说一个冷门知识点，集合的速度比字典的存读速度更快！因为它的数据项仅有1部分，而字典的数据项拥有2部分，即key与value。 基本声明 以下是使用类实例化的形式进行对象声明： s = set((1, 2, 3, 4, 5)) print(\"value : %r\\ntype : %r\" % (s, type(s))) # value : {1, 2, 3, 4, 5} # type : 也可以选择使用更方便的字面量形式进行对象声明，使用{}对数据项进行包裹，每个数据项间用逗号进行分割： s = {1, 2, 3, 4, 5} print(\"value : %r\\ntype : %r\" % (s, type(s))) # value : {1, 2, 3, 4, 5} # type : 注意一个集合声明的陷阱，如果要声明一个空集合必须使用类实例的形式进行声明。 如果用一个空的{}进行字面量声明会生成一个字典。 声明集合时，千万注意数据项只能是不可变类型。 如字符串（str），整形（int），浮点型（float），布尔型（bool），元组类型（tuple）等等，使用可变类型作为数据项加入至集合中会抛出TypeError异常。 续行操作 在Python中，集合中的数据项如果过多，可能会导致整个集合太长，太长的集合是不符合PEP8规范的。 每行最大的字符数不可超过79，文档字符或者注释每行不可超过72 Python虽然提供了续行符\\，但是在集合中可以忽略续行符，如下所示： s = { 1, 2, 3, 4, 5 } print(\"value : %r\\ntype : %r\" % (s, type(s))) # value : {1, 2, 3, 4, 5} # type : 类型转换 集合可以和布尔型、列表、元组、字符串类型进行转换： s = {1, 2, 3, 4, 5} boolSet = bool(s) strSet = str(s) listSet = list(s) tupleSet = tuple(s) print(\"value : %r\\ntype : %r\" % (boolSet, type(boolSet))) print(\"value : %r\\ntype : %r\" % (strSet, type(strSet))) print(\"value : %r\\ntype : %r\" % (listSet, type(listSet))) print(\"value : %r\\ntype : %r\" % (tupleSet, type(tupleSet))) # value : True # type : # value : '{1, 2, 3, 4, 5}' # type : # value : [1, 2, 3, 4, 5] # type : # value : (1, 2, 3, 4, 5) # type : 无序特性 Python本身并未对集合新增顺序数组，因此集合不论是Python3还是Python2中都是无序的。 Python2.7.10示例： >>> {chr(i) for i in range(10)} set(['\\x01', '\\x00', '\\x03', '\\x02', '\\x05', '\\x04', '\\x07', '\\x06', '\\t', '\\x08']) Python3.6.8示例： >>> {chr(i) for i in range(10)} {'\\x07', '\\x06', '\\t', '\\x02', '\\x00', '\\x05', '\\x04', '\\x03', '\\x01', '\\x08'} 去重特性 得益于内部hash存储方式，集合具有去处重复的特性，我们可以让其与列表结合，将列表中重复的数据项剔除： repeatList = [1, 1, 2, 2, 3, 4, 5, 1, 2] newList = list(set(repeatList)) print(newList) # [1, 2, 3, 4, 5] 集合中的数据项怎么拿出来 集合虽然是容器类型，但是更多的作用是操作数据项，存储非它所长（存了就不好取了）。 集合没有提供[]语法： 它没有key，无法像字典一样通过key来操作value 也没有index，因为它不是顺序存储的线性结构。 虽然set中没有提供单拿数据项的方法，但是我们可以将其转换为list后再通过index将某个数据项拿出来。 或者是通过遍历。 常用方法 常用的set方法一览，set有一部分方法可以进行符号操作： 方法名 符号表示 返回值 描述 add() 无 None 为集合中新增数据项 pop() 无 Data item 弹出随机数据项 remove() 无 None 删除指定数据项，若不存在则抛出异常 discard() 无 None 同上、但不存在不会抛出异常 clear() 无 None 清空集合 copy() 无 set 对集合进行浅拷贝 update() 无 None 原地更新集合 intersection() & set 求a集合与b集合的交集 difference() - set 求a集合与b集合的差集 union() | set 求a集合与b集合的合集/并集 symmetric_difference() ^ set 求a集合与b集合的对称差集 issuperset() >或者>= bool 判定a集合是否为b集合的父级 issubset() bool 判断a集合是否为b集合的子集 isdisjoint() 无 bool 判断两个集合是否完全独立没有共同部分返回 intersection_update() 无 None 求出a集合与b集合的交集后并更新a集合 difference_update() 无 None 求出a集合与b集合的差集后并更新a集合 基础公用函数： 函数名 返回值 描述 len() integer 返回容器中的项目数 数据管理 示例演示： s1 = set() # 增加数据项 s1.add(1) print(s1) # {1} # 更新数据项 s1.update({2, 3, 4, 5}) print(s1) # {1, 2, 3, 4, 5} # 删除数据项， 不存在则抛出异常 s1.remove(2) print(s1) # {1, 3, 4, 5} # 删除数据项， 即使不存在也不会抛出异常 s1.discard(2) print(s1) # {1, 3, 4, 5} # 随机弹出数据项 print(s1.pop()) # 1 print(s1) # {3, 4, 5} # 浅拷贝 print(s1.copy()) # {3, 4, 5} # 清空数据项 s1.clear() print(s1) # set() 关系图解 集合关系图示： 关系获取 示例演示： s1 = {1, 2, 3, 4, 5} s2 = {4, 5, 6, 7, 8} # 交集 print(s1 & s2) print(set.intersection(s1, s2)) # {4, 5} # 差集 print(s1 - s2) print(set.difference(s1, s2)) # {1, 2, 3} # 合集、并集 print(s1 | s2) print(set.union(s1, s2)) # {1, 2, 3, 4, 5, 6, 7, 8} # 对称差集 print(s1 ^ s2) print(set.symmetric_difference(s1, s2)) # {1, 2, 3, 6, 7, 8} # 父子集 s3 = {1, 2, 3} s4 = {1,2} # 父级 print(s3 > s4) print(s3 >= s4) print(set.issuperset(s3, s4)) # True # 子集 print(s4 不可变的集合 frozenset()创建的集合拥有元组的特性，一旦集合创建完成后将不可以修改。 fs = frozenset((1, 2, 3)) print(fs) # frozenset({1, 2, 3}) 可以与普通的set集合进行关系获取，但是不能够进行数据项管理（可以copy，copy也是绝对引用）。 2.3以前怎么办 Python2.3的set和frozenset首次以模块的形式加入到Python中。 并且在Python2.6之后，提升为内置模块。 在Python2.3以前，我们常用字典来进行与集合相同的操作，因为字典的key也具有去重的特性嘛！ repeatList = [1, 1, 2, 2, 3, 4, 5, 1, 2] newList = list(dict.fromkeys(repeatList, None).keys()) print(newList) # [1, 2, 3, 4, 5] 如果是求交叉并集这种关系，则实现会更加复杂一点，这里不再举例。 dictobject.c源码 官网参考：点我跳转 源码一览：点我跳转 关于集合的源码阅读，感兴趣的朋友可以看一下，这里不再进行延伸阅读。 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:46 "},"Python/Python基础知识/布尔类型.html":{"url":"Python/Python基础知识/布尔类型.html","title":"布尔类型","keywords":"","body":"布尔类型 布尔类型的值被称为布尔值，常用于分支流程中，仅有2种表现形式： True：代表条件为真 False：代表条件为假 布尔属于不可变类型，同时也是基础的原子类型，即不可分割，不能容纳其他对象。 基本声明 以下是使用类实例化的形式进行对象声明： term = bool(True) print(\"value : %r\\ntype : %r\" % (term, type(term))) # value : True # type : 也可以选择使用更方便的字面量形式进行对象声明： term = True print(\"value : %r\\ntype : %r\" % (term, type(term))) # value : True # type : 类型转换 布尔值仅能转换为数字、字符串，使用对应的工厂函数即可： termTrue = True termFalse = False iTrue = int(termTrue) iFalse = int(termFalse) fTrue = float(termTrue) fFalse = float(termFalse) sTrue = str(termTrue) sFalse = str(termFalse) print(\"value : %r\\ntype : %r\" % (iTrue, type(iTrue))) print(\"value : %r\\ntype : %r\" % (iFalse, type(iFalse))) print(\"value : %r\\ntype : %r\" % (fTrue, type(fTrue))) print(\"value : %r\\ntype : %r\" % (fFalse, type(fFalse))) print(\"value : %r\\ntype : %r\" % (sTrue, type(sTrue))) print(\"value : %r\\ntype : %r\" % (sFalse, type(sFalse))) # value : 1 # type : # value : 0 # type : # value : 1.0 # type : # value : 0.0 # type : # value : 'True' # type : # value : 'False' # type : 除此之外，使用bool()将任意类型对象包裹均能获得其布尔值的表现形式。 以下举例Python内置数据类型在不同状态下的布尔值表示： 类型 True False int&float 不为0 为0 str&bytes 不为空串 为空串 list&tuple 不为空序列 为空序列 dict&set 不为空映射 为空映射 示例如下： >>> # --- int & float --- >>> bool(0) False >>> bool(1) True >>> bool(-1) True >>> bool(0.1) True >>> bool(-0.1) True >>> # --- str & bytes --- >>> bool(\"\") False >>> bool(b\"\") False >>> bool(\"string\") True >>> bool(b\"bytes\") True >>> # --- list & tuple --- >>> bool(list()) False >>> bool(tuple()) False >>> bool(list((1, 2, 3))) True >>> bool(tuple((1, 2, 3))) True >>> # --- dict & set --- >>> bool(dict()) False >>> bool(set()) False >>> bool(dict(k1=\"v1\", k2=\"v2\")) True >>> bool(set((\"ele1\", \"ele2\"))) True 布尔常量池 True和False是会被经常使用到的，因此在Python解释器启动时就会进行创建，我将他两归类为布尔常量池中（实际上并不存在）。 与小整数常量池中的数字类似，即使经历不同的实例化过程，但每次得到的True和False都来自同一引用： >>> id(True) 4495471488 >>> id(False) 4495471456 >>> id(bool(1)) 4495471488 >>> id(bool(0)) 4495471456 True&False与1&0 布尔值参与四则运算的时候，True等价于1，False等价于0： >>> True + 1 2 >>> False + 1 1 >>> True - False 1 实际上，True和False当采用运算时将会从小整数池中取出1和0，但是若使用id()方法查看True和1的地址号，会发现是不同的： >>> id(True) 4495471488 >>> id(1) 4495853616 为什么会出现这种情况？其实点开bool类型的源代码就可以发现，在Python3中bool类继承至int类： class bool(int): 当传入一个任意类型构建bool类的实例对象时，通过内部一系列判定都会返回True或者False这种形式。 若要将布尔类型直接参与运算（四则运算、hash运算），则会通过内部某种特殊的机制拿到1或者0。 id()方法返回的是对象的地址号，而bool的实例对象和int的实例对象必定在堆区内存中由不同的位置进行存储，故它们的结果不一样。 而运算时，布尔类型会去小整数池中拿到对应的整型值来参与运算，故True和1的hash运算的结果都是相同的。 如下图所示： 绝对引用 布尔类型拥有绝对引用的特性，则无论是深拷贝还是浅拷贝，都不会获得其副本，而是直接对源对象进行引用： >>> import copy >>> oldBool = True >>> id(oldBool) 4369122176 >>> b1 = copy.copy(oldBool) >>> id(b1) 4369122176 >>> b2 = copy.deepcopy(oldBool) >>> id(b2) 4369122176 boolobject.c源码 官网参考：点我跳转 源码一览：点我跳转 现有的名称 Py_False 和 Py_True 引用独一无二的布尔对象 False 和 True （之前，它们分别引用了值为 0 和 1 的静态整数对象，是众多整数之一）。 一个新的 API，即PyObject *PyBool_FromLong(long) ，会接收一个 C长整型参数，并返回对 Py_False （当参数为零时）或 Py_True （当非零时）的新引用。 要检查对象是否为布尔对象，可以使用宏PyBool_Check()。 布尔实例的类型是 PyBoolObject*。 布尔类型对象可作为PyBool_Type使用。 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:46 "},"Python/Python基础知识/单例None.html":{"url":"Python/Python基础知识/单例None.html","title":"单例None","keywords":"","body":"None None是Python中经常出现的一种类型，但其实关于它的描述并不是很多，因此None也经常被人忽略。 None是一种不可变类型，同时也是基础的原子类型，即不可分割，不能容纳其他对象。 它常用于初始化数据，并且是函数默认的返回值。 基本声明 None的声明方式仅有字面量声明： empty = None print(\"value : %r\\ntype : %r\" % (empty, type(empty))) # value : None # type : NoneType与单例 尽管可以看到None的实例化类为NoneType，但是你可能无法直接找到NoneType： print(NoneType) # NameError: name 'NoneType' is not defined NoneType实现了单例模式，我们虽然无法直接拿到NoneType这个类，但是可以通过 __class__属性拿到。 以下实例化多个None，查看id()是否相同： NoneType = None.__class__ none1 = NoneType() none2 = NoneType() print(id(none1)) print(id(none2)) # 4377856088 # 4377856088 绝对引用 None类型也是绝对引用，无论是深拷贝还是浅拷贝，都不会获得其副本，而是直接对源对象进行引用： >>> import copy >>> oldNone = None >>> id(oldNone) 4369221720 >>> no1 = copy.copy(oldNone) >>> id(no1) 4369221720 >>> no2 = copy.deepcopy(oldNone) >>> id(no2) 4369221720 None的使用 None一般用于对一个变量进行初始化，可能我们还没想好这个变量存什么内容时可以用None先代替进行存入。 这种变量可称之为临时变量，即只在一定的场景下进行使用，而并不会常驻使用： temp = None Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:46 "},"Python/Python基础知识/内存管理.html":{"url":"Python/Python基础知识/内存管理.html","title":"内存管理","keywords":"","body":"Gc简介 Gc（garbage collection）中文直译为垃圾回收，是一种回收内存空间避免内存泄漏的机制。 我们在程序的运行中会产生大量的对象用于保存数据，而有时候有些对象已经没有用了就需要被清理释放掉该对象所占据的内存空间。 在一些较为低级的语言中对于内存空间的释放是需要编程人员来手动进行的，这种与底层硬件直接打交道的操作是十分的危险与繁琐的，而基于C语言开发而来的Python为了解决掉这种顾虑则自带了一种垃圾回收机制，从而让开发人员不必过分担心内存的使用情况而可以全身心的投入到开发中去。 引用计数 最简单的Gc机制，引用计数。 首先将堆区内存中的对象与栈区内存中标识符的绑定数量做一个计数。 示例如下： >>> a = \"Python\" >>> b = \"Python\" >>> c = \"Python\" 我们的图示按照标识符的引用次数为准，并忽略临时引用，下图中Python这个str对象的引用计数目前为3： 每次标识符与对象取消绑定关系，则计数-1，当计数减到0的时候将自动清理该对象。 示例如下： >>> del a >>> del b >>> del c 标记清除 循环引用 引用计数能够解决百分之九十的问题，但是有一种特殊的情况是引用计数处理不了的，即循环引用（也被称为交叉引用）。 什么是循环引用，举一个简单的例子就是列表的互相嵌套，如下所示，l1和l2的引用计数都为2（标识符+1次引用，两个列表的[-1]索引处+1次引用）： >>> l1 = [1,2,3] >>> l2 = [1,2,3,l1] >>> l1.append(l2) >>> l1 [1, 2, 3, [1, 2, 3, [...]]] >>> l2 [1, 2, 3, [1, 2, 3, [...]]] 接着往下看，我们取消标识符与对象的绑定关系： >>> del l1 >>> del l2 现在，由于2个列表对象的计数都为1，故引用计数的策略显得不好使了。 因为2个列表对象的引用计数都未清0： 解决方案 为了解决循环引用带来的内存泄露问题，出现了标记清除法。 标记清除的意思在于当应用程序可用内存空间即将被耗尽时便开始遍历栈区所有的标识符，并且会顺着栈区标识符对其引用的在堆区中的对象做一个标记。 如果堆区内存中存在没有与栈区标识符进行绑定的对象，该对象则会认为是无用的对象，将会被清理。 分代回收 基于引用计数的垃圾回收机制每一次执行清理操作前都会将整个堆区对象的引用计数做一次遍历统计。 这样做是非常消耗时间的，所以Python垃圾回收机制为了效率的提升加入了分代回收的策略。 即： 当多次扫描后，若该对象的引用计数一直不为0，且也没有被标记清除法所清理掉，则证明 该对象会被经常使用，因此降低该对象的扫描频率，以提升效率。 优秀文章推荐 其实Python内部的内存管理机制远不如此。 所以这里推荐一个知乎博主写的系列文章，感兴趣的朋友可以跳转后继续深入阅读，该博主对Python底层内存机制剖析的极为透彻，是不可多得的好文章： 点我跳转 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:46 "},"Python/Python基础知识/深浅拷贝.html":{"url":"Python/Python基础知识/深浅拷贝.html","title":"深浅拷贝","keywords":"","body":"拷贝 copy即拷贝，意在将相同的数据进行复制，以便将复制出的副本应用于不同的操作上，而本体不会受到任何影响。 绝大多数语言中都有深浅拷贝的概念，故此篇文章也是属于通用性文章。 在Python中，除开手动导入copy模块并使用deepcopy()函数的拷贝是深拷贝，其他的所有的拷贝操作都是浅拷贝。 在开始之前，介绍几个基本概念： 不可变类型：int、float、str、bool、None、tuple、frozenset 可变类型：list、dict、set（均是容器） 绝对引用：所有的不可变类型，都具有绝对引用的特性，即深浅拷贝都不会获得其副本，而是直接对源对象进行引用 赋值 赋值就是引用，代码如下： #!/usr/bin/env python3 # -*- coding:utf-8 -*- oldLi = [\"A\", [1, ], (1,)] newLi = oldLi if id(oldLi) == id(newLi): print(\"外部大容器：可变类型：list来自同一个引用\") else: print(\"外部大容器：可变类型：list来自不同的引用\") if id(oldLi[0] == id(newLi[0])): print(\"内部第1个元素：不可变类型：str来自同一个引用\") else: print(\"内部第1个元素：不可变类型：str来自不同的引用\") if id(oldLi[1]) == id(newLi[1]): print(\"内部第1个大容器：可变类型：list来自同一个引用\") else: print(\"内部第1个大容器：可变类型：list来自不同的引用\") if id(oldLi[1][0]) == id(newLi[1][0]): print(\"内部第1个大容器的数据项：不可变类型：int ：%r来自同一个引用\" % oldLi[1][0]) else: print(\"内部第1个大容器的数据项：不可变类型：int ：%r来自不同的引用\" % oldLi[1][0]) if id(oldLi[2]) == id(newLi[2]): print(\"内部第2个大容器：不可变类型：tuple来自同一个引用\") else: print(\"内部第2个大容器：不可变类型：tuple来自不同的引用\") if id(oldLi[2][0]) == id(newLi[2][0]): print(\"内部第2个大容器的数据项：不可变类型：int ：%r来自同一个引用\" % oldLi[2][0]) else: print(\"内部第2个大容器的数据项：不可变类型：int ：%r来自不同的引用\" % oldLi[2][0]) # 外部大容器：可变类型：list来自同一个引用 # 内部第1个元素：不可变类型：str来自同一个引用 # 内部第1个大容器：可变类型：list来自同一个引用 # 内部第1个大容器的数据项：不可变类型：int ：1来自同一个引用 # 内部第2个大容器：不可变类型：tuple来自同一个引用 # 内部第2个大容器的数据项：不可变类型：int ：1来自同一个引用 如图所示： 所有引用都相同，这代表着oldLi中任意一个数据项改变后，newLi中的数据项也会跟着发生改变： oldLi[0] = \"B\" print(\"oldLi -> index0:type=str -> %r\" % oldLi[0]) print(\"newLi -> index0:type=str -> %r\" % newLi[0]) oldLi[1][0] = 10 print(\"oldLi -> index1:type=list --> index0:type=int -> %r\" % oldLi[1][0]) print(\"newLi -> index1:type=list --> index0:type=int -> %r\" % newLi[1][0]) # oldLi -> index0:type=str -> 'B' # newLi -> index0:type=str -> 'B' # oldLi -> index1:type=list --> index0:type=int -> 10 # newLi -> index1:type=list --> index0:type=int -> 10 图示如下： 浅拷贝 被浅拷贝的对象如果是可变类型，则创建副本，如果是不可变类型，则是引用，浅拷贝仅拷贝1层。 代码如下： #!/usr/bin/env python3 # -*- coding:utf-8 -*- import copy oldLi = [\"A\", [1, ], (1,)] newLi = copy.copy(oldLi) if id(oldLi) == id(newLi): print(\"外部大容器：可变类型：list来自同一个引用\") else: print(\"外部大容器：可变类型：list来自不同的引用\") if id(oldLi[0] == id(newLi[0])): print(\"内部第1个元素：不可变类型：str来自同一个引用\") else: print(\"内部第1个元素：不可变类型：str来自不同的引用\") if id(oldLi[1]) == id(newLi[1]): print(\"内部第1个大容器：可变类型：list来自同一个引用\") else: print(\"内部第1个大容器：可变类型：list来自不同的引用\") if id(oldLi[1][0]) == id(newLi[1][0]): print(\"内部第1个大容器的数据项：不可变类型：int ：%r来自同一个引用\" % oldLi[1][0]) else: print(\"内部第1个大容器的数据项：不可变类型：int ：%r来自不同的引用\" % oldLi[1][0]) if id(oldLi[2]) == id(newLi[2]): print(\"内部第2个大容器：不可变类型：tuple来自同一个引用\") else: print(\"内部第2个大容器：不可变类型：tuple来自不同的引用\") if id(oldLi[2][0]) == id(newLi[2][0]): print(\"内部第2个大容器的数据项：不可变类型：int ：%r来自同一个引用\" % oldLi[2][0]) else: print(\"内部第2个大容器的数据项：不可变类型：int ：%r来自不同的引用\" % oldLi[2][0]) # 外部大容器：可变类型：list来自不同的引用 # 内部第1个元素：不可变类型：str来自同一个引用 # 内部第1个大容器：可变类型：list来自同一个引用 # 内部第1个大容器的数据项：不可变类型：int ：1来自同一个引用 # 内部第2个大容器：不可变类型：tuple来自同一个引用 # 内部第2个大容器的数据项：不可变类型：int ：1来自同一个引用 如图所示，浅拷贝为什么浅，因为只拷贝了一层： 如果修改oldLi第1层的index指向，newLi并不会受到影响，而如果修改oldLi第2层的index指向，则newLi会受到影响，如下所示： oldLi[0] = \"B\" print(\"oldLi -> index0:type=str -> %r\" % oldLi[0]) print(\"newLi -> index0:type=str -> %r\" % newLi[0]) oldLi[1][0] = 10 print(\"oldLi -> index1:type=list --> index0:type=int -> %r\" % oldLi[1][0]) print(\"newLi -> index1:type=list --> index0:type=int -> %r\" % newLi[1][0]) # oldLi -> index0:type=str -> 'B' # newLi -> index0:type=str -> 'A' # oldLi -> index1:type=list --> index0:type=int -> 10 # newLi -> index1:type=list --> index0:type=int -> 10 图示如下： 深拷贝 深拷贝是递归的拷贝，即在浅拷贝的基础上也会递归的判定其子数据项是否能被拷贝。 如果是可变类型则拷贝，如果是不可变类型则不拷贝，代码如下： #!/usr/bin/env python3 # -*- coding:utf-8 -*- import copy oldLi = [\"A\", [1, ], (1,)] newLi = copy.deepcopy(oldLi) if id(oldLi) == id(newLi): print(\"外部大容器：可变类型：list来自同一个引用\") else: print(\"外部大容器：可变类型：list来自不同的引用\") if id(oldLi[0] == id(newLi[0])): print(\"内部第1个元素：不可变类型：str来自同一个引用\") else: print(\"内部第1个元素：不可变类型：str来自不同的引用\") if id(oldLi[1]) == id(newLi[1]): print(\"内部第1个大容器：可变类型：list来自同一个引用\") else: print(\"内部第1个大容器：可变类型：list来自不同的引用\") if id(oldLi[1][0]) == id(newLi[1][0]): print(\"内部第1个大容器的数据项：不可变类型：int ：%r来自同一个引用\" % oldLi[1][0]) else: print(\"内部第1个大容器的数据项：不可变类型：int ：%r来自不同的引用\" % oldLi[1][0]) if id(oldLi[2]) == id(newLi[2]): print(\"内部第2个大容器：不可变类型：tuple来自同一个引用\") else: print(\"内部第2个大容器：不可变类型：tuple来自不同的引用\") if id(oldLi[2][0]) == id(newLi[2][0]): print(\"内部第2个大容器的数据项：不可变类型：int ：%r来自同一个引用\" % oldLi[2][0]) else: print(\"内部第2个大容器的数据项：不可变类型：int ：%r来自不同的引用\" % oldLi[2][0]) # 外部大容器：可变类型：list来自不同的引用 # 内部第1个元素：不可变类型：str来自同一个引用 # 内部第1个大容器：可变类型：list来自不同的引用 # 内部第1个大容器的数据项：不可变类型：int ：1来自同一个引用 # 内部第2个大容器：不可变类型：tuple来自同一个引用 # 内部第2个大容器的数据项：不可变类型：int ：1来自同一个引用 如图所示，深拷贝把能拷贝的，不是绝对引用的都拷贝了： 无论怎么修改oldLi，newLi都不会受到影响： oldLi[0] = \"B\" print(\"oldLi -> index0:type=str -> %r\" % oldLi[0]) print(\"newLi -> index0:type=str -> %r\" % newLi[0]) oldLi[1][0] = 10 print(\"oldLi -> index1:type=list --> index0:type=int -> %r\" % oldLi[1][0]) print(\"newLi -> index1:type=list --> index0:type=int -> %r\" % newLi[1][0]) # oldLi -> index0:type=str -> 'B' # newLi -> index0:type=str -> 'A' # oldLi -> index1:type=list --> index0:type=int -> 10 # newLi -> index1:type=list --> index0:type=int -> 1 图示如下： Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:46 "},"Python/Python基础知识/输入与输出.html":{"url":"Python/Python基础知识/输入与输出.html","title":"输入与输出","keywords":"","body":"输入与输出 输入（output）让计算机能够听懂人类的指令，输入（input）能够告诉人类程序目前的状态。 标准输出 print() 在Python3中，print()函数默认会将对象的表现形式输出至屏幕上： print(\"hello world\") # hello world 而在Python2中，print后面不必加括号，直接加上对象即可： print \"hello world\" 除此之外，print()函数还可以接收3个参数，分别是：sep、end、file sep参数 该参数用来显示逗号间隔中的链接字符，默认为一个空格： # 不指定sep参数 print(\"hello\", \"world\") # hello world # 指定sep参数 print(\"hello\", \"world\", sep=\"☺\") # hello☺world end参数 该参数用于指定当print()完成后所在行尾指定的字符，默认为\\n即换行符。 print(\"hello\", end=\"\\t\") print(\"world\") # hello world file参数 该参数默认内部为标准输出，即输出至用户屏幕，我们可以通过该参数来指定print()的内容写入到某个指定的文件句柄中： with open(\"testFile.txt\", mode=\"wt\", encoding=\"utf8\") as f: print(\"this line written in file\", file=f) 格式化输出 如果我们想将一个字符串与一个对象的表现形式相结合，可使用格式化输出。 % %格式化的历史悠久，很多码龄较长的程序员都喜欢用它进行格式化输出。 我们来看一个例子： name = \"YunYaSir\" age = 19 s1 = \"name : %s\\nage : %d\" % (name, age) # ❶ print(s1) # name : YunYaSir # age : 19 ❶：字符串中的%s、%d等都是占位符，占位符要和对象匹配，在进行格式化时%char会被对象的表现形式所代替。 常见的占位符如下表所示： 占位符 描述 %s 接收任意类型的值，以字符串形式显示 %r 接收任意类型的值，以r字符串形式显示 %c 只接收单个字符 %b 接收int类型的值，二进制整数形式显示 %d 接收int类型的值，十进制整数形式显示 %i 接收int类型的值，十进制整数形式显示 %o 接收int类型的值，八进制整数形式显示 %x 接收int类型的值，十六进制整数形式显示 %e 接收float类型的值，指数形式显示 (基底写为e) %E 接收float类型的值，指数形式显示 (基底写为E) %f 接收float类型的值，浮点数形式显示 %F 接收float类型的值，浮点数形式显示 %g 接收float类型的值，指数(e)或浮点数 (根据显示长度) %G 接收float类型的值，指数(E)或浮点数 (根据显示长度) %% 即打印1个百分号 位置传参 一个占位符对应一个对象，当对象与占位符有多个时便需要将%后面的对象跟上括号做出一个元组，如若只有一个则不需要加上括号，%后元组中的对象数量必须与占位符的数量一致，且位置要一一对应： name = \"YunYaSir\" age = 19 s1 = \"name : %s\\nage : %d\" % (name, age) # ❶ print(s1) # name : YunYaSir # age : 19 如上所示：%s对应name、%d对应age。 优点：便于维护 缺点：对象与占位符必须一一对应，数量必须保持一致 关键字传参 使用关键字传参可以打破位置传参中占位符和标识符顺序以及数量必须统一的限制： name = \"YunYaSir\" age = 19 s1 = \"name : %(name)s\\nage : %(age)d\" % {\"age\": age, \"name\": name} # ❶ print(s1) # name : YunYaSir # age : 19 如上所示：%(name)s代表将dict中key为name的值转换为字符串形式显示，而%(age)d则代表将dict中key为age的值转换为字符串形式显示。 优点：使用灵活 缺点：如果被格式化的占位符过多，可能导致维护不便的情况发生 格式化百分号 如果想打印%占比，则可以使用下面的方式 %%代表一个% 。放在 %d后面的%则代表格式化出后的结果是3%: s1 = \"%d%%\"%3 print(s1) # 3% 格式化精度控制 如果要格式化一个小数，保留点后2位该怎么做？ 如下示例： PI = 3.1415926 print(\"pi = %.2f\" % PI) # pi = 3.14 format() %虽然能够满足基本需求。但在Python2.6中新增的format()方法，它更加强大且速度更快。 推荐今后使用format()的方法进行字符串格式化 。 注意:format()中的s只接受str类型的传值而不接受全部类型 如下所示，必须一个{}对应format()中的一个对象： name = \"YunYaSir\" age = 19 s1 = \"name : {}\\nage : {}\".format(name, age) # ❶ print(s1) # name : YunYaSir # age : 19 ❶：第1个{}对应format()中传入的第1个对象name，而第2个{}对应format()中传入的第2个对象age 或者也可以使用对象的方法调用形式： name = \"YunYaSir\" age = 19 s1 = str.format(\"name : {}\\nage : {}\", name, age) print(s1) # name : YunYaSir # age : 19 位置传参 基本使用，采用{}进行占位，需要注意的是format中的s不是接收全部类型的对象，只能接收str类型的对象： name = \"YunYaSir\" age = 19 s1 = \"name : {:s}\\nage : {:d}\".format(name, age) print(s1) # name : YunYaSir # age : 19 如果不指定类型，则{}中默认接收全部类型的对象： name = \"YunYaSir\" age = 19 s1 = \"name : {}\\nage : {}\".format(name, age) print(s1) # name : YunYaSir # age : 19 索引传参 索引传参是format()方法所独有的。 采用{}进行占位，并在其中传入format()中被格式化对象的位置信息，如下所示： name = \"YunYaSir\" age = 19 s1 = \"name : {0:s}\\nage : {1:d}\".format(name, age) print(s1) # name : YunYaSir # age : 19 需要注意，索引传参时必须为正向索引，不支持负向索引。 关键字传参 format()方法传参时使用键值对的方式进行传参： name = \"YunYaSir\" age = 19 s1 = \"name : {name:s}\\nage : {age:d}\".format(name=name, age=age) print(s1) # name : YunYaSir # age : 19 你也可以直接传入一个字典，通过**语法对字典解包： name = \"YunYaSir\" age = 19 s1 = \"name : {name:s}\\nage : {age:d}\".format(**{\"name\": name, \"age\": age}) print(s1) # name : YunYaSir # age : 19 字符填充功能 format()方法格式化时支持字符填充，如下表所示： 填充位置符号 描述 字符串居左、往右填充数据项 > 字符串居右、往左填充数据项 ^ 字符串居中、两侧填充数据项 示例如下： char = \"M\" # 右填充*，字符串长度为10时停止填充 rightFill = str.format(\"{0:*10}\", char) print(leftFill) # *********M # 两侧填充*，字符串长度为10时停止填充 midFill = str.format(\"{0:*^10}\", char) print(midFill) # ****M***** 格式化百分号 format()方法格式化百分号方法如下，它比%的格式化更加简单： s1 = str.format(\"{0}%\", 3) print(s1) # 3% 格式化{}大括号 如果使用format()方法，格式化时要输出“{char}“该怎么做？ 在外部套用2次大括号即可，如下所示： s1 = str.format(\"{{{0}}}\", \"☺\") print(s1) # {☺} 内部的{0}代表要格式化后面的☺，而外部的2个{}格式化完成后则表现为1个{}。 格式化精度控制 如果要使用format()方法格式化一个小数，保留点后2位该怎么做？ 如下示例： PI = 3.1415926 print(\"pi = {0:.2f}\".format(PI)) # pi = 3.14 其他的格式化 进制转换、如下所示： # 进制转换 sBit = str.format(\"{:b}\", 10) # 2进制 sOct = str.format(\"{:o}\", 10) # 8进制 sHex = str.format(\"{:x}\", 10) # 16进制 print(sBit) # 1010 print(sOct) # 12 print(sHex) # a 如果1代表百分之百，该怎么表示？如下所示： # .2%中的2代表保留2小数点后2位 s1 = str.format(\"{:.2%}\", 1) print(s1) s2 = str.format(\"{:.2%}\", 0.5) print(s2) # 100.00% # 50.00% 千分位表示，用逗号进行分割： s = str.format(\"{:,}\", 100000000) print(s) # 100,000,000 f 尽管format()已经非常方便了。但是如果传入的参数值太多依旧会看着十分混乱，于是Python3.6中新增了 f 格式字符串的操作。 这种方法的速度最快，但是却不推荐使用，因为程序还要考虑一个向下兼容性的问题。 name = \"YunYaSir\" age = 19 s1 = f\"name : {name}\\nage : {age}\" print(s1) # name : YunYaSir # age : 19 具体使用方法参照上面，与原始字符串r使用差不多，用f添加在字符串前面，并且使用{}进行占位，{}中放入对象即可。 关于其他的字符串填充、精度控制、格式化转换等功能均和format()使用相同，这里不再举例。 标准输入 input() Python2和Python3中均有input()函数来接收用户的输入。 需要注意的是，Python3中input()所得到的所有用户输入的数据，类型都是str，举个例子，用户输入小键盘数字1，程序得到的类型为str而不是int，所以我们可能需要额外的进行类型转换。 而在Python2中，则会自动转换类型为int，Python2会检测用户输入的内容是否符合Python语法，如不符合语法就会抛出异常，因此Python3中才摈弃了这种设定。 Python3中获得的所有输入结果类型均为str： username = input(\"Please type in your name:\") userage = input(\"Please enter age:\") print(\"value : %r\\ntype : %r\" % (username, type(username))) print(\"value : %r\\ntype : %r\" % (userage, type(userage))) # Please type in your name:YunYaSir # Please enter age:18 # value : 'YunYaSir' # type : # value : '18' # type : 用户年龄应当是int类型，所以我们需要对其做一次类型转换： username = input(\"Please type in your name:\") userage = int(input(\"Please enter age:\")) Python2中如果用户没有按照Python语法进行数据的录入，则会抛出异常： # coding:u8 username = input(\"Please type in your name:\") userage = input(\"Please enter age:\") print u\"value : %r\\ntype : %r\" % (username, type(username)) print u\"value : %r\\ntype : %r\" % (userage, type(userage)) # -- 输入了 yunya 会抛出 name 'yunya' is not defined # -- 而输入了 \"yunya\" 则会正常 raw_input() raw_input()是Python2中独有的，与Python3的input()效果相同。 这还是因为Python2中input()的缺点而导致raw_input()的诞生，用户必须熟知Python语法才能与程序进行交互，这是不现实的。 >>> name = input(\"Please type in your name:\") Please type in your name: yunya ❶ NameError: name 'yunya' is not defined >>> name = input(\"Please type in your name:\") Please type in your name: \"yunya\" ❷ >>> name 'yunya' ❶：这里没加引号，Python2的input()会认为这是一个变量，但该变量并未被定义，所以抛出 yunya 未定义的这么一个异常。 ❷：加了引号，表明这是一个字符串 更进一步了解输出 stdin&stdout&stderr 在Linux下，当一个用户进程被创建的时候，系统会自动为该进程创建三个数据流，分别是stdin、stdout、stderr。 stdin：标准输入、指向用户键盘 stdout：标准输出、指向用户屏幕 stderr：标准错误、指向用户屏幕 print()的指向 Python3的print()函数，内部则是引用了stdout，也就是说会默认的将数据显示在用户屏幕上。 我们可以从Python中print()函数签名中看到： def print(self, *args, sep=' ', end='\\n', file=None): # known special case of print \"\"\" print(value, ..., sep=' ', end='\\n', file=sys.stdout, flush=False) Prints the values to a stream, or to sys.stdout by default. Optional keyword arguments: file: a file-like object (stream); defaults to the current sys.stdout. sep: string inserted between values, default a space. end: string appended after the last value, default a newline. flush: whether to forcibly flush the stream. \"\"\" pass 而关于flush参数，则可以理解为刷新机制。 默认是False即代表是流式的输出，而改为True则会拥有类似于帧动画的特性，以下代码将进行验证，推荐使用Python IDLE查看效果： import time print(\"downloading\\t\", end=\"\") for i in range(100): time.sleep(0.1) if i == 99: print('#', flush=True, end=\"\\tdownload complate\\n\") break print('#', flush=True, end=\"\") Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:46 "},"Python/Python基础知识/运算符相关.html":{"url":"Python/Python基础知识/运算符相关.html","title":"运算符相关","keywords":"","body":"算数运算符 符号意义 以下是常用的算数运算符： 符号 意义 + 加法运算 - 减法运算 * 乘法运算 / 除法运算，精确除法（返回float） // 除法运算，地板除法（向下取整，生成int） ** 幂运算 % 求余运算 注意事项： float与int或者bool做运算，得到的结果均为float >>> 1 + 1.0 2.0 >>> 1 - 1.0 0.0 >>> 1 * 1.0 1.0 >>> 1 / 1.0 1.0 **幂运算仅支持int 、float、 bool 三种类型 >>> 2 ** 3 8 >>> 2.0 ** 3 8.0 >>> True ** 3 1 >>> %求余运算只支持 int 、float、 bool 三种类型，如果被求余数小于求余数，那么余数就为被求余数本身 >>> 6 % 8 6 示例演示 加法运算 print(1 + 1) print(1 + 1.1) print(1 + True) print([1, 2, 3] + [4, 5, 6]) print('OldStr ' + ' NewStr') # Change the reference value, generate new objects print((1, 2, 3) + (4, 5, 6)) # Change the reference value, generate new objects # 2 # 2.1 # 2 # OldStr NewStr # [1, 2, 3, 4, 5, 6] # (1, 2, 3, 4, 5, 6) 减法运算 print(1 - 1) print(1 - 1.1) print(1 - True) # 0 # -0.10000000000000009 # 0 乘法运算 s1 = '￥' l1 = [1, 2, 3] t1 = (1, 2, 3) print(1 * 2) print(1 * 2.0) print(1 * True) print(3 * l1) print(3 * s1) # Change the reference value to generate a new STR object print(3 * t1) # Change the reference value to generate a new Tuple object # 2 # 2.0 # 1 # [1, 2, 3, 1, 2, 3, 1, 2, 3] # ￥￥￥ # (1, 2, 3, 1, 2, 3, 1, 2, 3) 精确除法 print(10 / 2) print(10 / 2.0) print(10.1 / True) print(10.1 / True) print(10.1 / True) print(10.1 / True) print(False / 10) print(True / 2) print(True / 2.0) # 5.0 # 5.0 # 10.1 # 10.1 # 10.1 # 10.1 # 0.0 # 0.5 # 0.5 赋值运算符 符号意义 以下是常用的赋值运算符： 符号 意义 = 普通的赋值 += 增量加法赋值 -= 增量减法赋值 *= 增量乘法赋值 /= 增量精确除法赋值 //= 增量地板除法赋值 **= 增量幂运算赋值 %= 增量求余赋值 普通赋值 赋值运算符为=，切记一个=才是赋值： >>> x = 1 >>> x 1 增量赋值 在原本标识符所指向的对象基础上进行增量的运算后，再将运算结果赋值给原本的标识符。 增量赋值运算符就是将赋值符号和算术运算符结合起来达到简写的目的： 普通的先运算后赋值： >>> x = 1 >>> x = x + 10 >>> x 11 >>> x = x - 10 >>> x 1 >>> x = x * 10 >>> x 10 >>> x = x / 10 >>> x 1.0 >>> x = x // 10 >>> x 0.0 >>> x = x ** 10 >>> x 0.0 >>> x = x % 10 >>> x 0.0 简便的增量运算符： >>> x = 1 >>> x += 10 >>> x 11 >>> x -= 10 >>> x 1 >>> x *= 10 >>> x 10 >>> x /= 10 >>> x 1.0 >>> x //= 10 >>> x 0.0 >>> x **= 10 >>> x 0.0 >>> x %= 10 >>> x 0.0 平行赋值 平行赋值，一次为多个标识符进行赋值： >>> x, y, z = 1, 2, 3 >>> x 1 >>> y 2 >>> z 3 链式赋值 链式赋值，多个标识符引用同一个对象： >>> x = y = z = \"Object\" >>> x 'Object' >>> y 'Object' >>> z 'Object' 链式赋值也被称之为间接赋值。 交叉赋值 交叉赋值，将2个标识符所指向的对象进行互换： >>> x = \"Object001\" >>> y = \"Object002\" >>> x, y = y, x >>> x 'Object002' >>> y 'Object001' 解压赋值 解压赋值这里不再进行赘述了，前面在介绍内置数据类型的时候已经介绍过了。 比较运算符 符号意义 比较运算符的返回结果总是为True或者False，一般是用于比较2个相同类型的值的大小。 常用于条件分支结构中： 符号 意义 > 大于 小于 == 等于 != 不等于 >= 大于或者等于 小于或者等于 示例演示 比较运算符得到的结果必然是bool类型： >>> 1 >> 1 > 2 False >>> 1 == 1.0 True >>> 1 == True True 比较方式 字符串与字符串之间的比较会一位一位对照ASCII表来进行比对： >>> ord(\"y\") 121 >>> ord(\"k\") 107 >>> \"y\" > \"k\" True 如果是非ASCII字符，则会调用其他的比较机制，如调用locale模块下的strxfrm()函数对字符串进行本地化处理： print(\"中\" > \"美\") 如果是数字串，则会一位一位进行比较： >>> \"100\" > \"4\" False # 第一位比较：1 小于 4，后续不再比较 数字与数字之间的比较会之间比较整体： >>> 100 > 1000 False 元组、列表之间的比较会根据相同的索引值进行一位一位的比较： >>> (\"100\", ) > (\"45\", \"b\") False # 1比4小 逻辑运算符 逻辑词汇 不同于其他编程语言的&&和||，Python中使用单词代表与或非。 单词 意义 not 非，统一取反 and 与，一真一假取一假，两个为真才取真 or 或，一真一假取一真，两个为假才取假 优先级 优先级的意思是如下： not True and False or True # 第一个True是该给not还是and做运算呢？ 牢记：NOT>AND>OR 故上面的结果为： True 以下是推算流程： False and False or True False or True True 示例演示 使用not进行取反： >>> not 1 > 2 True 使用and进行多条件连接： >>> name = \"Yunya\" >>> age = 18 >>> name == \"Yunya\" and age == 18 True >>> 使用or进行或逻辑判断： >>> name = \"Yunya\" >>> age = 18 >>> name == \"Yunya\" or age == 100 True >>> 短路运算 如果一次逻辑运算中的逻辑运算符号全部为 and 或者 or 则会从左至右依次进行逻辑运算。 如果每一次都进行运算是很消耗时间的，所以这个时候出现了短路机制。 看图说话： 与或运算 如果不是对True或者False进行and or运算而是对数字进行and or运算呢？ 只需要牢记0是False非0是True即可： >>> 1 and 0 or 3 3 >>> 3 + 1 and 4 or 0 4 每次的结果若都是数字，则or 为真都取第一个True值, and 为真都取最后一个True值： >>> 1 and 2 # and 取后一个 2 >>> 2 and 1 # and 取后一个 1 >>> 1 or 0 # or 取第一个 1 >>> 0 or 1 # or 取第一个 1 加大难度： print( 1 or 3, # or 取第一个 1 and 3, # and 取后一个 0 and 2 and 1, # 0 and 2 是 0, 0 and 1 为 0 0 and 2 or 1, # 0 and 2 是 0, 0 or 1 为 1 0 and 2 or 1 or 4, # 0 and 2 是 0, 0 or 1 为 1 0 or False and 1 # 0 or False 是 False， False and 1 为 False ) # 1 3 0 1 1 False 成员运算符 in in用来判断容器类型的某一个数据项是否在其中，支持的类型有str、list、tuple、dict、set、frozenset，所有的判定严格区分大小写。 in：在其中 not in：不在其中 需要注意的是如果是对dict做in的成员判定，只会判定key是否在其中： >>> string = \"ABCDEFG\" >>> \"A\" in string True >>> \"a\" in string False >>> li1 = [1, 2, 3] >>> 1 in li1 True >>> 0 in li1 False >>> tup = (1, 2, 3) >>> 1 in tup True >>> 0 in tup False >>> dic = {\"k1\" : \"v1\", \"k2\" : \"v2\"} >>> \"k1\" in dic True >>> \"v1\" in dic False >>> s1 = {1, 2, 3} >>> 1 in s1 True >>> 0 in s1 False 身份运算符 is is判定对象是否来自同一引用，即是否是同一个对象，用来判断引用是否相等： >>> x = y = z = \"I love Python\" >>> x is y True >>> x is z True is&==的异同 ==仅判断对象的值是否相同，不关心是否引用自同一对象： >>> x = \"I love Python\" >>> y = \"I love Python\" >>> x == y True >>> x is y False 两者的区别在于使用is时相当于使用 id(obj) == id(obj)，即对象是否为同一引用： >>> x = \"I love Python\" >>> y = \"I love Python\" >>> id(x) 4305667952 >>> id(y) 4305668016 >>> id(x) == id(y) # is False 而==则不会判定id，仅判断2个对象的形式值是否相同： >>> x = \"I love Python\" >>> y = \"I love Python\" >>> id(x) 4305667952 >>> id(y) 4305668016 >>> x == y True 小结： is：引用判定，引用相等的对象则必然值相等 ==：值判定，值相等的对象引用不一定相等 is None 一般来说，我们对None做判断时都会使用is None而不是 == None，这是因为None本身就是一个单例对象。 所有的None对象其实内部都引用自同一对象，在PEP8规范中明确表示，对于None的判定应该使用is而不是==： r = None print(r is None) print(r == None) # True # True 虽然这么使用毫无问题，但是在PyCharm中会报出PEP8不规范的提示： 对象的增量与普通运算操作 记住一句话，增量是原地操作，不会开辟新的内存空间（字符串的+=除外）。 而普通的运算操作则会开辟新的内存空间，返回1个新对象。 我们以列表举例： >>> lst1 = [1, 2, 3] >>> lst2 = lst1 * 3 >>> lst1 is lst2 False >>> lst2 [1, 2, 3, 1, 2, 3, 1, 2, 3] >>> lst1 = [1, 2, 3] >>> id(li1) 4346207752 >>> lst1 *= 3 >>> id(li1) 4346207752 >>> lst1 [1, 2, 3, 1, 2, 3, 1, 2, 3] Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:46 "},"Python/Python基础知识/分支结构.html":{"url":"Python/Python基础知识/分支结构.html","title":"分支结构","keywords":"","body":"分支结构 分支结构能够让计算机像人一样进行思考，应对不同的场景做出不同的回应。 Python中不支持switch语法，目前仅支持if/else形式，但是在Python3.10的测试版本中，貌似支持了switch语法，这里不做例举。 if 多条if语句出现会逐行进行判断，条件为真则执行其下的代码块，条件为假则略过： if 条件判断： 逻辑代码... if 条件判断: 逻辑代码... if 条件判断: 逻辑代码... 示例演示： userAge = int(input(\"Please enter your age:\")) if userAge = 18 and userAge = 30 and userAge = 60 and userAge = 80: print(\"Can still meal\") if/else if代表如果怎样就怎样，else代表否则怎样就怎样。 一组if/else只会执行其中的一个。 以下是Python中if/else语法： if 条件判断： 逻辑代码... else： 逻辑代码... 示例演示： userinput = input(\"Enter any character, determine if it is a numeric string:\") if userinput.isdigit(): print(\"Is a digital string\") else: print(\"Not a digital string\") if/elif/else 多条if会按顺序依次执行，对每一条if语句都进行判定，而如果使用elif则只会从多条逻辑判定中取出最先为True的进行执行，后续的判定将不会被执行。 也就是说，if/elif/else三者只会执行一个。 语法使用如下： if 条件判断： 逻辑代码... elif 条件判断: 逻辑代码... elif 条件判断: 逻辑代码... else: 逻辑代码 示例演示： userAge = int(input(\"Please enter your age:\")) if userAge 三元表达式 三元表达式中有三个重要的元素： 条件是第一元素 　 条件成立返回的值是第二元素 　 条件不成立返回的值是第三元素 普通形式 如果只是一个简单if/else判定，我们可以将代码写在一行，语法如下： if else 示例演示： age = int(input(\"Please enter your age:\")) result = \"adult\" if age >= 18 else \"underage\" print(result) 其他形式 上面的三元表达式是最常见的一种，除此之外再介绍几种不常见的。 第二种，这种有一个BUG，不能区分0或者Fasle（在 Lua 中是可以这样用的，因为 Lua 的 0 和 False 是分开的）： and or 如下所示，如果1大于0就返回0，否则返回False，但是第二种的返回的结果永远是False： result = 1 > 0 and 0 or False print(result) # False 如果使用第一种，就不会有这样的问题： result = 0 if 1 > 0 else False print(result) # False 第三种，语法如下： (, )[condition] 示例如下： age = int(input(\"Please enter your age:\")) result = (\"underage\", \"adult\")[age >= 18] print(result) 第四种，语法如下： {True: , False: }[] 示例如下： age = int(input(\"Please enter your age:\")) result = {True: \"adult\", False: \"underage\"}[age >= 18] print(result) Python语法糖 链式比较 在Python中的判定支持一种链式比较，下面是常规的比较： age = 13 if age > 12 and age 通过链式比较进行简写： age = 13 if 12 12 and age 获得布尔值 判定用户输入的是否为数字串，如果为数字串result变量为True，否则为False。 很多情况下，初学者可能会写出下面这种代码： userInput = input(\"Please enter your age:\") result = None if userInput.isdigit(): result = True else: result = False print(result) 其实一行代码就可以搞定： userInput = input(\"Please enter your age:\") result = bool(userInput.isdigit()) print(result) 或者你也可以使用另一种方式： userInput = input(\"Please enter your age:\") result = userInput.isdigit() or False print(result) 实例练习 输入一个数字，判断该数字是奇数还是偶数： num = int(input(\"Enter a number: \")) if (num % 2) == 0: print(\"%s an even number\" % num) else: print(\"%s an odd number\" % num) 输入一个年份，判断该年份是否是闰年？ year = int(input(\"Enter a year: \")) if (year % 4) == 0: if (year % 100) == 0: if (year % 400) == 0: print(\"%s is a leap year\" % year) # 整百年能被400整除的是闰年 else: print(\"%s not is leap year\" % year) else: print(\"%s is a leap year\" % year) # 非整百年能被4整除的为闰年 else: print(\"%s not is leap year\" % year) 输入某年某月某日，判断这一天是这一年的第几天？ year = int(input('year:\\n')) month = int(input('month:\\n')) day = int(input('day:\\n')) sumInt = None months = (0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334) if 0 2): sum += 1 print('it is the %dth day.' % sum) Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:46 "},"Python/Python基础知识/流程控制.html":{"url":"Python/Python基础知识/流程控制.html","title":"流程控制","keywords":"","body":"流程控制 流程控制以循环为主，旨在让计算机重复的去做某一件事情。 在介绍流程控制一章节前，引入一个叫做遍历的概念： 遍历是指对一个可迭代对象类型（暂时理解为容器类型），进行数据项的依次访问行为 下面这个是遍历行为轨迹示意： # [1, 2, 3, 4, 5, 6] # ------------------> 重复的取值也在遍历范畴： # [1, 2, 3, 4, 5, 6] # -----> # # 条件循环 while while循环是基于条件的循环，while本身具有if判断的功能，当条件为真时开始重复执行子代码块中的内容直至条件为假后跳出循环。 tag = 10 while tag > 5: print(\"current tag value : %s\" % tag) tag -= 1 print(\"while cycle end tag of value : %s\" % tag) # current tag value : 10 # current tag value : 9 # current tag value : 8 # current tag value : 7 # current tag value : 6 # while cycle end tag of value : 5 条件退出 while只有在每一次的循环开始前才会检测条件是否为真，如果条件在子代码块内部发生改变则本次的循环并不会立即退出，如下所示： tag = 10 while tag != 5: print(\"current tag value : %s\" % tag) tag = 5 print(\"no stop continue to run\") print(\"while cycle end tag of value : %s\" % tag) # current tag value : 10 # no stop continue to run\" # while cycle end tag of value : 5 while/else while循环正常结束后，会执行else代码块中的代码： 正常结束的while循环是指不被强制break的while循环 tag = 3 while tag: print(tag) tag -= 1 else: print(\"else...\") # 3 # 2 # 1 # else... 死循环 当while的结果永远为真时，将引发死循环。 单纯的死循环不会引来性能损耗问题，但是如果做一些计算操作则必将会对CPU带来极大的性能压力，因为CPU没有一刻的休息时间。 tag = 1 while 1: tag += 10 取值循环 for for循环内部是基于while循环来完成的，for循环在对可迭代对象的取值上比while循环更加的方便，故也被称为取值循环。 for循环常用于遍历可迭代对象进行取值操作，以下是语法介绍： for 迭代变量 in 可迭代对象（暂时可理解为容器类型） 逻辑操作... 以下是使用while循环遍历可迭代对象进行取值，相当麻烦： lst = [1, 2, 3, 4, 5] index = 0 while 1: try: print(lst[index]) except IndexError: break index += 1 # 1 # 2 # 3 # 4 # 5 如果使用for循环，那么就变的简单许多： lst = [1, 2, 3, 4, 5] for i in lst: print(i) # 1 # 2 # 3 # 4 # 5 结束退出 for循环的正常退出是遍历完整个可迭代对象之后进行退出。 lst = [1, 2, 3, 4, 5] for i in lst: print(i) print(\"for cycle end\") # 1 # 2 # 3 # 4 # 5 # for cycle end for/else 当for循环正常退出结束后，会执行else下的代码块： 正常结束的for循环是指不被强制break的for循环 lst = [1, 2, 3, 4, 5] for i in lst: print(i) else: print(\"else..\") # 1 # 2 # 3 # 4 # 5 # else.. range() 我们有一个需求需要让计算机重复打印5次hello,world，你可能会这样做： count = 5 while count: print(\"hello,world\") count -= 1 也可以使用for循环来进行完成，但是这样会很麻烦，由于使用for循环必须遍历一个可迭代对象，所以要先创建一个可迭代对象： count = [0, 1, 2, 3, 4] for i in count: print(\"hello,world\") 如果你使用range()，这一切都会变得非常简单，range()会帮助你快速的创建一个可迭代对象，我们只需要指定它的次数即可： for i in range(5): print(\"hello,world\") 关于range()方法的其他讲解，会在下面进行。 容器遍历 字符串遍历 示例演示： string = \"hello world\" for i in string: print(\"index : %s, value : %s\"%(string.index(i), i)) # index : 0, value : h # index : 1, value : e # index : 2, value : l # index : 2, value : l # index : 4, value : o # index : 5, value : # index : 6, value : w # index : 4, value : o # index : 8, value : r # index : 2, value : l # index : 10, value : d 列表遍历 普通遍历： lst = [1, 2, 3, 4] for i in lst: print(i) 通过enumerate()函数来同时遍历2个相同长度的列表： lst1 = [\"A\", \"B\", \"C\", \"D\"] lst2 = [\"a\", \"b\", \"c\", \"d\"] for index, item in enumerate(lst1): lst1Message = str.format( \"lst1 index position {} is data item {}\", index, item) print(lst1Message) lst2Message = str.format( \"lst2 index position {} is data item {}\", index, lst2[index]) print(lst2Message) 通过[::-1]来反向遍历列表： lst = [\"A\", \"B\", \"C\", \"D\"] for i in lst[::-1]: print(i) 隔一个取一个的遍历列表： lst = [\"A\", \"B\", \"C\", \"D\"] for i in lst[::2]: print(i) 字典遍历 普通的遍历只会遍历出key，这样的操作等同于遍历dict.keys()： dic = { \"k1\": \"v1\", \"k2\": \"v2\", \"k3\": \"v3\", } for k in dic: print(k) # k1 # k2 # k3 如果你想取出value，则可以遍历dict.values()： dic = { \"k1\": \"v1\", \"k2\": \"v2\", \"k3\": \"v3\", } for v in dic.values(): print(v) # v1 # v2 # v3 如果你想同时取出key和value，则可以遍历dict.items(): dic = { \"k1\": \"v1\", \"k2\": \"v2\", \"k3\": \"v3\", } for k, v in dic.items(): print(k, v) # k1 v1 # k2 v2 # k3 v3 局部作用域 如果一个迭代变量的命名为i，那么这个迭代变量能在外部访问到吗？答案是能！ 其实在Python2和Python3中，普通的for循环语句是没有局部作用域这一个说法的，希望在未来版本能有所改进。 for i in range(10): pass print(i) # 9 循环控制 continue 在while/for中均可以使用continue跳过本次循环。 以下用for循环进行举例： for i in range(5): if i == 3: continue else: print(i) # 0 # 1 # 2 # 4 break 在while/for中均可以使用break结束本层循环。 以下用for循环进行举例： for i in range(5): if i == 3: break else: print(i) # 0 # 1 # 2 循环嵌套 while嵌套 while循环支持多层嵌套，在使用时注意下面的事项： 如果是使用基于条件退出那么所有的while循环都必须遵循同一个条件才能退出 break只针对当前的while循环体退出，对于非当前的while循环体不生效 continue只针对当前while循环体跳过，对于非当前的while循环体不生效。 如下示例： tag = True while tag: print(\"outer while cycle start, current tag value is : %s\" % tag) while tag: print(\"intermediate while cycle start, current tag value is : %s\" % tag) while tag: print(\"inner while cycle start, current tag value is : %s\" % tag) tag = False # outer while cycle start, current tag value is : True # intermediate while cycle start, current tag value is : True # inner while cycle start, current tag value is : True for嵌套 for循环同样支持嵌套。 外层执行1次，内层的for循环要全部循环完成才回到外层执行第2次。 for i in range(65, 68): print(\"outer for cycle, current cycle value is : %s\" % chr(i)) for j in range(97, 100): print(\"inner for cycle, current cycle value is : %s\" % chr(j)) print(\"\") # outer for cycle, current cycle value is : A # inner for cycle, current cycle value is : a # inner for cycle, current cycle value is : b # inner for cycle, current cycle value is : c # outer for cycle, current cycle value is : B # inner for cycle, current cycle value is : a # inner for cycle, current cycle value is : b # inner for cycle, current cycle value is : c # outer for cycle, current cycle value is : C # inner for cycle, current cycle value is : a # inner for cycle, current cycle value is : b # inner for cycle, current cycle value is : c 以下是使用for循环打印乘法表的例子： for i in range(1, 10): for j in range(1, i+1): print(\"%s * %s = %s\" % (i, j, i*j), end=\"\\t\") print(\"\") range()详解 range() range()方法在Python2中返回的是一个列表，而在Python3中返回的是一个可迭代对象（这种可迭代对象不会存值，而是惰性求值，类似于生成器）。 range()方法有三个参数，如下表所示： 参数介绍 描述 start 从几开始生成 stop 生成到几结束 step 步长间距 在使用range()进行生成时，需要注意顾头不顾尾。 如下所示： lst = list(range(1, 10, 2)) print(lst) # [1, 3, 5, 7, 9] xrange() Python2中的xrange()与Python3中的range()相同，均返回可迭代对象，而非列表。 关于为什么做，其实是为了节省内存空间。 列表中的具体值会存在内存中，而如果是一个通过计算可惰性求值的可迭代对象，则不会消耗太大的内存，以下是自定义range()的实现。 class Range: def __init__(self, stop, start=0, step=1): self.start = start self.stop = stop self.step = step self.current = None def __iter__(self): return Range_iterator(self.stop, self.start, self.step) class Range_iterator: def __init__(self, stop, start, step): self.start = start self.stop = stop self.step = step self.current = self.start def __next__(self): if self.current 实例练习 将列表内的元素,根据位数合并成字典，列表如下： lst = [1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 32769, 65536, 4294967296] 答案： lst = [1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 32769, 65536, 4294967296] dic = {} for i in lst: k = len(str(i)) # 如果不存在该键，这该键等同于一个空列表 dic.setdefault(k, []) dic[k].append(i) print(dic) 使用for循环打印三角形： for i in range(1, 6): for j in range(1, 6 - i): print(\" \", end=\"\") for k in range(1, i + 1): print(\"* \", end=\"\") print(\"\") # * # * * # * * * # * * * * # * * * * * 有四个数字：1、2、3、4，能组成多少个互不相同且无重复数字的三位数？各是多少？ count = 0 for i in range(5): for j in range(1, 5): for k in range(1, 5): if (i != k) and (i != j) and (j != k): count += 1 print(i, j, k) print(count) # 36 斐波拉契数列是这样的一个数列：0、1、1、2、3、5、8、13、21、34、…… 前2个值加起来的结果恰好等于第3个值，求一个长度为10的斐波拉契数列： n = 10 fibArray = [] a , b = 0, 1 for i in range(n): fibArray.append(a) a, b = b, a + b print(fibArray) # [0, 1, 1, 2, 3, 5, 8, 13, 21, 34] 输入2个数字，求2个数字的最小公倍数： x = int(input(\">>>\")) y = int(input(\">>>\")) minCommonMultiple = None if x > y: greater = y else: greater = x while 1: if ((greater % x == 0 ) and (greater % y == 0)): minCommonMultiple = greater break greater += 1 msg = str.format(\"{0}和{1}的最小公倍数为{2}\", x, y, minCommonMultiple) print(msg) 输入2个数字，求2个数字的最大公约数： x = int(input(\">>>\")) y = int(input(\">>>\")) maxCommonDivisor = None if x > y: smaller = y else: smaller = x for i in range(1, smaller + 1): if ((x % i == 0) and (y % i == 0)): maxCommonDivisor = i msg = str.format(\"{0}和{1}的最大公约数为{2}\", x, y, maxCommonDivisor) print(msg) Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:46 "},"Python/Python基础知识/推导式.html":{"url":"Python/Python基础知识/推导式.html","title":"推导式","keywords":"","body":"推导式 Python从Haskell语言中取得灵感，创建了一系列的Python推导式（comprehension）。 它可以在不丧失代码可读性的前提下创建一系列容器，是Python颇受好评的特性。 列表推导式 应用场景 有一个列表中存了一些人名和性别的元组数据项，我需要将性别为男性（male）的数据项提取至一个新的列表中。 如下所示，在没有学习列表推导式之前， 你可能会这样做： oldList = [ (\"Tom\", \"Male\"), (\"Jack\", \"Male\"), (\"Mary\", \"Female\"), (\"Laura\", \"Female\") ] newList = [] for tpl in oldList: if tpl[-1].lower() == \"male\": newList.append(tpl) print(newList) # [['Tom', 'Male'], ['Jack', 'Male']] 如果有列表推导式的帮助，它就会简单许多，语法如下： newList = [ 被添加/操作的数据项 for 迭代变量 in 可迭代对象 if 条件] 列表推导式操作如下所示： oldList = [ (\"Tom\", \"Male\"), (\"Jack\", \"Male\"), (\"Mary\", \"Female\"), (\"Laura\", \"Female\") ] newList = [tpl for tpl in oldList if tpl[-1].lower() == \"male\"] # ❶ print(newList) # [['Tom', 'Male'], ['Jack', 'Male']] ❶：当数据项的判断为True时将自动添加至newList中，不能指定else条件 快速创建列表 使用列表推导式可以快速的创建一个列表。 如下所示，推导出数据项从1-10的列表： newLi = [i for i in range(1, 11)] print(newLi) # [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] 下面的示例中，我们可以快速的使用双层循环推导出了一副扑克牌的列表： newLi = [ i + str(j) for i in [\"❤\", \"♧\", \"♤\", \"♢\"] for j in range(1, 14)] newLi.append(\"bigKing\") newLi.append(\"smallKing\") print(newLi) 结果如下： ['❤1', '❤2', '❤3', '❤4', '❤5', '❤6', '❤7', '❤8', '❤9', '❤10', '❤11', '❤12', '❤13', '♧1', '♧2', '♧3', '♧4', '♧5', '♧6', '♧7', '♧8', '♧9', '♧10', '♧11', '♧12', '♧13', '♤1', '♤2', '♤3', '♤4', '♤5', '♤6', '♤7', '♤8', '♤9', '♤10', '♤11', '♤12', '♤13', '♢1', '♢2', '♢3', '♢4', '♢5', '♢6', '♢7', '♢8', '♢9', '♢10', '♢11', '♢12', '♢13', 'bigKing', 'smallKing'] 元素的处理 数据项在添加至列表之前，可以为其进行一些操作。 比如在上面扑克牌的示例中，我们将int对象转换为了str对象，同理也可以做一些别的操作。 如下示例，我们将推导出一个含有26字母的列表： newLi = [chr(i) for i in range(65, 91)] print(newLi) # ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'] 迭代变量 需要注意的是，迭代变量与条件成立后添加的数据项没有任何关系，如下所示，一行代码创建10个A： newLi = [\"A\" for i in range(10)] print(newLi) # ['A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A'] 对于这个题目，有一种更简便的解法： newLi = [\"A\"] * 10 字典推导式 使用示例 字典推导式和列表推导式大体差不多，但是外部是用花括号包裹，并且要有:进行key和value的区分。 如下所示，快速的推导出标准ASCII码表的对照关系： asciiDict = {i: chr(i) for i in range(0, 128)} print(asciiDict) 结果如下： {0: '\\x00', 1: '\\x01', 2: '\\x02', 3: '\\x03', 4: '\\x04', 5: '\\x05', 6: '\\x06', 7: '\\x07', 8: '\\x08', 9: '\\t', 10: '\\n', 11: '\\x0b', 12: '\\x0c', 13: '\\r', 14: '\\x0e', 15: '\\x0f', 16: '\\x10', 17: '\\x11', 18: '\\x12', 19: '\\x13', 20: '\\x14', 21: '\\x15', 22: '\\x16', 23: '\\x17', 24: '\\x18', 25: '\\x19', 26: '\\x1a', 27: '\\x1b', 28: '\\x1c', 29: '\\x1d', 30: '\\x1e', 31: '\\x1f', 32: ' ', 33: '!', 34: '\"', 35: '#', 36: '$', 37: '%', 38: '&', 39: \"'\", 40: '(', 41: ')', 42: '*', 43: '+', 44: ',', 45: '-', 46: '.', 47: '/', 48: '0', 49: '1', 50: '2', 51: '3', 52: '4', 53: '5', 54: '6', 55: '7', 56: '8', 57: '9', 58: ':', 59: ';', 60: '', 63: '?', 64: '@', 65: 'A', 66: 'B', 67: 'C', 68: 'D', 69: 'E', 70: 'F', 71: 'G', 72: 'H', 73: 'I', 74: 'J', 75: 'K', 76: 'L', 77: 'M', 78: 'N', 79: 'O', 80: 'P', 81: 'Q', 82: 'R', 83: 'S', 84: 'T', 85: 'U', 86: 'V', 87: 'W', 88: 'X', 89: 'Y', 90: 'Z', 91: '[', 92: '\\\\', 93: ']', 94: '^', 95: '_', 96: '`', 97: 'a', 98: 'b', 99: 'c', 100: 'd', 101: 'e', 102: 'f', 103: 'g', 104: 'h', 105: 'i', 106: 'j', 107: 'k', 108: 'l', 109: 'm', 110: 'n', 111: 'o', 112: 'p', 113: 'q', 114: 'r', 115: 's', 116: 't', 117: 'u', 118: 'v', 119: 'w', 120: 'x', 121: 'y', 122: 'z', 123: '{', 124: '|', 125: '}', 126: '~', 127: '\\x7f'} 第2个例子，对于迭代一些特殊格式的容器，可以直接生成出一个字典： userMessage = [(\"name\", \"Yunya\"), (\"age\", 18), (\"gender\", \"male\")] newDict = {k: v for k, v in userMessage} print(newDict) # {'name': 'Yunya', 'age': 18, 'gender': 'male'} 集合推导式 使用示例 集合推导式只需要将列表推导式的[]改为{}即可。 以下是示例演示，很显然，由于是集合推导式，故下面的双层循环并不会产生重复元素： newSet = {j for i in range(10) for j in range(10)} print(newSet) # {0, 1, 2, 3, 4, 5, 6, 7, 8, 9} 局部作用域 之前聊过普通的for循环中是不存在局部作用域的，那么在推导式当中是否存在局部作用域呢？ 以列表举例： newList = [i for i in range(10)] print(i) # NameError: name 'i' is not defined 可以看见，在推导式中的局部作用域是存在的。 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:46 "},"Python/Python基础知识/字符编码.html":{"url":"Python/Python基础知识/字符编码.html","title":"字符编码","keywords":"","body":"存储编码 一般来说，我们用什么方式进行文件存储，就用什么编码方式对其进行打开，一般使用UTF8进行存储和打开文件即可。 执行编码 Python3中在执行代码时，解释器都会按照UTF8编码格式将脚本文件中的代码加载至内存中，所以一般不会出现问题。 但是在Python2里解释器则是使用ASCII的编码格式进行脚本文件内容的解码。 所以你可能会遇上下面的情况： SyntaxError:Non-ASCII character .... in file ... 解决这个办法，可以利用头文件代码，让Python解释器在解码脚本文件内容时，以UTF8格式进行解码： # --*-- coding:UTF8 --*-- # 开始书写你的代码 可以使用sys的getdefaultencoding()方法来查看Python解释器默认采用的执行编码格式： >>> # Python2 >>> import sys >>> sys.getdefaultencoding() 'ascii' >>> # Python3 >>> import sys >>> sys.getdefaultencoding() 'utf-8' Unicode字符串 Python2中的str类型，本质是Python3中的bytes，所以仅支持ASCII码表中的字符。 如果想将其转换为Unicode字符串，则必须在前面加上u： print u\"这是Unicode字符串\" Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:46 "},"Python/Python基础知识/文件操作.html":{"url":"Python/Python基础知识/文件操作.html","title":"文件操作","keywords":"","body":"open() Python中提供了open()方法用于对文件进行操作，该方法会返回一个文件对象。 由于被读取的文件内容本身全部属于str类型，故使用open()方法对其进行操作必然涉及字符编码的问题。 以下是open()方法的函数签名： def open(file: Union[str, bytes, int, _PathLike[Any]], mode: str = ..., buffering: int = ..., encoding: Optional[str] = ..., errors: Optional[str] = ..., newline: Optional[str] = ..., closefd: bool = ..., opener: Optional[Callable[[str, int], int]] = ...) -> IO[Any]: 下面是对常用参数的解释： 参数名 描述 file 必需，文件路径（相对或者绝对路径） mode 可选，文件内容读取与操作模式，*t模式以为文本内容读取模式打开文件。需要填入encoding，b模式为二进制模式读取文件内容，默认该参数为*t 。*代表操作模式 encoding 可选（Python2没有该参数），当mode为 *t 时指定编码或解码格式。一般设置为 utf-8。如不指定Windows平台默认为GBK，Mac和Linux平台为utf-8 buffering 设置缓冲 errors 报错级别 newline 是否区分换行符，默认为True closefd 传入的file参数类型 以下是在Python3中进行读取文件的简单示例： f = open(file=\"test.txt\", mode=\"rt\", encoding=\"utf-8\") print(f.read()) # ❶ f.close() # ❷ ❶：read()读取所有内容 ❷：关闭文件句柄 with语句 在open()后要切记关闭文件句柄，释放系统资源，这是一项非常重要但很容易被人忽视的细节点。 故推荐使用with语句进行文件操作，它将在with子代码块结束后自动关闭文件句柄。 with open(file=\"test.txt\", mode=\"rt\", encoding=\"utf-8\") as f: print(f.read()) 使用with语句还可以同时打开多个文件，示例如下，\\可进行换行： with open(file=\"test.txt\",mode=\"rt\",encoding=\"utf-8\") as f1,\\ open(file=\"test2.txt\",mode=\"rt\",encoding=\"utf-8\") as f2: data1 = f1.read() print (data1) data2 = f2.read() print (data2) 读写内容模式 t模式 当打开一个文件时，默认以*t模式打开。 t代表以文本方式读取文件内容，读取的都是字符。 with open(file=\"test.txt\", mode=\"rt\", encoding=\"utf-8\") as f: result = f.read(3) # ❶ print(result) ❶：指定读取的字符数量 b模式 如果以b模式打开文件，则读取到的都是字节。 若使用字节模式打开文件，则不存在字符编码的问题 with open(file=\"test.txt\", mode=\"rb\") as f: result = f.read(3) # ❶ print(result) # b'\\xe6\\xb5\\x8b' hans = result.decode(\"utf-8\") print(hans) # ❷ ❶：指定读取的字节数量 ❷：解码 读写操作模式 r模式 r代表只读，使用r模式打开文件时文件的指针将跑到最开始。 如果文件不存在将会抛出异常，并且只能使用读取相关的方法。 with open(file=\"test.txt\", mode=\"rb\") as f: print(f.readlines()) w模式 w模式代表只写，使用w模式打开文件时就相当于新建一个文件。 如果文件已存在将清空原本文件中所有的内容，如果文件不存在则创建新文件，并且只能使用写入相关的方法。 with open(file=\"test.txt\", mode=\"wb\") as f: data = \"你好世界\" f.write(data.encode(\"utf-8\")) a模式 a模式为追写模式，当文件不存在时创建新文件，只能执行写相关的操作。 当文件存在时则打开文件，文件指针放到最后，所以被称为追写模式。 强调 w 模式与 a模式的异同： 相同点：在打开的文件不关闭的情况下，连续的写入，新写的内容总会跟在前写的内容之后 不同点：以 a 模式重新打开文件，不会清空原文件内容，会将文件指针直接移动到文件末尾，新写的内容永远写在最后 with open(file=\"test.txt\", mode=\"ab\") as f: f.write(b'\\nnew line...') x模式 x模式与w模式都相同。 唯一不同的地方在于如果需要打开的文件已存在，x模式会抛出异常。 而w模式会新建一个同名文件并且删除掉旧文件。 with open(file=\"test.txt\", mode=\"xb\") as f: f.write(b'\\nnew line...') # FileExistsError: [Errno 17] File exists: 'test.txt' +模式 +这里是对 r w a 的一种扩展。 代表可读可写，但是打开文件后文件指针的位置还是依照 r w a 原本的位置，应该尽量少用+方法。 with open(file=\"test.txt\", mode=\"r+b\") as f: data = f.read() print(data) f.seek(0, 2) f.write(b\"A new line again\\n\") 文件指针 使用seek()函数可以对文件指针进行操作。 以下是seek()函数的签名： def seek(self, offset: int, whence: int = 0) -> int 注意，使用文件指针应该在*b模式下进行使用，它的移动将会按照字节进行移动。 如果是*t模式下，按照字符移动可能会出现某些错误。 参数 描述 offset 偏移量，负数代表向前移动指针，正数代表向后移动指针 whence 偏移位置，0代表起始位置，1代表当前位置，2代表结束位置 示例如下： with open(file=\"test.txt\", mode=\"rb\") as f: # ❶ print(f.tell()) # ❷ f.seek(2, 0) f.seek(10, 0) f.seek(20, 0) print(f.tell()) # ❸ f.seek(-2, 1) f.seek(-3, 1) f.seek(-4, 1) print(f.tell()) # ❹ # 0 # 20 # 11 ❶：注意，文件指针除了（0，0）和（0，2）外，其他都应该用b模式进行。 ❷：打印当前文件指针的位置 0 ❸：打印当前文件指针的位置 20 ❹：由于是相对定位，故可以累加。 20 - 9 ，文件指针在 11 循环读取 for循环 如果直接使用f.read()，当文件内容过于庞大时，这些内容全部会存放于Python程序的内存空间中。 会给内存带来极大的压力，故在文件较小时才使用f.read()，太大的话将使用其他解决方案，如下面的for循环进行读取： data = b\"\" with open(\"test.txt\", mode=\"rb\") as f: for line in f: # ❶ data += line print(data.decode(\"utf-8\")) ❶：直接读取f代表每次读一行，以\\n为单位 while循环 如果一个文件只有一行，如压缩版的前端代码。 在读取时则可使用while循环进行读取，示例如下： data = b\"\" with open(\"test.txt\", mode=\"rb\") as f: while 1: temp = f.read(512) data += temp if not len(temp): break print(data.decode(\"utf-8\")) 文件写入 内存写入 文本编辑器的原理是在打开一个文本文件时其中所有的内容都会加载并存放至内存中。 对该文本内容的修改实际上全部都是在修改内存中的数据，当修改完成后点击保存时才会将内存的数据重新写入至硬盘中。 你应该深有体会，打开一个特别大的文本文件时速度很慢，哪怕没做任何修改保存时速度也还是很慢，实际上就是这个原因导致的。 以下是模拟内存写入，打开文件后将“计算机”替换为“电脑”： data = \"\" # ❶ with open(file=\"BigFileTest.txt\", mode=\"rt\", encoding=\"utf-8\") as f: # ❷ while 1: temp = f.read(512) data += temp # ❸ print(data) # ❹ if not len(temp): # ❺ break print(\"读取完毕..\") data = data.replace(\"计算机\", \"电脑\") # ❻ with open(file=\"BigFileTest.txt\", mode=\"wt\", encoding=\"utf-8\") as f: # ❼ f.write(data) print(\"写入完毕..\") ❶：用于存放数据 ❷：r模式的指针默认放在0位置 ❸：代表每次读取512个字符 ❹：这里可以做其他操作 ❺：代表没有新的内容。 len(temp) == 0 ❻：模拟手动修改文件内容。将计算机修改为电脑，注意此时修改的是内存中的数据 ❼：读取后将Python应用程序中维护的data变量中的数据全部写入该文件。w模式会清空源文件的内容 硬盘时刷 文本编辑器的做法是在内部维护了一个变量，用于提供给用户修改内容。 这么做的好处就是用户可以在修改文件内容时能够查看到所有的文件内容，但是坏处是占用内存空间太大。 这里再介绍一种减少内存压力的方式。 注意：两种方式没有优劣之分，只有使用场景不同的区别，还是和上面一样的操作，将“计算机”替换为“电脑”。 import os with open(file=\"BigFileTest.txt\", mode=\"rt\", encoding=\"utf-8\") as f1, \\ open(file=\".BigFileTest.txt.swap\", mode=\"wt\", encoding=\"utf-8\") as f2: # ❶ for line in f1: line = line.replace(\"计算机\", \"电脑\") # ❷ f2.write(line) # ❸ print(\"操作完成..\") os.remove(\"BigFileTest.txt\") # ❹ os.rename(\".BigFileTest.txt.swap\", \"BigFileTest.txt\") # ❺ 这么做的坏处是没办法随时的修改内存中的变量数据，因为内存中根本没存文本文件内容。 只能按照设定好的程序走一遍，但是极大的节省了内存空间的占用。 ❶：以. 开头的文件代表隐藏文件。以swap结尾的文件代表交换文件（可以理解为临时文件） ❷：每次拿到和修改的只有line ❸：写入交换文件中 ❹：删除源文件 ❺：修改临时文件的名字。与源文件保持一致 操作方法 以下是文件操作中常用的方法： 方法 描述 read() 读取某个文件(全部内容)。也可指定大小，t模式的大小为字符单位，b模式为字节单位 readline() 读取一行文件内容 readlines() 读取所有文件内容并返回一个列表，以行割开 write() 写入一行数据，默认不会\\n需要手动换行 writelines() 写入一行数据，通过列表的方式写到文件里面 tell() 显示当前文件光标的位置 seek() 移动当前文件光标的位置(字节为单位，建议在b模式下使用) readable() 文件是否可读 writable() 文件是否可写 closed 文件是否关闭 encoding 如果文件打开模式是b,则没有该属性 flush() 立刻将文件内容从内存刷到硬盘（测试模式下使用） Python2-open() 由于Python2中不能使用encoding参数指定编解码的方式。所以我们看看在Python2中open()应该怎样使用： #!/usr/bin/env python2 # coding:utf-8 # import sys # reload(sys) # sys.setdefaultencoding('utf-8') # 设置默认的解码方式为 utf-8。如果这样操作就不用设置decode()了。 f = open(file=\"test.txt\",mode=\"rt\",) data = unicode(f.read().decode(\"utf-8\")) # unicode()将读取出的字符转为unicode字符存储于内存中。 print data f.close() Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:46 "},"Python/Python函数相关/summary.html":{"url":"Python/Python函数相关/summary.html","title":"Python函数相关","keywords":"","body":" 初识函数 使用函数 参数详解 命名空间 高阶函数 递归函数 匿名函数 内置函数 装饰器 迭代器 生成器 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:46 "},"Python/Python函数相关/初识函数.html":{"url":"Python/Python函数相关/初识函数.html","title":"初识函数","keywords":"","body":"函数 在编程语言中的函数不同于数学中的函数（function）。 不管是数学上的函数还是编程语言中的函数都是为了完成特定的某一功能而诞生的，他们的区别在于： 数学中的函数当输入的值是固定的情况下那么输出的值也一定是固定的。 它内部不允许原本输入的值状态发生改变。 编程语言中的函数则可以允许传入的值进行修改的。 如果按照数学函数的定义来做编程语言的函数，那么这种函数则被称为纯函数（pure function） 分类 在Python中，函数主要有两类： 内置函数（Built-in function） 自定义函数（Custom function） 如，id()、type()、print()等均属于内置函数，内置函数又被称为工厂函数。 内置函数的实现初衷是将一些经常使用的功能进行封装，并且同Python解释器一起提供给开发者，开发者开箱即用，不必关心底层的算法实现。 而自定义函数是指在内置函数无法完成需求的情况下，由开发人员去自己创作的为了满足特定的某一项功能的可重复使用的具体代码集合。 函数的特点 函数主要解决流式代码的2大问题： 代码冗余度高，程序的组织结构不清晰，可读性差 可维护性以及可扩展性差 函数的特点如下： 提供封装性，用户在外部不用关心内部如何实现 提供可重复调用，开发人员最大限度的减少了重复代码的实现 提升程序可读性，对特定的功能进行分类，使后期维护变的简单 举一个简单的例子，如果没有定义函数，要打印100次“hello world”则需要写一百行下面的代码： print(\"hello world\") print(\"hello world\") print(\"hello world\") print(\"hello world\") ... 而如果使用了函数，则只需调用100次函数即可： def func(): print(\"hello world\") func() func() func() ... 函数与方法 函数（function）与方法（method）都是一个具体功能的实现，它们本质都是一个东西。 区别在于函数允许大多数类型进行调用，而方法只允许特定类型进行调用。 如： id()：允许所有类型进行调用，因此被称为 “函数” format()：只允许str类型进行调用，因此被称为 “方法” 可调用性 函数和方法都是可调用的，如何判断一个对象是否可调用？ 可以使用内置函数callable()进行判断，如下所示，只需在callable()中传入函数名即可： >>> callable(print) True >>> callable(input) True Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:46 "},"Python/Python函数相关/使用函数.html":{"url":"Python/Python函数相关/使用函数.html","title":"使用函数","keywords":"","body":"函数使用 内置函数 内置函数是被内部定义好的一些函数，直接调用即可。 但是要严格传入函数所需要的参数，为此，你可以查看Python内置函数源代码，获得函数签名： def bin(*args, **kwargs): # real signature unknown; NOTE: unreliably restored from __doc__ \"\"\" Return the binary representation of an integer. >>> bin(2796202) '0b1010101010101010101010' \"\"\" pass 自定义函数 对于自定义函数来说，与对象声明相同，必须先定义后使用。 以下是语法格式： def 函数标识符(参数1, 参数2): # ❶ \"\"\"功能描述文档\"\"\" # ❷ 逻辑体代码块 # ❸ return 返回值 # ❹ ❶：def为关键字，用于定义一个函数。函数名即函数标识符，参照变量标识符的命名规则。参数是可选的，可以没有 ❷：功能描述文档可有可无，这是提供给用户的帮助信息，可以使用help()函数通过传入函数标识符获得该功能描述文档 ❸：函数的逻辑体代码块，用于具体实现某一功能 ❹：用于返回给用户需要的结果，如果不返回默认返回None 如何使用 函数标识符指向的是函数对象在内存空间的引用，也就是函数体代码块： >>> print 当加上括号后，将自动调用该函数，此时则根据函数签名需求传入对应参数即可： >>> print(\"hello world\") hello world 也就是说，函数标识符不加括号不会调用，只是拿到函数的引用，而加括号后才会执行函数内部的逻辑代码。 定义函数 无参函数 无参函数大多数情况下只是希望该函数单纯的做一点什么事情而并不需要该函数给返回一个结果。 常用于一段特定功能的重复调用，如我想在某种特定的情况下打印出WARNING信息，此时就可以定义一个无参函数： import sys import datetime def warning(): message = str.format( \"WARNING time: file:[{1}] - line:[{2}]\", datetime.datetime.now(), # ❶ sys._getframe().f_code.co_filename, # ❷ sys._getframe().f_back.f_lineno # ❸ ) print(message) warning() print(datetime.datetime.now()) # WARNING time: file:[/Users/Project/demo.py] - line:[13] ❶：获取当前时间 ❷：获取被调用函数所在模块文件名 ❸：获取被调用函数在被调用时所处代码行数 有参函数 函数的参数用于接收用户传入的对象，可以认为传入的对象是指“待加工原材料”。 当函数执行完成后，通过加工“原材料”将会返回一个加工后的“产品”。 以下示例中将计算2个值的相加结果： def add(x, y): res = x + y return res # ❶ result = add(1, 2) print(result) # 3 ❶：返回加工完成后的“产品”，该产品被外部使用result标识符进行接收 空函数 只定义函数名并未做具体实现的函数叫做空函数，空函数在逻辑构思中常被用到。 关键词：pass或者Ellipsis对象。 如下所示： def add(x, y): pass # ❶ def sub(x, y): ... # ❷ ❶：代表省略 ❷：Ellipsis对象，代表省略，仅在Python3中适用 函数调用 语句形式 在函数标识符后加上括号进行调用即可： >>> print(\"hello world\") hello world 表达式形式 表达式形式可以将函数返回的对象赋值给一个标识符，如下所示： def add(x, y): res = x + y return res result = add(1, 2) print(result) # 3 也可以直接对这个函数返回的对象进行操作，如下所示： def add(x, y): res = x + y return res result = add(1, 2) * 10 print(result) # 30 参数调用形式 函数可以作为参数传递给其他函数： def add(x, y): res = x + y return res result = add(add(1, 2), 3) # ❶ print(result) # 6 ❶：相当于add(3, 3) 函数返回值 默认返回值 Python中的函数一定具有返回值。 如果没有显式的使用return关键字指定返回值，则默认会返回None。 def add(x, y): ... result = add(1, 2) print(result) # None return返回值 return有2个作用： 返回函数的执行结果，可以返回1个，也可以返回多个，若返回多个则以元组形式返回 跳出所有的循环体（如果在多层的循环中使用return，将直接跳出所有循环，并且将结果进行返回） 如下示例， 获得指定范围区间的累加结果： def accumulate(start, stop): res = 0 for i in range(start, stop + 1): res += i return res result = accumulate(1, 100) print(result) # 5050 返回多个值时，将以元组形式进行返回，如下示例中输入一个ASCII码表的字符，返回其ASCII码表中对应的大小写编号（a - z具有2个编号，符号只有1个编号）： def getAscii(char): asciiTable = {chr(i) : i for i in range(0, 128)} lowerKey = char.lower() capitalKey = char.upper() return asciiTable[lowerKey], asciiTable[capitalKey] lowInt, capitalInt = getAscii(\"a\") print(lowInt, capitalInt) # 98 66 函数执行 函数必须先定义后使用，否则无法执行： func() def func(): print(\"run ...\") # NameError: name 'func' is not defined 嵌套调用 Python是解释性语言，解释一行执行一行。 当碰见def关键字开头的语句，内部会检测一下该代码块的语法，如果没有出现问题则代表该函数定义好了。 只有碰到函数名加括号的情况下才会去执行该函数。 所以，函数也可以进行嵌套调用，不过我个人不太喜欢这种调用方法，我更倾向于传参调用，在代码维护时更加的方便： def func1(): print(\"run ... func1\") def func2(): print(\"run ... func2\") func1() print(\"run stop\") func2() # run ... func2 # run ... func1 # run stop 内部逻辑 当定义一个函数时，会发生3件事情： 申请内存空间，保存函数体代码 将内存地址编号绑定给函数标识符（函数名） 定义函数并不会执行函数体内部代码，但是会检测函数体的语法 当调用一个函数时，也会发生3件事情： 通过函数标识符找到函数在内存中存在的位置 加上括号是一种语法格式，代表执行函数体内部的代码 调用系统调用栈，创建一个函数的栈帧片段并压入栈中 我们以函数嵌套的例子来分析它的定义和执行流程： def func1(): print(\"run ... func1\") def func2(): print(\"run ... func2\") func1() print(\"run stop\") func2() 定义函数 在Python解释器解释到到第1行、第3行的时候，会加载函数体代码，检查函数体语法，若无误则将其编译为字节码： 随后会加载函数标识符，func1与func2，并且会在内存中将函数体代码进行保存，让函数标识符与在内存中保存的函数体代码进行绑定： 如上图所示，现在还未开始执行函数，内存中已有func1，func2了。 执行函数 开始分析第9行的执行函数func2()，当Python解释器发现函数标识符加了一个括号后，知道这是要调用函数，会顺着函数名找到在内存中的函数体代码： 当开始真正执行func2()函数体代码后，系统调用栈会创建出一个独一无二的函数栈帧，函数栈帧会将函数的字节码、谁调用的它、以及函数内部定义的变量（如参数）等关键信息进行保存。 在第6行，发现又执行func1()，这个func1()是在func2()内部执行的所以Python解释器会在func2()栈帧的基础上运行func1()的代码，同理也会创建func1()函数的栈帧： 当func1()执行完毕后，发现没有返回值，则加载常量None并做为默认的返回结果，此时会一并弹出func1()的栈帧，常量None将返回给func1()的调用处： 然后func2()也执行完毕，发现没有返回值，加载常量None并做为默认的返回结果，此时会一并弹出func2()的栈帧，常量None将返回给func2()的调用处： Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:46 "},"Python/Python函数相关/参数详解.html":{"url":"Python/Python函数相关/参数详解.html","title":"参数详解","keywords":"","body":"形参与实参 什么是传参 将需要被处理的对象传递给函数的行为，被称为传参。 形参介绍 在定义函数时，函数需要使用1个或者多个标识符来接收到外部传递进的对象。 这个标识符就是形参： def func(x, y, z): \"\"\" :param x: 形参x :param y: 形参y :param z: 形参z :return: None \"\"\" ... 可以理解为形参是函数（工厂）的预留位置，你将“原材料”放在这些位置上才能被工厂所接收到。 实参介绍 在调用函数时，外部向函数传入的对象则被称为实参。 def func(x, y, z): \"\"\" :param x: 形参x :param y: 形参y :param z: 形参z :return: None \"\"\" ... # 传入实参1，2，3 func(1, 2, 3) 可以理解为实参是待加工的“原材料”， 需要将这些“原材料”放到指定的工厂预留位置上（形参）才能被工厂所接收。 两者关系 由于Python中一切皆引用，故实参传递给形参的也就是同一个对象，这种传参被称为引用传参。 2者总结关系有3点： 在函数调用时，实参将对象传递给形参后，对象的引用计数会+1 在函数内部，可以通过形参访问到该对象 形参与对象的绑定关系在函数调用结束后就会被取消掉 下面示例将验证形参和实参引用的都是同1个对象： x = 1 def func(x): print(id(x)) func(x) print(id(x)) # 4518684720 # 4518684720 形参定义 位置参数 函数定义时从左至右依次排列的没有特殊意义的形参被称为位置形参，位置形参必须被对象传入，多一个少一个都不行。 如果传入的不够、或者传入的过多，将会抛出异常： def func(x, y, z): ... 传少了： func(1) # TypeError: func() missing 2 required positional arguments: 'y' and 'z' 传多了： func(1, 2, 3, 4) # TypeError: func() takes 3 positional arguments but 4 were given 默认参数 默认形参是指可以不用被传递对象的形参，它拥有1个默认的对象。 如果调用函数时没有传入对象，则使用该默认的对象 如果调用函数时传入了1个对象，则使用接收到的对象 需要注意在定义默认形参时必须放在位置形参后面，否则会抛出异常。 def func(x, y, z=3): print(x, y, z) func(1, 2) func(\"A\", \"B\", \"C\") # 1 2 3 # A B C 传参方式 位置传参 如果是位置形参，则实参传入对象时必须严格按照形参的位置顺序、形参的总体数量进行传入。 如果传入的不够、或者传入的过多，将会抛出异常： def func(x, y, z): ... 传少了： func(1) # TypeError: func() missing 2 required positional arguments: 'y' and 'z' 传多了： func(1, 2, 3, 4) # TypeError: func() takes 3 positional arguments but 4 were given 关键字传参 使用位置传参时，我们要牢记形参的位置，这样比较麻烦。 可以直接通过 key = value 的形式进行传入，避免了需要记住形参位置的繁琐步骤，但是关键字传参必须放置在位置传参后面，也是个人比较推崇的一种传参方式： def func(x, y, z=3): print(x, y, z) func(y=2, x=1, z=3) func(1, z=3, y=2) # 1 2 3 # 1 2 3 *与**语法使用 *的形参接收 *语法用在形参上，代表该形参可以接收任意数量的位置传参对象。 该形参将会变成一个元组形式，接收所有的位置传参对象，这种形参必须定义在位置形参与默认形参的后面： def func(x, y=2, *args): print(x, y, args) func(1, 2, 3, 4, 5, 6, 7, 8, 9) # 1 2 (3, 4, 5, 6, 7, 8, 9) **的形参接收 **语法用在形参上，代表该形参可以接收任意数量的关键字传参对象。 该形参将会变成一个字典形式，接收所有的关键字传参对象，这种形参必须定义在位置形参与默认形参以及*形参的后面： def func(x, y=2, *args,**kwargs): print(x, y, args, kwargs) func(1, 2, 3, 4, 5, 6, 7, 8, 9, a=ord(\"a\"), b=ord(\"b\"), c=ord(\"c\")) # 1 2 (3, 4, 5, 6, 7, 8, 9) {'a': 97, 'b': 98, 'c': 99} *的实参传入 通过*语法，我们可以将1个容器序列根据位置传参的方式把其中的数据项对象传递给形参，如下所示： def func(x, y, z): print(x, y, z) func(*(1, 2, 3)) # 1 2 3 **的实参传入 通过**语法，我们也可以将1个字典根据关键字传参的方式把字典中的value对象传递给形参，如下所示： def func(x, y, z): print(x, y, z) func(**{\"x\": 1, \"y\": 2, \"z\": 3}) # 1 2 3 *args与**kwargs *形参通常命名为*args，这是一种约定的俗称。 同理，**形参则被命名为**kwargs。 指定传入方式 形参中，如果存在一个*名字的特殊标识，则该标识不用传递对象。 该标识是规定了哪些形参必须是接收位置传入的对象、哪些形参是必须接收关键字传入的对象，如下所示： def func(a, b=2, *, c=3, d): # ❶ print(a, b, c, d) func(1, d=4) ❶：在 *左边的都是位置传入，在*右边的都是关键字传入，在*右边的参数也被称为命名关键字参数 a：位置传入，不是默认参数，则必须通过位置传参的方式传入对象 b：位置传入，是默认参数，可以不用通过位置传参的方式传入对象 c：关键字传入，不是默认参数，则必须通过关键字传参的方式传入对象 d：关键字传入，是默认参数，可以不用通过关键字传参的方式传入对象 形参的定义顺序 形参的定义顺序如下所示： 位置形参 -> 默认形参 -> *args -> **kwargs 示例演示： def func(a, b, c=\"c\", *args, **kwargs): print(\"\"\" position params: {} {} default params: {} * params:{} ** params:{} \"\"\".format(a, b, c, args, kwargs)) func(\"A\", \"B\", \"C\", 1, 2, 3, 4, 5, k1=\"v1\", k2=\"v2\") # position params: A B # default params: C # * params:(1, 2, 3, 4, 5) # ** params:{'k1': 'v1', 'k2': 'v2'} 实参的传入顺序 实参的传入顺序牢记位置传参在前，关键字传参在后即可。 或者统一使用关键字传参，示例如下： def func(a, b, c, d, e, f): pass func(\"A\", *[\"B\", \"C\"], d=\"D\", **{\"e\": \"E\", \"f\": \"F\"}) # eq： # func(\"A\", \"B\", \"C\", d=\"D\", e=\"E\", f=\"F\") 嵌套调用中*与** 当函数2作为函数1的一层外包装，我们想调用函数2的时候实际上是调用的函数1，并且参数也要完整的传递过去，该怎么做呢？ Ps：这其实是装饰器的一个前瞻知识点 def func(x, y, z): print(x, y, z) def wrapper(*args, **kwargs): func(*args, **kwargs) # ❶ ❷ wrapper(1, y=\"v1\", z=\"v2\") # 1 v1 v2 ❶：实参用 * 和 ** 拆分开， * 是位置传参，**是关键字传参 ❷：args = (1)，kwargs = {\"y\":\"v1\",\"z\":\"v2”}，然后再通过解构进行传递给func函数，func相当于接收了 func(1, y=“v1”, z=“v2”) 函数标注 Python3.5之后新增了函数标注（function annotation），即类型提示功能如下所示，仅做提示，并不会限制传递参数时的类型： def add(x: int or float, y: int or float) -> int or float: # ❶ print(x) print(y) return x + y ❶：->代表返回值，返回int或者float类型 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:46 "},"Python/Python函数相关/命名空间.html":{"url":"Python/Python函数相关/命名空间.html","title":"命名空间","keywords":"","body":"Python之禅 传奇的Python核心开发者，Tim Peters为我们总结了Python核心思想点，收录在了内置模块this中： >>> import this The Zen of Python, by Tim Peters Beautiful is better than ugly. Explicit is better than implicit. Simple is better than complex. Complex is better than complicated. Flat is better than nested. Sparse is better than dense. Readability counts. Special cases aren't special enough to break the rules. Although practicality beats purity. Errors should never pass silently. Unless explicitly silenced. In the face of ambiguity, refuse the temptation to guess. There should be one-- and preferably only one --obvious way to do it. Although that way may not be obvious at first unless you're Dutch. Now is better than never. Although never is often better than *right* now. If the implementation is hard to explain, it's a bad idea. If the implementation is easy to explain, it may be a good idea. Namespaces are one honking great idea -- let's do more of those! Python之禅 by Tim Peters 优美胜于丑陋（Python 以编写优美的代码为目标） 明了胜于晦涩（优美的代码应当是明了的，命名规范，风格相似） 简洁胜于复杂（优美的代码应当是简洁的，不要有复杂的内部实现） 复杂胜于凌乱（如果复杂不可避免，那代码间也不能有难懂的关系，要保持接口简洁） 扁平胜于嵌套（优美的代码应当是扁平的，不能有太多的嵌套） 间隔胜于紧凑（优美的代码有适当的间隔，不要奢望一行代码解决问题） 可读性很重要（优美的代码是可读的） 即便假借特例的实用性之名，也不可违背这些规则（这些规则至高无上） 不要包容所有错误，除非你确定需要这样做（精准地捕获异常，不写 except:pass 风格的代码） 当存在多种可能，不要尝试去猜测 而是尽量找一种，最好是唯一一种明显的解决方案（如果不确定，就用穷举法） 虽然这并不容易，因为你不是 Python 之父（这里的 Dutch 是指 Guido ） 做也许好过不做，但不假思索就动手还不如不做（动手之前要细思量） 如果你无法向人描述你的方案，那肯定不是一个好方案；反之亦然（方案测评标准） 命名空间是一种绝妙的理念，我们应当多加利用（倡导与号召） 而今天我们主要探索的内容就是这最后一句，命名空间。 以下内容将围绕Python之禅最后一句话来进行逐一解惑。 Tim Peters是一位高产的Python开发者，在Python1.0版本之前就已经贡献出大量的代码，如li.sort()的排序算法TimSort就是Tim Peters所贡献，并且最终在Python2.x版本中进行使用 NameSpaces 命名空间即存储所有标识符（变量名、函数名、类名）的地方。 它本身是一种虚拟的概念，实际上并不存在。 命名空间分为3大类： 内置命名空间（Builtin NameSpaces） 全局命名空间（Global NameSpaces） 局部命名空间（Local NameSpaces） 不同的命名空间，存储的标识符范畴也不同，如下所示： 内置命名空间：存储Python解释器自带的标识符 全局命名空间：存储未在类、函数、方法中定义的标识符 局部命名空间：在调用类、函数、方法时产生的标识符 我们以一个代码和一幅图来举例： name = \"Jack\" age = 18 gender = \"male\" def add(x , y): res = x + y return res def sub(x, y): res = x - y return res Builtin NameSpaces 内置命名空间： 存放的标识符：Python解释器自带的函数标识符、变量标识符、类标识符等，如print、input、open等... 生命周期：Python解释器启动时产生，关闭时销毁 允许的数量：至多1个 示例演示： >>> print >>> input >>> open Global NameSpaces 全局命名空间： 存放的标识符：未在类、函数、方法中定义的标识符 生命周期：Python脚本文件执行时产生，执行完毕时销毁 允许的数量：至多1个 示例演示： name = \"Jack\" age = 18 gender = \"male\" def mathFunctionSet(method, x, y): def add(x, y): res = x + y return res def sub(x, y): res = x - y return res methodNameMapping = { \"add\":add, \"sub\":sub } return methodNameMapping[method](x,y) 上述示例中共有1个全局命名空间，存储的标识符有： name age gender # 变量标识符 mathFunctionSet # 函数标识符 Local NameSpaces 局部命名空间： 存放的标识符：在调用类、函数、方法时产生的标识符 生命周期：对于函数的局部命名空间来说，函数调用时存活，调用完毕则销毁 允许的数量：可以有多个局部命名空间，取决于内存大小 示例演示： name = \"Jack\" age = 18 gender = \"male\" def mathFunctionSet(method, x, y): def add(x, y): res = x + y return res def sub(x, y): res = x - y return res methodNameMapping = { \"add\":add, \"sub\":sub } return methodNameMapping[method](x,y) 上述示例中共有3个局部命名空间，如下所示： mathFunctionSet的局部命名空间存储的标识符： method x y add sub methodNameMapping add局部命名空间存储的标识符： x y res sub局部命名空间存储的标识符: x y res 顺序相关 加载和销毁顺序 加载顺序：内置命名空间 -> 全局命名空间 -> 局部命名空间 销毁顺序：局部命名空间 -> 全局命名空间 -> 内置命名空间 命名空间封闭性 在全局命名空间中无法访问局部命名空间定义的标识符，但是局部命名空间中可以访问全局命名空间的标识符，如下所示： globalName = \"global\" def function(): localName = \"function\" print(localName) function() print(localName) # function # NameError: name 'localName' is not defined 当然，内置命名空间是在哪里都可以进行访问。 标识符查找顺序 先在自己的命名空间中找，找不到就往定义自己的命名空间中找，最后查找内置命名空间。 如下代码示例： name = \"global\" def outer(): name = \"outer\" inner() # ❷ def inner(): print(name) # ❸ outer() # ❶ 首先我们是在全局命名空间中定义了outer()函数的标识符、inner()函数的标识符以及name变量标识符。 ❶：运行outer()函数 ❷：运行inner()函数 ❸：inner()中查找name，inner()的局部命名空间中没有name标识符，往定义自己的命名空间找，即到全局命名空间，最终找到name标识符 标识符的覆盖特性 如果全局/局部命名空间与内置命名空间中的标识符发生冲突，则最先查找到全局/局部命名空间中的标识符。 这也是为什么在第一章的时候就说到标识符的命名应该避免关键字，示例如下： print(callable(input)) # ❶ input = \"..\" print(callable(input)) # ❷ # True # False ❶：input此时引用的是内置命名空间的input()函数，所以可调用 ❷：全局命名空间中已经定义了input，此时的input引用的是全局命名空间中的字符串“..”，所以不可调用 预先检测的标识符 我们来看一个有趣的例子： x = 1 def function(x): print(x) x = 1 function(x) # 1 将这个代码稍微改动： x = 1 def function(): print(x) x = 1 function() # UnboundLocalError: local variable 'x' referenced before assignment 按理说，例子2中的x会引用全局命名空间中的x，那么为何会抛出异常呢？ 我们说过，在初始化函数时，会预先检测其中的语法是否出现错误： 例子1中的x最早出现在形参中，也就是说第3行的形参中定义了x，所以下面再使用x时是没有任何问题的 例子2中的x是定义在第5行，但是在第4行里就进行了使用，违反了对象必须先声明后使用的原则，故抛出异常 方法介绍 global引入 一个例子 先看一个简单的例子吧： x = 1 # ❶ def function(): x = 3 # ❸ print(x) # ❹ function() # ❷ print(x) # ❺ # 3 # 1 图示如下： ❶：全局命名空间定义了变量x，指向内存中的1 ❷：开始调用函数function() ❸：函数function()的局部命名空间中也声明了x，并且指向内存中的3 ❹：打印x，打印语句在函数内部，所以先从function()的局部命名空间中找x，这个x指向的3 ❺：打印x，打印语句在函数外部，所以在全局命名空间中找x，这个x指向的1 所以最后的结果是：3、1 方法使用 gloabl关键词可以在函数中使用，该关键词后面出现的标识符在函数内部也可以进行使用，但是该标识符的对象会指向全局命名空间中的对象。 我们对上面例子加上一句代码，结果就变的不同了： x = 1 # ❶ def function(): global x # ❷ x = 3 # ❸、❹ print(x) # ❺ function() print(x) # ❻ # 3 # 3 如下图所示： ❶：全局命名空间定义了变量x，指向内存中的1 ❷：在函数function()执行时，引入了外部的x，指向内存中的1 ❸、❹：将x重新指向3 ❺：打印x，打印语句在函数内部，所以先从function()的局部命名空间中找x，这个x就是外部的x，指向1 ❻：打印x，打印语句在函数外部，所以在全局命名空间中找x，这个x当然也指向的1 nonlocal引入 一个例子 先看一个简单的例子吧： x = 1 def outer(): x = 2 def inner(): x = 3 print(x) inner() print(x) outer() print(x) # 3 # 2 # 1 这个参照上面的global引入图示。 第1个print()是在inner()函数的局部命名空间中打印x，所以打印了3 第2个print()是在outer()函数的局部命名空间中打印x，所以打印了2 第3个print()是在全局命名空间中打印x，所以打印了3 方法使用 nonlocal关键字与global使用相同，不同的是gloabl引用的是全局命名空间中的标识符对象，而nonlocal则是引用上层局部命名空间中的标识符对象。 将代码稍微改动，于是你便发现结果又变了： x = 1 def outer(): x = 2 def inner(): nonlocal x print(x) inner() print(x) outer() print(x) # 2 # 2 # 1 第1个print()是在inner()函数的局部命名空间中打印x，该x指向的是上层局部命名空间中的x，所以打印了2 第2个print()是在outer()函数的局部命名空间中打印x，所以打印了2 第3个print()是在全局命名空间中打印x，所以打印了3 LEGB 我们在nonlocal例子中看见了一共有4个命名空间，分别如下： 内置命名空间 全局命名空间 函数outer的局部命名空间 函数inner的局部命名空间 这样划分会显得有些杂乱，所以可以将它用新的命名方式来表示，总计划分为4层： B-Builtin(Python)：Python解释器的内置命名空间，用B来表示 G-Global(module)；函数定义所在模块（文件）的命名空间，即全局命名空间，用G来表示 E-Enclosing function locals：外部嵌套函数的命名空间，即outer的局部命名空间，用E来表示，因为它是封闭的 L-Local(function)：被嵌套的函数命名空间，即inner的局部命名空间，用L来表示，即代码执行最里层的本地空间 作用域 在很多其他的教程中，可能会有作用域的划分，将3个命名空间分为了2个作用域： 全局作用域：包含内置命名空间与局部命名空间 局部作用域：即局部命名空间 这是一种比较粗暴直白的划分，并没有命名空间的划分来的详细，本质都是1个东西，这里不再举例。 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:46 "},"Python/Python函数相关/高阶函数.html":{"url":"Python/Python函数相关/高阶函数.html","title":"高阶函数","keywords":"","body":"高阶函数 在Python中函数是一等公民，它与普通的数据项对象并没有什么区别，唯一的区别可能在于函数是能被调用的吧。 这意味着，Python中的函数可以做下面的事情： 可以赋值 可以将一个函数对象传递给另一个函数对象的形参 一个函数中可以返回另一个函数 可以将函数当做容器类型中的一个数据项元素 赋值 函数标识符本来仅是一个贴纸，指向了函数体代码在内存中的位置。 那么我们可以再加上一个贴纸标识符，让它与函数标识符指向内存中相同的位置，如下所示： def function(): print(\"function ...\") func = function func() # function ... 传参 可以将一个函数对象传递给另一个函数对象的形参，如下所示： def outer(func): print(\"start\") func() print(\"stop\") def inner(): print(\"inner ..\") outer(inner) # start # inner .. # stop 返回值 一个函数中可以返回另一个函数，这样的做法常用于嵌套定义函数。 Ps：嵌套定义函数和嵌套调用函数还是有所不同的，嵌套定义的2个函数不在同一命名空间中进行声明，而是具有包含关系，而嵌套调用的函数大部分情况在同一命名空间中进行定义声明。 def outer(): def inner(): print(\"inner\") return inner func = outer() func() # inner 因为函数具有封装线，故外部无法访问内部，但是如果E层函数主动返回L层函数，那么外部就可以拿到L层的函数进行调用。 数据项 函数可以作为容器对象中的数据项： def f1(): print(\"f1\") def f2(): print(\"f2\") def f3(): print(\"f3\") li1 = [f1, f2, f3] for func in li1: func() # f1 # f2 # f3 应用实例 函数的嵌套调用 函数的嵌套调用会很常见。 如果有2个函数，我们可以将2个函数的功能进行分类： 函数1主要负责为外部使用者提供入口，而不负责逻辑关系的处理 函数2主要负责内部逻辑关系的处理，对于外部调用者而言它是隐藏的 如下所示，我们使用2个函数来实现从1个容器类型中拿出最大数据项的功能： def getMaxValue(*args): \"\"\"interface\"\"\" currentMaxItem = args[0] for item in args[1:]: currentMaxItem = computeMaxValue(item, currentMaxItem) return currentMaxItem def computeMaxValue(x, y): \"\"\"logic\"\"\" return x if x > y else y result = getMaxValue(*[8, 1, 2, 3, 5, 4]) print(result) # 8 基于函数的封装 我们只需要在函数内部定义函数，将1堆类似功能的函数封装在1个抽象函数中即可。 如下我们定义了1个数学工具类函数，它将包含了求长方形、长发体的面积： def mathFormula(select, length, width, height=None): \"\"\"长方形，求面积输入长宽，求体积输入长宽高\"\"\" def area(length, width): \"\"\"长方形面积\"\"\" return length * width def bulk(length, width, height): \"\"\"长方体体积\"\"\" return length * width * height if select == 1: return area(length, width) elif select == 2: return bulk(length, width, height) else: print(\"输入有误\") res = mathFormula(select=1, length=20, width=20) print(res) # 400 基于函数的字典 修改学生信息的一个小例子，如下所示： studentMessage = { \"1\": {\"name\": \"Tom\", \"gender\": \"male\", \"age\": 18, \"height\": 192, \"weight\": 140}, \"2\": {\"name\": \"Jack\", \"gender\": \"male\", \"age\": 17, \"height\": 172, \"weight\": 120}, \"3\": {\"name\": \"Kelly\", \"gender\": \"female\", \"age\": 20, \"height\": 168, \"weight\": 130}, } def check(): \"\"\"查\"\"\" for item in studentMessage: print(\"学生编号:{0}\".format(item)) for key, value in studentMessage[item].items(): print(\"{0: >10} | {1: Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:46 "},"Python/Python函数相关/递归函数.html":{"url":"Python/Python函数相关/递归函数.html","title":"递归函数","keywords":"","body":"递归函数 递归的特性 递归（recursion）是一种函数的调用方式，简而言之就是自己调用自己。 递归可以将一个大规模的问题分解成更小的相同问题，经过持续分解到最后问题规模小到可以用非常简单直接的方式来解决，或者将一个问题拆分成不同的各个部分，达到分而解决分而治之的目的。 一个递归函数必须要满足3要素： 必须有一个基本结束条件 必须能改变问题规模 必须调用自身 如下所示，这就是一个标准的递归函数： def function(count): if count: print(count) function(count=count - 1) return function(5) # 5 # 4 # 3 # 2 # 1 回溯与递推 函数递归必然经历2个阶段，一个是回溯阶段，一个是递推阶段： 回溯：函数不断递归调用自身时的阶段被称为回溯阶段 递推：当函数退出递归调用时的阶段被称为递推阶段 下面是一个问姓名的问题，可以非常直白的阐述回溯和递推的2个概念。 首先，你问A多少岁，A会回答你他比B大10岁，然后你又问B多少岁，B会回答你它比C大10岁... 这样直至E，E说他的年龄是18岁，最后问A多少岁？ 如上图所示，当你问A年龄的时候，回溯阶段开始。 而当你得知E的年龄后，递推阶段开始，根据E反推出A年龄的过程即递推的过程。 代码表现形式如下： def getAge(n): if n == 1: return 18 return getAge(n - 1) + 10 a = getAge(5) print(a) # 58 实例练习 数据项提取 有1个不知道维度的列表，现在要将它转换为1维列表，并且按照升序进行排序： oldList = [10, 1.2, [3, 345, 2.2, [15, [88.6, [78, [89.3, 99, [50]]]]]]] newList = [] def listSort(li): for i in li: if isinstance(i, list): listSort(i) else: newList.append(i) newList.sort() listSort(oldList) print(newList) # [1.2, 2.2, 3, 10, 15, 50, 78, 88.6, 89.3, 99, 345] 爬楼梯问题 有1个n阶的楼梯，每次可以爬1个台阶或者2个台阶，求解有多少种方法爬完整个楼梯。 def climbTheStairs(n): if n == 1: return 1 # ❶ if n == 2: return 2 # ❷ return climbTheStairs(n - 1) + climbTheStairs(n - 2) # ❸ print(climbTheStairs(3)) # 3 ❶：只有1个台阶，就只有1种走法，一次走1步 ❷：只有2个台阶，就只有2中走法，一次走1步或者一次走2步 ❸：将1次走1步的算出来，将1次走2步的算出来进行相加 递归与while 递归与while循环有一些类似之处，比如都要设置结束条件，但是两者不可一概而论。 如果一个问题规模不被确定，使用递归是最好的方案。 而如果一个问题的规模已被确定，则可以使用while循环进行解决。 但是递归要比while循环的效率更加的低下，因为递归的过程中会进行函数的调用，而函数调用则必定会对内存造成更大的压力，这来源于系统调用栈的栈帧会跟随每一次递归而不断的生成。 递归的深度 系统调用栈栈帧的生成不能毫无限制，所以Python对递归的深度进行了最大1000层的限定。 你可以随时修改这个层次，但是如果问题规模过大导致递归层次过多，则可能发生爆内存的情况，因为每一次的栈帧都会保存在内存中，以下是修改递归最大深度限制的方法： >>> import sys >>> sys.setrecursionlimit(100000) # ❶ >>> sys.getrecursionlimit() # ❷ 100000 ❶：修改最大默认递归层次为10000层 ❷：获取当前最大的递归层次 尾递归优化 递归函数中，每一次的栈帧生成都是相同的。 每一个递归函数的栈帧都拥有相同的调用方（自身）、拥有相同的字节码（相同的函数）、用于相同的命名空间（标识符）。 由于栈帧在系统调用栈中会占用大量的内存，对于某些语言如Java而言，会针对递归函数做一些优化，具体是指如果1个函数是进行递归调用，则只生成1个栈帧。 这种优化策略能够极大的减少内存空间的占用，也被称之为尾递归优化。 遗憾的是，Python并未实现尾递归优化。 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:46 "},"Python/Python函数相关/匿名函数.html":{"url":"Python/Python函数相关/匿名函数.html","title":"匿名函数","keywords":"","body":"匿名函数 匿名函数即没有名字的函数，最早出现在LISP语言中，Python对其进行了引用。 匿名函数的作用就是在不丧失代码可读性的前提下为精简代码提供的一种方式，以下是定义匿名函数的语法，通过lambda关键字进行定义。 注意！函数不管有名没名，都必须先定义后使用 语法如下： lambda 形参1, 形参2 ... : 返回值 # ❶ ❷ ❶：形参可以有多个，也可以没有 ❷：返回值不用跟return，直接写逻辑语句即可，将会自动的把逻辑语句的结果进行返回 定义和使用匿名函数的实际示例，求2个数的和： res = (lambda x, y : x + y)(1, 2) print(res) 匿名函数常用于定义一些非常简单的逻辑，不支持多行，因此要尽量写的简洁易懂。 使用方式 为匿名函数取名 匿名函数也可以通过一个标识符进行命名，但是一般都不会这样做： add = lambda x, y : x + y res = add(1, 2) print(res) # 3 自执行和自销毁 自执行函数即定义了匿名函数之后就立刻加括号调用，这种函数只会运行一次。 并且由于没有标识符的引用绑定关系，故使用完成后就会被GC机制所立即回收掉： res = (lambda x, y : x + y)(1, 2) # ❶ print(res) # 3 ❶：自执行的匿名函数必须在括号中进行定义 内置函数搭配使用 匿名函数常用于与内置函数进行搭配使用，如下将使用内置函数max()搭配匿名函数求得下列薪资最高的人员名字： salaries = { 'Ken': 3000, 'Tom': 7000, 'Jack': 2000 } name = max(salaries, key=lambda k: salaries[k]) # ❶ print(name) ❶：max()函数的key参数可指定1个函数，此时函数的返回结果就是本次求最大值的对比条件，这个例子就是指定薪资作为对比条件 常用搭配函数 lambda表达式与一些函数配合，才能发挥出最大的威力。 Python中出名的诸如map()、filter()、reduce()函数等均来自Lisp语言的设计，它们实在是太方便了，其实说到底一门优秀的语言必定大量借鉴了其他语言的优秀特性。 max()与min() max()函数用于从1个可迭代对象中返回最大的数据项，而min()是返回最小的，其他都一样。 max()函数签名如下： def max(*args, key=None): pass 参数详解： args：一个可迭代对象，拥有1个形参 key：传入1个可调用对象（通常是指函数），指定本次的大小对比方式，默认是根据数据项值本身对比 默认比对是比对的值本身，如果是字典则拿key的值进行比对，以下示例中，由于C的ASCII码比A大，所以返回了C： dic = {\"A\": 100, \"B\": 50, \"C\": 20} res = max(dic) print(res) # C 传入参数key，修改对比方式为字典的value，那么最后A的value最大，故返回A： dic = {\"A\": 100, \"B\": 50, \"C\": 20} res = max(dic, key=lambda k:dic[k]) print(res) # A 手动实现max()函数： from collections.abc import Iterable def customizeMax(*args, key=None): def default(args): \"\"\"默认对比规则\"\"\" it = iter(args) if not isinstance(args[0], Iterable) else iter(args[0]) currentMaxItem = next(it) for item in it: if currentMaxItem map() map()函数会从一个可迭代对象中依次取出1个数据项，并且会按照指定函数对数据项进行处理，处理完成后生成新的map可迭代对象并返回该map可迭代对象。 map()函数签名如下： def __init__(self, func, *iterables): pass 参数详解： func：一个可调用对象（通常是指函数），拥有1个形参，对iterables的数据项进行遍历并将返回值加入至新的map容器中，迭代完成后返回新的map容器 iterables：一个可迭代对象 其实map()能做的推导式都能做，如将整个可迭代对象中的数据项+100，并返回新的可迭代对象： newMapObject = map(lambda x:x+100, range(10)) print(list(newMapObject)) newList = [(lambda x:x+100)(i) for i in range(10)] print(newList) # [100, 101, 102, 103, 104, 105, 106, 107, 108, 109] # [100, 101, 102, 103, 104, 105, 106, 107, 108, 109] 手动实现map()函数： from collections.abc import Iterable def customizeMap(func, *iterables): it = iter(iterables) if not isinstance(iterables[0], Iterable) else iter(iterables[0]) for item in it: yield func(item) print(list(customizeMap(lambda x:x + 100, range(10)))) # [100, 101, 102, 103, 104, 105, 106, 107, 108, 109] filter() filter()函数会从一个可迭代对象中依次取出1个数据项，并且会按照指定函数对数据项进行筛选，符合条件的数据项加入新的filter对象中，不符合条件的数据项会直接丢弃，当遍历完整个可迭代对象后会返回新的filter对象。 filter()函数签名如下： def __init__(self, function_or_None, iterable): pass 参数详解： function_or_None：一个可调用对象（通常是指函数），拥有1个形参，指筛选条件，如果是None则筛选条件，此时会按照数据项本身的布尔值进行筛选 iterable：一个可迭代对象 其实filter()能做的推导式都能做，如遍历整个容器对象，将是偶数的数据项筛选出来： newFilterObject = filter(lambda x: x % 2 == 0, range(10)) print(list(newFilterObject)) newList = [i for i in range(10) if i % 2 == 0] print(newList) # [0, 2, 4, 6, 8] # [0, 2, 4, 6, 8] 手动实现filter()函数： def customizeFilter(function_or_None, iterable): it = iter(iterable) if function_or_None is None: for item in it: # 若没有指定筛选函数，则按照数据项本身的布尔值进行筛选 if item: yield item for item in it: res = function_or_None(item) if res: yield item print(list(customizeFilter(lambda x: x % 2 == 0, range(10)))) # [0, 2, 4, 6, 8] reduce() reduce()函数有1个初始值，你可以指定该初始值或者不指定。 每次对可迭代对象数据项进行迭代后，都会调用函数处理该数据项，并且将该数据项与初始值进行操作。 常用于累积运算，如累加，累乘等。 虽然该函数在Python3中已经被移除至内置函数的范畴，但是其强大的功能却很少被人熟练应用。 reduce()函数签名如下： def reduce(function, sequence, initial=None): pass 参数详解： function：一个可调用对象（通常是指函数），拥有2个形参，接收来自可迭代对象的2个数据项 sequence：一个可迭代对象 initial：一个初始值，它会随着可调用对象传入的参数进行运算而不断的改变，最终返回 简单的使用示例，求1 - 100的累加总和： from functools import reduce seqSum = reduce(lambda x,y:x+y, range(1, 101)) print(seqSum) # 5050 使用reduce()能够快速的完成寻求最大最小值的操作： from functools import reduce seqMax = reduce(lambda x, y: x if x > y else y, [1, 5, 10, 100, 399, 29]) print(seqMax) # 399 如果指定了初始值，那么则在初始值的基础上进行操作，如下所示初始值是English，每次的x，y进行相加后会再与初始值进行相加，最后会返回初始值： from functools import reduce seqSumStr = reduce(lambda x, y: x + y, [chr(i) for i in range(65, 65 + 26)], \"English:\") print(seqSumStr) # English:ABCDEFGHIJKLMNOPQRSTUVWXYZ 手动实现reduce()函数，了解底层实现原理： def customizeReduce(function, sequence, initial=None): it = iter(sequence) if initial: value = initial else: value = next(it) for item in it: value = function(value, item) return value seqSum = customizeReduce(lambda x, y: x + y, range(1, 101)) print(seqSum) seqMax = customizeReduce(lambda x, y: x if x > y else y, [1, 5, 10, 100, 399, 29]) print(seqMax) seqSumStr = customizeReduce(lambda x, y: x + y, [chr(i) for i in range(65, 65 + 26)], \"English:\") print(seqSumStr) # 5050 # 399 # English:ABCDEFGHIJKLMNOPQRSTUVWXYZ sorted() sorted()函数可以将一个可迭代对象传入，返回一个经过排序的列表，默认是升序排序。 第一参数：可迭代对象 第二参数，关键字key：一个可调用对象（通常是指函数），拥有1个形参，返回结果即为排序的对比规则，如不指定则按照Python默认排序对比规则进行排序对比 第三参数，关键字reverse：一个布尔值，当排序完成后是否对新列表进行翻转，默认是False即不翻转整个列表，如果是True则进行翻转，相当于对可迭代对象进行降序排序 sorted()函数与li.sort()方法的区别在于它会返回一个新的排好序的列表，而li.sort()则是原地排序。 此外sorted()函数支持对字典排序，这样做会返回1个包含字典key的列表，而li.sort()方法仅支持对列表排序。 使用如下，按照哈希值进行排序，并且翻转整个新的排序列表： newList = sorted([chr(i) for i in range(65, 65 + 26)], key=lambda item: hash(item), reverse=True) print(newList) # ['X', 'J', 'R', 'L', 'Q', 'C', 'U', 'T', 'M', 'O', 'I', 'Y', 'A', 'V', 'S', 'N', 'D', 'E', 'G', 'K', 'W', 'F', 'H', 'Z', 'B', 'P'] reversed() reversed()函数不可与lambda表达式进行搭配，放到这里的主要原因是因为它与sorted()的reverse参数、li.sort()的reverse参数作用相同，用于生成一个被翻转过后的新列表，如下所示，返回的结果是一个reversed可迭代对象，必须将它转换为list或者tuple后才能查看其中数据项： print( tuple(reversed([i for i in range(10)])) ) # (9, 8, 7, 6, 5, 4, 3, 2, 1, 0) 注意：该方法是生成新的对象，而不是原地翻转。 版本区别 Python2中的reduce()是内置模块，直接使用即可。 并且Python2中的map()、filter()的返回结果均为列表，而不是map对象和filter对象。 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:46 "},"Python/Python函数相关/内置函数.html":{"url":"Python/Python函数相关/内置函数.html","title":"内置函数","keywords":"","body":"查看方式 Python3中常用的内置函数可通过导入builtins模块查看： print(builtins.__dict__) 下面将挑选常用的且以前很少使用的内置函数进行示例。 基础 常用函数： 函数 返回值 描述 关注度 help() None 打印对象下的doc文档注释信息 5 hash() int 返回不可变对象的hash表现形式 5 id() int 返回对象在内存中的标识，即地址空间编号 5 print() None 向终端输入一则信息 5 input() str 获得用户在终端中输入的内容 5 open() fileObject 打开一个文件，获得文件句柄 5 exit() None 关闭并退出当前的Python解释器 3 quit() None 与exit()相同 3 help()获得帮助文档： >>> help(int) Help on class int in module builtins: class int(object) | int(x=0) -> integer | int(x, base=10) -> integer ... exit()和quit()都是退出解释器，结束脚本的继续执行。 类型转换 常用函数： 函数 返回值 描述 关注度 bool() bool 返回对象的布尔值 5 int() int 返回整形 5 float() float 返回浮点型 5 str() str 返回字符串 5 bytes() bytes 返回字节串 5 list() list 返回列表 5 tuple() tuple 返回元组 5 dict() dict 返回字典 5 set() set 返回集合 5 frozenset() frozenset 返回不可变集合 5 数学 常用函数： 函数 返回值 描述 关注度 hex() str 传入整形，返回其16进制表现形式 5 oct() str 传入整形，返回其8进制表现形式 5 bin() str 传入整形，返回其2进制表现形式 5 divmod() tuple 返回x与y的整除结果与求余结果 5 pow() int 返回x的y次乘阶 3 round() int 对数字的小数位数进行四舍五入 2 abs() int 返回参数的绝对值 2 divmod()返回x与y的整除结果与求余结果： >>> divmod(10, 3) (3, 1) 相当于10 // 3，10 % 3。 pow()返回x的y次乘阶，相当于x ** y： >>> pow(3, 3) 27 round()对数字的小数位数进行四舍五入： >>> round(3.4) 3 >>> round(3.5) 4 abs()返回参数的绝对值： >>> abs(-1) 1 字符串 常用函数： 函数 返回值 描述 关注度 chr() str 传入整形，将其转换为Unicode的16进制编码表现形式 5 ord() int 传入单个Unicode字符，将其转换为整形 5 ascii() str 返回对象的纯ASCII表示形式 1 format() str 获得对象内部双下format()方法的结果 1 repr() str 返回对象的规范字符串表示形式 2 eval() any 执行一个字符串形式的Python语句，并且返回执行结果 3 exec() any 执行一个字符串形式的Python语句，不会返回执行结果 3 repr()返回对象的规范字符串表示形式，相当于%r： >>> repr(1) '1' >>> 1 1 eval()执行一个字符串形式的Python语句，并且返回执行结果： >>> string = \"1 + 2\" >>> res = eval(string) >>> res 3 exec()执行一个字符串形式的Python语句，不会返回执行结果： >>> string = \"print('hello world')\" >>> exec(string) hello world 容器 常用函数： 函数 返回值 描述 关注度 len() int 返回容器中的项目数 5 slice() sliceObject 返回索引切片对象 2 iter() iterator 调用对象的双下iter()方法，获得专属迭代器 4 next() Item 从迭代器返回下一个数据项 4 range() rangeObject 返回range可迭代对象 5 enumerate() enumerateObject 返回可迭代对象的枚举类型 5 zip() zipObject 接收2个可迭代对象，将其合并为1个可迭代对象并返回，拉链函数 3 max() item 返回容器中最大的数据项 4 min() item 返回容器中最小的数据项 4 sum() int or float 迭代一个可迭代对象，并对其中数据项进行累加，返回求和结果 4 map() mapObject 对一个可迭代对象进行遍历，并对其中数据项挨个做操作，处理完成后返回map对象 5 filter() filterObject 对一个可迭代对象进行遍历，将符合条件的数据项返回至新的filter对象中 5 sorted() list 对一个容器进行排序，返回新的容器 5 reversed() reversedObject 对一个容器进行翻转，返回新的reversed对象 5 all() bool 如果容器中的数据项均为真，则返回True，否则返回False，若是空容器返回True 3 any() bool 如果容器中的数据项有1个为真，则返回True，否则返回False，若是空容器返回False 3 iter()和next()在迭代器一章节中会详细介绍。 zip()接收2个可迭代对象，将其合并为1个可迭代对象并返回，拉链函数： >>> li1 = [\"k1\", \"k2\", \"k3\"] >>> li2 = [\"v1\", \"v2\", \"v3\"] >>> list(zip(li1, li2)) [('k1', 'v1'), ('k2', 'v2'), ('k3', 'v3')] 可以用它快速将2个列表合成1个字典： >>> dict(zip(li1, li2)) {'k1': 'v1', 'k2': 'v2', 'k3': 'v3'} sum()迭代一个可迭代对象，并对其中数据项进行累加，返回求和结果： >>> sum(range(1, 101)) 5050 all()如果容器中的数据项均为真，则返回True，否则返回False，若是空容器返回True： >>> all([1,None,0]) False >>> all([(),{},[],None,0]) False >>> all([]) True any()如果容器中的数据项有1个为真，则返回True，否则返回False，若是空容器返回False： >>> any([1,None,0]) True >>> any([(),{},[],None,0]) False >>> any([]) False 面向对象 常用函数： 函数 返回值 描述 关注度 type() str 获得对象的类型 4 callable() bool 返回对象是否可调用 4 dir() list 返回对象的所有类实现方法，以及类属性 5 vars() dict 当不传入对象时相当于locals()方法，传入对象后相当于调用对象底层的双下字典 1 hasattr() bool 判断一个对象下某一个属性或者方法是否存在 5 getattr() attr 获取一个对象下某一个属性或者方法 5 setattr() None 新增或者设置一个对象的属性或者方法 5 delattr() None 删除一个对象下某一个属性或者方法 5 isinstance() bool 返回对象是类的实例还是子类的实例 5 issubclass() bool 判断一个类是否是另一个类的子类 5 super() method 调用父类的同名方法 5 type()函数已经见过了，其他函数将放在面向对象一栏中详细介绍。 作用域 常用函数： 函数 返回值 描述 关注度 globals() dict 返回全局命名空间的字典 2 locals() dict 返回当前代码执行的局部命名空间的字典 2 没什么用，完全可以不在意。 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:46 "},"Python/Python函数相关/装饰器.html":{"url":"Python/Python函数相关/装饰器.html","title":"装饰器","keywords":"","body":"装饰器 开闭原则 根据设计模式中的6大设计原则中的开闭原则来说，一个良好的项目应该具有以下2个特性： 对扩展开放：项目应当具有良好的扩展性 对修改关闭：当项目需要做功能变更时，不应该修改源代码，而应该增添新的功能，达到热插拔的效果 装饰器 装饰器（decorator）的功能就是在不违背开闭原则的前提下为一个原有功能增加上一些新的功能。 但是原有功能的调用、源代码都不会被修改，类似于一种在外部打补丁的方式。 装饰器有函数装饰器，类装饰器等分别，这里介绍函数装饰器，其实它们的运行原理都是相同的。 功能需求 我们有2个函数，upload()和download()，现在有1个需求，分别求出2个函数的运行时间。 同时还有3点限制： 不能修改源函数内部代码 不能改变源函数的调用方式 要以最精简的代码量完成需求 源代码如下： import time import random def download(fileName): time.sleep(random.randint(1, 3)) return \"下载文件{}完成\".format(fileName) def upload(fileName): time.sleep(random.randint(1, 3)) return \"下载文件{}完成\".format(fileName) downResult = download(\"testDownload.text\") upResult = upload(\"testUpload.text\") 解决过程 外部代码 最简单的方式是添加外部代码，来看一下效果： import time import random def download(fileName): time.sleep(random.randint(1, 3)) return \"下载文件{}完成\".format(fileName) def upload(fileName): time.sleep(random.randint(1, 3)) return \"下载文件{}完成\".format(fileName) downStartTime = time.time() downResult = download(\"testDownload.text\") downEndTime = time.time() downTotalTime = downEndTime - downStartTime print(\"函数:{} 运行共花费时长:{}\".format(download.__name__, downTotalTime)) upStartTime = time.time() upResult = upload(\"testUpload.text\") upEndTime = time.time() upTotalTime = upEndTime - upStartTime print(\"函数:{} 运行共花费时长:{}\".format(upload.__name__, downTotalTime)) # 函数:download 运行共花费时长:2.002652883529663 # 函数:upload 运行共花费时长:2.002652883529663 优点： 没有改变源函数的调用方式 没有修改源函数内部代码 缺点： 代码冗余量过大，每一次函数执行都至少要添加4行代码（开始时间，结束时间，总计时间，打印语句） 传参方式 对上述代码进行优化，再来看看效果： import time import random def showTotalRunTime(func, *args, **kwargs): startTime = time.time() res = func(*args, **kwargs) endTime = time.time() totalTime = endTime - startTime print(\"函数:{} 运行共花费时长:{}\".format(func.__name__, totalTime)) return res def download(fileName): time.sleep(random.randint(1, 3)) return \"下载文件{}完成\".format(fileName) def upload(fileName): time.sleep(random.randint(1, 3)) return \"下载文件{}完成\".format(fileName) downResult = showTotalRunTime(download, \"testDownload.text\") upResult = showTotalRunTime(upload, \"testUpload.text\") print(downResult) print(upResult) 优点： 极大的减少了代码冗余量 没有修改源函数内部代码 缺点： 改变了源函数的调用方式，若想在使用原本功能的前提下获得统计时长的功能，则必须运行showTotalRunTime()函数 闭包函数 闭包函数介绍 闭包函数是装饰器的核心知识点。 闭函数通常是指L层的函数，即被嵌套定义在另一个函数中的函数 包函数通常是指E层的函数，即该函数的内部嵌套定义了另一个函数 它的基本概念在于： 标识符的查找顺序以定义阶段为标准。当前命名空间没找到名字时则往定义自己的命名空间中查找标识符。 如下所示，这就是一个完整的闭包函数： def outer(): # ❶ def inner(): # ❷ pass return inner ❶：outer()函数是包函数 ❷：inner()函数是闭函数 闭包方案 在闭包函数中，E层的包函数命名空间里所有的标识符对象都不会被销毁（即使包函数已经进行了return），在L层的闭函数中，可以通过命名空间标识符向上查找的特性拿到E层包函数的命名空间标识符。 故我们可以使用闭包函数来进行问题的解决，下面的warpper()函数其实就是装饰器函数： import time import random def warpper(func): def inner(*args, **kwargs): startTime = time.time() res = func(*args, **kwargs) # ❹ endTime = time.time() totalTime = endTime - startTime print(\"函数:{} 运行共花费时长:{}\".format(func.__name__, totalTime)) return res return inner def download(fileName): time.sleep(random.randint(1, 3)) return \"下载文件{}完成\".format(fileName) def upload(fileName): time.sleep(random.randint(1, 3)) return \"下载文件{}完成\".format(fileName) download = warpper(download) # ❶ upload = warpper(upload) # ❷ downResult = download(\"testDownload.text\") # ❸ print(downResult) upResult = upload(\"testUpload.text\") print(upResult) ❶：调用warpper()函数，func形参存储的对象为download()函数，并返回inner()函数，此时外部的download标识符指向了inner()函数 ❷：调用warpper()函数，func形参存储的对象为upload()函数，并返回inner()函数，此时外部的upload标识符指向了inner()函数 ❸：调用download标识符所指向的inner()函数，并且传入了参数”testDownload.text”，开始执行inner()函数 ❹：在L层命名空间找func标识符，找不到，向上找到E层的命名空间，找到了func标识符形参，指向了download()函数，执行download()函数 ... 可以看到，通过闭包函数完美的完成了需求。 优点： 极大的减少了代码冗余量 没有修改源函数内部代码 在没有改变了源函数的调用方式前提下，新增了计时的功能 缺点： 我们必须对源函数做1个包装，将它的标识符由指向源函数改为指向为包函数的返回值，即闭函数，每一个需要增加统计时长功能的函数都要添加这样的一行代码，即❶，❷处。 整个过程图示，注意查看全局命名空间的标识符指向改变： @语法糖 无参装饰器 针对闭包方案的缺点，我们可以使用@语法糖的形式来进行进一步改进。 @语法糖内部会做2件事情： 自动加括号执行@后面的函数名，并且将@下面的被装饰函数当做第1个参数传入（注意，这个自动调用仅调用一次，当嵌套层数过多时则不会自动调用） 自动将@下面的被装饰函数的标识符重新指向内层返回的闭函数 如下所示： import time import random def warpper(func): def inner(*args, **kwargs): startTime = time.time() res = func(*args, **kwargs) endTime = time.time() totalTime = endTime - startTime print(\"函数:{} 运行共花费时长:{}\".format(func.__name__, totalTime)) return res return inner @warpper # ❶ def download(fileName): time.sleep(random.randint(1, 3)) return \"下载文件{}完成\".format(fileName) @warpper def upload(fileName): time.sleep(random.randint(1, 3)) return \"下载文件{}完成\".format(fileName) downResult = download(\"testDownload.text\") # ❷ print(downResult) upResult = upload(\"testUpload.text\") print(upResult) ❶：Python解释器检查语法，发现函数头上有个@装饰器函数，开始做2件事情: 自动调用warpper()函数，并且将@下面被装饰函数download()当做参数传递给func参数 自动将@下面的被装饰函数的标识符download重新指向内层返回的闭函数inner ❷：此时执行的download()函数其实是inner()函数，inner()函数执行时发现要找func，L层命名空间没有func，则往定义自己的warpper()函数的E层命名空间找func，找到了func指向的是download()函数，然后执行并返回 为了验证上面的例子，我们可以打印一下download的__name__属性进行查看： @warpper def download(fileName): time.sleep(random.randint(1, 3)) return \"下载文件{}完成\".format(fileName) print(download.__name__) # inner 如果不加装饰器呢？ def download(fileName): time.sleep(random.randint(1, 3)) return \"下载文件{}完成\".format(fileName) print(download.__name__) # download @手动传参 @如果手动加括号会怎么样？它会将执行结果对象返回给被装饰器函数的标识符。 如下示例，首先是打印了int类型的帮助信息，然后返回了一个None，func指向了None，如果func加上括号进行调用，则会抛出异常： @help(int) def func(): print(\"func...\") # Help on class int in module builtins: # # class int(object) # | int(x=0) -> integer # | int(x, base=10) -> integer func() # TypeError: 'NoneType' object is not callable 有参装饰器 一个新的需求： 下载或时候如果用户是普通用户，则享用10M带宽，如果是VIP用户，则享用100M带宽 如果用@语法糖来解决这个问题，则需要在外部再嵌套一层函数： import time import random def outer(genre): def warpper(func): def inner(*args, **kwargs): if genre == \"VIP\": print(\"欢迎您，尊贵的VIP用户，您的下载速度是100M/s\") else: print(\"欢迎您，亲爱的普通用户，您的下载速度是10M/s\") startTime = time.time() res = func(*args, **kwargs) endTime = time.time() totalTime = endTime - startTime print(\"函数:{} 运行共花费时长:{}\".format(func.__name__, totalTime)) return res return inner return warpper @outer(genre=\"VIP\" if random.randint(1, 2) == 1 else \"common\") def download(fileName): time.sleep(random.randint(1, 3)) return \"下载文件{}完成\".format(fileName) downResult = download(\"testDownload.text\") print(downResult) 执行流程如下： 手动调用一次outer()函数，并且为genre传入参数，返回了warpper()函数。 此时会变成这个样子，由于手动在装饰器函数后面加了括号，所以本次的返回值会依然当做装饰器添加在头上，并不会改变download()： @warpper def download(fileName): pass 自动调用一次（仅一次）warpper()函数，并且将@下面被装饰函数download()当做参数传递给func参数 自动将@下面的被装饰函数的标识符download重新指向内层的inner()函数 此时执行的download()函数其实是inner()函数，然后根据命名空间查找特性，找到genre形参变量标识符与func形参函数标识符 @自动执行 Python中的@语法糖对闭包函数只会自动的执行1次，如下所示： def warpper(x): print(\"执行第1次，返回f1\") def f1(x): print(\"执行第2次，返回f2\") def f2(x): print(\"执行第3次，返回None\") return f2 return f1 @warpper def func(): ... # 执行第1次，返回f1 而我们手动的对@后的函数进行调用，则在1层自动执行的基础上又加上了1次手动执行： def warpper(x): print(\"执行第1次，返回f1\") def f1(x): print(\"执行第2次，返回f2\") def f2(x): print(\"执行第3次，返回None\") return f2 return f1 @warpper(\"x\") def func(): ... # 执行第1次，返回f1 这是手动执行的1次 # 执行第2次，返回f2 这是自动执行的1次 也就是说Python的@语法最大仅能支持3层嵌套定义的闭包函数，如果太深则里面的就拿不到了，因为你不能手动调用2次，这样会抛出语法错误： @warpper(\"x\")(\"c\") def func(): ... # SyntaxError: invalid syntax 多个装饰器 多个装饰器叠放的场景你今后肯定会遇见，只需要记住一句话即可： 定义顺序自下而上，执行顺序自上而下 如下所示： def f1(func): print(\"定义f1装饰器\") def inner(*args, **kwargs): print(\"执行f1装饰器\") func() return inner def f2(func): print(\"定义f2装饰器\") def inner(*args, **kwargs): print(\"执行f2装饰器\") func() return inner @f1 @f2 def func(): ... func() # 定义f2装饰器 # 定义f1装饰器 # 执行f1装饰器 # 执行f2装饰器 流程分析： # Python解释器执行到 @f1 时，想自动运行一下，发现下面被装饰的不是一个函数，就不自动运行了 # Python解释器执行到 @f2 时，想自动运行一下，发现下面被装饰的是一个函数，于是开始自动运行 # print(\"定义f2装饰器\") # 然后返回了 inner 函数，现在 func -> inner 函数，变成了这个样子 # # @f1 # def func(): # ... # # 然后，Python解释器发现 @f1 下面是一个函数了，于是开始自动运行 # print(\"定义f1装饰器\") # 然后又返回 inner 函数，现在 func -> 新的 inner 函数 # # Python解释器继续向下走，发现 func() # 由于 func -> 新的 inner 函数 故开始运行 f1的 inner 函数： # print(\"执行f1装饰器\") # 打印完成后又要执行 func() # 那么这里的 func 是旧的 inner 函数，故开始运行f2的 inner 函数： # print(\"执行f2装饰器\") @wraps分析 @wraps其实是functiontools中自带的一款有参装饰器，它能够做到很好的隐藏功能。 如，普通装饰器的标识符被改变指向为L层函数后，通过查看__name__还是会看到原本L层函数的名字： def warpper(func): def inner(*args, **kwargs): result = func() return result return inner @warpper def func(): ... print(func.__name__) # inner 如果对内层L函数加上@wraps后，就会将内层函数的大部分属性变为原本标识符所指向的被装饰函数，如下所示： from functools import wraps def warpper(func): @wraps(func) def inner(*args, **kwargs): result = func() return result return inner @warpper def func(): ... print(func.__name__) # func 这个仅是换了1个属性，实际上内存地址还是inner的，通过以下示例进行验证： from functools import wraps def warpper(func): @wraps(func) def inner(*args, **kwargs): result = func() return result print(\"内部打印 inner() 函数的内存地址\", id(inner)) return inner @warpper def func(): ... print(\"内部打印 func 所指向函数的内存地址\", id(func)) # 内部打印 inner() 函数的内存地址 4451701896 # 内部打印 func 所指向函数的内存地址 4451701896 装饰器模板 无参装饰器 from functools import wraps def warpper(func): @wraps(func) def inner(*args, **kwargs): # 开始前的逻辑 result = func() # 结束后的逻辑 return result return inner @warpper def func(): ... func() 有参装饰器 from functools import wraps def warpper(*args, **kwargs): def outer(func): @wraps(func) def inner(*args, **kwargs): # 参数的使用 # 开始前的逻辑 result = func() # 结束后的逻辑 return result return inner return outer @warpper(k1=\"v1\") def func(): ... func() Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:46 "},"Python/Python函数相关/迭代器.html":{"url":"Python/Python函数相关/迭代器.html","title":"迭代器","keywords":"","body":"迭代器 迭代是什么 迭代指的是一个重复的过程，每次重复都必须基于上一次的结果而继续，单纯的重复并不是迭代，如Python中的for循环就是一个非常好的迭代例子。 for item in range(10): print(item) 迭代必须向前推进，不能后退，如下所示： # [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] # ------------------------------> 下面这种方式就不属于迭代： # [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] # --------> # 迭代器协议 在学习迭代器的整个知识点中，迭代器协议占据了非常重要的位置。 迭代器协议中包含了2个最基本的概念，分别是可迭代对象和迭代器对象。 可迭代对象（Iterable）：内部实现了__iter__()方法的对象则被称为可迭代对象 迭代器对象（Iterator）：内部实现了__iter__()以及_next\\_()方法的对象则被称之为迭代器对象 两者之间的关系： 在Python中，迭代器对象一定属于可迭代对象范畴，也就说迭代器对象必须具有__iter__()方法以及__next__()方法 在Python中，可迭代对象不一定属于迭代器对象范畴，也就是说可迭代对象只需要实现__iter__()方法即可 介绍2个函数： iter(Object)函数，它底层会执行Object.__iter__()方法 next(Object)函数，它底层会执行Object.__next__()方法 内置类型 通过collections.abc下的Iterable类和Iterator类进行判定，可快速的判定出所有内置类型是否是一个可迭代对象或者迭代器对象： >>> from collections.abc import Iterable >>> from collections.abc import Iterator >>> isinstance(list(), Iterable) True >>> isinstance(list(), Iterator) False 经过测试，所有的容器类型（list、tuple、str、dict、set、frozenset）均属于可迭代对象，但不属于迭代器对象 原子类型（bool、int、float、None）等均不属于可迭代对象，更不属于迭代器对象。 也可以通过另一种方式进行验证，通过hasattr()函数，检查类中是否定义了某一个方法： >>> hasattr(list,\"__iter__\") True >>> hasattr(list,\"__next__\") False 迭代原理 当可迭代对象被for循环进行调用后，底层执行流程如下所示： 将自动的执行iter()方法，该方法内部会查找可迭代对象的__iter__()方法，如果具有该方法，则返回一个该可迭代对象的专属迭代器对象，如果没有该方法，则抛出TypeError object is not iterable的异常。 Ps：每次的for循环都会返回一个全新的迭代器对象 不断的调用迭代器对象的__next__()方法，并且返回迭代器对象中下一个数据项，当遍历完成整个迭代器后，引发Stopiteration异常终止迭代 Ps：迭代器本身并不存储任何数据项，存储的只是一个指针，该指针指向可迭代对象中真正存储的数据项，它指向当前被遍历到的数据项索引位置，下一次遍历则向后推进这个位置 for循环自动的捕捉Stopiteration异常，并且停止迭代 Ps:for循环底层就是while循环实现的，只不过多加了3个步骤： 第一步：执行可迭代对象的__iter()__方法并保存返回的专属迭代器 第二步：不断的执行迭代器的__next()__方法 第三步：捕获Stopiteration异常 我们手动的实现一个for循环： li1 = list(range(10)) iteratorObject = iter(li1) # ❶ while 1: try: print(next(iteratorObject)) # ❷ except StopIteration as e: # ❸ break ❶：执行可迭代对象的__iter__()方法并保存返回的专属迭代器 ❷：不断的执行迭代器的__next__()方法 ❸：捕获Stopiteration异常 线性可迭代对象与迭代器的实现 如果是一个线性容器的可迭代对象，那么它一定具有索引值，我们可以让它的__iter__()方法返回一个专属的迭代器对象。 然后专属迭代器对象中记录本次迭代遍历的索引值，根据这个索引值返回可迭代对象中的数据项，当索引值达到可迭代对象中数据项总个数-1的时候，抛出异常，本次迭代结束： class LinearTypeContainer: def __init__(self, array): if isinstance(array, list) or isinstance(array, tuple): self.array = array else: raise TypeError(\"argument array must is linear container\") def __iter__(self): return LinearContainer_iterator(self.array) # ❶ class LinearContainer_iterator: def __init__(self, array): self.index = 0 self.array = array self.len = len(self.array) def __next__(self): if self.index ❶：Python中的一切传参均为引用传递 故LinearTypeContainer中的self.array和LinearContainer_iterator的self.array都是一个对象，并不会额外开辟内存空间 这也就是为什么可迭代对象创建的专属迭代器不会消耗太多的内存空间原因了。 ❷：迭代器对象一定属于可迭代对象范畴，所以在这里我们为迭代器对象LinearContaineriterator类也新增了\\_iter__()方法 这样做的好处在于如果单独的拎出了这个迭代器对象，则它也会支持for循环的遍历： def __iter__(self): return self containerIterator = LinearTypeContainer([i for i in range(10)]).__iter__() for item in containerIterator: print(item) # 0 # 1 # 2 # 3 # 4 # 5 # 6 # 7 # 8 # 9 如果取消了linearContaineriterator类的这个\\_iter__()方法，则不支持for循环的遍历： # def __iter__(self): # return self containerIterator = LinearTypeContainer([i for i in range(10)]).__iter__() for item in containerIterator: print(item) # TypeError: 'LinearContainer_iterator' object is not iterable 非线性可迭代对象与迭代器实现 如果是一个非线性容器的可迭代对象，可以先判断它的类型，如果传入的容器是一个字典，则将迭代的数据项集合转换为元组，里面存储的全部是字典的key即可。 如果传入的容器是一个集合，则将迭代的数据项集合转换为元组，再参照线性可迭代对象与迭代器的实现。 具体实现： class MappingTypeContainer: def __init__(self, mapping): self.mapping = mapping if not ( isinstance(self.mapping, dict) or isinstance(self.mapping, set) or isinstance(self.mapping, frozenset) ): raise TypeError(\"argument mapping must is mapping container\") def __getattr__(self, name: str): try: return dict.__getattribute__(self.mapping, name) except AttributeError: return set.__getattribute__(self.mapping, name) def __str__(self): return str(self.mapping) def __iter__(self): return MappingContainer_iterator(tuple(self.mapping)) class MappingContainer_iterator: def __init__(self, array): self.index = 0 self.array = array self.len = len(self.array) def __next__(self): if self.index 迭代器对象的特性 每一次for循环创建出的可迭代对象的专属迭代器都是一次性的，用完后就没用了： ... # ❶ containerIterator = LinearTypeContainer([i for i in range(3)]).__iter__() for item in containerIterator: print(item) # 0 # 1 # 2 for item in containerIterator: print(item) # ❷ print(\"?\") ❶：直接拿出一个迭代器对象 ❷：在第2次循环中，迭代器对象中存储的索引值已经最大了，每次调用iter()都会抛出异常返回出来再被for处理，所以print()函数根本不会运行 迭代器对象并不存储可迭代对象中的真正迭代数据，而是仅存储长度和索引，所以内存的占用并不多： class LinearContainer_iterator: def __init__(self, array): self.index = 0 # ❶ self.array = array # ❷ self.len = len(self.array) # ❸ ... ❶：占用额外的内存空间 ❷：引用对象，并不开辟内存 ❸：占用额外的内存空间 惰性求值与及早求值 迭代器对象中对于返回的数据项，是进行实时演算的，这种实时演算的特性求值方式被称为惰性求值，即你需要的时候我算出来后再给你： def __next__(self): if self.index 除开惰性求值，还有一种及早求值的方案，即使你要1个，我也把所有的都给你。 如Python2中的range()、map()、filter()、dict.items()、dict.keys()、dict.values()，它们均返回的是一个纯粹的列表，这样的设计是不合理的，参见要命的问题③。 因为返回的列表会占用很大的内存空间，而Python3中则统一优化为惰性求值方案，即返回一个可迭代对象。 要命的问题 一个非常有趣的问题： Python中的所有自带容器类型为何不自己设置成迭代器？ 而是在for循环时实例出一个专属的迭代器？ 直接在这些自带类型的底层实现__next__()方法不好吗？ 这样岂不是更加减少了内存的消耗，少定义了类和实例化了类吗？ 答：这真是一个要命的问题，这个问题我也想过很久，最后是在stackoverflow提问并且获得了满意的答案才记录下来的。 因为它确实是可以实现的，如下所示，只需要在加上❶处代码即可： class LinearTypeContainer: def __init__(self, array): if isinstance(array, list) or isinstance(array, tuple): self.array = array else: raise TypeError(\"argument array must is Linear container\") self.index = 0 self.len = len(self.array) def __iter__(self): return self def __next__(self): if self.index 但是这样做在某种特殊情况下会出现问题： container = LinearTypeContainer(list(range(5))) for item in container: print(item) if container.index == 3: break print(\"*\"*20) for item in container: print(item) # 0 # 1 # 2 # ******************** # 3 # 4 你会发现如果第一次for循环到了1半的时候退出，第二次for循环会接着根据第一次for循环进行继续。 能够解决一下吗？只需要加上一个标志位即可： class LinearTypeContainer: def __init__(self, array): if isinstance(array, list) or isinstance(array, tuple): self.array = array else: raise TypeError(\"argument array must is Linear container\") self.index = 0 self.len = len(self.array) self.iter = False # ❶ def __iter__(self): if self.iter: # ❷ self.index = 0 self.iter = True return self def __next__(self): if self.index ❶：判断是不是一次新的调用 ❷：如果是新的调用，则将index重新置为0即可 那么为何Python不这样设计呢？我们应该更多的考虑多线程的情况下，多个for循环使用同一个迭代器它是否是线程安全的，上面的示例中这个共享迭代器并不是线程安全的，此外它也不支持嵌套循环，如下所示，这样会造成无限循环： container = LinearTypeContainer(list(range(5))) for item in container: print(item) for j in container: print(j) 综上各个方面的考虑，Python将内置的数据类型，都设置了在for循环时返回专属迭代器的做法，这是非常好的设计，但是对于有些内置的对象，则是将它本身做成了迭代器，如文件对象。 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:46 "},"Python/Python函数相关/生成器.html":{"url":"Python/Python函数相关/生成器.html","title":"生成器","keywords":"","body":"生成器 生成器（generator）是迭代器的一种特殊实现方式，有2种方式可以创建，一种是通过生成器函数创建，另一种是生成器表达式进行创建。 生成器继承了迭代器的一切优点，简而言之是迭代器的一种升级版本。 在前面的迭代器一章节中介绍过，如果要想获取一个迭代器，必须要先创建一个可迭代对象，然后调用其下的__iter__()方法才能拿到一个迭代器，这样做会产生一些问题，如下所示： 我们只想要一个迭代器，并不需要可迭代对象的前提下该怎么办 可迭代对象中的数据项会占据大量内存空间，如果要想获取1个含有1000万个数据项的列表迭代器，则必须先创建1个列表对象，再获取其专属的迭代器，虽然迭代器不耗费内存，但是可迭代对象必然耗费内存 而生成器则是简化了这种操作，只需要创建生成器函数就可以拿到一个单纯的迭代器。 如果要判断一个对象是否属于生成器，推荐使用collections.abc下的Generator进行判定： >>> from collections.abc import Generator >>> isinstance(list,Generator) False 生成器函数 如果一个函数中出现yield关键字，则它就是一个生成器函数，当一个生成器函数加括号进行调用时，并不会立即运行逻辑体代码，而是返回一个生成器对象。 当对这个生成器对象调用next()方法时，将启动该生成器对象，生成器对象开始执行函数逻辑体代码。 而在执行函数逻辑体代码时如果碰见yield则会发生2件事情： 返回yield后面的值，类似于return函数 挂起当前生成器函数的运行状态，而不是结束生成器函数的运行，也就是说这个生成器对象不会被销毁 再次对生成器对象调用next()方法时恢复暂停状态，继续上述流程进行运行。 一个简单的例子： def generatorFunction(): n = 3 while n: yield n n-=1 # return None ❶ # ❷ generatorObject = generatorFunction() print(generatorObject) # ❸ print(next(generatorObject)) print(next(generatorObject)) print(next(generatorObject)) # ❹ print(next(generatorObject)) # # 3 # 2 # 1 # StopIteration ❶：默认的函数返回值即为None，在Python3之前的较低版本中，return关键字和yield关键字不可以同时出现在一个函数中，但是目前已经取消了这种设定 ❷：生成器函数加括号，返回生成器对象 ❸：生成器对象调用next()方法，开始执行函数体代码 ❹：由next()方法抛出的StopIteration异常，并不是生成器对象抛出的 斐波拉契数列 下面的示例中将使用生成器函数获取斐波拉契数列中指定位数之前所有的数据项。 仅获取数据项，并不产生存储，因此使用生成器函数极为方便： def getFibPositionValue(n): count, currentValue, nextValue = 0, 0, 1 while count 而如果是要对斐波拉契数列本身进行存储，使用普通函数则更好一点： def createFibArray(n): fibArray = [] count, currentValue, nextValue = 0, 0, 1 while count 生成器表达式 生成器表达式类（generator expression）似于列表推导式，用于快速的创建一个生成器对象，使用()对表达式进行包裹： genObject = (i for i in range(3)) print(genObject) # at 0x10bed0db0> 如果外部已经拥有一个括号，则可以忽略这大括号，如将生成器对象转换为元组的完整写法如下： tup = tuple((i for i in range(3))) print(tup) # (0, 1, 2) 忽略括号： tup = tuple(i for i in range(3)) print(tup) # (0, 1, 2) send() close() 生成器的特性不仅如此，它还能够实现一种双向的生成器外部调用代码与生成器内部逻辑代码的信息交互功能。 因为yield不仅可以返回值，还可以接收值。 如下示例，外部通过send()方法发送的信息将被yield所接收，当整个生成器对象迭代完毕后，可以调用close()方法关闭这个生成器对象： def generatorFunction(): print(\"generator object run ...\") firstRecvExternal = yield 1 # ① print(firstRecvExternal) # 打印A secondRecvExternal = yield 2 # ② print(secondRecvExternal) # 打印B lastRecvExternal = yield 3 # ③ print(lastRecvExternal) # 打印C genObject = generatorFunction() # ❶：启动生成器对象，执行函数，运行至①处返回 1，并暂停 genStartResult = genObject.send(None) print(genStartResult) # 打印1 # ❷：继续运行生成器对象，发送了字符串A，被生成器①处的firstRecvExternal所接收到，并进行了一次打印 A # 直至运行至②处，返回结果2 genSecondSend = genObject.send(\"A\") print(genSecondSend) # 打印2 # ❸：继续运行生成器对象，发送了字符串B，被生成器②处的secondRecvExternal所接收到，并且进行了一次打印 B # 直至运行至③处，返回了结果3 genThirdSend = genObject.send(\"B\") print(genThirdSend) # 打印3 try: # 继续运行生成器函数，发送了字符串C，被生成器③处的lastRecvExternal所接收到，并且进行了一次打印 C # 然后再往下运行发现 return None，于是 __next__()函数抛出了 StopIteration 的异常，但是被这里处理了 genLastSend = genObject.send(\"C\") # StopIteration except StopIteration: # 处理异常，关闭生成器对象 genObject.close() # generator object run ... # 1 # A # 2 # B # 3 # C yield form 生成器函数加括号不会执行函数体内部代码，而是返回生成器对象，生成器对象的启动必须通过next()或者send(None)。 for循环底层会调用生成器对象的__next__()方法进行启动和向下运行，因此通过for循环来操纵生成器是十分方便的： def genFunction(): count = 0 while 1: if count ❶：首先将生成器函数转换为生成器对象，然后通过for不断的进行调用 如果是2个嵌套调用的生成器函数，外部嵌套生成器函数需要时刻yield子调用生成器函数的值，似乎用for循环来完成这个需求是最好的选择： def outer(): yield \"run outer...\" for item in inner(): # ❶ yield item def inner(): yield \"run inner 1 ...\" yield \"run innner 2 ...\" yield \"run inner 3 ...\" for item in outer(): print(item) # run outer... # run inner 1 ... # run innner 2 ... # run inner 3 ... ❶：首先将生成器函数转换为生成器对象，然后通过for不断的进行调用 在Python3.3版本之后，你有了新的选择，使用yield from关键字，yield from关键字必须定义在一个生成器函数之中，它将会自动的在底层运行for循环进行调用另一个生成器函数，并将另一个生成器函数的结果进行返回： def outer(): yield \"run outer...\" yield from inner() # ❶ def inner(): yield \"run inner 1 ...\" yield \"run innner 2 ...\" yield \"run inner 3 ...\" for item in outer(): print(item) # run outer... # run inner 1 ... # run innner 2 ... # run inner 3 ... ❶：yield from关键字底层就是for循环，所以这里的代码会更加的精简 yield from关键字后面必须跟上一个可迭代对象，如迭代器、生成器： def outer(): yield \"run outer...\" yield from range(3) for item in outer(): print(item) # run outer... # 0 # 1 # 2 生成器函数栈帧 生成器函数为什么能够挂起当前状态？普通函数为什么不可以？其实根本原因还是在栈帧上。 普通的函数栈帧组成图： 生成器函数栈帧组成图： 函数栈帧结构体 一个函数其实完整的栈帧是由很多部分组成的，参见CPython源码，感兴趣的可以研究一下： typedef struct _frame { PyObject_VAR_HEAD struct _frame *f_back; /* previous frame, or NULL */ PyCodeObject *f_code; /* code segment */ PyObject *f_builtins; /* builtin symbol table (PyDictObject) */ PyObject *f_globals; /* global symbol table (PyDictObject) */ PyObject *f_locals; /* local symbol table (any mapping) */ PyObject **f_valuestack; /* points after the last local */ /* Next free slot in f_valuestack. Frame creation sets to f_valuestack. Frame evaluation usually NULLs it, but a frame that yields sets it to the current stack top. */ PyObject **f_stacktop; PyObject *f_trace; /* Trace function */ char f_trace_lines; /* Emit per-line trace events? */ char f_trace_opcodes; /* Emit per-opcode trace events? */ /* Borrowed reference to a generator, or NULL */ PyObject *f_gen; int f_lasti; /* Last instruction if called */ /* Call PyFrame_GetLineNumber() instead of reading this field directly. As of 2.3 f_lineno is only valid when tracing is active (i.e. when f_trace is set). At other times we use PyCode_Addr2Line to calculate the line from the current bytecode index. */ int f_lineno; /* Current line number */ int f_iblock; /* index in f_blockstack */ char f_executing; /* whether the frame is still executing */ PyTryBlock f_blockstack[CO_MAXBLOCKS]; /* for try and loop blocks */ PyObject *f_localsplus[1]; /* locals+stack, dynamically sized */ } PyFrameObject; 本章总结 这一章可以说及其重要，Python的协程编程中本章知识是绝对的核心基础，只有理解了生成器才用可能理解协程。 还是以问答形式进行记录吧： ①：生成器和迭代器有什么不同？ 答：生成器就是迭代器的另一种实现，普通的迭代器必须通过iter()函数进行创建，也就是说普通的迭代器必须依赖可迭代对象才能够创建出来，但是可迭代对象会占用大量内存，所以产生了生成器，即不通过可迭代对象就能拿到的迭代器。 ②：yield form的作用？ 答：yield form只能定义在一个生成器函数中，该生成器函数内部如果嵌套调用了另一个生成器函数时就可以使用yield form进行另一个生成器函数的调用，它底层会自动经过for循环对另一个生成器对象进行操纵，且将值返回给最外部。 ③：生成器函数和普通函数有什么不同？ 答：生成器函数加括号得到生成器对象，生成器对象调用其下__next__()方法才会执行函数体代码。而普通函数加括号直接执行函数体代码。 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:46 "},"Python/Python模块与包/summary.html":{"url":"Python/Python模块与包/summary.html","title":"Python模块与包","keywords":"","body":" 目录规范 Python模块 Python包 内置模块：time 内置模块：datetime 内置模块：random 内置模块：os 内置模块：sys 内置模块：json&pickle&shelve 内置模块：hashlib 内置模块：configparser 内置模块：subprocess 内置模块：logging 内置模块：re 内置模块：importlib 内置模块：collections 内置模块：itertools 内置模块：functools 模块包库框架的区别 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:46 "},"Python/Python模块与包/目录规范.html":{"url":"Python/Python模块与包/目录规范.html","title":"目录规范","keywords":"","body":"目录规范 为了提高程序的可读性与可维护性，我们应该为软件设计良好的目录结构，这与规范的编码风格同等重要。 软件的目录规范并无硬性标准，只要清晰可读即可。 但是有一些规范还是十分合理的，我们应当予以遵守： 目录层次不超过5层 目录尽量以复数形式命名，如imgs而不是img 目录命名尽量清晰易懂 目录说明 bin 目录级别：一级目录 目录作用：通常用于存放项目启动脚本 其他命名：暂无 注意事项：如果拥有此目录，则启动脚本需要考虑模块导入路径的问题 core 目录级别：一级目录 目录作用：存放主程序、业务逻辑源代码 其他命名：src 注意事项：可根据不同的子业务继续划分二级目录 api 目录级别：一级目录 目录作用：通常用于存放项目接口文件，使得项目能够在启动后和外部通信 其他命名：interface 注意事项：可根据不同的子业务需要继续划分二级目录 db 目录级别：一级目录 目录作用：存放操作数据库相关文件，主要用于与数据库交互 其他命名：暂无 注意事项：暂无 lib 目录级别：一级目录 目录作用：存放程序中常用的自定义模块 其他命名：暂无 注意事项：暂无 conf 目录级别：一级目录 目录作用：存放项目所需要的配置文件 其他命名：config 注意事项：暂无 logs 目录级别：一级目录 目录作用：存放项目运行时所产生的日志文件 其他命名：暂无 注意事项：暂无 docs 目录级别：一级目录 目录作用：存放项目的详细说明文档 其他命名：暂无 注意事项：暂无 plugins 目录级别：一级目录 目录作用：存放项目中所需要的第三方插件 其他命名：utils、tools、helpers 注意事项：暂无 common 目录级别：一级目录 目录作用：存放项目中大部分需求都能使用到的功能，相当于公共插件 其他命名：暂无 注意事项：暂无 test 目录级别：一级目录 目录作用：存放项目测试代码 其他命名：暂无 注意事项：暂无 static 目录级别：一级目录 目录作用：存放项目中所需要的静态文件 其他命名：暂无 注意事项：暂无 views 目录级别：一级目录 目录作用：存放项目中所需要的模板文件，MVC模型中的视图 其他命名：templates 注意事项：暂无 controller 目录级别：一级目录 目录作用：存放项目中的主流算法，MVC模型中的控制 其他命名：暂无 注意事项：暂无 models 目录级别：一级目录 目录作用：存放项目中与数据库打交道的脚本，MVC模型中的模型 其他命名：暂无 注意事项：暂无 文件说明 run.py 文件位置：项目根目录下，或者bin目录下 文件作用：项目的启动脚本 其他命名：start.py 注意事项：如果启动脚本是在bin目录下，则需要考虑sys.path setup.py 文件位置：项目根目录下 文件作用：安装、部署、打包的脚本，一键安装所需要的所有依赖环境 其他命名：暂无 注意事项：暂无 一般来说，用setup.py来管理代码的打包、安装、部署问题。业界标准的写法是用Python流行的打包工具setuptools来管理这些事情，这种方式普遍应用于开源项目中。 不过这里的核心思想不是用标准化的工具来解决这些问题，而是说，一个项目一定要有一个安装部署工具，能快速便捷的在一台新机器上将环境装好、代码部署好和将程序运行起来。 settings.py 文件位置：conf文件夹下 文件作用：项目配置文件 其他命名：有的是py脚本，后缀就是.py，而有的是.ini 、.conf、.yaml等 注意事项：暂无 requirements.txt 文件位置：项目根目录下 文件作用：存放所有项目第三方依赖库、模块的名字及版本 其他命名：暂无 注意事项：这个一般都是用第三方模块生成的 　requirements.txt文件的存在是为了方便开发者维护软件的依赖库。我们需要将开发过程中依赖库的信息添加进该文件中，避免在 setup.py安装依赖时漏掉软件包，同时也方便了使用者明确项目引用了哪些Python包。 README.md 文件位置：项目根目录下 文件作用：项目整体描述信息，设计思路，设计目标等 其他命名：暂无 注意事项：暂无 关于README.me的内容，这个应该是每个项目都应该有的一个文件，目的是能简要描述该项目的信息，让读者快速了解这个项目。它需要说明以下几个事项: 软件定位，软件的基本功能； 运行代码的方法: 安装环境、启动命令等； 简要的使用说明； 代码目录结构说明，更详细点可以说明软件的基本原理； 常见问题说明。 其他文件 CHANGELOG.md ：描述项目每个版本的更新信息，说明版本号、更新内容、修复了哪些问题等 humans.txt ：保存网站信息和网站建设者信息 ，格式规范参考官网http://humanstxt.org/ LICENSE.txt：项目基于的许可协议 robots.txt：规定爬虫程序能够获取本网站的那些信息 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:46 "},"Python/Python模块与包/Python模块.html":{"url":"Python/Python模块与包/Python模块.html","title":"Python模块","keywords":"","body":"Python模块 Python中的模块是一系列功能的集合体，总计可分为3大类： 内置模块：Python自带的一些内置库，开箱即用 第三方模块：通过pip命令下载到的模块，无需自己定义，Python拥有海量的第三方模块 自定义模块：一个.py文件就是一个模块，所以自己编写的.py文件也可以当做模块使用，例如文件名为m.py的文件就是一个名为m的自定义模块 自定义模块 自定义模块即自己写的模块，好处如下： 将相同功能的代码进行分类 降低代码耦合度，减少代码冗余 使整个程序组织结构更清晰，便于后期维护 结构分类 由于一个.py文件即为一个模块，故我们可以创建2个.py文件，一个当做程序入口文件，一个当做功能模块文件，以下是结构图： . ├── m1.py # 功能模块文件 └── run.py # 程序入口文件 首先在m1.py中写一个基本的函数： # m1.py print(\"this is module m1\") def add(x, y): return x + y 其次是在run.py中写上一个打印语句： # run.py print(\"run ..\") import简单使用 如果run.py中想要使用到m1.py中的add()函数，该怎么做？ 只需要在run.py中导入m1.py里定义的add()函数即可，注意在使用时也必须按m1开头才行： # run.py import m1 # ❶ print(\"run ..\") result = m1.add(1, 2) # ❷ print(result) # this is module m1 # run .. # 3 ❶：当解释器发现import m1时，会查找m1.py文件，并且会执行m1.py中的所有代码，所以下面会打印出 this is module m1的字样 ❷：使用了m1中的add()函数 针对❶，提出一个问题，如果导入多次这个m1文件，是否也会执行多次其中的代码呢？ 结果是否，也就是说只有第一次导入模块时，才会执行模块中的代码，多次导入只执行一次，其根本原因参照Python模块查找一节。 # run.py import m1 import m1 import m1 print(\"run ..\") result = m1.add(1, 2) print(result) # this is module m1 ❶ # run .. # 3 模块命名空间 现在我们有2个模块文件： . ├── m1.py ├── m2.py └── run.py 且2个模块文件中的代码都大部分相似： # m1.py print(\"this is module m1\") def add(x, y): return x + y # m2.py print(\"this is module m2\") def add(x, y): return x + y 在run中导入2个模块，且分别使用其下的add()函数时，内部发生了什么事情？ # run.py import m1 import m2 print(\"run ..\") resultM1 = m1.add(1, 2) resultM2 = m2.add(1, 2) print(resultM1) print(resultM2) # this is module m1 # this is module m2 # run .. # 3 # 3 run.py执行时，会按照import的顺序执行m1.py和m2.py文件中的代码 当m1，m2执行完成之后，会产生一个模块的命名空间 run.py的全局命名空间中将产生2个标识符，分别指向了m1.py和m2.py的模块命名空间 模块命名空间如下所示： 当要使用m1.add()时，则run.py通过全局命名空间中的标识符m1，去m1模块的命名空间中查找函数标识符add。 当要使用m2.add()时，则run.py通过全局命名空间中的标识符m2，去m2模块的命名空间中查找函数标识符add。 __name__与__main__ 当一个模块编写完成后，将要对其进行测试工作，确保代码无误才能投入使用。 如下，m1的测试代码写上： # m1.py print(\"this is module m1\") def add(x, y): return x + y # test print(add(1, 2)) 测试没问题后，run.py中对其进行功能引用： # run.py import m1 import m2 print(\"run ..\") resultM1 = m1.add(1, 2) resultM2 = m2.add(1, 2) print(resultM1) print(resultM2) # this is module m1 # 3 ❶ # this is module m2 # run .. # 3 当运行run.py后，会发现1处多打印了个3，这是因为在执行m1模块时，也将测试代码给执行了。 如何避免这种问题？我们可以在m1.py中加上一个判断语句： # m1.py print(\"this is module m1\") def add(x, y): return x + y # test if __name__ == \"__main__\": # ❶ print(add(1, 2)) ❶：__name__：如果该.py文件当做脚本被执行，则该变量为__main__，如果该.py文件当做模块导入被执行，则该变量为.py文件的名字，如m1.py就是m1 所以说，加入这条测试语句的目的在于，.py文件在不同的方式使用时可以执行不同的代码： 当做脚本被执行时，会运行测试代码 当做模块被导入时，不会运行测试代码 模块导入 import .. import语句的使用方式： import 模块名 导入的最小单元是模块 使用import导入模块的优缺点： 优点：不会和当前的全局命名空间标识符产生冲突 缺点：在使用模块功能时必须加上import右边的标识符前缀 如下所示，2个不同模块的相同标识符函数并不会产生冲突： import time import datetime print(time.time()) print(datetime.time()) # 1621665686.779634 # 00:00:00 也可以一行导入多个模块，使用逗号进行分割： import time, datetime from .. import .. from语句的使用方式： from 模块名 import 标识符 导入的最小单元是具体功能 使用from语句导入模块的优缺点： 优点：在使用模块功能时必须加上import右边的标识符前缀，如果直接导入了一个具体功能，则不用加前缀 缺点：容易和当前的全局命名空间标识符产生冲突 如下示例，由于datetime模块后导入，所以它的time函数标识符替代了time模块的time函数标识符： from time import time from datetime import time print(time()) print(time()) # 00:00:00 # 00:00:00 也可以在一行导入同一模块下的多个功能，以逗号进行分割： from time import time, sleep, ctime 别名的使用 使用as语句来为冲突的标识符取一个别名： from time import time as ttime from datetime import time as dtime print(ttime()) print(dtime()) # 1621665953.605452 # 00:00:00 *与__all__ 使用from 模块名 import *的方式，可以导入该模块下的所有标识符。 如果你是该模块的开发者，则可以通过__all__属性规定这种导入方式允许哪些标识符被导入。 在__all__中的标识符，可以被from 模块名 import *的方式进行导入 未在__all__中的标识符，不会被from 模块名 import *的方式进行导入 如果未定义__all__属性，则所有的标识符都会from 模块名 import *的方式进行导入 如下，在m1.py模块文件中，定义了1个getMax()的接口暴露函数，此外还有1个内部处理函数computeMax()以及模块说明变量desc： # m1.py def getMax(iterable): currentMax = None for index, item in enumerate(iterable): if index == 0: currentMax = computeMax(item, iterable[index + 1]) elif currentMax != item: currentMax = computeMax(currentMax, item) return currentMax def computeMax(x, y): return x if x > y else y desc = \"this is module m1\" __all__ = (\"getMax\", \"desc\") # ❶ ❶：__all__的格式必须是Tuple(str, str) 现在run.py中如果使用from m1 import *，则会将__all__中的所有标识符进行导入，下面示例中由于使用了未在__all__中定义的标识符，则抛出NameError的异常： # run.py from m1 import * print(getMax) print(desc) print(computeMax) # # this is module m1 # NameError: name 'computeMax' is not defined 循环导入问题 模块a中导入模块b，模块b中又导入了模块a，且导入语句都在首行，此时将引发循环导入的问题。 示例如下： # run.py import m1 print(m1.desc) # m1.py import m2 desc = \"this is module m1\" print(m2.desc) # m2.py import m1 desc = \"this is module m2\" print(m1.desc) 运行run.py，结果如下： AttributeError: module 'm2' has no attribute 'desc' 异常原因在于： run.py首行导入了m1，m1首行导入了m2，m2首行又导入了m1，导致m1.desc未能成功进行对象声明，故抛出异常。 执行步骤： run.py：import m1 (将m1加载至内存中) m1.py：import m2 (将m2加载至内存中) m2.py：import m1 (m1已经执行了，不重复执行了) m2.py：desc = \"this is module m2” m2.py：print(m1.desc)）(m1.desc没有进行对象声明，抛出异常) 解决办法： 将m1导入m2的语句放在行尾 将m1导入m2的语句放入函数中，并在行尾执行函数 办法1： # m1.py desc = \"this is module m1\" import m2 print(m2.desc) 办法2： desc = \"this is module m1\" def importFunction(): import m2 print(m2.desc) importFunction() 模块查找 查找优先级 无论是from .. import ..语句还是import语句，在导入模块时都会涉及到模块位置查找的问题。 模块查找优先级如下： 先查找内存 后查找硬盘 当一个模块被导入过一次后，就会加载至内存中，重复导入便可直接从内存中拿到该模块，而存在于内存中的模块代码是不会被执行的。 sys.modules sys.modules用于查看存在于内存中的模块，如果要导入的模块存在于这里面，就直接进行导入，而不执行其中的代码： >>> import sys >>> sys.modules ... 当一个存在于硬盘之上的模块被导入时，则会将该模块加载至内存中，只要是存在于内存中的模块，重复导入时就不会执行其中的代码了。 如下示例，第一次导入存在于硬盘之上的m1模块后，它被加载至了内存中： >>> tuple(sys.modules.items())[-1] ('rlcompleter', ) >>> import m1 >>> tuple(sys.modules.items())[-1] (('m1', )) Ps：其实当Python解释器启动时，会自动的运行一遍所有的内置模块并加载至内存中，因为这些内置模块也是存放在磁盘下的，你可以在Python解释器安装根目录的lib目录下找到它们。 sys.path 当内存中没有模块路径时，将按照sys.path的路径顺序依次在磁盘中查找。 如果在PyCharm下打印sys.path，它会做一些优化处理，比原生的REPL环境多出一些查找路径，下面使用#号进行标注： [ # '/Users/yunya/PycharmProjects/Project', # '/Users/yunya/PycharmProjects/Project', # '/Applications/PyCharm.app/Contents/plugins/python/helpers/pycharm_display', '/Library/Frameworks/Python.framework/Versions/3.6/lib/python36.zip', '/Library/Frameworks/Python.framework/Versions/3.6/lib/python3.6', '/Library/Frameworks/Python.framework/Versions/3.6/lib/python3.6/lib-dynload', '/Users/yunya/Library/Python/3.6/lib/python/site-packages', '/Library/Frameworks/Python.framework/Versions/3.6/lib/python3.6/site-packages', # '/Applications/PyCharm.app/Contents/plugins/python/helpers/pycharm_matplotlib_backend' ] 原生的REPL环境打印： >>> import sys >>> sys.path [ '', '/Library/Frameworks/Python.framework/Versions/3.6/lib/python36.zip', '/Library/Frameworks/Python.framework/Versions/3.6/lib/python3.6', '/Library/Frameworks/Python.framework/Versions/3.6/lib/python3.6/lib-dynload', '/Users/yunya/Library/Python/3.6/lib/python/site-packages', '/Library/Frameworks/Python.framework/Versions/3.6/lib/python3.6/site-packages' ] >>> 模块导入规范 导入模块时要遵循的一些规范： 导入顺序：内置模块在最上面，第三方模块在中间，自定义模块在下面 自定义模块名风格：蛇形式命名 Ps：Python2中有些模块是驼峰式命名，但是在Python3中都更改为蛇形式命名了，如PyMySQL，更名为pymysql 此外，模块也是一等公民，运行被赋值、传参等等。 模块编写规范 如果要编写自定义模块，也需要遵循一些规范： 首行添加模块文档描述，让别人知道你的模块是干嘛的 减少全局变量的使用，这样在第一次导入模块时会加快导入速度 模块中的类、函数等都需要写好注释 使用 if __name__ == “__main__”:的语句写好测试案例 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:46 "},"Python/Python模块与包/Python包.html":{"url":"Python/Python模块与包/Python包.html","title":"Python包","keywords":"","body":"Python包 包是一个含有__init__.py的文件夹（Python2中必须拥有，Python3中可以省略）。 包的基础单元是模块，当然一个包中也可以包含其他的包，是一组模块的集合。 包的导入 当导入一个包时，将会先执行包下__init__.py文件，于此同时会产生一个包的命名空间。 而在__init__中定义的标识符都会丢入到这个命名空间中。 现在，我们定义了一个包： ├── package # 顶级包 │ ├── __init__.py │ ├── sub1 # 子级包 │ │ ├── __init__.py │ │ └── m1.py # 含有add()函数 │ └── sub2 # 子级包 │ ├── __init__.py │ └── m2.py # 含有multiplication()函数 └── run.py # 启动文件 产生2个问题： 作为包的使用者而言，run.py如何调用到包中的某一个功能呢？ 作为包的开发者而言，包中任意一个模块，如何调用到另一个模块中的功能？ 外部导入 外部导入时，只能通过绝对路径来进行导入，如： # run.py from package.sub1.m1 import add 但如果package的__init__文件中，定义了add的路径，如： # package/__init__.py from package.sub1.m1 import add 则在外部可以省略绝对导入，直接通过package拿到add()函数： # run.py from package import add 这是因为顶级包package的命名空间中，已经有了add()函数的具体指向，所以外部的导入可以简写。 内部导入 内部导入分为绝对导入和相对导入两种。 绝对导入，必须以顶级包作为起始，如我想在m2.py文件中调用m1.py文件中的功能： # package/sub2/m2.py from package.sub1.m1 import add 相对导入是通过1个点和2个点来进行区分，1个点代指当前目录，2个点代指上层目录，如果在m2.py用相对导入调用m1.py文件中的功能，则代码如下所示： # package/sub2/m2.py from ..sub1.m1 import add 导入的约束 外部导入时，如果顶级包__init__.py文件中没有定义某一个功能的具体指向，你只能通过绝对导入的方式。 内部导入时，可以使用绝对导入和相对导入2种方式，个人更喜欢相对导入。 其次，在导包时一定要注意，不论是import还是from语法，.点的左边只能是一个包或者子模块（相对导入除外，.点的左边可以为空），如下所示： # run.py from package.sub1.m1 import add 顶级包 子级包 子模块 使用时没有这种限制，只需要记住使用时必须带上import语句后所有的标识符即可： # 导入时 from package import sub1 # 使用时 sub1.m1.add(1, 2) # 导入时 from package.sub1 import m1 # 使用时 m1.add(1, 2) 包的开发者 做为一名包的开发者，你需要尽可能的方便包的使用者。 多在__init__.py文件中写入子模块、功能的指向。 写好注释，测试用例。 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:46 "},"Python/Python模块与包/time.html":{"url":"Python/Python模块与包/time.html","title":"内置模块：time","keywords":"","body":"time简介 time模块是Python自带的模块，提供了时间的访问和转换功能。 官方文档 time模块中，对时间的表示包含3个概念： 时间戳形式：从1970.1.1 08:00:00（Unix纪元）开始到现在所经历的毫秒数，它int类型 结构化形式：以元组包裹的形式进行时间的展示，它tuple类型 字符串形式：以字符串的形式进行时间的展示，它是str类型 3种表示时间的方式之间可以互相转换，如下图所示： 时间获取 获取时间的方法： 方法 描述 表现形式 time.time() 获取时间戳形式的时间 时间戳 time.localtime() 获取结构化的本地时间 结构化 time.gmtime() 获取结构化的世界时间 结构化 time.asctime() 获取字符串形式的本地时间 字符串 time.ctime() 获取字符串形式的世界时间 字符串 time.strftime() 获取自定义格式的本地时间 字符串 Ps：本地时间在中国以东八区，上海时间时间为准，和世界时间（UTC）差了8小时 示例演示： >>> import time >>> time.time() 1621693706.0193129 >>> time.localtime() time.struct_time(tm_year=2021, tm_mon=5, tm_mday=22, tm_hour=22, tm_min=28, tm_sec=43, tm_wday=5, tm_yday=142, tm_isdst=0) >>> time.gmtime() time.struct_time(tm_year=2021, tm_mon=5, tm_mday=22, tm_hour=14, tm_min=29, tm_sec=0, tm_wday=5, tm_yday=142, tm_isdst=0) >>> time.asctime() 'Sat May 22 22:29:05 2021' >>> time.ctime() 'Sat May 22 22:29:09 2021' >>> time.strftime(\"%Y-%m-%d %H:%M:%S\") '2021-05-22 22:29:45' 结构化时间说明 在time.localtime()和time.gmtime()中，可以看到元组中有很多看不懂的数据项属性组成，它们的释义如下： 属性 描述 tm_year 年 tm_mon 月 tm_mday 日 tm_ hour 时 tm_min 分 tm_sec 秒 tm_wday 星期几，从0开始计算，一周就是0-6 tm_yday 该年份的第几天 tm_isdst 夏令营时间 这些属性都可以单独的提取出来，如获取这一年的年、月、日： >>> time.localtime().tm_year 2021 >>> time.localtime().tm_mon 5 >>> time.localtime().tm_mday 22 time.strftime() 放入一段字符串，将时间格式化出来，如下所示： >>> time.strftime(\"%Y-%m-%d %H:%M:%S\") '2021-05-22 22:29:45' %Y-%m%d这些都代表格式化时间的占位符，分别代表年月日等信息。 如下表所示： 符号 描述 %Y 格式化年份 %m 格式化月份 %d 格式化天数 %H 格式化小时 %M 格式化分钟 %S 格式化秒数 %X 等同于 “%H:%M:%S” 如想了解更多，参照官网示例截图： %accordion%点我查看%accordion% %/accordion% 时间转换 转换方法 以下是时间表现形式互相转换的方法： 方法 描述 time.mktime() 放入结构化时间，转换为时间戳时间 time.strftime() 放入结构化时间，转换为字符串时间 time.strptime() 放入字符串时间，转换为结构化时间 time.localtime() 放入时间戳时间，转换为结构化的本地时间 time.gmtime() 放入时间戳时间，转换为结构化的世界时间 示例演示： >>> time.mktime(time.localtime()) 1621694964.0 >>> time.strftime(\"%Y-%m-%d %X\", time.gmtime()) '2021-05-22 14:50:01' >>> time.strptime(time.ctime()) time.struct_time(tm_year=2021, tm_mon=5, tm_mday=22, tm_hour=22, tm_min=50, tm_sec=15, tm_wday=5, tm_yday=142, tm_isdst=-1) >>> time.localtime(time.time()) time.struct_time(tm_year=2021, tm_mon=5, tm_mday=22, tm_hour=22, tm_min=50, tm_sec=33, tm_wday=5, tm_yday=142, tm_isdst=0) >>> time.gmtime(time.time()) time.struct_time(tm_year=2021, tm_mon=5, tm_mday=22, tm_hour=14, tm_min=51, tm_sec=4, tm_wday=5, tm_yday=142, tm_isdst=0) 常用操作 将时间戳转换为固定的UTC时间字符串格式： >>> time.ctime(00) 'Thu Jan 1 08:00:00 1970' 将时间戳转换为本地时间的字符串表现形式： >>> t = 1293495903 # 有一个时间戳 >>> stuct = time.localtime(t) # 先将其转为本地的结构化时间 >>> stringTime = time.strftime(\"%Y-%m-%d %X\", stuct) # 再将其转换为字符串时间 >>> stringTime '2010-12-28 08:25:03' 将时间戳转换为世界时间的字符串表现形式： >>> t = 1293495903 # 有一个时间戳 >>> stuct = time.gmtime(t) # 先将其转为世界的结构化时间 >>> stringTime = time.strftime(\"%Y-%m-%d %X\", stuct) # 再将其转换为字符串时间 >>> stringTime '2010-12-28 00:25:03' 将一个字符串时间转换为时间戳： >>> stringTime = \"1998-01-26 00:00:10\" # 有一个字符串时间 >>> stuct = time.strptime(stringTime, \"%Y-%m-%d %X\") # 先将其转换为结构化时间 >>> stamp = time.mktime(stuct) # 再将其转换为时间戳 >>> stamp 885744010.0 线程睡眠 通过time.sleep()方法，可指定主线程睡眠多少秒，如下所示，第2个print()将在2秒后运行： import time print(\"start\") time.sleep(2) print(\"end\") 其他操作 日期判断 根据时间戳，获取7天后的时间： >>> currentTime = time.time() >>> sum7dayTime = currentTime + 7 * 86400 >>> time.strftime(\"%Y-%m-%d\", time.localtime(sum7dayTime)) '2021-05-29' 根据时间戳，获取3天前的时间： >>> currentTime = time.time() >>> sub3dayTime = currentTime - 3 * 86400 >>> time.strftime(\"%Y-%m-%d\", time.localtime(sub3dayTime)) '2021-05-19' 如果是时间戳操作，谨记1天是86400秒即可。 定时任务 脚本启动后，每隔一分钟，向屏幕打印一次hello world： import time currentSec = time.localtime().tm_sec while 1: if time.localtime().tm_sec == currentSec: print(\"hello world\") time.sleep(1) 延时任务 脚本启动后的一分钟时，打印一次hello world： import time currentTime = time.time() runTime = currentTime + 60 while 1: if time.time() == runTime: print(\"hello world\") break print(\"任务执行完毕\") Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:46 "},"Python/Python模块与包/datetime.html":{"url":"Python/Python模块与包/datetime.html","title":"内置模块：datetime","keywords":"","body":"datetime简介 datetime模块是Python内置模块，相比于time模块能够更加方便的操纵时间。 官方文档 以下举例部分常用方法： 方法 描述 datetime.datetime() 实例化返回一个datetime的对象 datetime.datetime.now() 获取本地时间，返回一个datetime的对象 datetime.datetime.utcnow() 获取世界时间，返回一个datetime的对象 datetime.datetime.fromtimestamp() 放入时间戳时间，直接转换为本地的datetime对象时间 datetime.datetime.utcfromtimestamp() 放入时间戳时间，直接转换为世界的的datetime对象时间 datetime.timedelta() 在一个datetime对象时间的基础上进行加减，返回一个新的datetime的对象 datetime.datetime.weekday() 放入一个datetime对象，获取该对象是那一周的第几天，从0开始计算，一周就是0-6 对象获取 datetime.datetime.now()和datetime.datetime.utcnow()都可以获取一个表示当前时间的datetime对象。 >>> import datetime >>> datetime.datetime.now() datetime.datetime(2021, 5, 22, 23, 31, 43, 468077) >>> datetime.datetime.utcnow() datetime.datetime(2021, 5, 22, 15, 31, 52, 841214) 为datetime.datetime.fromtimestamp()放入一个时间戳可直接获取到表示本地时间的datetime的对象： >>> datetime.datetime.fromtimestamp(11111) datetime.date(1970, 1, 1) >>> datetime.datetime.utcfromtimestamp(11111) datetime.datetime(1970, 1, 1, 3, 5, 11) datetime对象是str类型的更高一级封装，你可以将datetime对象转换为str类型： >>> str(datetime.datetime.now()) '2021-05-23 00:06:03.271989' 对象属性 一个datetime对象拥有很多时间属性，如下表所示： 属性 描述 year 年份（int） month 月份（int） day 天数（int） hour 时数（int） minute 分数（int） second 秒数（int） microsecond 毫秒数（int） 你可以快速的获取它们： >>> currentTime = datetime.datetime.now() >>> currentTime.year 2021 >>> currentTime.month 5 >>> currentTime.day 22 >>> currentTime.hour 23 >>> currentTime.minute 48 >>> currentTime.second 52 >>> currentTime.microsecond 527012 对象方法 一个datetime对象拥有很多方法，如下表所示： 方法 描述 datetimeObject.timestamp() 返回一个时间戳，不同于time模块的时间戳，该方法返回的是一个float类型 datetimeObject.timetuple() 返回与time.localtime()兼容的本地时间元组 datetimeObject.utctimetuple() 返回与time.gmtime()兼容的UTC时间元组 datetimeObject.ctime() 返回ctime()样式字符串 datetimeObject.isoformat() 根据ISO格式返回时间字符串 datetimeObject.strptime() 类似于time.strptime() datetimeObject.tzname() 返回时区名字 datetimeObject.replace() 替换一个字符串格式的时间中某部分，返回一个新的datetime的对象 由于这些方法使用的时候并不多，所以只举例一个时间替换。 将当前时间的年份替换为1998年： >>> currentTime = datetime.datetime.now() >>> currentTime.replace(year=1998) datetime.datetime(1998, 5, 23, 0, 22, 24, 698922) 时间加减 datetime对象允许通过和datetime.timedelta()进行加减，以便进行时间的计算。 时间加减中不支持年份的计算，可以用365天代替 当前时间加3天： >>> sum3dayTime = datetime.timedelta(+3) + currentTime >>> sum3dayTime datetime.datetime(2021, 5, 26, 0, 15, 15, 405378) 当前时间-3天： >>> sub3dayTime = datetime.timedelta(-3) + currentTime >>> sub3dayTime datetime.datetime(2021, 5, 20, 0, 15, 15, 405378) 当前时间加3小时： >>> sum3hours = datetime.timedelta(hours=+3) + currentTime >>> sum3hours datetime.datetime(2021, 5, 23, 3, 15, 15, 405378) 当前时间减3小时： >>> sub3hours = datetime.timedelta(hours=-3) + currentTime >>> sub3hours datetime.datetime(2021, 5, 22, 21, 15, 15, 405378) Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:46 "},"Python/Python模块与包/random.html":{"url":"Python/Python模块与包/random.html","title":"内置模块：random","keywords":"","body":"random简介 random模块是Python自带的模块，该模块实现了各种分布的伪随机数生成器。 官方文档 以下举例部分常用方法： 方法 描述 random.randint(1, 3) 从1-3之间随机生成一个整数 random.randrange(1, 3) 从1-2之间随机生成一个整数 random.random() 生成大于0且小于1的浮点数 random.uniform(1, 3) 生成大于1且小于3的浮点数 random.choice(seq) 从序列中随机取出1个数据项 random.sample(seq, 2) 从序列中随机取出指定个数据项，这里是2，以列表形式返回 random.shuffle(seq) 将传入的拥有索引的序列进行打乱，原地打乱，不返回新序列 整数生成 random.randint()是顾头顾尾的生成随机整数： >>> import random >>> random.randint(1, 3) 1 >>> random.randint(1, 3) 2 >>> random.randint(1, 3) 3 random.randrange()是顾头不顾尾的生成随机整数： >>> random.randrange(1, 3) 1 >>> random.randrange(1, 3) 2 浮点数生成 random.random()生成浮点数的范围总是介于0和1之间： >>> random.random() 0.818462343335113 random.uniform()可指定生成浮点数的范围： >>> random.uniform(1, 3) 2.810443694822667 数据项抽取 random.choice()可以从一个序列中随机抽取出一个数据项： >>> random.choice(range(10)) 1 random.sample()可以从一个序列中随机抽取出多个数据项： >>> random.sample(range(10), 2) [1, 0] 它们貌似均不支持字典的随机抽取。 生成乱序列 random.shuffle()可以传入一个线性结构的序列，并将其中的数据项进行随机的打乱： >>> li1 = [i for i in range(10)] >>> random.shuffle(li1) >>> li1 [1, 5, 6, 3, 7, 2, 9, 8, 4, 0] >>> random.shuffle(li1) >>> li1 [1, 5, 4, 3, 7, 0, 9, 6, 8, 2 生成验证码 验证码总是随机的，因此可以通过random模块进行实现生成： import random def getVerificationCode(bitNumber): code = \"\" for i in range(bitNumber): code += random.choice( [ str(random.randint(1, 9)), chr(random.randint(65, 91)) # ❶ ] ) return code code = getVerificationCode(6) print(code) ❶：65-90是大写的A-Z的ASCII码表示范围 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:46 "},"Python/Python模块与包/os.html":{"url":"Python/Python模块与包/os.html","title":"内置模块：os","keywords":"","body":"os简介 os模块是Python内置模块，提供了各种使用Python对操作系统提供操纵的接口。 官方文档 以下举例部分常用方法和属性： 方法/属性 描述 os.curdir 总是返回一个字符串，“.”，代指当前目录 os.pardir 总是返回一个字符串，“..”，代指当前父级目录 os.sep 返回当前平台下的路径分隔符，Windows下为“\\”，Unix下为“/” os.linesep 返回当前平台下的行终止符，Windows下为“\\r\\n”，Unix下为“\\n” os.pathsep 返回当前平台下的用于分割文件的分隔符，Windows下为“;”，Unix下为“:” os.name 返回当前平台的信息，Windows下为“nt”，Unix下为“posix” os.environ 获取系统环境变量 os.system(“command”) 运行shell命令 os.listdir(“dirName”) 获取指定目录下的所有项目，相当于ls命令，以列表方式返回结果 os.getcwd() 获取当前脚本的工作目录，相当于pwd命令 os.chdir(“dirName”) 改变当前脚本的工作目录，相当于cd命令 os.makedir(“dirName”) 生成单级的空目录，相当于mkdir命令 os.makedirs(“dirName1/dirName2”) 生成多层递归目录，相当于mkdir -p命令 os.rmdir(“dirName”) 删除单级的空目录 os.removedirs(“dirName”) 删除多层递归目录，前提是该目录必须为空 os.remove(“fileName”) 删除一个文件 os.rename(“oldName”, “newName”) 重命名文件/目录 os.path.abspath(“path”) 返回当前path的绝对路径 os.path.split(“path”) 将path分为2部分，返回元组，索引0是路径，索引1是文件 os.path.dirname(“path”) 返回path的路径部分，相当于上面方法的索引0 os.path.basename(“path”) 返回path的路径部分，相当于上面方法的索引1，如果path是以“/”或者“\\”结尾，则返回None os.path.join(“path1”, “path2”) 将多个path进行组合，相当于os.path.split()的反操作 os.path.exists(“path”) 判断path是否存在，返回布尔值 os.path.isabs(“path”) 判断path是否是绝对路径，返回布尔值 os.path.isfile(“path”) 判断path是否是一个文件路径，返回布尔值 os.path.isdir(“path”) 判断path是否是一个目录路径，返回布尔值 os.stat(“path”) 获取path所指文件/目录的相关信息 os.path.getatime(“path”) 获取path所指文件/目录的最后存取时间 os.path.getmtime(“path”) 获取path所指文件/目录的最后修改时间 os.path.getsize(“path”) 获取path所指文件/目录的大小 平台信息 根据以下一些属性，可获取平台信息： 属性 描述 os.curdir 总是返回一个字符串，“.”，代指当前目录 os.pardir 总是返回一个字符串，“..”，代指当前父级目录 os.sep 返回当前平台下的路径分隔符，Windows下为“\\”，Unix下为“/” os.linesep 返回当前平台下的行终止符，Windows下为“\\t\\n”，Unix下为“\\n” os.pathsep 返回当前平台下的用于分割文件的分隔符，Windows下为“;”，Unix下为“:” os.name 返回当前平台的信息，Windows下为“nt”，Unix下为“posix” os.environ 获取系统环境变量 os.environ是一个全局字典，你可以将它当做普通字典进行操作。 >>> os.environ ... >>> os.environ[\"k1\"] = \"v1\" >>> os.environ.get(\"k1\") 'v1' 此外，它是全局的，这意味着同一个项目之中任何地方都能随时获取到它，因此可以用它来存储一些较为私密的信息，如数据库链接IP+PORT+USER+PASSWORLD。 使用该字典时需要注意key必须是str类型，若是其他类型则会抛出异常。 目录操作 使用以下一些方法，可对目录做出操作： 方法 描述 os.system(“command”) 运行shell命令 os.listdir(“dirName”) 获取指定目录下的所有项目，相当于ls命令，以列表方式返回结果 os.getcwd() 获取当前脚本的工作目录，相当于pwd命令 os.chdir(“dirName”) 改变当前脚本的工作目录，相当于cd命令 os.makedir(“dirName”) 生成单级的空目录，相当于mkdir命令 os.makedirs(“dirName1/dirName2”) 生成多层递归目录，相当于mkdir -p命令 os.rmdir(“dirName”) 删除单级的空目录 os.removedirs(“dirName”) 删除多层递归目录，前提是该目录必须为空 os.remove(“fileName”) 删除一个文件 os.rename(“oldName”, “newName”) 重命名文件/目录 os.system()应该是一个比较常用的方法，它可以运行任何的shell命令： >>> os.system(\"tree .\") >>> os.system(\"ifconfig\") 但是os.system()如果在Windows环境下的PyCharm中进行使用，则会抛出异常。 因为Windows平台执行命令的返回结果是采用GBK编码，而PyCharm中使用UTF8对结果进行解码就会产生乱码问题。 路径操作 路径操作应该是os模块中比较常用的： 方法 描述 os.path.abspath(“path”) 返回当前path的绝对路径 os.path.split(“path”) 将path分为2部分，返回元组，索引0是路径，索引1是文件 os.path.dirname(“path”) 返回path的路径部分，相当于上面方法的索引0 os.path.basename(“path”) 返回path的路径部分，相当于上面方法的索引1，如果path是以“/”或者“\\”结尾，则返回None os.path.join(“path1”, “path2”) 将多个path进行组合，相当于os.path.split()的反操作 os.path.exists(“path”) 判断path是否存在，返回布尔值 os.path.isabs(“path”) 判断path是否是绝对路径，返回布尔值 os.path.isfile(“path”) 判断path是否是一个文件路径，返回布尔值 os.path.isdir(“path”) 判断path是否是一个目录路径，返回布尔值 示例演示os.path.join()和os.path.split()： >>> dirName, fileName = os.path.split(\"/Users/yunya/document/os模块.md\") >>> dirName '/Users/yunya/document' >>> fileName 'os模块.md' >>> newPath = os.path.join(\"/\", \"Users\", \"yunya\", \"document\", \"os模块.md\") >>> newPath '/Users/yunya/document/os模块.md' >>> 信息获取 信息获取也有时候会用到： 方法 描述 os.stat(“path”) 获取path所指文件/目录的相关信息 os.path.getatime(“path”) 获取path所指文件/目录的最后存取时间 os.path.getmtime(“path”) 获取path所指文件/目录的最后修改时间 os.path.getsize(“path”) 获取path所指文件/目录的大小 项目模块查找 项目启动不了? 在之前介绍Python模块一章节中说到PyCharm和原生解释器在查找模块时的sys.path会有所不同。 PyCharm会自动的新增几行模块查找路径，而原生解释器则不会进行新增。 这样会产生一个问题，即项目上线后通过原生解释器进行启动项目时会发现找不到模块。 如，我们有一个下面结构的项目： Project │ ├── bin │ └── run.py # 入口文件 └── view ├── __init__.py └── views.py # 视图层 定义了main()函数 当run.py进行执行后，Python工作目录就被定义在了Project/bin/run.py一层。 from view.views import main if __name__ == '__main__': main() 如果在PyCharm中执行run.py，则不会抛出异常，它能顺利的找到view模块，这是因为PyCharm将工作目录的上层、上上层也加入到了sys.path即模块查找路径中： [ '/Users/yunya/PycharmProjects/Project/bin', '/Users/yunya/PycharmProjects/Project', '...' ] 这样查找模块范围就会大很多： Project # 上上层能找到 │ ├── bin # 上层找不到 │ └── run.py # 本层找不到 └── view ├── __init__.py └── views.py 但是如果在Python原生解释器环境下，调用执行run.py脚本，则会提示找不到view模块，因为view模块仅能在上上层被找到： Project # 这里才能找到 │ ├── bin │ └── run.py # 找不到 └── view ├── __init__.py └── views.py 如何解决这个问题？只需要在run.py脚本中将上上层路径加入至sys.path即可： import sys import os sys.path.append(os.path.abspath(os.path.dirname(os.path.dirname(__file__)))) from view.views import main if __name__ == '__main__': main() 这样再次使用Python原生解释器通过run.py脚本启动项目，就不会发生任何问题了。 OpenStack对路径的处理 在OpenStack中，对这种项目模块查找路径的处理采用了截然不同的方式： import os import os, sys print(os.path.abspath(__file__)) possible_topdir = os.path.normpath(os.path.join( # ❶ __file__, os.pardir, # 上一级，相当于手动输入\"..\" os.pardir, )) print(possible_topdir) ❶：os.path.normpath()可以将一个不规范的路径变为规范路径 这样也能够达到相同的效果。 Django3.x对路径的处理 Django3以前，对项目模块查找路径的处理采用了和我们相同的方式： BASE_DIR = os.path.dirname(os.path.dirname(__file__)) print(BASE_DIR) 在Django3之后，则使用pathlib模块代替了os模块，其实本质都是一样的： from pathlib import Path root = Path(__file__) res = root.parent.parent # ❶ print(res) ❶：取上层的上层 补充一点pathlib的知识，对于pathlib的路径拼接直接使用 / 符号即可，符号左边为Path对象，右边为str类型。 与os.path.join()拥有相同的效果。 print(Path(\"User/YunYa\") / r\"a/b/c\") # User\\YunYa\\a\\b\\c 无论是os.path.join()还是pathlib的/进行路径拼接，都会选择出适合当前平台的路径分隔符。 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:46 "},"Python/Python模块与包/sys.html":{"url":"Python/Python模块与包/sys.html","title":"内置模块：sys","keywords":"","body":"sys简介 sys模块是Python内置模块，提供了各种系统相关的参数和函数。 官方文档 以下举例部分常用方法和属性： 方法/属性 描述 sys.platform 返回操作系统平台名称 sys.version 获取Python解释程序的版本信息 sys.builtin_module_names 获取内置的所有模块名，元组形式返回 sys.modules 返回以加载至内存之中的模块及路径 sys.path 返回模块在硬盘中的搜索路径 sys.stdin Python标准输入通道，input()函数的底层实现 sys.stdout Python标准输出通道，print()函数的底层实现 sys.stderr Python标准输入错误通道 sys.getrecursionlimit() 获取当前Python中最大递归层级 sys.setrecursionlimit() 设置当前Python中最大递归层级 sys._getframe(0).f_code.co_name 获取被调用函数的名称 sys._getframe(1).f_code.co_name 获取被调用函数是被哪一个函数所嵌套调用的，若不是被嵌套调用则返回module sys._getframe().f_back.f_lineno 获取被调用函数在被调用时所处代码行数 sys._getframe().f_code.co_filename 获取被调用函数所在模块文件名 sys.getrefcount() 获取对象的引用计数 sys.argv 获取通过脚本调用式传递的数据 修改递归层级 修改递归层级已经介绍过一次了，默认Python的最大递归层级是1000层，我们可以对其进行修改： >>> sys >>> sys.getrecursionlimit() 1000 >>> sys.setrecursionlimit(10000) >>> sys.getrecursionlimit() 10000 函数栈帧信息 sys._getframe()能够获取到函数的栈帧对象，我们知道函数的栈帧对象中封存了一些函数运行时的信息。 那么通过下面这些属性就能拿到函数里栈帧的某些数据： sys._getframe(0).f_code.co_name：获取被调用函数的名称 sys._getframe(1).f_code.co_name：获取被调用函数是被哪一个函数所嵌套调用的，若不是被嵌套调用则返回module sys._getframe().f_back.f_lineno：获取被调用函数在被调用时所处代码行数 sys._getframe().f_code.co_filename：获取被调用函数所在模块文件名 import sys def func(): print(sys._getframe(0).f_code.co_name) print(sys._getframe(1).f_code.co_name) print(sys._getframe().f_back.f_lineno) print(sys._getframe().f_code.co_filename) func() 脚本传入参数 我们都知道Python解释器可以通过以下方式进行.py文件的调用： $ python3 demo.py 但是你可能不知道通过sys.argv属性可以获取通过脚本调用式传递的数据，如下启动.py脚本时传入了1、2、3： $ python3 demo.py 1 2 3 那么现在sys.argv就会接受到这3个数据，变成下面的格式： sys.argv = [\"scriptPath\", \"1\", \"2\", \"3\"] 基于这个特性，我们来做一个下载模拟器： import random import sys import time def download(): scale = 40 print(\"开始下载文件:{0}\".format(sys.argv[2]).center(scale + 10, '-')) totalSize = random.randint(1000, 2000) currentSize = totalSize / scale for i in range(scale + 1): a = '█' * i b = '_' * (scale - i) c = (i / scale) * 100 print('''\\r{0:^3.2f}% | {1}{2} | {3:.2f}/{4:.2f}(MB)'''.format(c, a, b, currentSize * i, totalSize), end=\"\") time.sleep(0.1) print(\"\\n\" + \"执行结束\".center(scale + 10, '-')) def main(): try: runFunc = eval(sys.argv[1]) except Exception: print(\"输入有误！\", file=sys.stderr) exit() else: runFunc() if __name__ == '__main__': main() 启动时输入参数： python3 ./bin/run.py download test.text Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:46 "},"Python/Python模块与包/json&pickle&shelve.html":{"url":"Python/Python模块与包/json&pickle&shelve.html","title":"内置模块：json&pickle&shelve","keywords":"","body":"序列化 序列化是指将在内存中的数据变成为可存储或者可传输的数据。 Python中称序列化为pickling，而其他编程语言中则称之为serialization、marshalling、flattening等等，都是一个意思。 序列化最重要的目的是数据持久化保存，以及数据跨平台传输： 持久化保存：数据无法在内存中长期驻留，因此可以将其转变为某种格式并写入到磁盘之中 跨平台传输：不同的编程语言中对于数据的表示都是不同的，如Python中的set在很多语言中就不具备，故可以将数据进行序列化，变为一种大家都认识的格式 json JSON格式最早来源于JavaScript语言，现在已经成为跨平台语言传输的通用格式。 它的操纵及其简单，以下是JSON与Python中数据类型的对应关系： Python数据类型 JSON格式表示 dict {} list [] str string int or float int or float True or False true or false None Null JSON优点是操纵简单、跨语言传输十分方便，因为它采用字符串进行存储。 JSON缺点是仅支持Python基本数据类型，像函数、类这种都不被支持。 Python中进行JSON格式化，可以选择内置的json模块： 官方文档 常用方法一览： 方法 描述 json.dumps() 将Python中的基本数据类型序列化为JSON格式的字符串 json.loads() 将JSON格式字符串反序列化为Python中的基本数据类型 json.dump() 同json.dumps()，不过写入文件更方便 json.load() 同json.loads()，不过读取文件更方便 序列化 使用json.dumps()可以将Python中的基本数据类型序列化为JSON格式的字符串： >>> import json >>> userMessage = {\"name\" : \"yunya\", \"age\" : \"18\", \"gender\" : True, \"hobby\" : [\"read\", \"playGame\"]} >>> json.dumps(userMessage) '{\"name\": \"yunya\", \"age\": \"18\", \"gender\": true, \"hobby\": [\"read\", \"playGame\"]}' 如果想将序列化的结果进行持久化保存，可以使用json.dump()方法，它可以指定输出对象为文件句柄，如下示例： >>> import json >>> userMessage = {\"name\" : \"yunya\", \"age\" : \"18\", \"gender\" : True, \"hobby\" : [\"read\", \"playGame\"]} >>> with open(file=\"test.json\", mode=\"wt\", encoding=\"utf8\") as f: json.dump(userMessage,fp=f) 反序列化 使用json.loads()可以将JSON格式字符串反序列化为Python中的基本数据类型： >>> userJsonStr = '{\"name\": \"yunya\", \"age\": \"18\", \"gender\": true, \"hobby\": [\"read\", \"playGame\"]}' >>> json.loads(userJsonStr) {'name': 'yunya', 'age': '18', 'gender': True, 'hobby': ['read', 'playGame']} 如果想从文件中读取JSON字符串并进行反序列化，可以使用json.load()方法，它可以指定读取对象为文件句柄，如下所示： >>> import json >>> with open(file=\"test.json\", mode=\"rt\", encoding=\"utf8\") as f: userMessage = json.load(fp=f) >>> userMessage {'name': 'yunya', 'age': '18', 'gender': True, 'hobby': ['read', 'playGame']} 序列化的过程 Python的基本数据类型转换为JSON字符串时，经历了什么？ 总计可分为2步： 修改str的单引号为双引号 根据JSON与Python中数据类型的对应关系，将数据进行包装转换为JSON表现形式 示例、修改str的单引号为双引号： >>> pyStr = 'string' >>> jsonStr = json.dumps(pyStr) >>> jsonStr '\"string\" 示例、根据JSON与Python中数据类型的对应关系，将数据进行包装转换为JSON表现形式： >>> pyType = None >>> jsonType = json.dumps(pyType) >>> jsonType 'null' 中文显示 如果JSON序列化的字符串中带有中文，则将其转变为Unicode的16进制表现形式： >>> pyStr = \"云崖先生\" >>> json.dumps(pyStr) '\"\\\\u4e91\\\\u5d16\\\\u5148\\\\u751f\"' 你可以指定序json.dumps()中的关键字参数ensure_ascii为False，此时不会对中文字符进行转换： >>> json.dumps(pyStr, ensure_ascii=False) '\"云崖先生\"' 猴子补丁介绍 Monkey Patch是指用一个补丁偷偷的将一个原本的功能进行替换，使用者并不知道目前使用的功能是已经替换后的功能。 第三方模块ujson相比于json来说性能更加的高效，你可以将它作为猴子补丁偷偷的替换掉json，只需要在项目运行时的入口加入并运行一个替换函数： import json import ujson def monkeyPatchJson(): json.__name__ = \"ujson\" json.dumps = ujson.dumps json.loads = ujson.loads monkeyPatchJson() 修改完毕后，重启项目，后面的代码甚至不需要任何修改，就能使用性能更高的ujson了。 采用猴子补丁之后，如果发现ujson不符合预期，那也可以快速撤掉补丁，删除掉函数的执行语句即可。 序列化非基本数据类型 datetime类型并非是Python基本的数据类型，所以JSON不支持对它的序列化。 import datetime import json now = datetime.datetime.now() strNow = json.dumps(now, ensure_ascii=False) print(strNow) # TypeError: Object of type 'datetime' is not JSON serializable 此时我们可以手动的扩展json.dumps()的功能，让其支持datetime的序列化。 具体思路是将非Python基本数据类型转换为基本数据类型后再使用json.dumps()对其进行序列化，实现步骤如下所示： import datetime import json from json.encoder import JSONEncoder class JsonRealize(JSONEncoder): \"\"\" 该类是自定义序列化非Python基本数据类型的逻辑实现类 主要作用是继承并覆写父类JSONEncoder的default() \"\"\" def default(self, serializeObject): # 发现序列化对象是datetime类型的话，就将其转换为str类型 if isinstance(serializeObject, datetime.datetime): return str(serializeObject) # 如果是其他类型，则交由JSONEncoder的default()进行处理 return JSONEncoder.default(self, serializeObject) if __name__ == '__main__': now = datetime.datetime.now() strNow = json.dumps(now, cls=JsonRealize, ensure_ascii=False) print(strNow) # \"2021-05-23 20:40:49.446823\" json模块使用注意事项 Python3.6以及Python2.7之前均不支持反序列化bytes类型。 也就是说json.loads()一个bytes类型会抛出异常。 pickle 　pickle模块是Python自带的模块，它和json模块的方法全部一致，区别在于pickle序列化后的类型是bytes类型，而json序列化后的类型是字符串类型。 由于要考虑到多语言的兼容性问题，json模块并不支持Python除基本数据类型之外的类型。如：函数类型，类等等。 但是pickle由于只支持Python使用，所以有了更强的对Python序列化对象的支持。 pickle可以序列化函数，类等等，但是并不推荐这么做，因为保存的只有一个内存地址。 另外，由于pickle的局限性太强所以更推荐使用JSON进行序列化操作。 由于很少使用，以及与json模块的方法一致，这里不再进行演示了。 官方文档 shelve shelves是Python自带的模块，它能够更加方便的将Python数据进行持久化保存。 官方文档 它将整个文件看做一个大的字典，将字典中的key看做Python中的标识符，将value看做存储的对象，因此操作起来十分方便。 只需要记住2个方法即可： shelve.open()：打开一个文件，这个文件是可读可写的 shelve.close()：关闭文件 示例演示： >>> import shelve >>> with shelve.open(\"test.txt\") as f: f[\"name\"] = \"Yunya\" f[\"age\"] = 18 f[\"hobby\"] = [\"readBook\", \"playGame\"] >>> with shelve.open(\"test.txt\") as f: name = f.get(\"name\") >>> name 'Yunya' Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:46 "},"Python/Python模块与包/hashlib.html":{"url":"Python/Python模块与包/hashlib.html","title":"内置模块：hashlib","keywords":"","body":"hashlib简介 密码学是一个庞大的领域，总体来说可将该领域中的加密方式分为2大类： 对称加密：可通过加密值反解出内容 非对称加密：不可通过加密值反解出内容 而今天介绍的hashlib模块是Python3中所独有的，提供了一系列的非对称加密算法：hash算法。 在Python2中hashlib模块被拆分成了md5模块和sha模块，它们提供的功能和Python3的hashlib模块相同。 官方文档 以下是该模块提供的部分常用方法及属性： 属性/方法 描述 hashlib.algorithms_guaranteed 以集合方式，列出所有平台所支持的hash算法 hashlib.algorithms_available 以集合方式，列出当前所运行的Python解释器所支持的hash算法 hash.digest_size 以字节表示结果hash对象的大小 hash.block_size 以字节表示的hash算法的内部块大小 hash.name 返回hash对象的规范名称 hash.copy() 返回hash对象的拷贝副本 hash.update() 在已有基础上对hash对象的内容进行更新 hash.hexdigest() 返回16进制的字符串hash值 hash.digest() 返回2进制的字节串hash值 hash特性 Python的字典在键值对数据存储和读取时，就用到了hash算法。 比如：\"k1\" : \"v1\"的键值对在存储过程中，\"k1\"会通过hash()函数得出1个hash值，该hash值与v1一一对应，后续通过dict.get()方法通过\"k1\"找\"v1\"时，内部也是利用的这个hash值来进行查找。 通过字典的种种特性，我们可以顺势推导出hash的一些特性： 相同的内容求hash值，得到的hash结果也必然相同 不能通过hash值反解出内容（或者说反解的代价大到不可能实现，但也不是绝对的） 如果采用相同的hash算法，无论需要校验的内容由多大，得到的hash值长度总是固定的 我们使用内置的hash()函数来验证这3点结论： 1）相同的内容求hash值，得到的hash结果也必然相同： >>> hash(\"hello world\") -484803057 >>> hash(\"HELLO WORLD\") 264022494 >>> hash(\"hello world\") -484803057 2）不能通过hash值反解出内容： >>> hash(\"k1\") -714364401 >>> hash(\"-714364401\") 1936952577 3）如果采用相同的hash算法，无论需要校验的内容有多大，得到的hash值长度总是固定的： >>> hash(\"hello\") 313408759 >>> hash(\"hello, Python3\") -1705693388 算法区别 由于hash算法的特性，它常被用于一致性校验、密码存储等领域。 其中最著名的hash算法就是MD5，它被称为永不可破的hash算法，但随着技术的发展MD5已经不那么可靠了，它可以用撞库的方式对其进行反解。 而SHA256作为MD5的加强版，是目前的主流方案。 关于MD5和SHA家族的区别在于使用的加密算法不一样，以及它们生成的hash值长度不同： MD5较SHA家族的hash值要短一些，因此生成速度更快一点 对暴力破解来说，SHA家族的hash值比MD5的hash值更安全，更值得信赖 MD5：128位 SHA1：160位 SHA256：256位 如果你的项目安全等级较高，可采用SHA256作为加密方式，其他情况下使用MD5即可。 模块使用 hashlib模块的使用非常简单，总体来说先要生成一个hash对象，然后再填入字节串即可。 首先是普通的使用，以MD5举例： >>> import hashlib >>> m = hashlib.md5(\"hello world\".encode(\"u8\")) >>> m.digest() b'^\\xb6;\\xbb\\xe0\\x1e\\xee\\xd0\\x93\\xcb\"\\xbb\\x8fZ\\xcd\\xc3' 如果对一个大字符串生成hash值，可使用update()方法在原有hash对象基础上进行内容更新： >>> m = hashlib.md5() >>> m.update(\"line1\".encode(\"u8\")) >>> m.update(\"line2\".encode(\"u8\")) >>> m.update(\"line3\".encode(\"u8\")) >>> m.digest() b'\\xcc\\x0c\\x81\\xcdsha256的加密方式与md5的加密使用相同，如下所示： >>> m = hashlib.sha256(\"hello world\".encode(\"u8\")) >>> m.digest() b\"\\xb9M'\\xb9\\x93M>\\x08\\xa5.R\\xd7\\xda}\\xab\\xfa\\xc4\\x84\\xef\\xe3zS\\x80\\xee\\x90\\x88\\xf7\\xac\\xe2\\xef\\xcd\\xe9\" 基本使用就介绍完毕了，是不是非常简单呢？ 撞库介绍 在密码破解领域，有一个百试不爽的方法就是撞库破解。 撞库是指通过一个庞大的数据库来记录未加密字符串与加密后的值的一种映射关系，理论上来说只要这个数据库无限大，那么生成的hash值都能在这里找到其对应的生成字符串。 举个例子： 我现在有1个字符串，I LOVE YOU。 对他进行hash加密得到的结果假设为3242。 现在将这个对应关系放到数据库中，及3242这个hash值对应的字符串为I LOVE YOU。 如果有人要对3242进行反解，通过查询数据库即可知道结果。 这个思路非常的简单粗暴，但个人是不可能进行数据库的完善和搭建。 在Google上如果搜索MD5反解，应该能找到一些撞库网站，但大多数都是付费的，如果感兴趣可以试一试。 加盐验证 为了防止你的加密内容被撞库反解，我们可以使用加盐的策略来对已加密的内容进行二次加密。 整体思路如下，我们以一个普通的用户登陆作为案例： Server端有一个固定的字符串，被称之为盐 用户第一次注册后，要将用户名和密码写入到数据库中，此时数据库中的密码应当密文存储，且不可被反解，做到仅有用户知道自己的密码，连开发人员都不得而知的状态是最完美的 存储密码的时候，对明文密码进行hash加密，并在其中掺盐，得到密文hash密码进行存储 用户登陆的时候，将用户登陆时发送的明文密码也进行hash加密和掺盐，并且通过登陆的用户名获取到存储在数据库中的密文hash密码，两者进行比对，若一致则登陆成功，若不一致则登陆失败 当数据库被黑客攻破后，只要保证盐不泄露，那么他就没有任何办法破解出用户的密码 理论很复杂，实操很简单。如下所示： >>> salt = \"slat\".encode(\"u8\") >>> userPwd = \"123456\".encode(\"u8\") >>> hashObject = hashlib.md5(salt) # ❶ >>> hashObject.update(userPwd) # ❷ >>> savePwd = hashObject.digest() # ❶ >>> savePwd b'ELr\\x05\\x14$z=\\x1d\\x19(^4L>n' >>> >>> >>> reLoginPwd = \"123456\".encode(\"u8\") >>> hashObject = hashlib.md5(salt) # ❶ >>> hashObject.update(reLoginPwd)　 # ❷ >>> getPwd = hashObject.digest() # ❸ >>> getPwd == savePwd # ❹ True ❶：加盐 ❷：加入用户内容 ❸：获得存储密码 ❹：对比用户重登陆的密码hash值是否和以存储的密码hash值一致 文件校验 在Server端对Client端发送文件的过程中，该文件可能被黑客截取做出一些篡改，如下所示： server端 ---------> client端 | | 可能被黑客窃取，修改下载文件 此时就需要使用文件校验来确保安全性了： 在发送文件的时候要让用户知道我们文件本身的hash校验值 用户下载完成后将得出的结果与我们的hash校验值做对比 如果一致则文件没有被篡改过 如果不一致则文件已被篡改过 我们有2种方式，来进行文件校验的实现。 下面将采用模拟Server端生成文件校验hash值的整个过程。 首先是方式1，将文件所有内容hash校验一遍，安全系数最高，速度最慢。 res = \"\" m = hashlib.sha256() f = open(file=\"test.txt\",mode=\"rb\") while 1: temp = f.read(1024) # ❶ m.update(temp) # ❷ if not len(temp): f.close() hash_res = m.hexdigest() # ❸ break print(hash_res) # 48dd13d8629b4a15f791dec773cab271895187a11683a3d19d4877a8c256cb70 ❶：更新hash值 ❷：由于打开文件的模式是rb，故temp本身就是bytes类型，所以不用encode() ❸：当所有内容读取完毕后，生成文件的校验hash值 其次是方式2，文件指定指针点来更新hash值，安全系数小幅度降低，但速度大幅度提升。 迅雷等下载软件均采用此种方式，前提是要让用户知道我们seek()的文件指针点在哪里: m = hashlib.sha256() f = open(file=\"1.txt\",mode=\"rb\") # ❶ f.seek(20,0) temp = f.read(10) m.update(temp) # ❷ f.seek(20,1) temp = f.read(10) m.update(temp) # ❸ f.seek(-20,2) temp = f.read(10) m.update(temp) # ❹ hash_res = m.hexdigest() print(hash_res) # daffa21b2be95802d2beeb1f66ce5feb61195e31074120a605421563f775e360 ❶：在文件的开始位置，读取10个bytes，用作生成hash值的源内容部分 ❷：在文件的中间位置，读取10个bytes，用作生成hash值的源内容部分 ❸：在文件的末尾位置，读取10个bytes，用作生成hash值的源内容部分 ❹：生成文件校验的hash值，该hash值共由30个bytes组成，分别来自文件的开始、中间、末尾位置。Ps：指针点越多，安全性越高，但是速度越慢 hmac模块 hmac模块的使用与hashlib大同小异。但是在某些方面会比hashlib更优秀： 它也是一个内置模块，以下是简单的使用： >>> import hmac >>> hmacObject = hmac.new(\"hello world\".encode(\"u8\"), digestmod=\"md5\") >>> hmacObject.update(\"salt\".encode(\"u8\")) >>> hashValue = hmacObject.digest() >>> hashValue b'\\xf3Q\\xff\\xb2V{\\x88\\xfe\\x0e\\x9aX\\x19\\xbf\\x12\\xf3>> 另外，还有一个compare_digest()方法，放入2个bytes类型，用于判断他们的值是否一致。 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:46 "},"Python/Python模块与包/configparser.html":{"url":"Python/Python模块与包/configparser.html","title":"内置模块：configparser","keywords":"","body":"configparser简介 configparser模块是Python的内置模块，提供了配置文件创建、解析、修改等功能。 官方文档 值得注意的是，在Python2中，它的命名是驼峰式的，为ConfigParser。 认识配置文件 配置文件常以.ini或者.cfg作为后缀，注释方式有2种。 #注释与;注释，一个配置项是以键值对方式进行存储，通过:或者=分割。 [regulator] user_name : Yunya age = 21 sex = male is_admin = true salary = 20 [path] RUN_LOG_FILE = log/run.log $true ERROR_LOG_FILE = log/error.log $true 如果某一个配置项后面加上了$true，则$true在解析的时候将被替换为BASE_DIR，也就说该$true会被替换为完整的路径。 我个人喜欢将一个配置文件分成3部分，尽管下面的叫法并不是非常的正确： 配置项分类（classify）：以[]包裹的数据项，或者称为block 配置项的键（key）：:或者=左边的数据项 配置项的值（value）：:或者=右边的数据项 字典一样操作 configparser模块能够让配置文件像字典一样进行操作。 下面介绍3个该模块提供的基本方法： 方法 描述 ConfigParser() 创建文档对象 documentObject.read(filenames, encoding=None) 读取配置文件 documentObject.write(fp) 将文档对象写入磁盘 如下示例，对配置文件进行读取： import configparser # 创建文档对象，并且读取配置文件 documentObject = configparser.ConfigParser() documentObject.read(filenames=\"./config.ini\", encoding=\"u8\") # 获取所有classify classifyAllTuple = tuple(documentObject.items()) # 获取所有的key和value for classify in documentObject.values(): print(dict(classify.items())) # 获取指定classify下的指定key的value # 需要自己做类型转换 userAge = documentObject[\"regulator\"][\"age\"] print(int(userAge)) 新增一个配置文件，先创建一个空的文档对象，然后加入一些子字典，将他看做嵌套字典，最后进行写入磁盘即可： import configparser # 先创建一些classify以及kev-value配置项 defaultClassify = { \"ip\": \"0.0.0.0\", \"port\": 65535, } serverClassify = { \"ip\": \"192.168.0.120\", \"port\": 65536, } loginClassify = { \"user\": \"root\", \"password\": \"123456\", \"db\": 1, \"verify\": False, } # 创建一个空文档对象 noneDocumentObject = configparser.ConfigParser() # 为这个空文档对象，添加classify，将它看成字典操作即可 noneDocumentObject[\"DEFAULT\"] = defaultClassify noneDocumentObject[\"SERVER\"] = serverClassify noneDocumentObject[\"LOGIN\"] = loginClassify # 将文档对象写入到磁盘 with open(file=\"./newConfig.ini\", mode=\"wt\", encoding=\"utf8\") as f: noneDocumentObject.write(fp=f) 修改一个配置项，对字典中的value进行更新。最后将文档对象写入到磁盘： import configparser # 创建文档对象，并且读取配置文件 documentObject = configparser.ConfigParser() documentObject.read(filenames=\"./config.ini\", encoding=\"u8\") # 修改regulator下的age为30岁，注意这里必须为str类型 documentObject[\"regulator\"][\"age\"] = \"30\" # 写入磁盘 with open(\"./config.ini\", mode=\"wt\", encoding=\"utf8\") as f: documentObject.write(fp=f) 读取配置文件 configparser模块此外也为文档对象提供了一些专用的方法，来操作配置文件。 如下所示： 方法 描述 sections(self) 拿到所有的classify options(self, section) 指定一个classify，拿到其下所有的key items(self, section=_UNSET, raw=False, vars=None) 指定一个classify，拿到其下所有的key和value get(self, section, option) 指定classify和key，拿到具体的value，并将其转换为Python中的str类型 getint(self, section, option) 指定classify和key，拿到具体的value，并将其转换为Python中的int类型 getfloat(self, section, option) 指定classify和key，拿到具体的value，并将其转换为Python中的float类型，保留1位小数 getboolean(self, section, option) 指定classify和key，拿到具体的value，并将其转换为Python中的bool类型 示例演示： import configparser # 初始化文档对象，并且读取配置文件 documentObject = configparser.ConfigParser() documentObject.read(filenames=\"./config.ini\", encoding=\"utf8\") # 获取配置文件中所有的classify allClassify = documentObject.sections() print(allClassify) # ['regulator', 'path'] # 获取classify（regulator）下所有的key regulatorKeys = documentObject.options(section=allClassify[0]) print(regulatorKeys) # ['user_name', 'age', 'sex', 'is_admin', 'salary'] # 获取classify(regulator)下所有的键值对 regulatorItems = documentObject.items(section=allClassify[0]) print(regulatorItems) #　[('user_name', 'Yunya'), ('age', '21'), ('sex', 'male'), ('is_admin', 'true'),('salary', '20')] # 获取classify(regulator)下的key(user_name)对应的value # get()会自动将value转换为str类型 name = documentObject.get(section=allClassify[0], option=\"user_name\") print(name) # Yunya # 获取classify(regulator)下的key(age)对应的value # getint()会自动将value转换为int类型 age = documentObject.getint(section=allClassify[0], option=\"age\") print(age) # 21 # 获取classify(regulator)下的key(is_admin)对应的value # getboolean()会自动将value转换为bool类型 isAdimin = documentObject.getboolean(section=allClassify[0], option=\"is_admin\") print(isAdimin) # True # 获取classify(regulator)下的key(salary)对应的value # getfloat()会自动将value转换为float类型，并保留一位小数 salary = documentObject.getfloat(section=allClassify[0], option=\"salary\") print(salary) # 20.0 修改配置文件 configparser模块也提供了一些修改配置文件的方法。 如下表所示，但我很少会使用到，所以不再进行案例书写了： 方法 描述 add_section(self, section) 向文档对象中增加一个classify set(self, section, option, value=None) 设置或添加文档对象的键值对 remove_section(self, section) 删除文档对象中的的一个classify remove_options(self, section, option) 删除文档对象中的一组键值对 has_section(self, section) 判断文档对象中的一个classify是否存在 has_options(self, section, option) 判断文档对象中的一个key是否存在 个人更加倾向于通过字典的方式操纵文档对象。 特殊的DEFAULT 配置文件中有1个名为DEFAULT的classify，它提供了一些默认设置。 如果你的配置文件中没有显式的配置DEFAULT这个classify，则通过字典操作任然会获取到到它。但是若通过方法进行操作，该classify则不会出现。 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:46 "},"Python/Python模块与包/subprocess.html":{"url":"Python/Python模块与包/subprocess.html","title":"内置模块：subprocess","keywords":"","body":"subprocess简介 subprocess模块最早在Python2.4中引入，它会生成一个子进程，该子进程可以执行shell命令，并且会监听系统的标准输入管道、标准输出管道、标准错误管道，在命令执行完毕后，将结果进行返回到对应的管道中。 官方文档 如下图所示： 它的功能虽然看上去十分单一，但是应用是非常广泛的。 试想，你是一名运维人员，编写了1个脚本，每天定时定点的在100台机器上获得它们的状态信息，就可以用到该模块。 让脚本在宿主机上通过该模块执行命令，并且拿到命令的返回结果，再通过网络返回结果并对其进行分析，依此判定各个宿主机的工作状态。 简单的使用 对于简单的使用，记住这4个方法即可，如下表所示： 方法 描述 subprocess.Popen(...) 执行系统命令，并将执行结果放入对应的管道中，返回一个Popen对象 PopenObject.stdout.read() 从标准输出管道中获取执行结果 PopenObject.stderr.read() 从标准错误管道中获取执行结果 PopenObject.stdin.write() 通过标准输入管道与系统进行交互 subprocess.Popen()的可指定参数比较多，下面是它的签名： def __init__(self, args, bufsize=-1, executable=None, stdin=None, stdout=None, stderr=None, preexec_fn=None, close_fds=_PLATFORM_DEFAULT_CLOSE_FDS, shell=False, cwd=None, env=None, universal_newlines=False, startupinfo=None, creationflags=0, restore_signals=True, start_new_session=False, pass_fds=(), *, encoding=None, errors=None): 常用参数的释义如下： args：将要执行的命令，可以是str类型或者list、tuple类型 bufsize：指定缓冲大小，0是没有，1是默认 executable：要执行的替换程序 stdin/stdout/stderr：标准输入、输出、错误管道的句柄 preexec_fn：仅在Unix平台下有效。指定一个可调用对象，通常是指函数，它将在fork出的子程序运行之前调用 close_sds：在Windows平台下，如果该参数指定为True，则fork出的子程序将不会继承父程序的标准输入、输出、错误管道中传输的内容，一般设置默认即可 shell：如果为True，则通过shell执行命令 cwd：设置子进程执行时的工作目录 env：用于指定子进程的环境变量，如果为None，子进程将继承父进程的环境变了 Universal_newlines：如果为True，则不区分平台，统一将换行符定义为\\n 简单的执行命令并获取返回结果： import subprocess popenObject = subprocess.Popen( args=\"ping www.baidu.com\", shell=True, stdin=subprocess.PIPE, stderr=subprocess.PIPE, stdout=subprocess.PIPE, ) successMessage, errorMessage = popenObject.stdout.read(), popenObject.stderr.read() print(successMessage.decode(\"gbk\")) print(errorMessage.decode(\"gbk\")) popenObject.stdout.close() popenObject.stderr.close() 注意事项： 如果你的测试环境是Windows，则对执行结果的解码方式需要使用GBK，因为Windows的终端字符编码方式就是GBK。而如果是Unix平台只需要使用UTF8即可。 通过stdin与与宿主机进行交互： import subprocess # 执行的语句 stdInCommand = \"\"\"print (\\\"Hello, world\\\")\"\"\" # 通过subprocess在测试机上启动1个新的Python REPT交互式环境 popenObject = subprocess.Popen( args=\"python\", shell=True, stdin=subprocess.PIPE, stderr=subprocess.PIPE, stdout=subprocess.PIPE, ) # 写入内容，进行交互，注意每次交互完毕后都要立即关闭管道 popenObject.stdin.write(stdInCommand.encode(\"utf8\")) popenObject.stdin.close() # 获取并打印结果 successMessage, errorMessage = popenObject.stdout.read(), popenObject.stderr.read() print(successMessage.decode(\"gbk\")) print(errorMessage.decode(\"gbk\")) popenObject.stdout.close() popenObject.stderr.close() 更多的操作 以下方法了解即可，其实用的并不多： 方法 描述 subprocess.run() 执行命令，不返回结果，拥有timeout参数，可设定超时时间 subprocess.call() 执行命令，并且返回执行状态（bool类型，0成功，1失败） subprocess.check_call() 执行命令，并且返回执行结果和执行状态，如果命令执行失败则抛出异常， subprocess.getstatusoutput() 执行命令，返回1个tuple，[0]是执行状态，[1]是执行结果 subprocess.getoutput() 执行命令，返回执行结果（str类型） subprocess.check_output() 执行命令，返回执行结果（bytes类型） 这里就不再进行演示了，感兴趣的可以参见官方文档。 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:46 "},"Python/Python模块与包/logging.html":{"url":"Python/Python模块与包/logging.html","title":"内置模块：logging","keywords":"","body":"logging简介 Python内置模块logging提供了日志记录相关功能，是一款非常强大且常用的模块。 官方文档 它的使用如果刨根问底可能比较复杂，所以里仅介绍1种最方便的使用方式，其他的使用方式日常开发中基本不会用到，故不进行介绍。 简单了解 logging模块中规定日志拥有6个级别，每个级别都有单词、数字2种表现形式，如下表所示： level number 描述 logging.critical 50 致命错误 logging.error 40 常规错误 logging.warning 30 警告信息 logging.info 20 普通信息 logging.debug 10 调试信息 logging.NOSET 0 ... logging.NOSET一般不会进行使用，所以你也可以认为logging的日志级别只有5个。 等级越低，越能看到更多的日志信息，它会根据等级依次向上推进，如下图所示： 默认的等级是30，也就是warning级别，仅能看到critical、error、warning这个级别的日志，而info和debug则看不见。 如下所示： import logging logging.debug(\"debug\") logging.info(\"info..\") logging.warning(\"warning..\") logging.error(\"error..\") logging.critical(\"critical..\") # ❶ ❷ # WARNING:root:warning.. # ERROR:root:error.. # CRITICAL:root:critical.. ❶：root指的是记录日志的用户，默认就是root ❷：默认的日志输出位置是向屏幕，也可以将日志输出至文件 配置文件 如果想快速的使用logging模块进行日志记录。 可以使用配置文件的形式，一般来说该配置文件会存放至settings.py中： import os # 定义2种日志记录格式 # 标准的：standard_format # 简单的：simple_format standard_format = \"[%(asctime)s][%(threadName)s:%(thread)d][username:%(name)s][%(filename)s:%(lineno)d]\" \\ \"[%(levelname)s][%(message)s]\" simple_format = \"[%(levelname)s][%(asctime)s][%(filename)s:%(lineno)d]%(message)s\" # 定义日志存放路径 LOG_DIR = os.path.dirname(os.path.abspath(__file__)) if not os.path.isdir(os.path.join(LOG_DIR, \"log\")): os.mkdir(os.path.join(LOG_DIR, \"log\")) LOG_PATH = os.path.join(LOG_DIR, \"log\", \"run.log\") # LOGGING的应用配置字典，无需太大改动，开箱即用 LOGGING_SETTING = { \"version\": 1, \"disable_existing_loggers\": False, # 添加2种日志记录格式 \"formatters\": { \"standard\": { \"format\": standard_format }, \"simple\": { \"format\": simple_format }, }, # 控制流相关配置 \"handlers\": { # 输出到终端(logging.StreamHandler)，采用简单的日志记录格式 \"screen\": { \"level\": \"DEBUG\", \"class\": \"logging.StreamHandler\", \"formatter\": \"simple\" }, # 输出到文件(logging.handlers.RotatingFileHandler)，采用标准的日志记录格式 \"file\": { \"level\": \"DEBUG\", \"class\": \"logging.handlers.RotatingFileHandler\", \"formatter\": \"standard\", # 日志文件位置及名称，若不指定则默认在当前目录下 \"filename\": LOG_PATH, # 每个日志文件最大5M，当存在5个日志文件后开启日志轮转 \"maxBytes\": 1024*1024*5, \"backupCount\": 5, \"encoding\": \"utf-8\", }, }, # 定义不同用户采用的控制流 \"loggers\": { # 如果不指定用户，或指定用户未在loggers字典中，则采用该配置 \"\": { \"handlers\": [\"screen\", \"file\"], # 以控制流相关配置中过滤级别为准，这里是1次过滤，控制流中是2次过滤 \"level\": \"DEBUG\", # 关闭日志冒泡，切勿手动更改 \"propagate\": False, }, # 若指定用户为testUser，则采用该配置 \"testUser\": { \"handlers\": [\"screen\"], \"level\": \"DEBUG\", \"propagate\": False, } } } 项目应用 如何使用该配置文件？我们假设项目目录如下： Project/ |-- bin/ | |-- run.py # 启动脚本 | |-- view/ | |-- main.py # 主程序 | |-- common.py # 公用模块 |-- settings.py # logging配置文件 首先是启动脚本： # bin/run.py import os import sys sys.path.append( os.path.dirname(os.path.dirname(__file__)) ) from view.main import main if __name__ == \"__main__\": main() 其次是主程序： # view/main.py from common import logger def main(): logger.debug(\"debug\") logger.info(\"info..\") logger.warning(\"warning..\") logger.error(\"error..\") logger.critical(\"critical..\") 最后是公用模块： # common.py from logging import config from logging import getLogger from settings import LOGGING_SETTING config.dictConfig(LOGGING_SETTING) logger = getLogger(\"adminstartion\") 可以看到在公用模块中导入了配置字典，并且将它应用进了logging模块。 然后获取了一个日志对象logger，在以后使用时都使用这个logger进行日志记录即可，这里getLogger()的用户名是adminstartion，未定义在LOGGIN_SETTING的loggers中，故会采用第一个配置，也就是下面这个： \"loggers\": { # 如果不指定用户，或指定用户未在loggers字典中，则采用该配置 \"\": { \"handlers\": [\"screen\", \"file\"], \"level\": \"DEBUG\", \"propagate\": False, }, ... } Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:46 "},"Python/Python模块与包/re.html":{"url":"Python/Python模块与包/re.html","title":"内置模块：re","keywords":"","body":"re简介 正则表达式其本身就是一种小型的，高度专业化的编程语言。 在Python中，它被内嵌在了re模块里面，正则表达式模式被编译成一系列的字节码，然后由用C编写的匹配引擎执行。 官方文档 本文仅针对可能用到的方法进行描述，对不常用的方法等进行了筛选。 方法一览 符号大全 以下是正则表达式的符号大全： 符号 中文名称 释义 . 通配符 匹配除\\n之外的任意字符，如果想匹配\\n可更换匹配模式为re.S或re.DOTALL ^ 开始符 匹配以特定字符开始的字符串，在检测时只会检测开头第一个字符并立即返回结果 $ 结束符 匹配以特定字符结尾的字符串，在检测时只会检测结尾最后一个字符并立即返回结果 * 可有重复符 代表可以取0-∞位*号前面的字符（默认贪婪取值，可通过?取消贪婪模式） + 必有重复符 代表可以取1-∞位+号前面的字符（默认贪婪取值，可通过?取消贪婪模式） ? 单一重复符 代表可以取1-∞位?号前面的字符（默认贪婪取值，可通过?取消贪婪模式） {n,m} 范围重复符 代表可以取到n-m位{n,m}前面的字符（默认贪婪取值，可通过?取消贪婪模式） {n} 精确重复符 代表可以精确取到n位{n}前面的字符 [] 字符集 在[]中多个字符仅能匹配到1个，并且字符集中所有符号失去特殊意义，仅有- ^ \\ 这3个符号在字符集中具有特殊意义 [-] 区间符 字符集中的-号代表可以取从多少到多少区间的值，按照ASCII码排序，比如[a-z0-9A-Z]代表这1位取全部的英文字母和数字 排除符 字符集中的^号代表非的作用，比如[^0-9]代表这1位并非是数字 [\\] 转义符 转义符如果在字符集中使用，可以为特定的字符赋予特殊的意义 \\ 转义符 转义符如果在字符集外使用，可以为特定的字符赋予特殊的意义，并且还可以让特定的字符失去特殊的意义，但是如果未用r原始字符串进行正则匹配，则可能会导致令人意外的情况发生 \\d ... 匹配任何十进制数，它相当于在字符集中使用[0-9] \\D ... 匹配任何非十进制数，它相当于在字符集中使用[^0-9] \\s ... 匹配任何空白字符，它相当于在字符集中使用[\\t\\n\\r\\f\\v] \\S ... 匹配任何非空白字符，它相当于在字符集中使用[^\\t\\n\\r\\f\\v] \\w ... 匹配任何字母数字下划线字符,它相当于在字符集中使用[a-z A-Z 0-9] \\W ... 匹配任何非字母数字下划线字符,它相当于在字符集中使用[a-z A-Z 0-9] \\b ... 匹配一个特殊字符边界，比如空格,&.#等(不常用) 管道符 相当于或，注意与字符集里的区别，管道符将前后分为2段，左右看做1个整体，而字符集中的或仅仅代表从众多选项中拿出1个 () 分组符 将多个元素字符看做一个整体，也就是将它们当做一个元素字符进行匹配，若整个匹配规则中无子分组，则默认的匹配结果为一组 (?=exp) 零宽先行断言 匹配后面为exp的内容 (? 零宽后行断言 匹配前面为exp的内容 (?!exp) 零宽负向先行断言 匹配后面不能是exp的内容 (? 零宽负向后行断言 匹配前面不能是exp的内容 匹配方法 以下是re模块提供的正则匹配方法： 方法 描述 findall() 将所有的匹配结果返回至1个列表中 finditer() 将所有的匹配结果返回至1个迭代器中 search() 将首次匹配的结果返回至search对象中，可通过group()进行取值 match() 在search()基础上添加了^，使之只能在开头匹配 group() 通过该方法对search对象进行取值操作，返回一个或者多个匹配的子组 groups() 通过该方法对search对象进行取值操作，返回一个元组，包含所有匹配的子组 groupdict() 通过该方法对search对象进行取值操作，返回一个字典，包含了所有的具名子组 split() 对字符串进行分割，其算法可能导致令人意外的情况发生 sub() 对字符串进行替换，最少需要3个参数，返回一个新的字符串 subn() 对字符串进行替换，最少需要3个参数，返回一个元祖，其中包含了替换成功了几次 complie() 可以将一个标示符赋予指定的规则，达到简化重复操作的目的 匹配模式 以下是re模块提供的正则匹配模式： 模式简写 模式全写 描述 re.I re.IGNORECASE 不分大小写字母的匹配模式 re.M re.MULTILINE 视为多行的匹配模式，以\\n作为行分割符 re.S re.DOTALL 视为单行的匹配模式，即通配符可以匹配\\n re.U re.UNICODE 宽字符匹配模式，即支持匹配占4个字符的UTF-16匹配模式 创建正则 re.findall() 在测试阶段，我们大部分示例都会使用re.findall()方法进行测试。 它的函数签名如下： def findall(pattern, string, flags=0): 参数释义： pattern：匹配规则 string：被匹配字符串 flags：匹配模式 一次简单的使用，匹配以hello开头且以exp结尾的子串，采用多行匹配模式： import re string = \"hello world\\nhello regexp\\nhello python\\n\" resultList = re.findall( pattern=r\"^hello.*exp$\", string=string, flags=re.M ) print(resultList) # ['hello regexp'] 基础符号 . 通配符 .通配符会匹配除\\n之外的任意字符，如果想匹配\\n可更换匹配模式为re.S或re.DOTALL。 如下示例，匹配11个除开\\n之外的任意字符组成的子串： import re rule = \".\" * 11 string = \"hello world\\n123456abcdeABCDE\" resultList = re.findall(pattern=rule, string=string) print(resultList) # ['hello world', '123456abcde'] ^ 开始符 ^开始符会匹配以特定字符开始的字符串，在检测时只会检测开头第一个字符并立即返回结果。 如下示例，匹配以P开头且后面必须是ython加上7个除开\\n的任意字符的子串： import re rule = \"^Python.......\" string = \"Python regexp module\" resultList = re.findall(pattern=rule, string=string) print(resultList) # ['Python regexp'] $ 结束符 $结束符会匹配以特定字符结尾的字符串，在检测时只会检测结尾最后一个字符并立即返回结果。 如下所示，匹配以p结束，且前面2个字符必须是E与x的子串，区分大小写： import re rule = \"Exp$\" string = \"Python regexp regExp RegExp\" resultList = re.findall(pattern=rule, string=string) print(resultList) # ['Exp'] 重复符 * 可有重复 *代表可以取0-∞位*号前面的字符（默认贪婪取值，可通过?取消贪婪模式） 如下示例，匹配必须是以h开头，后面可以有0个也可以有多个除了\\n外的任意字符，紧接着\\n后继续匹配0个或者n个除了\\n外的任意字符，最后必须以p进行结尾的子串： import re rule = \"^h.*\\n.*p$\" string = \"hello Python\\nregexp\" resultList = re.findall(pattern=rule, string=string) print(resultList) # ['hello Python\\nregexp'] 上面这个示例，有3个条件是必须的。 h开头 中间必须有\\n p结束 所以下面这个字符串也会被匹配到： string = \"h\\np\" + 必有重复 +代表可以取1-∞位+号前面的字符（默认贪婪取值，可通过?取消贪婪模式） 如下示例，匹配必须是以h开头，后面可以有1个也可以有多个除了\\n外的任意字符，紧接着\\n后继续匹配1个或者n个除了\\n外的任意字符，最后必须以p进行结尾的子串： import re rule = \"^h.+\\n.+p$\" string = \"hello Python\\nregexp\" resultList = re.findall(pattern=rule, string=string) print(resultList) # ['hello Python\\nregexp'] 上面这个示例，有5个条件是必须的： h开头 h后面必须至少有1个任意字符 中间必须有\\n \\n后面必须至少有1个任意字符 p结束 所以下面这个字符串不会被匹配到： string = \"h\\np\" ? 单一重复 ?代表可以取1-∞位?号前面的字符（默认贪婪取值，可通过?取消贪婪模式） 如下示例，匹配可以是1开头，也可以不是1开头且后面是2345678且以9结尾的字符串： import re rule = \"^1?23456789$\" string = \"123456789\" resultList = re.findall(pattern=rule, string=string) print(resultList) # ['123456789'] 上面这个示例，有2个条件是必须的： 字符串的开头如果不是1，则必须是2 后面必须跟上345678，且以9结尾 所以下面这个字符串也会被匹配到： string = \"23456789\" {n,m} 区间重复 {n,m}代表可以取到n-m位{n,m}前面的字符，（默认贪婪取值，可通过?取消贪婪模式） 如下示例，匹配包含4个或者3个连续是1的子串： import re rule = \"1{3,4}\" string = \"1111111\" resultList = re.findall(pattern=rule, string=string) print(resultList) # ['1111', '111'] {n} 精确重复 {n}代表可以精确取到n位{n}前面的字符。 如下示例，匹配包含3个连续的1的子串： import re rule = \"1{3}\" string = \"1111111\" resultList = re.findall(pattern=rule, string=string) print(resultList) # ['111', '111'] 取消贪婪匹配 默认的*，+，?，{n,m}都是贪婪取值。 即有多个就取多个，没有多个才少取。 在它们后面加上?即可取消贪婪匹配，如下示例： import re ruleList = [ # 取0个或者多个a，取消贪婪后取0个 \"a*?\", # 取1个或者多个a，取消贪婪后取1个 \"a+?\", # 取0个或者1个a，取消贪婪后取0个 \"a??\", # 取3个或者4个a，取消贪婪后取3个 \"a{3,4}\" ] string = \"a\" * 7 for rule in ruleList: resultList = re.findall(pattern=rule, string=string) print(resultList) # ['', '', '', '', '', '', '', ''] # ['a', 'a', 'a', 'a', 'a', 'a', 'a'] # ['', '', '', '', '', '', '', ''] # ['aaaa', 'aaa'] 字符集 [] 字符集 在[]中多个字符仅能匹配到1个，并且字符集中所有符号失去特殊意义，仅有- ^ \\ 这3个符号在字符集中具有特殊意义。 如下示例，匹配包含1a或者2a或者3a的子串： import re rule = \"[123]a\" string = \"1a2a3a1b2b3b\" resultList = re.findall(pattern=rule, string=string) print(resultList) # ['1a', '2a', '3a'] [-]区间符 字符集中的-号代表可以取从多少到多少区间的值，按照ASCII码排序，比如[a-z0-9A-Z]代表这1位取全部的英文字母和数字。 如下示例，匹配所有由连续的字母或者数字组成的子串： import re rule = \"[0-9A-Za-z]+\" string = \"1b23c4d\\n2342bbc\" resultList = re.findall(pattern=rule, string=string) print(resultList) # ['1b23c4d', '2342bbc'] [^] 排除符 字符集中的^号代表非的作用，比如[^0-9]代表这1位并非是数字。 如下所示，匹配结尾不为数字的子串，匹配模式为多行匹配： import re rule = \".+[^0-9]$\" string = \"abc\\n12x\\n345\" resultList = re.findall(pattern=rule, string=string, flags=re.M) print(resultList) # ['abc', '12x'] [\\]转义符 转义符如果在字符集中使用，可以为特定的字符赋予特殊的意义。 如下所示，\\w是具有特殊意义的字符，作用是匹配字母数字下划线字符。 它可以在字符集中使用： import re rule = \"[\\w]+\" string = \"abc\\n12x\\n345\" resultList = re.findall(pattern=rule, string=string, flags=re.M) print(resultList) # ['abc', '12x', '345'] 转义字符 \\ 转义符 转义符如果在字符集外使用，可以为特定的字符赋予特殊的意义，并且还可以让特定的字符失去特殊的意义，但是如果未用r原始字符串进行正则匹配，则可能会导致令人意外的情况发生。 如，失去特殊意义： .本来是通配符，如果是\\.就是普通的.，再也没有任何意义了。 如下示例，匹配一个url： import re rule = \"w{3}\\.\\w+\\.com\" string = \"www.google.com www.biying.com\" resultList = re.findall(pattern=rule, string=string) print(resultList) # ['www.google.com', 'www.biying.com'] 以下是常用加上\\后就拥有特殊意义的字符： 符号 中文名称 释义 \\d ... 匹配任何十进制数，它相当于在字符集中使用[0-9] \\D ... 匹配任何非十进制数，它相当于在字符集中使用[^0-9] \\s ... 匹配任何空白字符，它相当于在字符集中使用[\\t\\n\\r\\f\\v] \\S ... 匹配任何非空白字符，它相当于在字符集中使用[^\\t\\n\\r\\f\\v] \\w ... 匹配任何字母数字下划线字符,它相当于在字符集中使用[a-z A-Z 0-9] \\W ... 匹配任何非字母数字下划线字符,它相当于在字符集中使用[a-z A-Z 0-9] \\b ... 匹配一个特殊字符边界，比如空格,&.#等(不常用) \\d和\\D \\d可以匹配任何十进制数，它相当于在字符集中使用[0-9]： import re rule = \"\\d+\" string = \"123 abc 1a2b3c\" resultList = re.findall(pattern=rule, string=string) print(resultList) # ['123', '1', '2', '3'] \\D可以匹配任何非十进制数，它相当于在字符集中使用[^0-9]： import re rule = \"\\D+\" string = \"123 abc 1a2b3c\" resultList = re.findall(pattern=rule, string=string) print(resultList) # [' abc ', 'a', 'b', 'c'] \\s和\\S \\s可以匹配任何空白字符，它相当于在字符集中使用[\\t\\n\\r\\f\\v]： import re rule = \"\\s\" string = \"123 abc 1a2b3c\" resultList = re.findall(pattern=rule, string=string) print(resultList) # [' ', ' '] \\S匹配任何非空白字符，它相当于在字符集中使用[^\\t\\n\\r\\f\\v]： import re rule = \"\\S\" string = \"123 abc 1a2b3c\" resultList = re.findall(pattern=rule, string=string) print(resultList) # ['1', '2', '3', 'a', 'b', 'c', '1', 'a', '2', 'b', '3', 'c'] \\w和\\W \\w可以匹配任何字母数字下划线字符,它相当于在字符集中使用[a-z A-Z 0-9]： import re rule = \"\\w+\" string = \"user_name123 \\t\\n\\f\" resultList = re.findall(pattern=rule, string=string) print(resultList) # ['user_name123'] \\W可以匹配任何非字母数字下划线字符,它相当于在字符集中使用[a-z A-Z 0-9]： import re rule = \"\\W+\" string = \"user_name123 \\t\\n\\f\" resultList = re.findall(pattern=rule, string=string) print(resultList) # [' \\t\\n\\x0c'] 原始字符串 下面这种情况，可能导致re匹配的结果和预料的结果不符。 我想匹配1个\\或者\\d： import re rule = \"[\\\\d]\" string = \"123\\\\456\\\\\" resultList = re.findall(pattern=rule, string=string) print(resultList) # ['1', '2', '3', '4', '5', '6'] 是什么原因导致了这样的情况？由于re模块建立在Python解释器之上，所以\\\\d会被分解成\\d，故会出现这样的情况。如下图所示： 如何解决这个问题呢？你可能想使用这个匹配规则： rule = \"[\\\\\\\\d]\" 但是这样的匹配结果是： ['\\\\', '\\\\'] d被当成了单独的普通匹配字符了。 其实最有效的办法是对rule采用原始字符串处理： import re rule = r\"[\\\\\\d]\" string = \"123\\\\456\\\\\" resultList = re.findall(pattern=rule, string=string) print(resultList) # ['1', '2', '3', '\\\\', '4', '5', '6', '\\\\'] 所以无论今后在什么场合下，对于rule都使用原始字符串定义就ok了。 管道 | 管道符 |管道符相当于或，注意与字符集里的区别，管道符将前后分为2段，左右看做1个整体，而字符集中的或仅仅代表从众多选项中拿出1个。 如下所示，匹配abc123或者456xyz的子串： import re rule = r\"abc123|456xyz\" string = \"abcdefgabc123xyzqud456xyz\" resultList = re.findall(pattern=rule, string=string) print(resultList) # ['abc123', '456xyz'] 分组 推荐在分组时，使用re.search()或者re.match()进行操作。 () 分组符 ()分组符将多个元素字符看做一个整体，也就是将它们当做一个元素字符进行匹配。若整个匹配规则中无子分组，则默认的匹配结果为一组： 如下，没有定义子分组，则默认的匹配结果为1组。 因此可通过group(0)方法获取整组内容： import re rule = r\".*\" string = \"hello world\" searchObject = re.search(pattern=rule, string=string) print(searchObject.group(0)) # hello world 匿名分组 匿名分组即没有名字的分组，单纯的用括号包裹即可。 如果定义了子分组，则可以通过groups()方法来查看所有的子分组。 如下所示，定义了3个匿名分组，分别是拿到标签名字，标签内容，标签结束 import re rule = r\"(.*)\" string = \"hello world\" searchObject = re.search(pattern=rule, string=string) print(searchObject.groups()) # ('div', 'hello world', 'div') 具名分组 具名分组的意思是为每一个子分组取一个别名。 语法是(?P\\regexp)，对于具名分组来说，可以使用方法groupdict()来查看分组的名字和分组匹配到的内容。 如下所示，定义了3个具名分组，分别是拿到标签名字，标签内容，标签结束： import re rule = r\"\\w+)>(?P.*)\\1)>\" string = \"hello world\" searchObject = re.search(pattern=rule, string=string) print(searchObject.groupdict()) # {'tagName': 'div', 'tagContext': 'hello world', 'tagEnd': 'div'} 分组引用 没有定义子分组时，整个匹配结果就是1个分组，编号为0. 而定义了子分组后，子分组的编号从1开始，向后排列，如下图所示： 我们可以利用这个索引编号在后面引用前面分组匹配的内容作为后面的匹配规则，语法格式如下： \\编号 示例如下所示： import re rule = r\"(.*)\" string = \"hello world\" searchObject = re.search(pattern=rule, string=string) print(searchObject.groups()) # ('div', 'hello world', 'div') 分组1匹配到什么，后面的\\1的匹配规则就是什么。 如果字符串变成了这个样子就会抛出异常，匹配不到。 因为分组1匹配到的内容是div，所以\\1也只能匹配div： string = \"hello world\" 如果前面分组是1个具名分组，后面也可以通过名字进行引用，语法格式如下： (?P=分组名) 示例如下所示： import re rule = r\"\\w+)>(?P.*)(?P=tagName))>\" string = \"hello world\" searchObject = re.search(pattern=rule, string=string) print(searchObject.groupdict()) # {'tagName': 'div', 'tagContext': 'hello world', 'tagEnd': 'div'} 取消记录 每一个子分组都具有编号，如果想取消某个子分组的编号，则可以使用(?:)来进行分组，若这样做则该子分组不可被后面引用，也不可被获取到，如下示例： import re rule = r\"(.*)\" string = \"hello world\" searchObject = re.search(pattern=rule, string=string) print(searchObject.groups()) # ('hello world',) 可以看见，只有1个子分组。 断言匹配 断言匹配虽然都有1个括号，但它们并不是子分组。 故括号中的内容也不会当做结果进行保持，可以将它们理解为匹配时的条件。 (?=exp) 零宽先行断言匹配后面为exp的内容。 如下示例，匹配后面是world的内容： import re rule = r\".+(?=world)\" string = \"hello world\" searchObject = re.search(pattern=rule, string=string) print(searchObject.group(0)) # hello (? 零宽后行断言，匹配前面为exp的内容。 如下示例，匹配前面是hello的内容： import re rule = r\"(?(?!exp) 零宽负向先行断言，匹配后面不能是exp的内容。 如下示例，匹配hello后面不能是Java的内容： import re rule = r\"hello (?!Java).*\" string = \"hello Java hello Golang hello Python\" searchObject = re.search(pattern=rule, string=string) print(searchObject.group(0)) # hello Golang hello Python (? (? 如下示例，匹配hello前面不能是Golang的内容： import re rule = r\"(?re方法 findall() 将所有的匹配结果返回至1个列表中。 其实说实话这种方法在日常开发中也很少用到，由于直接返回的是1个列表，所以比较占用内存。 import re rule = r\"\\d+\" string = \"123A567\" resultList = re.findall(pattern=rule, string=string) print(resultList) # ['123', '567'] finditer() 将所有的匹配结果返回至1个迭代器中。 finditer()比findall()更节省内存，因此推荐使用。 import re rule = r\"\\d+\" string = \"123A567\" resultIter = re.finditer(pattern=rule, string=string) print(resultIter) # search() 将首次匹配的结果返回至search对象中，可通过group()进行取值。 这个方法是最常用的方法，推荐使用，但是只能返回首次的匹配结果： import re rule = r\"\\d+\" string = \"123A567\" searchObject = re.search(pattern=rule, string=string) print(searchObject) # match() 在search()基础上添加了^，使之只能在开头匹配。 这个方法用到的场景也不多吧，简单介绍一下： import re rule = r\"\\d+\" string = \"123A567\" searchObject = re.match(pattern=rule, string=string) print(searchObject) # group() 通过该方法对search对象进行取值操作，返回一个或者多个匹配的子组。 可以取值的情况： 当没有分组时默认取大组，直接使用group()方法或指定编号0 能对匿名的子组进行取值，输入子组编号即可，子组编号从1开始 能对具名的子组进行取值，输入子组别名即可 我们上面介绍过，默认最大的组就是所有匹配结果，编号为0. 子组编号从1开始向后排列，通过该方法可以取出任意一个分组。 如，没有子组，可以使用group(0)或者直接使用group()取出最大的默认组： import re rule = r\".+\" string = \"123A567\" searchObject = re.search(pattern=rule, string=string) print(searchObject.group()) # 123A567 如果有多分组，则可以指定1个或者多个子组的编号，将它们取出来： import re rule = r\"(\\d+)([A-Z])(\\d+)\" string = \"123A567\" searchObject = re.search(pattern=rule, string=string) print(searchObject.group(0, 1, 2, 3)) # ('123A567', '123', 'A', '567') 如果有具名分组，则可以指定分组名将它们取出来： import re rule = r\"(?P\\d+)(?P[A-Z])(?P\\d+)\" string = \"123A567\" searchObject = re.search(pattern=rule, string=string) print(searchObject.group(0, \"first\", \"second\", \"last\")) # ('123A567', '123', 'A', '567') groups() 通过该方法对search对象进行取值操作，返回一个元组，包含所有匹配的子组。 注意事项： 它不能返回最大组，仅能以元组的方式返回所有的子组 能返回匿名子组、具名子组 示例如下，groups()不能像group()那样指定组的编号进行取值，它直接返回的就是1个元组： import re rule = r\"(?P\\d+)(?P[A-Z])(?P\\d+)\" string = \"123A567\" searchObject = re.search(pattern=rule, string=string) print(searchObject.groups()) # ('123A567', '123', 'A', '567') groupdict() 通过该方法对search对象进行取值操作，返回一个字典，包含了所有的具名子组 注意事项： 它不能返回最大组，仅能以字典的方式返回所有的具名子组 不能返回匿名子组 示例如下： import re rule = r\"(?P\\d+)(?P[A-Z])(?P\\d+)\" string = \"123A567\" searchObject = re.search(pattern=rule, string=string) print(searchObject.groupdict()) # {'first': '123', 'second': 'A', 'last': '567'} split() 对字符串进行分割，其算法可能导致令人意外的情况发生。 函数签名如下： def split(pattern, string, maxsplit=0, flags=0): 参数释义： pattern：匹配规则 string：被切分的字符串 maxsplit：最大切分的次数 flags：匹配模式 普通的3个小示例： import re # 按空格切分 print(re.split(r\" \", \"hello abc def\")) # ['hello', 'abc', 'def'] # 按空格或 | 分 print(re.split(r\" |\\|\",\"hello abc|def\")) # ['hello', 'abc', 'def'] # 按空格或 | 分 print(re.split(r\"[ |]\",\"hello abc|def\")) # ['hello', 'abc', 'def'] 意外的情况示例： import re # 先按照a切分，后按照b切分 print(re.split(r\"[ab]\",\"asdabcd\")) # 第一次按a来分：['', 'sd', 'bcd'] # 第二次按b来分: ['', 'sd', '', 'cd'] # 按b的分法由于是空。故前进一位 # 结果 # ['', 'sd', '', 'cd'] sub() 对字符串进行替换，最少需要3个参数，返回一个新的字符串。 函数签名如下： def sub(pattern, repl, string, count=0, flags=0): 参数释义： pattern：匹配规则 repl：新的字符 string：被替换的字符串 count：替换次数 flags：匹配模式 示例如下： import re print(re.sub(r\"a|b\", \"N\", \"123a456b\")) # 123N456N subn() 对字符串进行替换，最少需要3个参数，返回一个元祖，其中包含了替换成功了几次。 函数签名如下： def subn(pattern, repl, string, count=0, flags=0): 参数释义： pattern：匹配规则 repl：新的字符 string：被替换的字符串 count：替换次数 flags：匹配模式 示例如下： import re print(re.subn(r\"a|b\", \"N\", \"123a456b\")) # ('123N456N', 2) complie() complie()可以将一个标示符赋予指定的规则，达到简化重复操作的目的。 函数签名如下： def compile(pattern, flags=0): 参数释义： pattern：匹配规则 flags：匹配模式 示例演示，我有一个HTML文档。现在，我要匹配每个a标签的链接、a标签的内容： import re #　step01：指定匹配规则 rule = re.compile(r\"(.*)\", flags=re.I) # step02: 书写HTML文档 htmlDocument = \"\"\" 百度搜索 谷歌搜索 必应搜索 \"\"\" # step03:开始匹配 resultList = rule.findall(htmlDocument) print(resultList) # [('www.baidu.com', '百度搜索'), ('www.google.com', '谷歌搜索'), ('www.biying.com', '必应搜索')] re模式 re.I I模式下不区分大小写，此模式下[a-z]等同于[a-zA-Z]： import re rule = \"[a-z]+\" string = \"ABC1abc\" resultList = re.findall(pattern=rule, string=string, flags=re.I) print(resultList) # ['ABC', 'abc'] re.M M模式下会将每一行单独匹配，主要是对^和$的修饰。 如下示例，匹配必须以j开头且为p结尾的子串： import re rule = \"^J.+t$\" string = \"Python\\nJavaScript\\nGolang\" resultList = re.findall(pattern=rule, string=string, flags=re.M) print(resultList) # ['JavaScript'] re.S S模式下会将多行视为单行，这意味着.通配符可以匹配\\n了。 import re rule = \".+\" string = \"\\n\\n\\n\\n\\n\" resultList = re.findall(pattern=rule, string=string, flags=re.S) print(resultList) # ['\\n\\n\\n\\n\\n'] re.U U模式使用的不多，主要针对占4个Bytes的字符进行匹配支持，尽在Python2中适用，因为Python3里的字符都是Unicode字符了。 import re rule = \"𝒳𝒴\" string = \"𝒳𝒴𝒳𝒴𝒳𝒴\" resultList = re.findall(pattern=rule, string=string, flags=re.U) print(resultList) # ['𝒳𝒴', '𝒳𝒴', '𝒳𝒴'] 通用正则表达式大全 原文转载至：Java后端 原文地址：点我跳转 数字校验 数字：^[0-9]*$ n位的数字：^\\d{n}$ 至少n位的数字：^\\d{n,}$ m-n位的数字：^\\d{m,n}$ 零和非零开头的数字：^(0|[1-9][0-9]*)$ 非零开头的最多带两位小数的数字：^([1-9][0-9]*)+(.[0-9]{1,2})?$ 带1-2位小数的正数或负数：^(\\-)?\\d+(\\.\\d{1,2})?$ 正数、负数、和小数：^(\\-|\\+)?\\d+(\\.\\d+)?$ 有两位小数的正实数：^[0-9]+(.[0-9]{2})?$ 有1~3位小数的正实数：^[0-9]+(.[0-9]{1,3})?$ 非零的正整数：^[1-9]\\d*$ 或 ^([1-9][0-9]*){1,3}$ 或 ^\\+?[1-9][0-9]*$ 非零的负整数：^\\-[1-9][]0-9\"*$ 或 ^-[1-9]\\d*$ 非负整数：^\\d+$ 或 ^[1-9]\\d*|0$ 非正整数：^-[1-9]\\d*|0$ 或 ^((-\\d+)|(0+))$ 非负浮点数：^\\d+(\\.\\d+)?$ 或 ^[1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*|0?\\.0+|0$ 非正浮点数：^((-\\d+(\\.\\d+)?)|(0+(\\.0+)?))$ 或 ^(-([1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*))|0?\\.0+|0$ 正浮点数：^[1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*$ 或 ^(([0-9]+\\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\\.[0-9]+)|([0-9]*[1-9][0-9]*))$ 负浮点数：^-([1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*)$ 或 ^(-(([0-9]+\\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\\.[0-9]+)|([0-9]*[1-9][0-9]*)))$ 浮点数：^(-?\\d+)(\\.\\d+)?$ 或 ^-?([1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*|0?\\.0+|0)$ 字符校验 汉字：^[\\u4e00-\\u9fa5]{0,}$ 英文和数字：^[A-Za-z0-9]+$ 或 ^[A-Za-z0-9]{4,40}$ 长度为3-20的所有字符：^.{3,20}$ 由26个英文字母组成的字符串：^[A-Za-z]+$ 由26个大写英文字母组成的字符串：^[A-Z]+$ 由26个小写英文字母组成的字符串：^[a-z]+$ 由数字和26个英文字母组成的字符串：^[A-Za-z0-9]+$ 由数字、26个英文字母或者下划线组成的字符串：^\\w+$ 或 ^\\w{3,20} 中文、英文、数字包括下划线：^[\\u4E00-\\u9FA5A-Za-z0-9_]+$ 中文、英文、数字但不包括下划线等符号：^[\\u4E00-\\u9FA5A-Za-z0-9]+$ 或 ^[\\u4E00-\\u9FA5A-Za-z0-9]{2,20}$ 可以输入含有^%&',;=?$\\\"等字符：[^%&',;=?$\\x22]+ 禁止输入含有~的字符[^~\\x22]+ 其他校验 .*匹配除 \\n 以外的任何字符。 /[\\u4E00-\\u9FA5]/ 汉字 /[\\uFF00-\\uFFFF]/ 全角符号 /[\\u0000-\\u00FF]/ 半角符号 钱币校验 1.有四种钱的表示形式我们可以接受:\"10000.00\" 和 \"10,000.00\", 和没有 \"分\" 的 \"10000\" 和 \"10,000\"：^[1-9][0-9]*$ 2.这表示任意一个不以0开头的数字,但是,这也意味着一个字符\"0\"不通过,所以我们采用下面的形式：^(0|[1-9][0-9]*)$ 3.一个0或者一个不以0开头的数字.我们还可以允许开头有一个负号：^(0|-?[1-9][0-9]*)$ 4.这表示一个0或者一个可能为负的开头不为0的数字.让用户以0开头好了.把负号的也去掉,因为钱总不能是负的吧.下面我们要加的是说明可能的小数部分：^[0-9]+(.[0-9]+)?$ 5.必须说明的是,小数点后面至少应该有1位数,所以\"10.\"是不通过的,但是 \"10\" 和 \"10.2\" 是通过的：^[0-9]+(.[0-9]{2})?$ 6.这样我们规定小数点后面必须有两位,如果你认为太苛刻了,可以这样：^[0-9]+(.[0-9]{1,2})?$ 7.这样就允许用户只写一位小数.下面我们该考虑数字中的逗号了,我们可以这样：^[0-9]{1,3}(,[0-9]{3})*(.[0-9]{1,2})?$ 8.1到3个数字,后面跟着任意个 逗号+3个数字,逗号成为可选,而不是必须：^([0-9]+|[0-9]{1,3}(,[0-9]{3})*)(.[0-9]{1,2})?$ 生活需求 Email地址：^\\w+([-+.]\\w+)*@\\w+([-.]\\w+)*\\.\\w+([-.]\\w+)*$ 域名：[a-zA-Z0-9][-a-zA-Z0-9]{0,62}(/.[a-zA-Z0-9][-a-zA-Z0-9]{0,62})+/.? InternetURL：[a-zA-z]+://[^\\s]* 或 ^http://([\\w-]+\\.)+[\\w-]+(/[\\w-./?%&=]*)?$ 手机号码：^(13[0-9]|14[5|7]|15[0|1|2|3|5|6|7|8|9]|18[0|1|2|3|5|6|7|8|9])\\d{8}$ 电话号码(\"XXX-XXXXXXX\"、\"XXXX-XXXXXXXX\"、\"XXX-XXXXXXX\"、\"XXX-XXXXXXXX\"、\"XXXXXXX\"和\"XXXXXXXX)：^(\\(\\d{3,4}-)|\\d{3.4}-)?\\d{7,8}$ 国内电话号码(0511-4405222、021-87888822)：\\d{3}-\\d{8}|\\d{4}-\\d{7} 身份证号(15位、18位数字)：^\\d{15}|\\d{18}$ 短身份证号码(数字、字母x结尾)：^([0-9]){7,18}(x|X)?$ 或 ^\\d{8,18}|[0-9x]{8,18}|[0-9X]{8,18}?$ 帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：^[a-zA-Z][a-zA-Z0-9_]{4,15}$ 密码(以字母开头，长度在6~18之间，只能包含字母、数字和下划线)：^[a-zA-Z]\\w{5,17}$ 强密码(必须包含大小写字母和数字的组合，不能使用特殊字符，长度在8-10之间)：^(?=.*\\d)(?=.*[a-z])(?=.*[A-Z]).{8,10}$ 日期格式：^\\d{4}-\\d{1,2}-\\d{1,2} 一年的12个月(01～09和1～12)：^(0?[1-9]|1[0-2])$ 一个月的31天(01～09和1～31)：^((0?[1-9])|((1|2)[0-9])|30|31)$ xml文件：^([a-zA-Z]+-?)+[a-zA-Z0-9]+\\\\.[x|X][m|M][l|L]$ 中文字符的正则表达式：[\\u4e00-\\u9fa5] 双字节字符：[^\\x00-\\xff] (包括汉字在内，可以用来计算字符串的长度(一个双字节字符长度计2，ASCII字符计1)) 空白行的正则表达式：\\n\\s*\\r (可以用来删除空白行) HTML标记的正则表达式：]*>.*?| (网上流传的版本太糟糕，上面这个也仅仅能部分，对于复杂的嵌套标记依旧无能为力) 首尾空白字符的正则表达式：^\\s*|\\s*$或(^\\s*)|(\\s*$) (可以用来删除行首行尾的空白字符(包括空格、制表符、换页符等等)，非常有用的表达式) 腾讯QQ号：[1-9][0-9]{4,} (腾讯QQ号从10000开始) 中国邮政编码：[1-9]\\d{5}(?!\\d) (中国邮政编码为6位数字) IP地址：\\d+\\.\\d+\\.\\d+\\.\\d+ (提取IP地址时有用) IP地址：((?:(?:25[0-5]|2[0-4]\\\\d|[01]?\\\\d?\\\\d)\\\\.){3}(?:25[0-5]|2[0-4]\\\\d|[01]?\\\\d?\\\\d)) IP-v4地址：\\\\b(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\\\b (提取IP地址时有用) 校验IP-v6地址:(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])) 子网掩码：((?:(?:25[0-5]|2[0-4]\\\\d|[01]?\\\\d?\\\\d)\\\\.){3}(?:25[0-5]|2[0-4]\\\\d|[01]?\\\\d?\\\\d)) 校验日期:^(?:(?!0000)[0-9]{4}-(?:(?:0[1-9]|1[0-2])-(?:0[1-9]|1[0-9]|2[0-8])|(?:0[13-9]|1[0-2])-(?:29|30)|(?:0[13578]|1[02])-31)|(?:[0-9]{2}(?:0[48]|[2468][048]|[13579][26])|(?:0[48]|[2468][048]|[13579][26])00)-02-29)$(“yyyy-mm-dd“ 格式的日期校验，已考虑平闰年。) 抽取注释： 查找CSS属性:^\\\\s*[a-zA-Z\\\\-]+\\\\s*[:]{1}\\\\s[a-zA-Z0-9\\\\s.#]+[;]{1} 提取页面超链接:(]*)(href=\"https?:\\\\/\\\\/)((?!(?:(?:www\\\\.)?'.implode('|(?:www\\\\.)?', $follow_list).'))[^\" rel=\"external nofollow\" ]+)\"((?!.*\\\\brel=)[^>]*)(?:[^>]*)> 提取网页图片:\\\\]*[src] *= *[\\\\\"\\\\']{0,1}([^\\\\\"\\\\'\\\\ >]*) 提取网页颜色代码:^#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$ 文件扩展名效验:^([a-zA-Z]\\\\:|\\\\\\\\)\\\\\\\\([^\\\\\\\\]+\\\\\\\\)*[^\\\\/:*?\"<>|]+\\\\.txt(l)?$ 判断IE版本：^.*MSIE [5-8](?:\\\\.[0-9]+)?(?!.*Trident\\\\/[5-9]\\\\.0).*$ Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:46 "},"Python/Python模块与包/importlib.html":{"url":"Python/Python模块与包/importlib.html","title":"内置模块：importlib","keywords":"","body":"importlib简介 importlib模块作为Python内置模块，提供了更多导入模块的方式。 官方文档 常用方法： importlib.import_module(str)：根据字符串导入1个模块，该字符串以.为路径分割，如\"package.module\" 项目示例 假设我的项目之中包含了多个中间件，并且这些中间件会在项目正式启动之前先行启动。 我该如何集中式的管理这些中间件，让它们在需要的时候能够快速加上，不需要的时候能够快速去除呢？ 使用importlib模块是最明智的选择，整个项目目录如下： PYTHONPROJECT │ ├─bin │ | run.py │ ├─middleware │ │ first_middle.py │ │ init.py │ │ second_middle.py │ │ __init__.py │ ├─view │ │ main.py │ │ settings.py 首先先查看一下run.py，它主要处理项目模块路径、中间件初始化以及主程序的运行： #　run.py import os import sys BASE_DIR = os.path.dirname(os.path.dirname(__file__)) sys.path.append(BASE_DIR) from middleware.init import init from view.main import main if __name__ == \"__main__\": # init middleware init() # run main main() 再来看一下中间件的启动，它会从配置文件中拿到被集中化管理的需要启动的中间件，然后利用importlib模块对其进行导入后执行其下的某一个方法： # middleware/init.py import importlib import settings def init(): for stringPath in settings.LOAD_MIDDLEWARE: modulePath, funcName = stringPath.rsplit(\".\", maxsplit=1) # 利用importlib模块根据字符串路径导入模块 module = importlib.import_module(modulePath) # 模块也是对象，所以利用反射拿到函数对象并执行 funcObject = getattr(module, funcName) funcObject() 被集中管理的需要加载的中间件被定义在了settings.py的1个列表中。 其中每条数据项代表1个需要被加载的中间件，以BASE_DIR为准，用.进行分割，确定了中间件的导入路径与运行函数： # settings.py LOAD_MIDDLEWARE = [ \"middleware.first_middle.m1\", \"middleware.second_middle.m2\" ] 当后续需要新增中间件，只需要在middleware包中添加好.py文件并且在settings.py中按照格式把路径和运行函数填入即可。 如果要取消某个中间件的加载，直接在列表中对它进行注释即可。 总结2点： 如何规定模块导入的格式，参见LOAD_MIDDLEWARE列表 如何使用importlib快速导入模块且执行模块下的某一个函数，参见init.py文件 把其他代码也补上吧，中间件的启动函数： # middleware/first_middle.py def m1(): print(\"middleware 1 run..\") # middleware/second_middle.py def m2(): print(\"middleware 2 run..\") 主程序函数： # view/main.py def main(): print(\"view main run...\") 运行结果： middleware 1 run.. middleware 2 run.. view main run... Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:46 "},"Python/Python模块与包/collections.html":{"url":"Python/Python模块与包/collections.html","title":"内置模块：collections","keywords":"","body":"collections简介 collections模块提供了许多容器的数据类型，是Python内置数据类型的一种升级。 官方文档 collections模块所提供的内置容器或者基类如下所示： 容器/基类 描述 namedtuple() 创建命名元组子类的工厂函数 deque 类似列表(list)的容器，实现了在两端快速添加(append)和弹出(pop) ChainMap 类似字典(dict)的容器类，将多个映射集合到一个视图里面 Counter 字典的子类，提供了可哈希对象的计数功能 OrderedDict 字典的子类，保存了他们被添加的顺序 defaultdict 字典的子类，提供了一个工厂函数，为字典查询提供一个默认值 UserDict 封装了字典对象，简化了字典子类化 UserList 封装了列表对象，简化了列表子类化 UserString 封装了列表对象，简化了字符串子类化 ChainMap ChainMap能够让多个字典链接起来，返回类似于字典视图的功能，可以直接将多个互相分离的字典当做1个大的整体字典来用，ChainMap支持所有字典方法，如get()，pop()等。 可能有的朋友会想，那为什么不新创建1个字典然后update()旧的字典呢？ 这是因为ChainMap和字典视图很相似，所以oldDict的数据如果发生更新，则ChainMap也会同步进行更新。 但使用dict.update()创建的newDict就没有这种特性了，它不会随着oldDict的数据改变而发生改变。 如下图所示： 快速使用 如下示例，将链接2个字典，组成英文字母大小写对照ASCII码表： from collections import ChainMap uppercaseAlphabet = {chr(i): i for i in range(65, 91)} lowercaseAlphabet = {chr(i): i for i in range(97, 123)} letterTable = ChainMap(uppercaseAlphabet, lowercaseAlphabet) print(letterTable) 生成的对象如下所示： ChainMap({'A': 65, 'B': 66, 'C': 67, 'D': 68, 'E': 69, 'F': 70, 'G': 71, 'H': 72, 'I': 73, 'J': 74, 'K': 75, 'L': 76, 'M': 77, 'N': 78, 'O': 79, 'P': 80, 'Q': 81, 'R': 82, 'S': 83, 'T': 84, 'U': 85, 'V': 86, 'W': 87, 'X': 88, 'Y': 89, 'Z': 90}, {'a': 97, 'b': 98, 'c': 99, 'd': 100, 'e': 101, 'f': 102, 'g': 103, 'h': 104, 'i': 105, 'j': 106, 'k': 107, 'l': 108, 'm': 109, 'n': 110, 'o': 111, 'p': 112, 'q': 113, 'r': 114, 's': 115, 't': 116, 'u': 117, 'v': 118, 'w': 119, 'x': 120, 'y': 121, 'z': 122}) maps ChainMap的底层其实是用了1个列表，来存放了oldDict的引用。 格式如下： [ {oldDict1..}, {oldDict2..}, ... ] 在查询时，如果oldDict1和oldDict2具有重复的key，则会查出oldDict1，因为它是挨个字典的向后进行查找，其他的操作也是同理： 如下示例，oldDict1和oldDict2都有为a的key，那么操纵ChainMap的a时必定先拿到oldDict1的a： from collections import ChainMap oldDict1 = {\"a\": 1, \"b\": 2, \"c\": 3} oldDict2 = {\"a\": 10, \"b\": 20, \"c\": 30} newMap = ChainMap(oldDict1, oldDict2) print(newMap.get(\"a\")) # 1 如果直接想操作oldDict2的a，则可以通过ChainMap.maps拿到存储字典映射的列表，指定索引值来操作第2个字典也就是oldDict2，示例如下： from collections import ChainMap oldDict1 = {\"a\": 1, \"b\": 2, \"c\": 3} oldDict2 = {\"a\": 10, \"b\": 20, \"c\": 30} newMap = ChainMap(oldDict1, oldDict2) print(newMap.maps[1].get(\"a\")) # 10 new_child(m=None) 该方法会在旧的ChainMap上生成1个新的ChainMap，并且新增1个空字典在最前面。 如下图所示： 代码示例： from collections import ChainMap oldDict1 = {\"a\": 1, \"b\": 2, \"c\": 3} oldDict2 = {\"a\": 10, \"b\": 20, \"c\": 30} oldMap = ChainMap(oldDict1, oldDict2) newMap = oldMap.new_child() print(newMap) # ChainMap({}, {'a': 1, 'b': 2, 'c': 3}, {'a': 10, 'b': 20, 'c': 30}) 你也可以选择，在使用该方法的时候传入1个新的字典，让它填补第1个位置： ... newMap = oldMap.new_child({\"new\": None}) print(newMap) # ChainMap({'new': None}, {'a': 1, 'b': 2, 'c': 3}, {'a': 10, 'b': 20, 'c': 30}) parents 返回ChainMap的父ChainMap，相较于子ChainMap来说，父ChainMap永远没有子ChainMap的第1个oldDict。 如下图所示： 示例如下： from collections import ChainMap oldDict1 = {\"a\": 1, \"b\": 2, \"c\": 3} oldDict2 = {\"a\": 10, \"b\": 20, \"c\": 30} oldMap = ChainMap(oldDict1, oldDict2) print(oldMap.parents) # ChainMap({'a': 10, 'b': 20, 'c': 30}) 使用场景 在官方文档中举例了一个非常好的使用场景。 有1个简单的脚本，它拥有一些默认的参数变量。 当启动该脚本时，会有以下3种情况发生： 如果在命令行启动脚本时，指定了参数，则使用命令行指定的参数 如果没有在命令行启动脚本时指定参数，则会查找os的环境变量试图获取该参数 如果os的环境变量中也没有该参数，则使用默认的参数 这里它就是用了ChainMap来实现的，具体代码如下，避免了大量的if和else，非常方便： import os import argparse from collections import ChainMap defaults = {'color': 'red', 'user': 'guest'} parser = argparse.ArgumentParser() parser.add_argument('-u', '--user') parser.add_argument('-c', '--color') namespace = parser.parse_args() command_line_args = {k: v for k, v in vars(namespace).items() if v} combined = ChainMap(command_line_args, os.environ, defaults) print(combined['color']) print(combined['user']) 测试1，命令行传入了参数： python3 demo.py -c Black -u Yunya Black Yunya 测试2，命令行和os的环境变量中都没有参数，则用默认的参数： python3 demo.py red guest Counter Counter能够快速的获取一个可迭代对象中每一个数据项所出现的次数。 因此可以用来做词频统计，排行榜等一类的工具。 Counter是Dict的派生类，故支持大部分的字典方法，如get()，pop()等。 序列记数 直接为Counter()传入1个可迭代对象，返回一个dict，包含数据项和出现次数，按照降序排列，如下所示： from collections import Counter seq = [\"A\", \"A\", \"B\", \"C\", \"C\", \"D\"] c = Counter(seq) print(c) # Counter({'A': 2, 'C': 2, 'B': 1, 'D': 1}) 计数获取 如果你想获取1个数据项的出现次数，可通过[]的操作或者get()方法来完成，像操纵字典一样操纵Counter即可。 值得一提的是，当Counter通过[item]来获取数据项出现次数的话，如果这个数据项不存在则会返回0，而不是抛出KeyError。 from collections import Counter seq = [\"A\", \"A\", \"B\", \"C\", \"C\", \"D\"] c = Counter(seq) print(c.get(\"A\")) print(c.get(\"Z\")) print(c[\"Z\"]) # 2 # None # 0 排行获取 Counter.most_common()会返回1一个列表，按照Counter的排列顺序从大到小进行返回，如下所示，返回出现次数最多的3个数据项： from collections import Counter seq = [\"A\", \"A\", \"B\", \"C\", \"C\", \"D\"] c = Counter(seq) print(sorted(c.most_common(3))) # [('A', 2), ('C', 2), ('B', 1)] 如果想返回出现次数最少的3个数据项该怎么办呢？ 如下所示： from collections import Counter seq = [\"A\", \"A\", \"B\", \"C\", \"C\", \"D\"] c = Counter(seq) print(sorted(c.items(), key=lambda li:li[1])[:3]) # [('B', 1), ('D', 1), ('A', 2)] 词频统计 打开一个文件，做词频统计： from collections import Counter result = Counter() with open(\"./data/input.txt\",\"r\") as f: while True: lines = f.read(1024).splitlines() if lines==[]: break lines = [lines[i].split(\" \") for i in range(len(lines))] words = [] for line in lines: words.extend(line) tmp = Counter(words) result+=tmp print (result.most_common(10)) deque deque是collections模块提供的一大杀器，名为双端队列。 虽然普通的list也能够在队列2端进行数据项操作，但诸如insert(0, item)， pop(0)等方法都会引起数据项在内存中的挪动，从而使这2个方法的时间复杂度降低到O(n)。 而deque针对insert(0, item)和pop(0)做出了优化，让它们的时间复杂度都降到了O(1)。 如果仅在队首、队尾做操作，那么使用双端队列是最合适的。 如果要在队列中部做操作，还是推荐使用list。 方法一览 下面是deque所提供的方法和属性： 方法/属性 描述 deque(iterable, maxlen) 返回新的双端队列，可指定该队列的最大容量，如果不指定最大容量，则内部会根据数据项个数进行自动扩容 append(item) 添加数据项至队尾 appendleft(item) 添加数据项至队首 clear() 清空队列中的数据项 copy() 创建一份浅拷贝 count(item) 返回item在队列中出现的次数 extend(iterable) 通过附加来自可迭代对象的数据项来扩展队列，数据项添加至队尾 extendleft(iterable) 通过附加来自可迭代对象的数据项来扩展队列，数据项添加至队首 index(item, start, stop) 返回第一个数据项在队列中出现位置的索引，若值不存在，则抛出ValueError，可指定start和stop的索引区间 insert(index, item) 在索引之前插入数据项 pop() 删除并弹出队尾的数据项，若队列为空则抛出IndexError popleft() 删除并弹出队首的数据项，若队列为空则抛出IndexError remove(item) 删除队列中第一次出现的数据项。如果不存在该数据项，则引发ValueError reverse() 翻转整个队列，返回None，即原地翻转 rotate(n=1) 如果为正数，将队尾n个数据项移动至队首，如果是负数，将队首n个数据项移至队尾 maxlen 返回队列的最大容量 除了以上方法和属性之外，deque还支持迭代，枚举，len(d), reversed(d), copy.copy(d), copy.deepcopy(d), 成员测试 in 操作符，和下标引用 d[-1]，但是不支持切片[::] 。 注意！len()和maxlen是不同的： len()取的是队列中以有多少个数据项 maxlen取的是队列中最多可容纳多少数据项 如下所示： from collections import deque q = deque(range(3), maxlen=10) print(q.maxlen) print(len(q)) # 10 # 3 此外，rotate()方法可以在队列中进行数据项的位置迁移，如下所示。 n为正数，将队尾n个数据项移动至队首： from collections import deque q = deque(range(5), maxlen=10) print(q) q.rotate(2) print(q) # deque([0, 1, 2, 3, 4], maxlen=10) # deque([3, 4, 0, 1, 2], maxlen=10) n为负数，将队首n个数据项移至队尾： from collections import deque q = deque(range(5), maxlen=10) print(q) q.rotate(-2) print(q) # deque([0, 1, 2, 3, 4], maxlen=10) # deque([2, 3, 4, 0, 1], maxlen=10) defaultdict defaultdict本身是一个字典，继承了dict类并覆写了__missing__()方法。 在实例化defaultdict对象时我们可以为字典设置1个默认值，当使用[key]获取value时，若[key]不存在将会返回默认值而不是直接抛出keyError。 快速使用 如下所示，在使用了defaultdict后，用[key]操作获取value时若key不存在则会返回设定的默认值： from collections import defaultdict dic = defaultdict(lambda : None) #　❶ dic[\"k1\"] = \"v1\" print(dic[\"k1\"]) print(dic[\"k2\"]) # v1 # None ❶：设定默认值，必须是1个可调用对象，将其返回值作为defaultdict的默认值 计数统计 统计数据项在列表中出现的次数，如果是普通的dict你可能需要这么做： li1 = [\"A\", \"A\", \"B\", \"C\", \"C\", \"D\"] dic = {} for item in li1: dic.setdefault(item, 0) dic[item] += 1 print(dic) # {'A': 2, 'B': 1, 'C': 2, 'D': 1} 如果是defaultdict，则可以让代码更精简一点： from collections import defaultdict li1 = [\"A\", \"A\", \"B\", \"C\", \"C\", \"D\"] dic = defaultdict(lambda: 0) for item in li1: dic[item] += 1 print(dic) # defaultdict( at 0x0127B6A8>, {'A': 2, 'B': 1, 'C': 2, 'D': 1}) namedtuple namedtuple翻译过来就是具名元组，因为元组的主要功能是数据的展示，如果能够将1个元组中每个数据项的意思也表达出来就更好了。 如下所示，一个普通的元组： (\"Jack\", 18, \"male\", \"123456\") 乍一看前3个你可能都能看懂是什么意思，那么最后1个呢？是不是一脸懵逼？ 而通过具名元组，你就能知道最后1个的意思了，如下所示： (name='Jack', age=18, gender='male', password='123456') 可能这里有的同学会说，那我为什么不用dict？而偏要这么麻烦的用collections中的namedtuple？ 别搞忘了，dict是可变类型，namedtuple则是继承了tuple的特性，是不可变的，数据仅作展示时使用具名元组是最好的选择。 此外，具名元组是元组的子类，所以可以使用所有元组的方法，除此之外它还新增了一些方法和属性。 对象创建 使用namedtuple()方法来初始化一个类。 函数签名如下： def namedtuple(typename, field_names, *, verbose=False, rename=False, module=None): pass 参数释义： typename：将要实例化出的类的名称 field_names：具名元组中每个字段的名称 ... 示例演示： from collections import namedtuple UserMessage = namedtuple(\"userMessage\", [\"name\", \"age\" ,\"gender\", \"password\"]) u = UserMessage(\"Jack\", 18, \"male\", \"123456\") print(u) # userMessage(name='Jack', age=18, gender='male', password='123456') _make() 若1个序列的数据项个数与具名元组类的字段个数相同，通过该方法可直接将这个序列传入并生成新的具名元组对象。 如下所示，u的数据项个数与具名元组类的字段个数相同，直接根据u创建1个具名元组对象： from collections import namedtuple UserMessage = namedtuple(\"userMessage\", [\"name\", \"age\" ,\"gender\", \"password\"]) u = (\"Jack\", 18, \"male\", \"123456\") print(UserMessage._make(u)) # userMessage(name='Jack', age=18, gender='male', password='123456') _asdict() 将具名元组对象转换为有序字典（注：不是dict，而是Orderdict）： from collections import namedtuple UserMessage = namedtuple(\"userMessage\", [\"name\", \"age\" ,\"gender\", \"password\"]) u = UserMessage(\"Jack\", 18, \"male\", \"123456\") print(u._asdict()) # OrderedDict([('name', 'Jack'), ('age', 18), ('gender', 'male'), ('password', '123456')]) _replace() 由于具名元组不可改变，所以通过该方法会生成1个新的具名元组，用于替换旧的具名元组中的某一个数据项值： from collections import namedtuple UserMessage = namedtuple(\"userMessage\", [\"name\", \"age\" ,\"gender\", \"password\"]) oldUser = UserMessage(\"Jack\", 18, \"male\", \"123456\") newUser = oldUser._replace(name=\"Tom\", password=\"abcdef\") print(newUser) # userMessage(name='Tom', age=18, gender='male', password='abcdef') _fields 返回具名元组的字段列表： from collections import namedtuple UserMessage = namedtuple(\"userMessage\", [\"name\", \"age\" ,\"gender\", \"password\"]) u = UserMessage(\"Jack\", 18, \"male\", \"123456\") print(u._fields) # ('name', 'age', 'gender', 'password') 字典转换 若想将具名元组转换为普通字典，可通过如下方法： from collections import namedtuple UserMessage = namedtuple(\"userMessage\", [\"name\", \"age\" ,\"gender\", \"password\"]) u = UserMessage(\"Jack\", 18, \"male\", \"123456\") print( dict(zip(u._fields, u[:])) ) # {'name': 'Jack', 'age': 18, 'gender': 'male', 'password': '123456'} 若想将普通字典转换为具名元组，可通过如下方法： from collections import namedtuple userDict = {'name': 'Jack', 'age': 18, 'gender': 'male', 'password': '123456'} UserMessage = namedtuple(\"userMessage\", [\"name\", \"age\" ,\"gender\", \"password\"]) print(UserMessage(**userDict)) # userMessage(name='Jack', age=18, gender='male', password='123456') OrderDict OrderDict见字生意，即有序字典。 但是Python3.6之后字典已经变的有序了，所以这里不再举例它的用法。 感兴趣可以参照collections的官方文档进行查阅。 继承基类 collections中提供了3个基类，分别是UserList，UserDict，UserString。 它们并没有什么实质性的功能，只是针对list、dict、string的C语言实现用Python重写了一遍。 如果你对这些数据类型的实现比较感兴趣，可翻阅一下它们的源码。 此外，如果在自定义序列时，也建议继承这3个类，而不是继承内置的3个类。 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:46 "},"Python/Python模块与包/itertools.html":{"url":"Python/Python模块与包/itertools.html","title":"内置模块：itertools","keywords":"","body":"itertools简介 itertools是Python内置模块，提供了大量为高效循环而创建的迭代器函数，当你有以下一些特殊需求时就可以使用它们，而不必再自己动手造轮子。 官方文档 由于提供的迭代器众多，故不可能每个都记得，这里放上摘自官网的迭代器一览表。 首先是无穷迭代器如下表所示，即能够无限被迭代的迭代器： 迭代器 实参 结果 示例 count() start, [step] start, start+step, start+2*step, … count(10) --> 10 11 12 13 14 ... cycle() p p0, p1, … plast, p0, p1, … cycle('ABCD') --> A B C D A B C D ... repeat() elem [,n] elem, elem, elem, … 重复无限次或n次 repeat(10, 3) --> 10 10 10 其次是可停止的迭代器： 迭代器 实参 结果 示例 accumulate() p [,func] p0, p0+p1, p0+p1+p2, … accumulate([1,2,3,4,5]) --> 1 3 6 10 15 chain() p, q, … p0, p1, … plast, q0, q1, … chain('ABC', 'DEF') --> A B C D E F chain.from_iterable() iterable – 可迭代对象 p0, p1, … plast, q0, q1, … chain.from_iterable(['ABC', 'DEF']) --> A B C D E F compress() data, selectors (d[0] if s[0]), (d[1] if s[1]), … compress('ABCDEF', [1,0,1,0,1,1]) --> A C E F dropwhile() pred, seq seq[n], seq[n+1], … 从pred首次真值测试失败开始 dropwhile(lambda x: x 6 4 1 filterfalse() pred, seq seq中pred(x)为假值的元素，x是seq中的元素。 filterfalse(lambda x: x%2, range(10)) --> 0 2 4 6 8 groupby() iterable[, key] 根据key(v)值分组的迭代器 islice() seq, [start,] stop [, step] seq[start:stop:step]中的元素 islice('ABCDEFG', 2, None) --> C D E F G starmap() func, seq func(seq[0]), func(seq[1]), … starmap(pow, [(2,5), (3,2), (10,3)]) --> 32 9 1000 takewhile() pred, seq seq[0], seq[1], …, 直到pred真值测试失败 takewhile(lambda x: x 1 4 tee() it, n it1, it2, … itn 将一个迭代器拆分为n个迭代器 zip_longest() p, q, … (p[0], q[0]), (p[1], q[1]), … zip_longest('ABCD', 'xy', fillvalue='-') --> Ax By C- D- 然后是排列组合迭代器： 迭代器 实参 结果 product() p, q, … [repeat=1] 笛卡尔积，相当于嵌套的for循环 permutations() p[, r] 长度r元组，所有可能的排列，无重复元素 combinations() p, r 长度r元组，有序，无重复元素 combinations_with_replacement() p, r 长度r元组，有序，元素可重复 product('ABCD', repeat=2) AA AB AC AD BA BB BC BD CA CB CC CD DA DB DC DD permutations('ABCD', 2) AB AC AD BA BC BD CA CB CD DA DB DC combinations('ABCD', 2) AB AC AD BC BD CD combinations_with_replacement('ABCD', 2) AA AB AC AD BB BC BD CC CD DD 自认为比较重要的方法有：chain()，zip_longset()，permutations()。 除此之外的方法局限性太强，不适合所有场景。 无穷迭代器 count() 创建1个迭代器，初始值是start，步长是step，结束是无限。 函数签名如下： itertools.count(start=0, step=1) 官方文档的实现： def count(start=0, step=1): # count(10) --> 10 11 12 13 14 ... # count(2.5, 0.5) -> 2.5 3.0 3.5 ... n = start while True: yield n n += step 注意，可以生成浮点数，这是range所不支持的。 cycle() 创建1个迭代器，对传入的可迭代对象元素进行无限复制。 函数签名如下： itertools.cycle(iterable) 官方文档的实现： def cycle(iterable): # cycle('ABCD') --> A B C D A B C D A B C D ... saved = [] for element in iterable: yield element saved.append(element) while saved: for element in saved: yield element repeat() 创建1个迭代器，对传入的可迭代对象进行无限复制，或通过times参数指定复制的次数： 函数签名如下： itertools.repeat(object[, times]) 官方文档的实现： def repeat(object, times=None): # repeat(10, 3) --> 10 10 10 if times is None: while True: yield object else: for i in range(times): yield object 可停止的迭代器 accumulate() 该函数可接收2个参数，1个可迭代对象和1个具有2参数的可调用对象，返回1个迭代器。 该迭代器的值生成基于可调用对象对传入数据项的处理。 函数签名如下： itertools.accumulate(iterable[, func]) 官方文档实现： def accumulate(iterable, func=operator.add): 'Return running totals' # accumulate([1,2,3,4,5]) --> 1 3 6 10 15 # accumulate([1,2,3,4,5], operator.mul) --> 1 2 6 24 120 it = iter(iterable) try: total = next(it) except StopIteration: return yield total for element in it: total = func(total, element) yield total 示例演示： import itertools print(list(itertools.accumulate(range(5), lambda x,y:x+y))) # [0, 1, 3, 6, 10] 过程解析： # range(5) lambda x,y : x+y # [0, 1, 2, 3, 4] # 第一次：返回0 -> [0] # 第二次：0 + 1 = 1 -> [0, 1] # 第三次：1 + 2 = 3 -> [0, 1, 3] # 第四次：3 + 3 = 6 -> [0, 1, 3, 6] # 第五次：4 + 6 = 10 -> [0, 1, 3, 6, 10] # 结果： # [0, 1, 3, 6, 10] chain() 该函数可接收无限多的可迭代对象，并将它们进行合并成1个迭代器进行返回。 函数签名如下： itertools.chain(*iterables) 官方文档实现： def chain(*iterables): # chain('ABC', 'DEF') --> A B C D E F for it in iterables: for element in it: yield element from_iterable() 该函数可接收一个多维度的可迭代对象，并将多维展开合并成1个平面迭代器进行返回。 函数签名如下： itertools.chain.from_iterable(iterable) 官方文档实现： def from_iterable(iterables): # chain.from_iterable(['ABC', 'DEF']) --> A B C D E F for it in iterables: for element in it: yield element compress 创建一个迭代器，它返回data中经selectors真值测试为True的元素。迭代器在两者较短的长度处停止。 函数签名如下： itertools.compress(data, selectors) 官方文档实现： def compress(data, selectors): # compress('ABCDEF', [1,0,1,0,1,1]) --> A C E F return (d for d, s in zip(data, selectors) if s) dropwhile() 创建一个迭代器，如果predicate为true，迭代器丢弃这些元素，然后返回其他元素。 注意，迭代器在predicate首次为false之前不会产生任何输出，所以可能需要一定长度的启动时间。 函数签名如下： itertools.dropwhile(predicate, iterable) 官方文档实现： def dropwhile(predicate, iterable): # dropwhile(lambda x: x 6 4 1 iterable = iter(iterable) for x in iterable: if not predicate(x): yield x break for x in iterable: yield x filterfalse() 创建一个迭代器，只返回iterable中predicate为False 的元素。如果predicate是None，返回真值测试为false的元素。 其实说白了就相当于filter()的反函数。 函数签名如下： itertools.filterfalse(predicate, iterable) 官方文档实现： def filterfalse(predicate, iterable): # filterfalse(lambda x: x%2, range(10)) --> 0 2 4 6 8 if predicate is None: predicate = bool for x in iterable: if not predicate(x): yield x islice() 创建一个迭代器，该函数接收3个参数，总体效果和切片取子序列类似，能指定开始位置、结束位置、步长等。 函数签名如下： itertools.islice(iterable, start, stop[, step] 官方文档实现： def islice(iterable, *args): # islice('ABCDEFG', 2) --> A B # islice('ABCDEFG', 2, 4) --> C D # islice('ABCDEFG', 2, None) --> C D E F G # islice('ABCDEFG', 0, None, 2) --> A C E G s = slice(*args) start, stop, step = s.start or 0, s.stop or sys.maxsize, s.step or 1 it = iter(range(start, stop, step)) try: nexti = next(it) except StopIteration: # Consume *iterable* up to the *start* position. for i, element in zip(range(start), iterable): pass return try: for i, element in enumerate(iterable): if i == nexti: yield element nexti = next(it) except StopIteration: # Consume to *stop*. for i, element in zip(range(i + 1, stop), iterable): pass starmap() 创建一个迭代器，使用从可迭代对象中获取的参数来计算该函数。当参数对应的形参已从一个单独可迭代对象组合为元组时（数据已被“预组对”）可用此函数代替 map()。map()与starmap()之间的区别可以类比 function(a,b)与function(*c)的区别。 函数签名如下： itertools.starmap(function, iterable) 官方文档实现： def starmap(function, iterable): # starmap(pow, [(2,5), (3,2), (10,3)]) --> 32 9 1000 for args in iterable: yield function(*args) 注意，function必须接收2个参数，而传入的Iterable也必须符合上述格式。 takewhile() 相当于filter()，创建一个迭代器，只要predicate为真就从可迭代对象中返回元素。 函数签名如下： itertools.takewhile(predicate, iterable) 官方文档实现： def takewhile(predicate, iterable): # takewhile(lambda x: x 1 4 for x in iterable: if predicate(x): yield x else: break zip_longset() 创建一个迭代器，从每个可迭代对象中收集元素。如果可迭代对象的长度未对齐，将根据fillvalue填充缺失值。迭代持续到耗光最长的可迭代对象。 函数签名如下： itertools.zip_longest(*iterables, fillvalue=None) 官方文档实现： class ZipExhausted(Exception): pass def zip_longest(*args, **kwds): # zip_longest('ABCD', 'xy', fillvalue='-') --> Ax By C- D- fillvalue = kwds.get('fillvalue') counter = len(args) - 1 def sentinel(): nonlocal counter if not counter: raise ZipExhausted counter -= 1 yield fillvalue fillers = repeat(fillvalue) iterators = [chain(it, sentinel(), fillers) for it in args] try: while iterators: yield tuple(map(next, iterators)) except ZipExhausted: pass 其他的迭代器 这里省略了2个迭代器，tee()和groupby()，因为我实在想不通在怎样的场景下会去使用它们.. 排序组合迭代器 product() 返回可迭代对象输入的笛卡儿积，存在重复元素。 函数签名如下： itertools.product(*iterables, repeat=1) 官方文档实现： def product(*args, repeat=1): # product('ABCD', 'xy') --> Ax Ay Bx By Cx Cy Dx Dy # product(range(2), repeat=3) --> 000 001 010 011 100 101 110 111 pools = [tuple(pool) for pool in args] * repeat result = [[]] for pool in pools: result = [x+[y] for x in result for y in pool] for prod in result: yield tuple(prod) permutations() 连续返回由iterable元素生成长度为r的排列。 如果r未指定或为None ，r默认设置为iterable的长度，这种情况下，生成所有全长排列。 排列依字典序发出。因此，如果iterable是已排序的，排列元组将有序地产出。 即使元素的值相同，不同位置的元素也被认为是不同的。如果元素值都不同，每个排列中的元素值不会重复。 函数签名如下： itertools.permutations(iterable, r=None 官方文档实现： def permutations(iterable, r=None): # permutations('ABCD', 2) --> AB AC AD BA BC BD CA CB CD DA DB DC # permutations(range(3)) --> 012 021 102 120 201 210 pool = tuple(iterable) n = len(pool) r = n if r is None else r if r > n: return indices = list(range(n)) cycles = list(range(n, n-r, -1)) yield tuple(pool[i] for i in indices[:r]) while n: for i in reversed(range(r)): cycles[i] -= 1 if cycles[i] == 0: indices[i:] = indices[i+1:] + indices[i:i+1] cycles[i] = n - i else: j = cycles[i] indices[i], indices[-j] = indices[-j], indices[i] yield tuple(pool[i] for i in indices[:r]) break else: return combinations() 返回由输入iterable中元素组成长度为 r 的子序列。 组合按照字典序返回。所以如果输入iterable是有序的，生成的组合元组也是有序的。 即使元素的值相同，不同位置的元素也被认为是不同的。如果元素各自不同，那么每个组合中没有重复元素。 函数签名如下： itertools.combinations(iterable, r) 官方文档实现： def combinations(iterable, r): # combinations('ABCD', 2) --> AB AC AD BC BD CD # combinations(range(4), 3) --> 012 013 023 123 pool = tuple(iterable) n = len(pool) if r > n: return indices = list(range(r)) yield tuple(pool[i] for i in indices) while True: for i in reversed(range(r)): if indices[i] != i + n - r: break else: return indices[i] += 1 for j in range(i+1, r): indices[j] = indices[j-1] + 1 yield tuple(pool[i] for i in indices) combinations_with_replacement() 返回由输入iterable中元素组成的长度为r的子序列，允许每个元素可重复出现。 组合按照字典序返回。所以如果输入iterable是有序的，生成的组合元组也是有序的。 不同位置的元素是不同的，即使它们的值相同。因此如果输入中的元素都是不同的话，返回的组合中元素也都会不同。 函数签名如下： itertools.combinations_with_replacement(iterable, r) 官方文档实现： def combinations_with_replacement(iterable, r): # combinations_with_replacement('ABC', 2) --> AA AB AC BB BC CC pool = tuple(iterable) n = len(pool) if not n and r: return indices = [0] * r yield tuple(pool[i] for i in indices) while True: for i in reversed(range(r)): if indices[i] != n - 1: break else: return indices[i:] = [indices[i] + 1] * (r - i) yield tuple(pool[i] for i in indices) Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:46 "},"Python/Python模块与包/functools.html":{"url":"Python/Python模块与包/functools.html","title":"内置模块：functools","keywords":"","body":"functools简介 functools是非常强大的内置模块，它提供了许多装饰器与函数，适用于对所有可调用对象的应用。 官方文档 这里主要着重介绍2种常用的函数与装饰器，它们适用于绝大部分的场景。 函数/装饰器 描述 partial() 冻结可调用对象的某些参数，因此该函数也被称为偏函数 @lru_cache 为函数提供缓存功能，当某一函数的两次调用参数均一致，则直接返回前一次调用的结果 在该模块中，我们之前也已经接触过它所提供的redue()与@warps装饰器，所以这里不再进行举例。 partial() 传入1个可调用对象和它的某一个或多个调用参数，返回1个新的可调用对象，并且该对象中的某些参数是被固定的。 函数签名如下： functools.partial(func, *args, **keywords) 官方文档实现： def partial(func, *args, **keywords): def newfunc(*fargs, **fkeywords): newkeywords = keywords.copy() newkeywords.update(fkeywords) return func(*args, *fargs, **newkeywords) newfunc.func = func newfunc.args = args newfunc.keywords = keywords return newfunc 示例演示： import functools def add(x, y): return x + y # newFunc = add(1, 2) newFunc = functools.partial(add, 1, 2) print(newFunc()) # 3 再来一个2进制转10进制的函数： import functools binToDecimal = functools.partial(int, base=2) print(binToDecimal(\"110\")) # 6 @lru_cache 一个为函数提供缓存功能的装饰器，缓存maxsize组传入参数，在下次以相同参数调用时直接返回上一次的结果。用以节约高开销或I/O函数的调用时间。 由于使用了字典存储缓存，所以被装饰的函数固定参数和关键字参数必须是可哈希的。 函数签名如下： @functools.lru_cache(maxsize=128, typed=False) 参数释义： 如果maxsize设置为None，LRU功能将被禁用且缓存数量无上限。maxsize设置为2的幂时可获得最佳性能。 如果typed设置为true，不同类型的函数参数将被分别缓存。例如，f(3)和f(3.0)将被视为不同而分别缓存。 一个简单的例子： 第一次运行函数，传入参数1和2，计算结果为3，缓存这2个参数和结果 第二次运行函数，传入参数1和2，查询缓存，缓存有就直接获得结果，根本不运行函数，所以没有看到print()的打印效果 第三次运行函数，传入参数1.0和2，查询缓存，由于typed为True，故严格区分浮点型和整形，再次运行函数，结果计算为3.0 如下示例： import functools @functools.lru_cache(maxsize=128, typed=True) def add(x, y): print(\"add run...\") return x+y print(add(1, 2)) print(add(1, 2)) print(add(1.0, 2)) # add run... # 3 # 3 # add run... # 3.0 乍一看之下好像没什么作用，不就是缓存了一下嘛，实际上，在对递归函数上加上该装饰器，性能将会得到质的提升。 如下示例了加上该装饰器函数求解上楼梯问题和不加该装饰器函数求解上楼梯问题的总计运行时间。 对35阶梯楼梯的计算，加了该装饰器的运行几乎是瞬间完成，而不加该装饰器大概需要耗费十秒左右： import functools import time @functools.lru_cache(maxsize=256, typed=False) def haveCache(n): if n == 1: return 1 if n == 2: return 2 return haveCache(n - 1) + haveCache(n - 2) def dontHaveCache(n): if n == 1: return 1 if n == 2: return 2 return dontHaveCache(n - 1) + dontHaveCache(n - 2) s = time.time() haveCache(35) print(\"HaveCache - >\", time.time() - s) s = time.time() dontHaveCache(35) print(\"dontHaveCache - >\", time.time() - s) # HaveCache - > 0.0 # dontHaveCache - > 11.06638216972351 如果最大缓存设为2，则运行时间会慢一点，但是32阶的上楼梯问题也是在短短0.2秒之内得到解决了： @functools.lru_cache(maxsize=2, typed=False) ... # HaveCache - > 0.23421168327331543 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:46 "},"Python/Python模块与包/模块包库框架的区别.html":{"url":"Python/Python模块与包/模块包库框架的区别.html","title":"模块包库框架的区别","keywords":"","body":"模块 Python中1个.py文件就是一个模块。 模块是指为了解决某一单独功能而专门诞生的。 如用户登录注册功能中包含验证码发送，针对这一个小功能可以单独拎出来做一个模块。 verification_code.py 包 包其实就是一个包含有__init__.py的文件夹。 一个包中可以包含另一个包，包的基础单元是由模块构成。 包将一些近似功能的模块组合到一起，如登录注册这2个大功能可以形成一个顶级包，可分为登录包、注册包、功能包3个子包： login_register/ # 顶级包：登录组成 ├── __init__.py │ ├── features # 子级包：功能类 │ └── verification_code.py # 发送验证码 │ │ ├── login # 子级包：登录类 │ ├── __init__.py │ ├── email.py # 邮箱登录 │ ├── phone.py # 手机登录 │ ├── qq.py # QQ登录 │ └── weichat.py # 微信登录 │ │ └── register # 子级包：注册类 ├── __init__.py ├── other.py # 其他注册 ├── email.py # 邮箱注册 └── phone.py # 手机注册 库 库更像是针对某个功能的解决工具包，一般来说由一个或多个包组成。 如想获取时间相关功能的操作，有内置库time进行提供。 如想获取日志相关功能的操作，有内置库logging进行提供。 再比如想获取网络功能的操作，有第三方库requests进行提供。 在Python中，很多人通常将一些内置库称为内置模块，严格意义上来说并不准确，应该叫做Python内置库更好一点。 框架 框架是一套通用的解决方案，通常由多个库组成。 使用框架能够提供一整套的服务，它将所有可能用到的资源进行了整合。 如想搭建一个网站，有Django框架可以快速完成需求。 如想进行数据分析，有Numpy框架可以助你锦上添花。 再比如想开始网络爬虫，有Scrapy框架可以让你进行花式爬取。 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:46 "},"Python/Python面向对象/summary.html":{"url":"Python/Python面向对象/summary.html","title":"Python面向对象","keywords":"","body":" 编程范式 类与对象 类的方法 属性代理 封装 继承 多态 抽象基类 自省反射 双下大全 描述符类 元类编程 异常处理 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:46 "},"Python/Python面向对象/编程范式.html":{"url":"Python/Python面向对象/编程范式.html","title":"编程范式","keywords":"","body":"编程范式 编程范式只是一种程序设计思维，本身并无优劣之分。 与任何语言都无关，不要觉得面向对象就一定比面向过程好，实际上恰恰相反。 面向过程才是所有代码在内存中最终的状态。 面向过程 面向过程（OPP）编程思想的重点是将注意力放在事物本身上，更多的是关心下一步操作该怎么做，以正在发生为目的。 将1个大的问题逐步拆解成多个小问题，一旦问题解决后代码上线将很少有改动的场景。 特性：模块化、流程化 优点：代码可读性高，并且性能高 缺点：不利于维护与扩展 著名的以面向过程思想为指导的设计产品有Linux内核，git等软件。 可以说如果一个项目是按照面向过程思维进行开发，它应该是从小的细节一步一步实现，最终变为一个整体。 面向对象 面向对象（OOP）编程思想是目前主流的编程思想，它在对业务的分析上更加侧重于应当由谁来完成这份工作，将注意力放在了人的上面，而并非事物本身。 特性：抽象、封装、继承、多态 优点：易于维护、易于扩展 缺点：继承使得代码耦合度提高，并且性能较于面向过程来说略有损失 面向对象的本质就是整合，将具有某一共同特性的不同功能整合到一起进行分类。 如果一个项目是按照面向对象思维进行开发，它应该是先构建整体大局观，然后进行细节的丰富，而细节的丰富又最终回到了面向过程的思维上，因此面向对象和面向过程是不可分离的。 面向切面 面向切面（AOP）编程思想是面向对象的一种衍生。它旨在与将主逻辑业务和副逻辑业务进行切分，让彼此之间最大限度的降低耦合度。 此外，面向切面也能够在不损失已有功能的前提下，植入一个新的功能。 如Python装饰器函数，就是面向切面编程思想的最好体现。 特性：分离，低耦合，高内聚 优点：对扩展及其友好，因为各部都是分离的所以新功能添加上不会有太多的问题产生 缺点：如果设计过于混乱，则会让代码可读性降低，如一味使用装饰器来进行缝补，还不如重构整个项目 面向接口 面向接口（PO）编程思想是近些年来逐渐火热起来的一种编程思想，它将抽象与实现互相抽离，先定义接口规范，后进行逻辑实现。 面向接口与面向对象相结合，能够让项目更加健壮，并且可读性扩展性都会得到一定程度的提升。 特性：现实与抽象分离，抽象定义规范，现实指定逻辑 优点：具有良好的扩展性，增强代码可读性，便与后期维护 缺点：大幅度增加代码量 函数式编程 函数式编程是与数学函数高度结合的编程方式，纯粹的函数式编程语言没有变量只有常量，代码重复率较低，且功能一旦完善就不会出错。 在函数中没有for循环，所有的for循环用递归实现，函数式编程的一个特点就是允许把函数本身作为参数传入另一个参数，还允许返回一个函数。 此外，Python中的lambda以及filter，map，reduce等等都是从一些函数式编程语言如haskell中提取出来的一些优秀且符合Python核心思想的好案例。 特性：无变量，无for循环 优点：代码重复率低 缺点：程序易读性差 Python特性 Python本身是一门纯粹的面向对象语言，除此之外它也支持： 面向切面：装饰器就是最好的面向切面实现 面向接口：严格意义上来说Python并未提供真正完全的面向接口语法，但仍然可以实现 函数式编程：lambda、filter、map等都是Python中拥有的函数式编程实现 一门优秀的语言总是融百家之长，Python当然也不例外。 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:46 "},"Python/Python面向对象/类与对象.html":{"url":"Python/Python面向对象/类与对象.html","title":"类与对象","keywords":"","body":"类和对象 类是一个抽象的概念，而对象是一个实体的存在。 对象由类创造而出，每个对象之间互相独立互不影响，一个对象只能由一个类创建，但是一个类可以创建出多个对象，而实例化就是指通过某个类创建出对象的过程。 类与对象的关系类似于模具与产品，必须先有模具，然后才能根据这个模具制作出各式各样的产品。 基础介绍 定义类 Python中定义类，使用class关键字，具体语法如下: class 类标示符(继承类): # ❶ \"\"\" 类的描述文档 # ❷ \"\"\" 标示符 = 对象 # ❸ def __init__(self): # ❹ self.标示符 = 对象 def 实例方法(self): # ❺ pass ❶：类标识符以大驼峰命名 ❷：类的描述文档，用于介绍该类的作用 ❸：类属性，用于存放所有实例对象都可能用到的变量 ❹：初始化方法，用于初始化实例对象独有属性变量 ❺：实例化方法，用于提供给实例对象调用的函数 当一个类被定义时，将会发生以下的事情： 申请内存空间，保存类体代码 将内存空间的地址绑定给类的标示符 创建类的局部命名空间（注意与函数命名空间区分，函数是加括号调用执行后才创建） 执行类体代码（注意与函数的执行时机区分，函数是加括号调用后才会执行函数体代码） 下面将定义一个人类： class Person: \"\"\" Person：人类 class attr：眼耳口鼻 每个人都具有共同特性，可定义为类属性 instance attr: 姓名性别年龄 每个人不同的特征，可定义为实例属性 instance method: 吃饭 每个人都具有共同行为，可定义为实例方法 \"\"\" eye = 2 ear = 2 mouth = 2 nose = 1 def __init__(self, name, age, gender) -> None: self.name = name self.age = age self.gender = gender def eat(self, food): return \"%s eating %s\"%(self.name, food) def getInfo(self): return \"name : %s\\nage : %s\\ngender : %s\\n\"%(self.name, self.age, self.gender) 实例化 如何通过类创建出一个具体的对象？只需要在类标示符后加上括号即可，如下所示： if __name__ == \"__main__\": jack = Person(name=\"Jack\", age=18, gender=\"male\") print(jack.eat(\"fish\")) print(jack.getInfo()) # Jack eating fish # name : Jack # age : 18 # gender : male 类实例化的过程中会做很多事情，大概可分为下面3个步骤： 调用类下的__new__()方法构建一个空的实例对象 调用类下的__init__()方法对空实例对象进行初始化 于此同时，创建实例的专属命名空间 如何验证这一过程呢？我们可通过自定义__new__()方法进行证明： class A: def __new__(cls, *args, **kwargs) -> object: print(\"Run ... new\") instanceObject = super(A, cls).__new__(cls) return instanceObject def __init__(self, attr): print(\"Run ... init\") self.instanceAttr = attr if __name__ == \"__main__\": instanceA = A(\"a\") # Run ... new # Run ... init self、__new()__、__init__() __new__()方法是类实例化过程中运行的方法，作用是构建空的实例化对象，因此该方法也被称之为构造方法。 __init__()方法也是类实例化过程中运行的方法，作用是为空的实例化对象增添实例属性，因此该方法也被称之为对象的初始化方法，注意该方法必须返回None。 self其实就是指实例化对象本身，在实例化操作开始后实例化对象会由__new__()方法经过__init__()方法进行创建并返回。 所以你会看见下面3个标示符都是指向同1个对象： class A: def __new__(cls, *args, **kwargs) -> object: print(\"Run ... new\") instanceObject = super(A, cls).__new__(cls) print(id(instanceObject)) return instanceObject def __init__(self) -> None: print(\"Run ... init\") print(id(self)) def getInstanceId(self): print(\"Run ... instance method\") print(id(self)) if __name__ == \"__main__\": print(\"instance start\") instanceA = A() print(\"instance end\") print(id(instanceA)) instanceA.getInstanceId() # instance start # Run ... new # 29435600 # Run ... init # 29435600 # instance end # 29435600 # Run ... instance method # 29435600 __dict__ 类和实例对象都有一个__dict__，它是一个字典，包含类和对象的一些特征属性。 对于类的__dict__来说，它包含类属性、类方法、实例方法等一系列东西。 而对实例的__dict__来说，它仅包含实例属性。 如下所示： class A: name = \"class\" def __init__(self) -> None: self.name = \"instance\" def instanceMethod(self): pass if __name__ == \"__main__\": instanceA = A() print(A.__dict__) print(instanceA.__dict__) 结果展示，类的__dict__，包含的东西非常多： {'__module__': '__main__', 'name': 'class', '__init__': , 'instanceMethod': , '__dict__': , '__weakref__': , '__doc__': None} 而实例对象的__dict__只包含自身的实例属性，甚至连实例方法都在类的__dict__中： {'name': 'instance'} 属性与方法 类属性 如果要在类的外部获取类属性，可通过下面两种方式： 类.属性 类.__dict__[\"属性\"] 更加推荐第一种方式，它更加的直白，让人一眼就能看到这是在获取属性，而不是操纵字典： class A: name = \"class\" def __init__(self) -> None: self.name = \"instance\" def instanceMethod(self): pass if __name__ == \"__main__\": print(A.name) print(A.__dict__[\"name\"]) print(A.__dict__.get(\"name\")) # class # class # class 其他的类属性增删改查，也都是通过这两种方式进行操作，这里不再举例。 实例属性 外部获取实例属性与类属性一样，都是通过下面2种方式： 实例.属性 实例.__dict__[\"属性\"] 如下所示： class A: name = \"class\" def __init__(self) -> None: self.name = \"instance\" def instanceMethod(self): pass if __name__ == \"__main__\": instanceA = A() print(instanceA.name) print(instanceA.__dict__[\"name\"]) print(instanceA.__dict__.get(\"name\")) # instance # instance # instance 其他的操作诸如增删改等，都比较少用到，故不再进行举例。 实例方法 实例方法其实就是函数，我们可以看一下下面这个方法： class A: name = \"class\" def __init__(self) -> None: self.name = \"instance\" def instanceMethod(self, params): print(params) 如何调用它呢？ 方式1，通过实例对象调用它，会自动的将对象本身传递给self： if __name__ == \"__main__\": instanceA = A() instanceA.instanceMethod(\"hello world\") # hello world 方式2，通过类来调用它，但是需要你手动的为self传递参数： class A: name = \"class\" def __init__(self) -> None: self.name = \"instance\" def instanceMethod(self, params): print(params) if __name__ == \"__main__\": instanceA = A() A.instanceMethod(instanceA, \"hello world\") 方式2可能比较少见，但我们之前已经用过了，比如str.format()。 def format(self, *args: object, **kwargs: object) -> str 相同的结果，不同的调用方式，如下所示，self就是字符串\"hello {}\"： classRunFormatMethod = str.format(\"hello {}\", \"world\") instanceRunFormatMethod = \"hello {}\".format(\"world\") print(classRunFormatMethod) print(instanceRunFormatMethod) # hello world # hello world 内部获取 类属性可以在实例方法中进行获取，获取方式有2种： 类.属性 self.属性 # 前提是self.__dict__中没有同名属性 推荐使用第一种，指名道姓的说我要获取类属性： class A: name = \"class\" def __init__(self) -> None: self.name = \"instance\" def instanceMethod(self): print(A.name) print(self.name) if __name__ == \"__main__\": instanceA = A() A.instanceMethod(instanceA) # class # instance 实例属性在实例方法中获取直接通过下面的方式即可： self.属性 如下所示： class A: name = \"class\" def __init__(self) -> None: self.name = \"instance\" def instanceMethod(self): print(self.name) if __name__ == \"__main__\": instanceA = A() A.instanceMethod(instanceA) # instance 实例方法中可以嵌套调用另一个方法，也可以调用外部的函数，如下所示： class A: name = \"class\" def __init__(self) -> None: self.name = \"instance\" def func1(self): print(\"func1\") self.func2() globalFunc() def func2(self): print(\"func2\") def globalFunc(): print(\"globalFunc\") if __name__ == \"__main__\": instanceA = A() instanceA.func1() # func1 # func2 # globalFunc 命名空间 类和实例的命名空间 类和实例的命名空间说白了就是__dict__字典。 一个类拥有多个实例，一个实例仅来自于一个类。 因此我们可以画出下面这幅图： 首先，类的命名空间是无法访问实例的命名空间的。 但是实例命名空间可以访问类的命名空间，类似于函数嵌套LEGB的关系。 标示符查找顺序 如果一个实例要查找某一个属性，自身存在就获取自身的，若自身不存在则取拿类的。 查看实例自身的__dict__，若没有 则查看类的__dict__，若没有 则抛出异常 我们来看一下下面这个例子： class A: name = \"ClassAttr:A\" if __name__ == \"__main__\": instanceOne = A() instanceTwo = A() instanceThree = A() print(instanceOne.name) print(instanceTwo.name) print(instanceThree.name) A.name = \"ClassAttr:B\" print(instanceOne.name) print(instanceTwo.name) print(instanceThree.name) instanceOne.name = \"InstanceAttr:a\" print(instanceOne.name) print(instanceTwo.name) print(instanceThree.name) # ClassAttr:A # ClassAttr:A # ClassAttr:A # ClassAttr:B # ClassAttr:B # ClassAttr:B # InstanceAttr:a # ClassAttr:B # ClassAttr:B 采用图解的方式来进行代码注释。 第一种情况，三个实例的__dict__中都没有name，所以会去类的__dict__中查找： 第二种情况，类__dict__中的name被修改，三个实例再次访问name，自身的__dict__没有故到类的__dict__中找，会获取到修改后的name： 第三种情况，第一个实例对象One的__dict__中具有实例属性name，故它会拿到自己的，其他2个实例对象都没有，依然会去拿类的： Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:46 "},"Python/Python面向对象/类的方法.html":{"url":"Python/Python面向对象/类的方法.html","title":"类的方法","keywords":"","body":"实例方法 实例方法是存储在类的__dict__字典中，实例方法都有一个固定的参数名为self，位于第一个位置。 实例方法通常会通过实例对象调用，当实例对象调用实例方法时，会自动的将自身传递给self。 如下所示： class Student: def __init__(self, name): self.name = name def show(self): return \"my name is %s\"%self.name if __name__ == \"__main__\": instanceOne = Student(\"Jack\") instanceTwo = Student(\"Tom\") print(instanceOne.show()) # self = instanceOne print(instanceTwo.show()) # self = instanceTwo # my name is Jack # my name is Tom 它的底层是怎么做的呢？ 其实还是要从属性查找顺序开始剖析，如下所示： 第一步：查找实例自身的__dict__试图获取实例方法，但实例方法都存于与类的__dict__中，故找不到 第二步：查找类的__dict__成功获取实例方法 第三步：根据类的__dict__中所定义的实例方法，自动的为self参数传递进调用者，生成一个新的方法 所以你会看见下面这样的场景，3个方法，3个存储空间： class Student: def __init__(self, name): self.name = name def show(self): return \"my name is %s\"%self.name if __name__ == \"__main__\": instanceOne = Student(\"Jack\") instanceTwo = Student(\"Tom\") print(instanceOne.show) print(instanceTwo.show) print(Student.show) # > # > # 类的方法 类方法是指头部带有@classmethod装饰器的方法，类方法都有一个固定的参数名为cls，位于第一个位置。 类方法通常由类进行调用，同时会自动的将类传递进方法cls参数中，如下所示： class Student: def __init__(self, name): self.name = name def show(self): return \"my name is %s\"%self.name @classmethod def learn(cls): print(cls.__name__) return \"students must learn\" if __name__ == \"__main__\": print(Student.learn()) # cls = Student # Student # students must learn 当然也可以通过实例对象调用类方法，cls接收的对象不是实例本身而是类，但是不建议这么做： class Student: def __init__(self, name): self.name = name def show(self): return \"my name is %s\"%self.name @classmethod def learn(cls): print(cls.__name__) return \"students must learn\" if __name__ == \"__main__\": instanceObject = Student(\"Jack\") print(instanceObject.learn()) # cls = Student # Student # students must learn 静态方法 静态方法是指头部带有@staticmethod装饰器的方法。 常作为类的工具箱出现，类和实例都可以随意的对其调用，没有自动传入的参数self或者cls，就是一个类中的普通函数： class MathTools: @staticmethod def getMax(x, y): return x if x > y else y if __name__ == \"__main__\": print(MathTools.getMax(1, 2)) instanceObject = MathTools() print(instanceObject.getMax(1, 2)) # 2 # 2 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:46 "},"Python/Python面向对象/属性代理.html":{"url":"Python/Python面向对象/属性代理.html","title":"属性代理","keywords":"","body":"属性代理 属性代理是指通过@property描述符装饰器来规定用户对类或者实例中某一属性的操作做出行为限制的方式。 类似于JavaScript中的代理器，Vue中的计算属性等，Python中则称之为描述符。 计算获取 　BMI指数是用来衡量一个人的体重与身高对健康影响的一个指标，计算公式为： BMI指数计算公式: BMI = 体重(kg) / (身高m**2) BMI正常值在20至25之间，超过25为超重，30以上则属肥胖 身高或体重是不断变化的，因而每次想查看BMI值都需要通过计算才能得到，但很明显BMI听起来更像是一个特征而非功能。 为此Python专门提供了一个装饰器@property，可以将类中的方法伪装成属性，对象在访问该特殊属性时会触发功能的执行，然后将返回值作为本次访问的结果，例如： class Person: def __init__(self, name, height, weight): self.name = name self.height = height self.weight = weight @property def bmi(self): v = self.weight / (self.height ** 2) if 20 25: return \"overweight\" return \"obesity\" if __name__ == \"__main__\": instanceObject = Person(\"ken\", height=1.76, weight=77) # autoRun instanceObjectMethod => bmi(self=instanceObject) print(instanceObject.bmi) #　normal 行为控制 你也可以使用其他的形式，来控制属性的删改查等行为，如下所示： class Person: def __init__(self): self.__attr = None @property def name(self): \"\"\"获取name时自动触发该方法，只有当__attr不为None才能被获取到\"\"\" if not self.__attr is None: return self.__attr else: raise AttributeError(\"name is not set\") @name.setter def name(self, params): \"\"\"设置name时自动触发该方法，只有当params为 'Jack' 时才能成功为__attr赋值\"\"\" if params != \"Jack\": raise AttributeError(\"name must setting is string 'Jack', but you set is %s\"%params) else: self.__attr = params @name.deleter def name(self): \"\"\"删除name时自动触发该方法，不允许删除name\"\"\" raise AttributeError(\"name not should delete\") if __name__ == \"__main__\": instanceObject = Person() instanceObject.name = \"Jack\" print(instanceObject.name) del instanceObject.name # Jack # AttributeError: name not should delete 行为控制 行为控制还有另外一种形式，它是固定的用法，如下所示，效果和上面一样： class Person: def __init__(self): self.__attr = None def nameGet(self): \"\"\"获取name时自动触发该方法，只有当__attr不为None才能被获取到\"\"\" if not self.__attr is None: return self.__attr else: raise AttributeError(\"name is not set\") def nameSet(self, params): \"\"\"设置name时自动触发该方法，只有当params为 'Jack' 时才能成功为__attr赋值\"\"\" if params != \"Jack\": raise AttributeError(\"name must setting is string 'Jack', but you set is %s\"%params) else: self.__attr = params def nameDelete(self): \"\"\"删除name时自动触发该方法，不允许删除name\"\"\" raise AttributeError(\"name not should delete\") name = property(fget=nameGet, fset=nameSet, fdel=nameDelete) if __name__ == \"__main__\": instanceObject = Person() instanceObject.name = \"Jack\" print(instanceObject.name) del instanceObject.name # Jack # AttributeError: name not should delete Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:46 "},"Python/Python面向对象/封装.html":{"url":"Python/Python面向对象/封装.html","title":"封装","keywords":"","body":"oop封装 封装是oop思想中最重要的一个，也是所有面向对象程序设计中始终绕不开的话题，说白了就是将数据和功能整合到一起。 类本身就属于封装，如定义一个类，该类中的属性以及方法只有该类或者其实例化对象才能调用，这就是类封装的体现。 除此之外，oop封装中还有2个十分重要的名词，即： 私有属性 公有属性 私有属性 类的私有属性是指在类中以_下划线开头，或者以__下划线开头命名的标示符。 它们都是指将该标示符属性隐藏，仅用于类的内部调用，不希望甚至不支持在类的外部访问这些属性。 单下封装 单下封装是指在类中以_下划线开头的标示符，它意味着使用者不应该在类的外部访问该属性，但实际上外部仍然可以访问。 如下示例，对于女孩子来说，年龄是一项比较私密的属性，因此可以使用单下命名法将该属性隐藏。 即告诉别人，我不想要你知道我的年龄，但是你要强求也是可以得到的： class Person: def __init__(self, name, age, gender) -> None: self.name = name self.gender = gender if self.gender == \"male\": self.age = age elif self.gender == \"female\": self._age = age def getInfo(self): message = \"name : %s\\ngender : %s\\n\"%(self.name, self.gender) if self.gender == \"male\": message += \"age : %d\"%self.age elif self.gender == \"female\": if 18 > self._age: # ❶ message += \"age : underage\" elif 18 ❶：对于单下命名的属性，应当在类的内部进行调用 ❷：虽然能够在外部获取到Mary的年龄，但是不建议这样使用，正确的做法应该是调用getInfo()方法获取信息 双下封装 双下封装是指在类中以__下划线开头的标示符，它意味着使用者应当禁止在类的外部访问该属性，但通过特殊的手段也是能访问到的。 如下示例，对于女孩子来说，体重是一项绝对私密的属性，因此可以使用双下命名法将该属性隐藏。 即告诉别人，你不可以通过常规手段获得我的体重： class Person: def __init__(self, name, gender, weight) -> None: self.name = name self.gender = gender if self.gender == \"male\": self.weight = weight elif self.gender == \"female\": self.__weight = weight def getInfo(self): message = \"name : %s\\ngender : %s\\n\" % (self.name, self.gender) if self.gender == \"male\": message += \"weight : %s(kg)\" % self.weight elif self.gender == \"female\": if 45 > self.__weight: # ❶ message += \"weight : thin\" elif 45 55: message += \"weight : normal\" else: message += \"weight : fat\" return message if __name__ == \"__main__\": jack = Person(name=\"Jack\", gender=\"male\", weight=60) print(jack.getInfo()) print(jack.weight) mary = Person(name=\"Mary\", gender=\"female\", weight=50) print(mary.getInfo()) print(mary.__weight) # ❷ # name : Jack # gender : male # weight : 60(kg) # 60 # name : Mary # gender : female # weight : fat # AttributeError: 'Person' object has no attribute '__weight' ❶：对于双下命名的属性，应当在类的内部进行调用 ❷：外部调用该属性直接抛出异常，找不到，所以应当使用getInfo()方法获取信息 双下重命名 其实双下封装法只是将属性重命名了，通过实例对象的__dict__可以查看到： if __name__ == \"__main__\": mary = Person(name=\"Mary\", gender=\"female\", weight=50) print(mary.__dict__) # {'name': 'Mary', 'gender': 'female', '_Person__weight': 50} 命名规则是： _类名__属性 所以，双下封装的属性其实在外部也能获取到，但是不推荐这么做，有悖于规范，如下所示： if __name__ == \"__main__\": mary = Person(name=\"Mary\", gender=\"female\", weight=50) print(mary._Person__weight) # 50 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:46 "},"Python/Python面向对象/继承.html":{"url":"Python/Python面向对象/继承.html","title":"继承","keywords":"","body":"oop继承 继承介绍 继承作为oop三大特性之一，可以说是最难的一章知识点，但是用的非常多。 继承是指创建类的一种方式，极大程度上规避了类与类之间代码的重复问题。 在Python中，是支持多继承的，即一个类可以继承多个类，这是其他大多数语言中所不支持的。 被继承的类可以称为父类，超类或者基类 继承的类可以称为子类或者派生类 派生类可以使用父类所有的属性及方法，但是父类是不能使用派生类的属性或方法的。 以下是语法格式： class 类标示符(父类1, 父类2): ... 举一个简单的例子，下面定义了一个狼（Wolf）类和狗（Dog）类，它们都具有相同的方法咬人（bite）、跑步（run）等，由于继承的存在故不用将该方法书写两次，直接使用狗类继承狼类即可： class Wolf: def __init__(self, name) -> None: self.name = name def bite(self, personName): return \"%s biting %s\" % (self.name, personName) def run(self): return \"%s runing...\" % self.name class Dog(Wolf): pass if __name__ == \"__main__\": wolfInstance = Wolf(\"King Kong\") print(wolfInstance.bite(\"Tom\")) print(wolfInstance.run()) print(\"=\" * 10) dogInstance = Dog(\"Small Black\") print(dogInstance.bite(\"Jack\")) print(dogInstance.run()) # King Kong biting Tom # King Kong runing... # ========== # Small Black biting Jack # Small Black runing... 方法覆写 如果派生类中拥有和父类同名的方法或者属性，则派生类或者其实例对象在查找这些属性或方法时只会拿自己的。 如下所示，在Dog类中重写了bite，让它不再咬人： class Wolf: def __init__(self, name) -> None: self.name = name def bite(self, personName): return \"%s biting %s\" % (self.name, personName) def run(self): return \"%s runing...\" % self.name class Dog(Wolf): def bite(self, personName): return \"%s not biting, %s escaped \" % (self.name, personName) if __name__ == \"__main__\": wolfInstance = Wolf(\"King Kong\") print(wolfInstance.bite(\"Tom\")) print(wolfInstance.run()) print(\"=\" * 10) dogInstance = Dog(\"Small Black\") print(dogInstance.bite(\"Jack\")) print(dogInstance.run()) # King Kong biting Tom # King Kong runing... # ========== # Small Black not biting, Jack escaped # Small Black runing... Python3 新式类 Python3中默认的所有类都继承了object类，这样的类被称为新式类： class A: # eq class A(object) pass if __name__ == \"__main__\": print(A.__bases__) # (,) 单继承 新式类单继承查找公有属性、方法时，每轮按照一条线的向上查找次序，如下图所示： 代码示例： class A: def show(self): print(\"--- A.show run ---\") self.info() def info(self): print(\"--- A.info run ---\") def __getattribute__(self, name: str): print(\"find A.%s\" % name) return super().__getattribute__(name) class B(A): def info(self): print(\"--- B.info run ---\") def __getattribute__(self, name: str): print(\"find B.%s\" % name) return super().__getattribute__(name) class C(B): def info(self): print(\"--- C.info run---\") def __getattribute__(self, name: str): print(\"find C.%s\" % name) return super().__getattribute__(name) if __name__ == \"__main__\": instanceC = C() instanceC.show() # find C.show # find B.show # find A.show # --- A.show run --- # find C.info # find B.info # find A.info # --- C.info run--- 而新式类如果是单继承查找私有属性、方法则结果又不一样，如下图所示： 代码示例： class A: def show(self): print(\"--- A.show run ---\") self.__info() def __info(self): print(\"--- A.__info run ---\") def __getattribute__(self, name: str): print(\"find A.%s\" % name) return super().__getattribute__(name) class B(A): def __info(self): print(\"--- B.__info run ---\") def __getattribute__(self, name: str): print(\"find B.%s\" % name) return super().__getattribute__(name) class C(B): def __info(self): print(\"--- C.__info run---\") def __getattribute__(self, name: str): print(\"find C.%s\" % name) return super().__getattribute__(name) if __name__ == \"__main__\": instanceC = C() instanceC.show() # find C.show # find B.show # find A.show # --- A.show run --- # find C._A__info # find B._A__info # find A._A__info # --- A.__info run --- 普通多继承 Python3中的新式类普通多继承，会按照深度优先的查找策略查找整个继承树。 深度优先：从左至右查找，每条分支查到最顶部，最后查找object类 如下图所示： 代码示例： class A: def __getattribute__(self, name: str): print(\"find A.%s\" % name) return super().__getattribute__(name) class B(A): def __getattribute__(self, name: str): print(\"find B.%s\" % name) return super().__getattribute__(name) class C(B): def show(self): print(\"--- C.show run ---\") def __getattribute__(self, name: str): print(\"find C.%s\" % name) return super().__getattribute__(name) class D: def __getattribute__(self, name: str): print(\"find D.%s\" % name) return super().__getattribute__(name) class E(D): def __getattribute__(self, name: str): print(\"find E.%s\" % name) return super().__getattribute__(name) class F: def __getattribute__(self, name: str): print(\"find F.%s\" % name) return super().__getattribute__(name) class G(C, E, F): def __getattribute__(self, name: str): print(\"find G.%s\" % name) return super().__getattribute__(name) if __name__ == \"__main__\": instanceG = G() instanceG.show() # find G.show # find C.show # find B.show # find A.show # find E.show # find D.show # find F.show # --- C.show run --- 钻石多继承 钻石多继承也被称为死亡菱形继承，继承关系如下所示： Python3中的新式类钻石多继承，会按照广度优先的查找策略查找整个继承树。 广度优先：从左至右查找，每条分支查到顶部第二个类超类，也就是不查钻石基类，如果都没有才查找钻石基类，最后查找object类 如下图所示： 代码示例： class A: def show(self): print(\"--- A.show run ---\") def __getattribute__(self, name: str): print(\"find A.%s\" % name) return super().__getattribute__(name) class B(A): def __getattribute__(self, name: str): print(\"find B.%s\" % name) return super().__getattribute__(name) class C(A): def __getattribute__(self, name: str): print(\"find C.%s\" % name) return super().__getattribute__(name) class D(A): def __getattribute__(self, name: str): print(\"find D.%s\" % name) return super().__getattribute__(name) class E(B): def __getattribute__(self, name: str): print(\"find E.%s\" % name) return super().__getattribute__(name) class F(C): def __getattribute__(self, name: str): print(\"find F.%s\" % name) return super().__getattribute__(name) class G(D): def __getattribute__(self, name: str): print(\"find G.%s\" % name) return super().__getattribute__(name) class H(E): def __getattribute__(self, name: str): print(\"find H.%s\" % name) return super().__getattribute__(name) class I(H, F, G): def __getattribute__(self, name: str): print(\"find I.%s\" % name) return super().__getattribute__(name) if __name__ == \"__main__\": instanceI = I() instanceI.show() # find I.show # find H.show # find E.show # find B.show # find F.show # find C.show # find G.show # find D.show # find A.show # --- A.show run --- Python2 经典类 Python2中如果一个类没有继承object类，这种类被称为经典类。 反之，如果继承了object类，则被称为新式类。 如下所示： # Python2中的经典类，也就是Python3中的新式类 class A: pass # Python2中的新式类 class A(object): pass 换而言之，Python2的类有新式类和经典类2种，Python3中仅有新式类，取消了经典类的设定。 不论是Python2的新式类还是Python3的新式类，它们的查找过程都是相同的，故下面只会例举经典类的查找顺序。 单继承 经典类在单继承的情况下，和新式类的查找顺序一致。 普通多继承 不管是新式类还是经典类，在普通多继承的查找下都是深度优先策略： 深度优先：从左至右查找，每条分支查到最顶部 由于不能使用__getattribute__()方法来查看整个查找过程，故这里就不再进行代码示例了。 感兴趣的朋友可以自行测试一下。 钻石多继承 钻石多继承中，经典类采用的是深度优先策略，而新式类则采用的广度优先策略。 深度优先：从左至右查找，每条分支查到最顶部，也就是说钻石基类在第一轮就会被查到 图示如下： 由于不能使用__getattribute__()方法来查看整个查找过程，故这里就不再进行代码示例了。 感兴趣的朋友可以自行测试一下。 双下属性 __class__ instanceObject.__class__属性可以查看实例对象所属的类： class A: pass if __name__ == \"__main__\": instanceObject = A() print(instanceObject.__class__) # __main__.A __base__ className.__base__属性可查看到类的父类，仅Python3有效，返回类对象： class A: pass class B(A): pass class C(B): pass if __name__ == \"__main__\": print(C.__base__) # __bases__ className.__bases__属性可查看到类的父类，仅Python3有效，返回元组，索引0处是其父类： class A: pass class B(A): pass class C(B): pass if __name__ == \"__main__\": print(C.__bases__) # (,) __mro__ 类的属性查找顺序在类定义时底层会根据C3算法生成，使用className.__mro__可调用出该查找顺序。 返回一个列表，列表中嵌套各种父类、超类，也就是说这是一个属性查找顺序列表。 注意，仅在Python3中生效。 下面是新式类普通多继承属性查找顺序，和上面测试的结果一致： class A: pass class B(A): pass class C(B): pass class D: pass class E(D): pass class F: pass class G(C, E, F): pass if __name__ == \"__main__\": print(G.__mro__) # (, , , , , , , ) 下面是新式类钻石多继承属性查找顺序，和上面测试的结果一致： class A: pass class B(A): pass class C(A): pass class D(A): pass class E(B): pass class F(C): pass class G(D): pass class H(E): pass class I(H, F, G): pass if __name__ == \"__main__\": print(I.__mro__) # (, , , , , , , , , ) 方法借用 class.attr 如果一个类和另一个类没有任何关系，但是要借用运行其下方法时，可以选择指名道姓的通过类来调用其下方法。 必须手动传入所有参数，如下所示： class A: def func(self): print(\"run A instance method\") class B: def func(self): print(\"run B instance method\") A.func(self=self) if __name__ == \"__main__\": B().func() # run B instance method # run A instance method super() 如果一个类和另一个类有继承关系，则可以通过super()方法自动向后查找其父类中需要借用的方法并执行。 它本质上会做两件事： 调用__mro__，拿到属性查找顺序列表 确定当前类在列表中的位置，并且拿到其父类，再自动使用class.attr的方式指名道姓的运行父类方法 所以，使用super()方法进行方法借用时，也需要手动传入所有参数，但是传入的参数与class.attr的方式有所不同。 具体的函数签名如下： super(__class__, ) 使用案例： class A: def func(self): print(\"run A instance method\") class B(A): def func(self): print(\"run B instance method\") super(__class__, self).func() # ❶ ❷ if __name__ == \"__main__\": B().func() # run B instance method # run A instance method ❶：传入__class__，用于确认该类在__mro__所返回的属性查找顺序列表中的位置，以便确定后面的父类查找 ❷：传入self，它将自动把self传递给A.func()的第一个参数 注意事项： Python3的super()方法中参数可以不传递，它会自动进行补充 Python2的经典类如果想使用super()方法，则必须在文件顶部添加一句代码 ： __metaclass__ = type，否则无法使用 Python2的super()方法中参数必须传递，不可进行省略 Mixins机制 Python由于支持多继承的关系，故在某些情况下可能导致代码逻辑不通顺的问题出现，如下所示： 为了能让基类的作用更加强大，符合一切交通工具的特性，你可能会在交通工具基类里面定义下面的方法： 飞行方法 抛锚方法 刹车方法 那么这个时候就已经产生了逻辑问题： 轮船不会飞，也不会刹车，但作为交通工具基类的派生类，它也能调用这些方法 汽车不会飞，也不会抛锚，但作为交通工具基类的派生类，它也能调用这些方法 飞机不会刹车，也不会抛锚，但作为交通工具基类的派生类，它也能调用这些方法 代码示例： class Transportation: def __init__(self, name) -> None: self.name = name def fly(self): \"\"\" 飞 \"\"\" print(\"%s flying\" % self.name) def brake(self): \"\"\" 刹车 \"\"\" print(\"%s braking\" % self.name) def anchor(self): \"\"\" 抛锚 \"\"\" print(\"%s anchor\" % self.name) class Aircraft(Transportation): pass class Car(Transportation): pass class Ship(Transportation): pass if __name__ == \"__main__\": aircraft = Aircraft(\"Boeing 747\") car = Car(\"BMW\") ship = Ship(\"Titanic\") # Serious Problem aircraft.brake() aircraft.anchor() car.fly() car.anchor() ship.fly() ship.brake() # Boeing 747 braking # Boeing 747 anchor # BMW flying # BMW anchor # Titanic flying # Titanic braking 如何解决这个问题呢？我们可以使用Mixins机制，将刹车、抛锚、飞行这3个不同的功能单独的封装到下面3个类中： 汽车功能类：刹车 飞机功能类：飞行 轮船功能类：抛锚 子类只需要继承交通工具基类和对应的功能类即可，如下图所示： 代码示例如下： class Transportation: def __init__(self, name) -> None: self.name = name class AircraftMixin: def fly(self): \"\"\" 飞 \"\"\" print(\"%s flying\" % self.name) class CarMixin: def brake(self): \"\"\" 刹车 \"\"\" print(\"%s braking\" % self.name) class ShipMixin: def anchor(self): \"\"\" 抛锚 \"\"\" print(\"%s anchor\" % self.name) class Aircraft(Transportation, AircraftMixin): pass class Car(Transportation, CarMixin): pass class Ship(Transportation, ShipMixin): pass if __name__ == \"__main__\": aircraft = Aircraft(\"Boeing 747\") car = Car(\"BMW\") ship = Ship(\"Titanic\") aircraft.fly() car.brake() ship.anchor() # Boeing 747 flying # BMW braking # Titanic anchor Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:46 "},"Python/Python面向对象/多态.html":{"url":"Python/Python面向对象/多态.html","title":"多态","keywords":"","body":"oop多态 多态更多的是指的一种思想，而非具体技术。 因为继承的存在，从而引发了多态，举个例子，所有的生物都是由一个单细胞生物不断演化而来，迄今为止它们的差异越来越大，这就是多态的体现。 多态的定义其实更准确的说法是：在不同类中实例化得到的不同对象调用一个相同方法时，它们的实现过程并不一样。 Python本身就实现了多态，其中len()方法就是最好的多态体现，2个不同类的实例化对象调用相同方法，该方法内部的处理是完全不同的： lst = [i for i in range(10)] tpl = tuple(i for i in range(10)) print(len(lst)) print(len(tpl)) # 10 # 10 多态实现 为了能够更好的理解多态，我们可以用下面这段代码来阐述。 首先，有一个犬科（Canine）的类，实现了吼叫（howl）的方法。 然后，狼（Wolf）和狗（Dog）类均继承自该类，它们都有一个吼叫的方法，但是由于狼和狗还是有很大差距的，所以该方法的内部实现过程并不一样，这就是多态的体现。 即：犬科具有吼叫方法，但同属犬科的狼和狗的吼叫是不同的。 class Canine: def howl(self): pass class Wolf(Canine): def howl(self): return \"wolf howling : ao~ ao~ ao~\" class Dog(Canine): def howl(self): return \"dog howling : wang~ wang~ wang~\" if __name__ == \"__main__\": wolfInstance = Wolf() dogInstance = Dog() print(wolfInstance.howl()) print(\"=\" * 10) print(dogInstance.howl()) # wolf howling : ao~ ao~ ao~ # ========== # dog howling : wang~ wang~ wang~ duke type 鸭子类型（duke type）是一个很有趣的词汇。 它指的是我不管你是不是鸭子，只要你具备了某些鸭子的特性，如会嘎嘎嘎，走路会摇摇晃晃等我就认为你是鸭子。 那它到底有什么好处呢？其实这样做是为了方便使用者进行方法调用。 如tuple和list，它们何其相似，如果你知道list.index()这个方法，你肯定也会尝试tuple.index()方法，结果发现居然还真的有。 鸭子类型与继承毫无关系，它强调的也是一种抽象的分类，如list和tuple同属线性结构，应该都能使用index()方法，也应当都能使用len()方法。 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:46 "},"Python/Python面向对象/抽象基类.html":{"url":"Python/Python面向对象/抽象基类.html","title":"抽象基类","keywords":"","body":"抽象基类 接口（interface）和抽象基类（abstract base class）是非常相似的，Python中并未提供真正意义上的接口，但是提供了抽象基类的使用。 抽象基类的作用在于： 约束子类实现，子类必须实现抽象基类中的所有抽象方法才能被实例化，否则将不可被实例化 举个例子，羊（Sheep）和狼（Wolf）都属于哺乳类（Breastfeeding），那么它们都至少具有1个方法名为哺乳（feeding），如果没有该方法，则该类不能被实例化。 其实说白了，抽象基类的作用就是规范子类实现，所以： 抽象基类仅用于被继承，不必对其进行实例化 抽象基类内部方法不必实现 而接口则是为了规范类的实现，它规定了一系列方法和属性，只有实现了这些方法和属性的类才能被算作这一个接口的实现类。 接口是针对所有类的实现的 接口规定了类的用途，举个例子，如果你这个类提供了支付方法和退款方法，那么就可以将其视为一个支付接口类，该类可用作支付功能，否则该类将不能用于支付功能 而抽象基类只是针对子类的实现的 抽象基类规定了子类的形状，你想继承我，就必须拥有我的一些特点，否则就不能算我的子类 说起来可能有点晕，抽象基类和接口并不是面向对象语言所必须的，但他们的出现却能让代码的编写变的更有逻辑。 abc Python中用abc模块定义抽象基类，只需要将抽象基类的metaclass=abc.ABCMeta即可。 除此之外，它还提供了3个装饰器： abc.abstractclassmethod：抽象类方法 abc.abstractstaticmethod：抽象静态方法 abc.abstractmethod：抽象实例方法 代码示例如下： import abc class Breastfeeding(metaclass=abc.ABCMeta): @abc.abstractmethod def feeding(self): pass class Sheep(Breastfeeding): def feeding(self): return \"sheep feeding\" class Wolf(Breastfeeding): pass if __name__ == \"__main__\": sheepInstance = Sheep() print(\"sheep class instance success!\") wolfInstance = Wolf() # sheep class instance success! # TypeError: Can't instantiate abstract class Wolf with abstract methods feeding 这个例子中，羊实现了哺乳的方法，所以实例化成功了，而狼则没有实现哺乳方法，故实例化失败了。 如果有1个狗（Dog）类继承了狼类，那么狗类能否受到抽象基类的影响呢？ 答案是不能，抽象基类只能影响其下一代继承类的实现，不能影响其孙系类。 如下所示： import abc class Breastfeeding(metaclass=abc.ABCMeta): @abc.abstractmethod def feeding(self): pass class Sheep(Breastfeeding): def feeding(self): return \"sheep feeding\" class Wolf(Breastfeeding): def feeding(self): return \"wolf fedding\" class Dog(Wolf): pass if __name__ == \"__main__\": sheepInstance = Sheep() print(\"sheep class instance success!\") wolfInstance = Wolf() print(\"wolf class instance success!\") dogInstance = Dog() print(\"dog class instance success!\") # sheep class instance success! # wolf class instance success! # dog class instance success! 继承约束 通过继承，也能进行子类的行为约束，但是常规手段不能禁止其实例化。 如下所示，狼类没有实现哺乳方法，依然实例化成功了，但是不能调用哺乳方法： class Breastfeeding: def feeding(self): raise AssertionError(\"%s must implement method feeding\" % (self.__class__.__name__)) class Sheep(Breastfeeding): def feeding(self): return \"sheep feeding\" class Wolf(Breastfeeding): pass if __name__ == \"__main__\": sheepInstance = Sheep() print(\"sheep class instance success!\") print(sheepInstance.feeding()) wolfInstance = Wolf() print(\"wolf class instance success!\") print(wolfInstance.feeding()) # sheep class instance success! # sheep feeding # wolf class instance success! # AssertionError: Wolf must implement method feeding 上面这种方式在很多框架中也被经常使用到，但如果你想实现和ABCMeta同样的效果，可以覆写基类的__new__()方法，如下所示： class Breastfeeding: def __new__(cls) -> object: for attr in Breastfeeding.__dict__: if attr.startswith(\"__\"): continue if attr not in cls.__dict__: raise TypeError(\"Can't instantiate abstract class %s with abstract methods %s\" % (cls.__name__, attr)) return super(Breastfeeding, cls).__new__(cls) def feeding(self): pass class Sheep(Breastfeeding): def feeding(self): return \"sheep feeding\" class Wolf(Breastfeeding): pass if __name__ == \"__main__\": sheepInstance = Sheep() print(\"sheep class instance success!\") print(sheepInstance.feeding()) wolfInstance = Wolf() print(\"wolf class instance success!\") print(wolfInstance.feeding()) # sheep class instance success! # sheep feeding # TypeError: Can't instantiate abstract class Wolf with abstract methods feeding Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:46 "},"Python/Python面向对象/自省反射.html":{"url":"Python/Python面向对象/自省反射.html","title":"自省反射","keywords":"","body":"自省反射 自省和反射是两个比较专业化的术语，释义如下： 自省是指获取对象的能力 反射是指操纵对象的能力 由于Python是一门强类型的动态解释型语言，所以它的自省和反射使用非常简单。 我们在某些时候并不知道对象中具有的属性与方法，尤其是接手别人的项目时这种情况更加明显。 在这种情况下，我们不能直接通过Object.__dict__来获取其对象的属性与方法（因为这样获取不到继承的属性），而应当先使用自省来获取对象信息后，再使用反射来操纵对象，故自省和反射的学习显得尤为重要。 以下举例常见自省与反射的函数： 函数 返回值 描述 help(object) None 获取对象文档帮助信息 dir(object) list 获取对象下所有能被.操纵的属性与方法 hasattr(object, str) bool 返回对象是否具有给定名称的属性或方法 getattr(object, str, default) attr 获取对象中指定的属性或方法，若该属性或方法不存在，则抛出AttributeError异常，若设置默认值，则在属性或方法不存在时返回默认值 setattr(object, str, any) None 设置对象中某一属性或方法的值 delattr(object, str) None 删除对象中某一指定属性或方法 issubclass(subClass, parentClass) bool 判定一个类是否是另一个类的子类 isinstance(instance, class) bool 判定一个对象是否是另一个类的实例 callable(object) bool 判定该对象是否可调用 示例演示 help(object)能够获取对象文档帮助信息。 返回None： >>> help(int) Help on class int in module builtins: class int(object) | int(x=0) -> integer | int(x, base=10) -> integer | | Convert a number or string to an integer, or return 0 if no arguments | are given. If x is a number, return x.__int__(). For floating point | numbers, this truncates towards zero. | | If x is not a number or if base is given, then x must be a string, | bytes, or bytearray instance representing an integer literal in the | given base. The literal can be preceded by '+' or '-' and be surrounded ... dir(object)能够获取对象下所有能被.操纵的属性与方法。 返回list： >>> dir(list) ['__add__', '__class__', '__contains__', '__delattr__', '__delitem__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__getitem__', '__gt__', '__hash__', '__iadd__', '__imul__', '__init__', '__init_subclass__', '__iter__', '__le__', '__len__', '__lt__', '__mul__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__reversed__', '__rmul__', '__setattr__', '__setitem__', '__sizeof__', '__str__', '__subclasshook__', 'append', 'clear', 'copy', 'count', 'extend', 'index', 'insert', 'pop', 'remove', 'reverse', 'sort'] hasattr(object, str)能够返回对象是否具有给定名称的属性或方法。 返回bool： >>> hasattr(list, \"index\") True >>> hasattr(list, \"items\") False getattr(object, str, default)能够获取对象中指定的属性或方法，若该属性或方法不存在，则抛出AttributeError异常，若设置默认值，则在属性或方法不存在时返回默认值： >>> method = getattr(list, \"index\") >>> method >>> method([1, 2, 3], 2) 1 setattr(object, str, any)能够设置对象中某一属性或方法的值。 返回None： >>> class A: ... pass ... >>> A.__doc__ None >>> setattr(A, \"__doc__\", \"help message\") >>> A.__doc__ help message delattr(object, str)能够删除对象中某一指定属性或方法。 返回None： >>> class A: ... classAttr = \"attr\" ... >>> A.classAttr 'attr' >>> delattr(A, \"classAttr\") >>> A.classAttr AttributeError: type object 'A' has no attribute 'classAttr' issubclass(subClass, parentClass)可以判定一个类是否是另一个类的子类。 返回bool： >>> issubclass(bool, int) True isinstance(instance, class)可以判定一个对象是否是另一个类的实例。 返回bool： >>> isinstance(1, bool) False >>> isinstance(True, bool) True 常用操作 当不确定对象中是否具有某一属性或方法时，可以使用hasattr()，getattr()以及callable()进行组合使用。 如下所示： import sys class YunPan: \"\"\" this is YunPan. You can specify start-up parameters on the command line. If the specified parameter is attribute, this property will be displayed. If the specified parameter is called, the method is performed The parameters you can specify now are: Help: Get help information The method you can specify is: Download: Test Download Features, Parameters -> Str UPLOAD: Test Upload Energy, Parameters -> Str Raises: TypeError: If there is no such method or attribute in the class, it will throw an exception. \"\"\" help = __doc__ def __init__(self) -> None: self.attrOrMethod = sys.argv[1] self.fileName = sys.argv[2] if len(sys.argv) > 2 else None self.choices() def download(self): print(\"downloading file : %s\"%self.fileName) def upload(self): print(\"uploading file : %s\"%self.fileName) def choices(self): if not hasattr(self, self.attrOrMethod): raise TypeError(\"%s not implement method or attributes:%s\"%(self.__class__.__name__, self.attrOrMethod)) attrOrMethod = getattr(self, self.attrOrMethod) if callable(attrOrMethod): return attrOrMethod() print(attrOrMethod) if __name__ == \"__main__\": YunPan() 测试结果： $ python3 .\\demo.py help this is YunPan. You can specify start-up parameters on the command line. If the specified parameter is attribute, this property will be displayed. If the specified parameter is called, the method is performed The parameters you can specify now are: Help: Get help information The method you can specify is: Download: Test Download Features, Parameters -> Str UPLOAD: Test Upload Energy, Parameters -> Str Raises: TypeError: If there is no such method or attribute in the class, it will throw an exception. $ python3 .\\demo.py download TestFile downloading file : TestFile $ python3 .\\demo.py upload TestFile uploading file : TestFile $ python3 .\\demo.py func .. TypeError: YunPan not implement method or attributes:func Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:46 "},"Python/Python面向对象/双下大全.html":{"url":"Python/Python面向对象/双下大全.html","title":"双下大全","keywords":"","body":"特殊的双下 在Python中有很多特殊的方法函数，如__init__()、__new__()等。 除此之外，也有很多特殊的属性变量，如__base__，__class__等。 这些属性变量或者方法函数经常被人称其为“魔法方法”，个人并不是很喜欢这种叫法。 我更喜欢称呼他们为双下方法或者双下属性，因为“魔法”一词总是带有玄幻的色彩，但在计算机领域中如果你觉得一个知识点过于玄幻，说明你并未真正的理解它。 言归正传，那么它们具体有什么作用呢？如下所示： 双下方法：在满足某一特定的条件下进行自动调用 双下属性：本身就含有一定的意义 本章节我们将先探讨双下方法，而后探讨双下属性。 双下方法 对象相关 __new__() 对象的构造方法，用于构建实例对象。 在类加括号时自动调用，创建并返回一个空的实例对象。 参数释义： cls：被实例化的类本身 args： 实例化类时传入的位置参数 kwargs： 实例化类时传入的关键字参数 返回值： object：实例化对象 应用场景： 实现单例模式，函数二次封装等 如下所示： class Category: def __new__(cls, *args, **kwargs) -> object: print(cls) print(args) print(kwargs) instanceObject = super(__class__, cls).__new__(cls) return instanceObject if __name__== \"__main__\": instance = Category(\"positionParams\", k=\"keyWordParams\") # # ('positionParams',) # {'k': 'keyWordParams'} __init__() 对象的初始化方法，用于构建实例对象，可以理解为为实例对象的__dict__填充内容。 在类加括号时自动调用，返回None： 参数释义： self：实例本身，也就是由__new__()创建出的空对象 返回值： None：该方法必须返回None 应用场景： 基本上适用于所有定义类的场景 如下所示： class Category: def __init__(self, params) -> None: self.k = params if __name__== \"__main__\": instance = Category(\"v\") print(instance.__dict__) # {'k': 'v'} __call__() 对象的调用方法，当对象后面加上括号时自动触发。 参数释义： self：实例本身，也就是由__new__()创建出的空对象 返回值： Any：任意值 应用场景： 它是内置函数callable()的判断依据，当callable(object)时，会判断object内部是否实现了该方法从而返回True或者False 如下所示，经过该方法实现，现在普通实例对象加括号会打印出其属性查找顺序： class Category: x = 1 def __call__(self): findList = list(self.__class__.__mro__) findList.insert(0, self) return tuple(findList) if __name__== \"__main__\": instance = Category() print(instance()) # (, , ) __del__() 对象的析构方法，当手动 del object 删除对象，或者在程序运行结束后自动触发。 参数释义： self：实例本身，也就是由__new__()创建出的空对象 返回值： None 应用场景： 用于关闭一些占据系统资源的操作，如文件资源，网络资源 如下所示： class Category: x = 1 def __del__(self): print(\"run ... __del__()\") if __name__== \"__main__\": instance = Category() del instance # run ... __del__() 示例，自定义文件操作类，可用于自动关闭文件： class OpenFile: def __init__(self, *args, **kwargs) -> None: self.__file = open(*args, **kwargs) def __getattr__(self, name:str): return getattr(self.__file, name) def __del__(self): print(\"auto file close\") self.__file.close() if __name__== \"__main__\": fileObject = OpenFile(file=\"./test.txt\", mode=\"rt\", encoding=\"utf8\") print(fileObject.read(32)) 属性操作 __getattribute__() 当要查找某一个属性或者方法时，都会触发该方法。 如要查找的属性或者方法存在，则返回该属性或方法。 否则抛出AttributeError的异常。 参数释义： self：实例本身，也就是 . 前面的对象 name：要查找的属性或方法 返回值： Any：要查找的方法或者属性 应用场景：自定义容器的方法查找，内置函数getattr()的底层其实就是该方法 如下所示： from typing import Any class Category: def __getattribute__(self, name: str) -> Any: print(\"run ..\") try: return super(__class__, self).__getattribute__(name) except AttributeError as e: return \"don't have attribute %s\" % name if __name__== \"__main__\": instance = Category() print(instance.x) # run .. # don't have attribute x __getattr__() 在对对象进行 . 操作试图获取对象下的某一属性或方法时而恰好该属性或方法不存在时自动触发。 若__getattribute__()与__getattr__()同时出现，则只会调用__getattribute__()。 参数释义： self：实例本身，也就是 . 前面的对象 name：要查找的属性或方法 返回值： Any：任意给定的值 应用场景：自定义类的方法借用，或者代理类 示例1，只定义了__getattr__()，它会在获取对象下的某一属性或方法不存在时触发： from typing import Any class Category: x = 1 def __getattr__(self, name: str) -> Any: print(\"run ..\") return \"%s not existing\" % name if __name__== \"__main__\": instance = Category() print(\"Find the existing properties and not call __getattr__()\") print(instance.x) print(\"Find the property that does not exist will call __getattr__()\") print(instance.y) # Find the existing properties and not call __getattr__() # 1 # Find the property that does not exist will call __getattr__() # run .. # y not existing 示例2，如果同时定义了__getattr__()和__getattribute__()则无论什么情况都不会触发__getattr__()： from typing import Any class Category: x = 1 def __getattribute__(self, name: str) -> Any: print(\"run __getattribute__()\") try: return super(Category, self).__getattribute__(name) except AttributeError as e: return \"don't have attribute %s\" % name def __getattr__(self, name: str) -> Any: print(\"run __getattr__()\") return \"%s not existing\" % name if __name__== \"__main__\": instance = Category() print(instance.x) print(instance.y) # run __getattribute__() # 1 # run __getattribute__() # don't have attribute y __setattr__() 在对对象进行 . 操作试图修改对象下的某一属性或方法时自动触发。 参数释义： self：实例本身，也就是 . 前面的对象 name：要设置的属性或方法 value：要为属性和方法设置的新值 返回值： None 应用场景：自定义代理类，内置函数setattr()的底层其实就是该方法 如下所示： from typing import Any class Category: x = 1 def __setattr__(self, name: str, value: Any) -> None: print(\"run .. __setattr__()\") self.__dict__[name] = value if __name__== \"__main__\": instance = Category() instance.y = \"newAttribute\" # run .. __setattr__() 一个容易被人忽视的地方，如果__setattr__()中设置成这样，则会引发无限递归，无数次调用自身： def __setattr__(self, name: str, value: Any) -> None: self.name = value __delattr__() 在对对象进行 . 操作试图删除对象下的某一属性或方法时自动触发。 参数释义： self：实例本身，也就是 . 前面的对象 name：要删除的属性或方法 返回值： None 应用场景：自定义不可变容器，内置函数delattr()的底层其实就是该方法 如下所示： class Category: x = 1 def __delattr__(self, name: str) -> None: print(\"run .. __delattr__()\") del self.__dict__[name] if __name__== \"__main__\": instance = Category() instance.attr = \"newAttr\" del instance.attr # run .. __delattr__() __getitem__() 在对对象进行 [] 操作试图获取对象下的某一对象属性或方法时自动触发。 除此之外，它也能代替__iter__()方法创建专属迭代器。 参数释义： self：实例本身，也就是 [] 前面的对象 name：要获取的属性或方法 返回值： None 应用场景：自定义映射容器，实现类似字典的操作 dict[k] 如下所示： from typing import Any class Category: x = 1 def __getitem__(self, name: str) -> Any: print(\"run .. __getitem__()\") return self.__dict__[name] if __name__== \"__main__\": instance = Category() instance.attr = \"newAttr\" print(instance[\"attr\"]) # run .. __getitem__() # newAttr 此外，如果类中实现了该方法，则该类的实例化对象就是可迭代对象： from typing import Any class Category: x = 1 def __getitem__(self, name: str) -> Any: print(\"run .. __getitem__()\") return self.__dict__[name] if __name__== \"__main__\": instance = Category() print(iter(instance)) # ❶ # ❶：即使该类没实现__iter__()，但是仍然可以创建专属迭代器 __setitem__() 在对对象进行 [] 操作试图修改对象下的某一对象属性或方法时自动触发。 参数释义： self：实例本身，也就是 [] 前面的对象 name：要设置的属性或方法 value：要为属性和方法设置的新值 返回值： None 应用场景：自定义映射容器，实现类似字典的操作 dict[k] = v 如下所示： from typing import Any class Category: x = 1 def __setitem__(self, name: str, value: Any) -> None: print(\"run .. __setitem__()\") self.__dict__[name] = value if __name__== \"__main__\": instance = Category() instance[\"y\"] = \"newAttr\" # run .. __setitem__() __delitem__() 在对对象进行 [] 操作试图删除对象下的某一对象属性或方法时自动触发。 参数释义： self：实例本身，也就是 [] 前面的对象 name：要删除的属性或方法 返回值： None 应用场景：自定义映射容器，实现类似字典的操作 del dict[k] 如下所示： class Category: x = 1 def __delitem__(self, name: str) -> None: print(\"run .. __delitem__()\") del self.__dict__[name] if __name__== \"__main__\": instance = Category() instance.attr = \"newAttr\" del instance[\"attr\"] # run .. __delitem__() 输出相关 __str__() print(object)时自动触发该方法。 参数释义： self：实例本身，也就是 . 前面的对象 返回值： 必须是str类型 应用场景：非常常用，如Django框架admin，models类中都会定义该方法进行数据项展示 如下所示： class Category: x = 1 def __str__(self) -> str: return \"it is class %s instance object\" % self.__class__.__name__ if __name__== \"__main__\": instance = Category() print(instance) # it is class Category instance object __repr__() 交互式环境下输入对象标识符，print(object)时自动触发该方法。 参数释义： self：实例本身，也就是 . 前面的对象 返回值： 必须是str类型 应用场景：与__str__()应用场景相当，但是比它要强大一点。 如果没有实现__str__()方法，则会在print(object)时使用该方法。 如下所示： class Category: x = 1 def __repr__(self) -> str: return \"it is class %s instance object\" % self.__class__.__name__ if __name__== \"__main__\": instance = Category() print(instance) # it is class Category instance object __format__() format(object)时自动触发该方法。 参数释义： self：实例本身，也就是 . 前面的对象 format_spec：模板{:}中:后面的值 返回值： 必须是str类型 应用场景：自定义时间类，格式化打印相关 如下所示： class Date: formatStyle = { \"ymd\": \"{0.year}:{0.month}:{0.day}\", \"dmy\": \"{0.day}/{0.month}/{0.year}\", \"mdy\": \"{0.month}-{0.day}-{0.year}\", } def __init__(self, year, month, day) -> None: self.year = year self.month = month self.day = day def __format__(self, format_spec: str) -> str: if format_spec is None or format_spec not in __class__.formatStyle: format_spec = \"ymd\" return __class__.formatStyle[format_spec].format(self) if __name__== \"__main__\": instance = Date(2011, 1, 23) print(format(instance)) print(\"{:mdy}\".format(instance)) # 2011:1:23 # 1-23-2011 组合套餐 __enter__()与__exit__() __enter__()与__exit__()方法可实现上下文管理协议。 使用with语句将自动触发__enter__()方法的执行。 with语句代码块执行完毕后或者with语句代码块执行过程中抛出异常都会自动触发__exit__()方法的执行。 上下文管理作用如下： 使用with语句的目的就是把代码块放入with中执行，with结束后，自动完成清理工作，无须手动干预 在需要管理一些资源比如文件，网络连接和锁的编程环境中，可以在__exit__()中定制自动释放资源的机制，你无须再去关心这个问题，这将大有用处 函数签名如下： def __enter__(self) -> object: pass def __exit__(self, exc_type, exc_val, exc_tab) -> bool: pass __enter__()方法说明： 参数释义： self：实例本身，也就是 . 前面的对象 返回值： 返回的对象会被as语句当做句柄接收 __exit__()方法说明： 参数释义： self：实例本身，也就是 . 前面的对象 exc_type：异常类型 exc_val：异常值 exc_tab：异常回溯信息 返回值： 如果返回False则代表立即抛出异常，如果返回True则代表捕获本次异常 示例演示，通过__new__()方法和上下文管理协议，实现文件类封装： class OpenFile: fileObject = None __doc__= open.__doc__ def __new__(cls, *args, **kwargs) -> object: cls.fileObject = open(*args, **kwargs) return cls.fileObject def __enter__(self): return __class__.fileObject def __exit__(exc_type, exc_val, exc_tab): __class__.fileObject.close() return False def __del__(self): __class__.fileObject.close() def __getattr__(self, name: str): return getattr(__class__.fileObject, name) if __name__== \"__main__\": with OpenFile(\"./test.txt\", mode=\"rt\", encoding=\"utf8\") as f: print(f.read()) print(help(OpenFile)) __iter__()与__next__() __iter__()与__next__()可实现迭代器协议。 具体参照迭代器一章节，这里不再具体演示。 容器相关 __len__() 当使用len(object)时将会自动执行该方法。 该方法应当返回int类型。 示例如下： class Category: x = 1 def __len__(self): return 100 if __name__== \"__main__\": instance = Category() print(len(instance)) # 100 __contains__() 当使用 item in object 时将会自动执行该方法。 该方法应当返回bool类型。 示例如下： class Category: x = 1 def __contains__(self, item): return True if __name__== \"__main__\": instance = Category() print(\"a\" in instance) # True 双下方法一览表 以上介绍的均是常见的双下方法，足以应付大部分使用场景。 下面是双下方法大全表： __new__(cls[, …]) ： 是在一个对象实例化的时候所调用的第一个方法，它的第一个参数是这个类，其他的参数是用来直接传递给 __init__方法。决定是否要使用该 __init__方法，因为 __new__可以调用其他类的构造方法或者直接返回别的实例对象来作为本类的实例，如果 __new__没有返回实例对象，则 __init__不会被调用。 __new__主要是用于继承一个不可变的类型比如一个 tuple 或者 string。 __init__(self[, …])： 构造器，当一个实例被创建的时候调用的初始化方法 __del__(self)： 析构器，当一个实例被销毁的时候调用的方法 __call__(self[, args…])： 允许一个类的实例像函数一样被调用：x(a, b) 调用 x.__call__(a, b) __len__(self)： 定义当被 len() 调用时的行为 __repr__(self)： 定义当被 repr() 调用时的行为 __str__(self)： 定义当被 str() 调用时的行为 __bytes__(self)： 定义当被 bytes() 调用时的行为 __hash__(self)： 定义当被 hash() 调用时的行为 __bool__(self)： 定义当被 bool() 调用时的行为，应该返回 True 或 False __format__(self, format_spec)： 定义当被 format() 调用时的行为 有关属性 __getattr__(self, name)： 定义当用户试图获取一个不存在的属性时的行为 __getattribute__(self, name)： 定义当该类的属性被访问时的行为 __setattr__(self, name, value)： 定义当一个属性被设置时的行为 __delattr__(self, name)： 定义当一个属性被删除时的行为 __dir__(self)： 定义当 dir() 被调用时的行为 __get__(self, instance, owner)： 定义当描述符的值被取得时的行为 __set__(self, instance, value)： 定义当描述符的值被改变时的行为 __delete__(self, instance)： 定义当描述符的值被删除时的行为 比较操作符 __lt__(self, other)： 定义小于号的行为：x y 调用 x.gt(y) __ge__(self, other) ： 定义大于等于号的行为：x >= y 调用 x.ge(y) 算数运算符 __add__(self, other)： 定义加法的行为：+ __sub__(self, other)： 定义减法的行为：- __mul__(self, other)： 定义乘法的行为：* __truediv__(self, other)： 定义真除法的行为：/ __floordiv__(self, other)： 定义整数除法的行为：// __mod__(self, other)： 定义取模算法的行为：% __divmod__(self, other)： 定义当被 divmod() 调用时的行为 __pow__(self, other[, modulo])： 定义当被 power() 调用或 ** 运算时的行为 __lshift__(self, other)： 定义按位左移位的行为：> __and__(self, other)： 定义按位与操作的行为：& __xor__(self, other)： 定义按位异或操作的行为：^ __or__(self, other)： 定义按位或操作的行为：| 反运算 __radd__(self, other)： （与上方相同，当左操作数不支持相应的操作时被调用） __rsub__(self, other) ： （与上方相同，当左操作数不支持相应的操作时被调用） __rmul__(self, other) ： （与上方相同，当左操作数不支持相应的操作时被调用） __rtruediv__(self, other)： （与上方相同，当左操作数不支持相应的操作时被调用） __rfloordiv__(self, other)： （与上方相同，当左操作数不支加粗样式持相应的操作时被调用） __rmod__(self, other)： （与上方相同，当左操作数不支持相应的操作时被调用） __rdivmod__(self, other)： （与上方相同，当左操作数不支持相应的操作时被调用） __rpow__(self, other)： （与上方相同，当左操作数不支持相应的操作时被调用） __rlshift__(self, other)： （与上方相同，当左操作数不支持相应的操作时被调用） __rrshift__(self, other)： （与上方相同，当左操作数不支持相应的操作时被调用） __rand__(self, other)： （与上方相同，当左操作数不支持相应的操作时被调用） __rxor__(self, other)： （与上方相同，当左操作数不支持相应的操作时被调用） __ror__(self, other)： （与上方相同，当左操作数不支持相应的操作时被调用） 增量赋值运算 __iadd__(self, other)： 定义赋值加法的行为：+= __isub__(self, other)： 定义赋值减法的行为：-= __imul__(self, other)： 定义赋值乘法的行为：*= __itruediv__(self, other)： 定义赋值真除法的行为：/= __ifloordiv__(self, other)： 定义赋值整数除法的行为：//= __imod__(self, other)： 定义赋值取模算法的行为：%= __ipow__(self, other[, modulo])： 定义赋值幂运算的行为：**= __ilshift__(self, other)： 定义赋值按位左移位的行为：>= __iand__(self, other)： 定义赋值按位与操作的行为：&= __ixor__(self, other)： 定义赋值按位异或操作的行为：^= __ior__(self, other)： 定义赋值按位或操作的行为：|= 一元操作符 __pos__(self)： 定义正号的行为：+x __neg__(self)： 定义负号的行为：-x __abs__(self)： 定义当被 abs() 调用时的行为 __invert__(self)： 定义按位求反的行为：~x 类型转换 __complex__(self)： 定义当被 complex() 调用时的行为（需要返回恰当的值） __int__(self)： 定义当被 int() 调用时的行为（需要返回恰当的值） __float__(self)： 定义当被 float() 调用时的行为（需要返回恰当的值） __round__(self[, n])： 定义当被 round() 调用时的行为（需要返回恰当的值） __index__(self)： 当对象是被应用在切片表达式中时，实现整形强制转换，若定义了一个可能在切片时用到的定制的数值型,应该定义 __index__，若 __index__被定义，则 __int__也需要被定义，且返回相同的值 上下文管理（with 语句） __enter__(self)： 定义当使用 with 语句时的初始化行为，返回值被 with 语句的目标或者 as 后的名字绑定 __exit__(self, exc_type, exc_value, traceback)： 定义当一个代码块被执行或者终止后上下文管理器应该做什么，一般被用来处理异常，清除工作或者做一些代码块执行完毕之后的日常工作 容器类型 __len__(self)： 定义当被 len() 调用时的行为（返回容器中元素的个数） __getitem__(self, key)： 定义获取容器中指定元素的行为，相当于 self[key] __setitem__(self, key, value)： 定义设置容器中指定元素的行为，相当于 self[key] = value __delitem__(self, key)： 定义删除容器中指定元素的行为，相当于 del self[key] __iter__(self)： 定义当迭代容器中的元素的行为 __reversed__(self)： 定义当被 reversed() 调用时的行为 __contains__(self, item)： 定义当使用成员测试运算符（in 或 not in）时的行为 双下属性 类的属性 __doc__ 类的帮助信息，使用help(class or instanceObject)时，将获得该信息。 class Category: __doc__ = \"hello magic attribute\" if __name__== \"__main__\": help(Category) # class Category(builtins.object) # | hello magic attribute # | # | Data descriptors defined here: # ... __dict__ 类或者实例对象的底层字典。 详情参见类与对象一章。 __slots__ __slots__可以代替__dict__作为类或者实例的属性存储容器。 它还能限制实例对象属性的增加，如下只允许实例对象具有name和age属性，当添加gender属性时抛出异常： class Category: __slots__ = (\"name\", \"age\") if __name__== \"__main__\": instance = Category() instance.name = \"Jack\" print(instance.name) instance.age = 18 print(instance.age) instance.gender = \"male\" # Jack # 18 # AttributeError: 'Category' object has no attribute 'gender' __class__ 在类中调用__class__获得类本身。 通过self.__class__获得实例化出self的类。 推荐使用它来获取类属性，在类中使用__class__.attr而不是className.attr，这样更加灵活。 __base__ 通过className.__base__可获得类的父类，返回父类对象。 详情参见继承一章。 __bases__ 通过className.__bases__可获得类的父类，返回父类对象元组。 详情参见继承一章。 __mro__ 通过className.__mro__可获得该类的属性查找顺序列表。 详情参见继承一章。 全局属性 __file__ 获取当前脚本文件路径： print( __file__ ) # /Users/yunya/PythonProject/demo.py __name__ 如果使用__class__.name，则获取当前类的名称，而不是返回类对象： print( None.__class__ ) print( None.__class__.__name__ ) # # NoneType 如果在全局使用__name__则会判断执行方式是脚本“main”还是模块“module”。 详情参见模块一章。 __all__ 定义模块中允许被import *导入的标识符。 详情参见模块一章。 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:46 "},"Python/Python面向对象/描述符类.html":{"url":"Python/Python面向对象/描述符类.html","title":"描述符类","keywords":"","body":"描述符类 我们在之前接触了代理属性@property装饰器，它其实就是一个描述符，本质上而言是一个新式类。 如果想自定义一个描述符类，则必须实现以下三种双下方法的任意一个或多个： __get__()：获取描述符类实例时，触发该方法 __set__()：设置描述符类实例时，触发该方法 __delete__()：删除描述符类实例时，触发该方法 于此同时还需要注意在定义描述符类时的2点细节： 描述符类本身应该定义成新式类，被代理的类也应该是新式类 必须把描述符实例定义成这个类的类属性，不能定义到__init__()中成为实例属性 简单的属性代理示例，如下所示： 当访问Category.name时，会触发Proxy.__get__()方法 当设置Category.name时，会触发Proxy.__set__()方法 当删除Category.name时，会触发Proxy.__delete__()方法： class Proxy: proxyName = None def __get__(self, instance, owner): # ❶ print(\"run ... Proxy.__get__()\") return __class__.proxyName def __set__(self, instance, value): # ❷ print(\"run ... Proxy.__set__()\") __class__.proxyName = value def __delete__(self, instance): # ❸ print(\"run ... Proxy.__delete__()\") del __class__.proxyName class Category: name = Proxy() if __name__== \"__main__\": ins = Category() ins.name = \"King Kong\" print(ins.name) del ins.name # run ... Proxy.__set__() # run ... Proxy.__get__() # King Kong # run ... Proxy.__delete__() ❶：instance即实例对象本身，就是外部的ins标识符指向的对象，owner即实例对象拥有者，就是Category类 ❷：instance即实例对象本身，就是外部的ins标识符指向的对象，value是新设置的值，即23行的King Kong ❸：instance即实例对象本身，就是外部的ins标识符指向的对象 描述符类的种类 描述符类可分为数据描述符类和非数据描述符类，如下所示： 数据描述符类：至少实现了__get__()和__set__()方法的类 非数据描述符类：只实现了__get__()方法的类 数据描述符类和非数据描述符类对实例对象属性查找极其重要，所以这里特别指出。 如下，定义一个数据描述符类： class Proxy: def __get__(self, instance, owner): print(\"run ... Proxy.__get__()\") return __class__.proxyName def __set__(self, instance, value): print(\"run ... Proxy.__set__()\") __class__.proxyName = value 如下，定义一个非数据描述符类： class Proxy: def __get__(self, instance, owner): print(\"run ... Proxy.__get__()\") return __class__.proxyName 代理属性设置优先级 现在有1个类（Category），它的类属性（name）被代理了，并且代理类（Proxy）中设置了__set__()方法，于此同时被代理类（Category）中也设置了__setattr__()方法。 当对Category的实例对象进行. 操作试图修改name时，会执行哪一个方法？ Category.__setattr__()的优先级是高于Proxy.__set__()的，故会执行Category.__setattr__()方法。 如下所示： class Proxy: proxyName = None def __get__(self, instance, owner): print(\"run ... Proxy.__get__()\") return __class__.proxyName def __set__(self, instance, value): print(\"run ... Proxy.__set__()\") __class__.proxyName = value def __delete__(self, instance): print(\"run ... Proxy.__delete__()\") del __class__.proxyName class Category: name = Proxy() def __setattr__(self, name, value): print(\"run ... Category.__setattr__()\") self.__dict__[name] = value if __name__ == \"__main__\": ins = Category() ins.name = \"King Kong\" # run ... Category.__setattr__() 如果被代理类（Category）没有实现__setattr__()方法，则修改被代理属性name时，会触发Proxy.__set__()方法的执行： class Proxy: proxyName = None def __get__(self, instance, owner): print(\"run ... Proxy.__get__()\") return __class__.proxyName def __set__(self, instance, value): print(\"run ... Proxy.__set__()\") __class__.proxyName = value def __delete__(self, instance): print(\"run ... Proxy.__delete__()\") del __class__.proxyName class Category: name = Proxy() if __name__ == \"__main__\": ins = Category() ins.name = \"King Kong\" # run ... Proxy.__set__() 代理属性查找优先级 当具有描述符类存在时，属性查找顺序不再是一味的从实例开始查找到类及其超类。 而是按照以下流程： object.__getattribute__() 数据描述符 实例对象__dict__ 非数据描述符 类即超类__dict__ 类即超类__getattr__() 整个流程如图下所示： 1）数据描述符的查找优先于实例属性 class Proxy: proxyName = None def __get__(self, instance, owner): print(\"run ... Proxy.__get__()\") return __class__.proxyName def __set__(self, instance, value): print(\"run ... Proxy.__set__()\") __class__.proxyName = value def __delete__(self, instance): print(\"run ... Proxy.__delete__()\") del __class__.proxyName class Category: name = Proxy() def __init__(self) -> None: self.name = \"Proxy.proxyName\" if __name__ == \"__main__\": ins = Category() print(ins.__dict__) print(ins.name) # run ... Proxy.__set__() # {} # run ... Proxy.__get__() # Proxy.proxyName ❶：self.name的时候，由于name本身是一个被数据描述符类代理的属性，且Category未实现__setattr__()故会执行Proxy.__set__()方法，现在Proxy.proxyName = “Proxy.proxyName” ❷：由于self.name操作触发了Proxy代理类的__set__()方法执行，故instance.__dict__中并未拥有任何实例属性 ❷：28行print()操作试图获取这个被数据描述符类代理的属性，故会执行Proxy.__get__()方法获取并返回Proxy.proxyName 2）实例属性的查找优先于非数据描述符 class Proxy: proxyName = None def __get__(self, instance, owner): print(\"run ... Proxy.__get__()\") return __class__.proxyName class Category: name = Proxy() def __init__(self) -> None: self.name = \"instance name\" # ❶ if __name__ == \"__main__\": ins = Category() print(ins.__dict__) print(ins.name) # {'name': 'instance name'} # instance name ❶：self.name的时候，由于name不是一个被数据描述符类代理的属性，故底层会执行object.__setattr__()方法，将name变更为实例属性存储至instance.__dict__中 3）实例属性的查找优先于类属性 class Category: name = \"class name\" def __init__(self) -> None: self.name = \"instance name\" if __name__ == \"__main__\": ins = Category() print(ins.__dict__) print(ins.name) # {'name': 'instance name'} # instance name 描述符类简单应用 众所周知，Python是动态语言，即参数的赋值没有类型限制，下面我们通过描述符机制来实现类型限制功能。 注意点：如果对传入值进行参数设置，其被描述符代理属性的类千万不要设置 __setattr__()，因为__setattr__()方法的优先级高于描述符的__get__()方法。 class Proxy: def __init__(self, key, expectedType) -> None: self.key = key self.expectedType = expectedType def __get__(self, instance, owner): if instance is None: # ❶ return self return instance.__dict__[self.key] def __set__(self, instance, value): if not isinstance(value, self.expectedType): raise TypeError(\"parameter type error, expected %s type %s, but you give type is %s\" % ( self.key, self.expectedType, type(value))) instance.__dict__[self.key] = value def __delete__(self, instance): del instance.__dict__[self.key] class Category: name = Proxy(\"name\", str) age = Proxy(\"age\", int) def __init__(self, name: str, age: int) -> None: self.name = name self.age = age if __name__ == \"__main__\": ins = Category(\"Jack\", 18) print(ins.name, type(ins.name)) print(ins.age, type(ins.age)) # Jack # 18 ❶：这个判断条件是针对使用Category.被代理属性，如果是这样直接返回Proxy实例即可 类装饰器 装饰器可以给类装饰 装饰器的本质就是将@decorator下面的可调用对象当做参数自动传入到装饰器中，类本身是可调用的，因此我们也可以给类的上面套一个装饰器。 类的无参装饰器： def warpper(object): object.attr = \"newAttr\" return object @warpper class Category: pass if __name__ == \"__main__\": print(Category.attr) # newAttr 类的有参装饰器： def warpper(**kwargs): def inner(object): for k, v in kwargs.items(): setattr(object, k, v) return object return inner @warpper(name=\"Category\", type=\"class\") class Category: pass if __name__ == \"__main__\": for k,v in Category.__dict__.items(): if not k.startswith(\"__\"): print(k, v) # name Category # type class 类也可以作为装饰器 一定要理解，装饰器的本质只是将@decorator下对象的引用传入至形参中，所以我们也可以将类作为装饰器： class Warpper: def __new__(cls, instanceClass) -> object: instanceClassObject = instanceClass(\"Jack\", 18, \"male\") return instanceClassObject @Warpper class Category: def __init__(self, name, age, gender) -> None: self.name = name self.age = age self.gender = gender if __name__ == \"__main__\": print(Category) print(Category.name) print(Category.age) print(Category.gender) # # Jack # 18 # male 在这个例子中，Category其实是Category的instance对象。 描述符与类装饰器应用 属性类型限制 我们在学习了类的装饰器后，已经可以将其与描述符类相结合，完成以下功能了。 1）通过给类添加有参装饰器实现动态添加类属性： def addClassAttribute(**kwargs): def inner(cls): for k, v in kwargs.items(): setattr(cls, k, v) return cls return inner @addClassAttribute(name=\"Jack\", age=18, gender=\"male\") class Person: pass if __name__ == \"__main__\": for k, v in Person.__dict__.items(): if not k.startswith(\"__\"): print(k, v) # name Jack # age 18 # gender male 2）通过给类添加有参装饰器以及配合数据描述符实现实例属性类型检测： class Proxy: def __init__(self, key, expectedType) -> None: self.key = key self.expectedType = expectedType def __get__(self, instance, owner): if instance is None: # ❶ return self return instance.__dict__[self.key] def __set__(self, instance, value): if not isinstance(value, self.expectedType): raise TypeError(\"parameter type error, expected %s type %s, but you give type is %s\" % ( self.key, self.expectedType, type(value))) instance.__dict__[self.key] = value def __delete__(self, instance): del instance.__dict__[self.key] def addClassAttribute(**kwargs): def inner(cls): for k, v in kwargs.items(): setattr(cls, k, Proxy(key=k, expectedType=v)) return cls return inner @addClassAttribute(name=str, age=int, gender=str) class Person: def __init__(self, name: str, age: int, gender: str) -> None: self.name = name self.age = age self.gender = gender if __name__ == \"__main__\": for k, v in Person.__dict__.items(): if not k.startswith(\"__\"): print(k, v) ins = Person(name=\"Jack\", age=\"19\", gender=1) # name # age # gender # TypeError: parameter type error, expected type , but you give type is ❶：这个判断条件是针对使用Person.被代理属性，如果是这样直接返回Proxy实例即可 自定义property @property本身是通过描述符类实现的，因此我们也可以自己实现: class Property: def __init__(self, method) -> None: self.method = method def __get__(self, instance, owner): if instance is None: # ❶ return self else: v = self.method(instance) # ❷ # instance.__dict__[self.method.__name__] = v # ❸ return v class Person: def __init__(self, name, height, weight): self.name = name self.height = height self.weight = weight @Property def bmi(self): v = self.weight / (self.height ** 2) if 20 25: return \"overweight\" return \"obesity\" if __name__ == \"__main__\": instanceObject = Person(\"ken\", height=1.76, weight=77) print(instanceObject.bmi) #　normal ❶：这个判断条件是针对使用Person.被代理属性的操作，如果是这样直接返回Proxy实例即可 ❷：手动的为self传递参数为instance ❸：这里是做一个缓存功能，将第一次求值结果存放至实例字典中。 如果要做缓存功能，则需要注意自定义的这个描述符种类必须是非数据描述符，因为数据描述符属性的查找顺序是在实例之前。 此外，如果添加上缓存功能，后续该实例的身高体重一旦发生改变，则会导致二次求值结果不准确，因此一般不做这个缓存 自定义classmethod @classmethod本身是通过描述符类实现的，因此我们也可以自己实现: class ClassMethod: def __init__(self, method) -> None: self.clsMethod = method def __get__(self, instance, owner): def inner(*args, **kwargs): return self.clsMethod(owner, *args, **kwargs) return inner class Person: desc = \"This is person class\" @ClassMethod def show(cls, x, y, z): print(x, y, z) print(cls.desc) if __name__ == \"__main__\": Person.show(1, 2, 3) # 1 2 3 # This is person class 自定义staticmethod @staticmethod本身是通过描述符类实现的，因此我们也可以自己实现： class StaticMethod: def __init__(self, method) -> None: self.staticMethod = method def __get__(self, instance, owner): def inner(*args, **kwargs): return self.staticMethod(*args, **kwargs) return inner class Person: @StaticMethod def show(x, y, z): print(x, y, z) if __name__ == \"__main__\": Person.show(1, 2, 3) # 1 2 3 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:46 "},"Python/Python面向对象/元类编程.html":{"url":"Python/Python面向对象/元类编程.html","title":"元类编程","keywords":"","body":"一切皆对象 函数是对象 Python中一切皆对象，故函数也是一个实例对象。 通过function.__class__，可以拿到创建出函数这个实例对象的类： >>> func = lambda : 1 >>> print(func.__class__) 我们还可以为函数实例对象增添实例属性，虽然没人会这样做： >>> func.attr = \"intance attribute\" >>> func.attr 'intance attribute' 类也是对象 由于一切皆对象的缘故，故类也是一个实例对象。 而创建出类这个实例对象的类，被称为元类（metaclass），Python中只有1个内置元类，为type。 如下示例，使用class.__class__即可拿到元类type： >>> int.__class__ >>> list.__class__ >>> class Category: pass >>> Category.__class__ 什么是元类 经过上面的例子，我们可以看见所有类都是由元类type类进行实例化而得到的。 故元类即为创造类的类，它的作用主要有2个： 用于生产出类对象 用于生产出类对象的实例对象 class定义内部机制 当我们使用class关键字定义一个类之后，底层的创建步骤大体可分为4步： 拿到类标识符 拿到类的基类 执行类体代码，创建类的命名空间 调用元类，默认为type类，得到实例化出的类对象 创建类不一定非要使用class关键字，也可以有其他形式，下面这个示例将重现上面4大步骤： # first step : get class name className = \"Person\" # second step : get class parent class and super class and bases classes classBasesClass = (object, ) # third step 1 : definition class __dict__ ， Now this is empty classDict = {} # third step 2 : get class body code , It is interpreted by Python is a string classBody = \"\"\" def __init__(self, name, age, gender): self.name = name self.age = age self.gender = gender def show(self): return \"name : %s age : %s gender : %s\"%(self.name, self.age, self.gender) \"\"\" # first param : class body code # second param : global name space # last param : class __dict__ , is class local name space exec(classBody, {}, classDict) # Now, class __dict__ have content, class initing end print(classDict) # last step # class name give global identifier Person Person = type(className, classBasesClass, classDict) if __name__ == \"__main__\": ins = Person(name=\"Jack\", age=18, gender=\"male\") print(ins.show()) 自定义元类 如何自定义元类 如果一个类继承了type类，那么他就是一个元类： class MetaClass(type): pass print(type(MetaClass)) # 元类如何生产出类对象 元类如何生成出一个类呢？实际上class ClassName后执行脚本时这一系列过程都是自动的。 在元类中会经历2大步骤： 调用元类自己的__new__()方法，构建出1个空的类对象 调用元类自己的__init__()方法，为空的类对象增添属性 详细的整体过程如图所示： 如下示例，我们如果要指定1个类的元类，则必须在其继承括号中添加上 metaclass = className 的字样： class MetaClass(type): def __new__(cls, *args, **kwargs) -> object: \"\"\" cls : meta class args : (class name, (class bases, ), { class __dict__ }) kwargs : empty dict Returns: object: meta class instance object \"\"\" # must transfer all params return super(__class__, cls).__new__(cls, *args, **kwargs) def __init__(self, *args, **kwargs) -> None: \"\"\" self : meta class instance object args : (class name, (class bases, ), { class __dict__ }) kwargs : empty dict Returns: None \"\"\" super(__class__, self).__init__(*args, **kwargs) class Person(object, metaclass=MetaClass): pass if __name__ == \"__main__\": pass 当解释器执行到25行时，会自动调用元类__new__()方法开始构造类对象。 元类如何生产出类的实例对象 一个普通的类如果创建实例对象，必定会使用className()的形式。 那么他底层会做什么事情呢？如下所示： 当className()时， 类自动调用元类下的_call\\_()方法 元类下的__call__()方法会自动调用类的__new__()方法，创建出一个空的实例化对象 元类下的__call__()方法会自动调用类的__init__()方法，为这个空实例化对象增添实例属性 元类下的__call__()方法将返回造好的这个实例化对象 如下所示： class MetaClass(type): # create cls object method : __new__() 、 __init__() def __new__(cls, *args, **kwargs) -> object: return super(__class__, cls).__new__(cls, *args, **kwargs) def __init__(self, *args, **kwargs) -> None: super(__class__, self).__init__(*args, **kwargs) # create cls instance obj method : __call__() def __call__(cls, *args, **kwargs) -> object: \"\"\" cls : meta class instance object args : cls instance position params kwargs : cls instance keyword params Returns : cls instance object \"\"\" clsInstanceObject = cls.__new__(cls, *args, **kwargs) cls.__init__(clsInstanceObject, *args, **kwargs) return clsInstanceObject class Person(object, metaclass=MetaClass): def __new__(cls, *args, **kwargs) -> object: return super(__class__, cls).__new__(cls) def __init__(self, name, age, gender) -> None: self.name = name self.age = age self.gender = gender if __name__ == \"__main__\": ins = Person(name=\"Jack\", age=18, gender=\"male\") 过程图示如下： 实例对象与类对象的属性查找 查找的区别 我们如果对ins加上括号，会不会调用元类的__call()__方法呢？ 答案是不会，实例对象和类对象的属性查找是不一样的，验证如下所示： class MetaClass(type): # create cls object method : __new__() 、 __init__() def __new__(cls, *args, **kwargs) -> object: return super(__class__, cls).__new__(cls, *args, **kwargs) def __init__(self, *args, **kwargs) -> None: super(__class__, self).__init__(*args, **kwargs) # create cls instance obj method : __call__() def __call__(cls, *args, **kwargs) -> object: clsInstanceObject = cls.__new__(cls, *args, **kwargs) cls.__init__(clsInstanceObject, *args, **kwargs) return clsInstanceObject class Person(object, metaclass=MetaClass): def __new__(cls, *args, **kwargs) -> object: return super(__class__, cls).__new__(cls) def __init__(self, name, age, gender) -> None: self.name = name self.age = age self.gender = gender if __name__ == \"__main__\": ins = Person(name=\"Jack\", age=18, gender=\"male\") ins() # TypeError: 'Person' object is not callable 类对象的属性查找顺序 类对象如果要进行属性查找，它会去父类、超类、object基类以及type元类中查找。 如图所示： 示例如下： class MetaClass(type): findAttr = \"MetaClass.attr\" class A: # findAttr = \"A.attr\" pass class B(A): # findAttr = \"B.attr\" pass class C(B, metaclass=MetaClass): # findAttr = \"C.attr\" pass if __name__ == \"__main__\": print(C.findAttr) 实例对象的属性查找顺序 类的实例对象如果要进行属性查找，它会去父类、超类、object基类中查找，不会去元类层。 如图所示： 示例如下： class MetaClass(type): findAttr = \"MetaClass.attr\" class A: findAttr = \"A.attr\" pass class B(A): # findAttr = \"B.attr\" pass class C(B, metaclass=MetaClass): # findAttr = \"C.attr\" pass if __name__ == \"__main__\": ins = C() print(ins.findAttr) 实例练习 类的命名规则检测 有了自定义元类，我们可以将自定义类的命名规定为必须大驼峰，否则抛出异常： class MetaClass(type): def __new__(cls, *args, **kwargs): if not args[0].istitle(): raise NameError(\"class %s name must upper\" % args[0]) super(__class__, cls).__new__(cls, *args, **kwargs) class category(metaclass=MetaClass): pass # NameError: class name must upper 类的文档信息检测 有了自定义元类，我们可以规定类必须书写文档信息，即__doc__，否则抛出异常： class MetaClass(type): def __new__(cls, *args, **kwargs): if \"__doc__\" not in args[-1] : raise SyntaxError(\"class %s must have help doc\" % args[0]) super(__class__, cls).__new__(cls, *args, **kwargs) class Category(metaclass=MetaClass): pass # SyntaxError: class Category must have help doc Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:46 "},"Python/Python面向对象/异常处理.html":{"url":"Python/Python面向对象/异常处理.html","title":"异常处理","keywords":"","body":"异常介绍 异常分类 　　程序中难免出现错误，总共可分为两种。 　　1.逻辑错误 　　2.语法错误 　　对于刚接触编程的人来说，这两个错误都会经常去犯，但是随着经验慢慢的积累，语法错误的情况会越来越少反而逻辑错误的情况会越来越多（因为工程量巨大）。 不论多么老道的程序员都不可避免出现这两种错误。 异常信息 　异常其实就是程序运行时发生错误的信号，我们写代码的过程中不可避免也最害怕的就是出现异常，然而当程序抛出异常时实际上会分为三部分，即三大信息。 常见异常 在Python中一切皆对象，异常本身也是由一个类生成的，NameError其实本身就是一个异常类，其他诸如此类的异常类还有很多，如下表所示。 异常类 描述 AttributeError 属性错误，被查找属性不存在 IOError IO错误，文件无法打开 ImportError 导包错误，导入模块或包时给定了错误的路径或导入了没有的功能 IndentaionError 缩进错误，代码没有正确对齐 KeyError 键错误，获取字典中不存在的键 NameError 标识符错误，试图使用一个未被赋值的标识符 SyntaxError 语法错误，代码写错了 TypeError 类型错误，传入对象的类型和预期不符 ValueError 值错误，传入一个调用者不期望的值，即使值的类型是正确的 AssertionError 断言异常 异常处理 我们可以来用某些方法进行异常捕捉，当出现异常时我们希望代码以另一种逻辑运行，使得我们的程序更加健壮，这个就叫做异常处理。 异常处理是非常重要的，本身也并不复杂，千万不可马虎大意，但是切记不可滥用异常处理，这会使得你的代码可读性变差。 if else处理异常 if和else本身就具有处理异常的功能，他们更多的是在我们能预测到可能出现异常的范围内进行规避异常，对于我们不能预测的异常来说就显得不是那么的好用。 如下所示，我们仅期待用户输入数字，如果是输入其他内容则会被其他逻辑所处理： while 1: choice = input(\"Please enter a digital string:\") if choice.isdigit(): print(\"success!!\") break else: print(\"You input not is a digital string!!\") try/except try和except是最常用的一种异常处理方式。 try：代表要检测可能出现异常的代码块 except：当特定异常出现后的处理情况 执行流程如下： try中检测的代码块 如果有异常 执行except代码块 执行正常逻辑 执行完毕 try中检测的代码块 如果无异常 执行完try中代码快 执行正常逻辑 执行完毕 如图所示： 示例如下，try中未抛出异常： lst = [i for i in range(3)] try: print(\"run try\") print(lst[2]) except IndexError as e: print(\"run except\") print(\"normal code\") # run try # 2 # normal code 示例如下，try中抛出异常： lst = [i for i in range(3)] try: print(\"run try\") print(lst[3]) except IndexError as e: print(\"run except\") print(\"normal code\") # run try # run except # normal code 多段except捕捉多异常 使用1个try和多个except来捕捉多种可能出现的异常： lst = [i for i in range(3)] dic = dict.fromkeys((chr(i) for i in range(65, 68)), None) try: print(lst[2]) print(dic[\"D\"]) except IndexError as e: print(\"index error %s \" % e) except KeyError as e: print(\"key error %s\" % e) print(\"normal code\") # 2 # key error 'D' # normal code 元组捕获多异常 使用多段except处理多异常会显得麻烦，可以使用except (error1, error2)来处理多个异常。 但是多个异常只有1个处理结果，故处理逻辑可能会写的比较麻烦： lst = [i for i in range(3)] dic = dict.fromkeys((chr(i) for i in range(65, 68)), None) try: print(lst[2]) print(dic[\"D\"]) except (IndexError, KeyError) as e: if isinstance(e, IndexError): print(\"index error %s\" % e) elif isinstance(e, KeyError): print(\"key error %s\" % e) print(\"normal code\") # 2 # key error 'D' # normal code except捕获万能异常 使用except Exception来捕捉所有可能出现的异常，Exception是所有异常的基类。 Exception类的父类则是BaseException类，而BaseException的父类则是object类 lst = [i for i in range(3)] dic = dict.fromkeys((chr(i) for i in range(65, 68)), None) try: print(lst[2]) print(dic[\"D\"]) except Exception as e: if isinstance(e, IndexError): print(\"index error %s\" % e) elif isinstance(e, KeyError): print(\"key error %s\" % e) print(\"normal code\") # 2 # key error 'D' # normal code try/except/esle else代表没有异常发生的情况下执行的代码，如下图所示： 如下示例： lst = [i for i in range(3)] dic = dict.fromkeys((chr(i) for i in range(65, 68)), None) try: print(lst[2]) print(dic[\"A\"]) except Exception as e: if isinstance(e, IndexError): print(\"index error %s\" % e) elif isinstance(e, KeyError): print(\"key error %s\" % e) else: print(\"don't have throw an exception\") print(\"normal code\") # 2 # None # don't have throw an exception # normal code try/except/else/finally finally代表不论抛异常与否都会执行，因此常被用作关闭系统资源的操作。 如下图所示： 如下示例： lst = [i for i in range(3)] dic = dict.fromkeys((chr(i) for i in range(65, 68)), None) try: print(lst[2]) print(dic[\"A\"]) except Exception as e: if isinstance(e, IndexError): print(\"index error %s\" % e) elif isinstance(e, KeyError): print(\"key error %s\" % e) else: print(\"don't have throw an exception\") finally: print(\"last run this\") print(\"normal code\") # 2 # None # don't have throw an exception # last run this # normal code 主动抛出异常 在某些时候我们可能需要主动的去阻止程序的运行，主动的抛出一个异常。 以防止逻辑越错越远。 raise raise可以主动的抛出一个异常，如下所示： lst = [i for i in range(3)] l = input(\"please input %s length >>>\" % lst) if not l.isdigit(): raise TypeError(\"you must input number\") if int(l) != len(lst): raise ValueError(\"your length input error, he length is not %s\" % l) if int(l) == len(lst): print(\"success!!\") assert 断言内部会进行if判断，如果判断结果为False则抛出AssertionError异常，如果为True就不抛出AssertionError异常。 如下所示： lst = [i for i in range(3)] l = input(\"please input %s length >>>\" % lst) assert l.isdigit(), \"you must input number\" assert int(l) == len(lst), \"your length input error, he length is not %s\" % l print(\"success!!\") 自定义异常 前面已经说过一切皆对象，异常也来自一个对象，所以我们可以自定义一个异常，只需要继承BaseException类即可。 如下示例，内置异常没有InputTypeError，我们来自己定义一个： class InputTypeError(BaseException): pass lst = [i for i in range(3)] l = input(\"please input %s length >>>\" % lst) if not l.isdigit(): raise InputTypeError(\"you must input number\") if int(l) != len(lst): raise ValueError(\"your length input error, he length is not %s\" % l) if int(l) == len(lst): print(\"success!!\") Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:46 "},"Python/Python数算基础/summary.html":{"url":"Python/Python数算基础/summary.html","title":"Python数算基础","keywords":"","body":" 算法与数构 list和dict性能 数构之线构篇 数构之哈希篇 数构之链表篇 算法之递归篇 算法之搜索篇 算法之排序篇 数构之树相关 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:46 "},"Python/Python数算基础/算法与数构.html":{"url":"Python/Python数算基础/算法与数构.html","title":"算法与数构","keywords":"","body":"为什么要学习数算 随着应用程序变的越来越复杂，我们最常思考的问题无非下面2个： 如何存储海量数据？ 如何从海量数据中操纵所需要的数据？ 为了解决上述问题，我们需要有合理的机制来规划如何存储数据，那么如何存储数据即为数据的结构。 同时，我们还需要制定一系列方案，来思考如何从海量数据中进行增、删、改、查，这一方案的实现即程序的算法。 尼克劳斯·埃米尔·维尔特（n.writh）说过一句很著名的话： 程序 = 算法 + 数据结构 因此，一个良好的健硕的程序，必然根据其业务场景采用了合适的数据存储方案，并且指定了一系列相关的数据操纵方案。 什么是算法 算法的定义 算法（Algorithm）是指解题方案的准确而完整的描述，是一系列解决问题的清晰指令，算法代表着用系统的方法描述解决问题的策略机制。 也就是说，能够对一定规范的输入，在有限时间内获得所要求的输出。 如果一个算法有缺陷，或不适合于某个问题，执行这个算法将不会解决这个问题。 不同的算法可能用不同的时间、空间或效率来完成同样的任务。 一个算法的优劣可以用空间复杂度与时间复杂度来衡量。 算法与语言本身无关，仅是一种解决思路，用于解决一些实际的问题 通过知名算法的学习，可以提高编程思维，优化程序代码。 算法的特征 一个算法应该具有以下五个重要的特征： 有穷性（Finiteness） 算法的有穷性是指算法必须能在执行有限个步骤之后终止； 确切（Definiteness） 算法的每一步骤必须有确切的定义； 输入项（Input） 一个算法有0个或多个输入，以刻画运算对象的初始情况，所谓0个输入是指算法本身定出了初始条件； 输出项（Output） 一个算法有一个或多个输出，以反映对输入数据加工后的结果。没有输出的算法是毫无意义的； 可行性（Effectiveness） 算法中执行的任何计算步骤都是可以被分解为基本的可执行的操作步骤，即每个计算步骤都可以在有限时间内完成（也称之为有效性）。 算法的评定 同一问题可用不同算法解决，而一个算法的质量优劣将影响到算法乃至程序的效率。 算法分析的目的在于选择合适算法和改进算法。 一个算法的评价主要从时间复杂度和空间复杂度来考虑。 除此之外，评定规则还有以下3个： 正确性 算法的正确性是评价一个算法优劣的最重要的标准 可读性 算法的可读性是指一个算法可供人们阅读的容易程度 鲁棒性 鲁棒性是指一个算法对不合理数据输入的反应能力和处理能力，也称为容错性 时间复杂度 时间复杂度是指算法的大概运行时间，是判定算法优劣的重要评定规则，使用大O进行表示。 对一个算法的时间复杂度而言，对其影响最大因素就是需要解决的问题规模。 问题规模越大，解决时间也就越久，如下图所示： 时间复杂度更多是表示一个模糊的大概时间，而并非一个具体的准确的数字。 如： 抽一支烟，这个行为大概会占用几分钟的时间 睡一觉，这个行为大概会占用几个小时的时间 当然，这只是大概，并不用进行精确的求值，因为个体差异，客观环境因素等原因都会导致这个时间度不同，没有人敢确切的说自己在任何情况下抽一支烟只花费3分钟，也没有人敢确切的说自己在任何情况下睡一觉只花费8个小时。 时间复杂度可依照基础语句对其进行判断，基础语句操作的时间复杂度记为1 除此之外还有循环次数n，和循环嵌套层数n²或者n³、至于四层循环就很少了，不再举例。 当有多种判定时，取最大的即可： 1）仅一次基础操作，时间复杂度就直接等于1： x = 1 # O(1) # 取O(1) 2）根据问题规模而变化，单次循环，时间复杂度等于循环次数n： for i in range(n): # O(n) x = i # O(1) # 取O(n) 3）一个更加复杂的问题规模，双层循环，时间复杂度等于循环次数n加上循环嵌套层数： for i in range(n): # O(n²) for j in range(n): x = i + j # O(1) # 取O(n²) 4）目前来说相当复杂的问题规模，三层循环，时间复杂度等于循环次数n加上循环嵌套层数： for i in range(n): # O(n³) for j in range(n): for k in range(n): x = i + j + k # O(1) # 取 O(n³) 当然，不要陷入逻辑误区，像下面这条语句的时间复杂度也是O(1)，因为1次基础操作和3次基础操作的速度没有本质区别，它没有一个可以改变问题规模的n，所以归类为O(1)而不是O(3)。 一定记住一句话，时间复杂度是一个模糊的估算值，并不是确切值： x = 1 x = 2 x = 3 继续判断，将下面代码看为4部分，依照取最大的原则： a = 5 # O(1) b = 6 c = 10 for i in range(n): # O(n²) for j in range(n): x = i * i y = j * j z = i * j for k in range(n): # O(n) w = a * k + 45 v = b * b d = 33 # O(1) # 取O(n²) 同时，如果双层循环中，内层循环有多个，时间复杂度也记为O(n²)，因为循环只嵌套了2层，如下所示： for i in range(n): for j in range(n): pass for k in range(n): pass # 层数是2，所以取O(n²) 还有一个常见的时间复杂度，O(logn)。 如下所示，每一次运行，问题规模减少一半，其实全部表示法是O(log2n)，简写为了O(logn)，这种时间复杂度在递归中很容易看到。 n = 64 # O(1) while n > 1: # O(log2n) print(n) # O(1) n = n // 2 以下方法可快速判断算法的时间复杂度： 确定问题规模O(n) 有没有循环减半的过程O(logn) 有几层循环O(nn) 空间复杂度 空间复杂度是用来评估算法内存占用大小的式子。 空间复杂度和时间复杂度是一种相对应的关系，一句很流行的话叫做空间换时间，也是现在的主流，如分布式等架构就是典型的空间换时间。 表示方式与时间复杂度完全一样，都采用大O表示法： 算法使用了几个变量：O(1) 算法使用了长度为n的一维列表：O(n) 算法使用了n行n列的二维列表：O(nn) 一般来说，时间复杂度的判定比空间复杂度的判定更为重要。 什么是数据结构 数据结构的定义 数据结构是计算机存储、组织数据的方式。 数据结构是指相互之间存在一种或多种特定关系的数据元素的集合。 通常情况下，精心选择的数据结构可以带来更高的运行或者存储效率。 数据结构往往同高效的检索算法和索引技术有关。 常见数据结构 线性结构：数据结构中的元素存在一对一的相互关系 树形结构：数据结构中的元素存在一对多的相互关系 图形结构：数据结构中的元素存在多对多的相互关系 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:46 "},"Python/Python数算基础/list和dict性能.html":{"url":"Python/Python数算基础/list和dict性能.html","title":"list和dict性能","keywords":"","body":"2种常用类型 在Python中，最常用的2种数据类型为list和dict。 你是否了解过它们的各种方法，时间复杂度到底如何？在那种策略下用那种方法更省时？ 两种数据类型都拥有很多方法，常用的亦或是不常用的，因此在Python设计之初定下了一个原则： 让最常用的操作性能最好，牺牲不太常用的操作 在实际使用中，80%的功能其使用率往往只有20%，因此将剩下的20%的功能时间复杂度降低，而将不常用的80%功能时间复杂度增加，做到一种均衡的策略。 其实在Python官网上，已经贴出了每种数据类型方法的时间复杂度，点我跳转 dict 官方展示 The Average Case assumes parameters generated uniformly at random. Internally, a list is represented as an array; the largest costs come from growing beyond the current allocation size (because everything must move), or from inserting or deleting somewhere near the beginning (because everything after that must move). If you need to add/remove at both ends, consider using a collections.deque instead. Operation Average Case Amortized Worst Case Copy O(n) O(n) Append[1] O(1) O(1) Pop last O(1) O(1) Pop intermediate[2] O(n) O(n) Insert O(n) O(n) Get Item O(1) O(1) Set Item O(1) O(1) Delete Item O(n) O(n) Iteration O(n) O(n) Get Slice O(k) O(k) Del Slice O(n) O(n) Set Slice O(k+n) O(k+n) Extend[1] O(k) O(k) Sort O(n log n) O(n log n) Multiply O(nk) O(nk) x in s O(n) min(s), max(s) O(n) Get Length O(1) O(1) pop()和inster() pop()和inster()通常来说有2种情况： 如果都是操纵list[-1]，也就是最后一个数据项，它们的时间复杂度均为O(1) 如果操纵的是其他数据项，则时间复杂度均为O(n) 由于list底层是顺序存储，故任何一个非index-1的数据项的添加或删除都会引起整个列表的调整。 例如，从中部移除数据项的话，要把被移除数据项后面的全部数据项向前挪一个槽位。 虽然看起来有点笨拙，但这种实现方法能够保证列表按索引取值和赋值的操作很快，能够达到O(1)的良好情况。 这也算是一种对常用和不常用操作的折衷方案吧。 dict 官方展示 The Average Case times listed for dict objects assume that the hash function for the objects is sufficiently robust to make collisions uncommon. The Average Case assumes the keys used in parameters are selected uniformly at random from the set of all keys. Note that there is a fast-path for dicts that (in practice) only deal with str keys; this doesn't affect the algorithmic complexity, but it can significantly affect the constant factors: how quickly a typical program finishes. Operation Average Case Amortized Worst Case k in d O(1) O(n) Copy[3] O(n) O(n) Get Item O(1) O(n) Set Item[1] O(1) O(n) Delete Item O(1) O(n) Iteration[3] O(n) O(n) 为什么字典这么快 dict内部采用hash存储，所以单点查找非常迅速，但不能使用范围查找。 这也是所有hash存储的特性，是属于一种典型的空间换时间的方案。 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:46 "},"Python/Python数算基础/数构之线构篇.html":{"url":"Python/Python数算基础/数构之线构篇.html","title":"数构之线构篇","keywords":"","body":"Linear Structure 认识线性结构 线性结构是一种有序的数据项集合结构，线性结构中除开第一个后最后一个数据项，其他每一个数据项都有前驱和后继，如图所示： 当新的数据项加入到数据集中时，只会加入到原有某个数据项之前或之后。 具有这种性质的数据集，就称为线性结构。 如Python中的list、tuple等数据类型都属于线性结构。 特点介绍 线性结构总有2端，在不同情况下，2端的称呼也不同。 如称呼为：(前端、后端)，（左端、右端）、（首端、尾端）： 还有称呼为：（上端、下端）、（顶端、底端）： 两端的称呼并不是关键，不同线性结构的关键区别在于数据项增减的方式。 有的线性结构只允许数据项从一端添加或删除，而有的线性结构则允许数据项从两端添加或删除，或者从任意位置添加或删除： 栈（Stack） 栈的特点 栈是一种数据项进出有序的线性结构，在栈中，所有数据项的加入和移除都只能发生在栈顶（stack top），而栈底（stack base）则不能有其他操作。 栈中的数据项总是按照后进先出（LIFO）的特性进行出入栈，如下图所示： 栈有一个特性，即进栈和出栈的次序正好相反。 这种访问次序反转的特性，我们在某些计算机操作上也经常碰到过，如浏览器的“后退back”按钮，最先back的是最近访问的网页，再比如Word的“Undo”按钮，最先撤销的是最近操作。 ADT Stack 如果要使用Python来定义栈这种数据结构，则应当提供以下方法： 方法名 描述 ADTStack() 一个类，用于构建一个空栈 push() 将值加入到栈顶，无返回值 pop() 将栈顶数据项移除，并返回被移除的数据项，栈会被修改 peek() “窥视”栈顶数据项，返回栈顶的数据项但不移除，栈不被修改 isEmpty() 返回栈是否为空栈 size() 返回栈中有多少个数据项 接下来我们基于Python内置的数据类型list，来实现一个栈。 其实实现非常简单，唯一需要考虑的就是栈顶是index-1处还是index0处。 推荐将index-1处作为栈顶，这样在进行出栈操作时list.pop()和list.append()方法时间复杂度为O(1)，而如果将index0处作为栈顶，则list.pop(0)和list.insert(0, item)方法的时间复杂度为O(n)： 以下是代码实现： #!/usr/bin/env python3 # -*- coding:utf-8 -*- class ADTStack: def __init__(self) -> None: self.stack = [] def push(self, item): self.stack.append(item) def pop(self): return self.stack.pop() def peek(self): return self.stack[-1] def isEmpty(self): return not bool(self.stack) def size(self): return len(self.stack) 符号匹配 我们可以利用栈的特性实现一个符号匹配，一组括号必须成对出现，如下所示： { { ( [ ] [ ] ) } ( ) } [ [ { { ( ( ) ) } } ] ] [ ] [ ] [ ] ( ) { } 如果不是成对出现的，像下面这样，就匹配失败： ( [ ) ] ( ( ( ) ] ) ) [ { ( ) ] 代码如下： from linear_structure import ADTStack def SymbolMatch(symbolString): s = ADTStack() leftSymbolString = \"([{\" rightSymbolString = \")]}\" for char in symbolString: # 如果被循环的字符是左符号 if char in leftSymbolString: s.push(char) # 如果被循环的字符不是左符号，也不是右符号，则抛出异常 elif char not in rightSymbolString: raise ValueError(\"character:% s does not support matching\" % char) # 开始循环右符号 else: # 1. 如果是空栈，代表左右符号个数不一，直接返回False # 2. 如果不是空栈，则判定左右符号是否匹配，如果不匹配直接返回False if s.isEmpty() or leftSymbolString.index(s.pop()) != rightSymbolString.index(char): return False # 循环完毕，判定所有左符号是否匹配完毕 return True if s.isEmpty() else False if __name__ == \"__main__\": print(SymbolMatch(\"{{([][])}()}\")) print(SymbolMatch(\"[{()]\")) 进制转换 使用栈的特性，我们可以快速实现2、8、16进制转换为10进制的函数。 思路图示，10进制转换2、8、16进制都可采用求余法，下图以2进制举例： 代码如下： from linear_structure import ADTStack def baseConversion(decimalNumber, base): s = ADTStack() digits = \"0123456789ABCDEF\" while decimalNumber > 0: quotient, residue = divmod(decimalNumber, base) decimalNumber = quotient s.push(residue) newString = \"\" while not s.isEmpty(): newString += digits[s.pop()] return newString if __name__ == \"__main__\": print(baseConversion(101, 2)) print(baseConversion(101, 8)) print(baseConversion(101, 16)) # 1100101 # 145 # 65 队列（Queue） 队列的特点 队列是一种数据项进出有序的线性结构，在队列中，数据项的添加总发生在其中一端（通常称为尾“tail”端），而数据项的移除总发生在另一端（通常称为首“head”端） 队列中的数据项总是按照先进后出（FILO）的特性进行出入栈，如下图所示： 队列仅有一个入口和一个出口，不允许数据项直接插入队中，也不允许从中间移除数据项。 队列其实在生活中随处可见，如排队、必须等到前一个人出队后，后一个人才能接着出队，当然新来的成员也不能进行插队，要想入队只能从队尾开始排列。 ADT Queue 如果要使用Python来定义一个队列这种数据类型，则应当提供以下方法： 方法名 描述 ADTQueue() 一个类，用于构建一个空队列 enqueue() 将值加入到队尾，无返回值 dequeue() 将队首数据项移除，并返回被移除的数据项，队列会被修改 isEmpty() 返回队列是否为空 size() 返回队列中有多少个数据项 接下来我们基于Python内置的数据类型list，来实现一个队列。 如果将list的index0处作为队列尾端，list的index-1处作为队列首端，则enqueue()复杂度为O(n)，而dequeue()复杂度为O(1) 如果将list的index0处作为队列首端，list的index-1处作为队列尾端，则enqueue()复杂度为O(1)，而dequeue()复杂度为O(n) 以下是代码实现，采用第2种方案，将list的index0处作为队列首端： #!/usr/bin/env python3 # -*- coding:utf-8 -*- class ADTQueue: def __init__(self) -> None: self.queue = [] def enqueue(self, item): self.queue.append(item) def dequeue(self): return self.queue.pop(0) def isEmpty(self): return not bool(self.queue) def size(self): return len(self.queue) 约瑟夫环 传说犹太人反叛罗马人，落到困境，约瑟夫和40人决定殉难，坐成一圈儿，报数1～7，报到7的人由旁边杀死，结果约瑟夫给自己安排了个位置，最后活了下来...... 现在，使用队列模拟解决约瑟夫环问题，队首始终是要被杀死的人，因此从第一轮开始由队首的人开始出队，每数到7，在队首的人就不必再入队了，依次循环往复： from linear_structure import ADTQueue def Joseph(nameList, num): q = ADTQueue() # 所有人加入游戏 for name in nameList: q.enqueue(name) # 只要剩下的人数大于1，游戏就继续 while q.size() > 1: # 前6个都没事 for i in range(num - 1): q.enqueue(q.dequeue()) # 第7个死掉 q.dequeue() return q.dequeue() if __name__ == \"__main__\": nameList = (\"position:%s\" % i for i in range(1, 42)) survivor = Joseph(nameList, 7) print(survivor) 双端队列（Deque） 双端队列的特点 双端队列是一种数据项进出有序的线性结构，跟队列相似，其两端可以称作“首”“尾”端或者“左”“右”端，但双端队列中数据项既可以从队首加入，也可以从队尾加入，数据项也可以从两端移除。 某种意义上说，双端队列集成了栈和队列的能力： 双端队列并不具有内在的LIFO或者FIFO特性，如果用双端队列来模拟栈或队列需要由使用者自行维护操作的一致性。 ADT Deque 如果要使用Python来定义一个双端队列这种数据类型，则应当提供以下方法： 方法名 描述 ADTDeque() 一个类，用于构建一个空的双端队列 appendLeft() 将值加入到队首，无返回值 appendRight() 将值加入到队尾，无返回值 popLeft() 将队首数据项移除，并返回被移除的数据项，队列会被修改 popRight() 将队尾数据项移除，并返回被移除的数据项，队列会被修改 isEmpty() 返回队列是否为空 size() 返回队列中有多少个数据项 接下来我们基于Python内置的数据类型list，来实现一个双端队列。 如果将list的index0处作为双端队列尾端，list的index-1处作为双端队列首端，则appendLeft()和popLeft()时间复杂度为O(1)，而appendRight()和popRight()时间复杂度为O(n) 如果将list的index0处作为双端队列首端，list的index-1处作为双端队列尾端，则appendLeft()和popLeft()时间复杂度为O(n)，而appendRight()和popRight()时间复杂度为O(1) 以下是代码实现，采用第2种方案，将list的index0处作为队列首端： #!/usr/bin/env python3 # -*- coding:utf-8 -*- class ADTDeque: def __init__(self) -> None: self.dequeue = [] def appendLeft(self, item): self.dequeue.insert(0, item) def appendRight(self, item): self.dequeue.append(item) def popLeft(self): return self.dequeue.pop(0) def popRight(self): return self.dequeue.pop() def isEmpty(self): return not bool(self.dequeue) def size(self): return len(self.dequeue) 回文词判定 我们可以利用双端队列的特性，进行回文词判定，如radar、madam、toot。 再比如中文短句“上海自来水来自海上”“山东落花生花落东山”等。 实现思路也非常简单，先将需要判定的词从队尾加入deque再从两端同时移除字符判定是否相同，直到deque中剩下0个或1个字符，代码如下： from linear_structure import ADTDeque def termJudgment(string): dq = ADTDeque() for ch in string: dq.appendLeft(ch) while dq.size() > 1: first = dq.popLeft() last = dq.popRight() if first != last: return False return True if __name__ == \"__main__\": print(termJudgment(\"radar\")) print(termJudgment(\"radarr\")) Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:46 "},"Python/Python数算基础/数构之哈希篇.html":{"url":"Python/Python数算基础/数构之哈希篇.html","title":"数构之哈希篇","keywords":"","body":"Hash Table 散列表（hash table）也被称为哈希表，它是一种根据键（key）来存储值（value）的特殊线性结构。 常用于迅速的无序单点查找，其查找速度可达到常数级别的O(1)。 散列表数据存储的具体思路如下： 每个value在放入数组存储之前会先对key进行计算 根据key计算出一个重复率极低的指纹 根据这个指纹将value放入到数组的相应槽位中 同时查找的时候也将经历同样的步骤，以便能快速的通过key查出想要的value。 这一存储、查找的过程也被称为hash存储、hash查找。 如图所示： 我们注意观察，其实散列表中的每一个槽位不一定都会被占据，它是一种稀疏的数组结构，即有许多的空位，并不像list那种顺序存放的结构一样必须密不可分，这就导致了散列表无法通过index来进行value的操作。 散列表在Python中应用非常广泛，如dict底层就是散列表实现，而dict也是经历了上述步骤才将key-value进行存入的，后面会进行介绍。 名词释义 在学习Hash篇之前，介绍几个基本的相关名词： 散列表（hash table）：本身是一个普通的数组，初始状态全是空的 槽位（slot、bucket）：散列表中value的存储位置，用来保存被存入value的地方，每一个槽位都有唯一的编号 哈希函数（hash function）：如图所示，它会根据key计算应当将被存入的value放入那一个槽位 哈希值（hash value）：哈希函数的返回值，也就是对数据项存放位置的结算结果 还有2个比较专业性的词汇： 散列冲突：打个比方，k1经过hash函数的计算，将v1存在了1号槽位上，而k22也经过了hash函数的计算，发现v2也应该存在1号槽位上。 现在这种情况就发生了散列冲突，v2会顶替v1的位置进行存放，原本1号槽位的存放数据项会变为v2。 负载因子：说白了就说这个散列表存放了多少数据项，如11个槽位的一个散列表，存放了6个数据项，那么该散列表的负载因子就是6/11 哈希函数 如何通过key计算出value所需要插入的槽位这就是哈希函数所需要思考的问题。 求余哈希法 如果我们的key是一串电话号码，或者身份证号，如436-555-4601： 取出数字，并将它们分成2位数（43，65，55，46，01） 对它们进行相加，得到结果为210 假设散列表共有11个槽位，现在使用210对11求余数，结果为1 那么这个key所对应的value就应当插入散列表中的1号槽位 平方取中法 平方取中法如下，现在我们的key是96： 先计算它的平方值：96^2 平方值为9216 取出中间的数字：21 假设散列表共有11个槽位，现在使用21对11求余数，结果为10 那么这个key所对应的value就应当插入散列表中的10号槽位 字符串求值 上面举例的key都是int类型，如果是str类型该怎么做？ 我们可以遍历这个str类型的key，并且通过内置函数ord()来将它字符转换为int类型： >>> k = \"hello\" >>> i = 0 >>> for char in k: i += ord(char) >>> i 532 然后再将其对散列表长度求余，假设散列表共有11个槽位，现在使用532对11求余数，结果为4 那么这个key所对应的value就应当插入散列表中的4号槽位。 字符串问题 如果单纯的按照上面的方式去做，那么一个字符完全相同但字符位置不同的key计算的hash结果将和上面key的hash结果一致，如下所示： >>> k = \"ollhe\" >>> i = 0 >>> for char in k: i += ord(char) >>> i 532 如何解决这个问题呢？我们可以使用字符的位置作为权重进行解决： 代码设计如下： def getHash(string): idx = 0 hashValue = 0 while idx 完美散列函数 为了应对散列冲突现象的发生，我们必须严格定制hash函数根据key生产hash值的这一过程，尽量做到每一个不同key产生的hash值都是不重复的，能做到这一点的hash函数被称为完美散列函数。 如何设计完美散列函数？主要看该散列函数产生的散列值是否有以下特性： 压缩性：任意长度的数据，得到的“指纹”长度是固定的 易计算性：从原数据计算“指纹”很容易 抗修改性：对原数据的微小变动，都会引起“指纹”的大改变 抗冲突性：已知原数据和“指纹”，要找到相同指纹的数据（伪造）是非常困难的 介绍2种产生散列函数的方案，MD5和SHA系列函数。 MD5（MessageDigest）将任何长度的数据变换为固定长为128位（16字节 ）的“摘要” SHA（SecureHashAlgorithm）是另一组散列函数 SHA-0/SHA-1输出散列值160位（20字节） SHA-256/SHA-224分别输出256位、224位 SHA-512/SHA-384分别输出512位和384位 128位二进制已经是一个极为巨大的数字空间：据说是地球沙粒的数量，MD5能达到这种效果。 160位二进制相当于10的48次方，地球上水分子数量估计是47次方，SHA-0能达到这种效果。 256位二进制相当于10的77方， 已知宇宙所有基本粒子大约是72～87次方，SHA-256能达到这种效果。 所以一般来说，MD5函数作为散列函数是非常合适的，而在Python中使用它们也非常简单： #! /usr/local/bin/python3 # -*- coding:utf-8 -*- import hashlib m = hashlib.md5(\"salt\".encode(\"utf8\")) m.update(\"HELLO\".encode(\"utf8\")) print(m.hexdigest()) # ad24f795146b59b78c145fbd6b7f4d1f 像这种方案，通常还被应用到一致性校验中，如文件下载、网盘分享等。 只要改变任意一个字节，都会导致散列值发生巨大的变化。 散列冲突 如果两个不同的key被散列映射到同一个槽位，则需要一个系统化的方法在散列表中保存第2个value。 这个过程称为“解决冲突”，除了可以使用完美散列函数进行解决之外，以下也会介绍一些常见的解决办法。 开放定址法 所谓的开放定址法就是一旦发生了冲突，就去寻找下一个空的散列地址，只要散列表足够大，空的散列地址总能找到，并将记录存入。 从冲突的槽开始往后扫描，直到碰到一个空槽如果到散列表尾部还未找到，则从首部接着扫描： 这种寻找空槽的技术称为“开放定址openaddressing” 逐个向后寻找空槽的方法则是开放定址技术中的“线性探测linearprobing” 如下图所示： 它有一个缺点，就是会造成数据项扎堆形成聚集（clustering）的趋势，这会影响到其他数据项的插入。 比如上图中4号和5号槽位都被占据了，下次的v3本来是要插入到5号槽位的，但是5号槽位被v1占据了，它就只能再次向后查找： 针对这个缺点，可以做一个优化措施，即线性探测的范围从1变为3，每次向后查找3个槽位。 或者让线性探测的范围不固定，而是按照线性的趋势进行增长，如第一次跳3个，第二次跳5个，第三次跳7个等等，也是较好的解决方案。 如果采用跳跃式探测方案，则需要注意： 跳跃步数的取值不能被散列表大小整除，否则会产生周期性跳跃，从而造成很多空槽永远无法被探测到 这里提供一个技巧，把散列表的大小设为素数，如11个槽位大小的散列表就永远不会产生跳跃式探测方案的插槽浪费。 再哈希法 再哈希法又叫双哈希法，有多个不同的hash函数，当发生冲突时，使用第二个，第三个，等哈希函数计算槽位，直到出现空槽位后再插入value。 虽然不易发生聚集，但是增加了计算时间。 链地址法 每个哈希表节点都有一个next指针，多个哈希表节点可以用next指针构成一个单向链表，被分配到同一个索引上的多个节点可以用这个单向链表向后排列。 如下图所示： 公共溢出区 将哈希表分为基本表和溢出表两部分，凡是和基本表发生冲突的元素，一律填入溢出表。 当要根据key查找value时，先查找基本表，再查找溢出表。 ADT Map 思路解析 Python的dict是以一种key-value的键值对形式进行保存，也被称之为映射。 我们如何使用Python的list来实现一个类似的数据结构呢？参照dict，有2大因素： key必须具有唯一性，不可变 通过key可以唯一的确定一个value 在做ADT Map之前，思考一下它应该具有哪些方法： 方法 描述 ADTMap() 创建一个空的映射，返回空映射对象 set() 将key-val加入映射中，如果key已存在，将val替换旧关联值 get() 给定key，返回关联的数据值，如不存在，则返回None pop() 给定key，删除键值对，返回value，如果key不存在，则抛出KeyError，不进行缩容进制 len() 返回映射中key-val关联的数目 keys() 返回map的视图，类似于dict.keys() values() 返回map的视图，类似于dict.values() items() 返回map的视图，类似于dict.items() clear() 清空所有的key-val，触发缩容机制 in 通过key in map的语句形式，返回key是否存在于关联中，布尔值 [] 支持[]操作，与内置dict一致 for 支持for循环，与内置dict一致 我们都知道，Python3.6之后的dict是有序的，所以ADT Map也应该实现有序，减少遍历次数。 Ps：详情参见Python基础dict一章 另外还需要思考： 散列表应该是什么结构？ 采用怎样的哈希函数？ 如何解决可能出现的hash冲突？ 如何做到动态扩容？ 首先第一个问题，我们的散列表采用二维数组方式进行存储，具体结果如下，初始散列表长度为8，内容全为None，与Python内置的dict初始容量保持一致： [ [hash值, key, value], [hash值, key, value], [hash值, key, value], ... ] 第二个问题，这里采用字符串求值的哈希函数，也就是说key支持str类型 第三个问题，解决hash冲突采用开放定址+定性的线性探测 第四个问题，动态扩容也按照Python底层实现，即当容量超过三分之二时，进行扩容，扩容策略为已有散列表键值对个数 * 2，而在pop()时不进行缩容，但是在clear()会进行缩容，将散列表恢复初始状态。 map实现 下面是按照Python的dict底层实现的动态扩容map： #!/usr/bin/env python3 # -*- coding:utf-8 -*- class ADTMap: def __init__(self) -> None: # 初始容量为8 self.cap = 8 # 已有键值对个数为0 self.size = 0 # 初始map self.map = [[None] * 3] * self.cap # map顺序表 self.order = [None] * self.cap def set(self, key, value): # 求hash值 hashValue = self.__getHash(key) # 求插入或者更新槽位 slotIdx = self.__getSlot(hashValue) # 检查是否需要扩容, 当容量超过三分之二时，即进行扩容（resize）机制 if (self.size + 1 > round(self.cap * (2 / 3))): self.__resize() # 添加键值对 self.map[slotIdx] = [hashValue, key, value] self.size += 1 # 添加顺序表，如果是更新value，则不用添加 for i in range(len(self.order)): if self.order[i] is None or slotIdx == self.order[i]: self.order[i] = slotIdx break def get(self, key): # 求hash值 hashValue = self.__getHash(key) # 求key所在槽位 slotIdx = self.__getSlot(hashValue) return self.map[slotIdx][2] def pop(self, key): # 求hash值 hashValue = self.__getHash(key) # 求key所在槽位 slotIdx = self.__getSlot(hashValue) if self.map[slotIdx][2] == None: raise KeyError(\"%s\" % key) # 移除key self.size -= 1 retValue = self.map[slotIdx][2] self.map[slotIdx] = [None] * 3 for idx in range(len(self.order)): if self.order[idx] == slotIdx: # 删除 del self.order[idx] # 在最后添加空的，确保前面都是有序的不会出现None self.order.append([None] * 3) break return retValue def keys(self): for idx in self.order: if idx is not None: yield self.map[idx][1] else: break def values(self): for idx in self.order: if idx is not None: yield self.map[idx][2] else: break def items(self): for idx in self.order: if idx is not None: yield self.map[idx][1], self.map[idx][2] else: break def clear(self): self.cap = 8 self.size = 0 self.map = [[None] * 3] * self.cap self.order = [None] * self.cap def __setitem__(self, name, value): self.set(key=name, value=value) def __getitem__(self, name): return self.get(key=name) def __delitem__(self, name): # del map[\"k1\"] 无返回值 self.pop(key=name) def __contains__(self, item): keyList = self.keys() for key in keyList: if key == item: return True return False def __iter__(self): # 直接迭代map则返回keys列表 return self.keys() def __getHash(self, key): # int类型的keyhash值是其本身 if isinstance(key, int): return key # str类型需要使用ord()进行转换，并添加位权 if isinstance(key, str): idx = 0 v = 0 while idx str: retStr = \"\" for idx in self.order: if idx is not None: retStr += \" \" % (self.map[idx][1], self.map[idx][2]) else: break retStr = \"[\" + retStr + \"]\" return retStr Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:46 "},"Python/Python数算基础/数构之链表篇.html":{"url":"Python/Python数算基础/数构之链表篇.html","title":"数构之链表篇","keywords":"","body":"线性表(linear list) 顺序表(order list) Python中list和tuple的实现都是基于一种叫顺序表的东西。 顾名思义，所有的数据项都是有序的并且在一片连续的内存空间中存放，在使用顺序表进行存储时，需预先申请一整块足够大的存储空间，然后将数据按照次序逐一存储，数据项之间紧密贴合，不留一丝空隙： 当pop()掉任意一个非尾部数据项时，会导致pop()后的所有数据项前推，如下图所示： 同理，当insert()一个数据项时，如果insert()的数据项未在顺序表尾部，也会导致所有insert()后的数据项后移，如下图所示： 顺序表的优秀在于其查找性能，由于是顺序存储，故可以通过index直接获取到数据项本身，时间复杂度为O(1)，但缺点也很明显，诸如pop()、insert()、remove()等操作都会造成数据项前推或后移，时间复杂度是O(n)。 链表(linked list) 链表（Linked list），也是一种线性结构的数据类型，存储方式与顺序表截然相反，什么时候存储数据，什么时候才申请存储空间，数据之间的逻辑关系依靠每个数据项携带的指针维持： 链表的优秀在于其扩展性上，链表中数据项元素之间的逻辑关系靠的是节点之间的指针维持。 当需要在链表中某处插入或删除节点时，只需改变相应节点的指针指向即可，无需大量移动数据项，时间复杂度为O(1)。 而缺点在于其查找性能上，在链表中访问数据项，需要从链首依次遍历，直到找到指定节点，花费的时间复杂度为 O(n)。 下表中对顺序表和链表进行总结： 插入、删除、移动 查询 内存申请 链表 O(1) 需要从链首开始查找，所以是O(n) 按需申请 顺序表 由操作数据项的位置决定，最差情况是O(n) 顺序表中可直接使用index进行查询，所以是O(1) 一次申请 单向链表 认识单向链表 单向链表（Unidirectional Linked List）顾名思义，每个链表节点之间只有next指针，没有prev指针。 如下图所示： 如果需要让你来实现一个抽象的单向链表，你会如何设计呢？ 1）需要有一个LinkedListNode类，作为链表中的各个节点，主要包含以下属性和方法： self.nextNode：下一个节点指向，tail节点该属性总是为None self.dataItem：当前节点数据项 getData(self)：获取当前节点数据项 setData(self, item)：设置当前节点数据项 getNext(self)：获取当前节点的下一个节点 setNext(self, node)：设置当前节点的下一个节点 __str__(self) -> str：返回当前节点对象的显示 2）还需要有一个LinkedList类，来进行管理其中的各个节点，它主要包含以下属性和方法： self.head：当前链表中第一个节点 self.tail：当前链表中最后一个节点 self.size：当前链表的节点数量 add(self, item)：为当前链表增加一个新节点 search(self, item)：搜索并返回当前链表中某一个节点，若链表为空或被搜索节点不存在，使用该方法则抛出异常 remove(self, item)：删除并返回当前链表中某一个节点，若链表为空或被删除节点不存在，使用该方法则抛出异常 __str__(self) -> str：返回当前链表对象的显示 __len__(self) -> int：返回当前链表的长度 增加节点 增加节点的add()方法应当考虑将newNode插入到哪里性能最高？这个时候又分2种情况： 你的链表是无序链表 你的链表是有序链表 如果是无序链表，则可以直接插入在self.head节点前，或者也可以选择直接插入在self.tail节点后，它们的时间复杂度均为O(1)，这里需要注意2个点： 直接插入在self.head节点之前，列表总是以 直接插入在self.tail节点之后，列表总是以 -> 的方向新增节点 如下图所示： 如果是有序链表，则在插入前需要进行节点搜索并判断节点数据项的大小，由于此时的插入受到插入节点数据项大小与整体链表长度的因素影响，故插入性能是O(n)，如下图所示： 除了插入位置的考虑外，我们还需要考虑怎么添加新节点，单向链表比较简单，总体来说分为2步： 将newNode链接到currentSearchNextNode上 将currentSearchNode链接到newNode上 我们以单向有序链表举例，如下图所示： 这个顺序十分重要，如果将步骤互换，则会导致链表断开，currentSearchNextNode就找不到了： 当然也有解其他决方案，你可以用一个临时变量来存储currentSearchNextNode，但是并不推荐这样做。 搜索节点 如果是无序单向链表的查找，则需要从链首查到链尾，对比所有节点值与被查找的数据项是否一致，返回被查找的节点或者None，时间复杂度为O(n)。 如果是有序单向链表的查找，则只需要从链首查到大于被查找数据项的节点即可，也是返回被查找的节点或者None，时间复杂度为O(n)。 删除节点 节点的删除和节点查询的方法相差无几，唯一需要注意的是如果找到被删除的节点，则需要记录该节点的前一个节点，以便于删除currentSearchNode后让currentSearchPrevNode和currentSearchNextNode进行链接。 那么整体的顺序也是让currentSearchPrevNode指向currentSearchNextNode后，再将currentSearchNode的next指向清除。 如下图所示： 单向无序链表实现 下面是单向无序链表的实现代码： #!/usr/bin/env python3 # -*- coding:utf-8 -*- class UnidirectionalDisorderLinkedListNode: def __init__(self, dataItem) -> None: self.nextNode = None self.dataItem = dataItem def getData(self): return self.dataItem def setData(self, item): self.dataItem = item def getNext(self): return self.nextNode def setNext(self, node): self.nextNode = node def __str__(self) -> str: return str(\"\" % self.dataItem) class ADTUnidirectionalDisorderLinkedList: def __init__(self) -> None: self.head = None self.tail = None self.size = 0 def add(self, item): newNode = UnidirectionalDisorderLinkedListNode(dataItem=item) # 第一次插入 if self.head is None: self.head = newNode self.tail = newNode # 其他的插入 else: self.tail.setNext(newNode) self.tail = newNode self.size += 1 def search(self, item): if not self.size: raise ValueError(\"empty linked list not support search\") # 开始查找数据项 currentSearchNode = self.head # 遍历整个链表 while currentSearchNode is not None: if currentSearchNode.getData() == item: return currentSearchNode else: currentSearchNode = currentSearchNode.getNext() # 没找到，抛出异常 raise ValueError(\"%s does not exist\" % item) def remove(self, item): if not self.size: raise ValueError(\"empty linked list not support remove\") # 开始查找数据项 currentSearchNode = self.head currentSearchPrevNode = None # 遍历整个链表 while currentSearchNode is not None: # 符合条件 if currentSearchNode.getData() == item: # 被删除节点是链首 if currentSearchNode is self.head: self.head = currentSearchNode.getNext() # 被删除节点是链尾 elif currentSearchNode is self.tail: self.tail = currentSearchPrevNode self.tail.setNext(None) else: currentSearchPrevNode.setNext(currentSearchNode.getNext()) self.size -= 1 return currentSearchNode # 不符合条件，继续向下找 else: currentSearchPrevNode = currentSearchNode currentSearchNode = currentSearchNode.getNext() # 没找到，抛出异常 raise ValueError(\"%s does not exist\" % item) def __str__(self) -> str: if not self.size: return \"{}\" currentSearchNode = self.head retStr = \"{ \" while currentSearchNode.getNext() is not None: retStr += \"[%r] -> \" % currentSearchNode.getData() currentSearchNode = currentSearchNode.getNext() retStr += \"[%r] node-size:%r }\" % ( currentSearchNode.getData(), self.size) return retStr def __len__(self) -> int: return self.size 单向有序链表实现 下面是单向有序链表的实现代码： #!/usr/bin/env python3 # -*- coding:utf-8 -*- class UnidirectionalOrderLinkedListNode: def __init__(self, dataItem) -> None: self.nextNode = None self.dataItem = dataItem def getData(self): return self.dataItem def setData(self, item): self.dataItem = item def getNext(self): return self.nextNode def setNext(self, node): self.nextNode = node def __str__(self) -> str: return str(\"\" % self.dataItem) class ADTUnidirectionalOrderLinkedList: def __init__(self) -> None: self.head = None self.tail = None self.size = 0 def add(self, item): newNode = UnidirectionalOrderLinkedListNode(dataItem=item) # 第一次插入 if self.head is None: self.head = newNode self.tail = newNode # 其他的插入 else: currentSearchNode = self.head currentSearchPrevNode = None # 寻找插入位置 while currentSearchNode is not None and currentSearchNode.getData() str: if not self.size: return \"{}\" currentSearchNode = self.head retStr = \"{ \" while currentSearchNode.getNext() is not None: retStr += \"[%r] -> \" % currentSearchNode.getData() currentSearchNode = currentSearchNode.getNext() retStr += \"[%r] node-size:%r }\" % ( currentSearchNode.getData(), self.size) return retStr def __len__(self) -> int: return self.size 其他链表 双向链表 双向链表（double linked list）即每个节点除了拥有next指针外还有一个prev指针，如下图所示： 单向循环链表 单向循环链表是指tail节点会将next指针指向head节点，如下图所示： 双向循环链表 双向循环链表是指head节点的prev指针会指向tali节点，而tail节点的next指针会指向head节点，如下图所示： 跳跃表 普通的有序链表查找速度均为O(n)，总是按照一条线向后进行查找。 我们可以为链表中关键节点建立层级索引，如下图所示，这样就构成了跳跃表： 当要查询时，则从层级索引开始往下找，查找速度为O(logn)，但是空间复杂度会增加为O(n)，是典型的空间换时间的查询方式： Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:46 "},"Python/Python数算基础/算法之递归篇.html":{"url":"Python/Python数算基础/算法之递归篇.html","title":"算法之递归篇","keywords":"","body":"递归前言 递归（Recursion）相信各位都非常了解了，所以这里就不再详细阐述，具体可参照Python函数章节中的递归函数。 递归三大定律如下： 递归算法必须有一个基本结束条件 递归算法必须能改变问题规模 递归算法必须调用自身 分治策略 分治策略是指将一个大规模的问题分解成更小的相同问题，经过持续分解到最后问题规模小到可以用非常简单直接的方式来解决，或者将一个问题拆分成不同的各个部分，分而解决分而治之。 分治策略一般会经历三个步骤： 划分：此步骤涉及将问题分解为更小的子问题。子问题应该代表原始问题的一部分。这一步通常采用递归方法来划分问题，直到没有子问题可以进一步划分。在这个阶段，子问题本质上变成了原子，但仍然代表了实际问题的一部分 解决：这一步需要解决很多较小的子问题。通常，在此级别上，问题被视为自行“解决”。 合并：当较小的子问题得到解决时，这个阶段会开始递归地组合它们，直到它们合并成出原始问题的解决方案。 进制转换 前面的线性结构（栈）我们实现了一次10进制转换2、8、16进制，如果利用递归函数则整个实现过程又会变的非常简单。 如下所示： def baseConversion(n, base): digits = \"0123456789ABCDEF\" if n 汉诺塔 汉诺塔问题是由法国数学家爱德华·卢卡斯在 1883 年提出的。 他的灵感来自一个传说，有一个印度教寺庙，将谜题交给年轻的牧师，在开始的时候，牧师被给予三根杆和一堆 64 个金碟，每个盘比它下面一个小一点。 牧师的任务是将所有 64 个盘子从三个杆中一个转移到另一个。 有两个重要的约束： 一次只能移动一个盘子 不能在较小的盘子顶部上放置更大的盘子。 牧师日夜不停每秒钟移动一块盘子，传说，当他完成工作时，寺庙会变成灰尘，世界将消失。 游戏规则如下图所示： 如何用递归法求解呢？我们先对汉诺塔本身的游戏规则进行分析。 在上图中可以看到，s和m型号的圆盘，必须通过C号杆子再坐落到B号杆子上，我们可以将任意数量的非最大号的圆盘看为一整组，而最大号圆盘单独分为一组，总共将圆盘分为2组，并且在移动时按照组来进行划分： 算法如下，如此只要分三步即可： 把n-1个圆盘从柱子A经过C移动到B，但是省略掉到C的步骤，直接到B即可 把第n圆盘（最大的圆盘）从A移动到C 把n-1个圆盘从B经过A移动到C，但是省略掉到A的步骤，直接到C即可 代码如下，先按照3个圆盘求解： def hanoi(n, a, b, c): if n: # 从a经过c到b hanoi(n - 1, a, c, b) # 从a到c print(\"moving from %s to %s\" % (a, c)) # 从b经过a到c hanoi(n - 1, b, a, c) if __name__ == \"__main__\": hanoi(3, \"A\", \"B\", \"C\") # moving from A to C # moving from A to B # moving from C to B # moving from A to C # moving from B to A # moving from B to C # moving from A to C 贪心策略 贪心算法（又称贪婪算法）是指，在对问题求解时，总是做出在当前看来是最好的选择。 也就是说，不从整体最优上加以考虑，算法得到的是在某种意义上的局部最优解 。 贪心算法不是对所有问题都能得到整体最优解，关键是贪心策略的选择 。 找硬币问题 假设你为一家自动售货机厂家编程序，自动售货机要每次找给顾客最少数量硬币； 假设某次顾客投进$1(美元)纸币，买了ȼ37(美分)的东西，要找ȼ63，那么最少数量就是：2个quarter（ȼ25）、1个dime（ȼ10）和3个penny（ȼ1），一共6个。 人们会采用各种策略来解决这些问题，例如最直观的“贪心策略”，一般我们这么做： 从最大面值的硬币开始找起，用尽量少的硬币找尽量多的余额，直至最大的找不开 再到下一个最大面值的硬币，直至到penny（ȼ1）为止。 因为我们每次都试图解决问题的最大部分，对应到兑换硬币问题上就是每次以最多数量的最大面值硬币来迅速减少找零面值，这就是贪心策略，代码如下，你可以尝试将它改写成递归实现的： def findCoins(coinValueList, change): \"\"\" :param coinValueList: 传入硬币体系 :param change: 传入需要找回的硬币 :return: 返回的信息，找回多少 \"\"\" minCoins = \"\" for coin in coinValueList[::-1]: # 如果需要找的钱大于最大的面值，则算法开始 if change >= coin: # 最多找几枚最大面值的硬币? n = int(change // coin) # 最多能找多少钱? amount = n * coin # 还差多少钱没找？准备开始下一轮 change -= amount # 本次找了多少枚硬币，硬币是多少元 minCoins += \"%s枚%s元硬币\\n\" % (n, coin) return minCoins if __name__ == '__main__': print(findCoins([1, 5, 10, 25], 63)) # 2枚25元硬币 # 1枚10元硬币 # 3枚1元硬币 递归实现如下： def findCoins(coinValueList, change): minCoins = \"\" coin = coinValueList[-1] if change >= coin: n = int(change // coin) amount = n * coin change -= amount minCoins += \"%s枚%s元硬币\\n\" % (n, coin) if change == 0: return minCoins return findCoins(coinValueList[:-1], change=change) + minCoins if __name__ == '__main__': print(findCoins([1, 5, 10, 25], 63)) # 3枚1元硬币 # 1枚10元硬币 # 2枚25元硬币 动态规划 动态规划方法类似于分治法，将问题分解为更小的可能的子问题，但与分而治之不同的是，这些子问题不是独立解决的，相反，这些较小子问题的结果会被记住并用于相似或重叠的子问题。 在我们遇到问题的地方使用动态规划，可以将这些问题划分为类似的子问题，以便可以重复使用它们的结果。 大多数情况下，该算法往往用于优化。在解决现有子问题之前，动态算法将尝试检查先前解决的子问题的结果。将子问题的解决方案组合起来以获得最佳解决方案。 所以我们可以说： 问题应该能够分成更小的重叠子问题 最优解可以通过使用较小子问题的最优解来实现 动态算法使用记忆化 Elbonia奇怪的硬币体系 ”贪心策略”解决找零兑换问题，在美元或其他货币的硬币体系下表现尚好，但如果你的老板决定把自动售货机出口到Elbonia，事情就会有点复杂。 Elbonia是系列漫画Dilbert里杜撰的国家 这个古怪的国家除了上面3种面值之外，还有一种【ȼ21】的硬币！ 按照“贪心策略”，在Elbonia，ȼ63还是原来的6个硬币： ȼ63 =ȼ25*2+ȼ10*1+ȼ1*3 但实际上最优解是3个面值ȼ21的硬币！ ȼ63 =ȼ21*3 所以...贪心策略失效了。 常规解决 我们来找一种肯定能找到最优解的方法，放弃掉贪心策略的方案。 因为，贪心策略是否有效依赖于具体的硬币体系，如在Elbonia的货币体系中贪心策略就失效了。 首先是确定基本结束条件，兑换硬币这个问题最简单直接的情况就是，需要兑换的找零，其面值正好等于某种硬币，如找零25分，答案就是1个硬币！ 其次是减小问题的规模，我们要对每种硬币尝试1次，例如美元硬币体系： 找零减去1分(penny)后，求兑换硬币最少数量（递归调用自身） 找零减去5分(nikel)后，求兑换硬币最少数量 找零减去10分(dime)后，求兑换硬币最少数量 找零减去25分(quarter)后，求兑换硬币最少数量 上述4项中选择最小的一个 代码实现如下： #! /usr/local/bin/python3 # -*- coding:utf-8 -*- def recMC(coinValueList, change): minCoins = change if change in coinValueList: return 1 else: for i in [c for c in coinValueList if c 对63分的兑换硬币问题，需要进行67,716,925次递归调用。 这个实现方案我足足跑了40多秒，因为其中存在大量的子递归重复计算。 例如找零15分的，出现了3次！而它最终解决还要52次递归调用，下图中只是递归一角： 优化方案 对这个递归解法进行改进的关键就在于消除重复计算，我们可以用一个表将计算过的中间结果保存起来，在计算之前查表看看是否已经计算过，如果计算过就不运行函数，故也不会生成函数栈帧，极大减少了运行时长，这就是动态规划。 虽然这个做法会增大空间复杂度，但是会极大的减少时间复杂度，即让每个子问题只求解一次。 在递归调用之前，先查找表中是否已有部分找零的最优解如果有，直接返回最优解而不进行递归调用如果没有，才进行递归调用。 代码实现如下： #! /usr/local/bin/python3 # -*- coding:utf-8 -*- def recDC(coinValueList,change,knownResults): \"\"\" :param coinValueList: :param change: :param knownResults: 存表的结果（对应设计模式中，备忘录模式），因为我们要对63找零，所以这里设置为宽度为64的列表即可 \"\"\" minCoins = change # 递归结束基本条件 if change in coinValueList: # 记录最优解 knownResults[change] = 1 return 1 elif knownResults[change] > 0: # 查表成功，直接使用最优解 return knownResults[change] else: for i in [c for c in coinValueList if c 现在再次调用，则仅需要零点几秒就可以获得结果了。 Python内置库functools的@lrc_chace也实现了这种缓存功能，但该装饰器使用了字典存储缓存，所以被装饰函数的固定参数和关键字参数必须是可哈希的。 如下所示，不用自己写动态规划，直接调用该装饰器，只需要将货币体系传入由列表改为元组即可： #! /usr/local/bin/python3 # -*- coding:utf-8 -*- import functools @functools.lru_cache(maxsize=63) def recMC(coinValueList, change): minCoins = change if change in coinValueList: return 1 else: for i in [c for c in coinValueList if c 递归可视化 turtle module 这是一个Python内置的模块，随时可以进行调用，以LOGO语言的创意为基础模拟一只海龟在沙滩上爬行而留下的足迹。 以下是一些基本方法： 方法 描述 turtle.Turtle() 实例化对象 hideturtle() 使乌龟本身不可见，仅留下足迹 forward() 乌龟向前移动（头朝东） backward() 乌龟向后移动（头朝西） left() 乌龟向左边转向 right() 乌龟向右边转向 penup() 抬起画笔 pendown() 放下画笔 pensize() 笔的宽度 pencolor() 笔的颜色 turtle.done() 画完后不关闭 画一个三角形： import turtle import time def triangle(): t = turtle.Turtle() t.forward(200) t.right(60) t.backward(200) t.left(120) t.backward(200) if __name__ == '__main__': triangle() time.sleep(5) 自相似递归图形 分形Fractal，是1975年由Mandelbrot开创的新学科。 它的概念是：“一个粗糙或零碎的几何形状，可以分成数个部分，且每一部分都（至少近似地）是整体缩小后的形状”，即具有自相似的性质。 在大自然中的自相似递归图形有很多，比如雪花、树枝等等： 分形树 我们可以使用递归来画一颗二叉分形树，将树分解为3个部分：：树干、左边的小树、右边的小树。 分解后，正好符合递归的定义：对自身的调用。 代码如下： import turtle def tree(branch_len: int, t: turtle.Turtle) -> None: # 递归结束条件，树干不能太短 if branch_len > 5: # 画树干 t.forward(branch_len) # 右倾斜20度 t.right(20) # 递归，画右边小数，树干 - 15 tree(branch_len - 15, t) # 左倾斜40度，即回正后向左倾斜20度 t.left(40) # 递归，画左边小数，树干 - 15 tree(branch_len - 15, t) # 右倾斜20度，即回正 t.right(20) # 海龟退回原来的位置 t.backward(branch_len) if __name__ == '__main__': t = turtle.Turtle() # 转头，向正北 t.left(90) # 抬笔 t.penup() # 向上抬100个px t.backward(100) # 落笔 t.pendown() # 笔宽：2，颜色：绿色 t.pencolor(\"green\") t.pensize(2) # 开始画长度为75的树干 tree(75, t) # 使乌龟不可见 t.hideturtle() # 退出时不关闭 turtle.done() 效果演示： 谢尔宾斯三角形 谢尔宾斯三角形Sierpinski是一种分型构造。 创建一个三角形，然后每次都将这个三角形分成三份，无限制的挖下去最终这个三角形的面积会变为0，而周长变为无穷，是介于一维和二维之间的分数维（约1.585维）构造。 据自相似特性，谢尔宾斯基三角形是由3个尺寸减半的谢尔宾斯基三角形按照品字形拼叠而成。 由于我们无法真正做出谢尔宾斯基三角形（degree->∞），只能做degree有限的近似图形。 在degree有限的情况下，degree=n的三角形 ，是由3个degree=n-1的三角形按照品字形拼叠而成同时，这3个degree=n-1的三角形边长均为degree=n的三角形的一半（规模减小）。 当degree=0，则就是一个等边三角形，这是递归基本结束条件。 代码如下，感兴趣的可以仔细研究一下： import turtle def drawTriangle(points, color, myTurtle): myTurtle.fillcolor(color) myTurtle.up() myTurtle.goto(points[0][0], points[0][1]) myTurtle.down() myTurtle.begin_fill() myTurtle.goto(points[1][0], points[1][1]) myTurtle.goto(points[2][0], points[2][1]) myTurtle.goto(points[0][0], points[0][1]) myTurtle.end_fill() def getMid(p1, p2): return ((p1[0] + p2[0]) / 2, (p1[1] + p2[1]) / 2) def sierpinski(points, degree, myTurtle): colormap = ['blue', 'red', 'green', 'white', 'yellow', 'violet', 'orange'] drawTriangle(points, colormap[degree], myTurtle) if degree > 0: sierpinski([points[0], getMid(points[0], points[1]), getMid(points[0], points[2])], degree - 1, myTurtle) sierpinski([points[1], getMid(points[0], points[1]), getMid(points[1], points[2])], degree - 1, myTurtle) sierpinski([points[2], getMid(points[2], points[1]), getMid(points[0], points[2])], degree - 1, myTurtle) def main(): myTurtle = turtle.Turtle() myWin = turtle.Screen() myPoints = [[-100, -50], [0, 100], [100, -50]] sierpinski(myPoints, 3, myTurtle) myWin.exitonclick() if __name__ == '__main__': main() 效果演示： 绘制步骤： Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:46 "},"Python/Python数算基础/算法之搜索篇.html":{"url":"Python/Python数算基础/算法之搜索篇.html","title":"算法之搜索篇","keywords":"","body":"线性搜索 顺序查找也被称之为线性查找，因在Python中list的底层为顺序表存储，故我们可以使用index来循环遍历整个列表获得所需要查找的数据项。 它的时间复杂度为O(n)，如果刚好被搜索的数据项排列在最后一个，那么整个查找是非常耗费时间的： 如下所示，如果查找数据项50，将会查找11次： def seqLinerSearch(seq, findItem): idx = 0 count = 0 seqLenght = len(seq) while idx 有序的必要性 现在，让我们观察上面的代码是否有什么可以优化的地方。 我们的查找在数据项不存在的情况下总是会遍历完整个列表，导致这个问题的主要原因还是因为传入的列表是无序的。 如上述代码，我们查找数据项53，它总是一遍一遍的进行对比，直至对比完成整个列表发现都没有符合条件的数据项后才会返回，时间复杂度总是为O(n)，所以要针对这个情况进行简单的优化。 如果我们将列表排为有序的状态，当查找到71后，也就发现了没有必要往后查找，故至此直接返回即可。 优化策略： 列表要有序 如果正在遍历的数据项大于被查找的数据项，则代表此列表中没有该数据项 代码实现如下，虽然整体的时间复杂度还是O(n)，但是已经做了很大的优化了： def seqLinerSearch(seq, findItem): idx = 0 count = 0 seqLenght = len(seq) while idx 注意：排序本身就花费时间，复杂度为O(n log n) 二分搜索 通过上面的2个例子，可以得出一个结论： 对查找来说，保持数据项的有序是十分必要的 那么现在基于这个先决条件，介绍一种查找效率更高的算法，二分查找法。 二分查找的实现理念：每次只查找列表中间元素的值，判定这个中间元素与被查找元素的关系，通过关系将列表进行折半后，继续查找，时间复杂度是O(logn)，如下所示二分查找法与顺序查找的对比图： 实现二分查找，查找数据项50仅需要3次： #! /usr/local/bin/python3 # -*- coding:utf-8 -*- def binarySearch(seq, findItem): count = 0 l_idx = 0 r_idx = len(seq) - 1 while l_idx seq[m_idx]: l_idx = m_idx + 1 # 如果查找的元素小于当前列表中部索引的元素，则重新定义右侧索引 else: r_idx = m_idx - 1 else: return None, count if __name__ == '__main__': result, count = binarySearch([2, 8, 18, 22, 34, 37, 50, 71, 82, 91, 92], 50) print(result, count) # 50 3 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:46 "},"Python/Python数算基础/算法之排序篇.html":{"url":"Python/Python数算基础/算法之排序篇.html","title":"算法之排序篇","keywords":"","body":"排序简介 常见的十大排序算法如下所示，本章节会例举6种常见且易于掌握的排序算法： 算法名称 平均时间复杂度 最好情况 最坏情况 空间复杂度 排序方式 稳定性 冒泡排序 O(n²) O(n) O(n²) O(1) in-place 稳定 选择排序 O(n²) O(n²) O(n²) O(1) in-place 不稳定 插入排序 O(n²) O(n) O(n²) O(1) in-place 稳定 希尔排序 O(n log n) O(n log n) O(n log² n) O(1) in-plcae 不稳定 归并排序 O(n log n) O(n log n) O(n log n) O(n) out-place 稳定 快速排序 O(n log n) O(n log n) O(n²) O(log n) in-plcae 不稳定 堆排序 O(n log n) O(n log n) O(n log n) O(1) in-plcae 不稳定 计数排序 O(n + k) O(n + k) O(n + k) O(k) out-place 稳定 桶排序 O(n + k) O(n + k) O(n²) O(n + k) out-place 稳定 基数排序 O(n + k) O(n + k) O(n + k) O(n + k) out-place 稳定 关于排序算法的3大基础知识： 稳定性：示例，排序前红色3在蓝色3前面，如果排序完成后位置没有发生改变则该排序算法是稳定的： 稳定：1，2，3，3，5 不稳定：1，2，3，3，5 有序区和无序区：在排序算法中，会将一个序列分为2大区，如下所示： [1, 2, 3, | 28, 11, 43] ---------- ---------- 有序区 无序区 原地排序：原地排序是指在原序列中进行数据项排列，不用开辟额外内存空间 非原地排序则需要生成新的序列，来存储排列好的数据项，空间复杂度会增加 冒泡排序 冒泡排序（Bubble Sort）是一种简单的排序算法。 这种排序算法是基于比较的算法，每次比较2个相邻数据项并进行交换。 该算法不适合大型数据集，因为其平均和最坏情况复杂度为 Ο(n²)，其中n是项目数。 代码及注释如下： def bubbleSort(seq): # ❶ for i in range(len(seq) - 1): # ❷ tag = False # ❸ for j in range(len(seq) - (i + 1)): if seq[j] > seq[j + 1]: seq[j], seq[j + 1] = seq[j + 1], seq[j] tag = True if not tag: break if __name__ == \"__main__\": lst = [2, 1, 3, 4, 5, 6, 7, 8, 9] bubbleSort(lst) print(lst) ❶：我们认为最后1个数据项不用排序，故循环次数是 len(seq) - 1，每一次外层循环都会令有序区数据项 + 1 ❷：一个标志位，用于判定是否还需要继续进行排序 ❸：内层循环只会遍历无序区数据项，i 是外层循环次数， + 1代指seq最后1个数据项，即不用排序的数据项 如果不加该标志位，则会产生许多重复的且无用的排序，因此该标志位算是一种优化手段。 选择排序 选择排序（Selection Sort）会将序列分为2部分，有序区和无序区。 它的工作原理：首先在无序区中找到最小（大）数据项，存放到有序区的起始位置，然后，再从剩余无序区中继续寻找最小（大）数据项，然后放到有序区的末尾。 以此类推，直到所有数据项均排序完毕。 该算法不适合大型数据集，因为其平均和最坏情况复杂度为 Ο(n²)，其中n是项目数。 代码及注释如下： def selectionSort(seq): # ❶ for i in range(len(seq) - 1): # ❷ minIndex = i # ❸ for j in range(i + 1, len(seq)): # ❹ if seq[minIndex] > seq[j]: minIndex = j # ❺ if minIndex != i: seq[i], seq[minIndex] = seq[minIndex], seq[i] if __name__ == '__main__': lst = [4, 1, 0, 2, 3] selectionSort(lst) print(lst) ❶：我们认为最后1个数据项不用排序，故循环次数是 len(seq) - 1，每一次外层循环都会令有序区数据项 + 1 ❷：将当前被外层循环遍历的数据项当做最小值，并记录其索引位置 ❸：循环所有无序区数据项 ❹：判断当前被遍历的无序区数据项是否小于以设定的最小值数据项，如果是则更新 ❺：交换最小值数据项与外层循环被遍历数据项的位置 插入排序 插入排序（Inster Sort）类似于打扑克牌，先会构建出一个有序区，再遍历无序区数据项并将其插入到有序区中合适的位置。 该算法不适合大型数据集，因为其平均和最坏情况复杂度为 Ο(n²)，其中n是项目数。 代码及注释如下： def insertSort(seq): # ❶ for i in range(1, len(seq)): # ❷ currentItem = seq[i] # ❸ prevItemIndex = i - 1 # ❹ while prevItemIndex >= 0 and seq[prevItemIndex] > currentItem: # ❺ seq[prevItemIndex + 1] = seq[prevItemIndex] prevItemIndex -= 1 seq[prevItemIndex + 1] = currentItem if __name__ == \"__main__\": lst = [1, 4, 2, 3, 0] insertSort(lst) print(lst) ❶：外层循环从索引1处开始向后遍历，即我们认为有序区默认有1个数据项 ❷：拿到当前的数据项，即有序区最后一个数据项 ❸：拿到有序区前一个数据项的索引，这里就是插入位置，当无序区被遍历数据项小于有序区最后一个数据项，就插入到这里 ❹：条件1：如序列为[1, 2, 3 | 0, 9, 8, 10]，0如果想要插入1前面，索引就变成了-1，而-1位置是序列中最后位置，这样就会插入失败，故该条件确保不会出现负向索引 条件2：规定什么时候进行插入，当然是被遍历的无序区数据项小于有序区最后一个数据项时才进行插入 ❺：寻找插入位置 希尔排序 希尔排序（Shell Sort）是插入排序的一种，它是针对直接插入排序算法的改进。 希尔排序又称缩小增量排序，因 DL.Shell 于 1959 年提出而得名。 它通过比较相距一定间隔的数据项来进行，各趟比较所用的距离随着算法的进行而减小，直到只比较相邻数据项的最后一趟排序为止，是首次突破O(n²)的排序算法。 该算法对于中等规模的数据集非常有效，因为该算法的平均和最坏情况复杂度取决于间隙序列，最著名的是 Ο(n)，其中 n 是项目的数量。最坏情况下的空间复杂度是 O(n)。 首先，我们有一个长度为8的序列，我们需要对其 // 2，得到一个值是4，这个值叫做gap值。 现在，我们将整个序列分为4组，如下图所示，35和14为一组，中间的间隔是4，33和19是一组，中间的间隔也是4，依次类推： 然后我们对这4组中的元素进行插入排序，非常简单，下图是排序完成后的样子： 上次得到的gap值是4，我们再将它 // 2，得到新的gap值，为2。 老规矩，将整个序列分为2组，如下图所示： 然后，再将这2组中的元素进行插入排序，下图是排序完成之后的样子： 上次的gap值是2，我们再将它 // 2，得到结果是1，继续对这1组进行插入排序，如下图所示： 代码及注释如下： def shellSort(seq): # ❶ currentGap = len(seq) // 2 # ❷ while currentGap >= 1: # ❸ for startPosition in range(currentGap): gapInsertSort(seq, startPosition, currentGap) print(\"after increments of size %s, the sequence is %s\" % (currentGap, seq)) # ❹ currentGap //= 2 def gapInsertSort(seq, start, gap): # ❺ for i in range(start + gap, len(seq), gap): currentItem = seq[i] position = i while position >= gap and seq[position - gap] > currentItem: seq[position] = seq[position - gap] position = position - gap seq[position] = currentItem if __name__ == \"__main__\": lst = [35, 33, 42, 10, 14, 19, 27, 44] shellSort(lst) print(lst) ❶：获取gap值，后续会根据gap值进行分组 ❷：死循环，直至所有组都排序完毕 ❸：循环，开始进行插入排序 ❹：插入排序完毕后，重新进行分组，更新gap值 ❺：start + gap是当前需要插排的分组，len(seq)是整体序列长度， gap是跳过的步数，也就是不同的分组，至此开始每一轮的插入排序 归并排序 归并排序（Merge Sort）是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。 归并排序会不断的将序列 // 2，直至每个序列仅包含1个数据项，然后再将小序列排序并合并成大序列。 归并排序是一种基于分治技术的排序技术，最坏情况的时间复杂度为 Ο(n log n)，它是最受尊敬的算法之一。 首先，下面是一个未经历排序的长度为8的序列： 我们不断的将它拆分，直至每个序列中仅有1个数据项： 然后开始进行子序列合并，通过不断的对比每个子序列中的数据项，最终将它们合并成1个大的序列： 代码及注释如下： def mergeSort(seq): # ❶ if len(seq) > 1: mid = len(seq) // 2 leftSeq, rightSeq = seq[:mid], seq[mid:] mergeSort(leftSeq) mergeSort(rightSeq) # ❷ i = j = k = 0 while i ❶：不断的对序列进行拆分，直至每个序列中仅有1个数据项 ❷：开始进行排序、对比、合并，i 是左侧序列索引值，j是右侧序列索引值，k是整个大序列索引值 ❸：如果左序列被遍历数据项小于右序列被遍历数据项，则整体大序列中左序列数据项排列在前面 如：leftSeq = [0]， rightSeq = [1]， 则大的seq = [0 , 1] ❹：如果右序列被遍历数据项小于左序列被遍历数据项，则整体大序列中右序列数据项排列在前面 如：leftSeq = [1]， rightSeq = [0]， 则大的seq = [0 , 0] ❺：针对❹的情况，要将大seq的[0, 0]变为[0, 1]，因为❹的时候 i 没有 + 1，总之最后要保证：i = 1, j = 1, k = 2 ❻：针对❸的情况，因为❸的时候 j 没有 + 1，总之最后要保证：i = 1, j = 1, k = 2 快速排序 快速排序（Quick Sort）最大的特点就是快，使用分治法进行实现。 它的算法步骤是在一个序列中选定任意一个值，作为基准（pivot），然后使用2个指针，从序列的左侧与右侧一起进行数据项检测，每检测1步2个指针距离更进一步。 左侧指针用于将比基准值小的数据项排在左侧 右侧指针用于将比基准值大的数据项排在右侧 当2个指针重合时代表一趟排序完成，如此排列一轮整个序列就分为了2组，左侧比基准小（左侧各个序列数据项之间也大概率无序），右侧比基准大（右侧各个序列数据项之间也大概率无序）。 再次重复以上的步骤，对左侧或者右侧的列表重新定义基准值，再次进行挑选，直至最后划分为无数个长度为1的小序列时，排序完成。 该算法对于大型数据集非常有效，因为其平均复杂度和最坏情况复杂度分别为O(n log n) 和 O(n² )。 可能动图演示太快了，我们使用图解的形式： 第一趟的基准值是6（随机的）： 接下来继续第2倘，重新定义基准值为3（随机的），重复上面的步骤。 代码及注释如下： def quickSort(seq): def innerQuickSort(seq, left, right): if left left and seq[right] >= pivot: right -= 1 seq[left] = seq[right] # ❸ while left ❶：定义基准值，pivot ❷：右侧指针与左侧指针没有重合，且右侧指针数据项大于基准值则右侧指针左移一位 ❸：左侧指针与右侧指针没有重合，且左侧指针数据项小于基准值则左侧指针右移一位 ❹：重新定义基准值，本倘遍历完成 此时还可能会出现一个最坏情况： 由于pivot我们总是选择在了首位，如果出现传入一个已经有序（升序）的列表，就会发生最坏情况。 反之，如果pivot总是选择在末位，如果出现传入一个已经有序（降序）的列表，也会发生最坏的情况。 最坏情况下，时间复杂度将退化O(n²)，加上递归的开销可能比冒泡排序还要慢一点，解决方案是将pivot选择为一个随机位置，如中间。 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:46 "},"Python/Python数算基础/数构之树相关.html":{"url":"Python/Python数算基础/数构之树相关.html","title":"数构之树相关","keywords":"","body":"树的知识 什么是树 树是一种基本的非线性数据结构，在操作系统、图形学、数据库系统、计算机网络等领域被广泛使用。 跟自然界中的树一样，数据结构树也分为：根、枝、叶三个部分，一般数据结构的图示会把根放在上方，叶放在下方，就像一颗倒置的树，如下示例： 相关术语 节点(node) 节点是组成树的基本部分，每个节点具有不同的名称或“键值”属性。 除此之外，节点还可以保存额外数据项，数据项根据不同的应用而变化。 边(edge) 边是组成树的另一个基本部分，每条边恰好连接两个节点，表示节点之间具有关联。 除此之外，边还具有出入方向： 每个节点（除根节点）恰好有一条来自另一节点的入边。 每个节点可以有多条连到其它节点的出边。 根(root) 根是树中唯一一个没有入边的节点，即最顶端的节点。 路径(path) 路径是由边依次连接在一起的节点组成的有序列表，如：HTML->BODY->UL->LI就是一条路径。 子节点(children) 入边均来自于同一个节点的若干节点，称为这个节点的子节点。 父节点(parent) 一个节点是其所有出边所连接节点的父节点。 兄弟节点(sibling) 具有同一个父节点的节点之间称为兄弟节点. 子树(subtree) 子树是一个节点和其所有子孙节点，以及相关边的集合。 一个树中有多个子树，每个子树是独立的一颗树。 叶子节点(leaf) 没有子节点的节点称为叶节点。 层级(level) 根节点开始到达一个节点的路径，所包含的边的数量，称为这个节点的层级。 Root从0开始计数，也可以从1开始计数： 高度(height) 树中所有节点的最大层级称为树的高度。 如下图树的高度为2： 度(degree) 一个枝的度代表它有几条出边，而一颗树的度则取决于树中节点的最大度。 如，一颗树中最大的度为2，这可树可被称为二叉树，除此之外还有三叉、四叉树等结构。 如下图，这是一颗三叉树： 认识二叉树 普通二叉树 普通的二叉树没什么要求，树的最大度为2即可。 完全二叉树 在完全二叉树中，枝节点必须全部是满的，叶子节点可以不满。 但是新的节点添加时必须从左至右依次添加，不能先添加右边后添加左边。 平衡二叉树 树的左右子树高度差不超过1的树被称为平衡二叉树，空树也是平衡二叉树的一种。 满二叉树 满二叉树的意思就是无论是枝节点还是叶子节点，必须全部都是满的。 二叉树表示 列表表示法 在Python中，我们可以使用多维的列表来表示一颗不确定度的多叉树。 这样的做法有一个好处，每一个列表都是一颗子树，索引值1是左子树，索引值2是右子树。 同时，如果要增加某个节点的度，则向其添加一个空列表即可。 如上述这幅图的二叉树，则可以向下面这样进行表示： 第1个元素为根节点的值 第2个元素是左子树（所以也是一个列表） 第3个元素是右子树（所以也是一个列表） [root, [left], [right]] ----------------------- 0 1 2 如下所示： myTree = \\ [ \"a\", [\"b\", [\"d\", [], []], [\"e\", [], []] ], [\"c\", [\"f\"] ] ] 拿到第二层的叶子节点f： print(myTree[2][1]) 节点表示法 使用节点表示法，能够更加清晰的管理树，这比列表表示法通常更加省力。 如下图所示： 以下是代码实现上图中二叉树的表现： class BinaryTree: def __init__(self, root): self.key = root self.leftChild = None self.rightChild = None self.height = 0 def insertLeft(self, newNode): tree = BinaryTree(newNode) if not self.leftChild: self.leftChild = tree else: # 如果插入位置已有节点，则整体向下挪 # 新的子节点与旧的子节点链接，旧的父节点与新的子节点链接 tree.leftChild = self.leftChild self.leftChild = tree self.height += 1 def insertRight(self, newNode): tree = BinaryTree(newNode) if not self.rightChild: self.rightChild = tree else: tree.rightChild = self.rightChild self.rightChild = tree self.height += 1 def getRightChild(self): return self.rightChild def getLeftChild(self): return self.leftChild def setRootVal(self, obj): self.key = obj def getRootVal(self): return self.key if __name__ == '__main__': binaryTree = BinaryTree(\"a\") binaryTree.insertLeft(\"b\") binaryTree.insertRight(\"c\") binaryTree.leftChild.insertLeft(\"d\") binaryTree.leftChild.insertRight(\"e\") binaryTree.rightChild.insertLeft(\"f\") 二叉树遍历 将一颗二叉树依次排开，如下所示： 根节点在中间 左节点在左边 右节点在右边 那么就会有不同的4种遍历规则。 前序遍历（preorder） 中序遍历（inorder） 后序遍历（postorder） 层级遍历（levelorder） 我们可以在BinaryTree中新增几个实例方法，用来书写不同的遍历代码： class BinaryTree: ... def preOrder(self): pass def inOrder(self): pass def postOrder(self): pass def levelOrder(self): pass 前序遍历(pre order) 前序遍历规则如下： 首先访问根节点 前序访问左子树 前序访问右子树 一句话总结：中左右 遍历顺序： 代码实现： def preOrder(self): def inner(tree): if tree: print(tree.getRootVal()) inner(tree.getLeftChild()) inner(tree.getRightChild()) inner(self) 中序遍历(in order) 中序遍历规则如下： 中序访问左子树 然后访问根节点 中序访问右子树 一句话总结：左中右 遍历顺序： 代码实现： def inOrder(self): def inner(tree): if tree: inner(tree.getLeftChild()) print(tree.getRootVal()) inner(tree.getRightChild()) inner(self) 后序遍历(post order) 后序遍历规则如下： 后序访问左子树 后序访问右子树 最后访问根节点 一句话总结：左右中 遍历顺序： 代码实现： def postOrder(self): def inner(tree): if tree: inner(tree.getLeftChild()) inner(tree.getRightChild()) print(tree.getRootVal()) inner(self) 层级遍历(level order) 层级遍历没什么好说的，按层访问： 第0层、根 第1层、左、右 …第n层、左、右 遍历顺序： 代码实现，需要借助一个双端队列或者列表： def levelOrder(self): def inner(tree): treeLst = [] treeLst.append(tree) while len(treeLst) > 0: node = treeLst.pop(0) print(node.getRootVal()) if node.leftChild: treeLst.append(node.getLeftChild()) if node.rightChild: treeLst.append(node.getRightChild()) inner(self) 根据遍历画出树 如果给出你2个遍历结果，并且指明这棵树是二叉树，如何画出这棵树的结构？ 前序遍历顺序是 A B C D E F G 中序遍历顺序是 C B D A F E G 首先，前序遍历是中左右，中序遍历是左中右，按照下面的结构开始进行结构划分： 前序： [A] [B C D] [E F G] 中序： [C B D] [A] [F E G] 划分完成之后就可以出图了： 二叉堆 什么是二叉堆 二叉堆是二叉树的一种特殊结构，二叉堆必须是完全二叉树或者近似完全二叉树，可分为大根堆和小根堆。 小根堆（小顶堆）：任意一个节点都比其孩子节点小 大根堆（大顶堆）：任意一个节点都比其孩子节点大 图示如下： 二叉堆的表示 使用列表来表示二叉堆的时候，不需要利用多维列表，单纯的一维列表足以。 因为二叉堆必须是完全二叉树或者近似完全二叉树，所以整个树是平衡的，可以用列表来进行表示。 [1, 2, 3, 4, 5, 6, 7] 如果要查找任意节点的左子节点与右子节点，可以使用 2p 与 2p+1 来查找，如果想查找其父节点，可以使用 n // 2 的方式。 如上述列表表示了一个小根堆，我们要寻找3的左子节点与右子节点及父节点，流程如下： Node 3 Position: 3 # 不要按照索引计算，正确计算是索引值+1 Left Child Node Position: 3 * 2 = 6 Right Child Node Position: 3 * 2 + 1 = 7 Parent Node Position: 3 // 2 = 1 堆排序(Heap Sort) 由于堆只有大根堆和小根堆，为了满足其中的特性，我们必须将一些节点进行值的比对然后上浮或者下沉。 如下图所示，展示了一个大根堆的排序过程： 时间复杂度为O(n log n)，空间复杂度为O(1)。 实现思路： 构造初始堆，将给定无序序列构造成一个大根堆（排序时一般大根堆为升序，小根堆为降序） 将堆顶元素与末尾元素进行交换，使末尾元素最大。然后继续调整堆，再将堆顶元素与末尾元素交换，得到第二大元素； 重新调整结构，使其满足堆定义，然后继续交换堆顶元素与当前末尾元素； 如此反复进行交换、重建、交换，直到整个序列有序。 代码实现如下，这是一个大根堆： def build(seq, root, end): while True: # 左子节点的位置 child = 2 * root + 1 # 若左子节点超过了最后一个节点，则终止循环 if child > end: break # 若右子节点在最后一个节点之前，并且右子节点比左子节点大，则我们的孩子指针移到右子节点上 if (child + 1 seq[child]): child += 1 # 若最大的孩子节点大于根节点，则交换两者顺序，并且将根节点指针，移到这个孩子节点上 if seq[child] > seq[root]: seq[child], seq[root] = seq[root], seq[child] root = child else: break def heapSort(seq): n = len(seq) # 确认最深最后的那个根节点的位置 first_root = n // 2 - 1 # 由后向前遍历所有的根节点，建堆并进行调整 for root in range(first_root, -1, -1): build(seq, root, n - 1) # 调整完成后，将堆顶的根节点与堆内最后一个元素调换位置，此时为数组中最大的元素，然后重新调整堆，将最大的元素冒到堆顶。依次重复上述操作 for end in range(n - 1, 0, -1): seq[0], seq[end] = seq[end], seq[0] build(seq, 0, end - 1) if __name__ == '__main__': lst = [7, 3, 2, 4, 1, 5] heapSort(lst) print(lst) ADT BinHeap 如果要使用Python来进行二叉堆实现，同时应当提供以下方法。 这样做的好处是所有的入堆出堆操作时间复杂度均为O(n log n)，我们可以用二叉堆来模拟实现类似优先级队列的数据结构。 方法名 描述 BinaryHeap() 一个类，用于构建一个空的二叉堆对象 insert() 将新key加入到堆中 findMin() 返回堆中的最小项，最小项仍保留在堆中，堆本身不会改变 delMin() 返回堆中的最小项，同时从堆中删除，堆本身会改变 isEmpty() 返回堆是否为空 size() 返回堆中key的个数 buildHeap() 从一个key列表创建新堆 现在准备实现一个小根堆，用一个列表来保存堆数据，其中列首下标为0的项无用，但是节点的左右子节点查找是根据 2p 与 2p+1 来计算的，因此我们可以用这个0来做一个占位，使索引与p相同，而不是从0开始计数，所以选择保留它： class BinHeap: def __init__(self): self.heapList = [0] self.currentSize = 0 insert()方法的实现，一定要满足完全二叉树的性质，因此我们可以将新的key添加到列表末尾，同时使用堆排序来将该key上浮或者到合适的位置，实现有序的特性。 def percUp(self, i): # 判断父节点是否存在，由于现在新添加的元素 # 索引+1了，直接进行整除即可 while i // 2 > 0: # 如果新元素小于父节点，则上浮，交换位置 if self.heapList[i] delMin()方法的实现要移走整个堆中最小的key，由于我们实现的是小根堆，所以最小的元素都在堆顶。 如果直接简单粗暴的移走堆顶root，用那个元素来顶替好呢？ 实际上，我们可以采用将堆底，即列表最后一个元素放到堆顶再向下沉的策略来进行该方法的构建。 def percDown(self, i): # 如果没有左子节点，则代表整个列表就1个元素，不是一个堆 # 就不向下执行 while (i * 2) self.heapList[mc]: # 临时保留root节点的元素信息 temp = self.heapList[i] self.heapList[i] = self.heapList[mc] self.heapList[mc] = temp i = mc def minChild(self, i): # 先判断右子节点，是否大于当前的堆顶元素 if i * 2 + 1 > self.currentSize: return i * 2 # 不大于 else: # 判断左子节点，是否小于右子节点 if self.heapList[i * 2] 其他方法的实现： def buildHeap(self, li): # 一颗树的总长度+1整除2，会得到该树的root节点+枝节点 # 忽略掉了叶子节点 i = len(li) // 2 # 重新定义长度 self.currentSize = len(li) # 重新赋值 self.heapList = [0] + li # 从最后一个元素开始，进行排序 while i > 0: self.percDown(i) i -= 1 def findMin(self): return self.heapList[1] def isEmpty(self): return not self.heapList def size(self): return self.__len__() def __len__(self): return len(self.heapList) - 1 def __str__(self): return str(self.heapList[1:]) def __contains__(self, item): return item in self.heapList 完整代码： class BinHeap: def __init__(self): self.heapList = [0] self.currentSize = 0 def percUp(self, i): # 判断父节点是否存在，由于现在新添加的元素 # 索引+1了，直接进行整除即可 while i // 2 > 0: # 如果新元素小于父节点，则上浮，交换位置 if self.heapList[i] self.heapList[mc]: # 临时保留root节点的元素信息 temp = self.heapList[i] self.heapList[i] = self.heapList[mc] self.heapList[mc] = temp i = mc def minChild(self, i): # 先判断右子节点，是否大于当前的堆顶元素 if i * 2 + 1 > self.currentSize: return i * 2 # 不大于 else: # 判断左子节点，是否小于右子节点 if self.heapList[i * 2] 0: self.percDown(i) i -= 1 def findMin(self): return self.heapList[1] def isEmpty(self): return not self.heapList def size(self): return self.__len__() def __len__(self): return len(self.heapList) - 1 def __str__(self): return str(self.heapList[1:]) def __contains__(self, item): return item in self.heapList if __name__ == '__main__': bHeap = BinHeap() for i in range(5, 12): bHeap.insert(i) bHeap.insert(4) print(bHeap) bHeap.delMin() print(bHeap) print(bHeap.isEmpty()) print(bHeap.size()) 二叉查找树 在前面的章节中，我们已经介绍了基于线性数据结构+二分查找法的查找方式，以及使用HashMap做定点查找的方式。 现在，将介绍一种基于二叉树的查找方式，名为二叉查找树或二叉搜索树Binary Search Tree。 BinarySearchTree有一个性质，即比父节点小的key都出现在左子树，比父节点大的key都出现在右子树。 在插入时，也一样会经过上浮下沉的步骤，如果按照70,31,93,94,14,23,73的顺序插入： 首先插入的70成为树根 31比70小，放到左子节点 93比70大，放到右子节点 94比93大，放到右子节点 14比31小，放到左子节点 23比14大，放到右子节点 73比93小，放到左子节点 若插入顺序如果不同，则生成的BinarySearchTree也会不同。 Python实现BinarySearch树 如果要使用Python来进行二叉查找树的实现，同时应当提供以下方法： 方法名 描述 BinarySearchTree() 一个类，用于构建一个空的二叉查找树对象 put() 将key-val关联对加入至BinarySearchTree中，如果key已存在，则将val进行更新 get() 指定key，返回val，如val不存在，则返回None del 通过 del BinarySearchTree[key]的语句形式删除一组键值对 len() 返回BinarySearchTree中键值对的数量 in 支持成员运算符的应用 为了实现二叉查找树，我们可以用2个类，BinarySearchTree以及TreeNode。 一个用来构建树的结构，一个用来生成树的节点。 BinarySearchTree类的root成员引用根节点的TreeNode，以下是基本方法： class BinarySearchTree: def __init__(self): self.root = None self.size = 0 def length(self): return self.size def __len__(self): return self.size 下面是节点类的基本方法： class TreeNode: def __init__(self, key, val, left=None, right=None, parent=None): self.key = key self.payload = val self.leftChild = left self.rightChild = right self.parent = parent def getLeftChild(self): \"\"\"返回左子节点\"\"\" return self.leftChild def getRightChild(self): \"\"\"返回右子节点\"\"\" return self.rightChild def isLeftChild(self): \"\"\"判断当前节点是否是左节点\"\"\" return self.parent and \\ self.parent.leftChild == self def isRightChild(self): \"\"\"判断当前节点是否是右节点\"\"\" return self.parent and \\ self.parent.rightChild == self def isRoot(self): \"\"\"判断当前节点是否是根节点，根节点无父节点\"\"\" return not self.parent def isLeaf(self): \"\"\"判断当前节点是否是叶子节点\"\"\" return not (self.rightChild or self.leftChild) def hasAnyChildren(self): \"\"\"判断当前节点是否含有任意的子节点\"\"\" return self.rightChild or self.leftChild def hasBothChildren(self): \"\"\"判断当前节点是否含有左子节点和右子节点\"\"\" return self.rightChild and self.leftChild def replaceNodeDate(self, key, value, lc, rc): \"\"\"替换当前节点\"\"\" self.key = key self.payload = value self.leftChild = lc self.rightChild = rc if self.getLeftChild(): self.leftChild.parent = self if self.getRightChild(): self.rightChild.parent = self 当所有的基本方法都齐全后，开始构建put()方法。 put() put()方法是BinarySearchTree的一个实例方法，该方法将检测树是否已有根，若没有根那么put()方法将创建一个新的TreeNode实例并将其作为BinarySearchTree的根，如果根节点已就位，则put()方法将调用私有的递归辅助函数_put()方法，它将根据以下算法进行树的搜索： 从树的根开始，搜索二叉树，将新键与当前节点中的键进行比较。如果新键小于当前节点，则搜索左子树。如果新键大于当前节点，则搜索右子树。 当没有左（或右）孩子要搜索时，我们在树中找到应该建立新节点的位置。 以下是代码实现： def put(self, key, val): # 如果存在root节点，则下沉开始寻找插入位置 if self.root: self._put(key, val, self.root) else: self.root = TreeNode(key, val) self.size += 1 def _put(self, key, val, currentNode): # 如果新key小于root，则准备在左子树中寻找插入位置 if key 顺带将索引赋值也做上： def __setitem__(self, key, value): self.put(key,value) get() put()方法构建完毕后，让我们接着构建get()方法。 gut()方法是BinarySearchTree的一个实例方法，它与put()方法类似，同样也有一个私有的递归辅助函数_get()方法来进行递归检测，大体流程如下： 首先判断该树有没有根，若没有根则直接返回None 如果有根，则判断要查找的key是否等于root，如果相等直接返回，如果小于则往左子树递归查找，反之则往右子树递归查找，若都找不到则返回None 以下是代码实现： def get(self, key): if self.root: res = self._get(key, self.root) if res: return res.payload else: return None else: return None def _get(self, key, currentNode): # 查找到叶子节点都没找到，返回None if not currentNode: return None # 判断是否等于当前Node的key elif currentNode.key == key: return currentNode # 如果小于，递归遍历左子树 elif key 顺带着，由于实现了get()方法，我们也可以将BinarySearchTree的掌管成员运算符in的\\_contains__()一起实现，代码如下： def __contains__(self, key): if self._get(key, self.root): return True else: return False __iter__() 当get()方法构建完毕后，下一步要构建迭代器了，只需要实现__iter__()方法即可。 将BinarySearchTree中的__iter__()调用至TreeNode中的__iter__()方法即可： # BinarySearchTree def __iter__(self): return self.root.__iter__() # TreeNode def __iter__(self): \"\"\"采用中序遍历\"\"\" if self: if self.getLeftChild(): for ele in self.leftChild: yield ele yield self.key if self.getRightChild(): for ele in self.rightChild: yield ele delete() 现在简单的方法都构建完毕了，最难的就属delete()方法，它包含2层，1层是找节点、2层是删节点。 为了使程序更加解耦，我们用delete()作为2个方法的代理，负责调度_get()方法来找节点与remove()方法来删节点，当然remove()方法暂时还没有实现。 在delete()方法中，大体思路如下： 如果这个树的长度大于1，则说明有节点，调用_get()方法开始从root节点向后查找，找得到就将其设置为None，找不得则抛出异常 如果这个树的长度为1，则说明只有一个root节点，此时判定root节点是否是我们需要找的节点，找得到就将root节点设为None，找不得就删除 代码实现如下： def delete(self,key): if self.size > 1: nodeToRemove = self._get(key,self.root) if nodeToRemove: self.remove(nodeToRemove) self.size -= 1 else: raise KeyError(\"Error, key not in tree\") elif self.size == 1 and self.root.key == key: self.root = None self.size -= 1 else: raise KeyError(\"Error, key not in tree\") def __delitem__(self, key): self.delete(key) 如果找到了节点，就需要执行remove()方法对其进行删除，但是remove()方法还未实现，我们需要提前对其做一些规划。为了保持整颗二叉查找树的性质，删节点时要对以下3种情形做出分别不同的处理： 将要被删除的节点是一个叶子节点（没有任何子节点） 将要被删除的节点有1个子节点 将要被删除的节点有2个子节点 没有子节点的第1种情况最好办，直接删除即可： def remove(self, currentNode): # 第一种情况：如果被删除节点是叶子节点 if currentNode.isLeaf(): # 判断是左叶子还是右叶子，将其置为None if currentNode == currentNode.parent.leftChild: currentNode.parent.leftChild = None else: currentNode.parent.rightChild = None 第2种情况稍微复杂，被删节点有1个子节点，我们需要将这个唯一的子节点上移，替换掉被删节点的位置。 但是在替换操作的时候，又要区分几种情况，如下所示： 被删节点的子节点是左？还是右子节点？ 被删节点本身是其父节点的左？还是右子节点？ 被删节点本身就是根节点？ 解决策略如下： 如果当前被删节点是左子节点，则我们只需要更新左子节点的父引用以指向当前节点的父节点，然后更新父节点的左子节点引用以指向当前节点的左子节点 如果当前被删节点是右子节点，则我们只需要更新左子节点的父引用以指向当前节点的父节点，然后更新父节点的右子节点引用以指向当前节点的左子节点 如果当前被删节点没有父级，则它是根。在这种情况下，我们将通过在根上调用replaceNodeData() 方法来替换 key，payload，leftChild和rightChild的数据。 说了这么多，还不如看代码实际，先写个else，来处理第二种情况，因为我们无法保证该节点只有1个子节点，所以将这个情况放在第三种情形下面即可，（将要被删除的节点有2个子节点）： def remove(self, currentNode): # 第一种情况：如果被删除节点是叶子节点 if currentNode.isLeaf(): # 判断是左叶子还是右叶子，将其置为None if currentNode == currentNode.parent.leftChild: currentNode.parent.leftChild = None else: currentNode.parent.rightChild = None # 第三种情况：如果被删除节点有2个子节点 elif currentNode.hasBothChildren(): pass # 第二种情况：如果被删除的节点有1个子节点 else: # 如果被删除的节点的1个子节点是左子节点 if currentNode.getLeftChild(): # 如果被删除的节点本身是左节点 if currentNode.isLeftChild(): # 爸爸死了，让左儿子的爷爷做左儿子的监护人 currentNode.leftChild.parent = currentNode.parent # 爷爷的左儿子死了，爷爷让左孙子顶替左儿子的位置 currentNode.parent.leftChild = currentNode.leftChild # 如果被删除的节点本身是右节点 elif currentNode.isRightChild(): # 爸爸死了，让左儿子的爷爷做左儿子的监护人 currentNode.leftChild.parent = currentNode.parent # 爷爷的右儿子死了，爷爷让左孙子顶替右儿子的位置 currentNode.parent.rightChild = currentNode.leftChild # 如果被删除的节点本身是根节点 else: # 爸爸死了儿子顶上 currentNode.replaceNodeData(currentNode.leftChild.key, currentNode.leftChild.payload, currentNode.leftChild.leftChild, currentNode.leftChild.rightChild) # 如果被删除的节点的1个子节点是右子节点 else: # 如果被删除的节点本身是左节点 if currentNode.isLeftChild(): # 爸爸死了，让右儿子的爷爷做右儿子的监护人 currentNode.rightChild.parent = currentNode.parent # 爷爷的左儿子死了，爷爷让右孙子顶替左儿子的位置 currentNode.parent.leftChild = currentNode.rightChild # 如果被删除的节点本身是右节点 elif currentNode.isRightChild(): # 爸爸死了，让右儿子的爷爷做右儿子的监护人 currentNode.rightChild.parent = currentNode.parent # 爷爷的右儿子死了，爷爷让右孙子顶替右儿子的位置 currentNode.parent.rightChild = currentNode.rightChild # 如果被删除的节点本身是根节点 else: # 爸爸死了儿子顶上 currentNode.replaceNodeData(currentNode.rightChild.key, currentNode.rightChild.payload, currentNode.rightChild.leftChild, currentNode.rightChild.rightChild) 第3种情形最复杂，即被删节点有2个子节点。 这时无法简单地将某个子节点上移替换被删节点但可以找到另一个合适的节点来替换被删节点，这个合适节点就是被删节点的下一个key值节点，即被删节点右子树中最小的那个，称为后继。 可以肯定这个后继节点最多只有1个子节点（本身是叶节点，或仅有右子树）将这个后继节点摘出来，替换掉被删节点。 继续补全remove()中第二个条件的代码，我们可以发现下面有一个寻找后继的函数findSuccessor()与进行切分的函数spliceOut()。 # 第三种情况：如果被删除节点有2个子节点 elif currentNode.hasBothChildren(): succ = currentNode.findSuccessor() succ.spliceOut() # 使用后继节点替换掉当前节点信息 currentNode.key = succ.key currentNode.payload = succ.payload 这三个方法要书写到TreeNode类中： def findSuccessor(self): \"\"\" 寻找后继 self:将要被删除的节点 \"\"\" succ = None if self.getRightChild(): succ = self.rightChild.findMin() else: if self.parent: if self.isLeftChild(): succ = self.parent else: self.parent.rightChild = None succ = self.parent.findSuccessor() self.parent.rightChild = self return succ def spliceOut(self): if self.isLeaf(): if self.isLeftChild(): self.parent.leftChild = None else: self.parent.rightChild = None elif self.hasAnyChildren(): if self.getLeftChild(): if self.isLeftChild(): self.parent.leftChild = self.leftChild else: self.parent.rightChild = self.leftChild self.leftChild.parent = self.parent else: if self.isLeftChild(): self.parent.leftChild = self.rightChild else: self.parent.rightChild = self.rightChild self.rightChild.parent = self.parent def findMin(self): \"\"\"寻找最小值，self是当前将要被删除节点的右子节点\"\"\" current = self # 判断当前节点是否有左子节点，有就一直往下找 while current.getLeftChild(): current = current.leftChild # 直到找到将要被删除节点的右子节点下的最左侧节点 return current 完整代码 完整及测试代码如下： #! /usr/local/bin/python3 # -*- coding:utf-8 -*- class BinarySearchTree: def __init__(self): self.root = None self.size = 0 def length(self): return self.size def __len__(self): return self.size def __iter__(self): return self.root.__iter__() def put(self, key, val): if self.root: self._put(key, val, self.root) else: self.root = TreeNode(key, val) self.size += 1 def _put(self, key, val, currentNode): # 如果新key小于root，则准备在左子树中寻找插入位置 if key 1: nodeToRemove = self._get(key, self.root) if nodeToRemove: self.remove(nodeToRemove) self.size -= 1 else: raise KeyError(\"Error, key not in tree\") elif self.size == 1 and self.root.key == key: self.root = None self.size -= 1 else: raise KeyError(\"Error, key not in tree\") def __delitem__(self, key): self.delete(key) def remove(self, currentNode): # 第一种情况：如果被删除节点是叶子节点 if currentNode.isLeaf(): # 判断是左叶子还是右叶子，将其置为None if currentNode == currentNode.parent.leftChild: currentNode.parent.leftChild = None else: currentNode.parent.rightChild = None # 第三种情况：如果被删除节点有2个子节点 elif currentNode.hasBothChildren(): succ = currentNode.findSuccessor() succ.spliceOut() # 使用后继节点替换掉当前节点信息 currentNode.key = succ.key currentNode.payload = succ.payload # 第二种情况：如果被删除的节点有1个子节点 else: # 如果被删除的节点的1个子节点是左子节点 if currentNode.getLeftChild(): # 如果被删除的节点本身是左节点 if currentNode.isLeftChild(): # 爸爸死了，让左儿子的爷爷做左儿子的监护人 currentNode.leftChild.parent = currentNode.parent # 爷爷的左儿子死了，爷爷让左孙子顶替左儿子的位置 currentNode.parent.leftChild = currentNode.leftChild # 如果被删除的节点本身是右节点 elif currentNode.isRightChild(): # 爸爸死了，让左儿子的爷爷做左儿子的监护人 currentNode.leftChild.parent = currentNode.parent # 爷爷的右儿子死了，爷爷让左孙子顶替右儿子的位置 currentNode.parent.rightChild = currentNode.leftChild # 如果被删除的节点本身是根节点 else: # 爸爸死了儿子顶上 currentNode.replaceNodeData(currentNode.leftChild.key, currentNode.leftChild.payload, currentNode.leftChild.leftChild, currentNode.leftChild.rightChild) # 如果被删除的节点的1个子节点是右子节点 else: # 如果被删除的节点本身是左节点 if currentNode.isLeftChild(): # 爸爸死了，让右儿子的爷爷做右儿子的监护人 currentNode.rightChild.parent = currentNode.parent # 爷爷的左儿子死了，爷爷让右孙子顶替左儿子的位置 currentNode.parent.leftChild = currentNode.rightChild # 如果被删除的节点本身是右节点 elif currentNode.isRightChild(): # 爸爸死了，让右儿子的爷爷做右儿子的监护人 currentNode.rightChild.parent = currentNode.parent # 爷爷的右儿子死了，爷爷让右孙子顶替右儿子的位置 currentNode.parent.rightChild = currentNode.rightChild # 如果被删除的节点本身是根节点 else: # 爸爸死了儿子顶上 currentNode.replaceNodeData(currentNode.rightChild.key, currentNode.rightChild.payload, currentNode.rightChild.leftChild, currentNode.rightChild.rightChild) class TreeNode: def __init__(self, key, val, left=None, right=None, parent=None): self.key = key self.payload = val self.leftChild = left self.rightChild = right self.parent = parent def getLeftChild(self): \"\"\"返回左子节点\"\"\" return self.leftChild def getRightChild(self): \"\"\"返回右子节点\"\"\" return self.rightChild def isLeftChild(self): \"\"\"判断当前节点是否是左节点\"\"\" return self.parent and \\ self.parent.leftChild == self def isRightChild(self): \"\"\"判断当前节点是否是右节点\"\"\" return self.parent and \\ self.parent.rightChild == self def isRoot(self): \"\"\"判断当前节点是否是根节点，根节点无父节点\"\"\" return not self.parent def isLeaf(self): \"\"\"判断当前节点是否是叶子节点\"\"\" return not (self.rightChild or self.leftChild) def hasAnyChildren(self): \"\"\"判断当前节点是否含有任意的子节点\"\"\" return self.rightChild or self.leftChild def hasBothChildren(self): \"\"\"判断当前节点是否含有左子节点和右子节点\"\"\" return self.rightChild and self.leftChild def replaceNodeDate(self, key, value, lc, rc): \"\"\"替换当前节点\"\"\" self.key = key self.payload = value self.leftChild = lc self.rightChild = rc if self.getLeftChild(): self.leftChild.parent = self if self.getRightChild(): self.rightChild.parent = self def __iter__(self): \"\"\"采用中序遍历\"\"\" if self: if self.getLeftChild(): for ele in self.leftChild: yield ele yield self.key if self.getRightChild(): for ele in self.rightChild: yield ele def findSuccessor(self): \"\"\" 寻找后继 self:将要被删除的节点 \"\"\" succ = None if self.getRightChild(): succ = self.rightChild.findMin() else: if self.parent: if self.isLeftChild(): succ = self.parent else: self.parent.rightChild = None succ = self.parent.findSuccessor() self.parent.rightChild = self return succ def spliceOut(self): if self.isLeaf(): if self.isLeftChild(): self.parent.leftChild = None else: self.parent.rightChild = None elif self.hasAnyChildren(): if self.getLeftChild(): if self.isLeftChild(): self.parent.leftChild = self.leftChild else: self.parent.rightChild = self.leftChild self.leftChild.parent = self.parent else: if self.isLeftChild(): self.parent.leftChild = self.rightChild else: self.parent.rightChild = self.rightChild self.rightChild.parent = self.parent def findMin(self): \"\"\"寻找最小值，self是当前将要被删除节点的右子节点\"\"\" current = self # 判断当前节点是否有左子节点，有就一直往下找 while current.getLeftChild(): current = current.leftChild # 直到找到将要被删除节点的右子节点下的最左侧节点 return current if __name__ == '__main__': mytree = BinarySearchTree() mytree[3] = \"red\" mytree[4] = \"blue\" mytree[6] = \"yellow\" mytree[2] = \"at\" del mytree[2] for i in mytree: print(i) 性能分析 上述的二叉搜索树，性能影响最大的是其高度，而其高度又受数据项key插入顺序的影响。 如果key的列表是随机分布的话，那么大于和小于根节点key的键值大致相等。 这样的树就是平衡树，put()方法最差性能为O(log2n)。 如果key的插入的顺序十分极端，如下图所示，那么put()方法的性能就变为了O(n)，其他方法也类似： 如何改进二叉搜索树，让其不受到key插入顺序的影响呢？ 这就涉及到下面要介绍的平衡二叉查找树的知识了。 平衡二叉查找树 AVL树即为平衡二叉树，它能够保证性能不受到key插入顺序的影响。 AVL是发明者的名字缩写：G.M. Adelson-Velskii and E.M. Landis AVL树的实现与基础的BinarySearcTree的实现基本相同，唯一不同之处在于二叉树的生成与维护过程。 平衡因子 AVL树的实现中，需要对每个节点跟踪“平衡因子balancefactor”参数，平衡因子是根据节点的左右子树的高度来定义的，确切地说，是左右子树高度差。 balanceFactor = height(leftSubTree) − height(rightSubTree) 如果平衡因子大于0，称为“左重left-heavy”，小于零称为“右重right-heavy”平衡因子等于0，则称作平衡。 如果一个二叉查找树中每个节点的平衡因子都在-1，0，1之间，则把这个二叉搜索树称为平衡树。 在平衡树操作过程中，有节点的平衡因子超出此范围，则需要一个重新平衡的过程。 也就是说，左子树和右子树的高度差不能超过1，在AVL树实现中只要确保该点即可。 树的自旋 我们只需要在上面的BinarySearchTree中做改进便可完成实现，首先，如果向AVL树插入一个新key，如何才能保持AVL树的平衡性质。 作为BinarySearchTree，新key必定以叶节点形式插入到AVL树中，叶节点的平衡因子是0，其本身无需重新平衡。 但这样做会影响其父节点的平衡因子： 作为左子节点插入，则父节点平衡因子会增加1 作为右子节点插入，则父节点平衡因子会减少1 这种影响可能随着其父节点到根节点的路径一直传递上去，直到传递到根节点为止。 或者某个父节点平衡因子被调整到0，不再影响上层节点的平衡因子为止。 无论从-1或者1调整到0，都不会改变子树高度，如下图所示，左侧的父节点本身平衡因子是1，但是因为加入了新的节点，父节点的平衡因子变为了0，此时不会再往上传递。 AVL树中如何将不平衡因子转为平衡？最主要的手段就是通过旋转，左旋、右旋、先左旋后右旋、先右旋后左旋4种策略。 根据当前树是左重，还是右重来进行不同方向的旋转，同时还需要更新相关父节点的引用，更新旋转后被影响节点的平衡因子。 左旋(LL) 示例1，新插入了C在B的右侧： 叶子节点C的平衡因子为0 从B的角度看这课树，平衡因子是-1，符合AVL树的性质 从A的角度看这课树，平衡因子是-2，已经不符合AVL树的性质，需要进行左旋调整 右旋(RR) 示例2，新插入了A在B的左侧： 叶子节点A的平衡因子为0 从B的角度看这棵树，平衡因子是1，符合AVL树的性质 从A的角度看这棵树，平衡因子是2，已经不符合AVL树的性质，需要进行右旋调整 两次旋转是已经解释过的旋转形式的稍微复杂的版本。为了更好地理解它们，我们应注意旋转时执行的每个动作。让我们首先检查如何执行左右旋转。左右旋转是左旋转与右旋转的组合。 先左后右旋(LR) 一个节点已插入到左子树的右子树中。这使C成为不平衡节点。这种情况下使AVL树执行左右旋转： 我们首先在C的左子树上执行左旋转。这使A成为B的左子树： 节点C仍然不平衡： 现在，我们将树右旋转，使B成为该子树的新根节点。C现在成为其自己的左子树的右子树。 目前，树已平衡： 先右旋后左旋(RL) 一个节点已插入到右子树的左子树中。这使C成为不平衡节点。这种情况下使AVL树执行右左旋转： 首先，我们沿C节点执行右旋转，使C成为其自己的左子树B的右子树。现在，B成为A的右子树。 节点A仍然由于其右子树的右子树而处于不平衡状态，并且需要向左旋转。 通过使B成为子树的新根节点，可以执行向左旋转。A成为其右子树B的左子树。 目前，树已平衡： 代码实现 只需要在BinarySearchTree的代码中做如下修改即可，如下添加了左旋代码，右旋和双向旋转没有添加，感兴趣的朋友可以自行实现： # __init__中新增节点的平衡因子属性： rotRoot.balanceFactor = rotRoot.balanceFactor + 1 - min(0,newRoot.balanceFactor) def _put(self, key, val, currentNode): # 如果新key小于root，则准备在左子树中寻找插入位置 if key 1 or node.balanceFactor 0: self.rotateRight(node.rightChild) self.rotateLeft(node) else: self.rotateLeft(node) elif node.balanceFactor > 0: if node.leftChild.balanceFactor Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:46 "},"Python/Python设计模式/summary.html":{"url":"Python/Python设计模式/summary.html","title":"Python设计模式","keywords":"","body":" 设计模式 普通工厂模式 抽象工厂模式 建造者模式 单例模式 原型模式 适配器模式 桥接模式 组合模式 外观模式 代理模式 装饰器模式 享元模式 责任链模式 解释器模式 迭代器模式 观察者模式 中介者模式 访问者模式 备忘录模式 命令模式 状态模式 策略模式 模板模式 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:46 "},"Python/Python设计模式/设计模式.html":{"url":"Python/Python设计模式/设计模式.html","title":"设计模式","keywords":"","body":"设计模式 设计模式与语言无关，是一种通用的解决思路。 是早期的先辈们在实践中总结出的精华，是考虑了封装性、复用性、效率性、可修改性、可一致性等各种因素的高度总结思想。 一个良好的设计模式对整个系统的影响极其重要，能大幅度提升可读性，利于团队项目的继承和扩展。 反之，如果设计的不好，不光是维护麻烦，项目交接等工作也变的难以展开。 GOF 1994 年，由 Erich Gamma、Richard Helm、Ralph Johnson 和 John Vlissides 四人合著出版了一本名为 Design Patterns - Elements of Reusable Object-Oriented Software（中文译名：设计模式 - 可复用的面向对象软件元素）的书，该书首次提到了软件开发中设计模式的概念。 四位作者合称 GOF（四人帮，全拼 Gang of Four）。 他们所提出的设计模式主要是基于以下的面向对象设计原则。 对接口编程而不是对实现编程 优先使用对象组合而不是继承 六大原则 开闭原则(Open Close Principle) 开闭原则的意思是：对扩展开放，对修改关闭。 在程序需要进行拓展的时候，不能去修改原有的代码，必须实现一个热插拔的效果。 简而言之，它是为了使程序的扩展性更好，更易于维护和升级而提出的一种原则。 想要达到这样的效果，我们需要使用接口和抽象基类对实现类进行约束。 一句话表示：不要修改源代码进行扩展，而是在设计之初就做好扩展的打算 里氏代换原则(Liskov Substitution Principle) 里氏代换原则是面向对象设计的基本原则之一。 里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。 LSP 是继承复用的基石，只有当派生类可以替换掉基类，且软件单位的功能不受到影响时，基类才算真正被复用，而派生类也能够在基类的基础上增加新的行为。 里氏代换原则是对开闭原则的补充。实现开闭原则的关键步骤就是抽象化，而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。 一句话表示：一个功能被父类能调用，则子类也必定能被调用，如动物类能够调用吃东西这个功能，则其子类狼、狗、猫等都能够调用吃东西这个功能 依赖倒转原则(Dependence Inversion Principle) 这个原则是开闭原则的基础，具体内容：针对接口编程，依赖于抽象而不依赖于具体。 一句话表示：多使用接口、抽象基类等规范子类行为，使整个项目逻辑仅看接口便能知道它是如何运作的。 接口隔离原则(Interface Segregation Principle) 这个原则的意思是：使用多个隔离的接口，比使用单个接口要好。 它还有另外一个意思是：降低类之间的耦合度。 由此可见，其实设计模式就是从大型软件架构出发、便于升级和维护的软件设计思想，它强调降低依赖，降低耦合。 一句话表示：将各个不同功能之间的接口耦合度降低，尽可能防止链式崩塌，即一个接口出了问题其他接口跟着完蛋 迪米特法则(Demeter Principle) 又称最少知道原则，它是指：一个实体应当尽量少地与其他实体之间发生相互作用，使得系统功能模块相对独立。 一句话表示：一个对象尽量只负责自己的一些行为，而不要涉及其他对象的行为 合成复用原则(Composite Reuse Principle) 合成复用原则是指：尽量使用合成/聚合/组合的方式书写代码，而不是使用继承。 一句话表示：继承是增加耦合性、减少代码量的一种方式，不要随意滥用。 相关分类 常说的设计模式有23种，可分为3大类，其类别分别是： 创建型模式5种 结构型模式7种 行为性模式11种 来源于Design Patterns - Elements of Reusable Object-Oriented Software一书。 而另外有8种设计模式，被分为J2EE模式，更加注重表示层，由Sun Java Center进行鉴定，这里不再进行演示。 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:46 "},"Python/Python设计模式/普通工厂模式.html":{"url":"Python/Python设计模式/普通工厂模式.html","title":"普通工厂模式","keywords":"","body":"普通工厂模式 工厂模式（Factory Pattern）是非常常用的一种模式，主要分为2大部分： 简单工厂模式 工厂方法模式 两者同属普通工厂模式，只是在理念上有一些细微的差异。 该模式属于创建型模式。 简单工厂模式 基本介绍 用户只需关注自身需要一个什么样的产品，而不用将注意力放在如何构建这个产品上。 只要用户构思好了，直接从工厂类的一个指定接口中去拿产品即可。、 特点：对外隐藏，只暴露一个接口，但这个接口可以创建出非常多的用户所需要的产品 案例图示 假如一个用户要买手机，他只需要考虑手机的品牌，型号，颜色等信息，而并不需要关心去那里买的问题，因为在手机城里各式各样的手机都应有尽有。 优缺点 优点： 隐藏对象创建的细节 客户端不需要修改代码 缺点： 违反单一职责原则，将创建逻辑集中到了一个工厂类里 当添加新的产品时，需要修改工厂类的代码，违反了开闭原则 代码实现 用Python实现简单工厂模式： # 定义手机厂商 class BasePhone: def __init__(self, model, color) -> None: self.model = model self.color = color def getInfo(self): return \"A %s mobile phone, the brand is %s, the model is %s\" % (self.color, self.brand, self.model) class SamSung(BasePhone): def __init__(self, model, color) -> None: self.brand = __class__.__name__ super(__class__, self).__init__(model, color) class Apple(BasePhone): def __init__(self, model, color) -> None: self.brand = __class__.__name__ super(__class__, self).__init__(model, color) class HuaWei(BasePhone): def __init__(self, model, color) -> None: self.brand = __class__.__name__ super(__class__, self).__init__(model, color) # 定义工厂 class MobleCity: def shopPhone(self, brand, model, color): brandDict = { \"SamSung\": SamSung, \"Apple\": Apple, \"HuaWei\": HuaWei } cls = brandDict.get(brand) if cls: instance = cls(model, color) return instance raise TypeError(\"no brand : %s\" % brand) if __name__ == \"__main__\": store = MobleCity() iphone_x = store.shopPhone(brand=\"Apple\", model=\"X\", color=\"black\") sumsung_note7 = store.shopPhone( brand=\"SamSung\", model=\"Note 7\", color=\"blue\") huawei_p10 = store.shopPhone(brand=\"HuaWei\", model=\"P10\", color=\"white\") print(iphone_x.getInfo()) print(sumsung_note7.getInfo()) print(huawei_p10.getInfo()) # A black mobile phone, the brand is Apple, the model is X # A blue mobile phone, the brand is SamSung, the model is Note 7 # A white mobile phone, the brand is HuaWei, the model is P10 工厂方法模式 基本介绍 简单工厂模式是将所有产品都放在1个工厂中，而工厂方法模式是每个不同种类的产品都放在一个单独的工厂中。 相较于简单工厂模式来说，设计更加简单一些。 特点：对外隐藏，每个工厂指定暴露一个接口，用于让用户取出该工厂的产品 案例图示 假如一个用户要买手机，他只需要考虑手机的品牌，型号，颜色等信息，并不需要关心手机是怎么造出来的，充分对外隐藏内部实现细节。 只要用户构思好了，就直接到每个手机品牌专卖店去买即可： 乍一看和简单工厂很相似，但是这个是每个手机品牌都有一个自己的专卖店，也就是说代码耦合度降低了。 优缺点 优点： 每个具体产品都对应一个具体的工厂类，当新增产品时不需要修改工厂类代码 隐藏了对象创建的细节 缺点： 每增加一个具体产品类，就必须增加一个相应的具体工厂类 代码实现 用Python实现工厂方法模式： # 定义手机厂商 class BasePhone: def __init__(self, model, color) -> None: self.model = model self.color = color def getInfo(self): return \"A %s mobile phone, the brand is %s, the model is %s\" % (self.color, self.brand, self.model) class SamSung(BasePhone): def __init__(self, model, color) -> None: self.brand = __class__.__name__ super(__class__, self).__init__(model, color) class Apple(BasePhone): def __init__(self, model, color) -> None: self.brand = __class__.__name__ super(__class__, self).__init__(model, color) class HuaWei(BasePhone): def __init__(self, model, color) -> None: self.brand = __class__.__name__ super(__class__, self).__init__(model, color) # 定义工厂 class SamSungStore: def shopPhone(self, model, color): return SamSung(model, color) class AppleStore: def shopPhone(self, model, color): return Apple(model, color) class HuaWeiStore: def shopPhone(self, model, color): return HuaWei(model, color) if __name__ == \"__main__\": samsungStore = SamSungStore() appleStore = AppleStore() huaweiStore = HuaWeiStore() iphone_x = appleStore.shopPhone(model=\"X\", color=\"black\") sumsung_note7 = samsungStore.shopPhone(model=\"Note 7\", color=\"blue\") huawei_p10 = huaweiStore.shopPhone(model=\"P10\", color=\"white\") print(iphone_x.getInfo()) print(sumsung_note7.getInfo()) print(huawei_p10.getInfo()) # A black mobile phone, the brand is Apple, the model is X # A blue mobile phone, the brand is SamSung, the model is Note 7 # A white mobile phone, the brand is HuaWei, the model is P10 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:46 "},"Python/Python设计模式/抽象工厂模式.html":{"url":"Python/Python设计模式/抽象工厂模式.html","title":"抽象工厂模式","keywords":"","body":"基本介绍 抽象工厂模式（Abstract Factory Pattern）在其他普通工厂模式的2个分支基础上，能够控制产品的类型。 该设计模式主要围绕一个超级工厂创建其他工厂。 该超级工厂又称为其他工厂的工厂。 特定：对外隐藏，可搭配普通工厂模式或者工厂方法模式来指定接口，但在此基础上管控了生成产品的零部件来源 该模式属于创建型模式。 案例图示 在普通工厂模式中，造一辆车时如果不对其零部件来源加以控制，可能发现装上了一个不属于该车范畴的配件。 但是在抽象工厂模式下，购车造车时专卖店必须负责车辆配件的来源，如发生假冒伪劣产品必须承担责任，如下图所示： 优缺点 优点： 将客户端与类的具体实现相分离 每个工厂创建了一个完整的产品系列，使得易于交换产品系列 有利于产品的一致性 缺点： 难以支持新种类的抽象产品，扩展困难 代码实现 用Python实现抽象工厂模式： # 零部件厂商 # 生产奔驰轮胎的厂商 class BenzTiresManufacturer: def getInfo(self): return \"Benz make\" # 生产奔驰底盘的厂商 class BenzChassisManufacturer: def getInfo(self): return \"Benz make\" # 生产奔驰其他零部件的厂商 class BenzOtherManufacturer: def getInfo(self): return \"Benz make\" # 品牌厂商 class Benz: def __init__(self, color): self.brandMsg = self.__class__.__name__ self.colorMsg = color self.tiresMsg = None self.chassisMsg = None self.otherMsg = None def build_car(self, tiresManufacturer, chassisManufacturer, otherManufacturer): # 由厂家内部根据指定零件厂商，开始制造零件 self.makeTires(tiresManufacturer) self.makeChassis(chassisManufacturer) self.makeOther(otherManufacturer) def getCar(self): return self def makeTires(self, tiresManufacturer): tires = tiresManufacturer() self.tiresMsg = tires.getInfo() def makeChassis(self, chassisManufacturer): chassis = chassisManufacturer() self.chassisMsg = chassis.getInfo() def makeOther(self, otherManufacturer): other = otherManufacturer() self.otherMsg = other.getInfo() def getInfo(self): return \"brand:%s\\ncolor:%s\\ntires:%s\\nchassis:%s\\nother:%s\\n\" % (self.brandMsg, self.colorMsg, self.tiresMsg, self.chassisMsg, self.otherMsg) # 品牌厂商专卖店 class BenzStore: def buyCar(self, color): # step03：告诉奔驰厂家该车的颜色 self.brand = Benz(color=color) # step04：通知厂家开始造车，专卖店必须要对零部件负责，故此在这里指定 # 轮胎、底盘、其他零件均为奔驰制造 self.brand.build_car( tiresManufacturer=BenzTiresManufacturer, chassisManufacturer=BenzChassisManufacturer, otherManufacturer=BenzChassisManufacturer ) # step05：获取造出来的汽车并返回给用户 return self.brand.getCar() if __name__ == \"__main__\": # step01：实例化出奔驰专卖店 benzStore = BenzStore() # step02：去专卖店买车 benzCar = benzStore.buyCar(\"black\") print(benzCar.getInfo()) # brand:Benz # color:black # tires:Benz make # chassis:Benz make # other:Benz make Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:46 "},"Python/Python设计模式/建造者模式.html":{"url":"Python/Python设计模式/建造者模式.html","title":"建造者模式","keywords":"","body":"基本介绍 建造者模式（Builder Pattern）使用多个简单的对象一步一步构建成一个复杂的对象。 具体内容是将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。 特点：灵活，耦合度低，可自由组合，提供暴露接口使用户不必关心底层的实现，直接调用即可 建造者模式与抽象工厂模式相似，也用来创建复杂的对象。 主要的区别是建造者模式着重一步步构造一个复杂且灵活的对象，而抽象工厂模式着重于同时提供多个系列的产品对象。 该模式属于创建型模式。 案例图示 去肯德基，汉堡、可乐、薯条、炸鸡翅等是不变的，而其组合是经常变化的，生成出所谓的”套餐\"： 优缺点 优点： 隐藏了一个产品的内部结构和装配过程 将构造代码与表示代码分开 可以对构造过程进行更加精细的控制 缺点： 产品必须有共同点，范围有限制 如果内部变化复杂，会有很多的建造类 代码实现 用Python实现建造者模式： # 最终产品 class Product: def __init__(self) -> None: self.hamburger = None self.coke = None def __str__(self) -> str: return \"Product\".center(20, \"=\") + \\ \"\\n\" + (\"hamburger : %s\" % self.hamburger).center(20, \" \") + \\ \"\\n\" + (\"coke : %s\" % self.coke).center(20, \" \") + \\ \"\\n\" + \"=\" * 20 # 套餐组合 # 套餐1（肥牛组合）：牛肉汉堡、可口可乐 class BeefPackage: def __init__(self) -> None: self.product = Product() def buildHamburger(self): self.product.hamburger = \"Beaf Hamburger\" def buildCoke(self): self.product.coke = \"Coca Cola\" # 套餐2(炸鸡套餐) ： 鸡肉汉堡、百事可乐 class ChickenPackage: def __init__(self) -> None: self.product = Product() def buildHamburger(self): self.product.hamburger = \"Chicken Hamburger\" def buildCoke(self): self.product.coke = \"Pepsi Cola\" # 建造者类 class KfcStore: def getProduct(self): package = None choice = input( \"Please Choice Your Package\\na.Beef Package\\nb.Chicken Package\\n>>> \") if choice == \"a\": package = BeefPackage() elif choice == \"b\": package = ChickenPackage() else: raise ValueError(\"don't have package choice %r\" % choice) # 根据选择套餐方案开始建造产品 package.buildHamburger() package.buildCoke() return package.product if __name__ == \"__main__\": kfc = KfcStore() product = kfc.getProduct() print(product) # Please Choice Your Package # a.Beef Package # b.Chicken Package # >>> b # ======Product======= # hamburger : Chicken Hamburger # coke : Pepsi Cola # ==================== Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:46 "},"Python/Python设计模式/单例模式.html":{"url":"Python/Python设计模式/单例模式.html","title":"单例模式","keywords":"","body":"基本介绍 单例模式（Singleton Pattern）即一个类只能拥有一个实例对象，实例化多次的结果都会指向同一个对象。 特点：全局唯一，允许更改 该模式属于创建型模式，同时也是创建型模式中应用最为广泛的一种。 案例图示 从配置文件中读取配置来进行实例化，在配置相同的情况下，就没必要重复产生对象浪费内存了，只有在配置不同的情况下才会生成新的实例。 文件内容如下： # settings.py文件内容如下 HOST = \"localhost\" PORT = 3306 案例图示： 优缺点 优点： 避免对资源的多重占用，如写入文件操作 节省内存 防止命名空间被污染 缺点： 没有接口，不能继承，与单一职责原则冲突，一个类应该只关心内部逻辑，而不关心外面怎么样来实例化 代码实现 Python实现单例模式手段较多，这里例举5种比较常见的。 继承实现 基础代码如下： class Singleton: def __new__(cls, *args, **kwargs) -> object: \"\"\" cls : class Category \"\"\" if not hasattr(cls, \"ins\"): singletonInsObject = super(__class__, cls).__new__(cls, *args, **kwargs) setattr(cls, \"ins\", singletonInsObject) return getattr(cls, \"ins\") class Category(Singleton): pass if __name__ == \"__main__\": ins = Category() print(id(ins)) ins = Category() print(id(ins)) 元类实现 基础代码如下： class MetaClass(type): def __call__(self, *args, **kwargs): \"\"\" self : class Category \"\"\" if not hasattr(self, \"ins\"): singletonInsObject = super(__class__, self).__call__(*args, **kwargs) setattr(self, \"ins\", singletonInsObject) return getattr(self, \"ins\") class Category(object, metaclass=MetaClass): pass if __name__ == \"__main__\": ins = Category() print(id(ins)) ins = Category() print(id(ins)) 装饰器实现 基础代码如下： def warpper(clsObject): def inner(*args, **kwargs): if not hasattr(clsObject, \"ins\"): singletonInsObject = clsObject(*args, **kwargs) setattr(clsObject, \"ins\", singletonInsObject) return getattr(clsObject, \"ins\") return inner @warpper class Category: pass if __name__ == \"__main__\": ins = Category() print(id(ins)) ins = Category() print(id(ins)) 模块实现 基础代码如下： - foo.py --> ins = Category() - bar.py --> from foo import ins @classmethod实现 基础代码如下： class Category: @classmethod def getSingletonInstanceObject(cls, *args, **kwargs): if not hasattr(cls, \"ins\"): singletonInsObject = cls(*args, **kwargs) setattr(cls, \"ins\", singletonInsObject) return getattr(cls, \"ins\") if __name__ == \"__main__\": ins = Category.getSingletonInstanceObject() print(id(ins)) ins = Category.getSingletonInstanceObject() print(id(ins)) 案例实现 案例实现采用元类实现、装饰器实现以及@classmethod实现. 1）元类实现： import settings class MetaClass(type): \"\"\" self : class MySQL \"\"\" def __call__(self, *args, **kwargs): # 常规实例化 if args or kwargs: insObject = object.__new__(self) self.__init__(insObject, *args, **kwargs) return insObject # 采用默认配置实例化，生成单例对象 if not hasattr(self, \"ins\"): singletonInsObject = object.__new__(self) self.__init__(singletonInsObject, settings.HOST, settings.PORT) setattr(self, \"ins\", singletonInsObject) return getattr(self, \"ins\") class MySQL(object, metaclass=MetaClass): def __init__(self, host, port) -> None: self.host = host self.port = port if __name__ == \"__main__\": ins1 = MySQL(\"192.168.0.1\", 3306) ins2 = MySQL(\"192.168.0.1\", 3307) print(ins1 is ins2) ins3 = MySQL() ins4 = MySQL() print(ins3 is ins4) # False # True 2）装饰器实现： import settings def warpper(cls): singletonInsObject = cls(settings.HOST, settings.PORT) def inner(*args, **kwargs): # 常规实例化 if args or kwargs: insObject = cls(*args, **kwargs) return insObject # 采用默认配置实例化，生成单例对象 return singletonInsObject return inner @warpper class MySQL: def __init__(self, host, port) -> None: self.host = host self.port = port if __name__ == \"__main__\": ins1 = MySQL(\"192.168.0.1\", 3306) ins2 = MySQL(\"192.168.0.1\", 3307) print(ins1 is ins2) ins3 = MySQL() ins4 = MySQL() print(ins3 is ins4) # False # True 3）@classmethod实现： import settings class MySQL: singletonInsObject = None # 常规实例化 def __init__(self, host, port) -> None: self.host = host self.port = port # 采用默认配置实例化，生成单例对象 @classmethod def getSingletonInstanceObject(cls): if not cls.singletonInsObject: cls.singletonInsObject = cls(settings.HOST, settings.PORT) return cls.singletonInsObject if __name__ == \"__main__\": ins1 = MySQL(\"192.168.0.1\", 3306) ins2 = MySQL(\"192.168.0.1\", 3307) print(ins1 is ins2) ins3 = MySQL.getSingletonInstanceObject() ins4 = MySQL.getSingletonInstanceObject() print(ins3 is ins4) # False # True Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:46 "},"Python/Python设计模式/原型模式.html":{"url":"Python/Python设计模式/原型模式.html","title":"原型模式","keywords":"","body":"基本介绍 原型模式（Prototype Pattern）是用于创建重复的对象，同时又能保证性能。 这种模式是实现了一个原型接口，该接口用于创建当前对象的克隆。 当直接创建对象的代价比较大时，则采用这种模式。 特点：仅存在一份，后面如果要用类似的就进行克隆拷贝，拷贝方式分2种，深拷和浅拷，原型允许个体中的属性存在差异 原型模式更适用于创建一个通用的模板，后续要使用时在此模板的基础上对实例属性进行一定范围内的变更。 该模式属于创建型模式。 案例图示 每台计算机的构成都是类似的，如果要同时组装多台计算机，可采用原型模式进行设计。 只实例化一次，减少实例化的消耗，后续个体都通过拷贝原型并修改其中属性实现差异化： 优缺点 优点： 性能提高，减少实例化时的内存消耗 节省内存 简化对象创建，同时避免了构造函数的约束，不受构造函数的限制直接复制对象，是优点，也有隐患，这一点还是需要多留意一些 缺点： 深拷贝和浅拷贝的使用需要事先考虑周到 某些编程语言中，拷贝会影响到静态变量和静态函数的使用 代码实现 用Python实现原型模式： import copy # 计算机原型 class ComputerPrototype: def __init__(self) -> None: self.cpu = None self.gpu = None self.ram = None def getInfo(self): return \"cpu : %s\\ngpu : %s\\nram : %s\" % (self.cpu, self.gpu, self.ram) # 原型建造类 class Prototype: def __init__(self) -> None: self.prototype = ComputerPrototype() def getComputer(self, cpu, gpu, ram): computer = copy.deepcopy(self.prototype) computer.__dict__.update({\"cpu\": cpu, \"gpu\": gpu, \"ram\": ram}) return computer if __name__ == \"__main__\": pro = Prototype() computerOne = pro.getComputer(cpu=\"Intel\", gpu=\"Nvidia\", ram=\"Samsung\") computerSecond = pro.getComputer(cpu=\"AMD\", gpu=\"AMD\", ram=\"Kingston\") print(computerOne.getInfo()) print(computerOne.getInfo()) # cpu : Intel # gpu : Nvidia # ram : Samsung # cpu : Intel # gpu : Nvidia # ram : Samsung Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:46 "},"Python/Python设计模式/适配器模式.html":{"url":"Python/Python设计模式/适配器模式.html","title":"适配器模式","keywords":"","body":"基本介绍 适配器模式（Adapter Pattern）是作为两个不兼容的接口之间的桥梁。 这种模式涉及到一个单一的类，该类负责加入独立的或不兼容的接口功能。 特点：兼容不同功能接口的2个类，让这2个类都能用相同的方式进行功能调用 该模式属于结构型模式。 案例图示 现在有2种支付方案，AliPay和WechatPay，它们调用支付的方法都不相同： AliPay调用的是aliPayAPI()进行支付 WechatPay调用的是wechatPayAPI()进行支付 现在我想实现的是不管是AliPay还是WechatPay都调用payAPI来进行支付，不再有各种区分。 并且如果后期加入了AppalePay支付的话，也是调用payAPI进行支付。 有这种需求的话就可以使用适配器模式来对接口进行适配，进行统一管理，如下图所示： 优缺点 优点： 可以让任何两个没有关联的类一起运行 提高了类的复用 增加了类的透明度 灵活性好 缺点： 过多地使用适配器，会让系统非常零乱，不易整体进行把握。比如，明明看到调用的是 A 接口，其实内部被适配成了 B 接口的实现 代码实现 用Python实现适配器模式，有2种实现方案，1是多继承，2是组合，下面是使用组合的方式实现： # 被适配类和接口 class AliPay: def aliPayAPI(self, sum): print(\"ali pay $%s\" % sum) class WeichatPay: def weichatPayAPI(self, sum): print(\"weichat pay $%s\" % sum) # 适配器类 class PayAdapter: def __init__(self, payMode, payMethod) -> None: self.payMode = payMode() self.payMethod = payMethod self.checkPay() def checkPay(self): if not hasattr(self.payMode, self.payMethod): raise AttributeError( \"Unsupported payment method：%s\" % self.payMethod) def payAPI(self, sum): method = getattr(self.payMode, self.payMethod) return method(sum) if __name__ == \"__main__\": # 对支付方案套上适配器 aliPayInstance = PayAdapter(AliPay, \"aliPayAPI\") weichatPayInstance = PayAdapter(WeichatPay, \"weichatPayAPI\") # 使用适配器接口付款 aliPayInstance.payAPI(100) weichatPayInstance.payAPI(100) # ali pay $100 # weichat pay $100 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:46 "},"Python/Python设计模式/桥接模式.html":{"url":"Python/Python设计模式/桥接模式.html","title":"桥接模式","keywords":"","body":"基本介绍 桥接模式（Bridge）将一个事物一分为二，把抽象的部分和实现的部分进行抽离，达到解耦的作用。 同时，被拆分的2个部分也都可以进行独立的变化。 特点：一分为二、独立扩展 桥接模式属于结构型模式。 案例图示 拿一支笔来举例，它拥有钢笔、毛笔等类型（实体）。 同时，不同的实体类型有不同的作用，如钢笔就写硬笔字（抽象），毛笔就写软笔字（抽象）。 优缺点 优点： 实现抽象和现实分离，便于维护 桥接模式拥有优秀的可扩展能力 实现细节对用户透明 缺点： 增加理解和设计难度 代码实现 用Python实现桥接模式： # 实现 class Pen: def __init__(self, use) -> None: self.name = \"pen\" self.use = use def getUse(self): return \"%s can write %s\" % (self.name, self.use.desc) class Brush: def __init__(self, use) -> None: self.name = \"brush\" self.use = use def getUse(self): return \"%s can write %s\" % (self.name, self.use.desc) # 抽象 class HardPenWords: @property def desc(self): return \"hard pen words\" class SoftPenWords: @property def desc(self): return \"soft pen words\" if __name__ == \"__main__\": pen = Pen(use=HardPenWords()) brush = Brush(use=SoftPenWords()) print(pen.getUse()) print(brush.getUse()) # pen can write hard pen words # brush can write soft pen words Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:46 "},"Python/Python设计模式/组合模式.html":{"url":"Python/Python设计模式/组合模式.html","title":"组合模式","keywords":"","body":"基本介绍 组合模式（Composite Pattern），又叫部分整体模式，是用于把一组相似的对象当作一个单一的对象。 组合模式依据树形结构来组合对象，用来表示部分以及整体层次。 特点：多个小的构成一个大的，根据不同粒度可以无限制的进行组合 该模式属于结构型模式，它创建了对象组的树形结构。 案例图示 一台计算机由粗看之下由以下配件组成： 机箱（chassis） 显示器（monitor） 核心处理器（CPU） 显卡（GPU） 内存（memory） 硬盘（disk） 电源（mains） 主板（motherboard） 我们可以使用组合模式将这些配件组装到一起，得到一台计算机。 优缺点 优点： 高层模块调用简单 节点自由增加 缺点： 在使用组合模式时，其叶子和树枝的声明都是实现类，而不是接口，违反了依赖倒置原则 代码实现 用Python实现组合模式，需要注意硬盘内存和显示器可能有多个，因此内部需要用列表来进行维护： # 机箱 class Chassis: def __init__(self, brand, model) -> None: self.brand = brand self.model = model # 主板 class Motherboard: def __init__(self, brand, model) -> None: self.brand = brand self.model = model # CPU class CPU: def __init__(self, brand, model) -> None: self.brand = brand self.model = model # GPU class GPU: def __init__(self, brand, model) -> None: self.brand = brand self.model = model # 内存 class Memory: def __init__(self, brand, size) -> None: self.brand = brand self.size = size # 硬盘 class Disk: def __init__(self, brand, size, type) -> None: self.brand = brand self.size = size self.type = type # 电源 class Mains: def __init__(self, brand, power) -> None: self.brand = brand self.power = power # 显示器 class Monitor: def __init__(self, brand, size, resolution) -> None: self.brand = brand self.size = size self.resolution = resolution # 电脑 class Computer: def __init__(self) -> None: self.chassis = None self.monitor = [] self.cpu = None self.gpu = None self.memory = [] self.disk = [] self.mains = None self.motherboard = None def add(self, name, obj): if hasattr(self, name): oldObject = getattr(self, name) if isinstance(oldObject, list): oldObject.append(obj) else: setattr(self, name, obj) else: raise TypeError(\"invalid accessories\") def remove(self, name): if hasattr(self, name): oldObject = getattr(self, name) if isinstance(oldObject, list): oldObject.pop() else: setattr(self, name, None) def getInfo(self): compileMessage = f\"\"\" ---- compile message ---- Chassis : {self.chassis.brand} {self.chassis.model} Monitor : {list(map(lambda obj:obj.brand + \" \" + obj.size + \" \" + obj.resolution, self.monitor))} * {len(self.monitor)} CPU : {self.cpu.brand} {self.cpu.model} GPU : {self.gpu.brand} {self.gpu.model} Memory : {list(map(lambda obj:obj.brand + \" \" + obj.size, self.memory))} * {len(self.memory)} Disk : {list(map(lambda obj:obj.brand + \" \" + obj.size, self.disk))} * {len(self.disk)} Mains: {self.mains.brand} {self.mains.power} Motherboard : {self.motherboard.brand} {self.motherboard.model} \"\"\" return compileMessage if __name__ == \"__main__\": chassis = Chassis(brand=\"ROG\", model=\"MINI-ITX\") monitor = Monitor(brand=\"SamSung\", size=\"72\", resolution=\"244hz\") cpu = CPU(brand=\"Intel\", model=\"core i9-10980XE\") gpu = GPU(brand=\"Nvidia\", model=\"RTX3090\") memory = Memory(brand=\"SamSung\", size=\"32GB\") disk = Disk(brand=\"SamSung\", size=\"2TB\", type=\"SSD\") mains = Mains(brand=\"Huntkey\", power=\"700W\") motherboard = Motherboard(brand=\"ROG\", model=\"Strix X299-E Gaming II\") compile = Computer() compile.add(\"chassis\", chassis) compile.add(\"monitor\", monitor) compile.add(\"cpu\", cpu) compile.add(\"gpu\", gpu) compile.add(\"memory\", memory) compile.add(\"memory\", memory) compile.add(\"disk\", disk) compile.add(\"mains\", mains) compile.add(\"motherboard\", motherboard) print(compile.getInfo()) # ---- compile message ---- # Chassis : ROG MINI-ITX # Monitor : ['SamSung 72 244hz'] * 1 # CPU : Intel core i9-10980XE # GPU : Nvidia RTX3090 # Memory : ['SamSung 32GB', 'SamSung 32GB'] * 2 # Disk : ['SamSung 2TB'] * 1 # Mains: Huntkey 700W # Motherboard : ROG Strix X299-E Gaming II Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:46 "},"Python/Python设计模式/外观模式.html":{"url":"Python/Python设计模式/外观模式.html","title":"外观模式","keywords":"","body":"基本介绍 外观模式（Facade Pattern）隐藏系统的复杂性，并向客户端提供了一个客户端可以访问系统的接口。 这种模式涉及到一个单一的类，该类提供了客户端请求的简化方法和对现有系统类方法的委托调用。 特点：为子系统中的一组接口提供一个一致的界面，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用 该模式属于结构型模式，它向现有的系统添加一个接口，来隐藏系统的复杂性。 案例图示 去医院看病，可能要去挂号、门诊、划价、取药，让患者或患者家属觉得很复杂，如果有提供接待人员，只让接待人员来处理，就很方便，当然现实中这是不可能存在的： 优缺点 优点： 减少系统相互依赖 提高灵活性 提高了安全性 缺点： 不符合开闭原则，如果要改东西很麻烦，继承重写都不合适 代码实现 用Python实现外观模式： # 行为类 class Hospital: def registered(self, name): print(\"patient : %s go to registered\" % name) def diagnosis(self, name): print(\"patient : %s go to diagnosis\" % name) def price(self, name): print(\"patient : %s go to calculating price\" % name) def getMedicine(self, name): print(\"patient : %s go to get medicine\" % name) # 外观类 class Admit: def __init__(self, name) -> None: self.name = name self.hospital = Hospital() def see_a_doctors(self): print(\"receptionist ..\") # 挂号 self.hospital.registered(self.name) # 诊断 self.hospital.diagnosis(self.name) # 计算价格 self.hospital.price(self.name) # 取药 self.hospital.getMedicine(self.name) if __name__ == \"__main__\": man = \"Ken\" hospital = Admit(man) hospital.see_a_doctors() # receptionist .. # patient : Ken go to registered # patient : Ken go to diagnosis # patient : Ken go to calculating price # patient : Ken go to get medicine Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:46 "},"Python/Python设计模式/代理模式.html":{"url":"Python/Python设计模式/代理模式.html","title":"代理模式","keywords":"","body":"基本介绍 在代理模式（Proxy Pattern）中，一个类代表另一个类的功能。 和适配器模式的区别：适配器模式主要改变所考虑对象的接口，而代理模式不能改变所代理类的接口。 和装饰器模式的区别：装饰器模式为了增强功能，而代理模式是为了加以控制。 特点：为其他对象提供一种代理以控制对这个对象的访问 代理模式属于结构型模式。 案例图示 买火车票不一定要去火车站买，也可以在网上买，省去了排队的环节： 优缺点 优点： 职责清晰 高扩展性 智能化 缺点： 由于在客户端和真实主题之间增加了代理对象，因此有些类型的代理模式可能会造成请求的处理速度变慢 实现代理模式需要额外的工作，有些代理模式的实现非常复杂 代码实现 用Python实现代理模式： class TrainStation: def buy_tickets(self): return \"Train ticket\" def line_up(self): print(\"Users are waiting in line ...\") class Proxy: def __init__(self): # 与火车站建立联系 self.train_station = TrainStation() def buy_tickets(self): self.__request() return self.train_station.buy_tickets() def __request(self): print(\"I am launching a ticket request to the train station ...\") if __name__ == '__main__': get_tickets = Proxy() tickets = get_tickets.buy_tickets() print(tickets) # I am launching a ticket request to the train station ... # Train ticket Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:46 "},"Python/Python设计模式/装饰器模式.html":{"url":"Python/Python设计模式/装饰器模式.html","title":"装饰器模式","keywords":"","body":"基本介绍 装饰器模式（Decorator Pattern）允许向一个现有的对象添加新的功能，同时又不改变其结构。 这种模式创建了一个装饰类，用来包装原有的类，并在保持类方法签名完整性的前提下，提供了额外的功能。 常用于扩展一个类的功能，同时这个新增的功能与原本的类没有任何关联，可以动态的进行撤销。 特点：动态地给一个对象添加一些额外的职责 装饰器模式属于结构型模式。 案例图示 在蜘蛛侠被蜘蛛咬之前，他只是一个普通人，但是被蜘蛛咬了之后，他具有了一些超能力。 同时，如果超能力在未来某一天没有了，他依然还是一个普通人： 优缺点 优点： 装饰类和被装饰类可以独立发展，不会相互耦合，装饰模式是继承的一个替代模式，装饰模式可以动态扩展一个实现类的功能 缺点： 多层装饰比较复杂 代码实现 用Python实现装饰器模式： # 超人（装饰类） class Superman: def __init__(self, person) -> None: self.person = person def fly(self): print(\"%s are flying\" % self.person.name) # 普通人（被装饰类） class Person: def __init__(self, name): self.name = name def eat(self): print(\"%s are eating\" % self.name) # 装饰器类 class Decorator: def __init__(self, person, superman) -> None: self.person = person self.superman = superman(self.person) def __getattr__(self,attr): try: return getattr(self.person, attr) except AttributeError: return getattr(self.superman, attr) if __name__ == \"__main__\": ken = Person(\"ken\") ken.eat() # ken.fly() parker = Decorator(Person(\"Parker\"), Superman) parker.eat() parker.fly() # ken are eating # Parker are eating # Parker are flying Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:46 "},"Python/Python设计模式/享元模式.html":{"url":"Python/Python设计模式/享元模式.html","title":"享元模式","keywords":"","body":"基本介绍 享元模式（Flyweight Pattern）主要用于减少创建对象的数量，以减少内存占用和提高性能。 享元模式尝试重用现有的同类对象，如果未找到匹配的对象，则创建新对象。 特点：运用共享技术有效地支持大量细粒度的对象，用HashMap存储这些对象 该模式属于结构型模式，它提供了减少对象数量从而改善应用所需的对象结构的方式。 案例图示 当大多数请求都是同一个结果，为每个请求生成一个实例的代价太高。 故只要请求的是同一个结果，我们就将已存在的实例进行返回。 举个例子，我们有一个报表系统，当第一次请求2016年度报表时会生成并存储该报表，以后再次请求2016年度报表时都不会重复生成该报表而是通过查询直接返回。 优缺点 优点： 大大减少对象的创建 降低系统的内存 缺点： 提高了系统的复杂度，需要分离出外部状态和内部状态，而且外部状态具有固有化的性质，不应该随着内部状态的变化而变化，否则会造成系统的混乱 代码实现 用Python实现享元模式： # 报表系统 class Report: def __init__(self, year) -> None: self.year = year self.desc = \"%s report\" % year # 请求报表（享元） class RequestReport: def __init__(self) -> None: self.savaMap = {} def getReport(self, year): if not self.savaMap.get(year): print(\"generated report\") newReport = Report(year) self.savaMap[year] = newReport return self.savaMap[year] if __name__ == \"__main__\": client = RequestReport() report = client.getReport(2016) print(report.desc) # 仅生成一次 report = client.getReport(2016) print(report.desc) # generated report # 2016 report # 2016 report Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:46 "},"Python/Python设计模式/责任链模式.html":{"url":"Python/Python设计模式/责任链模式.html","title":"责任链模式","keywords":"","body":"基本介绍 责任链模式（Chain of Responsibility Pattern）为请求创建了一个接收者对象的链。 在这种模式中，通常每个接收者都包含对另一个接收者的引用。如果一个对象不能处理该请求，那么它会把相同的请求传给下一个接收者，依此类推（亦可反之，一个处理了给下一个，直到处理完毕或其中一个不再进行处理）。 特点：避免请求发送者与接收者耦合在一起，让多个对象都有可能接收请求，将这些对象连接成一条链，并且沿着这条链传递请求，直到有对象处理它为止 该模式属于行为型模式。 案例图示 这里有3种等级的日志，info、warning、error。 它们的优先级是：info info日志只处理info级别的，如果碰见warning或者error级别日志则向上传递，如果碰见info级别的则直接处理并返回，不再向上传递。 整个记录过程是一个链式的顺序，如图所示： 优缺点 优点： 降低耦合度，一个请求将被分为接收者和发送者 简化了对象，使得对象不需要知道链的结构 增强给对象指派职责的灵活性。通过改变链内的成员或者调动它们的次序，允许动态地新增或者删除责任 增加新的请求处理类很方便 缺点： 不能保证请求一定被接收 系统性能将受到一定影响，而且在进行代码调试时不太方便，可能会造成循环调用 可能不容易观察运行时的特征，有碍于除错 代码实现 用Python实现责任链模式： import datetime class LevelBase: def write(self, logName, message): print(\"%s:[%s]:[%s] -- %s\" % (logName, datetime.datetime.now(), self.__class__.__name__.upper(), message)) class Error(LevelBase): pass class Warning(LevelBase): pass class Info(LevelBase): pass class Logger: # 建立等级关系 logLevel = (Info(), Warning(), Error()) def __init__(self, logName) -> None: self.logName = logName def write(self, level, message): for ins in __class__.logLevel: if level.upper() == ins.__class__.__name__.upper(): ins.write(self.logName, message) break else: raise ValueError(\"don't have level %s\" % level) if __name__ == \"__main__\": log = Logger(\"Yunya\") log.write(\"error\", \"this is error message\") log.write(\"info\", \"this is info message\") # Yunya:[2021-06-24 19:59:52.958078]:[ERROR] -- this is error message # Yunya:[2021-06-24 19:59:52.958136]:[INFO] -- this is info message Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:46 "},"Python/Python设计模式/解释器模式.html":{"url":"Python/Python设计模式/解释器模式.html","title":"解释器模式","keywords":"","body":"基本介绍 解释器模式（Interpreter Pattern）提供了评估语言的语法或表达式的方式。 这种模式实现了一个表达式接口，该接口解释一个特定的上下文，常被用在 SQL 解析、符号处理引擎等。 特点：给定一个语言，定义它的文法表示，并定义一个解释器，这个解释器使用对应文法来解释语言中的语句 该模式属于行为型模式。 案例图示 使用解释器模式，创建一门新的语言，例如 A是B，B是C，C是D… 可用于加密的工程上： 优缺点 优点： 可扩展性比较好，灵活 增加了新的解释表达式的方式 易于实现简单文法 缺点： 可利用场景比较少 对于复杂的文法比较难维护 代码实现 用Python实现解释器模式： # 密文 class Code: def __init__(self, content) -> None: self.content = content # 解释器 class Interpreter: # 定义文法 grammar = { \"a\" : \"b\", \"b\" : \"c\", \"c\" : \"d\" } def run(self, document): content = document.content result = \"\" for ch in content: result += __class__.grammar[ch] return result if __name__ == \"__main__\": document = Code(\"abc\") result = Interpreter().run(document) print(result) # bcd Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:46 "},"Python/Python设计模式/迭代器模式.html":{"url":"Python/Python设计模式/迭代器模式.html","title":"迭代器模式","keywords":"","body":"基本介绍 迭代器模式（Iterator Pattern）是 Java 和 .Net 编程环境中非常常用的设计模式。 这种模式用于顺序访问集合对象的元素，而不需要知道集合对象的底层表示。 特点：提供一种方法顺序访问一个聚合对象中各个元素，而又无须暴露该对象的内部表示 迭代器模式属于行为型模式。 案例图示 一个对象内部的数据存储结构并不能被直接获取到，而是通过迭代器进行获取。 Python本身已经实现了迭代器模式，只需要重写对象中的__iter__()方法和__next__()方法即可。 优缺点 优点： 支持以不同的方式遍历一个聚合对象 迭代器简化了聚合类 在同一个聚合上可以有多个遍历 缺点： 由于迭代器模式将存储数据和遍历数据的职责分离，增加新的聚合类需要对应增加新的迭代器类，类的个数成对增加，这在一定程度上增加了系统的复杂性 代码实现 用Python实现迭代器模式，迭代一个二叉树对象： # 可迭代对象 class BinaryTree: def __init__(self, root): self.key = root self.leftChild = None self.rightChild = None self.height = 0 def insertLeft(self, newNode): tree = BinaryTree(newNode) if not self.leftChild: self.leftChild = tree else: # 如果插入位置已有节点，则整体向下挪 # 新的子节点与旧的子节点链接，旧的父节点与新的子节点链接 tree.leftChild = self.leftChild self.leftChild = tree self.height += 1 def insertRight(self, newNode): tree = BinaryTree(newNode) if not self.rightChild: self.rightChild = tree else: tree.rightChild = self.rightChild self.rightChild = tree self.height += 1 def getRightChild(self): return self.rightChild def getLeftChild(self): return self.leftChild def setRootVal(self, obj): self.key = obj def getRootVal(self): return self.key def __iter__(self): return TreeIterator(tree=self) def __str__(self): return \"\"%self.getRootVal() # 迭代器 class TreeIterator: def __init__(self, tree) -> None: self.tree = tree self.treeLst = [self.tree] def __iter__(self): return self def __next__(self): # 采用层级遍历 while len(self.treeLst) > 0: node = self.treeLst.pop(0) if node.leftChild: self.treeLst.append(node.getLeftChild()) if node.rightChild: self.treeLst.append(node.getRightChild()) return node raise StopIteration(\"Tree iter end\") if __name__ == '__main__': binaryTree = BinaryTree(\"a\") binaryTree.insertLeft(\"b\") binaryTree.insertRight(\"c\") binaryTree.leftChild.insertLeft(\"d\") binaryTree.leftChild.insertRight(\"e\") binaryTree.rightChild.insertLeft(\"f\") for node in binaryTree: print(node) # # # # # # Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:46 "},"Python/Python设计模式/观察者模式.html":{"url":"Python/Python设计模式/观察者模式.html","title":"观察者模式","keywords":"","body":"基本介绍 观察者模式（Observer Pattern）常用于一对多关系依赖中，当某个对象发生改变后，其他对象也会做出相应的调整策略。 特点：定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新 观察者模式也被称为发布订阅模式，属于行为型模式的一种。 案例图示 当客户减少到阀值时，销售通知工厂减少生产、人力资源开始裁人，反之则增加： 优缺点 优点： 观察者和被观察者是抽象耦合的 建立一套触发机制 缺点： 如果一个被观察者对象有很多的直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间 如果在观察者和观察目标之间有循环依赖的话，观察目标会触发它们之间进行循环调用，可能导致系统崩溃 观察者模式没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的，而仅仅只是知道观察目标发生了变化 代码实现 用Python实现观察者模式： # 观察者：销售部门 # 被观察者：客户资源（SalesInstanceObject._customer） # 通知对象：工厂、人事部门 class Sales: \"\"\"销售部门\"\"\" def __init__(self): # 被观察对象 self._customer = None self._department = [] @property def customer(self): return self._customer @customer.setter def customer(self, value): self._customer = value print('当前客户数量:{}'.format(self._customer)) for obj in self._department: obj.change(value) print('------------------') def notice(self, department): \"\"\"相关部门\"\"\" self._department.append(department) class Hr: \"\"\"人事部门\"\"\" def change(self, value): if value 20: print(\"人事变动：扩员\") else: print(\"人事不受影响\") class Factory: \"\"\"工厂类\"\"\" def change(self, value): if value 25: print(\"生产计划变动：增产\") else: print(\"生产计划保持不变\") if __name__ == '__main__': sales = Sales() hr = Hr() factory = Factory() # 部门关联 sales.notice(hr) sales.notice(factory) # 客户变动 sales.customer = 10 sales.customer = 15 sales.customer = 20 sales.customer = 25 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:46 "},"Python/Python设计模式/中介者模式.html":{"url":"Python/Python设计模式/中介者模式.html","title":"中介者模式","keywords":"","body":"基本介绍 中介者模式（Mediator Pattern）是用来降低多个对象和类之间的通信复杂性。 这种模式提供了一个中介类，中介类来处理不同类之间的通信，并支持松耦合，使代码易于维护。 也就是说，消费者和生产者不直接接触，而是通过中介者来建立联系。 比如MVC 框架中C（控制器）就是 M（模型）和 V（视图）的中介者。 特点：用一个中介对象来封装一系列的对象交互，中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互 中介者模式属于行为型模式。 案例图示 生产者生成各类产品，中介者购买生产者的产品再转卖给消费者，生产者和消费者不直接进行接触： 优缺点 优点： 降低了类的复杂度，将一对多转化成了一对一 各个类之间的解耦 符合迪米特原则 缺点： 中介者会随着业务不断增长而变的庞大，这样的后果是中介者代码复杂且难以维护 代码实现 用Python实现中介者模式： class Consumer: \"\"\"消费者类\"\"\" def __init__(self, product, price): self.name = \"消费者\" self.product = product self.price = price def shopping(self, name): \"\"\"买东西\"\"\" print(\"向{} 购买 {}价格内的 {}产品\".format(name, self.price, self.product)) class Producer: \"\"\"生产者类\"\"\" def __init__(self, product, price): self.name = \"生产者\" self.product = product self.price = price def sale(self, name): \"\"\"卖东西\"\"\" print(\"向{} 销售 {}价格的 {}产品\".format(name, self.price, self.product)) class Mediator: \"\"\"中介者类\"\"\" def __init__(self): self.name = \"中介者\" self.consumer = None self.producer = None def sale(self): \"\"\"进货\"\"\" self.consumer.shopping(self.producer.name) def shopping(self): \"\"\"出货\"\"\" self.producer.sale(self.consumer.name) def profit(self): \"\"\"利润\"\"\" print('中介净赚：{}'.format((self.consumer.price - self.producer.price))) def complete(self): self.sale() self.shopping() self.profit() if __name__ == '__main__': consumer = Consumer('手机', 3000) producer = Producer(\"手机\", 2500) mediator = Mediator() mediator.consumer = consumer mediator.producer = producer mediator.complete() # 向生产者 购买 3000价格内的 手机产品 # 向消费者 销售 2500价格的 手机产品 # 中介净赚：500 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:46 "},"Python/Python设计模式/访问者模式.html":{"url":"Python/Python设计模式/访问者模式.html","title":"访问者模式","keywords":"","body":"基本介绍 访问者模式（Visitor Pattern）可以让多个处理对象对同一个数据对象做出不同的反应，但并不会改变被访问的数据对象。 特点：主要将数据结构与数据操作分离 访问者模式应该是所有模式中最抽象、最难以理解的一个。 该模式属于行为型模式。 案例图示 上市公司的原始财务数据，对于会计来说需要制作各种报表，对于财务总监来说需要分析公司业绩，对于战略顾问来说需要分析行业变化。 它们总是对同一份数据进行访问，但是获得的结果都是不同的： 优缺点 优点： 符合单一职责原则 优秀的扩展性 灵活性 缺点： 具体元素对访问者公布细节，违反了迪米特原则 具体元素变更比较困难 违反了依赖倒置原则，依赖了具体类，没有依赖抽象 代码实现 用Python实现访问者模式： class Finance: \"\"\"财务数据结构类\"\"\" def __init__(self): # 销售额 self.salesvolume = None # 成本 self.cost = None # 历史销售额 self.history_salesvolume = None # 历史成本 self.history_cost = None def set_salesvolume(self, value): self.salesvolume = value def set_cost(self, value): self.cost = value def set_history_salesvolume(self, value): self.history_salesvolume = value def set_history_cost(self, value): self.history_cost = value def accept(self, visitor): pass class Finance_year(Finance): \"\"\"2018年财务数据类\"\"\" def __init__(self, year): Finance.__init__(self) self.work = [] # 安排工作人员列表 self.year = year def add_work(self, work): self.work.append(work) def accept(self): for obj in self.work: obj.visit(self) class Accounting: \"\"\"会计类\"\"\" def __init__(self): self.ID = \"会计\" self.Duty = \"计算报表\" def visit(self, table): print('会计年度： {}'.format(table.year)) print(\"我的身份是： {} 职责： {}\".format(self.ID, self.Duty)) print('本年度纯利润： {}'.format(table.salesvolume - table.cost)) print('------------------') class Audit: \"\"\"财务总监类\"\"\" def __init__(self): self.ID = \"财务总监\" self.Duty = \"分析业绩\" def visit(self, table): print('会计总监年度： {}'.format(table.year)) print(\"我的身份是： {} 职责： {}\".format(self.ID, self.Duty)) if table.salesvolume - table.cost > table.history_salesvolume - table.history_cost: msg = \"较同期上涨\" else: msg = \"较同期下跌\" print('本年度公司业绩： {}'.format(msg)) print('------------------') class Adviser: \"\"\"战略顾问\"\"\" def __init__(self): self.ID = \"战略顾问\" self.Duty = \"制定明年战略\" def visit(self, table): print('战略顾问年度： {}'.format(table.year)) print(\"我的身份是： {} 职责： {}\".format(self.ID, self.Duty)) if table.salesvolume > table.history_salesvolume: msg = \"行业上行，扩大生产规模\" else: msg = \"行业下行，减小生产规模\" print('本年度公司业绩： {}'.format(msg)) print('------------------') class Work: \"\"\"工作类\"\"\" def __init__(self): self.works = [] # 需要处理的年度数据列表 def add_work(self, obj): self.works.append(obj) def remove_work(self, obj): self.works.remove(obj) def visit(self): for obj in self.works: obj.accept() if __name__ == '__main__': work = Work() # 计划安排财务、总监、顾问对2018年数据处理 # 实例化2018年数据结构 finance_2018 = Finance_year(2018) finance_2018.set_salesvolume(200) finance_2018.set_cost(100) finance_2018.set_history_salesvolume(180) finance_2018.set_history_cost(90) # 实例化会计 accounting = Accounting() # 实例化总监 audit = Audit() # 实例化总监 adviser = Adviser() # 会计安排到2018分析日程中 finance_2018.add_work(accounting) finance_2018.add_work(audit) # 顾问安排到2018分析日程中 finance_2018.add_work(adviser) # 添加2018年财务工作安排 work.add_work(finance_2018) work.visit() # 会计年度： 2018 # 我的身份是： 会计 职责： 计算报表 # 本年度纯利润： 100 # ------------------ # 会计总监年度： 2018 # 我的身份是： 财务总监 职责： 分析业绩 # 本年度公司业绩： 较同期上涨 # ------------------ # 战略顾问年度： 2018 # 我的身份是： 战略顾问 职责： 制定明年战略 # 本年度公司业绩： 行业上行，扩大生产规模 # ------------------ Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:46 "},"Python/Python设计模式/备忘录模式.html":{"url":"Python/Python设计模式/备忘录模式.html","title":"备忘录模式","keywords":"","body":"基本介绍 备忘录模式（Memento Pattern）用于保存一个对象的某个状态，以便在适当的时候恢复对象。 特点：不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态 备忘录模式属于行为型模式。 案例图示 游戏有存档和删档的功能，当我们进行到某一关时便可对游戏进行存档，下次进入游戏后按照上次的存档位置继续游戏： 优缺点 优点： 给用户提供了一种可以恢复状态的机制，可以使用户能够比较方便地回到某个历史的状态 实现了信息的封装，使得用户不需要关心状态的保存细节 缺点： 消耗资源。如果类的成员变量过多，势必会占用比较大的资源，而且每一次保存都会消耗一定的内存 代码实现 用Python实现备忘录模式： import copy class AddNumber: def __init__(self): self.start = 0 def add(self, number): self.start = number class Memento: \"\"\"备忘录\"\"\" def backups(self, obj=None): \"\"\" 设置备份方法 :param obj: :return: \"\"\" self.obj_dict = copy.deepcopy(obj.__dict__) print(\"备份数据:{}\".format(self.obj_dict)) def recovery(self, obj): \"\"\" 恢复备份方法 :param obj: :return: \"\"\" obj.__dict__.clear() obj.__dict__.update(self.obj_dict) print(\"恢复数据:{}\".format(self.obj_dict)) return obj if __name__ == '__main__': test = AddNumber() memento = Memento() for i in [1, 2, 3, 4, 5]: if i == 2: memento.backups(test) test.add(i) print(\"当前数据:{}\".format(test.start)) memento.recovery(test) print(test.start) # 备份数据:{'start': 1} # 当前数据:5 # 恢复数据:{'start': 1} # 1 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:46 "},"Python/Python设计模式/命令模式.html":{"url":"Python/Python设计模式/命令模式.html","title":"命令模式","keywords":"","body":"基本介绍 命令模式（Command Pattern）是一种数据驱动的设计模式，它将请求以命令的形式包裹在对象中，并传给调用对象。 调用对象寻找可以处理该命令的合适的对象，并把该命令传给相应的对象，该对象执行命令。 特点：将一个请求封装成一个对象，从而使您可以用不同的请求对客户进行参数化 该模式属于行为型模式。 案例图示 命令模式应该有一下几个角色： 1）Command： 定义命令的接口，声明执行的方法，可以理解为一个基类。 2）ConcreteCommand： 命令接口实现对象，通常会持有接收者，并调用接收者的功能来完成命令要执行的操作。 3）Receiver： 接收者，真正执行命令的对象。任何类都可能成为一个接收者，只要它能够实现命令要求实现的相应功能。 4）Invoker： 要求命令对象执行请求，通常会持有命令对象，可以持有很多的命令对象，相当于使用命令对象的入口。 5）Client： 创建具体的命令对象，组装命令对象和接收者，或许，把这个Client称为装配者会更好理解，因为真正使用命令的客户端是从Invoker来触发执行。 优缺点 优点： 降低了系统耦合度 新的命令可以很容易添加到系统中去 缺点： 使用命令模式可能会导致某些系统有过多的具体命令类 代码实现 用Python实现命令模式： class Command: \"\"\"声明命令模式接口\"\"\" def __init__(self, obj): self.obj = obj def execute(self): pass class ConcreteCommand(Command): \"\"\"实现命令模式接口\"\"\" def execute(self): self.obj.run() class Invoker: \"\"\"接受命令并执行命令的接口\"\"\" def __init__(self): self._commands = [] def add_command(self, cmd): self._commands.append(cmd) def remove_command(self, cmd): self._commands.remove(cmd) def run_command(self): for cmd in self._commands: cmd.execute() class Receiver: \"\"\"具体动作\"\"\" def __init__(self, word): self.word = word def run(self): print(self.word) def client(): \"\"\"装配者\"\"\" test = Invoker() cmd1 = ConcreteCommand(Receiver('命令一')) test.add_command(cmd1) cmd2 = ConcreteCommand(Receiver('命令二')) test.add_command(cmd2) cmd3 = ConcreteCommand(Receiver('命令三')) test.add_command(cmd3) test.run_command() if __name__ == '__main__': client() # 命令一 # 命令二 # 命令三 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:46 "},"Python/Python设计模式/状态模式.html":{"url":"Python/Python设计模式/状态模式.html","title":"状态模式","keywords":"","body":"基本介绍 状态模式（State Pattern）是指当对象的内部状态改变的时候，允许对象执行不同的流程，这样看起来就像改写了一个对象。 核心的方法是把复杂状态变化情况下的流程抽象出来，简化复杂情况状态的判断。 特点：允许对象在内部状态发生改变时改变它的行为，对象看起来好像修改了它的类 案例图示 定义一个运维脚本，用于监控CPU使用率状态，在不同状态下的自动化运维脚本执行不同的操作： 优缺点 优点： 封装了转换规则 枚举可能的状态，在枚举状态之前需要确定状态种类 将所有与某个状态有关的行为放到一个类中，并且可以方便地增加新的状态，只需要改变对象状态即可改变对象的行为 允许状态转换逻辑与状态对象合成一体，而不是某一个巨大的条件语句块 可以让多个环境对象共享一个状态对象，从而减少系统中对象的个数 缺点： 状态模式的使用必然会增加系统类和对象的个数 状态模式的结构与实现都较为复杂，如果使用不当将导致程序结构和代码的混乱 状态模式对\"开闭原则\"的支持并不太好，对于可以切换状态的状态模式，增加新的状态类需要修改那些负责状态转换的源代码，否则无法切换到新增状态，而且修改某个状态类的行为也需修改对应类的源代码 代码实现 用Python实现状态模式： class Base: def executor(self, value): self.run(value) class Low(Base): def __init__(self): self.name = \"较低占用率状态\" def run(self, value): print(\"当前：{} 值:{}\".format(self.name, value)) print(\"无应急情况执行\") class Large(Base): def __init__(self): self.name = \"较高占用率状态\" def run(self, value): print(\"当前：{} 值：{}\".format(self.name, value)) print(\"发送警报邮件\") class Status: def __init__(self): self.value = 0.1 self.low = Low() self.large = Large() self.status = None def monitor(self): if self.value Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:46 "},"Python/Python设计模式/策略模式.html":{"url":"Python/Python设计模式/策略模式.html","title":"策略模式","keywords":"","body":"基本介绍 策略模式（Strategy Pattern）中，一个类的行为或其算法可以在运行时更改。 也就是说该类在不同的环境下，能够调用不同的策略算法。 特点：定义一系列的算法，把它们一个个封装起来, 并且使它们可相互替换 该模式属于行为型模式。 案例图示 如一个人旅游时，当他身在不同的国家中便要说不同的语言： 优缺点 优点： 算法可以自由切换 避免使用多重条件判断 扩展性良好 缺点： 策略类会增多 所有策略类都需要对外暴露 代码实现 用Python实现策略模式： # 人 class People(object): def __init__(self): self.strategy = {} def get_strategy(self, location): strategy = self.strategy.get(location) if strategy: return strategy() else: raise AttributeError(\"不会这个位置的语言\") def register_strategy(self, location, strategy): self.strategy[location] = strategy # 策略类 class Strategy(object): @staticmethod def speak_english(): return \"说英文\" @staticmethod def speak_chinese(): return \"说中文\" # 位置 class Location(object): def __init__(self, location): self.location = location if __name__ == '__main__': person = People() location = Location(\"美国\") # 注册地理位置的策略 person.register_strategy(location.location, Strategy.speak_english) # 获取在美国的策略 print(person.get_strategy(\"美国\")) location = Location(\"中国\") # 注册地理位置的策略 person.register_strategy(location.location, Strategy.speak_chinese) # 获取在中国的策略 print(person.get_strategy(\"中国\")) # 说英文 # 说中文 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:46 "},"Python/Python设计模式/模板模式.html":{"url":"Python/Python设计模式/模板模式.html","title":"模板模式","keywords":"","body":"基本介绍 在模板模式（Template Pattern）中，一个抽象类公开定义了执行它方法的模板。 它的子类可以按需要重写方法实现，但调用将以抽象类中定义的方式进行。 特点：在有一些通用方法都需要使用时，可将其定义为模板 该模式属于行为型模式。 案例图示 如图所示，为同一个模板传入不同的参数会得到不同的结果： 优缺点 优点： 封装不变部分，扩展可变部分 提取公共代码，便于维护 行为由父类控制，子类实现 缺点： 每一个不同的实现都需要一个子类来实现，导致类的个数增加，使得系统更加庞大 代码实现 用Python实现模板模式，实现一个客户点单后的处理流程流程： class User: def __init__(self, name, shop, times, number): self.name = name self.shop = shop self.times = times self.number = number class Handle: def __init__(self, user=None): self.user = user def Invoicen(self): \"\"\"打印小票\"\"\" string = \"打印小票\\n\" \\ \"客户：{} \" \\ \"商品：{} \" \\ \"数量：{} \" \\ \"时间：{} \".format(self.user.name, self.user.shop, self.user.number, self.user.times) print(string) def Make(self): \"\"\"开始制作\"\"\" print(\"制作完成：{} 数量：{}\".format(self.user.shop, self.user.number)) def run(self): self.Invoicen() self.Make() if __name__ == '__main__': test = Handle() xiaoming = User(\"小明\", \"汉堡\", \"17:50\", \"5\") test.user = xiaoming test.run() # 打印小票 # 客户：小明 商品：汉堡 数量：5 时间：17:50 # 制作完成：汉堡 数量：5 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:46 "},"Python/Python网络编程/summary.html":{"url":"Python/Python网络编程/summary.html","title":"Python网络编程","keywords":"","body":" socket编程 TCP粘包 socketserver使用 socketserver源码 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:46 "},"Python/Python网络编程/socket编程.html":{"url":"Python/Python网络编程/socket编程.html","title":"socket编程","keywords":"","body":"前瞻知识 C/S架构 C/S架构是一种由服务端（Server）和客户端（Client）组成的双层架构。 互联网中处处充满了C/S架构（Client/Server），比如我们需要玩英雄联盟，就必须连接至英雄联盟的服务器上，那么对于我们玩家来说它的英雄联盟服务器就是Server端，而我们必须要下载一个英雄联盟Client端才能够去和英雄联盟Server端进行数据交互。 五层协议 互联网的协议实际上就是为了让计算机之间互相进行通信而产生的，本身并没有层级之分。 为了便于理解，我们可以按照功能将它们划分成5层或者7层，如下表所示： 层级 功能 相关协议 应用层 用于规定应用数据的格式，提供给各个应用程序以便于彼此之间进行通信 HTTP、FTP 传输层 用于区分该系统上的唯一一个网络应用程序 TCP、UDP 网络层 用于区分广播域，防止网络风暴的发生 IP 数据链路层 用于划分电信号以及提供IP地址和MAC地址相互转换的功能 以太网协议、ARP协议 物理层 用于传输电信号，它是网络传输数据的基石 socket抽象层 计算机网络的核心就是一堆协议，想开发基于网络通信的软件就必须遵守这些协议。 但是由于学习协议的代价巨大，故我们需要一种高度抽象的中间层来承上启下便于我们进行快速开发。 此时，socket产生了，socket位于应用层和传输层之间，它向下封装了各种协议，用户只需要通过socket提供的接口就能快速的开发出基于网络通信的软件，而并不需要深入的去研究某些底层协议，如TCP、UDP等。 为什么要学习socket呢？因为它是各种与网络沾边的应用框架的底层实现，如Django、requests等只要与网络有关系的框架或模块都离不开socket。 TCP协议简述 流式传输 TCP协议是一种基于字节流的形式，什么叫流呢？因为数据的传输就像是水龙头一样打开哗啦啦的没有确切的边界，如下图所示： 三次握手 Client端和Server端若想正常进行数据交互，必须先经历一次三次握手的过程，用于确定二者关系并建立双向链接通道： 状态释义，可通过netstat命令查看： SYN_SENT：Client端发送一次建立链接请求后会立刻进入该状态，并且在没有收到Server端的回应之前都会保持该状态，通常来说该状态持续时间非常短，几乎不可测 ESTABLISHED：当某一方进入该状态后，则代表可以向另一方发送数据了 LISTEN：Server端在等待Client端建立三次握手时的状态，即监听Client端的请求 SYN_RCVD：Server端进入该状态代表已收到Client端的三次握手链接请求 信息释义： SYN：用于建立链接的标志位 ACK：确认请求的标志位 seq：可以理解为一段暗号，用于确认该信息未被修改 补充，SYN泛洪攻击： 当Server端长期进入SYN_RCVD状态时就要当心是否遭受了SYN洪水攻击。 因为TCP三次握手对于Server端来讲会无限的回复Client端发来的SYN请求，收到一条就回一条。 如果有黑客模拟成千上万台Client端对Server端发起SYN请求，在发送第一次握手后就溜溜球了那么服务器还傻乎乎的等待第三次的握手回信，这么做会让Server端的压力很大。所以TCP协议也被称为好人协议... 补充，半链接池backlog： Server端如果不能一时之间全部处理完成所有的请求时会将后到的请求放入半链接池中进行排队 防止SYN 洪水攻击的有效策略其中一点就是：增大backlog链接池的最大数量，但是一般不会采用该策略 另一个策略是缩小Server端对每个请求的返回次数（如果Server端发现Client端没理自己，就会不断的回应上次的信息。初始值为5s，过5s发一次，然后变成3s，再过3s发一次，变成1s，再发一次...直到不想发了就不会理睬这个请求了） 平常打开一个网页打不开的时候，有一种可能性就是人家的backlog满了，你就只能排在外边儿等 双向链接通道 当Client端和Server端三次握手完成后，TCP协议会创建一个双向链接通道，用于Client端和Server端之间的数据交互，如图所示： 可靠传输 TCP协议也被称为可靠传输协议，即发送方向接收方发送了数据后，接收方必须回应发送方一个收到了的信息的ACK确认，若发送方没收到该ACK确认，则会重新发送一次数据，如下图所示。 注意：三次握手时的数据交互并不是走双向链接通道，而对于下图的数据传输来说则是走的双向链接通道了 四次挥手 当Client端要断开与Server端的链接时，必须要经历一个四次挥手的过程。 为什么创建链接仅需要三次，而断开链接则需要四次呢？ 可以看到，三次握手之前是没有数据传输的，并且其中第二次是一次性发送了一个请求和一个确认。所以减少了一次操作。 而四次挥手涉及到数据的传输，所以不可能简化成三次挥手。 此外，四次挥手也是不同于三次握手，四次挥手也是建立在双向链接通道的基础之上的，而三次握手的时候该双向通道还未建立成功： 状态释义： FIN_WAIT_1：代表主动发起断开链接请求 FIN_WAIT_2：代表此时的Client端不会再主动向Server端发送数据 TIME_WAIT：代表Client端还要回复最后一条确认消息，回复完毕后双向链接正式关闭 CLOSE_WAIT：代表关闭等待 LAST_ACK：代表持续的确认（即只要Client端没有回复第4条信息，Server端就不断尝试发送断开链接的FIN请求） 另外，在实际生活场景中，服务端主动断开链接的情况比较多，因为它涉及到了和很多客户端的通信，还有的客户端还在排队，所以不可能对一个客户端浪费太多时间。 这句话你可以理解为： 服务器是个渣男 ，很多女孩子（Client端）都喜欢他，都给他写情书，他回复完了一个女孩子的情书后立马会拆开下一封情书，并不会只留恋于一封。 UDP协议简述 数据报传输 UDP协议是一种基于数据报的格式（也被称为基于消息的传输），不同于TCP的字节流格式。UDP的数据报格式是有头有尾的，这一点很重要。 如图所示： 不可靠传输 UDP协议在数据传输时并不需要建立双向链接通道。 且UDP发消息与TCP不太一样，发送发只管发送消息，不管接收方有没有收到消息都不会再发，所以这也是UDP协议被称为不可靠传输协议的由来。 因为UDP协议没有这种ACK确认的机制，虽然对于数据可靠性来说下降了不少但是对于数据传输性上则有了明显的提示。 故DHCP服务以及DNS域名解析服务都是使用UDP协议，因为它速度更快，此外早起的QQ也是使用的UDP协议进行通信。 套接字发展史 套接字起源 套接字起源于20世纪70年代加利福尼亚大学伯克利分校版本的Unix，它最初的设计是为了让同一台主机上的多个应用程序之间进行通信，也就是进程通信或者被称为IPC，套接字有两种： 基于文件的套接字 基于网络的套接字 同机的不同进程之间本身是不允许通信的，但是可以通过套接字来进行数据交互。 此外，套接字也允许应用程序将I/O（input / output）插入到网络中，并与网络中的其他应用程序进行通信，基于网络的套接字就是IP地址加端口的组合。 故socket也被称为：IP+PORT。 基于文件的套接字家族 名称：AF_UNIX 作用：Unix一切皆文件，基于文件的套接字调用的就是底层的文件系统来存取数据，两个套接字进程运行在同一台机器上，可以通过访问同一个文件系统间接完成通信。 基于网络的套接字家族 名称：AF_INET 作用：IPV4协议套接字，有了IP + PORT我们可以与互联网上的任何应用程序进行通信。 除此之外还有一个叫AF_INET6的套接字，也就是基于IPV6的套接字。 套接字工作流程 基于TCP协议的套接字工作流程 由于TCP协议本身比较复杂，故使用基于TCP协议的套接字编写程序整体流程也较为复杂： 基于UDP协议的套接字工作流程 基于UDP协议的套接字工作流程相比于基于TCP协议的套接字工作流程来说简单一些，因为不用建立双向链接通道： TCP/Socket简单通信 基础实现 由于TCP协议需要建立双向链接通道，故必须先开启Server端后再开启Client端，否则会发生异常。 Server端代码如下： from socket import * # 1. 实例化socket对象，并添加端口复用 # AF_INET：IPV4 # SOCK_STREAM：TCP协议 server = socket(family=AF_INET, type=SOCK_STREAM) server.setsockopt(SOL_SOCKET, SO_REUSEADDR, 1) # 2.绑定IP地址与端口号 # localhost：仅允许本机使用 # 127.0.0.1：仅允许本机使用 # 0.0.0.0：允许任意client链接 server.bind((\"localhost\", 8888)) # 3.设置半链接池大小 server.listen(5) # 4.阻塞等待三次握手请求 # conn：双向链接通道 # clientAddr：客户端链接信息 conn, clientAddr = server.accept() # 5.接收client发送的信息，单位：字节 data = conn.recv(1024) # 6.给client发送信息 conn.send(data.upper()) # 7.关闭双向链接通道，释放底层端口占用的系统资源 conn.close() # 8.关闭服务器，释放Python应用程序所占据的内存资源 server.close() Client端代码如下： from socket import * # 1. 实例化socket对象 # AF_INET：IPV4 # SOCK_STREAM：TCP协议 client = socket(family=AF_INET, type=SOCK_STREAM) # 2.向服务端发送请求 # 开始进行三次握手并创建双向链接通道 client.connect((\"localhost\", 8888)) # 3.通信开始，发送消息 client.send(\"hello world\".encode(\"u8\")) # 4.接收server端的消息 msg = client.recv(1024) print(msg.decode(\"u8\")) # 5.关闭客户端 client.close() 双层循环 上面的例子中，Server端会接受Client端的信息，并将其进行upper()后返回。 也就是说Server端和Client端的交互仅有一次，这显然不符合常理。 所以我们需要为Server端的代码做一些小小的改动，让其能够不断的处理Client端的请求，而非只处理一次。 具体逻辑是： 增加链接循环，接收不同Client端的三次握手请求 增加通信循环，让Client端和Server端能够长时间通信 Server端代码如下所示： from socket import * server = socket(family=AF_INET, type=SOCK_STREAM) server.setsockopt(SOL_SOCKET, SO_REUSEADDR, 1) server.bind((\"localhost\", 8888)) server.listen(5) while 1: # 不断接受新请求， 即服务端永不停止运（链接循环） conn, clientAddr = server.accept() print(\"%s connect server\" % clientAddr[0]) # 服务端能一直保持和客户端的通信，当客户端输入exit后将停止对当前客户端的服务（通信循环） while 1: data = conn.recv(1024) if data.decode(\"u8\") == \"exit\": break conn.send(data.upper()) print(\"%s close connect\" % clientAddr[0]) conn.close() Client端代码如下所示： from socket import * client = socket(family=AF_INET, type=SOCK_STREAM) client.connect((\"localhost\", 8888)) # 不断的与服务器进行交互 while 1: sendMsg = input(\">>>\") client.send(sendMsg.encode(\"u8\")) # 如果发送的是exit，则断开链接 if sendMsg == \"exit\": break recvMsg = client.recv(1024) print(recvMsg.decode(\"u8\")) print(\"client close\") client.close() Client端发送空信息导致的异常 现在Server端已经全部做好了，但是Client端还有一个问题。 当Client端出现 >>> 时直接敲击回车后会Server端会卡住，只有重启Server端才能解决该问题。 若进行代码调试，可观察到此时Client端处于recv()状态，而Server端也处于recv()状态，这代表Client端发送的回车“空消息”根本没有被Server端所接收到。 为什么会出现这样的情况？还需要从底层原理说起。 其实不管是send()还是recv()都是socket应用程序对操作系统发出的一次系统调用，再此期间CPU工作状态会从用户态转变至内核态。 而用户态的内存数据是不能直接与内核态的内存数据发生交互的，所以只能靠一种映射关系（可以理解为拷贝，但是并不准确）来映射出需要发送的内容。 如果Client端输入一个回车，且发送给了Server端后，Server端是接收不到该信息的，因为recv()的映射是读取不到“空消息”的： Client端将自己的回车“空消息”进行发送 Server端的recv()由于读取不到“空消息”，故会直接卡住 如下图所示： 如果要解决这个问题，我们只需对Client端发送的消息做出限制，让其不为空即可： from socket import * client = socket(family=AF_INET, type=SOCK_STREAM) client.connect((\"localhost\", 8888)) # 不断的与服务器进行交互 while 1: sendMsg = input(\">>>\") # 不让客户端发送空消息 if not sendMsg: continue client.send(sendMsg.encode(\"u8\")) recvMsg = client.recv(1024) print(recvMsg.decode(\"u8\")) # 如果发送的是exit，则断开链接 if sendMsg == \"exit\": break print(\"client close\") client.close() 强行关闭Client端导致的异常 当Server端正在与Client端链接时，如果此时强行关闭Client端，将会导致Server端出现异常。 Windows平台下Server端会直接抛出ConnectionResetError异常 Unix平台下Server端的recv()会无限制收到空信息 如下所示： ConnectionResetError: [WinError 10054] 远程主机强迫关闭了一个现有的连接。 为什么会出现这种原因呢？因为Server端和Client端的链接是双向的，一旦一方关闭链接通道后这个链接通道就会崩塌，从而导致Server端发生此异常。 如何解决该异常？需要用到try和except以及if判断，如下所示： from socket import * server = socket(family=AF_INET, type=SOCK_STREAM) server.setsockopt(SOL_SOCKET, SO_REUSEADDR, 1) server.bind((\"localhost\", 8888)) server.listen(5) while 1: conn, clientAddr = server.accept() print(\"%s connect server\" % clientAddr[0]) while 1: # try： 针对Windows环境 try: data = conn.recv(1024) # if：针对Unix环境 if not data: break conn.send(data.upper()) except ConnectionResetError as e: break print(\"%s close connect\" % clientAddr[0]) conn.close() 最终代码 最终代码如下。 Server端： from socket import * server = socket(family=AF_INET, type=SOCK_STREAM) server.setsockopt(SOL_SOCKET, SO_REUSEADDR, 1) server.bind((\"localhost\", 8888)) server.listen(5) while 1: conn, clientAddr = server.accept() print(\"%s connect server\" % clientAddr[0]) while 1: # try： 针对Windows环境 try: data = conn.recv(1024) # if：针对Unix环境 if not data: break conn.send(data.upper()) except ConnectionResetError as e: break print(\"%s close connect\" % clientAddr[0]) conn.close() Client端： from socket import * client = socket(family=AF_INET, type=SOCK_STREAM) client.connect((\"localhost\", 8888)) # 不断的与服务器进行交互 while 1: sendMsg = input(\">>>\") # 不让客户端发送空消息 if not sendMsg: continue # 如果发送的是exit，则断开链接 if sendMsg == \"exit\": break client.send(sendMsg.encode(\"u8\")) recvMsg = client.recv(1024) print(recvMsg.decode(\"u8\")) print(\"client close\") client.close() UDP/Socket简单通信 基础实现 下面是基于UDP协议的socket通信。由于UDP协议是没有双向链接通道的，故首先启动任意一端都不会报错。 Server端代码如下： from socket import * # 1. 实例化socket对象，并添加端口复用 # AF_INET：IPV4 # SOCK_DGRAM：UDP协议 server = socket(family=AF_INET, type=SOCK_DGRAM) server.setsockopt(SOL_SOCKET, SO_REUSEADDR, 1) # 2.绑定IP地址与端口号 # localhost：仅允许本机使用 # 127.0.0.1：仅允许本机使用 # 0.0.0.0：允许任意client链接 server.bind((\"localhost\", 8888)) # 3.接收client端的数据 data, clientAddr = server.recvfrom(1024) # 4.回复client的信息 server.sendto(data.upper(), clientAddr) # 5.关闭服务器，释放Python应用程序所占据的内存资源 server.close() Client端代码如下： from socket import * # 1. 实例化socket对象 # AF_INET：IPV4 # SOCK_DGRAM：UDP协议 client = socket(family=AF_INET, type=SOCK_DGRAM) # 2.向服务端发送数据 client.sendto(\"hello world\".encode(\"u8\"), (\"localhost\", 8888)) # 3.接收服务端的数据 msg, serverAddr = client.recvfrom(1024) print(msg.decode(\"u8\")) # 4.关闭客户端 client.close() 增加单层循环 由于基于UDP协议通信不会建立双向链接通道，所以我们只需要增加一个“通信循环”即可。 Server端改进代码如下所示： from socket import * server = socket(family=AF_INET, type=SOCK_DGRAM) server.setsockopt(SOL_SOCKET, SO_REUSEADDR, 1) server.bind((\"localhost\", 8888)) while 1: data, clientAddr = server.recvfrom(1024) server.sendto(data.upper(), clientAddr) Client端改进代码如下所示： from socket import * client = socket(family=AF_INET, type=SOCK_DGRAM) while 1: sendMsg = input(\">>>\") if sendMsg == \"exit\": break client.sendto(sendMsg.encode(\"u8\"), (\"localhost\", 8888)) msg, serverAddr = client.recvfrom(1024) print(msg.decode(\"u8\")) client.close() Bug测试 我们对该两段代码进行BUG测试均未发现异常。 1）强制停止Client端是否会导致Server端异常崩溃？ 没有导致，原因是因为UDP协议的通信不基于双向链接通道 2）客户端发送回车或者任意空消息是否会导致recvfrom()卡住？ 没有导致，这个还是要从UDP的数据格式说起，因为UDP是数据报格式的发送，所以即便消息体是空，也还有一个消息头在里面 所以UDP的整段数据是不可能为空的，也就不会导致内核缓冲区读不到数据而卡住 解决端口占用问题 在进行socket编程中肯定会遇到端口被占用的情况，实际上就是服务器再向客户端发送最后一条ACK回应，也就是四次挥手中的第四步。 此时服务器的状态应该处于：TIME_WAIT（等待一段时间确保双向链接通道中的信息全部读取完毕）。这是属于正常情况，请勿惊慌。 解决方式如下： 1）加入一条socket配置，重用ip和端口： # 这条代码放在bind的前面 server = socket(family=AF_INET, type=SOCK_STREAM) server.setsockopt(SOL_SOCKET, SO_REUSEADDR, 1) # * server.bind((\"localhost\", 8888)) 2）针对Linux平台： 发现系统存在大量TIME_WAIT状态的连接，通过调整linux内核参数解决， vi / etc / sysctl.conf 编辑文件，加入以下内容： net.ipv4.tcp_syncookies = 1 net.ipv4.tcp_tw_reuse = 1 net.ipv4.tcp_tw_recycle = 1 net.ipv4.tcp_fin_timeout = 30 然后执行 / sbin / sysctl - p 让参数生效。 net.ipv4.tcp_syncookies = 1 表示开启SYN Cookies。当出现SYN等待队列溢出时，启用cookies来处理，可防范少量SYN攻击，默认为0，表示关闭； net.ipv4.tcp_tw_reuse = 1 表示开启重用。允许将TIME - WAIT sockets重新用于新的TCP连接，默认为0，表示关闭； net.ipv4.tcp_tw_recycle = 1 表示开启TCP连接中TIME - WAIT sockets的快速回收，默认为0，表示关闭。 net.ipv4.tcp_fin_timeout 修改系統默认的 TIMEOUT 时间 验证链接合法性 在很多时候，我们的TCP服务端为了防止网络泛洪可以设置一个客户端链接的验证机制。 这个验证机制的实现其实也是非常简单，思路在于进入通信循环之前，客户端和服务端先走一次链接认证，只有通过认证的客户端才能够继续和服务端进行链接，核心点在于Server端和Client端都必须具有1个相同的验证对比盐值。 实现如图所示： Server端代码如下： from socket import * import json import os import hmac class TcpServer: def __init__(self, ip_port=(\"localhost\", 8888), backlog=5, bufsize=1024) -> None: self.salt = b\"SOCKET SERVER\" self.verificationString = None self.bufsize = bufsize self.backlog = backlog self.ip_port = ip_port self.socket = None self.conn = None self.clientAddr = None def run(self): self.initialization() while 1: self.requestHandler() if not self.verification(): print(\"verification fail\") continue while 1: try: self.communicateHandler() except ConnectionResetError as e: self.conn.close() break def initialization(self): \"\"\"初始化数据\"\"\" self.socket = socket(family=AF_INET, type=SOCK_STREAM) self.socket.setsockopt(SOL_SOCKET, SO_REUSEADDR, 1) self.socket.bind(self.ip_port) self.socket.listen(5) self.socket.listen(self.backlog) def requestHandler(self): \"\"\"处理链接请求\"\"\" self.conn, self.clientAddr = self.socket.accept() def verification(self): \"\"\"验证链接合法性\"\"\" # 生成32位bytes类型的随机值 self.verificationString = os.urandom(32) # 将随机值发送给client端 self.conn.send(self.verificationString) # 接收client端的信息 recvMsg = self.conn.recv(self.bufsize) # 将随机值和盐进行hash加密，与recvMsg进行对比，如果一样则验证通过 # 否则认证失败，关闭双向通道 h = hmac.new(self.salt, self.verificationString) digest = h.digest() print(digest, \"\\n\", recvMsg) return hmac.compare_digest(digest, recvMsg) def communicateHandler(self): \"\"\"处理通信请求\"\"\" data = self.conn.recv(self.bufsize) if not data: raise ConnectionResetError( \"client %s close\" % str(self.clientAddr)) data = json.loads(data.decode(\"u8\")) self.conn.send( json.dumps(data).encode(\"u8\") ) if __name__ == \"__main__\": server = TcpServer() server.run() Client端代码如下： import json import hmac from socket import * class TcpClient: def __init__(self, server_ip_port=(\"localhost\", 8888), backlog=5, bufsize=1024) -> None: self.salt = b\"SOCKET SERVER\" self.bufsize = bufsize self.backlog = backlog self.server_ip_port = server_ip_port self.socket = None def run(self): \"\"\"初始化数据\"\"\" self.socket = socket() self.socket.connect(self.server_ip_port) self.verification() self.communicateHandler() def verification(self): \"\"\"验证链接合法性\"\"\" # 获取server端发送的验证字符串 recvVerificationString = self.socket.recv(self.bufsize) # 将验证字符串与本地的盐进行混合，得到新的结果 h = hmac.new(self.salt, recvVerificationString) digest = h.digest() # 将新结果发送给server端做比对 self.socket.send(digest) def communicateHandler(self): \"\"\"处理通信请求\"\"\" while 1: sendMsg = input(\">>>\") # 不让客户端发送空消息 if not sendMsg: continue # 如果发送的是exit，则断开链接 if sendMsg == \"exit\": break self.socket.send( json.dumps(sendMsg).encode(\"u8\") ) recvMsg = json.loads( self.socket.recv(1024).decode(\"u8\") ) print(recvMsg) self.socket.close() if __name__ == \"__main__\": client = TcpClient() client.run() socket模块方法大全 以下是socket模块所提供的方法： 方法 描述 s.bind() 绑定地址（host, port）到套接字， 在AF_INET下,以元组（host, port）的形式表示地址 s.listen() 开始TCP监听。backlog指定在拒绝连接之前，操作系统可以挂起的最大连接数量。该值至少为1，大部分应用程序设为5就可以了 s.accept() 被动接受TCP客户端连接，(阻塞式)等待连接的到来 s.connect() 主动初始化TCP服务器连接。一般address的格式为元组（hostname, port），如果链接出错会抛出socket.error异常 s.connect_ex() connect()函数的扩展版本，出错时返回出错码，而不是抛出异常 s.recv() 接收TCP数据，数据以字符串形式返回，bufsize指定要接收的最大数据量。flag提供有关消息的其他信息，通常可以忽略 s.send() 发送TCP数据，将string中的数据发送到连接的套接字。返回值是要发送的字节数量，该数量可能小于string的字节大小 s.sendall() 完整发送TCP数据，将string中的数据发送到连接的套接字，但在返回之前会尝试发送所有数据。成功返回None，失败则抛出异常 s.recvfrom() 接收UDP数据，与recv()类似，但返回值是（data, address）。其中data是包含接收数据的字符串，address是发送数据的套接字地址 s.sendto() 发送UDP数据，将数据发送到套接字，address是形式为（ipaddr，port）的元组，指定接收方的ip地址和端口号。返回值是发送的字节数 s.close() 关闭套接字 s.getpeername() 返回连接套接字的远程地址。返回值通常是元组（ipaddr, port） s.getsockname() 返回套接字自己的地址。通常是一个元组(ipaddr, port) s.setsockopt(level,optname,value) 设置给定套接字选项的值 s.getsockopt(level,optname[.buflen]) 返回套接字选项的值 s.settimeout(timeout) 设置链接超时时间，默认为None，即永不超时 s.gettimeout() 返回当前超时期的值，单位是秒，如果没有设置超时期，则返回None s.fileno() 返回套接字的文件描述符 s.setblocking(flag) 如果flag为0，则将套接字设为非阻塞模式，否则将套接字设为阻塞模式（默认值）。非阻塞模式下，如果调用recv()没有发现任何数据，或send()调用无法立即发送数据，那么将引起socket.error异常 s.makefile() 创建一个与该套接字相关连的文件 更多方法，参考官方文档：点我跳转 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:46 "},"Python/Python网络编程/TCP粘包.html":{"url":"Python/Python网络编程/TCP粘包.html","title":"TCP粘包","keywords":"","body":"TCP/Socket与subprocess 我们准备做一个可以在Client端远程执行Server端的shell命令并拿到其执行结果的程序，而涉及到网络通信就必然会使用到socket模块，此外还需要subprocess模块拿到命令执行结果。 关于传输层协议的选择我们采用TCP协议，因为它是可靠传输协议且一次传输的数据量要比UDP协议更大。 以下是Server端的代码实现： import subprocess from socket import * # 默认直接实例化socket是IPV4 + TCP协议 server = socket() server.setsockopt(SOL_SOCKET, SO_REUSEADDR, 1) server.bind((\"localhost\", 8888)) server.listen(5) while 1: conn, clientAddr = server.accept() print(\"%s connect server\" % clientAddr[0]) while 1: try: command = conn.recv(1024) if not command: break result = subprocess.Popen( args=command.decode(\"u8\"), shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE ) # get success result successOut = result.stdout.read() # get error result errorOut = result.stderr.read() # type == bytes dataBody = successOut or errorOut conn.send(dataBody) except ConnectionResetError as e: break print(\"%s close connect\" % clientAddr[0]) conn.close() 以下是Client端代码的实现： from socket import * client = socket() client.connect((\"localhost\", 8888)) while 1: command = input(\">>>\").strip() if not command: continue if command == \"exit\": break client.send(command.encode(\"u8\")) dataBody = client.recv(1024) # windows server : decode(\"gbk\") # unix server : decode(\"u8\") print(dataBody.decode(\"u8\")) print(\"client close\") client.close() 使用测试，Client端输入命令： >>>ls __pycache__ socketClient.py socketServer.py >>>pwd /Users/yunya/PythonProject >>>cal 六月 2021 日 一 二 三 四 五 六 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 >>> 粘包现象 上面的测试看起来一切都非常完美，但如果Client端输入一条结果很长的命令时会出现一次性读取不完的Bug，如下所示： >>>info vim File: *manpages*, Node: vim, Up: (dir) VIM(1) VIM(1) NAME vim - Vi IMproved, a programmer's text editor SYNOPSIS vim [options] [file ..] vim [options] - vim [options] -t tag vim [options] -q [errorfile] ex view gvim gview evim eview rvim rview rgvim rgview DESCRIPTION Vim is a text editor that is upwards compatible to Vi. It can be used to edit all kinds of plain text. It is especially useful for editing programs. There are a lot of enhancements above Vi: multi level undo, multi win- dows and buffers, syntax highlighting, command line editing, filename completion, on-line help, visual selection, etc.. See \":help vi_diff.txt\" for a summary of the differences between Vim and Vi. While running Vim a lot of help can be obtained from the on-line help system, with the \":help\" command. See the ON- >>>ls LINE HELP section below. Most often Vim is started to edit a single file with the command vim file More generally Vim is started with: vim [options] [filelist] If the filelist is missing, the editor will start with an empty buffer. Otherwise exactly one out of the following four may be used to choose one or more files to be edited. file .. A list of filenames. The first one will be the current file and read into the buffer. The cursor will be posi- tioned on the first line of the buffer. You can get to the other files with the \":next\" command. To edit a file that starts with a dash, precede the filelist with \"--\". - The file to edit is read from stdin. Commands are read from stderr, which should be a tty. -t {tag} The file to edit and the initial cursor position depends on a >>> 可以看到，第一次命令是info vim，第二次命令是ls，但是ls显示的依旧是info vim命令的执行结果。 这种现象就被称之为粘包现象。 产生原因 为什么会产生粘包现象呢？其实这与TCP底层传输有关，我们知道TCP是流式传输协议，故消息没有确切的边界。 上述代码中每次的recv()仅读取1024个字节，当消息超过1024字节后就会发生一次性读取不完整个内核缓冲区的情况，此时第二次recv()的读取会接着上次读取的位置继续进行读取，如下图所示： 由于我们的recv()只是按照固定的1024去读取数据，那么一旦整体内核缓冲区中所存储的数据量大于1024个字节，就会产生粘包现象。 产生粘包现象的原因主要还是因为接收方不知道消息之间的界限，不知道一次性读取多少字节的数据所造成的。 Nagle算法 基于TCP协议的socket通信有一个特点： 即一方的send()与另一方的recv()可以没有任何关系 比如一方send()三次，另一方recv()一次就可以将数据全部取出来。 TCP协议的发送方有一个特征，他会采用了Nagle算法来对数据进行组包，如果一次发送的数据量很小，比如第一次发送10个字节，第二次发送2个字节，第三次发送3个字节，他可能会将这15个字节的数据凑到一块发送出去。 这么做有一个弊端就是接收方想要将这个大的数据包按照发送方的发送次数精确无误的接收拆分成10 2 3必须要有发送方提供的拆包机制才行。 Server端代码如下所示： from socket import * ip_port = (\"localhost\", 8000) back_log = 5 server = socket(AF_INET, SOCK_STREAM) server.setsockopt(SOL_SOCKET, SO_REUSEADDR, 1) server.bind(ip_port) server.listen(back_log) conn, addr = server.accept() conn.send(\"ABCDEFGHJK\".encode(\"utf-8\")) # 第一次发送是10Bytes的数据 conn.send(\"LM\".encode(\"utf-8\")) # 第二次也是2Bytes的数据 conn.send(\"NOP\".encode(\"utf-8\")) # 第三次是3Bytes的数据 Client端代码如下所示： from socket import * ip_port = (\"localhost\", 8000) buffer_size = 1024 client = socket(AF_INET, SOCK_STREAM) client.connect(ip_port) data_1 = client.recv(buffer_size) print(\"first send of data:\", data_1.decode(\"utf-8\")) data_2 = client.recv(buffer_size) print(\"second send of data:\", data_2.decode(\"utf-8\")) data_3 = client.recv(buffer_size) print(\"last send of data:\", data_3.decode(\"utf-8\")) 最终接受结果： first send of data: ABCDEFGHJK second send of data: LMNOP last send of data: 可以看见发送方Server分三次发送了15bytes的数据，而接收方Client仅用两个recv()就接收完毕了所有的数据。 由Nagle算法产生的组包，会有极大可能导致粘包现象的发生，故我们需要思考如何让接收方知道发送方每一次发送的数据大小并准确进行拆分。 手动拆分 如果我们手动拆分接收方的recv()读取大小呢？是否还会发生粘包现象？ 改进的Client端代码如下所示： from socket import * ip_port = (\"localhost\", 8000) buffer_size = 1024 client = socket(AF_INET, SOCK_STREAM) client.connect(ip_port) # 由于预先知道对面第一次发送的数据包大小为10bytes，故这里也用10bytes进行读取 data_1 = client.recv(10) print(\"first send of data:\", data_1.decode(\"utf-8\")) # 由于预先知道对面第一次发送的数据包大小为2bytes，故这里也用2bytes进行读取 data_2 = client.recv(2) print(\"second send of data:\", data_2.decode(\"utf-8\")) # 由于预先知道对面第一次发送的数据包大小为3bytes，故这里也用3bytes进行读取 data_3 = client.recv(3) print(\"last send of data:\", data_3.decode(\"utf-8\")) 最终接收结果： first send of data: ABCDEFGHJK second send of data: LM last send of data: NOP 粘包被我们手动的计算字节数来精确的分割数据接受量的大小给解决了，但是这样做是不现实的，我们不可能知道对方发送的数据到底是怎么样的，更不用说手动计算。 所以有没有更好的解决方案呢？ 预先发送消息长度 好了，其实上面关于解决粘包的思路已经出来了。 我们需要做的就是让接收方知道本次需要接收内容的大小才能够精确的将所有数据全部提取出来不产生遗漏。 实现方式很简单，可以尝试以下思路： 发送方发送一个此次数据固定的长度 接收方接收到该数据长度并且回应 发送方收到回应并且发送真正的数据 接收方不断的用默认的buffer_size值接收新的数据并存储起来直到超出整个数据的长度，代表此次数据全部接收完毕 实现代码如下，Server端： import subprocess from socket import * # 默认直接实例化socket是IPV4 + TCP协议 server = socket() server.setsockopt(SOL_SOCKET, SO_REUSEADDR, 1) server.bind((\"localhost\", 8888)) server.listen(5) while 1: conn, clientAddr = server.accept() print(\"%s connect server\" % clientAddr[0]) while 1: try: command = conn.recv(1024) if not command: break result = subprocess.Popen( args=command.decode(\"u8\"), shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE ) # get success result successOut = result.stdout.read() # get error result errorOut = result.stderr.read() # type == bytes dataBody = successOut or errorOut # this is message head # tell client next receive of buffsize how many dataHead = len(dataBody) conn.send(str(dataHead).encode(\"u8\")) # server receive result is ready # representative client it is already possible to receive real data body if conn.recv(1024) == b\"ready\": conn.send(dataBody) except ConnectionResetError as e: break print(\"%s close connect\" % clientAddr[0]) conn.close() Client端： from socket import * client = socket() client.connect((\"localhost\", 8888)) while 1: command = input(\">>>\").strip() if not command: continue if command == \"exit\": break client.send(command.encode(\"u8\")) dataHead = client.recv(1024) dataBodyLength = int(dataHead.decode(\"u8\")) currentRecvDataBodyLength = 0 dataBody = b\"\" # Can receive data body client.send(b\"ready\") while currentRecvDataBodyLength 经过实测后发现输入任何命令都不会发生粘包了。 json+struct增加消息头 上面的解决方案还是有一些弊端，因为Server端是发送了2次send()，第1次发送数据整体长度，第2次发送数据内容主体，这样是不太好的（Server端可能同时处理多个链接，所以send()次数越少越好）。 而且如果Server端传的是一个文件的话那么局限性就太强了。因为我们只能将整体的消息长度发送过去而诸如文件名，文件大小之内的信息就发送不过去。 所以我们需要一个更加完美的解决方案，即Server端发送一次send()就将本次的数据整体长度发送过去（还可以包括文件姓名，文件大小等信息）。 那么这里就要使用到一个内置模块，struct。 struct模块可以将其某一种数据格式序列化为固定长度的bytes类型，其中最重要的两个方法就是pack()、unpack()。 pcak(fmt, *args)：根据格式将数据转换为固定长度的bytes类型 unpack(fmt, string)：根据格式将bytes类型转换为原本的数据 以下是常用fmt格式类型： 格式 C语言类型 Python类型 字节数大小 x 填充字节 没有值 c char 字节长度为1 1 b signed char 整数 1 B unsigned char 整数 1 ? _Bool bool 1 h short 整数 2 H unsigned short 整数 2 i int 整数 4 I unsigned int 整数 4 l long 整数 4 L unsigned long 整数 4 q long long 整数 8 Q unsigned long long 整数 8 n ssize_t 整数 N size_t 整数 f float 浮点数 4 d double 浮点数 8 s char[] 字节 p char[] 字节 P void * 整数 简单的使用示例，将数值转换为固定长度的bytes： >>> import struct >>> binInt = struct.pack(\"i\", len(\"this is message\")) >>> binInt b'\\x0f\\x00\\x00\\x00' >>> struct.unpack(\"i\", binInt) (15,) >>> 现在利用该struct模块 + json模块，我们就可以完美的解决粘包现象。 Server端代码如下： import subprocess import json import struct from socket import * # 默认直接实例化socket是IPV4 + TCP协议 server = socket() server.setsockopt(SOL_SOCKET, SO_REUSEADDR, 1) server.bind((\"localhost\", 8888)) server.listen(5) while 1: conn, clientAddr = server.accept() print(\"%s connect server\" % clientAddr[0]) while 1: try: command = conn.recv(1024) if not command: break result = subprocess.Popen( args=command.decode(\"u8\"), shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE ) # get success result successOut = result.stdout.read() # get error result errorOut = result.stderr.read() # type == bytes dataBody = successOut or errorOut # 如果请求的是文件，还可以添加诸如 fileName fileSize # 等属性 dataHeadDict = { \"dataBodyLength\": len(dataBody), \"dataBodyType\": str(type(dataBody)), } # 将字典序列化为字节 dataHead = json.dumps(dataHeadDict).encode(\"u8\") dataHeadLength = struct.pack(\"i\", len(dataHead)) # 发送数据头长度（固定为4字节）， 数据头字典，数据体信息 conn.send( dataHeadLength + \\ dataHead + \\ dataBody ) except ConnectionResetError as e: break print(\"%s close connect\" % clientAddr[0]) conn.close() Client端代码如下： import json import struct from socket import * client = socket() client.connect((\"localhost\", 8888)) while 1: command = input(\">>>\").strip() if not command: continue if command == \"exit\": break client.send(command.encode(\"u8\")) # step01：接收数据头长度，也就是数据头字典的bufsize dataHeadLength = struct.unpack(\"i\", client.recv(4))[0] # step02：提取数据头字典 dataHeadDict = json.loads(client.recv(dataHeadLength)) # step03：提取数据体长度和数据体类型 dataBodyLength, dataBodyType = dataHeadDict.values() # step04：提取数据体 dataBody = b\"\" currentRecvDataBodyLength = 0 while currentRecvDataBodyLength 通过占位符拆分消息 规定一个特定的占位符作为消息的结束符。这是一个简单的解决方案，总体来说并不如上述方案优秀。 Server 端代码如下： import subprocess from socket import * server = socket() server.setsockopt(SOL_SOCKET, SO_REUSEADDR, 1) server.bind((\"localhost\", 8888)) server.listen(5) placeholder = \"{{$E$}}\" def recv_msg(conn, size=1024) -> str: data = bytes.decode(conn.recv(size), \"utf-8\") # 客户端强制退出，会无限发送 \"\" if not data: return \"\" while not str.endswith(data, placeholder): data += bytes.decode(conn.recv(size), \"utf-8\") return data[:-len(placeholder)] def send_msg(conn, msg: str) -> None: conn.send(str.encode(msg + placeholder, \"utf-8\")) while 1: conn, client_addr = server.accept() print(\"%s connect server\" % client_addr[0]) while 1: try: command = recv_msg(conn, 1024) if not command: break result = subprocess.Popen( args=command, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE ) success_out = result.stdout.read() error_out = result.stderr.read() send_msg(conn, bytes(success_out or error_out).decode(\"utf-8\")) except ConnectionResetError as e: break print(\"%s close connect\" % client_addr[0]) conn.close() Client端代码如下： from socket import * client = socket() client.connect((\"localhost\", 8888)) placeholder = \"{{$E$}}\" def recv_msg(conn, size=1024) -> str: data = bytes.decode(conn.recv(size), \"utf-8\") while not str.endswith(data, placeholder): data += bytes.decode(conn.recv(size), \"utf-8\") return data[:-len(placeholder)] def send_msg(conn, msg: str) -> None: conn.send(str.encode(msg + placeholder, \"utf-8\")) while 1: command = input(\">>>\").strip() if not command: continue if command == \"exit\": break send_msg(client, command) print(recv_msg(client)) print(\"client close\") client.close() Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-08-16 17:23:12 "},"Python/Python网络编程/socketserver使用.html":{"url":"Python/Python网络编程/socketserver使用.html","title":"socketserver使用","keywords":"","body":"socketserver简介 在之前我们使用socket模块来构建服务器，但是使用该模块所编写的服务器处理请求都是串行的，即来一个处理一个，无疑这样的处理效率是十分低下的。 那么本篇文章将介绍socketserver模块的使用，它是对socket模块的更高级别封装，内部支持I/O多路复用机制，能够在最短的时间内处理更多的请求。 官方文档：点我跳转 TCP/socketserver 下面是使用socketserver模块构建TCP服务器的基本格式： import socketserver class Server(socketserver.BaseRequestHandler): def handle(self) -> None: # self.request == conn ❶ # self.client_address = clientAddr ❷ print(\"%s connect server\" % self.client_address[0]) while 1: try: data = self.request.recv(1024) if not data: break print(\"receive client data : %s\" % data.decode(\"u8\")) self.request.send(data.upper()) except ConnectionResetError as e: break print(\"%s close connect\" % self.client_address[0]) self.request.close() if __name__ == \"__main__\": server = socketserver.ThreadingTCPServer( server_address=(\"localhost\", 8888), RequestHandlerClass=Server ) # run server server.serve_forever() ❶：self.request等同于双向链接通道conn ❷：self.client_address就是Client端的地址和端口信息 建立TCP/socketserver的步骤如下： 导入socketserver模块 创建一个新的类，并继承socketserver.BaseRequestHandler，重写其handle()方法，用于处理TCP请求 写入交互逻辑 防止客户端发送空信息以致双方卡死（针对Unix平台Client端异常关闭） 防止客户端突然断开服务端抛出的ConnectionResetError异常（针对Windows平台Client端异常关闭） 实例化socketserver.ThreadingTCPServer类，并传入自定义处理TCP请求的类和绑定ip+port 调用socketserver.ThreadingTCPServer实例对象下的serve_forever()方法，启动服务 注意：socketserver模块实现的TCP服务器并不会提供粘包优化，所以需要自己手动实现。 可以看见，使用socketserver模块来构建TCP/socket服务器会简单很多，同时使用它创建的服务器还支持并发服务，而不再是串行服务。 UDP/socketserver 下面是使用socketserver模块构建UDP服务器的基本格式： import socketserver class Server(socketserver.BaseRequestHandler): def handle(self) -> None: # self.request == (message, server) ❶ # self.client_address = clientAddr ❷ data = self.request[0] server = self.request[1] print(\"receive client data : %s\" % data.decode(\"u8\")) server.sendto(data.upper(), self.client_address) if __name__ == \"__main__\": server = socketserver.ThreadingUDPServer( server_address=(\"localhost\", 8888), RequestHandlerClass=Server ) # run server server.serve_forever() ❶：self.request和TCP的self.request不同，它不是双向链接通道conn，而是包含了信息与服务端本身 ❷：self.client_address就是Client端的地址和端口信息 TCP/socketserver解决粘包 使用socketserver模块来构建能够解决粘包的TCP服务器，以远程输入命令为例。 Server端代码如下： import json import struct import socketserver import subprocess class Server(socketserver.BaseRequestHandler): def handle(self) -> None: \"\"\" 处理通信 \"\"\" print(\"%s connect server\" % self.client_address[0]) while 1: try: command = self.request.recv(1024) if not command: break self.main(command) except ConnectionResetError as e: break print(\"%s close connect\" % self.client_address[0]) self.request.close() def main(self, command): \"\"\" 通信处理的主体逻辑 \"\"\" dataBody = self.runCommand(command) sendData = self.encapsulate(dataBody) self.request.send(sendData) def runCommand(self, command): \"\"\" 运行命令，并返回结果 Args: command string: 远程传入的命令 Returns: string: 命令执行结果 \"\"\" result = subprocess.Popen( args=command.decode(\"u8\"), shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE ) successOut = result.stdout.read() errorOut = result.stderr.read() return successOut or errorOut def encapsulate(self, dataBody): \"\"\" 对命令执行结果进行封装，自定义协议解决粘包问题 Args: dataBody: 命令执行结果 Returns: string: 封装完成的结果，格式是 '消息头长度 [消息头 {消息体长度} ] 消息体' \"\"\" dataHeadDict = { \"dataBodyLength\": len(dataBody), } dataHead = json.dumps(dataHeadDict).encode(\"u8\") dataHeadLength = struct.pack(\"i\", len(dataHead)) sendData = dataHeadLength + dataHead + dataBody return sendData if __name__ == \"__main__\": server = socketserver.ThreadingTCPServer( server_address=(\"localhost\", 8888), RequestHandlerClass=Server ) # run server server.serve_forever() Client端代码如下： import json import struct from socket import * client = socket() client.connect((\"localhost\", 8888)) while 1: command = input(\">>>\").strip() if not command: continue if command == \"exit\": break client.send(command.encode(\"u8\")) # step01：接收数据头长度，也就是数据头字典的bufsize dataHeadLength = struct.unpack(\"i\", client.recv(4))[0] # step02：提取数据头字典 dataHeadDict = json.loads(client.recv(dataHeadLength)) # step03：提取数据体长度和数据体类型 dataBodyLength= dataHeadDict.get(\"dataBodyLength\") # step04：提取数据体 dataBody = b\"\" currentRecvDataBodyLength = 0 while currentRecvDataBodyLength Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:46 "},"Python/Python网络编程/socketserver源码.html":{"url":"Python/Python网络编程/socketserver源码.html","title":"socketserver源码","keywords":"","body":"基础源码 包含信息 socketserver源代码中基本上所有的类都会分成两部分。 server类：处理链接相关 request类：处理通信相关 我们可以看一下socketserver中使用到了哪些比较基础的模块（socketserver.py line 126 - 136）： import socket # socket基础模块 import selectors # I/O多路复用模块 import os # 操作系统接口模块 import errno # 定义符号错误码的模块 import sys # 系统相关模块 try: import threading # 多线程模块，如果平台支持 except ImportError: import dummy_threading as threading # 多线程模块的另一个版本，当平台不支持时导入该模块 from io import BufferedIOBase # 读取相关模块 from time import monotonic as time # 单调时钟模块，避免时间波动的发生 下面是定义了允许导入该模块的内容，这里就基本上是socketserver模块最常用的一些类（socketserver.py line 138 - 141）： __all__ = [\"BaseServer\", \"TCPServer\", \"UDPServer\", \"ThreadingUDPServer\", \"ThreadingTCPServer\", \"BaseRequestHandler\", \"StreamRequestHandler\", \"DatagramRequestHandler\", \"ThreadingMixIn\"] 平台扩展 接下来socketserver模块的执行，会根据不同的平台做出一些不同的区分了。 如（socketserver.py line 142 - 147）： if hasattr(os, \"fork\"): __all__.extend([\"ForkingUDPServer\",\"ForkingTCPServer\", \"ForkingMixIn\"]) if hasattr(socket, \"AF_UNIX\"): __all__.extend([\"UnixStreamServer\",\"UnixDatagramServer\", \"ThreadingUnixStreamServer\", \"ThreadingUnixDatagramServer\"]) 这里主要的意思是动态的为__all__属性增加一些可用于导入的类，但是这些类可以说很少用到，因此不必太在意。 上面为__all__属性增加的类还未进行实现，在何时进行实现呢？你可以在（socketserver.py line 681 - 698）找到这些类的实现，代码如下： if hasattr(os, \"fork\"): class ForkingUDPServer(ForkingMixIn, UDPServer): pass class ForkingTCPServer(ForkingMixIn, TCPServer): pass class ThreadingUDPServer(ThreadingMixIn, UDPServer): pass class ThreadingTCPServer(ThreadingMixIn, TCPServer): pass if hasattr(socket, 'AF_UNIX'): class UnixStreamServer(TCPServer): address_family = socket.AF_UNIX class UnixDatagramServer(UDPServer): address_family = socket.AF_UNIX class ThreadingUnixStreamServer(ThreadingMixIn, UnixStreamServer): pass class ThreadingUnixDatagramServer(ThreadingMixIn, UnixDatagramServer): pass 下面这两行比较重要（socketserver.py line 151 - 154），它会根据平台选择不同的I/O多路复用机制，如果是Unix平台，会采用epoll，而Windows平台则只能采用性能较低的select机制。 if hasattr(selectors, 'PollSelector'): _ServerSelector = selectors.PollSelector else: _ServerSelector = selectors.SelectSelector 其实针对不同平台实例化或添加不同的应用类在各大框架中都比较常见，socketserver模块也不仅仅只有上面一些地方会根据平台进行区分，这里只是例举几个比较重要的。 类的介绍 当socketserver源码执行至此，基本上所有常用的类都被初始化了。 那么这些类的作用到底是什么？前面已经说过，socketserver模块中主要分为两大类，我们就依照这个来进行划分。 1）处理链接相关的类： 类名 描述 父类 BaseServer 基础链接类 object TCPServer TCP协议类 BaseServer UDPServer UDP协议类 TCPServer UnixStreamServer 文件形式字节流类 TCPServer UnixDatagramServer 文件形式数据报类 UDPServer 2）处理通信相关的类： 类名 描述 父类 BaseRequestHandler 基础请求处理类 object StreamRequestHandler 字节流请求处理类 BaseRequestHandler DatagramRequestHandler 数据报请求处理类 BaseRequestHandler 除此之外，还有一些多线程以及多进程相关的类，如下所示。 1）多线程相关的类： 类名 描述 父类 ThreadingMixIn 线程工具包类 object ThreadingUDPServer 多线程UDP协议服务类 ThreadingMixIn, UDPServer ThreadingTCPServer 多线程TCP协议服务类 ThreadingMixIn, TCPServer 2）多进程相关的类： 类名 描述 父类 ForkingMixIn 进程工具包类 object ForkingUDPServer 多进程UDP协议服务类 ForkingMixIn, UDPServer ForkingTCPServer 多进程TCP协议服务类 ForkingMixIn, TCPServer 继承图示 上面所举例的类的继承关系如下所示。 1）处理链接相关的类： 2）处理通信相关的类： 3）多线程相关的类： 4）多进程相关的类： 5）总继承关系一览图： TCP/socketserver分析 实例化过程分析 有了继承关系后，我们可以看TCP服务的实例化过程，首先它的启动如下： ins = socketserver.ThreadingTCPServer((\"ip\", port), RequestHandler) # RequestHandler即我们自己写的类，需要覆写handle()方法 所以我们首先是需要找到ThreadingTCPServer类的__init__()方法，在其父类TCPServer类中能找该方法（socketserver.py line 394 - 460 ）： class TCPServer(BaseServer): address_family = socket.AF_INET # 网络家族的socket，IPV4 socket_type = socket.SOCK_STREAM # TCP协议 request_queue_size = 5 # 消息队列最大数，即backlog半链接池 allow_reuse_address = False # 重用端口，默认关闭 def __init__(self, server_address, RequestHandlerClass, bind_and_activate=True): BaseServer.__init__(self, server_address, RequestHandlerClass) self.socket = socket.socket(self.address_family, self.socket_type) if bind_and_activate: try: self.server_bind() self.server_activate() except: self.server_close() raise 在这里，它又调用了BaseServer.__init__()方法，所以我们先看一下（socketserver.py line 157 - 209）： class BaseServer: timeout = None def __init__(self, server_address, RequestHandlerClass): self.server_address = server_address # 即传入的(ip+port) self.RequestHandlerClass = RequestHandlerClass # 即我们自己传入的类 self.__is_shut_down = threading.Event() # 线程加事件锁 self.__shutdown_request = False 这里的（socketserver.py line 208）会去实例化出一把线程锁，目的是为了今后控制多个请求的处理顺序，所以暂时不用管。接着回到（socketserver.py line 394 - 460 ）的TCPServer类中__init__()方法： 首先它会实例化出一个对象 然后会判断默认参数bind_and_activate是否为True 执行self.server_bind() self.server_activate() class TCPServer(BaseServer): address_family = socket.AF_INET # 网络家族的socket，IPV4 socket_type = socket.SOCK_STREAM # TCP协议 request_queue_size = 5 # 消息队列最大数，即backlog半链接池 allow_reuse_address = False # 重用端口，默认关闭 def __init__(self, server_address, RequestHandlerClass, bind_and_activate=True): BaseServer.__init__(self, server_address, RequestHandlerClass) self.socket = socket.socket(self.address_family, self.socket_type) if bind_and_activate: # bind_and_activate是默认参数，也就是True try: self.server_bind() self.server_activate() except: self.server_close() raise 现在又需要去找self.server_bind()方法，我们要时刻铭记self是谁，self目前是ThreadingTCPServer类的实例对象，所以还需要回到ThreadingTCPServer类中寻找该方法。 最终可以在其第二父类，TCPServer中找到该方法（socketserver.py line 462 - 471 ）： def server_bind(self): # 判断是否重用端口，该属性是TCPServer类属性，默认为False，即不重用端口 if self.allow_reuse_address: self.socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1) # 绑定地址 self.socket.bind(self.server_address) # 获取socket名字，实际上就是 (\"ip\", port) self.server_address = self.socket.getsockname() 该方法执行完毕后又要去找self.server_activate()方法，老样子，先去ThreadingTCPServer类中找，找不到去第一父类ThreadingMixIn中找，依旧找不到，所以再找TCPServer类，最终在（socketserver.py line 473 - 498 ）中找到。 其实该方法就是开启监听，backlog参数为TCPServer类属性request_queue_size，为5： def server_activate(self): \"\"\"Called by constructor to activate the server. May be overridden. \"\"\" self.socket.listen(self.request_queue_size) 现在整个实例化流程已经跑完了，因为没有任何异常的发生，就不会触发self.server_bind()方法。 该方法定义在TCPServer中（socketserver.py line 481 - 487 ），一旦实例化出错将关闭套接字对象，即停止服务器运行： def server_close(self): \"\"\"Called to clean-up the server. May be overridden. \"\"\" self.socket.close() server_forever()启动服务分析 接下来是启动服务，启动服务的代码是： ins.server_forever() 所以我们需要到ThreadingTCPServer类中去寻找该方法，最终可以在其第二父类TCPServer的父类BaseServer中找到（socketserver.py line 219 - 246 ），其实说白了该类就是使用I/O多路复用机制进行不断的死循环监听，一旦有请求过来就立即进行三次握手，创建双向链接通道： def serve_forever(self, poll_interval=0.5): # self.__is_shut_down是一把事件锁，用于控制子线程的启动顺序。 # 这里的clear()代表清除，这个不是重点，往下看。 self.__is_shut_down.clear() try: # （socketserver.py line 151 - 154）中定义了I/O多路复用的机制 # 所以这里会自动选择 with _ServerSelector() as selector: # 事件注册，可读事件，self即当前ThreadingTCPServer的实例 selector.register(self, selectors.EVENT_READ) # 该条件是BaseServer.__init__()的实例属性，默认为False # 所以下面开始死循环进行监听 while not self.__shutdown_request: # 每隔0.5秒，循环监听一次 ready = selector.select(poll_interval) # 由于该属性为False，所以不会跳出 if self.__shutdown_request: break # 一旦有客户端请求链接，便立即运行下面的方法 if ready: self._handle_request_noblock() self.service_actions() finally: self.__shutdown_request = False self.__is_shut_down.set() 如果有链接请求，则会执行self._handle_request_noblock()方法，它在哪里呢？ 其实就在BaseServer中，位于（socketserver.py line 307- 328 ）： def _handle_request_noblock(self): try: # self.get_request()方法在TCPServer中定义 # 返回值为 self.socket.accept()，也就是说它这里会返回conn和clientAddr request, client_address = self.get_request() except OSError: return # self.verify_request()方法的返回结果永远都是True，其实就是验证 # 双向链接通道和客户端地址是否合法，不用太在意 if self.verify_request(request, client_address): try: self.process_request(request, client_address) except Exception: self.handle_error(request, client_address) self.shutdown_request(request) except: self.shutdown_request(request) raise else: self.shutdown_request(request) 这里又要去找self.process_request()方法了，self是ThreadingTCPServer的实例对象，所以先去ThreadingTCPServer类中找，最终该方法可以在其第一父类ThreadingMixIn中找到（socketserver.py line 660- 669 ）。 该方法主要是针对请求验证成功后，需要进行通信的客户端，会创建一个线程来对其进行服务： def process_request(self, request, client_address): # 创建子线程任务，子线程运行self.process_request_thread()方法 # 并且传入了参数双向链接通道request以及客户端地址 t = threading.Thread(target = self.process_request_thread, args = (request, client_address)) # ThreadingMixIn的类属性，为False t.daemon = self.daemon_threads # 第一个值为False，第二个值为True。他们都是ThreadingMixIn的类属性 # 故下面会执行 if not t.daemon and self._block_on_close: if self._threads is None: self._threads = [] # 创建空列表 self._threads.append(t) # 将子线程任务添加至空列表中 t.start() # 执行子线程任务 process_request_thread()方法是子线程处理通信的方法，该方法位于ThreadingMixIn类中，在（socketserver.py line 647- 658 ）处： def process_request_thread(self, request, client_address): \"\"\"Same as in BaseServer but as a thread. In addition, exception handling is done here. \"\"\" try: self.finish_request(request, client_address) except Exception: self.handle_error(request, client_address) finally: self.shutdown_request(request) # 它不会关闭这个线程，而是将其设置为wait()状态 再来接着看self.finish_request()方法，该方法位于BaseServer类中（socketserver.py line 362- 364）： def finish_request(self, request, client_address): \"\"\"Finish one request by instantiating RequestHandlerClass.\"\"\" self.RequestHandlerClass(request, client_address, self) self.RequestHandlerClass即我们自己传入的类，现在会对其进行实例化，我们自定义的类没有__init__()方法，所以他会去寻找该自定义类的父类BaseRequestHandler（socketserver.py line 700- 735）： class BaseRequestHandler: def __init__(self, request, client_address, server): self.request = request # 双向链接通道 self.client_address = client_address # 客户端信息 self.server = server # 实例本身，self self.setup() # 一个钩子函数 try: self.handle() # 我们覆写的handle() finally: self.finish() # 一个钩子函数 def setup(self): pass def handle(self): pass def finish(self): pass 所以现在，你应该明白为什么我们自己写的类一定要覆写handle()方法了。 内部调用顺序图示 以下是实例化过程图示： 以下是启动服务过程图示： UDP/socketserver分析 关于UDP的分析这里暂时就不做了，感兴趣的朋友可以按照继承关系图和上述的分析思路自己分析实现一次。 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:46 "},"Python/Python并发编程/summary.html":{"url":"Python/Python并发编程/summary.html","title":"Python并发编程","keywords":"","body":" 任务处理发展史 并发与并行 线程与进程 GIL锁 threading模块使用 threading线程锁 threading.local功能介绍 multiprocessing模块使用 线程或进程通信 生产者消费者模型 使用执行器提交任务 Linux五大I/O模型 常见I/O示例演示 协程 asynic Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:46 "},"Python/Python并发编程/任务处理发展史.html":{"url":"Python/Python并发编程/任务处理发展史.html","title":"任务处理发展史","keywords":"","body":"从任务处理角度看待操作系统发展史 操作系统的作用是管理硬件，目的是为了让用户更加方便的来操控计算机底层的硬件。 可以看到操作系统对于人们操控计算机进行作业有着不可小觑的功劳，那么在早期没有操作系统的时候你能想象是什么样子吗？现在我们来看一看。 手动化时代 早期的计算机并没有操作系统，而是通过纸带来进行程序的编辑。 它有3台设备，分别是： 输入机 计算机 输出机 那个时候的程序员需要一起约定好时间，来轮流的对自己的程序进行编辑，因为那个时候的计算机在同一时刻下只能由一个人去运行和掌控，我们来看一下它的计算流程： 这个时代的计算机一次只能跑一个人的程序，即同一时刻至多只能运行一个任务，不会受到其他因素的干扰。 它的缺点非常明显，一次只能一个人使用而后面想要使用的人必须得等待前一个人用完之后才行，其执行效率非常低下。 除此之外最关键的就是人在进行与计算机交互的时候计算机的运算器是没有任何工作的，这就造成了资源上极大的浪费，那么这种浪费可以理解为I/O阻塞。 批处理系统时代 相比于前一代计算机处理任务的方式，批处系统的诞生让这一代计算机有了极大的进步，并且输入也不再使用纸带，而是采用磁带，批处理操作系统可以将多个用户的任务同时提交（但是不能同时运行）。 注意：批处理系统并不是一个真正意义上的我们现在所理解的操作系统，而仅是一种支持多任务同时提交、区分不同任务的一段代码 假设有三个程序员需要使用这台计算机，他们需要将自己的程序全部交由一个程序员让其进行人机之间的交互，那么这样就节省了三倍的时间。 但是这样的缺点也很明显，大家只能等待三个人的程序全部处理完后大家才能拿到各自的结果，这个等待过程是十分漫长的。 批处理最大的问题还是在于拥有人手动与计算机交互的过程，此时会发生I/O阻塞，那么能不能把中间的两个小人全部干掉让计算机来做他们做的事儿呢？当然可以，但是当时的人还没想到这一点，如图，缺点如下： 任务提交虽然是同时提交，但是任务执行依旧是串行执行 仍然具有人为操作，I/O时间太长 我们再来想一个问题，如果程序员A的程序出错了，它第一时间拿不到结果，输出的时候会一直卡在那，程序员B和程序员C的程序结果也不用拿了，反正都出不来。是不是很蛋疼？ 后来慢慢的经过时间的积累与技术的发展，针对这一代的批处理系统的缺点，又出现了一种新的技术。 该技术名叫SPOOLING技术，这个技术的出现让上图的两个小人下岗了。SPOOLING技术的出现极大的减少了I/O阻塞的时间。 除此之外，该代操作系统还提出了一个非常重要的思想，即多道程序设计的思想，这个技术思想目前在我们的进程中依然存在，它的主要功能就是解决了程序串行执行的问题。 也就是说： SPOOLING技术解决了人为的I/O阻塞问题 多道程序设计解决了程序串行执行的问题 如图所示： 尽管这样做的确让程序效率提高了不少，但是我们还有一个问题。 计算机中依然是批处理系统，还是要等A、B、C的程序同时出结果才能拿到最终结果，这个时间太长了，就像上面说的如果程序员A的程序出错了卡住了程序员B和C的正常程序也取不出来。 分时系统时代 为了解决上述统一化打印结果的问题，出现了分时操作系统。 该系统很形象的一个比喻就是一台计算机给A、B、C每个程序员一个键盘鼠标和显示器，大家共有一个主机各玩各的互不影响，它们都认为自己的程序是独享的并且马上就能看到自己程序的运行结果，但是实际上大家还是共用的同一个CPU，分时操作系统一言以蔽之即多用户多任务的系统。 分时操作系统到现在依然存在，并且还十分常见，比如许多人去操作同一台服务器。 这时候大家就在考虑，你丫键盘鼠标显示器啥都给我了，为啥直接给我一个主机呢？这主要还是受限于当时的计算机高额的成本造价问题，但是到了如今计算机的成本以及体积都下来后，这些都不是问题了。 个人操作系统的诞生 科技在发展，时代在进步，当科学技术达到一定的水平后，计算机造价变的越来越低廉，此时便出现了个人操作系统。 个人操作系统的出现让任务处理变的越来越迅速，每个人都能做到真正意义上的互不影响。 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:46 "},"Python/Python并发编程/并发与并行.html":{"url":"Python/Python并发编程/并发与并行.html","title":"并发与并行","keywords":"","body":"并发与并行 并发和并行是指操作系统处理任务的能力。 即有多个任务时是一个一个的处理？还是一次处理多个？ 并发：操作系统具有处理多个任务的能力 并行：操作系统具有同时处理多个任务的能力 并发是包含并行的，这里再提出一个伪并行的概念，就是看起来像是同时处理多个任务，但是实际上这些任务并不是被同时处理的，而是具有一定的先后次序，由于这种任务处理切换的速度太快了，所以看起来像是同时处理。 同步与异步 同步和异步是指任务的提交方式。 即当一个任务提交完成后是否需要等待任务的反馈结果出现后再去做其他的事情。 同步：当任务提交完成后，原地等待任务的返回结果，等待的过程中不做任何事 程序上面表现出来的感觉就是卡住了 异步：任务提交之后，不原地等待任务的返回结果，直接去做其他事情 当任务结果出现后会自动反馈给调用者 同步很好理解，但是异步的执行结果是怎么自动反馈的呢？ 这是因为我们在提交异步任务的时候会给任务绑定一个回调函数，当任务完成后会自动的触发该回调函数获得任务执行结果。 阻塞与非阻塞 阻塞和非阻塞是指程序的运行状态。 即程序现在是否卡住了？卡住了就是阻塞，没卡住就是非阻塞，常见I/O操作。 阻塞：当调用某个函数的时候卡住不懂了，如input()函数 非阻塞：当调用某个函数的时候，如遇见I/O操作程序并不会卡住而是去做其他的事情 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:46 "},"Python/Python并发编程/线程与进程.html":{"url":"Python/Python并发编程/线程与进程.html","title":"线程与进程","keywords":"","body":"进程相关 程序和进程 程序是一堆躺在硬盘中的代码，是“死”的 进程是程序被调用执行时活动的状态，是“活”的 当程序运行时必定会产生很多的数据，那么这些数据会被保存在进程中，所以： 进程是最小的资源单元 注意一点，程序只有在运行状态时才会产生进程，而不运行时就是一堆代码而已。 因此，你可以理解为每一段程序运行时都会创建一个“小房子”，这个“小房子”中存放了很多资源。 进程是由谁创建的 进程必定是由操作系统所创建，每个程序运行时都必然会产生一个进程，当然也可以产生多个进程。 如下图所示： 进程间的数据交互 不同进程之间的数据一般来说不允许共享，因为每个进程都是独立的“小房子”，每个“小房子”的资源都是自己独享的。 但我们之前学过socket，这玩意儿最早就是用来解决进程间数据交互问题的。 所以，进程之间虽然默认不支持数据交互，但是我们可以使用某些特殊手段让两个进程之间支持数据交互，这样做需要付出一些代价。 进程中的切换 一个CPU核心同一时刻最多只能运行一个进程，而多个CPU核心同一时刻可以运行多个进程，这个就是并发的体现。 一个系统中肯定有大量的进程，所以CPU需要不断的进行进程切换： 进程切换实际上是由操作系统说了算，但是进程切换的消耗是非常大的，系统需要保留当前进程的状态，进行切换后还需要将进程状态进行恢复，下面介绍一些最基本的进程切换策略。 1）先来先服务策略： 谁先创建进程，CPU就先执行谁。 该算法对一个存活时间很短的进程是相当不利的，如果一个存活时间很长的进程占用了一个CPU核心，而恰巧这个CPU又是单核的，那么其他存活时间短的进程永远也得不到CPU的眷顾了。 所以操作系统的进程调度如果仅有这一种策略是行不通的。 2）短作业优先调度策略： 那个进程作业时间短，CPU就先执行谁。 显然，单一的这种算法会让长作业进程得不到CPU眷顾，故也不能一直采取这种策略。 3）时间片轮询策略： 什么意思呢？就是说假如有多个进程，我每个进程让你运行个三五秒就切换到另一个进程运行，如此来回切换就是时间片轮转，即将时间分段，每个进程只运行一段时间。 在类Unix系统中，我们可以为某个进程分配更多的时间片。 4）多级反馈队列： 这个其实是基于时间片轮转做的，它会将当前所有的活动进程送入一个队列中，根据存活时间来为其分配到不同的队列中，进程存活时间越久，其得到CPU眷顾的次数越低。 如图所示： 其实在Unix系统中，我们可以为一个进程分配更多的时间片与更高的优先级，这里不再举例。 专业性解释 进程就是一个程序在一个数据集上的一次动态执行过程。 进程一般由以下三部分组成： 程序 数据集 进程控制块 我们编写的程序用来描述进程要完成哪些功能以及如何完成； 数据集则是程序在执行过程中所需要使用的资源； 进程控制块用来记录进程的外部特征，描述进程的执行变化过程，系统可以利用它来控制和管理进程，它是系统感知进程存在的唯一标志。 数据集提供所有程序运行时需要的资源，进程控制块用来记录程序的状态，比如说挂起被切换状态还是运行状态等等 线程相关 线程和进程 每个进程创建时也会默认至少创建一个线程，如果把进程比喻为“小房子”，那么线程就是小房子中的人，是真正干活的单元。 因此： 线程是最小的执行单元 一个进程中的所有线程都会共享该进程的所有资源。 需要注意，线程一定是包含在进程内的。 必须先有进程后才能有线程，就像线程这个人必须住在进程的房子里一样： 线程是由谁创建的 线程有2种，一般所说的线程都是系统级别创建的，但也有用户级别创建的线程，这种线程常常被称之为纤程。 它们的区别在于： 系统级线程的切换消耗较大 用户级线程的切换消耗较小 所以，对任务执行效率来说，使用 纤程 > 线程。 线程间的数据交互 线程必须存在于进程中，我们上面说过一个进程可以有多个线程，那么想当然的该进程里的所有资源都可以被位于该进程中的线程所拿到。 而跨进程之间的线程数据交互就是属于进程间的数据交互了： 线程之间的通信一定要注意线程安全问题，举个例子，假如你和你的同学均是一个线程： 你和你的同学在一个房间中，房间里有一颗糖，趁着你干活的时候你同学将糖吃掉了，你干完活回来之后肯定会以为糖果还在，当你去拿糖果的时候由于糖果不在了所以就会抛出异常。 那么这个就是线程安全问题，如何解决线程安全问题这是之后要聊到的一个话题。 线程的切换 线程切换与进程切换如出一辙，看上面的就行了。 专业性解释 1） 一个程序至少有一个进程，一个进程至少有一个线程 2） 进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率。 3） 线程在执行过程中与进程还是有区别的。每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。 4） 进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动，进程是系统进行资源分配和调度的一个独立单元。而线程是进程的一个实体，是CPU调度和分派的基本单元，它是比进程更小的能独立运行的基本单元。 5）线程自己基本上不拥有系统资源，只拥有一点在运行中必不可少的资源（如程序计数器，一组寄存器和栈）但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源。 6） 一个线程可以创建和撤销另一个线程，同一个进程中的多个线程之间可以并发执行。 切换流程 为了控制进程的执行，内核必须有能力挂起正在CPU上运行的进程，并恢复以前挂起的某个进程的执行。这种切换是由操作系统来完成的。因此可以说，任何进程都是在操作系统内核的支持下运行的，是与内核紧密相关的。 从一个进程的运行转到另一个进程上运行，这个过程中经过下面这些变化： 　　　　1. 保存处理机上下文，包括程序计数器和其他寄存器。 　　　　2. 更新PCB信息。 　　　　3. 把进程的PCB移入相应的队列，如就绪、在某事件阻塞等队列。 　　　　4. 选择另一个进程执行，并更新其PCB。 　　　　5. 更新内存管理的数据结构。 　　　　6.恢复处理机上下文。 总而言之，进程的切换非常的消耗资源。 不同的进程之间能进行切换那么不同的线程之间也必定能进行切换，既然线程是最小的执行单元那么同一进程中的线程切换的代价必然是少于进程间的切换的。 程序计数器 我们都知道软件的数据是存储在硬盘上的，这个调用的过程十分缓慢，但是在内存中就会快很多。 同时，一个线程或者进程的切换挂起状态如果是存放在内存中那么是肯定不行的，这个速度对于切换毫秒级别的线程或者进程来说速度依旧不够快。 所以在CPU旁边有了一个程序计数器的存在，由于距离CPU比较近传输状态的时间也会相应缩短。 它的大小并不是很大只有小小的1 - 2kb，主要功能就是存储了这些进程或者线程切换状态的数据。 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:46 "},"Python/Python并发编程/GIL锁.html":{"url":"Python/Python并发编程/GIL锁.html","title":"GIL锁","keywords":"","body":"GIL锁是什么 GIL锁是CPython所独有的，全称为Global Interpreter Lock，译为全局解释器锁。 它是CPython经常被人诟病的一个槽点，直接让CPython的多线程变成了残废。 GIL锁产生的原因 CPython中的一个线程对应于C语言中的一个线程，而CPython在执行函数时会将函数转变为可执行的字节码，如果多个线程同时运行一段字节码是很有可能出错的，为了避免这个错误所以Python使用了GIL锁限制了多线程技术。 GIL锁使得同一个时刻的同一进程下的多个线程只能有一个在CPU上执行字节码，无法将这些线程映射到不同的CPU核心上去执行。 因此CPython的GIL锁注定了其在多线程任务处理方面并没有太大优势，只能做到伪并行的效果，如下图所示： 而对比Java语言，Java语言能够将多个线程映射到不同的CPU核心上，所以他的多线程任务处理是真正的并行化的： GIL锁抢占策略 由于CPython中同一时刻一个CPU只能执行一个线程，那么其他的线程该怎么办呢？ 这个时候其他线程就要对GIL锁进行抢占了，当GIL锁死一个线程之后，并不是非要等这个线程运行完后才会释放，而是会在适当的时候就进行释放 : 该线程遇到了I/O操作 该线程的时间片轮询到了 我们可以通过sys模块查看GIL锁的释放时机： import sys print(sys.getcheckinterval()) # 100 这代表CPU接收100个指令后会切换另一条线程进行执行。 如下图所示： I/O密集型操作 CPython中，多线程技术常于I/O密集型业务中使用，如网络爬虫。 因为GIL锁的释放时机是当一个线程遇到I/O操作后就切换至另一条线程，所以对于需要频繁进行网络I/O的爬虫业务来说，CPython多线程还是很有必要的，它比多进程切换代价更小。 计算密集型操作 CPython中，多进程技术常于计算密集型业务中使用。 因为GIL锁的存在，CPython中一个进程中的多个线程无法映射到不同的CPU核心上进行执行，但是多个进程中的线程则可以映射到不同的CPU核心上，所以当实现一些计算密集型业务时，应当考虑多进程操作。 如下图所示： 为什么不干掉GIL锁 参考文章：Python 有可能删除 GIL 吗？ Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:46 "},"Python/Python并发编程/threading模块使用.html":{"url":"Python/Python并发编程/threading模块使用.html","title":"threading模块使用","keywords":"","body":"threading模块 Python中提供了threading模块来实现线程并发编程，官方文档如下： 官方文档 添加子线程 实例化Thread类 使用该方式新增子线程任务是比较常见的，也是推荐使用的。 简单的代码示例如下，创建3个子线程并向其添加任务，然后运行并打印它们的线程ID和线程名字： import threading import time def task(params): print(\"sub thread run\") currentThread = threading.current_thread() time.sleep(3) print(\"current subthread id : %s\\ncurrent subthread name : %s\\ncurrent subthread params : %s\" % ( currentThread.ident, currentThread.name, params)) if __name__ == \"__main__\": print(\"main thread run\") for item in range(3): subThreadIns = threading.Thread(target=task, args=(item, )) subThreadIns.start() print(\"main thread run end\") # main thread run # sub thread run # sub thread run # sub thread run # main thread run end # current subthread id : 123145534398464 # current subthread name : Thread-1 # current subthread params : 0 # current subthread id : 123145544908800 # current subthread name : Thread-3 # current subthread params : 2 # current subthread id : 123145539653632 # current subthread name : Thread-2 # current subthread params : 1 ❶：返回一个线程对象，注意args的参数必须是一个tuple，否则抛出异常，也就是说单实参必须添加逗号 ❷：start()方法是指该线程对象能够被系统调度了，但不是立即运行该线程，而是等待系统调度后才运行。所以你会看见上面子线程的运行顺序是0、2、1，另外一个线程对象只能运行一次该方法，若多次运行则抛出RunTimeError的异常。 ❸：获取当前的线程对象 ❹：获取当前线程对象的编号和名字，以及传入的参数。当线程启动时，系统都会分配给它一个随机的编号和名字 首先上述代码会先运行主线程，然后会创建3个子线程并运行。 当子线程运行的时候碰到了sleep(3)这种I/O操作时会释放掉GIL锁，并将线程执行权交还给了主线程。 然后主线程就运行完毕了，此时主线程并不会被kill掉，而是等待子线程运行结束后才会被kill掉，而子线程则是运行完毕后会被立刻kill掉。 我们可以看见，上面3个任务如果按照串行执行共会花费9.+秒时间，而通过多线程来运行，则仅需花费3.+秒的时间，极大的提升了任务处理效率。 自定义类覆写run()方法 上面的子线程任务对象是一个全局函数，我们也可以将它作为方法来进行调用。 书写一个类并继承Threading类，覆写run()方法即可： import threading import time class TaskClass(threading.Thread): # ❶ def __init__(self, params): self.params = params # ❷ super(__class__, self).__init__() def run(self): print(\"sub thread run\") currentThread = threading.currentThread() time.sleep(3) print(\"current subthread id : %s\\ncurrent subthread name : %s\\ncurrent subthread params : %s\" % ( currentThread.ident, currentThread.name, self.params)) if __name__ == \"__main__\": print(\"main thread run\") for item in range(3): subThreadIns = TaskClass(item) subThreadIns.start() print(\"main thread run end\") # main thread run # sub thread run # sub thread run # sub thread run # main thread run end # current subthread id : 123145495068672 # current subthread name : Thread-1 # current subthread params : 0 # current subthread id : 123145500323840 # current subthread name : Thread-2 # current subthread params : 1 # current subthread id : 123145505579008 # current subthread name : Thread-3 # current subthread params : 2 ❶：必须继承Threading类并调用父类的__init__()方法 ❷：传入的参数 源码浅析 为什么添加子线程有2种截然不同的方式呢？它们之间有什么区别？这些都可以从源码中找到答案。 我们从Thread类的实例看起，首先是__init__()方法（threading.py line 738 - 800），它主要做了一些初始化的准备工作： class Thread: _initialized = False _exc_info = _sys.exc_info def __init__(self, group=None, target=None, name=None, args=(), kwargs=None, *, daemon=None): # 如果group不是None，就会抛出断言异常 assert group is None, \"group argument must be None for now\" # 如果kwargs是None，则构造一个空字典 if kwargs is None: kwargs = {} # 传入的执行任务的函数或者None self._target = target # 线程名字 self._name = str(name or _newname()) # 任务函数传入的元组参数 self._args = args # 任务函数传入的关键字参数 self._kwargs = kwargs # 是否是守护线程启动，如果不是None则以守护线程模式启动 if daemon is not None: self._daemonic = daemon # 如果是None，则继承当前线程的守护模式 else: self._daemonic = current_thread().daemon # 线程编号 self._ident = None # 锁定状态，None self._tstate_lock = None # 一把Event事件锁 self._started = Event() # 是否停止运行的标志位 self._is_stopped = False # 初始化状态改为True self._initialized = True self._stderr = _sys.stderr _dangling.add(self) 参数释义： group：应该为None，为了日后扩展ThreadGroup类而保留的 target：传入一个可调用对象，即线程任务task，默认为None，即可以不进行传入 name：线程启动时将不再由系统分配线程名称，而是自定义，默认情况下，系统分配的线程名称会由 \"Thread-N\" 的格式构成一个唯一的名称，其中 N 是小的十进制数 args：用于调用目标函数的参数元组，默认是()空元组，你必须传入一个元组 kwargs：用于调用目标函数的关键字参数字典，默认是None，你必须传入一个字典 daemon：命名关键字参数，应当传入一个布尔值，默认为None，它会指定该线程是否是以守护线程模式启动，如果为None，该线程将继承当前线程的守护模式属性 接下来看start()方法，它是告知系统当前线程完成调度，可随时启用的方法（threading.py line 828 - 851）： def start(self): # 如果初始状态不为True，则抛出异常 if not self._initialized: raise RuntimeError(\"thread.__init__() not called\") # 判断当前线程是否被锁住，如果被锁住则抛出异常 if self._started.is_set(): raise RuntimeError(\"threads can only be started once\") with _active_limbo_lock: _limbo[self] = self try: # 执行引导 _start_new_thread(self._bootstrap, ()) except Exception: with _active_limbo_lock: del _limbo[self] raise self._started.wait() 这里关键是看self._bootstrap()方法，该该方法位于（threading.py line 870 - 888），看看它会做什么事情： def _bootstrap(self): try: self._bootstrap_inner() except: if self._daemonic and _sys is None: return raise 继续找self._bootstrap_inner()方法，该该方法位于（threading.py line 901 - 964）。 在该方法的916行时，它会执行run()方法： def _bootstrap_inner(self): ... try: # 执行run self.run() except SystemExit: pass except: ... 如果此时你按照第二种添加子线程的方式，则直接会运行被子类TaskClass覆写的run()方法。 如果是第一种添加子线程的方式，则还需要往里面看（threading.py line 835 - 868）： def run(self): try: # self._target = 我们自己传递的可调用对象task if self._target: self._target(*self._args, **self._kwargs) finally: del self._target, self._args, self._kwargs 至此可以发现，不管是使用哪一种方式添加子线程，都会运行5个方法。 所以说它们内部实现其实都是一样的，没什么特别的，也不要觉得它特别神奇。 threading模块方法大全 以下是threading模块提供的类或方法： 类或方法 描述 返回值 threading.Thread(target, args, kwargs) 创建并返回一个线程对象 threadObject threading.Timer(interval, function, args, kwargs) 创建并返回一个延迟启动的线程对象 threadObject threading.active_count() 获取当前进程下存活的线程数量 int threading.enumerate() 查看当前进程存活了的所有线程对象，以列表形式返回 [threadObject, ...] threading.main_thread() 获取主线程对象 threadObject threading.current_thread() 获取当前正在执行的线程对象 threadObject threading.currentThread() 获取当前正在执行的线程对象 threadObject threading.get_ident() 获取当前正在执行的线程对象的编号 int 下面我将使用该代码对上述功能进行演示： import threading import time class TaskClass(threading.Thread): def run(self): time.sleep(3) pass if __name__ == \"__main__\": for i in range(3): subThreadIns = TaskClass() subThreadIns.start() 1）获取当前进程下存活的线程数量： print(threading.active_count()) # 4 2）查看当前进程存活了的所有线程对象，以列表形式返回： print(threading.enumerate()) # [, , , ] 3）获取主线程对象： print(threading.main_thread()) # 4）获取当前正在执行的线程对象： print(threading.currentThread()) # 5）获取当前正在执行的线程对象的编号： print(threading.get_ident()) # 4380034496 threadObject方法大全 以下是针对线程对象提供的属性或者方法： 方法/属性 描述 返回值 threadObject.start() 通知系统该线程调度完毕，可以随时进行启动，一个线程对象只能运行一次该方法，若多次运行则抛出RunTimeError异常 ... threadObject.join(timeout=None) 主线程默认会等待子线程运行结束后再继续执行，timeou为等待的秒数，如不设置该参数则一直等待。 ... threadObject.getName() 获取线程对象的名字 str threadObject.setName(name) 设置线程对象的名字 None threadObject.is_alive() 查看线程对象是否存活 bool threadObject.isAlive() 查看线程对象是否存活，不推荐使用 bool threadObject.isDaemon() 查看线程对象是否是守护线程 bool threadObject.setDaemon() 设置线程对象为守护线程，主线程运行完毕之后设置为守护线程的子线程便立即结束执行 None threadObject.ident 获取线程对象的编号 int threadObject.name 获取或者设置线程对象的名字 str or None threadObject.daemon 查看线程对象是否是守护线程 bool 主线程阻塞 默认情况下，当子线程启动后，主线程会依旧往下运行而不是等待所有的子线程运行完毕后再继续往下运行。 如图所示，主线程在运行结束后并不会被理解kill掉，而是所有的子线程运行完毕后主线程才会被kill掉： 我们可以利用threadObject.join(timeout=None)来让主线程等待子线程运行完毕后再继续向下运行，timeout为等待的秒数，如不设置该参数则一直等待。 如图所示，这是没有设置timeout的示意图，主线程必须等待所有子线程运行完毕后再接着运行： 代码示例： import threading import time class TaskClass(threading.Thread): def run(self): thName = threading.current_thread().name print(\"%s start run\" % thName) time.sleep(3) print(\"%s run end\" % thName) if __name__ == \"__main__\": print(\"main thread start run\") threadLst = [] for i in range(3): threadLst.append(TaskClass()) for ins in threadLst: ins.start() # 开始运行所有子线程 for ins in threadLst: ins.join() # 让主线程等待所有子线程运行完毕后再接着运行，注意，设置主线程等待的子线程必须处于活跃状态 print(\"main thread carry on run\") print(\"main thread run end\") # main thread start run # Thread-1 start run # Thread-2 start run # Thread-3 start run # Thread-1 run end # Thread-2 run end # Thread-3 run end # main thread carry on run # main thread run end 守护线程 守护线程是指当主线程运行完毕后，子线程是否还要继续运行。 默认threadObject.setDaemon()为None，也就是False，即当前主线程运行完毕后，子线程依旧可以接着运行。 如果threadObject.setDaemon()为True，则当前主线程运行完毕后，子线程即使没有运行完毕也会结束运行。 代码示例： import threading import time class TaskClass(threading.Thread): def run(self): thName = threading.current_thread().name print(\"%s start run\" % thName) time.sleep(3) print(\"%s run end\" % thName) if __name__ == \"__main__\": print(\"main thread start run\") threadLst = [] for i in range(3): threadLst.append(TaskClass()) for ins in threadLst: # 注意，守护线程的设置必须在线程未启动时设置 ins.setDaemon(True) ins.start() print(\"main thread carry on run\") print(\"main thread run end\") # main thread start run # Thread-1 start run # Thread-2 start run # Thread-3 start run # main thread carry on run # main thread run end join()与setDaemon(True)共存 如果同时设置setDaemon(True)与join()方法会怎么样呢？有两种情况： join()方法没有设置timeout（没有设置即表示死等）或者timeout的时间比子线程作业时间要长，这代表子线程会死在主线程之前，setDaemon(True)也就没有了意义，即失效了 join()设置了timeout并且timeout的时间比子线程作业时间要短，这代表主线程会死在子线程之前，setDaemon(True)生效，子线程会跟着主线程一起死亡。 情况一： import threading import time class TaskClass(threading.Thread): def run(self): thName = threading.current_thread().name print(\"%s start run\" % thName) time.sleep(3) print(\"%s run end\" % thName) if __name__ == \"__main__\": subThread = TaskClass() subThread.setDaemon(True) # 主线程运行完后会立即终止子线程的运行。但是由于有join()，故不生效。 subThread.start() subThread.join() # 主线程必须等待子线程运行结束后再接着运行 print(\"main thread run end\") # Thread-1 start run # Thread-1 run end # main thread run end 情况2： import threading import time class TaskClass(threading.Thread): def run(self): thName = threading.current_thread().name print(\"%s start run\" % thName) time.sleep(3) print(\"%s run end\" % thName) if __name__ == \"__main__\": subThread = TaskClass() subThread.setDaemon(True) # 主线程运行完后会立即终止子线程的运行。但是由于有join()，故不生效。 subThread.start() subThread.join(1) # 主线程必须等待子线程运行结束后再接着运行，只等待1s print(\"main thread run end\") # Thread-1 start run # main thread run end 线程延迟启动 使用threading模块中提供的Timer类，可让子线程延迟启动，如下所示： import threading import time def task(): print(\"sub thread start run\") time.sleep(3) print(\"sub thread run end\") if __name__ == \"__main__\": print(\"main thread run\") t1 = threading.Timer(interval=3, function=task) t1.start() # 3秒后才启动子线程 t1.join() print(\"main thread run end\") # main thread run # sub thread start run # sub thread run end # main thread run end 如果要用类的形式，则可以继承threading.Timer()类，并修改self.function属性，个人极度不推荐这样做。 如下所示，在不知道某一个方法怎么使用时扒扒源码看一看，翻翻官方文档就大概能了解： import threading import time class TaskClass(threading.Timer): def __init__(self, *args, **kwargs): # 必须要修改function为你想执行的方法 super(__class__, self).__init__(*args, **kwargs) self.function = self.task def task(self, x, y): print(\"sub thread start run\") time.sleep(3) print(\"parmas %s %s\" % (x, y)) print(\"sub thread run end\") if __name__ == \"__main__\": # 必须传入一个None t1 = TaskClass(interval=3, function=None, args=(1, 2)) t1.start() t1.join() print(\"main thread run end\") # sub thread start run # parmas 1 2 # sub thread run end # main thread run end 多线程编程应用场景 由于GIL锁的存在，Python中对于I/O操作来说可以使用多线程编程，如果是计算密集型的操作则不应该使用多线程进行处理，因为没有I/O操作就不能通过I/O切换来执行其他线程，故对于计算密集型的操作来说多线程没有什么优势，甚至还可能比普通串行还慢（因为涉及到线程切换，虽然是毫秒级别，但是计算的数值越大这个切换也就越密集，GIL锁是100个CPU指令切换一次的） 注意：我们是在Python2版本下进行此次测试，Python3版本确实相差不大，但是，从本质上来说依然是这样的。 计算密集型程序的普通串行运行时间： import threading import time num = 0 def add(): global num for i in range(10000000): # 一千万次 num += 1 def sub(): global num for i in range(10000000): # 一千万次 num -= 1 if __name__ == '__main__': start_time = time.time() add() sub() end_time = time.time() print(\"执行时间:\",end_time - start_time) # ==== 执行结果 ==== 三次采集 \"\"\" 大约在 1.3 - 1.4 秒 \"\"\" 计算密集型程序的多线程并发运行时间： # coding:utf-8 import threading import time num = 0 def add(): global num for i in range(10000000): # 一千万次 num += 1 def sub(): global num for i in range(10000000): # 一千万次 num -= 1 if __name__ == '__main__': start_time = time.time() t1 = threading.Thread(target=add,) t2 = threading.Thread(target=sub,) t1.start() t2.start() t1.join() t2.join() end_time = time.time() print(u\"执行时间:\",end_time - start_time) # ==== 执行结果 ==== 三次采集 \"\"\" 大约 4 - 5 秒 \"\"\" Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:46 "},"Python/Python并发编程/threading线程锁.html":{"url":"Python/Python并发编程/threading线程锁.html","title":"threading线程锁","keywords":"","body":"前言 本章节将继续围绕threading模块讲解，基本上是纯理论偏多。 对于日常开发者来讲很少会使用到本章节的内容，但是对框架作者等是必备知识，同时也是高频的面试常见问题。 官方文档 线程安全 线程安全是多线程或多进程编程中的一个概念，在拥有共享数据的多条线程并行执行的程序中，线程安全的代码会通过同步机制保证各个线程都可以正常且正确的执行，不会出现数据污染等意外情况。 线程安全的问题最主要还是由线程切换导致的，比如一个房间（进程）中有10颗糖（资源），除此之外还有3个小人（1个主线程、2个子线程），当小人A吃了3颗糖后被系统强制进行休息时他认为还剩下7颗糖，而当小人B工作后又吃掉了3颗糖，那么当小人A重新上岗时会认为糖还剩下7颗，但是实际上只有4颗了。 上述例子中线程A和线程B的数据不同步，这就是线程安全问题，它可能导致非常严重的意外情况发生，我们按下面这个示例来进行说明。 下面有一个数值num初始值为0，我们开启2条线程： 线程1对num进行一千万次+1的操作 线程2对num进行一千万次-1的操作 结果可能会令人咋舌，num最后并不是我们所想象的结果0： import threading num = 0 def add(): global num for i in range(10_000_000): num += 1 def sub(): global num for i in range(10_000_000): num -= 1 if __name__ == \"__main__\": subThread01 = threading.Thread(target=add) subThread02 = threading.Thread(target=sub) subThread01.start() subThread02.start() subThread01.join() subThread02.join() print(\"num result : %s\" % num) # 结果三次采集 # num result : 669214 # num result : -1849179 # num result : -525674 上面这就是一个非常好的案例，想要解决这个问题就必须通过锁来保障线程切换的时机。 需要我们值得留意的是，在Python基本数据类型中list、tuple、dict本身就是属于线程安全的，所以如果有多个线程对这3种容器做操作时，我们不必考虑线程安全问题。 　　 锁的作用 锁是Python提供给我们能够自行操控线程切换的一种手段，使用锁可以让线程的切换变的有序。 一旦线程的切换变的有序后，各个线程之间对数据的访问、修改就变的可控，所以若要保证线程安全，就必须使用锁。 threading模块中提供了5种最常见的锁，下面是按照功能进行划分： 同步锁：lock（一次只能放行一个） 递归锁：rlock（一次只能放行一个） 条件锁：condition（一次可以放行任意个） 事件锁：event（一次全部放行） 信号量锁：semaphore（一次可以放行特定个） Lock() 同步锁 基本介绍 Lock锁的称呼有很多，如： 同步锁 互斥锁 它们是什么意思呢？如下所示： 互斥指的是某一资源同一时刻仅能有一个访问者对其进行访问，具有唯一性和排他性，但是互斥无法限制访问者对资源的访问顺序，即访问是无序的 同步是指在互斥的基础上（大多数情况），通过其他机制实现访问者对资源的有序访问 同步其实已经实现了互斥，是互斥的一种更为复杂的实现，因为它在互斥的基础上实现了有序访问的特点 下面是threading模块与同步锁提供的相关方法： 方法 描述 threading.Lock() 返回一个同步锁对象 lockObject.acquire(blocking=True, timeout=1) 上锁，当一个线程在执行被上锁代码块时，将不允许切换到其他线程运行，默认锁失效时间为1秒 lockObject.release() 解锁，当一个线程在执行未被上锁代码块时，将允许系统根据策略自行切换到其他线程中运行 lockObject.locaked() 判断该锁对象是否处于上锁状态，返回一个布尔值 使用方式 同步锁一次只能放行一个线程，一个被加锁的线程在运行时不会将执行权交出去，只有当该线程被解锁时才会将执行权通过系统调度交由其他线程。 如下所示，使用同步锁解决最上面的问题： import threading num = 0 def add(): lock.acquire() global num for i in range(10_000_000): num += 1 lock.release() def sub(): lock.acquire() global num for i in range(10_000_000): num -= 1 lock.release() if __name__ == \"__main__\": lock = threading.Lock() subThread01 = threading.Thread(target=add) subThread02 = threading.Thread(target=sub) subThread01.start() subThread02.start() subThread01.join() subThread02.join() print(\"num result : %s\" % num) # 结果三次采集 # num result : 0 # num result : 0 # num result : 0 这样这个代码就完全变成了串行的状态，对于这种计算密集型I/O业务来说，还不如直接使用串行化单线程执行来得快，所以这个例子仅作为一个示例，不能概述锁真正的用途。 死锁现象 对于同步锁来说，一次acquire()必须对应一次release()，不能出现连续重复使用多次acquire()后再重复使用多次release()的操作，这样会引起死锁造成程序的阻塞，完全不动了，如下所示： import threading num = 0 def add(): lock.acquire() # 上锁 lock.acquire() # 死锁 # 不执行 global num for i in range(10_000_000): num += 1 lock.release() lock.release() def sub(): lock.acquire() # 上锁 lock.acquire() # 死锁 # 不执行 global num for i in range(10_000_000): num -= 1 lock.release() lock.release() if __name__ == \"__main__\": lock = threading.Lock() subThread01 = threading.Thread(target=add) subThread02 = threading.Thread(target=sub) subThread01.start() subThread02.start() subThread01.join() subThread02.join() print(\"num result : %s\" % num) with语句 由于threading.Lock()对象中实现了__enter__()与__exit__()方法，故我们可以使用with语句进行上下文管理形式的加锁解锁操作： import threading num = 0 def add(): with lock: # 自动加锁 global num for i in range(10_000_000): num += 1 # 自动解锁 def sub(): with lock: # 自动加锁 global num for i in range(10_000_000): num -= 1 # 自动解锁 if __name__ == \"__main__\": lock = threading.Lock() subThread01 = threading.Thread(target=add) subThread02 = threading.Thread(target=sub) subThread01.start() subThread02.start() subThread01.join() subThread02.join() print(\"num result : %s\" % num) # 结果三次采集 # num result : 0 # num result : 0 # num result : 0 RLock() 递归锁 基本介绍 递归锁是同步锁的一个升级版本，在同步锁的基础上可以做到连续重复使用多次acquire()后再重复使用多次release()的操作，但是一定要注意加锁次数和解锁次数必须一致，否则也将引发死锁现象。 下面是threading模块与递归锁提供的相关方法： 方法 描述 threading.RLock() 返回一个递归锁对象 lockObject.acquire(blocking=True, timeout=1) 上锁，当一个线程在执行被上锁代码块时，将不允许切换到其他线程运行，默认锁失效时间为1秒 lockObject.release() 解锁，当一个线程在执行未被上锁代码块时，将允许系统根据策略自行切换到其他线程中运行 lockObject.locaked() 判断该锁对象是否处于上锁状态，返回一个布尔值 使用方式 以下是递归锁的简单使用，下面这段操作如果使用同步锁则会发生死锁现象，但是递归锁不会： import threading num = 0 def add(): lock.acquire() lock.acquire() global num for i in range(10_000_000): num += 1 lock.release() lock.release() def sub(): lock.acquire() lock.acquire() global num for i in range(10_000_000): num -= 1 lock.release() lock.release() if __name__ == \"__main__\": lock = threading.RLock() subThread01 = threading.Thread(target=add) subThread02 = threading.Thread(target=sub) subThread01.start() subThread02.start() subThread01.join() subThread02.join() print(\"num result : %s\" % num) # 结果三次采集 # num result : 0 # num result : 0 # num result : 0 with语句 由于threading.RLock()对象中实现了__enter__()与__exit__()方法，故我们可以使用with语句进行上下文管理形式的加锁解锁操作： import threading num = 0 def add(): with lock: # 自动加锁 global num for i in range(10_000_000): num += 1 # 自动解锁 def sub(): with lock: # 自动加锁 global num for i in range(10_000_000): num -= 1 # 自动解锁 if __name__ == \"__main__\": lock = threading.RLock() subThread01 = threading.Thread(target=add) subThread02 = threading.Thread(target=sub) subThread01.start() subThread02.start() subThread01.join() subThread02.join() print(\"num result : %s\" % num) # 结果三次采集 # num result : 0 # num result : 0 # num result : 0 Condition() 条件锁 基本介绍 条件锁是在递归锁的基础上增加了能够暂停线程运行的功能。并且我们可以使用wait()与notify()来控制线程执行的个数。 注意：条件锁可以自由设定一次放行几个线程。 下面是threading模块与条件锁提供的相关方法： 方法 描述 threading.Condition() 返回一个条件锁对象 lockObject.acquire(blocking=True, timeout=1) 上锁，当一个线程在执行被上锁代码块时，将不允许切换到其他线程运行，默认锁失效时间为1秒 lockObject.release() 解锁，当一个线程在执行未被上锁代码块时，将允许系统根据策略自行切换到其他线程中运行 lockObject.wait(timeout=None) 将当前线程设置为“等待”状态，只有该线程接到“通知”或者超时时间到期之后才会继续运行，在“等待”状态下的线程将允许系统根据策略自行切换到其他线程中运行 lockObject.wait_for(predicate, timeout=None) 将当前线程设置为“等待”状态，只有该线程的predicate返回一个True或者超时时间到期之后才会继续运行，在“等待”状态下的线程将允许系统根据策略自行切换到其他线程中运行。注意：predicate参数应当传入一个可调用对象，且返回结果为bool类型 lockObject.notify(n=1) 通知一个当前状态为“等待”的线程继续运行，也可以通过参数n通知多个 lockObject.notify_all() 通知所有当前状态为“等待”的线程继续运行 使用方式 下面这个案例会启动10个子线程，并且会立即将10个子线程设置为等待状态。 然后我们可以发送一个或者多个通知，来恢复被等待的子线程继续运行： import threading currentRunThreadNumber = 0 maxSubThreadNumber = 10 def task(): global currentRunThreadNumber thName = threading.currentThread().name condLock.acquire() # 上锁 print(\"start and wait run thread : %s\" % thName) condLock.wait() # 暂停线程运行、等待唤醒 currentRunThreadNumber += 1 print(\"carry on run thread : %s\" % thName) condLock.release() # 解锁 if __name__ == \"__main__\": condLock = threading.Condition() for i in range(maxSubThreadNumber): subThreadIns = threading.Thread(target=task) subThreadIns.start() while currentRunThreadNumber with语句 由于threading.Condition()对象中实现了__enter__()与__exit__()方法，故我们可以使用with语句进行上下文管理形式的加锁解锁操作： import threading currentRunThreadNumber = 0 maxSubThreadNumber = 10 def task(): global currentRunThreadNumber thName = threading.currentThread().name with condLock: print(\"start and wait run thread : %s\" % thName) condLock.wait() # 暂停线程运行、等待唤醒 currentRunThreadNumber += 1 print(\"carry on run thread : %s\" % thName) if __name__ == \"__main__\": condLock = threading.Condition() for i in range(maxSubThreadNumber): subThreadIns = threading.Thread(target=task) subThreadIns.start() while currentRunThreadNumber Event() 事件锁 基本介绍 事件锁是基于条件锁来做的，它与条件锁的区别在于一次只能放行全部，不能放行任意个数量的子线程继续运行。 我们可以将事件锁看为红绿灯，当红灯时所有子线程都暂停运行，并进入“等待”状态，当绿灯时所有子线程都恢复“运行”。 下面是threading模块与事件锁提供的相关方法： 方法 描述 threading.Event() 返回一个事件锁对象 lockObject.clear() 将事件锁设为红灯状态，即所有线程暂停运行 lockObject.is_set() 用来判断当前事件锁状态，红灯为False，绿灯为True lockObject.set() 将事件锁设为绿灯状态，即所有线程恢复运行 lockObject.wait(timeout=None) 将当前线程设置为“等待”状态，只有该线程接到“绿灯通知”或者超时时间到期之后才会继续运行，在“等待”状态下的线程将允许系统根据策略自行切换到其他线程中运行 使用方式 事件锁不能利用with语句来进行使用，只能按照常规方式。 如下所示，我们来模拟线程和红绿灯的操作，红灯停，绿灯行： import threading maxSubThreadNumber = 3 def task(): thName = threading.currentThread().name print(\"start and wait run thread : %s\" % thName) eventLock.wait() # 暂停运行，等待绿灯 print(\"green light, %s carry on run\" % thName) print(\"red light, %s stop run\" % thName) eventLock.wait() # 暂停运行，等待绿灯 print(\"green light, %s carry on run\" % thName) print(\"sub thread %s run end\" % thName) if __name__ == \"__main__\": eventLock = threading.Event() for i in range(maxSubThreadNumber): subThreadIns = threading.Thread(target=task) subThreadIns.start() eventLock.set() # 设置为绿灯 eventLock.clear() # 设置为红灯 eventLock.set() # 设置为绿灯 # start and wait run thread : Thread-1 # start and wait run thread : Thread-2 # start and wait run thread : Thread-3 # green light, Thread-1 carry on run # red light, Thread-1 stop run # green light, Thread-1 carry on run # sub thread Thread-1 run end # green light, Thread-3 carry on run # red light, Thread-3 stop run # green light, Thread-3 carry on run # sub thread Thread-3 run end # green light, Thread-2 carry on run # red light, Thread-2 stop run # green light, Thread-2 carry on run # sub thread Thread-2 run end Semaphore() 信号量锁 基本介绍 信号量锁也是根据条件锁来做的，它与条件锁和事件锁的区别如下： 条件锁：一次可以放行任意个处于“等待”状态的线程 事件锁：一次可以放行全部的处于“等待”状态的线程 信号量锁：通过规定，成批的放行特定个处于“上锁”状态的线程 下面是threading模块与信号量锁提供的相关方法： 方法 描述 threading.Semaphore() 返回一个信号量锁对象 lockObject.acquire(blocking=True, timeout=1) 上锁，当一个线程在执行被上锁代码块时，将不允许切换到其他线程运行，默认锁失效时间为1秒 lockObject.release() 解锁，当一个线程在执行未被上锁代码块时，将允许系统根据策略自行切换到其他线程中运行 使用方式 以下是使用示例，你可以将它当做一段限宽的路段，每次只能放行相同数量的线程： import threading import time maxSubThreadNumber = 6 def task(): thName = threading.currentThread().name semaLock.acquire() print(\"run sub thread %s\" % thName) time.sleep(3) semaLock.release() if __name__ == \"__main__\": # 每次只能放行2个 semaLock = threading.Semaphore(2) for i in range(maxSubThreadNumber): subThreadIns = threading.Thread(target=task) subThreadIns.start() # run sub thread Thread-1 # run sub thread Thread-2 # run sub thread Thread-3 # run sub thread Thread-4 # run sub thread Thread-6 # run sub thread Thread-5 with语句 由于threading.Semaphore()对象中实现了__enter__()与__exit__()方法，故我们可以使用with语句进行上下文管理形式的加锁解锁操作： import threading import time maxSubThreadNumber = 6 def task(): thName = threading.currentThread().name with semaLock: print(\"run sub thread %s\" % thName) time.sleep(3) if __name__ == \"__main__\": semaLock = threading.Semaphore(2) for i in range(maxSubThreadNumber): subThreadIns = threading.Thread(target=task) subThreadIns.start() 锁关系浅析 上面5种锁可以说都是基于同步锁来做的，这些你都可以从源码中找到答案。 首先来看RLock递归锁，递归锁的实现非常简单，它的内部会维护着一个计数器，当计数器不为0的时候该线程不能被I/O操作和时间轮询机制切换。但是当计数器为0的时候便不会如此了： def __init__(self): self._block = _allocate_lock() self._owner = None self._count = 0 # 计数器 而Condition条件锁的内部其实是有两把锁的，一把底层锁（同步锁）一把高级锁(递归锁)。 低层锁的解锁方式有两种，使用wait()方法会暂时解开底层锁同时加上一把高级锁，只有当接收到别的线程里的notfiy()后才会解开高级锁和重新上锁低层锁，也就是说条件锁底层是根据同步锁和递归锁的不断切换来进行实现的： def __init__(self, lock=None): if lock is None: lock = RLock() # 可以看到条件锁的内部是基于递归锁，而递归锁又是基于同步锁来做的 self._lock = lock self.acquire = lock.acquire self.release = lock.release try: self._release_save = lock._release_save except AttributeError: pass try: self._acquire_restore = lock._acquire_restore except AttributeError: pass try: self._is_owned = lock._is_owned except AttributeError: pass self._waiters = _deque() Event事件锁内部是基于条件锁来做的： class Event: def __init__(self): self._cond = Condition(Lock()) # 实例化出了一个条件锁。 self._flag = False def _reset_internal_locks(self): # private! called by Thread._reset_internal_locks by _after_fork() self._cond.__init__(Lock()) def is_set(self): \"\"\"Return true if and only if the internal flag is true.\"\"\" return self._flag isSet = is_set Semaphore信号量锁内部也是基于条件锁来做的： class Semaphore: def __init__(self, value=1): if value = 0\") self._cond = Condition(Lock()) # 可以看到，这里是实例化出了一个条件锁 self._value = value 基本练习题 条件锁的应用 需求：一个空列表，两个线程轮番往里面加值（一个加偶数，一个加奇数），最终让该列表中的值为 1 - 100 ，且是有序排列的。 import threading def even(): \"\"\"加偶数\"\"\" with condLock: # 必须先启动加奇数 condLock.wait() for i in range(2, 101, 2): lst.append(i) condLock.notify() condLock.wait() def odd(): \"\"\"加奇数\"\"\" with condLock: for i in range(1, 101, 2): lst.append(i) condLock.notify() condLock.wait() condLock.notify() if __name__ == \"__main__\": lst = [] condLock = threading.Condition() addEvenTask = threading.Thread(target=even) addOddTask = threading.Thread(target=odd) addEvenTask.start() addOddTask.start() addEvenTask.join() addOddTask.join() print(lst) 事件锁的应用 有2个任务线程来扮演李白和杜甫，如何让他们一人一句进行对答？文本如下： 杜甫：老李啊，来喝酒！ 李白：老杜啊，不喝了我喝不下了！ 杜甫：老李啊，再来一壶？ 杜甫：...老李？ 李白：呼呼呼...睡着了.. 代码如下： import threading def libai(): event.wait() print(\"李白：老杜啊，不喝了我喝不下了！\") event.set() event.clear() event.wait() print(\"李白：呼呼呼...睡着了..\") def dufu(): print(\"杜甫：老李啊，来喝酒！\") event.set() event.clear() event.wait() print(\"杜甫：老李啊，再来一壶？\") print(\"杜甫：...老李？\") event.set() if __name__ == '__main__': event = threading.Event() t1 = threading.Thread(target=libai) t2 = threading.Thread(target=dufu) t1.start() t2.start() t1.join() t2.join() Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:46 "},"Python/Python并发编程/threading.local功能介绍.html":{"url":"Python/Python并发编程/threading.local功能介绍.html","title":"threading.local功能介绍","keywords":"","body":"threading.local() threading.local()方法可以让每个线程都拥有一些自己独立的数据，这些数据是其他线程访问不到的。 如图所示： 或者用另外一种更形象的比喻更加的贴切，将一个进程比喻成一个公司，该进程下的线程比喻成公司的员工，而将threading.local()比喻为公司的储物柜，每个员工都有一个单独的柜格，且每个员工也只能访问自己的柜格。 如图所示： 那么这个东西到底有什么作用？举个例子，当你使用迅雷进行多线程下载时，每个线程的下载进度是不一样的，那么这个下载进度如何进行存储就显得尤为重要。 数据的存储一定是方便数据的取出，存储结构做的好，查找取出数据的速度才会更快。 threading.local()的设计思想其实在flask框架的上下文管理机制中也会体现到，两者基本如出一辙，所以现在了解threading.local()的原理后对flask框架的源码阅读也会变得轻松。 基本使用 下面是基本使用，使用步骤如下： 储物柜 = threading.local() 在线程下使用 储物柜.物品名称 = 物品 即可，以后对于该物品只有该线程可以获取 获取或者使用时，直接使用 储物柜.物品名称 即可，若要获取的物品不是该线程存放的，则会抛出异常 示例案例： import threading def jack(article): locker.rose = article print(locker.rose) # 正常取出 print(locker.food) # 抛出异常 def ken(article): locker.food = article print(locker.food) # 正常取出 print(locker.rose) # 抛出异常 if __name__ == \"__main__\": locker = threading.local() jackTask = threading.Thread(target=jack, args=(\"rose\",)) kenTask = threading.Thread(target=ken, args=(\"food\",)) jackTask.start() kenTask.start() # rose # AttributeError: '_thread._local' object has no attribute 'food' # food # AttributeError: '_thread._local' object has no attribute 'rose' 原理分析 我们可以自己做一个全局字典，来实现类似的功能，字典格式如下： locker = { \"线程ID\" : {\"物品名称\" : \"物品本身\"}, \"线程ID\" : {\"物品名称\" : \"物品本身\"}, \"线程ID\" : {\"物品名称\" : \"物品本身\"}, } 如下所示： import threading def task(article): thId = threading.get_ident() # 开始存放东西 locker[thId] = { \"rose\": article } # 取出东西 print(locker[thId][\"rose\"]) if __name__ == \"__main__\": locker = {} subThreadIns = threading.Thread(target=task, args=(\"rose\",)) subThreadIns.start() # rose 代码优化 上面这样存取东西是不是显得特别麻烦？所以我们可以定义一个类，让这个储物柜的操作变的更加简单。 如下所示： import threading class Locker: locker = {} def __getattr__(self, name): \"\"\"当试图使用.访问对象属性且找不到该属性时触发该方法\"\"\" ident = threading.get_ident() return __class__.locker[ident][name] def __setattr__(self, name, value): \"\"\"当试图使用.修改或添加对象属性时触发该方法\"\"\" ident = threading.get_ident() if ident not in __class__.locker: __class__.locker[ident] = {} __class__.locker[ident].update({name: value}) def task(article): # 开始存放东西 locker.rose = article print(locker.rose) if __name__ == \"__main__\": locker = Locker() subThreadIns = threading.Thread(target=task, args=(\"rose\",)) subThreadIns.start() # rose Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:46 "},"Python/Python并发编程/multiprocessing模块使用.html":{"url":"Python/Python并发编程/multiprocessing模块使用.html","title":"multiprocessing模块使用","keywords":"","body":"multiprocessing模块 Python中提供了multiprocessing模块来实现进程并发编程，官方文档如下： 官方文档 由于GIL锁的存在，所以CPython中多线程是不能够并行运行的，但是多进程可以并行运行，该模块用到的地方基本很少，但是仍然需要进行掌握。 此外，它和threading模块99%的接口都一模一样，只有少量的差别。 添加子进程 针对不同平台选择添加子进程的方式 multiprocessing模块针对不同的平台，添加子进程的方式也有所区别： spawn：该方式是Windows平台下的默认方式，它会创建一个新的解释器进程，速度比较慢 fork：该方式是Unix平台下的默认方式，内部会通过os.fork()产生一个新的解释器分叉 需要注意的是，如果平台是Windows，则必须将启动代码书写到if __name__ == \"__main__”语句的下面，否则将会抛出异常。 如何指定新进程的启动方式？示例如下： import multiprocessing if __name__ == \"__main__\": multiprocessing.set_start_method(\"fork\") 实例化Process类 使用该方式新增子线程任务是比较常见的，也是推荐使用的。 简单的代码示例如下，创建3个子进程并向其添加任务，然后运行并打印它们的PID和进程名字： import multiprocessing import time def task(params): print(\"sub process run\") currentThread = multiprocessing.current_process() time.sleep(3) print(\"current subProcess id : %s\\ncurrent sub process name : %s\\ncurrent sub process params : %s\" % ( currentThread.ident, currentThread.name, params)) if __name__ == \"__main__\": print(\"main Process run\") for item in range(3): subProcessIns = multiprocessing.Process(target=task, args=(item, )) subProcessIns.start() print(\"main Process run end\") # main Process run # main Process run end # sub process run # current subProcess id : 7761 # current sub process name : Process-1 # current sub process params : 0 # sub process run # current subProcess id : 7762 # current sub process name : Process-2 # current sub process params : 1 # sub process run # current subProcess id : 7763 # current sub process name : Process-3 # current sub process params : 2 自定义类覆写run()方法 上面的子进程任务对象是一个全局函数，我们也可以将它作为方法来进行调用。 书写一个类并继承Process类，覆写run()方法即可： import multiprocessing import time class TaskClass(multiprocessing.Process): def __init__(self, params): self.params = params super(__class__, self).__init__() def run(self): print(\"sub process run\") currentProcess = multiprocessing.current_process() time.sleep(3) print(\"current sub process id : %s\\ncurrent sub process name : %s\\ncurrent sub process params : %s\" % ( currentProcess.ident, currentProcess.name, self.params)) if __name__ == \"__main__\": print(\"main process run\") for item in range(3): subThreadIns = TaskClass(item) subThreadIns.start() print(\"main process run end\") # main process run # main process run end # sub process run # current sub process id : 7800 # current sub process name : TaskClass-1 # current sub process params : 0 # sub process run # current sub process id : 7801 # current sub process name : TaskClass-2 # current sub process params : 1 # sub process run # current sub process id : 7802 # current sub process name : TaskClass-3 # current sub process params : 2 multiprocessing模块方法大全 以下是multiprocessing模块提供的类或方法： 类或方法 描述 返回值 multiprocessing.Process(target, args, kwargs) 创建并返回一个进程对象 processObject multiprocessing.active_children() 查看当前进程下的所有子进程对象，以列表形式返回 [processObject, ...] multiprocessing.current_process() 获取当前的进程对象 processObject 以下是好伙伴os模块所提供的2个方法： 方法 描述 返回值 os.getpid() 返回当前进程pid int os.getppid() 返回当前进程的父进程的pid int processObject方法大全 以下是针对进程对象提供的属性或者方法： 方法/属性 描述 返回值 processObject.start() 通知系统该进程调度完毕，可以随时进行启动，一个进程对象只能运行一次该方法，若多次运行则抛出RunTimeError异常 ... processObject.join(timeout=None) 主进程默认会等待子进程运行结束后再继续执行，timeou为等待的秒数，如不设置该参数则一直等待。 ... processObject.close() 关闭进程 ... processObject.terminate() 终止进程 ... processObject.kill() 终止进程 ... processObject.is_alive() 查看进程对象是否存活 bool processObject.ident 获取进程对象的编号 int processObject.pid 获取进程对象的编号 processObject.name 获取或者设置进程对象的名字 str or None processObject.daemon 查看进程对象是守护进程 bool processObject.exitcode 子进程的退出代码。如果进程尚未终止，这将是None。负值 -N 表示子进程被信号 N 终止 int processObject.authkey 获取进程的身份验证密码 bytes 守护进程示例 multiprocessing模块的守护进程和threading的守护线程设置有所不同。 它是通过赋值来进行设置的，如下所示： import multiprocessing import time class TaskClass(multiprocessing.Process): def run(self): pName = multiprocessing.current_process().name print(\"%s start run\" % pName) time.sleep(3) print(\"%s run end\" % pName) if __name__ == \"__main__\": print(\"main process start run\") processLst = [] for i in range(3): processLst.append(TaskClass()) for ins in processLst: # 注意，守护进程的设置必须在进程未启动时设置 ins.daemon = True ins.start() print(\"main process carry on run\") print(\"main process run end\") # main process start run # TaskClass-1 start run # main process carry on run # main process run end multiprocessing与threading模块异同 　　1.创建子进程的方式针对不同平台有着差异化 　　2.关于守护线程的设置接口是setDaemon(True)，而关于守护进程的接口是deamon = True 　　3.multiprocessing模块下的获取进程名与设置进程名没有threading模块下的getName()和setName()，而是直接采取属性name进行操作 锁的使用 multiprocessing模块中锁的接口和使用与threading中锁的接口和使用一致。 所以这里仅介绍一个lock锁即可： import multiprocessing num = 0 def add(): lock.acquire() global num for i in range(10_000_000): num += 1 lock.release() def sub(): lock.acquire() global num for i in range(10_000_000): num -= 1 lock.release() if __name__ == \"__main__\": lock = multiprocessing.Lock() subProcess01 = multiprocessing.Process(target=add) subProcess02 = multiprocessing.Process(target=sub) subProcess01.start() subProcess02.start() subProcess01.join() subProcess02.join() print(\"num result : %s\" % num) # 结果三次采集 # num result : 0 # num result : 0 # num result : 0 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:46 "},"Python/Python并发编程/线程或进程通信.html":{"url":"Python/Python并发编程/线程或进程通信.html","title":"线程或进程通信","keywords":"","body":"线程或进程通信 在同一个进程中，该进程下的所有数据资源都会被该进程下的线程共享。 为了保证数据安全性，我们在多个线程进行数据交互时必须使用一种线程安全的容器来承载交互信息。 如，常见的Redis数据库、MQ等消息中间件是非常好的选择。 当然，多进程也是如此。 但是在实际的测试环境中，我们需要更加方便的一些工具来测试代码是否准确，这时候就会用到下面介绍的工具了。 多线程通信 queue queue模块对于多线程通信来讲是十分明智的选择，它使用简单开箱即用，最关键的一点是它是Python的内置模块，故不用经历任何额外的下载、安装过程。 官方文档 queue本身是线程安全的，它其实就是管道 + 锁的组合，它提供了3种队列供用户使用： queue.Queue：先进先出队列 queue.LifoQueue：后进先出队列 quque.PriorityQueue：优先级队列 以下是queue模块各个队列中提供的常见方法： 方法 描述 Queue.qsize() 返回当前队列的大小 Queue.empty() 判断当前队列是否为空 Queue.full() 判断当前队列是否已满 Queue.put(item, block=True, timeout=None) 将item放入队列中，如果block为True，则队列已满时进行阻塞，timeout为阻塞超时时间，超过该时间后抛出Full的异常 Queue.put_nowait(item) 相当于Queue.put(item, block=False, timeout=None)，将item放入队列时一旦队列已满就立即抛出Full的异常 Queue.get(block=True, timeout=None) 从队列中取出项目，如果block为True，则队列为空时进行阻塞，timeout为阻塞超时时间，超过该时间后抛出Empty的异常 Queue.get_nowait() 相当于Queue.get(block=False, timeout=None)，从队列中取出项目时一旦队列为空就立即抛出Empty的异常 Queue.join() 阻塞队列，此时队列中不可取出任何数据 Queue.task_done() 通知取消阻塞队列，此时队列中可取出数据 先进先出队列 以下是先进先出队列的简单使用： import queue q = queue.Queue() # 可指定maxsize参数，定义当前队列的容量 q.put(1) q.put(2) q.put(3) print(q.get()) print(q.get()) print(q.get()) # 1 # 2 # 3 后进先出队列 以下是后进先出队列的简单使用： import queue q = queue.LifoQueue() # 可指定maxsize参数，定义当前队列的容量 q.put(1) q.put(2) q.put(3) print(q.get()) print(q.get()) print(q.get()) # 3 # 2 # 1 优先级队列 以下是优先级队列的简单使用，出队时优先级较小的先出队： import queue q = queue.PriorityQueue() # 可指定maxsize参数，定义当前队列的容量 q.put([10, \"A\"]) # [优先级, 数据项] q.put([50, \"B\"]) q.put([30, \"C\"]) print(q.get()) print(q.get()) print(q.get()) # [10, 'A'] # [30, 'C'] # [50, 'B'] 队列阻塞 下面是队列阻塞方法Queue.join()和Queue.task_done()的示例： import threading import queue def putTask(article): name = \"Ken\" # 放入玫瑰 q.put(article) print(\"%s put %s\" % (name, article)) # 通知对面可以取了 q.task_done() def getTask(): name = \"Jack\" # 如果先启动该线程，则会阻塞进行等待对吗的task_done()进行通知 q.join() # 取出玫瑰 print(\"%s get %s\" % (name, q.get())) if __name__ == \"__main__\": q = queue.Queue() gT = threading.Thread(target=getTask) pT = threading.Thread(target=putTask, args=(\"rose\", )) gT.start() pT.start() # Ken put rose # Jack get rose 内部原理图示 由于多线程都在一个进程中，故queue这个队列是共享的，任意该进程下的线程都能自由的对其进行数据项的读取。 如下图所示： 多进程通信 multiprocessing.Queue 多进程通信时不可使用普通的queue模块所提供的队列，而必须多进程模块multiprocessing所提供的Queue。 这个进程队列是没有提供task_done()方法与join()方法的，如果你想使用这2个方法，则可以导入multiprocessing.JoinableQueue这个队列。 以下是multiprocessing.Queue()所提供的方法： 方法 描述 Queue.qsize() 返回当前队列的大小 Queue.empty() 判断当前队列是否为空 Queue.full() 判断当前队列是否已满 Queue.put(item, block=True, timeout=None) 将item放入队列中，如果block为True，则队列已满时进行阻塞，timeout为阻塞超时时间，超过该时间后抛出Full的异常 Queue.put_nowait(item) 相当于Queue.put(item, block=False, timeout=None)，将item放入队列时一旦队列已满就立即抛出Full的异常 Queue.get(block=True, timeout=None) 从队列中取出项目，如果block为True，则队列为空时进行阻塞，timeout为阻塞超时时间，超过该时间后抛出Empty的异常 Queue.get_nowait() 相当于Queue.get(block=False, timeout=None)，从队列中取出项目时一旦队列为空就立即抛出Empty的异常 Queue.close() 关闭队列，该队列将变得不可put() Queue.join_thread() 等待后台线程。这个方法仅在调用了 close()方法之后可用。这会阻塞当前进程，直到后台线程退出，确保所有缓冲区中的数据都被写入管道中 Queue.cancel_join_thread() 防止 join_thread() 方法阻塞当前进程。具体而言，这防止进程退出时自动等待后台线程退出。详见 join_thread() 方法 个人还是推荐使用multiprocessing.JoinableQueue这个队列，因为它比multiprocessing.Queue强大一点。 需要注意的是，不管是multiprocessing.Queue还是multiprocessing.JoinableQueue，它们都是先进先出队列。 队列阻塞 以下是使用multiprocessing.JoinableQueue实现的队列阻塞： import multiprocessing import queue def putTask(article): name = \"Ken\" # 放入玫瑰 q.put(article) print(\"%s put %s\" % (name, article)) # 通知对面可以取了 q.task_done() def getTask(): name = \"Jack\" # 如果先启动该线程，则会阻塞进行等待对吗的task_done()进行通知 q.join() # 取出玫瑰 print(\"%s get %s\" % (name, q.get())) if __name__ == \"__main__\": q = multiprocessing.JoinableQueue() gT = multiprocessing.Process(target=getTask) pT = multiprocessing.Process(target=putTask, args=(\"rose\", )) gT.start() pT.start() # Ken put rose # Jack get rose 内部原理 为什么线程队列queue.Queue不能做到进程间数据共享呢？ 这是因为进程队列multiprocessing.Queue会采取一种映射的方式来同步数据，所以说进程队列的资源消耗比线程队列要庞大很多。 由于一个进程下的所有线程中的信息是共享的，所以线程队列根本不需要映射关系。 进程队列只是告诉你可以这样使用它达到进程间的数据共享，但是并不推荐你滥用它。 multiprocessing.Pipe 除开使用进程队列来实现进程间的通信，multiprocessing还提供了Pipe管道来进行通信。 他的资源消耗较少并且使用便捷，但是唯一的缺点便是只支持点对点。 Pipe有点类似socket通信。但是比socket通信更加简单，它不需要将字符串转换成字节后再进行发送，先来看一个实例： import multiprocessing from multiprocessing.connection import Pipe def putTask(article): name = \"Ken\" # 发送玫瑰 conn1.send(article) print(\"%s send %s\" % (name, article)) def getTask(): name = \"Jack\" # 接收玫瑰 article = conn2.recv() print(\"%s receive %s\" % (name, article)) if __name__ == \"__main__\": conn1, conn2 = multiprocessing.Pipe() # 实例化2个电话 gT = multiprocessing.Process(target=getTask) pT = multiprocessing.Process(target=putTask, args=(\"rose\", )) gT.start() pT.start() # Ken send rose # Jack receive rose Pipe()会去创建一个双向链接通道，如下所示： multiprocessing.Manager 除了进程队列multiprocessing.Queue，管道Pipe之外，multiprocessing还提供了Manager作为共享变量来提供多进程数据交互。 但是这种方式是不应该被直接使用的，因为它相较于进程队列Queue是数据不安全的。当多个进程同时修改一个共享变量势必导致结果出现问题，所以要想使用共享变量还得使用multiprocessin提供的进程锁才行。 Manager类是数据不安全的 Mangaer类支持的类型非常多，如：value, Array, List, Dict, Queue(进程池通信专用)，Lock等。 Mangaer实现了上下文管理器，可使用with语句创建多个对象 下面这个例子是使用multiprocessing.Manager来实现进程数据共享： import multiprocessing from multiprocessing import Manager def task_1(): dic[\"task_1\"] = \"A\" def task_2(): dic[\"task_2\"] = \"B\" if __name__ == \"__main__\": with Manager() as m: dic = m.dict() subProcessIns01 = multiprocessing.Process(target=task_1) subProcessIns02 = multiprocessing.Process(target=task_2) subProcessIns01.start() subProcessIns02.start() subProcessIns01.join() subProcessIns02.join() print(dic) # {'task_1': 'A', 'task_2': 'B'} 可以看见使用multiprocessing.Manager所提供的数据类用来数据交互展示很方便，但是要操纵数据则需要考虑数据安全问题： import multiprocessing from multiprocessing import Manager def task_1(): for i in range(1000): dic[\"number\"] -= 1 def task_2(): for i in range(1000): dic[\"number\"] += 1 if __name__ == \"__main__\": with Manager() as m: dic = m.dict() dic[\"number\"] = 0 subProcessIns01 = multiprocessing.Process(target=task_1) subProcessIns02 = multiprocessing.Process(target=task_2) subProcessIns01.start() subProcessIns02.start() subProcessIns01.join() subProcessIns02.join() print(dic) # 结果三次采集 # {'number': -13} # {'number': 5} # {'number': 8} 我们可以使用进程锁，来保证数据一致性： import multiprocessing from multiprocessing import Manager def task_1(): with lock: for i in range(1000): dic[\"number\"] -= 1 def task_2(): with lock: for i in range(1000): dic[\"number\"] += 1 if __name__ == \"__main__\": lock = multiprocessing.RLock() with Manager() as m: dic = m.dict() dic[\"number\"] = 0 subProcessIns01 = multiprocessing.Process(target=task_1) subProcessIns02 = multiprocessing.Process(target=task_2) subProcessIns01.start() subProcessIns02.start() subProcessIns01.join() subProcessIns02.join() print(dic) # 结果三次采集 # {'number': 0} # {'number': 0} # {'number': 0} Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:46 "},"Python/Python并发编程/生产者消费者模型.html":{"url":"Python/Python并发编程/生产者消费者模型.html","title":"生产者消费者模型","keywords":"","body":"生产者消费者模型 生产者消费者模型是一种设计思想，生产者生产出产品，消费者对产品进行消费。 但是他们之间不直接进行接触，而是通过中间件进行产品交易，这样做的好处是降低生产者与消费者之间的耦合度，使他们没有强制的关联。 如下图所示，当生产者生产出产品后会将产品放入中间件中，消费者监听中间件当中间件状态一旦发生变化后就立即获取出产品并消费： 多线程实现 下面将采用多线程实现生产者与消费者模型，需要借助queue.Queue()作为中间件： import threading import queue import time def producer(): thName = threading.current_thread().name product = 0 while 1: time.sleep(3) q.put(product) print(\"%s create %s\" % (thName, product)) product += 1 def consumer(): thName = threading.current_thread().name while 1: product = q.get() print(\"%s get %s\" % (thName, product)) if __name__ == \"__main__\": q = queue.Queue(maxsize=5) producerSubThread = threading.Thread(target=producer, name=\"producer\") producerSubThread.start() for i in range(3): consumerSubThread = threading.Thread( target=consumer, name=\"consumer - %s\" % i) consumerSubThread.start() 首先生产者会每隔3s生产出一个产品，然后将产品放入q队列中，消费者们会不断的从q队列中取出产品。 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:46 "},"Python/Python并发编程/使用执行器提交任务.html":{"url":"Python/Python并发编程/使用执行器提交任务.html","title":"使用执行器提交任务","keywords":"","body":"concurrent.futures 我们在以往创建线程或进程的时候都会使用threading与multiprocessing模块进行创建。 那么在本章节学习完成后就不要使用这两种方式创建线程或者进程了，而是应当使用concurrent.futures所提供的执行器来构建线程或进程并执行任务。 concurrent.futures提供了2种执行器，如下所示，它们的接口使用也都一模一样： from concurrent.futures import ThreadPoolExecutor # 线程池执行器 from concurrent.futures import ProcessPoolExecutor # 进程池执行器 注意，在Python2中是没有线程池执行器的。 官方文档 使用执行器和不使用执行器创建线程或进程两者2有什么不同呢？如下表所示： 普通线程 执行器 创建线程 惰性创建，需要执行任务时再创建线程 及早创建，在初始化执行器时就会创建一堆线程 提交任务 同步的提交任务，获取结果时需要等待，完成任务的线程会立即销毁 异步的提交任务，获取结果时将采用回调机制，完成任务的线程会立即返回至执行器中 销毁线程 任务完成后立即销毁线程 删除执行器或解释器析构时销毁线程 我们可以从这张图中看出2者的差距： 线程的创建和销毁是需要额外占据系统资源的，所以使用线程池执行器来管理线程性能上也会得到一定的提升。 执行器对象 方法大全 下面是执行器所提供的方法，用于创建子线程以及给子线程派发并执行任务： 方法 描述 ThreadPoolExecutor(max_workers=int) 返回一个线程池执行器对象，可指定该池中工作线程的最大数量 submit(fn, *args, **kwargs) 异步提交任务fn并派发给线程池执行器中的线程进行任务执行，返回期程对象 map(fn, *iterables, timeout=None, chunksize=1) 类似于内置函数map，它将map中fn的任务提交变更为异步的 shutdown(wait=True) 等待，类似于join()方法。在所有任务完成后关闭线程池执行器 基本使用 下面将创建一个包含5个线程的线程池执行器，然后给这5个线程分配10个任务并执行： from concurrent.futures import ThreadPoolExecutor import threading import time def task(): thName = threading.current_thread().name time.sleep(0.2) print(thName) if __name__ == \"__main__\": executor = ThreadPoolExecutor(max_workers=5) for i in range(10): executor.submit(task) # ThreadPoolExecutor-0_0 # ThreadPoolExecutor-0_1 # ThreadPoolExecutor-0_2 # ThreadPoolExecutor-0_3 # ThreadPoolExecutor-0_4 # ThreadPoolExecutor-0_1 # ThreadPoolExecutor-0_2 # ThreadPoolExecutor-0_0 # ThreadPoolExecutor-0_4 # ThreadPoolExecutor-0_3 with语句 我们也可以使用with语句来初始化线程池执行器： from concurrent.futures import ThreadPoolExecutor import threading import time def task(): thName = threading.current_thread().name time.sleep(0.2) print(thName) if __name__ == \"__main__\": with ThreadPoolExecutor(5) as executor: for i in range(10): executor.submit(task) map() 如果要多次调用同一个任务，而传入的参数不同时可使用map()函数。 如下所示，模拟爬取3个不同的网站： from concurrent.futures import ThreadPoolExecutor import threading import time def task(url): thName = threading.current_thread().name time.sleep(0.2) print(\"%s get %s\" % (thName, url)) if __name__ == \"__main__\": urlLst = [\"http://www.google.com\", \"http://www.baidu.com\", \"http://www.biying.com\"] with ThreadPoolExecutor(5) as executor: executor.map(task, urlLst) # ThreadPoolExecutor-0_0 get http://www.google.com # ThreadPoolExecutor-0_1 get http://www.baidu.com # ThreadPoolExecutor-0_2 get http://www.biying.com 期程对象 方法大全 当执行器的线程、进程任务执行完毕后，会返回一个期程对象（也被称为未来对象）。 下面是期程对象所提供的方法： 方法 描述 result(timeout=None) 从期程对象中获取任务执行结果，可设置超时时间timeout，若不设置该时间则一直等待，也就是说该方法是一个同步阻塞的获取执行结果的方法，若超时则引发cancelledError异常 add_done_callback(fn) 为期程对象添加回调函数，用于异步非阻塞的获取任务执行结果，fn为一个函数，该函数的形参会接受已完成任务的期程对象 exception(timeout=None) 返回由调用引发的异常。如果调用还没完成那么这个方法将等待 timeout 秒。如果在 timeout 秒内没有执行完成，concurrent.futures.TimeoutError将会被触发。timeout 可以是整数或浮点数。如果 timeout 没有指定或为 None，那么等待时间就没有限制。 cancel() 尝试取消任务的调用，如果当前任务正在执行或已经执行完毕则不能取消。若成功取消返回True，若取消失败则返回False cancelled() 如果调用成功则取消并返回True running() 如果调用正在执行而且不能被取消那么返回True done() 如果调用已被取消或正常结束那么返回True 期程对象 executor.submit()的返回结果是一个期程对象： from concurrent.futures import ThreadPoolExecutor import time def task(): time.sleep(0.2) if __name__ == \"__main__\": with ThreadPoolExecutor(1) as executor: for i in range(3): futureObject = executor.submit(task) print(futureObject) # # # 上面这个例子中执行器中包含1个线程，但是却要执行3个任务，所以你会发现它们的状态并不相同。 期程对象拥有5个状态，它们表示未来将可能出现的任务执行状态： _FUTURE_STATES = [ PENDING, # 等待执行任务 RUNNING, # 正在执行任务 CANCELLED, # 被取消 CANCELLED_AND_NOTIFIED, # 被取消 FINISHED # 已完成 ] 同步的获取结果 使用futureObject.result()可同步的获得任务的返回结果： from concurrent.futures import ThreadPoolExecutor import threading import time def task(params): taskIndex = params - 64 print(\"start carried out task, this is %s task\" % taskIndex) time.sleep(3) return \"task %s carried out end, result : %s\" % (taskIndex, chr(params)) if __name__ == \"__main__\": with ThreadPoolExecutor(5) as executor: for i in range(65, 91): futureObject = executor.submit(task, i) print(futureObject.result()) # start carried out task, this is 1 task # task 1 carried out end, result : A # start carried out task, this is 2 task # task 2 carried out end, result : B # start carried out task, this is 3 task # task 3 carried out end, result : C # start carried out task, this is 4 task # task 4 carried out end, result : D # start carried out task, this is 5 task # task 5 carried out end, result : E # ... 这将会引发主线程的阻塞，因为result()方法必须等待任务执行完毕后才能获取到结果，所以不应该这么使用。 异步的获取结果 由于executor.submit()的任务提交是异步提交，故我们应当采取绑定回调函数的策略来获得任务执行结果，而不是使用直接result()方法。 绑定回调函数并不会引起主线程的阻塞，一旦某个任务完成后便会立即触发回调函数的执行，并将期程对象传入该回调函数中。 因为此时的期程对象状态一定是FINISHED，所以使用result()方法便不会等待了。 如下所示，异步的获取结果，你可以看见它的打印结果和上面的例子是完全不同的： from concurrent.futures import ThreadPoolExecutor import threading import time def task(params): taskIndex = params - 64 print(\"start carried out task, this is %s task\" % taskIndex) time.sleep(3) return \"task %s carried out end, result : %s\" % (taskIndex, chr(params)) def callback(futureObject): print(futureObject.result()) if __name__ == \"__main__\": with ThreadPoolExecutor(5) as executor: for i in range(65, 91): futureObject = executor.submit(task, i) futureObject.add_done_callback(callback) # start carried out task, this is 1 task # start carried out task, this is 2 task # start carried out task, this is 3 task # start carried out task, this is 4 task # start carried out task, this is 5 task # task 1 carried out end, result : A # start carried out task, this is 6 task # task 2 carried out end, result : B # start carried out task, this is 7 task # task 4 carried out end, result : D # start carried out task, this is 8 task # task 5 carried out end, result : E # start carried out task, this is 9 task # task 3 carried out end, result : C # start carried out task, this is 10 task # ... 进程池执行器的进程通信 当我们使用进程池执行器启动多进程执行任务时，如果想用数据共享，单纯multiprocessing.Queue进程队列并不支持。 import multiprocessing from concurrent.futures import ProcessPoolExecutor # 进程池执行器 def task_1(q): q.put(\"玫瑰花\") print(\"放完了...\") def task_2(q): print(q.get()) print(\"取到了\") if __name__ == '__main__': q = multiprocessing.Queue() with ProcessPoolExecutor(max_workers=2) as pool: pool.submit(task_1,q) pool.submit(task_2,q) # 会阻塞住 这个时候我们需要用到multiprocessing中的Manager()中的Queue。只有它支持进程池的进程数据共享： from multiprocessing import Manager from concurrent.futures import ProcessPoolExecutor # 进程池执行器 def task_1(q): q.put(\"玫瑰花\") print(\"放完了...\") def task_2(q): print(q.get()) print(\"取到了\") if __name__ == '__main__': q = Manager().Queue() with ProcessPoolExecutor(max_workers=2) as pool: pool.submit(task_1,q) pool.submit(task_2,q) # 放完了... # 玫瑰花 # 取到了 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:46 "},"Python/Python并发编程/Linux五大IO模型.html":{"url":"Python/Python并发编程/Linux五大IO模型.html","title":"Linux五大I/O模型","keywords":"","body":"基础知识 I/O分类 常见的I/O主要分为以下几类，如下所示： 阻塞I/O（blocking I/O） 非阻塞I/O（non-blocking I/O） 同步I/O（sync I/O） 异步I/O（async I/O） 同步：调用端会一直等待服务端响应，直到返回结果 异步：调用端发起调用之后不会等待服务端响应。服务端通过某种通知机制或者回调函数来通知客户端 阻塞：服务端返回结果之前，客户端线程会被挂起，此时线程不可被CPU调度，线程暂停运行 非阻塞：在服务端返回前，函数不会阻塞调用端线程，而会立刻返回 用户态与内核态 用户态（User model）和内核态（Kernel model）是CPU的2种工作状态。 内核态下运行的必然是操作系统相关的代码，它允许直接操作硬件。 而用户态下运行的必然是应用程序相关的代码，用户态下不可以直接操纵底层硬件。 它必须通过操作系统调用才能间接的使用底层硬件，而应用程序的运行必然是要操纵底层硬件的，所以就必须让CPU不断的做2种状态的切换才行。 需要注意的是，核心态和内核态中所产生的数据是不允许直接交互的，而是只能通过一种映射的方式进行数据交互，可以理解为copy。 在CPU中有一个名叫psw的寄存器就是区分内核态和用户态的，它有2个状态位，当CPU指令集是0的时候对应到内核态，也就获取了所有的内存权限。 当指令集是1的时候对应到用户态，保留一部分内存不让访问。所以说真正的内存是不可划分的，都只是一个状态不同的问题。 当应用层面的程序被CPU执行时，那么可以肯定的是它的状态必定是1，限制了一些调度硬件的权限。 文件描述符 文件描述符简称为fd，全称为file descriptor。 Linux系统一切皆文件，因此文件描述符通常是用于描述指向文件的引用的抽象化概念。文件描述符在形式上是一个非负整数。实际上，它是一个索引值，指向内核为每一个进程所维护的该进程打开文件的记录表。 当程序打开一个现有文件或者创建一个新文件时，内核都会向进程返回一个文件描述符。 在程序设计中，一些涉及底层的程序编写往往会围绕着文件描述符展开。但是文件描述符这一概念往往只适用于Linux这样的操作系统。 缓存I/O 缓存I/O又被称作标准I/O，大多数文件系统的默认I/O操作都是缓存IO。 在Linux的缓存I/O机制中，操作系统会将 I/O的数据缓存在文件系统的页缓存（ page cache ）中，也就是说，数据会先被拷贝到操作系统内核的缓冲区中，然后才会从操作系统内核的缓冲区拷贝到应用程序的地址空间。 缓存I/O的缺点： 数据在传输过程中需要在应用程序地址空间和内核进行多次数据拷贝操作，这些数据拷贝操作所带来的 CPU 以及内存开销是非常大的。 其实缓存I/O出现的原因还是用户态和内核态的内存不允许直接进行数据交互而产生的，必须拥有这样一个缓存机制。 event loop event loop中文释义为事件循环，是一种常见的编程范式，常用于前端领域。 它是一种非线性的驱动模式，举个例子： 任何的UI编程都是基于事件循环的驱动模型来完成的，当我们的鼠标放在任何一段文字之上，它会根据文字不同而做出对应的不同反应。 并且，我们进入一个网页不仅仅可以用鼠标与网页产生交互，也可以使用键盘与网页产生交互，那么这里就会有很多很多种不同的选择，如果想尝试用传统的编程思想来解决识别用户的操作无疑效率是非常低下的。 传统编程思想解决方案： 死循环来不断的检测是否有鼠标点击，键盘按下，鼠标悬浮等等操作 通过阻塞的方式来等待用户的一次点击或者键盘按下或者鼠标悬浮的等等操作 这种解决方案看似十分完美，但是拥有很大的缺点： 死循环占用大量CPU资源，并且如果需要检测的事件太多势必会引发延迟问题 通过阻塞方式只能检测一种操作，并不能同时检测多种操作 为了解决这些缺点，故诞生了event loop，它的设计思路如下： 有一个事件(消息)队列，包括但不仅限于鼠标事件，键盘事件，悬浮事件等等 假设当鼠标按下，便往这个队列中增加一个点击事件(消息) 有一个循环，不断的从队列中取出事件，根据不同的事件调用不同的函数 事件（消息）一般都各自保存各自的处理函数指针，这样每个消息都有独立的处理函数 图解如下： 包含一个事件循环并且只有当外部事件发生时才使用回调机制来触发相应的处理。 也就是说程序运行的整个流程都是取决于用户触发的各种事件来决定的，开发者并不用关心大体流程，而只是需要做好每一个事件对应的处理方式即可。 Linux五大I/O模型 阻塞I/O模型 发起I/O系统调用后，进程会被阻塞，直至出现响应数据。 当响应数据出现后，系统会转到内核空间进行处理，将内核缓冲区的数据映射（或被称为拷贝）至应用程序中。 举例说明： 一个人去食堂买饭，他问了食堂大妈还有没有饭后就站在窗口原地的等，此时这个人什么也做不了。 非阻塞I/O模型 发起I/O系统调用后，进程不会阻塞，而是通过死循环不断的查看是否出现响应数据，如果响应数据未出现时就进行拷贝，则会引起异常。 当响应数据出现后，系统会转到内核空间进行处理，将内核缓冲区的数据映射（或被称为拷贝）至应用程序中。 举例说明： 一个人要去食堂买饭，他会先问食堂大妈有没有饭，食堂大妈说没有饭这个人就走开了，过一会又会过来问食堂大妈有没有饭，直至食堂大妈说饭好了后他才端上饭满意的离开。 I/O复用模型 I/O复用模型与事件驱动模型相似，它会先将I/O事件以及回调函数进行注册，然后再进行循环监听，一旦文件描述符状态发生改变后就会触发回调函数。 我们可以注册多个文件描述符，来达到同时监听多个I/O的目的，相较于前两种I/O模型，它拥有了监听机制，而正是因为有了这个机制，故并发量可以得到质的提升。 I/O复用模型拥有3种不同的监听机制，分别是select、poll以及epoll。 I/O复用模型的出现很大程度改变了一个进程多个I/O阻塞的问题，它能够实现一个线程下监听多个I/O的功能，极大的提升了程序的并发性，也是目前较为主流的一种解决方案。 举例说明： 一群人要买饭，于是托付给一个人去食堂，这个人去食堂后会先告诉食堂大妈，我这里有多少人要吃饭，这个人等待食堂大妈做好饭后会打电话通知某一个人过来拿饭，即一份饭做完之后立马让一个人来吃。 信号驱动式I/O模型 当进程发起一个IO操作，会向内核注册一个信号处理函数，然后进程返回不阻塞； 当内核数据就绪时会发送一个信号给进程，进程便在信号处理函数中调用I/O读取数据。 由于该种I/O模型的编码难度较大，故现在很少有应用程序使用这种模型进行编程了。 异步I/O模型 当进程发起一个I/O操作，进程返回（不阻塞），但也不能返回果结； 内核把整个I/O处理完后，会通知进程结果。 如果I/O操作成功则进程直接获取到数据。 举例说明： 一个人要去食堂买饭，他告诉食堂大妈，我要吃饭，饭好了你让人给我送过来，然后这个人就可以去做其他的事情了。 五种I/O模型对比 5种I/O模型中，异步I/O模型的性能最高，它全程无阻塞，以下是对比图示： I/O复用select、poll、epoll简介 select selelct监听模式一般应用在Windows平台上。 它会使用顺序表存储所有注册的I/O事件描述符。 支持最大同时监听1024（32位系统）或者2048（64位系统）个描述符。 同时，它会不断的去轮询查看所有描述符的状态是否发生改变，以便触发回调函数，所以他的性能有点低，当然这只是针对其他的监听模式而言。 当描述符状态发生改变后，会将内核缓冲区的数据映射到应用程序中，这相当于拷贝一次。 还是举个例子，一个班主任最多管理1024个学生，当班主任想知道谁没有交作业的时候他会对这1024个学生一个一个进行询问，学生只会被动的回答。 如，老师问第一个学生，你交作业了吗？学生说交了，老师再问第二个学生，你交作业了吗？以此类推... 总结： 支持最大监听的描述符数量：1024（32位系统）或者2048（64位系统） 描述符存储结构：顺序表 处理事件响应：轮询处理 消息传递方式：将内核缓冲区的数据映射到应用程序中，这相当于拷贝一次 poll poll监听模式一般应用在Linux平台上。 它会使用链表存储所有注册的I/O事件描述符。 最大支持同时监听的描述符数量无上限。 他会采用轮询方式来处理事件响应。 当描述符状态发生改变后，会将内核缓冲区的数据映射到应用程序中，这相当于拷贝一次。 总结： 支持最大监听的描述符数量：无限制，2G内存就可存放20W个描述符 描述符存储结构：链表 处理事件响应：轮询处理 消息传递方式：将内核缓冲区的数据映射到应用程序中，这相当于拷贝一次 epoll epoll监听模式一般应用在Linux平台上。 它会使用红黑树存储所有注册的I/O事件描述符。 最大支持同时监听的描述符数量无上限。 它会采用及时响应的方式来处理事件响应。 epoll监听模式下，内核缓冲区的数据并不需要映射到应用程序中，因为epoll通过内核与用户空间共享一块内存来实现免拷贝的过程。 举个例子，如果说select以及poll对处理事件响应的机制是一个一个问，那么poll就是举手。 老师想知道谁没交作业，只需要吼一声，谁还没交作业？此时立马就会有人举手，相比于轮询来说它的响应速度上快了很多。 总结： 支持最大监听的描述符数量：无限制，2G内存就可存放20W个描述符 描述符存储结构：红黑树 处理事件响应：主动响应 消息传递方式：通过内核与用户空间共享一块内存来实现免拷贝的过程 LT和ET 水平触发(level-trggered)和边缘触发(edge-triggered)是2种读取内核缓冲区数据的机制。 水平触发(level-trggered) 只要文件描述符关联的读内核缓冲区非空，有数据可以读取，就一直发出可读信号进行通知， 当文件描述符关联的内核写缓冲区不满，有空间可以写入，就一直发出可写信号进行通知 边缘触发(edge-triggered) 当文件描述符关联的读内核缓冲区由空转化为非空的时候，则发出可读信号进行通知， 当文件描述符关联的内核写缓冲区由满转化为不满的时候，则发出可写信号进行通知 水平触发是只要读缓冲区有数据，就会一直触发可读信号，而边缘触发仅仅在空变为非空的时候通知一次，举个例子： 读缓冲区刚开始是空的 读缓冲区写入2KB数据 水平触发和边缘触发模式此时都会发出可读信号 收到信号通知后，读取了1kb的数据，读缓冲区还剩余1KB数据 水平触发会再次进行通知，而边缘触发不会再进行通知 边缘触发的效率比水平触发的效率明显要高出许多，它减少了重复且无用的通知。 poll和epoll均支持ET，而select只支持LT，但是一定要注意，要想支持水平触发，I/O读取机制必须设置成非阻塞的。 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:46 "},"Python/Python并发编程/常见IO示例演示.html":{"url":"Python/Python并发编程/常见IO示例演示.html","title":"常见I/O示例演示","keywords":"","body":"阻塞I/O的socket服务端 使用socket模块与concurrent.futures实现阻塞式I/O的socket服务端。 开启多个子线程，每个子线程单独负责一个链接，这意味着该服务器最大的并发量取决于你CPU能够打开的最大有效线程数： import socket import threading import concurrent.futures class TcpServer: def __init__(self, bind_addr=(\"localhost\", 8001), allow_reuse_address=False): self.socket = socket.socket() self.backlog = 5 self.bufsize = 1024 self.server_addr = bind_addr self.allow_reuse_address = allow_reuse_address # 默认创建的线程数为cpu核心数 * 5 self.executor = concurrent.futures.ThreadPoolExecutor() def run_server(self): \"\"\"运行服务\"\"\" self.server_bind() self.server_activate() self.handle_request() def server_bind(self): \"\"\"绑定地址\"\"\" if self.allow_reuse_address: self.socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1) self.socket.bind(self.server_addr) def server_activate(self): \"\"\"开启监听\"\"\" self.socket.listen(self.backlog) def handle_request(self): \"\"\"处理链接\"\"\" while 1: # 阻塞点1：accept()函数会导致程序卡住，直至有新的链接请求到来 conn, addr = self.socket.accept() self.executor.submit( self.handle_communicate, conn, addr) def handle_communicate(self, conn, addr): \"\"\"多线程处理通信\"\"\" thName = threading.current_thread().name print(f\"{addr} connect server, handle thread : {thName}\") while 1: try: # 阻塞点2：recv()函数会导致程序卡住，直至有新的信息放入conn双向链接通道中 data = conn.recv(self.bufsize) if not data: raise Exception( f\"{addr} close connect, handle thread : {thName}\") conn.send(data.upper()) except Exception as e: self.close_connect(conn, e) break def close_connect(self, conn, msg): \"\"\"关闭链接\"\"\" conn.close() print(msg) if __name__ == \"__main__\": server = TcpServer(allow_reuse_address=True) server.run_server() 非阻塞I/O的socket服务端 将上述的socket服务端改为非阻塞的： import socket import threading import concurrent.futures class TcpServer: def __init__(self, bind_addr=(\"localhost\", 8001), allow_reuse_address=False): self.socket = socket.socket() # 设置为非阻塞 self.socket.setblocking(False) self.backlog = 5 self.bufsize = 1024 self.server_addr = bind_addr self.allow_reuse_address = allow_reuse_address # 默认创建的线程数为cpu核心数 * 5 self.executor = concurrent.futures.ThreadPoolExecutor() def run_server(self): \"\"\"运行服务\"\"\" self.server_bind() self.server_activate() self.handle_request() def server_bind(self): \"\"\"绑定地址\"\"\" if self.allow_reuse_address: self.socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1) self.socket.bind(self.server_addr) def server_activate(self): \"\"\"开启监听\"\"\" self.socket.listen(self.backlog) def handle_request(self): \"\"\"处理链接\"\"\" while 1: # 设置非阻塞I/O后，accept()这个原本会阻塞的函数变的非阻塞了 # 所以这里要不断的检测是否有新的链接请求 try: conn, addr = self.socket.accept() self.executor.submit( self.handle_communicate, conn, addr) except BlockingIOError as e: continue def handle_communicate(self, conn, addr): \"\"\"多线程处理通信\"\"\" thName = threading.current_thread().name print(f\"{addr} connect server, handle thread : {thName}\") while 1: try: # 设置非阻塞I/O后，recv()这个原本会阻塞的函数变的非阻塞了 # 所以这里要不断的检测是否有新的链接请求 data = conn.recv(self.bufsize) if not data: raise Exception( f\"{addr} close connect, handle thread : {thName}\") conn.send(data.upper()) except BlockingIOError as e: continue except Exception as e: self.close_connect(conn, e) break def close_connect(self, conn, msg): \"\"\"关闭链接\"\"\" conn.close() print(msg) if __name__ == \"__main__\": server = TcpServer(allow_reuse_address=True) server.run_server() I/O多路复用的socket服务端 上述的2个示例中，每个线程都会负责监听双向链接通道和处理通信请求，所以这意味着你的系统最大有效线程数决定了你服务器的最高并发数，显然效率是十分低下的。 而如果有一种机制让一个线程来监听所有的双向链接通道的话那么并发量就会得到质的提升，它不再是单纯的一对一服务了，而是一对多服务。 下面将利用select模块实现select监听模式的I/O多路复用机制，仅仅利用单线程，最大并发数量就能提升到2048个： import socket import select class TcpServer: def __init__(self, bind_addr=(\"localhost\", 8001), allow_reuse_address=False): self.socket = socket.socket() # 设置为非阻塞（高性能的边缘触发必备条件） self.socket.setblocking(False) self.backlog = 5 self.bufsize = 1024 self.server_addr = bind_addr self.allow_reuse_address = allow_reuse_address # 1.存放注册读取事件描述符的列表，当有可读事件发生时意味着客户端请求建立与服务端的双向链接通道 # 或者客户端有新的消息发送给服务端 self.r_list = [] # 2.存放注册可写事件描述符的列表，当有可写事件发生时意味着服务端可以主动向客户端发送信息 self.w_list = [] # 3.存放注册错误事件描述符的列表，... self.e_list = [] # 4.存放被监听描述符回调函数的字典 self.callback_dict = {} # 5.循环监听的时间间隔 self.poll_interval = 0.5 def run_server(self): \"\"\"运行服务\"\"\" self.server_bind() self.server_activate() self.server_forever() def server_bind(self): \"\"\"绑定地址\"\"\" if self.allow_reuse_address: self.socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1) self.socket.bind(self.server_addr) def server_activate(self): \"\"\"开启监听\"\"\" self.socket.listen(self.backlog) def server_forever(self): \"\"\"I/O多路复用\"\"\" # 注册self.sockt的可读事件并绑定回调函数为self.handle_request # 当客户端试图建立与服务端的双向链接通道时将触发self.socket的可读事件 self.register(obj=self.socket, event_type=\"read\", callback=self.handle_request) # 开始循环监听描述符，每次while循环间隔0.5s while 1: # 当可读事件列表、可写事件列表、错误事件列表中任何一个fd的状态发生改变后 # 都会添加到r、w、e中 r, w, e = select.select( self.r_list, self.w_list, self.e_list, self.poll_interval) # 查看是否有可读事件发生，如果有就运行其回调函数 for fd in r: # 运行回调函数 fd_callback = self.callback_dict[fd][\"r\"] fd_callback(fd) def handle_request(self, fd_socket): \"\"\"处理链接\"\"\" conn, addr = fd_socket.accept() print(f\"{addr} connect server\") # 注册conn的可读事件并绑定回调函数为self.handle_communicate # 当该客户端向服务端发送信息时将触会触发conn的可读事件 self.register(obj=conn, event_type=\"read\", callback=self.handle_communicate) def handle_communicate(self, fd_conn): \"\"\"处理通信\"\"\" # 实际上就是链接服务端的客户端地址 addr = getattr(fd_conn, \"getsockname\")() try: data = fd_conn.recv(self.bufsize) # 针对Unix环境：客户端强制断开链接 if not data: raise Exception( f\"{addr} close connect\") fd_conn.send(data.upper()) # 针对Windows环境：客户端强制断开链接 except Exception as e: # 关闭双向链接通道并注销可读事件，这意味着不再监听该双向链接通道 self.close_connect(fd_conn, e) self.unregister(obj=fd_conn, event_type=\"read\") def close_connect(self, conn, msg): \"\"\"关闭链接\"\"\" conn.close() print(msg) def register(self, obj, event_type, callback): \"\"\"事件注册\"\"\" if event_type == \"read\": self.r_list.append(obj) self.callback_dict[obj] = {\"r\": callback} elif event_type == \"write\": self.w_list.append(obj) self.callback_dict[obj] = {\"w\": callback} elif event_type == \"error\": self.e_list.append(obj) self.callback_dict[obj] = {\"e\": callback} else: raise TypeError(\"unknown event type %r\" % event_type) def unregister(self, obj, event_type): \"\"\"取消注册\"\"\" if event_type == \"read\": self.r_list.remove(obj) del self.callback_dict[obj][\"r\"] elif event_type == \"write\": self.w_list.remove(obj) del self.callback_dict[obj][\"w\"] elif event_type == \"error\": self.e_list.remove(obj) del self.callback_dict[obj][\"e\"] else: raise TypeError(\"unknown event type %r\" % event_type) if __name__ == \"__main__\": server = TcpServer(allow_reuse_address=True) server.run_server() 异步的socket服务端 selectors模块是select模块的升级版，他还会根据平台自动选择监听方式，是十分方便的。 　官方文档 注意，Windows平台下不支持poll或者epoll模式 epoll模式仅有Linux平台支持 现在很多框架的内部，如著名的异步框架tornado，Twisted ，等等都是通过epoll实现的异步，其实epoll到底属于不属于异步在网络上有很大的争议，下面会有一节会和大家一起讨论一下epoll和异步之间的关系。 下面是它的使用案例，基本步骤和select模块使用类似，也是注册事件、绑定回调、监听描述符。 相较于使用select模式的I/O多路复用机制来说，epoll模式的I/O多路复用机制单线程下的效率和最大支持并发量提升了不少： import socket import selectors class TcpServer: def __init__(self, bind_addr=(\"localhost\", 8001), allow_reuse_address=False): self.socket = socket.socket() # 设置为非阻塞（高性能的边缘触发必备条件） self.socket.setblocking(False) self.backlog = 5 self.bufsize = 1024 self.server_addr = bind_addr self.allow_reuse_address = allow_reuse_address # 1.自动选择监听模式:select、poll、epoll self.sel = selectors.DefaultSelector() # 2.循环监听的时间间隔 self.poll_interval = 0.5 def run_server(self): \"\"\"运行服务\"\"\" self.server_bind() self.server_activate() self.server_forever() def server_bind(self): \"\"\"绑定地址\"\"\" if self.allow_reuse_address: self.socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1) self.socket.bind(self.server_addr) def server_activate(self): \"\"\"开启监听\"\"\" self.socket.listen(self.backlog) def server_forever(self): \"\"\"I/O多路复用\"\"\" # 注册self.sockt的可读事件并绑定回调函数为self.handle_request # 当客户端试图建立与服务端的双向链接通道时将触发self.socket的可读事件 self.sel.register(self.socket, selectors.EVENT_READ, self.handle_request) # 开始循环监听描述符，每次while循环间隔0.5s while 1: # 当有已注册描述符状态发生改变后，都会添加至fd_list # fd_list = [(fd, event), ...] fd_list = self.sel.select(self.poll_interval) for fd, event in fd_list: # 运行回调函数 fd_callback = fd.data fd_callback(fd.fileobj) def handle_request(self, fd_socket): \"\"\"处理链接\"\"\" conn, addr = fd_socket.accept() print(f\"{addr} connect server\") # 注册conn的可读事件并绑定回调函数为self.handle_communicate # 当该客户端向服务端发送信息时将触会触发conn的可读事件 self.sel.register(conn, selectors.EVENT_READ, self.handle_communicate) def handle_communicate(self, fd_conn): \"\"\"处理通信\"\"\" # 实际上就是链接服务端的客户端地址 addr = getattr(fd_conn, \"getsockname\")() try: data = fd_conn.recv(self.bufsize) # 针对Unix环境：客户端强制断开链接 if not data: raise Exception( f\"{addr} close connect\") fd_conn.send(data.upper()) # 针对Windows环境：客户端强制断开链接 except Exception as e: # 关闭双向链接通道并注销可读事件，这意味着不再监听该双向链接通道 self.close_connect(fd_conn, e) self.sel.unregister(fd_conn) def close_connect(self, conn, msg): \"\"\"关闭链接\"\"\" conn.close() print(msg) if __name__ == \"__main__\": server = TcpServer(allow_reuse_address=True) server.run_server() 更高性能的提升 上述的I/O多路复用服务端都是用单线程来实现对于请求的处理，如果加上了多线程进行处理请求，那么效率上又会有很大的提升。 如下所示： import socket import selectors import concurrent.futures class TcpServer: def __init__(self, bind_addr=(\"localhost\", 8001), allow_reuse_address=False): self.socket = socket.socket() # 设置为非阻塞（高性能的边缘触发必备条件） self.socket.setblocking(False) self.backlog = 5 self.bufsize = 1024 self.server_addr = bind_addr self.allow_reuse_address = allow_reuse_address # 默认创建的线程数为cpu核心数 * 5 self.executor = concurrent.futures.ThreadPoolExecutor() # 1.自动选择监听模式:select、poll、epoll self.sel = selectors.DefaultSelector() # 2.循环监听的时间间隔 self.poll_interval = 0.5 def run_server(self): \"\"\"运行服务\"\"\" self.server_bind() self.server_activate() self.server_forever() def server_bind(self): \"\"\"绑定地址\"\"\" if self.allow_reuse_address: self.socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1) self.socket.bind(self.server_addr) def server_activate(self): \"\"\"开启监听\"\"\" self.socket.listen(self.backlog) def server_forever(self): \"\"\"I/O多路复用\"\"\" # 注册self.sockt的可读事件并绑定回调函数为self.handle_request # 当客户端试图建立与服务端的双向链接通道时将触发self.socket的可读事件 self.sel.register(self.socket, selectors.EVENT_READ, self.handle_request) # 开始循环监听描述符，每次while循环间隔0.5s while 1: # 当有已注册描述符状态发生改变后，都会添加至fd_list # fd_list = [(fd, event), ...] fd_list = self.sel.select(self.poll_interval) for fd, event in fd_list: # 多线程运行回调函数 fd_callback = fd.data self.executor.submit(fd_callback, fd.fileobj) def handle_request(self, fd_socket): \"\"\"处理链接\"\"\" conn, addr = fd_socket.accept() print(f\"{addr} connect server\") # 注册conn的可读事件并绑定回调函数为self.handle_communicate # 当该客户端向服务端发送信息时将触会触发conn的可读事件 self.sel.register(conn, selectors.EVENT_READ, self.handle_communicate) def handle_communicate(self, fd_conn): \"\"\"处理通信\"\"\" # 实际上就是链接服务端的客户端地址 addr = getattr(fd_conn, \"getsockname\")() try: data = fd_conn.recv(self.bufsize) # 针对Unix环境：客户端强制断开链接 if not data: raise Exception( f\"{addr} close connect\") fd_conn.send(data.upper()) # 针对Windows环境：客户端强制断开链接 except Exception as e: # 关闭双向链接通道并注销可读事件，这意味着不再监听该双向链接通道 self.close_connect(fd_conn, e) self.sel.unregister(fd_conn) def close_connect(self, conn, msg): \"\"\"关闭链接\"\"\" conn.close() print(msg) if __name__ == \"__main__\": server = TcpServer(allow_reuse_address=True) server.run_server() epoll到底是同步还是异步 摘自知乎： 学习tornado、asyncio这些异步网络库时，遇到了同样的问题，网上查到的也都说不明白，原来几个概念没搞清楚。 I/O操作有多种，处理socket是一种，磁盘读写也是一种，暂时分为网络I/O和文件I/O、 I/O多路复用是操作系统级别的，属于linux操作系统的五种I/O模型中的一种，是操作系统级别同步非阻塞的 异步网络库 twisted、tornado、asyncio所谓的异步，是应用级别的异步，底层确实是基于epoll实现，基本上都是处理网络 I/O，而且都是基于事件驱动的，使用时划分事件也大多是根据网络请求。 操作系统级别的异步I/O才是真正异步非阻塞的，然后并没有很多应用，貌似unix平台没有，windows NT平台有也很少，而且基本都是文件I/O I/O多路复用的实现用的比较多，linux平台的epoll，windows平台的select等，基于epoll，select的应用大多是实现网络I/O。 所以，遇到异步框架，异步网络库都应该知道是应用级别的异步，而且基本上都是基于epoll/select实现的。 已知tornado会根据系统平台，选择epoll还是select。 实现高并发有多种方式，python多进程可以利用多核优势，协程(gevent、asyncio)可以实现应用级别的异步，celery实现任务异步，消息队列实现服务解耦等等，项目中可以根据实际情况选择或组合不同的方式。 tornado(web框架/异步网络库)：进程+异步+epoll asyncio：协程+epoll，使用中需要相应的异步库，如常用的aiohttp gevent：greenlet+猴子补丁，猴子补丁把socket相关库改为非阻塞 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:46 "},"Python/Python并发编程/协程asynic.html":{"url":"Python/Python并发编程/协程asynic.html","title":"协程 asynic","keywords":"","body":"协程 协程（coroutine）并不是一个系统层面上真实存在的东西，而是由程序员进行创造。 你可以理解为协程是用户态的“线程”，因此协程也被称为“微线程”或者“纤程（Fiber）”。 协程能够做到在单线程下实现多线程的并发操作，这是非常厉害的一点。 既然协程和线程很像，那么它对比线程有什么优势呢？ 协程和线程一样能够做切换，但是其切换代价远远小于线程，极大的提升了运行效率 协程中修改共享数据时不需要为数据加锁，因为协程本身就是一个单线程 协程有2大重要的概念，如下所示： 作为用户态线程，它必然存在于内核态线程中，也就是说协程本身是一个非常纯粹的单线程 协程最重要的意义就是切换 普通的代码运行总是顺序执行的，而如果我们有某种机制让它能够遇见I/O后进行自动切换执行就非常牛逼了。 例如下面这个例子，普通的运行打印结果是1、2、3、4，而我们如果加上遇见I/O自动切换执行的策略的话它的打印结果就会变成1、3、2、4： import time def task_01(): print(1) time.sleep(1) # I/O操作 print(2) def task_02(): print(3) time.sleep(1) # I/O操作 print(4) task_01() task_02() # 1 # 2 # 3 # 4 如果真的实现了上述的功能，那么使用单线程实现并发就变的不是那么遥不可及了。 生成器 我们可以利用生成器函数的yield关键字来实现代码的切换，如下所示： import time def task_01(): print(1) time.sleep(1) # I/O操作 yield # 手动切换 print(2) def task_02(): print(3) time.sleep(1) # I/O操作 yield # 手动切换 print(4) # 创建生成器对象 genObject_01 = task_01() genObject_02 = task_02() # 待执行任务列表 task_list = [genObject_01, genObject_02] # 开启循环 while 1: # 可执行任务列表 executable_list = task_list.copy() # 已执行任务列表 completed_list = [] for run_generator in executable_list: try: next(run_generator) except StopIteration as e: # 如果任务执行完毕，添加到已执行任务列表中 completed_list.append(run_generator) for end_generator in completed_list: # 从待执行任务列表、已执行任务列表中删除已完成任务 task_list.remove(end_generator) executable_list.remove(end_generator) else: # 清空已完成任务列表 completed_list.clear() if not task_list: break # 1 # 3 # 2 # 4 就这样一个基础的协程就做好了，但是你可以发现它的编码难度较大。 并且每次遇见I/O操作后都需要我们手动进行切换，十分的不方便。 gevent模块 针对yield协程的缺点，我们可以利用gevent模块，让整个碰见I/O操作就切换的过程变为自动进行。 它是一个第三方模块，所以你需要手动进行安装下载： $ pip3 install gevent 代码如下所示： import gevent import time from gevent import monkey # 声明：下面代码碰见I/O操作自动切换 monkey.patch_all() def task_01(): print(1) time.sleep(1) # I/O操作，自动切换 print(2) time.sleep(1) # I/O操作，自动切换 def task_02(): print(3) time.sleep(1) # I/O操作，自动切换 print(4) # 创建协程对象 fiberObject_01 = gevent.spawn(task_01, ) # 后面可传递参数 fiberObject_02 = gevent.spawn(task_02, ) # 任务列表 task_list = [fiberObject_01, fiberObject_02] # 开始执行 gevent.joinall( task_list ) # 1 # 3 # 2 # 4 asyncio模块 Python3.4之后，官方提供了asyncio模块来提供对协程的支持。 下面是代码示例： import asyncio # 函数头部加上该装饰器，表明该函数是一个协程函数 @asyncio.coroutine def task_01(): print(1) yield from asyncio.sleep(1) # I/O操作 自动切换 print(2) @asyncio.coroutine def task_02(): print(3) yield from asyncio.sleep(1) # I/O操作 自动切换 print(4) # 创建协程对象，并将它包装为期程对象 fiberObject_01 = asyncio.ensure_future(task_01()) fiberObject_02 = asyncio.ensure_future(task_02()) # 任务列表 task_list = [fiberObject_01, fiberObject_02] # 获取并开启循环 loop = asyncio.get_event_loop() # 运行任务列表，并等待所有协程任务执行完毕 loop.run_until_complete(asyncio.wait(task_list)) # 1 # 3 # 2 # 4 我们要注意，如果一个协程函数中要调用另一个函数，则必须使用yield from关键字，yield form后面可以运行的对象类型： 协程对象 期程对象 task任务对象 另外，如果你想在协程函数中运行一些模块方法，那么一定要保证模块所提供的方法是异步方法，否则协程切换无效。 有关于yield from的使用，请参照Python基础生成器一章节。 async&awit语法 async和awit语法在Python3.5中被支持，它本质和asyncio模块使用没有任何区别，只是简化了语法。 async：用于定义协程函数，而不再使用@asyncio.coroutine装饰器来进行定义 awit：相当于yield from的简写形式，必须书写在协程函数中 以下是它的使用示例： import asyncio async def task_01(): print(1) await asyncio.sleep(1) # I/O操作 自动切换 print(2) async def task_02(): print(3) await asyncio.sleep(1) # I/O操作 自动切换 print(4) # 创建协程对象，并将它包装为期程对象 fiberObject_01 = asyncio.ensure_future(task_01()) fiberObject_02 = asyncio.ensure_future(task_02()) # 任务列表 task_list = [fiberObject_01, fiberObject_02] # 获取并开启循环 loop = asyncio.get_event_loop() # 运行任务列表，并等待所有协程任务执行完毕 loop.run_until_complete(asyncio.wait(task_list)) # 1 # 3 # 2 # 4 协程的作用 单纯的协程只是能够做切换，没有其他的任何特定功能。 也就是说，协程本身并不能提高并发量，但是如果能够加上碰见I/O自动切换的机制，那么协程的真正意义才能够被体现。 注意一点： 对于计算密集型的操作来说，利用协程来回进行切换是没有任何意义的，来回切换并保存状态，反倒会降低性能 对于I/O密集型的操作来说，利用协程在I/O等待时间中去切换并执行其他任务，当I/O结束后再进行回调，那么就会大大节省系统资源并提供高性能从而实现异步编程 接下来我们将使用一个简单的爬虫案例，来探究协程和多线程的执行效率到底提升了多少。 下面是多线程爬虫的示例，需要用到requests模块，所以你必须先安装它： $ pip3 install requests 一个任务负责爬取资源，一个任务负责解析资源，为了更加方便对比，我们将整个运行时长都*10： import requests import time from concurrent.futures import ThreadPoolExecutor headers = { \"user-agent\": \"User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/87.0.4280.88 Safari/537.36\" } urls = [ \"https://www.jianshu.com/\", \"https://www.csdn.net/\", \"https://www.cnblogs.com/\", ] start = time.time() # 任务函数 def func(url): response = requests.get(url, headers=headers) return response.text # 绑定回调函数 def callback(futuresObject): print(futuresObject.result()) if __name__ == \"__main__\": with ThreadPoolExecutor() as executor: for url in urls: futuresObject = executor.submit(func, url) futuresObject.add_done_callback(callback) end = time.time() print(f\"总计花费时长{(end - start) * 10}\") # 总计花费时长21.973369121551514 下面是协程爬虫的示例，由于协程中不允许同步方法的出现，而requests模块下的请求方法都是同步请求方法，所以需要使用aiohttp模块下的异步请求方法完成网络请求，你必须先安装它： $ pip3 install aiohttp 示例如下： import asyncio import aiohttp import time headers = { \"user-agent\": \"User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/87.0.4280.88 Safari/537.36\" } urls = [ \"https://www.jianshu.com/\", \"https://www.csdn.net/\", \"https://www.cnblogs.com/\", ] start = time.time() # 任务函数 async def func(url): # async wait 相当于是执行一个异步的 __enter__ 方法 async with aiohttp.ClientSession() as session: # 防止ssl抛出错误 async with session.get(url, headers=headers, verify_ssl=False) as response: return await response.text() # 绑定回调函数 def callback(futuresObject): print(futuresObject.result()) if __name__ == \"__main__\": # 创建协程任务列表 task_list = [] # 创建协程任务 for url in urls: # 创建协程对象，并将它包装为期程对象 fiberObject = asyncio.ensure_future(func(url)) # 为期程对象绑定回调函数 fiberObject.add_done_callback(callback) # 添加到协程任务列表 task_list.append(fiberObject) # 创建事件循环 event_loop = asyncio.get_event_loop() # 执行任务，并且主线程会等待协程任务列表中的所有任务处理完毕后再执行 event_loop.run_until_complete(asyncio.wait(task_list)) end = time.time() print(f\"总计花费时长{(end - start) * 10}\") # 总计花费时长14.334436416625977 可以看见，协程爬虫比多线程爬虫的执行效率提高了不止一星半点，它真正称得上是Python中I/O密集型任务处理的大杀器。 asyncio详细探究 基于协程实现高性能的异步编程，这是Python未来发展方向，诸如fastapi、tornado等非常出名的异步web框架内部其实都与协程息息相关。 此外，Python web领域大火的Django也在3.x版本中正式迈入异步领域，这意味着：异步编程，永远的神。 事件循环 事件循环是asyncio的关键，你可以将它理解为一个while循环，它会在循环中周期性的执行协程任务，并且在特定的条件下终止循环。 你可以参照生成器实现协程的代码或者下面的伪代码，这就是事件循环最直观的体现。 待执行任务列表 = [协程任务, 协程任务] while 1: 可执行任务列表 = 待执行任务列表[:] 已执行任务列表 = [] for 可执行任务 in 可执行任务列表： try: next(可执行任务) except StopIteration as e: 已执行任务列表.append(可执行任务) for 已执行任务 in 已执行任务列表: 待执行任务.remove(已执行任务) 可执行任务.remove(已执行任务) else: 已执行任务列表.clear() if not 待执行任务列表: break 使用asyncio模块时，你可以直接通过下面方式获取到该事件循环： event_loop = asyncio.get_event_loop() 协程对象 协程函数就是加上了@asyncio.coroutine装饰器的函数，或者以async开头定义的函数，如下所示： async def task(): pass 它和生成器有着一样的特性，即加括号时不会调用函数体内部代码，而是返回一个协程对象： fiberObject = task() print(type(fiberObject)) # 任务执行 当要执行任务的时候，必须先获取事件循环，然后再将协程对象任务添加到事件循环中： import asyncio async def task(): print(\"run task ...\") fiberObject = task() event_loop = asyncio.get_event_loop() event_loop.run_until_complete(fiberObject) print(\"run main ...\") # run task ... # run main ... event_loop.run_until_complete()方法会添加协程对象至事件循环中，并且执行协程对象，直至协程对象运行完毕后才跳出事件循环。 在Python3.7之前，我们每次要运行一个协程对象都必须先获取事件循环，再调用event_loop.run_until_complete()添加协程对象并执行，这很麻烦。 在Python3.7之后asyncio模块新增了run()方法，它简化了这2步操作，如下所示： import asyncio async def task(): print(\"run task ...\") fiberObject = task() asyncio.run(fiberObject) print(\"run main ...\") # run task ... # run main ... await await关键字只能在协程函数中使用，类似于yield from只能在生成器函数中使用一样。 它与生成器函数相同，都用于运行嵌套在一个协程函数中的另一个协程函数，具体可参照yield from： import asyncio async def inner(): print(\"run ... inner\") return 1 async def warpper(): print(\"run ... warpper\") result = await inner() print(result) if __name__ == \"__main__\": fiberObject = warpper() event_loop = asyncio.get_event_loop() event_loop.run_until_complete(fiberObject) # run ... warpper # run ... inner # 1 await后面可以运行的对象类型： 协程对象 期程对象 taskr任务对象 期程对象 上述所有的代码都是在事件循环中添加一个协程对象，当事件循环中仅有一个对象时是无法做到遇见I/O就切换的操作的。 同时，协程对象本身不能绑定回调函数，所以要想绑定回调函数必须将它包装为期程对象。 在Python3.7之前，你可以使用asyncio.ensure_future()函数将一个协程对象包装为期程对象，这样它就可以绑定回调函数了： import asyncio async def task(): await asyncio.sleep(3) return 1 def callback(fiberObject): print(fiberObject.result()) if __name__ == \"__main__\": fiberObject = asyncio.ensure_future(task()) fiberObject.add_done_callback(callback) event_loop = asyncio.get_event_loop() event_loop.run_until_complete(fiberObject) # 1 如果想同时在事件循环中添加多个期程对象，你可以创建一个任务列表，并使用asyncio.wait()方法来将任务列表中所有的期程对象都添加到事件循环中，如下所示： import asyncio async def task(param): print(f\"run task{param}\") await asyncio.sleep(3) return param def callback(fiberObject): print(fiberObject.result()) if __name__ == \"__main__\": task_list = [] for i in range(3): fiberObject = asyncio.ensure_future(task(i)) fiberObject.add_done_callback(callback) task_list.append(fiberObject) event_loop = asyncio.get_event_loop() event_loop.run_until_complete( asyncio.wait(task_list) ) # run task0 # run task1 # run task2 # 0 # 1 # 2 这样一个异步提交的案例就出现了。 任务对象 任务对象是基于期程对象的一个封装。 如果你的Python版本是Python3.7或者更高，则可以直接创建任务对象并绑定回调函数，然后将它丢入的事件循环循环中： import asyncio async def task(param): print(f\"run task{param}\") await asyncio.sleep(3) return param def callback(fiberObject): print(fiberObject.result()) async def main(): task_list = [] for i in range(3): fiberObject = asyncio.create_task(task(i), name=f\"task{i}\") fiberObject.add_done_callback(callback) task_list.append(fiberObject) done, pending = await asyncio.wait(task_list, timeout=None) print(done, pending) if __name__ == \"__main__\": asyncio.run(main()) # run task0 # run task1 # run task2 # 0 # 1 # 2 concurrent.futures.Futures 在concurrent.futures模块中，也有一个期程对象，该模块用于提供线程执行器和进程执行器，能够更加方便管理线程和进程，详情参照前面>一章。 concurrent.futures.Futures和asyncio的Futures对象还是有所不同的，下面是官方文档的说明： 与 asyncio Futures 不同， concurrent.futures.Future 实例不能等待 asyncio.Future.result() 和 asyncio.Future.exception() 不接受超时参数 asyncio.Future.result() 和 asyncio.Future.exception() 在 Future 未完成时引发 InvalidStateError 异常 使用 asyncio.Future.add_done_callback() 注册的回调不会立即调用。 它们是用 loop.call_soon() 来安排的 asyncio Future 与 concurrent.futures.wait() 和 concurrent.futures.as_completed() 函数不兼容 如果想将concurrent.futures.Futures变的和asyncio.Future相同，则可以使用asyncio所提供的方法wrap_future()。 其实，一般在程序开发中我们要么统一使用 asycio 的协程实现异步操作、要么都使用进程池和线程池实现异步操作。但如果 协程的异步和 进程池/线程池的异步 混搭时，那么就会用到此功能了。 import time import asyncio import concurrent.futures def func1(): # 某个耗时操作 time.sleep(2) return 1 async def main(): loop = asyncio.get_running_loop() # 1. Run in the default loop's executor ( 默认ThreadPoolExecutor ) # 第一步：内部会先调用 ThreadPoolExecutor 的 submit 方法去线程池中申请一个线程去执行func1函数，并返回一个concurrent.futures.Future对象 # 第二步：调用asyncio.wrap_future将concurrent.futures.Future对象包装为asycio.Future对象。 # 因为concurrent.futures.Future对象不支持await语法，所以需要包装为 asycio.Future对象 才能使用 fut = loop.run_in_executor(None, func1) result = await fut print('default thread pool', result) # 2. Run in a custom thread pool: # with concurrent.futures.ThreadPoolExecutor() as pool: # result = await loop.run_in_executor( # pool, func1) # print('custom thread pool', result) # 3. Run in a custom process pool: # with concurrent.futures.ProcessPoolExecutor() as pool: # result = await loop.run_in_executor( # pool, func1) # print('custom process pool', result) asyncio.run(main()) 应用场景：当项目以协程式的异步编程开发时，如果要使用一个第三方模块，而第三方模块不支持协程方式异步编程时，就需要用到这个功能，例如： import asyncio import requests async def download_image(url): # 发送网络请求，下载图片（遇到网络下载图片的IO请求，自动化切换到其他任务） print(\"开始下载:\", url) loop = asyncio.get_event_loop() # requests模块默认不支持异步操作，所以就使用线程池来配合实现了。 future = loop.run_in_executor(None, requests.get, url) response = await future print('下载完成') # 图片保存到本地文件 file_name = url.rsplit('_')[-1] with open(file_name, mode='wb') as file_object: file_object.write(response.content) if __name__ == '__main__': url_list = [ 'https://www3.autoimg.cn/newsdfs/g26/M02/35/A9/120x90_0_autohomecar__ChsEe12AXQ6AOOH_AAFocMs8nzU621.jpg', 'https://www2.autoimg.cn/newsdfs/g30/M01/3C/E2/120x90_0_autohomecar__ChcCSV2BBICAUntfAADjJFd6800429.jpg', 'https://www3.autoimg.cn/newsdfs/g26/M0B/3C/65/120x90_0_autohomecar__ChcCP12BFCmAIO83AAGq7vK0sGY193.jpg' ] tasks = [download_image(url) for url in url_list] loop = asyncio.get_event_loop() loop.run_until_complete(asyncio.wait(tasks)) async for 异步可迭代对象 async for语句是针对异步可迭代对象所使用的。 异步可迭代对象是指内部是实现了__aiter__()方法的对象，它必须返回一个await iterator对象 异步迭代器 异步迭代器是指内部实现了__aiter__()和__anext__()方法的对象，其中__anext__()方法必须返回一个awaitable对象。 async for会处理异步迭代器的 __anext__()方法所返回的可等待对象，直到其引发一个StopAsyncIteration异常。由 PEP 492引入。 代码实现 下面实现一个异步可迭代对象，它的可迭代器就是本身。 import asyncio class Reader(object): \"\"\" 自定义异步迭代器（同时也是异步可迭代对象） \"\"\" def __init__(self): self.count = 0 async def readline(self): # await asyncio.sleep(1) self.count += 1 if self.count == 100: return None return self.count def __aiter__(self): return self async def __anext__(self): val = await self.readline() if val == None: raise StopAsyncIteration return val async def func(): # 创建异步可迭代对象 async_iter = Reader() # async for 必须要放在async def函数内，否则语法错误。 async for item in async_iter: print(item) asyncio.run(func()) async wait 异步上下文管理 此种对象通过定义__aenter__()和__aexit__()方法来对 async with 语句中的环境进行控制。由 PEP 492 引入。 import asyncio class AsyncContextManager: def __init__(self): self.conn = conn async def do_something(self): # 异步操作数据库 return 666 async def __aenter__(self): # 异步链接数据库 self.conn = await asyncio.sleep(1) return self async def __aexit__(self, exc_type, exc, tb): # 异步关闭数据库链接 await asyncio.sleep(1) async def func(): async with AsyncContextManager() as f: result = await f.do_something() print(result) asyncio.run(func()) 这个异步的上下文管理器还是比较有用的，平时在开发过程中 打开、处理、关闭 操作时，就可以用这种方式来处理。 uvloop Python标准库中提供了asyncio模块，用于支持基于协程的异步编程。 uvloop是 asyncio 中的事件循环的替代方案，替换后可以使得asyncio性能提高。事实上，uvloop要比nodejs、gevent等其他python异步框架至少要快2倍，性能可以比肩Go语言。 安装uvloop pip3 install uvloop 在项目中想要使用uvloop替换asyncio的事件循环也非常简单，只要在代码中这么做就行。 import asyncio import uvloop asyncio.set_event_loop_policy(uvloop.EventLoopPolicy()) # 编写asyncio的代码，与之前写的代码一致。 # 内部的事件循环自动化会变为uvloop asyncio.run(...) 注意：知名的asgi uvicorn内部就是使用的uvloop的事件循环。 官方文档 在程序中只要看到async和await关键字，其内部就是基于协程实现的异步编程，这种异步编程是通过一个线程在I/O等待时间去执行其他任务，从而实现并发。 以上就是异步编程的常见操作，其他具体的内容可参考官方文档。 中文版：https://docs.python.org/zh-cn/3.8/library/asyncio.html 英文本：https://docs.python.org/3.8/library/asyncio.html 此外，此篇文章基本借鉴于武Sir，再次特别感谢。 原文地址 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:46 "},"Python/Python驱动程序/summary.html":{"url":"Python/Python驱动程序/summary.html","title":"Python驱动程序","keywords":"","body":" Python操纵MySQL Python操纵Redis Python操纵MongoDB Python操纵Elasticsearch Python操纵RabbitMQ ORM框架：SQLALchemy的使用 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:46 "},"Python/Python驱动程序/Python操纵MySQL.html":{"url":"Python/Python驱动程序/Python操纵MySQL.html","title":"Python操纵MySQL","keywords":"","body":"pymysql 基本使用 pymysql是一款第三方的Python模块，它可以帮助我们链接MySQL： $ pip3 install pymysql 以下是它的基本使用： import pymysql # 链接信息 link_information = { \"host\": \"192.168.0.120\", \"user\": \"Jack\", \"password\": \"123\", \"database\": \"db1\", \"charset\": \"utf8mb4\", \"cursorclass\": pymysql.cursors.DictCursor, # 结果以字典形式呈现 \"autocommit\": False, # 关闭自动提交 } # 获取链接 conn = pymysql.connect(**link_information) # 获取游标 cursor = conn.cursor() # 定义语句, ?为占位符 sql_statement = \"SELECT * FROM studentsInfo WHERE id IN (%s, %s)\" # 执行语句，返回受影响的行数，传入tuple格式化占位符，防止sql注入 affected_row = cursor.execute(sql_statement, (1, 2)) # 结果信息 result = cursor.fetchall() # 打印结果 print(affected_row) # 2 print(result) # [ # {'id': 1, 'name': 'Jack', 'gender': 'male', 'age': 17, 'fk_student_id': 1, 'fk_class_id': 2}, # {'id': 2, 'name': 'Tom', 'gender': 'male', 'age': 18, 'fk_student_id': 2, 'fk_class_id': 1} # ] # 关闭游标和链接 cursor.close() conn.close() 结果获取 pymysql中对于结果集而言，是存在一个游标的概念的，它相当于当前记录的指针，可以上下移动。 当pymysql执行完成SQL语句后，可用下面3个方法从由表中获取记录结果： - cursor.fetchone() 返回第一条记录，游标向下移动一行，默认返回一个Tuple 若指定了cursorclass为pymysql.cursors.DictCursor，则返回一个Dict - cursor.fetchmany(2) 获取接下来的两条记录，游标向下移动两行，默认返回一个List[Tuple...] 若指定了cursorclass为pymysql.cursors.DictCursor，则返回一个List[Dict...] - cursor.fetchall() 获取全部记录，游标移动到末尾，默认返回一个List[Tuple...] 若指定了cursorclass为pymysql.cursors.DictCursor，则返回一个List[Dict...] 也可以通过下面的方法改变游标的位置： - cursor.scroll(3, mode='absolute') 游标以绝对位置向下移动3条记录 - cursor.scroll(3, mode='relative') 游标以相对位置向上移动3条记录 # 如果移动值为负数，则代表向上移动 SQL注入 在提交某些需要格式化的SQL语句时，一定要使用cursor.execute()中的方法第二参数args格式化SQL语句，而不是利用str.format()或者f-string进行格式化。 这会避免SQL注入带来的安全隐患。 另外，在使用cursor.execute()格式化SQL语句时，不能格式化table-name、database-name，否则会抛出语法错误，这是因为execute()在格式化SQL语句时会自动加上`号。 事务提交 在执行UPDATE、INSERT、DELETE等TCL事务控制语句时，必须使用conn.commit()或conn.rollback()方法提交或撤销事务语句： sql_statement = \"UPDATE studentsInfo SET age = age + 1 WHERE id = %s\" affected_row = cursor.execute(sql_statement, (1, )) conn.commit() # conn.rollback() 或者你也可以在实例化conn对象时为它传入autocommit=true的参数： link_information = { \"host\": \"192.168.0.120\", \"user\": \"Jack\", \"password\": \"123\", \"database\": \"db1\", \"charset\": \"utf8mb4\", \"cursorclass\": pymysql.cursors.DictCursor, # 结果以字典形式呈现 \"autocommit\": True, } # 获取链接 conn = pymysql.connect(**link_information) 提交多条 使用cursor.executemany()方法可以一次性提交多条SQL语句，这在INSERT时非常常用： import pymysql # 链接信息 link_information = { \"host\": \"192.168.0.120\", \"user\": \"Jack\", \"password\": \"123\", \"database\": \"db1\", \"charset\": \"utf8mb4\", \"cursorclass\": pymysql.cursors.DictCursor, # 结果以字典形式呈现 \"autocommit\": False, } # 获取链接 conn = pymysql.connect(**link_information) # 获取游标 cursor = conn.cursor() # 定义语句, ?为占位符 sql_statement = \"INSERT INTO userInfo(name, gender, age) VALUES(%s, %s, %s)\" user_info = ( (\"Jack\", 1, 18), (\"Mary\", 0, 17), (\"Ken\", 1, 21) ) # 将会自动执行3次 affected_row = cursor.executemany(sql_statement, user_info) conn.commit() # 结果信息 result = cursor.fetchall() # 最后一条行号 # 打印结果 print(affected_row) # 2 print(result) # () # 插入完成后，最后一条记录所在的行号 print(cursor.lastrowid) # 3 # 关闭游标和链接 cursor.close() conn.close() dbutils 链接池 使用dbutils的链接池来与MySQL服务端建立链接，可以有效避免频繁的socket链接请求，在多线程场景下适用。 因为pymysql在多线程下必须与MySQL服务器沟通多次，每一次创建1条链接，而dbutils可以一次创建多条链接供所有线程使用，所以它的网络I/O开销会比较小。 下载dbutils模块： $ pip3 install dbutils 基本使用 如下所示： import pymysql from dbutils.pooled_db import PooledDB link_information = { \"host\": \"192.168.0.120\", \"user\": \"Jack\", \"password\": \"123\", \"database\": \"db1\", \"charset\": \"utf8mb4\", \"cursorclass\": pymysql.cursors.DictCursor, # 结果以字典形式呈现 \"autocommit\": False, # dbutils依赖于pymysql模块发起链接 \"creator\": pymysql, # 初始化时，链接池中至少创建的空闲的链接，0表示不创建 \"mincached\": 10, # 链接池中最多共享的链接数量，0和None表示全部共享 \"maxshared\": 0, # 一个链接最多被重复使用的次数，None表示无限制 \"maxusage\": 0, # 链接池中最多闲置的链接，0和None不限制 \"maxcached\": 0, # 连接池允许的最大连接数，0和None表示不限制连接数 \"maxconnections\": 70, # 连接池中如果没有可用连接后，是否阻塞等待。True，等待；False，不等待然后报错 \"blocking\": True, # 开始会话前执行的命令列表 \"setsession\": [], } # 确保链接池只会初始化一次 pool = PooledDB(**link_information) if __name__ == \"__main__\": conn = pool.connection() cursor = conn.cursor() cursor.execute(\"SELECT * FROM userInfo;\") print(cursor.fetchall()) cursor.close() conn.close() Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:46 "},"Python/Python驱动程序/Python操纵MongoDB.html":{"url":"Python/Python驱动程序/Python操纵MongoDB.html","title":"Python操纵MongoDB","keywords":"","body":"pymongo pymongo是MongoDB官方推出的一款驱动程序，适用于Python语言。 $ pip3 install pymongo 官方文档：点我跳转 链接MongoDB 通过pymongo模块链接MongoDB的示例代码： from pymongo import MongoClient host = \"192.168.0.120\" port = \"27017\" user = \"root\" password = \"123\" auth_source = \"admin\" client = MongoClient( f\"mongodb://{user}:{password}@{host}:{port}/?authSource={auth_source}\") with client: db = client[\"db1\"] print(db.name) # db1 库的操作 相关API 库层面操作的相关API如下所示： - list_database_names 查看所有库的名字 - list_databases 查看所有库 - get_database 获取某个库 - get_default_database 获取默认库 - drop_database 删除某个库 查看库 查看当前MongoDB实例上的所有库的名字： with client: print(client.list_database_names()) # ['admin', 'config', 'db1', 'local'] 查看当前MongoDB实例上的所有库及其基础状态： with client: db_lst = client.list_databases() for db in db_lst: print(db) # ['admin', 'config', 'db1', 'local'] # {'name': 'admin', 'sizeOnDisk': 135168.0, 'empty': False} # {'name': 'config', 'sizeOnDisk': 12288.0, 'empty': False} # {'name': 'db1', 'sizeOnDisk': 73728.0, 'empty': False} # {'name': 'local', 'sizeOnDisk': 221184.0, 'empty': False} 获取库 获取库有3种方法： client.库名 client[\"库名\"] client.get_database(\"库名\") 个人比较喜欢第2种方式，如下所示： with client: admin = client.admin test = client[\"test\"] local = client.get_database(\"local\") print(admin.name) print(test.name) print(local.name) # admin # test # local 创建库 创建库的语法： client.新库名 client[\"新库名\"] 示例如下： with client: db1 = client.db1 db2 = client[\"db2\"] print(db1.name) print(db2.name) # db1 # db2 删除库 删除库可以使用drop_database()方法，如下所示： with client: client.drop_database(\"db2\") 删除后并不会有任何返回结果，因为在MongoDB中即使删除一个不存在的库也不会抛出异常。 集合操作 相关API 集合层面操作的相关API如下所示： - list_collection_names 查看所有集合的名字 - list_collections 查看所有集合 - get_collection 获取某个集合 - create_collection 创建某个集合 - drop_collection 删除某个集合 查看集合 查看当前库中所有集合的名字： with client: admin = client.get_database(\"admin\") print(admin.list_collection_names()) # ['system.users', 'system.version'] 查看当前库中所有集合及其基础状态： with client: admin = client.get_database(\"admin\") collection_lst = admin.list_collections() for collection in collection_lst: print(collection) # {'name': 'system.users', 'type': 'collection', 'options': {}, 'info': {'readOnly': False, 'uuid': Binary(b'j\\x04\\xe5\\rd\\x0eM\\xb4\\xa0T\\xa0L\\x90>b\\xe7', 4)}, 'idIndex': {'v': 2, 'key': {'_id': 1}, 'name': '_id_'}} # {'name': 'system.version', 'type': 'collection', 'options': {}, 'info': {'readOnly': False, 'uuid': Binary(b'\\xdc\\xf5qj\\xed!I\\xf1\\xbe\\x07N\\xaf\\xcf\\xc1\\xab\\xe9', 4)}, 'idIndex': {'v': 2, 'key': {'_id': 1}, 'name': '_id_'}} 获取集合 获取集合有3种方法： 库对象.集合名 库对象[\"集合名\"] 库对象.get_collection(\"集合名\") 个人比较喜欢第2种方式，如下所示： with client: admin = client.get_database(\"admin\") user = admin[\"user\"] version = admin.get_collection(\"version\") print(user.name) print(version.name) # user # version 创建集合 创建集合的语法： 库对象.新集合名 库对象[\"新库名\"] 库对象.create_collection(\"新集合名\") 示例如下： with client: db1 = client.get_database(\"db1\") user = db1.create_collection(\"user\") print(user.name) # user 删除集合 删除集合可以使用drop_collection()方法，如下所示： with client: db1 = client.get_database(\"db1\") db1.drop_collection(\"user\") 删除后并不会有任何返回结果，因为在MongoDB中即使删除一个不存在的集合也不会抛出异常。 文档操作 相关API 文档操作的相关API如下所示： - insert_one 插入单行记录 - insert_many 插入多行记录 - update_one 更新单行记录 - update_many 更新多行记录 - delete_one 删除单行记录 - delete_many 删除多行记录 插入文档 更新记录可以使用insert_one()或者insert_many()，他们的区别在于： insert_one()：仅插入第一个文档 insert_many()：可插入多个文档 如果要插入时间类型，则需要使用datetime模块，下面使用insert_many()进行示例： from pymongo import MongoClient import datetime host = \"192.168.0.120\" port = \"27017\" user = \"root\" password = \"123\" auth_source = \"admin\" client = MongoClient( f\"mongodb://{user}:{password}@{host}:{port}/?authSource={auth_source}\") with client: db1 = client.get_database(\"db1\") user_info = db1.get_collection(\"userInfo\") user_info.insert_many( [ { \"name\": \"Jack\", \"age\": 18, \"gender\": 1, \"create_time\": datetime.datetime(2016, 8, 15), \"grades\": [ {\"type\": \"mysql\", \"score\": 92}, {\"type\": \"redis\", \"score\": 78}, {\"type\": \"mongodb\", \"score\": 32}, ] }, { \"name\": \"Tom\", \"age\": 20, \"gender\": 1, \"create_time\": datetime.datetime(2013, 4, 5), \"grades\": [ {\"type\": \"mysql\", \"score\": 88}, {\"type\": \"redis\", \"score\": 68}, {\"type\": \"mongodb\", \"score\": 54}, ] }, { \"name\": \"Mary\", \"age\": 18, \"gender\": 0, \"create_time\": datetime.datetime(2012, 2, 3), \"grades\": [ {\"type\": \"mysql\", \"score\": 91}, {\"type\": \"redis\", \"score\": 89}, {\"type\": \"mongodb\", \"score\": 72}, ] } ] ) 更新文档 更新文档可以使用update_one()或者update_many()，他们的区别在于： update_one()：仅更新匹配到的第一个文档 update_many()：可更新匹配到的多个文档 下面使用update_many()进行示例： with client: db1 = client.get_database(\"db1\") user_info = db1.get_collection(\"userInfo\") result = user_info.update_many( {\"name\": \"Jack\"}, {\"$inc\": {\"age\": +1}}) # 成功匹配的文档数量 print(result.matched_count) # 成功修改的文档数量 print(result.modified_count) 删除文档 删除文档可以使用delete_one()或者delete_many()，他们的区别在于： delete_one()：仅删除掉匹配到的第一个文档 delete_many()：可删除掉匹配到的多个文档 下面使用delete_many()进行示例： with client: db1 = client.get_database(\"db1\") user_info = db1.get_collection(\"userInfo\") result = user_info.delete_many( {\"name\": \"Jack\"}) # 成功删除的文档数量 print(result.deleted_count) 文档查询 相关API 文档查询的相关API如下所示： - find 查询符合条件的所有文档，如不指定查询条件则返回全部文档 - find_one 只查询一条文档 - aggregate 聚合查询 - count_documents 查询文档数量 - distinct 获取所有文档中的某一个key 文档查询 普通的文档查询可使用find()以及find_one()进行，他们的区别在于： find_one()：仅返回匹配到的第一个文档 find()：返回全部匹配到的文档 如下所示： result = user_info.find({\"grades.0.score\": {\"$gt\": 25}}, { \"name\": 1, \"_id\": 0}) 查询完成后的result对象可调用的一些方法或者属性如下： - cursor_id - distinct - explain - hint - limit - max - min - skip - sort - where 示例演示，查询所有mysql成绩大于25的学生： with client: db1 = client.get_database(\"db1\") user_info = db1.get_collection(\"userInfo\") result = user_info.find({\"grades.0.score\": {\"$gt\": 25}}, { \"name\": 1, \"_id\": 0}) for row in result: print(row) # {'name': 'Tom'} # {'name': 'Mary'} 其实pymongo的查询接口和原生语句都差不多，可以参照MongoDB系列的查询文章。 聚合查询 聚合使用aggregate()方法进行，在内部指定管道和步骤，如下所示： with client: db1 = client.get_database(\"db1\") user_info = db1.get_collection(\"userInfo\") # 以性别分组，查询年龄大于18的组 result = user_info.aggregate( [ # 步骤1 { \"$group\": { # 指定聚合条件 \"_id\": \"$gender\", \"avg_age\": {\"$avg\": \"$age\"} } }, # 步骤2 { \"$match\": { \"avg_age\": {\"$gt\": 18} } } ] ) for row in result: print(row) # {'_id': 1, 'avg_age': 20.0} 具体的聚合查询可参照MongoDB系列中的聚合查询文章。 索引相关 相关API - create_index 创建索引 - create_indexes 创建多个索引 - index_information 查询索引相关信息 - list_indexes 列出所有的索引 - drop_index 删除索引 - drop_indexes 删除多个索引 创建索引 查询索引可使用create_index()或者create_indexes()方法，如下所示： with client: db1 = client.get_database(\"db1\") user_info = db1.get_collection(\"userInfo\") user_info.create_index([(\"grades.type\", pymongo.DESCENDING)], background=True) 查询索引 查询索引可使用list_indexes()或者index_information()方法，如下所示： with client: db1 = client.get_database(\"db1\") user_info = db1.get_collection(\"userInfo\") print(user_info.index_information()) # {'_id_': {'v': 2, 'key': [('_id', 1)]}, 'grades.type_-1': {'v': 2, 'key': [('grades.type', -1)], 'background': True}} 删除索引 删除索引可使用drop_index()或者drop_indexs()方法，如下所示： with client: db1 = client.get_database(\"db1\") user_info = db1.get_collection(\"userInfo\") user_info.drop_index(index_or_name=\"grades.type_-1\") Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:46 "},"Python/Python驱动程序/ORM框架：SQLALchemy的使用.html":{"url":"Python/Python驱动程序/ORM框架：SQLALchemy的使用.html","title":"ORM框架：SQLALchemy的使用","keywords":"","body":"SQLAlchemy SQLAlchemy是Python中一款非常优秀的ORM框架，它可以与任意的第三方web框架相结合，如flask、tornado、django、fastapi等。 SQLALchemy相较于Django ORM来说更贴近原生的SQL语句，因此学习难度较低。 SQLALchemy由以下5个部分组成： Engine：框架引擎 Connection Pooling：数据库链接池 Dialect：数据库DB API种类 Schema/Types：数据库架构类型 SQL Exprression Language：SQL表达式语言 图示如下： 运行流程： 首先用户输入的操作会交由ORM对象 接下来ORM对象会将用户操作提交给SQLALchemy Core 其次该操作会由Schema/Types以及SQL Expression Language转换为SQL语句 然后Egine会匹配用户已经配置好的egine，并从链接池中去取出一个链接 最终该链接会通过Dialect调用DBAPI，将SQL语句转交给DBAPI去执行 下载SQLALchemy： $ pip3 install sqlalchemy 值得注意的是，SQLAlchemy必须依赖其他操纵数据库的模块才能进行使用，也就是上面提到的DBAPI。 SQLAlchemy配合DBAPI使用时，链接字符串也有所不同，如下所示： MySQL-Python mysql+mysqldb://:@[:]/ pymysql mysql+pymysql://:@/[?] MySQL-Connector mysql+mysqlconnector://:@[:]/ cx_Oracle oracle+cx_oracle://user:pass@host:port/dbname[?key=value&key=value...] 创建单表 SQLAlchemy不允许修改表结构，如果需要修改表结构则必须删除旧表，再创建新表，或者执行原生的SQL语句ALERT TABLE进行修改。 这意味着在使用非原生SQL语句修改表结构时，表中已有的所有记录将会丢失，所以我们最好一次性的设计好整个表结构避免后期修改： # models.py import datetime from sqlalchemy.orm import sessionmaker from sqlalchemy.orm import scoped_session from sqlalchemy import ( create_engine, Column, Integer, String, Enum, DECIMAL, DateTime, Boolean, UniqueConstraint, Index ) from sqlalchemy.ext.declarative import declarative_base # 基础类 Base = declarative_base() # 创建引擎 engine = create_engine( \"mysql+pymysql://tom:123@192.168.0.120:3306/db1?charset=utf8mb4\", # \"mysql+pymysql://tom@127.0.0.1:3306/db1?charset=utf8mb4\", # 无密码时 # 超过链接池大小外最多创建的链接 max_overflow=0, # 链接池大小 pool_size=5, # 链接池中没有可用链接则最多等待的秒数，超过该秒数后报错 pool_timeout=10, # 多久之后对链接池中的链接进行一次回收 pool_recycle=1, # 查看原生语句（未格式化） echo=True ) # 绑定引擎 Session = sessionmaker(bind=engine) # 创建数据库链接池，直接使用session即可为当前线程拿出一个链接对象conn # 内部会采用threading.local进行隔离 session = scoped_session(Session) class UserInfo(Base): \"\"\" 必须继承Base \"\"\" # 数据库中存储的表名 __tablename__ = \"userInfo\" # 对于必须插入的字段，采用nullable=False进行约束，它相当于NOT NULL id = Column(Integer, primary_key=True, autoincrement=True, comment=\"主键\") name = Column(String(32), index=True, nullable=False, comment=\"姓名\") age = Column(Integer, nullable=False, comment=\"年龄\") phone = Column(DECIMAL(6), nullable=False, unique=True, comment=\"手机号\") address = Column(String(64), nullable=False, comment=\"地址\") # 对于非必须插入的字段，不用采取nullable=False进行约束 gender = Column(Enum(\"male\", \"female\"), default=\"male\", comment=\"性别\") create_time = Column( DateTime, default=datetime.datetime.now, comment=\"创建时间\") last_update_time = Column( DateTime, onupdate=datetime.datetime.now, comment=\"最后更新时间\") delete_status = Column(Boolean(), default=False, comment=\"是否删除\") __table__args__ = ( UniqueConstraint(\"name\", \"age\", \"phone\"), # 联合唯一约束 Index(\"name\", \"addr\", unique=True), # 联合唯一索引 ) def __str__(self): return f\"object : \" if __name__ == \"__main__\": # 删除表 Base.metadata.drop_all(engine) # 创建表 Base.metadata.create_all(engine) 记录操作 新增记录 新增单条记录： # 获取链接池、ORM表对象 import models user_instance = models.UserInfo( name=\"Jack\", age=18, phone=330621, address=\"Beijing\", gender=\"male\" ) models.session.add(user_instance) # 提交 models.session.commit() # 关闭链接，亦可使用session.remove()，它将回收该链接 models.session.close() 批量新增 批量新增能减少TCP链接次数，提升插入性能： # 获取链接池、ORM表对象 import models user_instance1 = models.UserInfo( name=\"Tom\", age=19, phone=330624, address=\"Shanghai\", gender=\"male\" ) user_instance2 = models.UserInfo( name=\"Mary\", age=20, phone=330623, address=\"Chongqing\", gender=\"female\" ) models.session.add_all( ( user_instance1, user_instance2 ) ) # 提交 models.session.commit() # 关闭链接，亦可使用session.remove()，它将回收该链接 models.session.close() 修改记录 修改某些记录： # 获取链接池、ORM表对象 import models # 修改的信息： # - Jack -> Jack + son # 在SQLAlchemy中，四则运算符号只能用于数值类型 # 如果是字符串类型需要在原本的基础值上做改变，必须设置 # - age -> age + 1 # synchronize_session=False models.session.query(models.UserInfo)\\ .filter_by(name=\"Jack\")\\ .update( { \"name\": models.UserInfo.name + \"son\", \"age\": models.UserInfo.age + 1 }, synchronize_session=False ) # 本次修改具有字符串字段在原值基础上做更改的操作，所以必须添加 # synchronize_session=False # 如果只修改年龄，则不用添加 # 提交 models.session.commit() # 关闭链接，亦可使用session.remove()，它将回收该链接 models.session.close() 删除记录 删除记录用的比较少，了解即可，一般都是像上面那样增加一个delete_status的字段，如果为1则代表删除： # 获取链接池、ORM表对象 import models models.session.query(models.UserInfo).filter_by(name=\"Mary\").delete() # 提交 models.session.commit() # 关闭链接，亦可使用session.remove()，它将回收该链接 models.session.close() 单表查询 基本查询 查所有记录、所有字段，all()方法将返回一个列表，内部包裹着每一行的记录对象： # 获取链接池、ORM表对象 import models result = models.session.query(models.UserInfo)\\ .all() print(result) # [, ] for row in result: print(row) # object : # object : # 关闭链接，亦可使用session.remove()，它将回收该链接 models.session.close() 查所有记录、某些字段（注意，下面返回的元组实际上是一个命名元组，可以直接通过.操作符进行操作）： # 获取链接池、ORM表对象 import models result = models.session.query( models.UserInfo.id, models.UserInfo.name, models.UserInfo.age ).all() print(result) # [(1, 'Jackson', 19), (2, 'Tom', 19)] for row in result: print(row) # (1, 'Jackson', 19) # (2, 'Tom', 19) # 关闭链接，亦可使用session.remove()，它将回收该链接 models.session.close() 只拿第一条记录，first()方法将返回单条记录对象（注意，下面返回的元组实际上是一个命名元组，可以直接通过.操作符进行操作）： # 获取链接池、ORM表对象 import models result = models.session.query( models.UserInfo.id, models.UserInfo.name, models.UserInfo.age ).first() print(result) # (1, 'Jackson', 19) # 关闭链接，亦可使用session.remove()，它将回收该链接 models.session.close() AS别名 通过字段的label()方法，我们可以为它取一个别名： # 获取链接池、ORM表对象 import models result = models.session.query( models.UserInfo.name.label(\"s_name\"), models.UserInfo.age.label(\"s_age\") ).all() for row in result: print(row.s_name) print(row.s_age) # 关闭链接，亦可使用session.remove()，它将回收该链接 models.session.close() 条件查询 一个条件的过滤： # 获取链接池、ORM表对象 import models result = models.session.query( models.UserInfo, ).filter( models.UserInfo.name == \"Jackson\" ).all() # 上面是Python语句形式的过滤条件，由filter方法调用 # 亦可以使用ORM的形式进行过滤，通过filter_by方法调用 # 如下所示 # .filter_by(name=\"Jackson\").all() # 个人更推荐使用filter过滤，它看起来更直观，更简单，可以支持 == != > = ] # 关闭链接，亦可使用session.remove()，它将回收该链接 models.session.close() AND查询： # 获取链接池、ORM表对象 import models # 导入AND from sqlalchemy import and_ result = models.session.query( models.UserInfo, ).filter( and_( models.UserInfo.name == \"Jackson\", models.UserInfo.gender == \"male\" ) ).all() # 过滤成功的结果数量 print(len(result)) # 1 # 过滤成功的结果 print(result) # [] # 关闭链接，亦可使用session.remove()，它将回收该链接 models.session.close() OR查询： # 获取链接池、ORM表对象 import models # 导入OR from sqlalchemy import or_ result = models.session.query( models.UserInfo, ).filter( or_( models.UserInfo.name == \"Jackson\", models.UserInfo.gender == \"male\" ) ).all() # 过滤成功的结果数量 print(len(result)) # 1 # 过滤成功的结果 print(result) # [] # 关闭链接，亦可使用session.remove()，它将回收该链接 models.session.close() NOT查询： # 获取链接池、ORM表对象 import models # 导入NOT from sqlalchemy import not_ result = models.session.query( models.UserInfo, ).filter( not_( models.UserInfo.name == \"Jackson\", ) ).all() # 过滤成功的结果数量 print(len(result)) # 1 # 过滤成功的结果 print(result) # [] # 关闭链接，亦可使用session.remove()，它将回收该链接 models.session.close() 范围查询 BETWEEN查询： # 获取链接池、ORM表对象 import models result = models.session.query( models.UserInfo, ).filter( models.UserInfo.age.between(15, 21) ).all() # 过滤成功的结果数量 print(len(result)) # 1 # 过滤成功的结果 print(result) # [] # 关闭链接，亦可使用session.remove()，它将回收该链接 models.session.close() 包含查询 IN查询： # 获取链接池、ORM表对象 import models result = models.session.query( models.UserInfo, ).filter( models.UserInfo.age.in_((18, 19, 20)) ).all() # 过滤成功的结果数量 print(len(result)) # 2 # 过滤成功的结果 print(result) # [, ] # 关闭链接，亦可使用session.remove()，它将回收该链接 models.session.close() NOT IN，只需要加上~即可： # 获取链接池、ORM表对象 import models result = models.session.query( models.UserInfo, ).filter( ~models.UserInfo.age.in_((18, 19, 20)) ).all() # 过滤成功的结果数量 print(len(result)) # 0 # 过滤成功的结果 print(result) # [] # 关闭链接，亦可使用session.remove()，它将回收该链接 models.session.close() 模糊匹配 LIKE查询： # 获取链接池、ORM表对象 import models result = models.session.query( models.UserInfo, ).filter( models.UserInfo.name.like(\"Jack%\") ).all() # 过滤成功的结果数量 print(len(result)) # 1 # 过滤成功的结果 print(result) # [] # 关闭链接，亦可使用session.remove()，它将回收该链接 models.session.close() 分页查询 对结果all()返回的列表进行一次切片即可： # 获取链接池、ORM表对象 import models result = models.session.query( models.UserInfo, ).all()[0:1] # 过滤成功的结果数量 print(len(result)) # 1 # 过滤成功的结果 print(result) # [] # 关闭链接，亦可使用session.remove()，它将回收该链接 models.session.close() 排序查询 ASC升序、DESC降序，需要指定排序规则： # 获取链接池、ORM表对象 import models result = models.session.query( models.UserInfo, ).filter( models.UserInfo.age > 12 ).order_by( models.UserInfo.age.desc() ).all() # 过滤成功的结果数量 print(len(result)) # 2 # 过滤成功的结果 print(result) # [, ] # 关闭链接，亦可使用session.remove()，它将回收该链接 models.session.close() 聚合分组 聚合分组与having过滤： # 获取链接池、ORM表对象 import models # 导入聚合函数 from sqlalchemy import func result = models.session.query( func.sum(models.UserInfo.age) ).group_by( models.UserInfo.gender ).having( func.sum(models.UserInfo.id > 1) ).all() # 过滤成功的结果数量 print(len(result)) # 1 # 过滤成功的结果 print(result) # [(Decimal('38'),)] # 关闭链接，亦可使用session.remove()，它将回收该链接 models.session.close() 多表查询 多表创建 五表关系： 建表语句： # models.py from sqlalchemy.orm import sessionmaker from sqlalchemy.orm import scoped_session from sqlalchemy.orm import relationship from sqlalchemy import ( create_engine, Column, Integer, Date, String, Enum, ForeignKey, UniqueConstraint, ) from sqlalchemy.ext.declarative import declarative_base # 基础类 Base = declarative_base() # 创建引擎 engine = create_engine( \"mysql+pymysql://tom:123@192.168.0.120:3306/db1?charset=utf8mb4\", # \"mysql+pymysql://tom@127.0.0.1:3306/db1?charset=utf8mb4\", # 无密码时 # 超过链接池大小外最多创建的链接 max_overflow=0, # 链接池大小 pool_size=5, # 链接池中没有可用链接则最多等待的秒数，超过该秒数后报错 pool_timeout=10, # 多久之后对链接池中的链接进行一次回收 pool_recycle=1, # 查看原生语句 # echo=True ) # 绑定引擎 Session = sessionmaker(bind=engine) # 创建数据库链接池，直接使用session即可为当前线程拿出一个链接对象 # 内部会采用threading.local进行隔离 session = scoped_session(Session) class StudentsNumberInfo(Base): \"\"\"学号表\"\"\" __tablename__ = \"studentsNumberInfo\" id = Column(Integer, primary_key=True, autoincrement=True, comment=\"主键\") number = Column(Integer, nullable=False, unique=True, comment=\"学生编号\") admission = Column(Date, nullable=False, comment=\"入学时间\") graduation = Column(Date, nullable=False, comment=\"毕业时间\") class TeachersInfo(Base): \"\"\"教师表\"\"\" __tablename__ = \"teachersInfo\" id = Column(Integer, primary_key=True, autoincrement=True, comment=\"主键\") number = Column(Integer, nullable=False, unique=True, comment=\"教师编号\") name = Column(String(64), nullable=False, comment=\"教师姓名\") gender = Column(Enum(\"male\", \"female\"), nullable=False, comment=\"教师性别\") age = Column(Integer, nullable=False, comment=\"教师年龄\") class ClassesInfo(Base): \"\"\"班级表\"\"\" __tablename__ = \"classesInfo\" id = Column(Integer, primary_key=True, autoincrement=True, comment=\"主键\") number = Column(Integer, nullable=False, unique=True, comment=\"班级编号\") name = Column(String(64), nullable=False, unique=True, comment=\"班级名称\") # 一对一关系必须为连接表的连接字段创建UNIQUE的约束，这样才能是一对一，否则是一对多 fk_teacher_id = Column( Integer, ForeignKey( \"teachersInfo.id\", ondelete=\"CASCADE\", onupdate=\"CASCADE\", ), nullable=False, unique=True, comment=\"班级负责人\" ) # 下面这2个均属于逻辑字段，适用于正反向查询。在使用ORM的时候，我们不必每次都进行JOIN查询，而恰好正反向的查询使用频率会更高 # 这种逻辑字段不会在物理层面上创建，它只适用于查询，本身不占据任何数据库的空间 # sqlalchemy的正反向概念与Django有所不同，Django是外键字段在那边，那边就作为正 # 而sqlalchemy是relationship字段在那边，那边就作为正 # 比如班级表拥有 relationship 字段，而老师表不曾拥有 # 那么用班级表的这个relationship字段查老师时，就称为正向查询 # 反之，如果用老师来查班级，就称为反向查询 # 另外对于这个逻辑字段而言，根据不同的表关系，创建的位置也不一样： # - 1 TO 1：建立在任意一方均可，查询频率高的一方最好 # - 1 TO M：建立在M的一方 # - M TO M：中间表中建立2个逻辑字段，这样任意一方都可以先反向，再正向拿到另一方 # - 遵循一个原则，ForeignKey建立在那个表上，那个表上就建立relationship # - 有几个ForeignKey，就建立几个relationship # 总而言之，使用ORM与原生SQL最直观的区别就是正反向查询能带来更高的代码编写效率，也更加简单 # 甚至我们可以不用外键约束，只创建这种逻辑字段，让表与表之间的耦合度更低，但是这样要避免脏数据的产生 # 班级负责人，这里是一对一关系，一个班级只有一个负责人 leader_teacher = relationship( # 正向查询时所链接的表，当使用 classesInfo.leader_teacher 时，它将自动指向fk的那一条记录 \"TeachersInfo\", # 反向查询时所链接的表，当使用 teachersInfo.leader_class 时，它将自动指向该老师所管理的班级 backref=\"leader_class\", ) class ClassesAndTeachersRelationship(Base): \"\"\"任教老师与班级的关系表\"\"\" __tablename__ = \"classesAndTeachersRelationship\" id = Column(Integer, primary_key=True, autoincrement=True, comment=\"主键\") # 中间表中注意不要设置单列的UNIQUE约束，否则就会变为一对一 fk_teacher_id = Column( Integer, ForeignKey( \"teachersInfo.id\", ondelete=\"CASCADE\", onupdate=\"CASCADE\", ), nullable=False, comment=\"教师记录\" ) fk_class_id = Column( Integer, ForeignKey( \"classesInfo.id\", ondelete=\"CASCADE\", onupdate=\"CASCADE\", ), nullable=False, comment=\"班级记录\" ) # 多对多关系的中间表必须使用联合唯一约束，防止出现重复数据 __table_args__ = ( UniqueConstraint(\"fk_teacher_id\", \"fk_class_id\"), ) # 逻辑字段 # 给班级用的，查看所有任教老师 mid_to_teacher = relationship( \"TeachersInfo\", backref=\"mid\", ) # 给老师用的，查看所有任教班级 mid_to_class = relationship( \"ClassesInfo\", backref=\"mid\" ) class StudentsInfo(Base): \"\"\"学生信息表\"\"\" __tablename__ = \"studentsInfo\" id = Column(Integer, primary_key=True, autoincrement=True, comment=\"主键\") name = Column(String(64), nullable=False, comment=\"学生姓名\") gender = Column(Enum(\"male\", \"female\"), nullable=False, comment=\"学生性别\") age = Column(Integer, nullable=False, comment=\"学生年龄\") # 外键约束 # 一对一关系必须为连接表的连接字段创建UNIQUE的约束，这样才能是一对一，否则是一对多 fk_student_id = Column( Integer, ForeignKey( \"studentsNumberInfo.id\", ondelete=\"CASCADE\", onupdate=\"CASCADE\" ), nullable=False, comment=\"学生编号\" ) # 相比于一对一，连接表的连接字段不用UNIQUE约束即为多对一关系 fk_class_id = Column( Integer, ForeignKey( \"classesInfo.id\", ondelete=\"CASCADE\", onupdate=\"CASCADE\" ), comment=\"班级编号\" ) # 逻辑字段 # 所在班级, 这里是一对多关系，一个班级中可以有多名学生 from_class = relationship( \"ClassesInfo\", backref=\"have_student\", ) # 学生学号，这里是一对一关系，一个学生只能拥有一个学号 number_info = relationship( \"StudentsNumberInfo\", backref=\"student_info\", ) if __name__ == \"__main__\": # 删除表 Base.metadata.drop_all(engine) # 创建表 Base.metadata.create_all(engine) 插入数据： # 获取链接池、ORM表对象 import models import datetime models.session.add_all( ( # 插入学号表数据 models.StudentsNumberInfo( number=160201, admission=datetime.datetime(2016, 9, 1).date(), graduation=datetime.datetime(2021, 6, 15).date() ), models.StudentsNumberInfo( number=160101, admission=datetime.datetime(2016, 9, 1).date(), graduation=datetime.datetime(2021, 6, 15).date() ), models.StudentsNumberInfo( number=160301, admission=datetime.datetime(2016, 9, 1).date(), graduation=datetime.datetime(2021, 6, 15).date() ), models.StudentsNumberInfo( number=160102, admission=datetime.datetime(2016, 9, 1).date(), graduation=datetime.datetime(2021, 6, 15).date() ), models.StudentsNumberInfo( number=160302, admission=datetime.datetime(2016, 9, 1).date(), graduation=datetime.datetime(2021, 6, 15).date() ), models.StudentsNumberInfo( number=160202, admission=datetime.datetime(2016, 9, 1).date(), graduation=datetime.datetime(2021, 6, 15).date() ), # 插入教师表数据 models.TeachersInfo( number=3341, name=\"David\", gender=\"male\", age=32, ), models.TeachersInfo( number=3342, name=\"Jason\", gender=\"male\", age=30, ), models.TeachersInfo( number=3343, name=\"Lisa\", gender=\"female\", age=28, ), # 插入班级表数据 models.ClassesInfo( number=1601, name=\"one year one class\", fk_teacher_id=1 ), models.ClassesInfo( number=1602, name=\"one year two class\", fk_teacher_id=2 ), models.ClassesInfo( number=1603, name=\"one year three class\", fk_teacher_id=3 ), # 插入中间表数据 models.ClassesAndTeachersRelationship( fk_class_id=1, fk_teacher_id=1 ), models.ClassesAndTeachersRelationship( fk_class_id=2, fk_teacher_id=1 ), models.ClassesAndTeachersRelationship( fk_class_id=3, fk_teacher_id=1 ), models.ClassesAndTeachersRelationship( fk_class_id=1, fk_teacher_id=2 ), models.ClassesAndTeachersRelationship( fk_class_id=3, fk_teacher_id=3 ), # 插入学生表数据 models.StudentsInfo( name=\"Jack\", gender=\"male\", age=17, fk_student_id=1, fk_class_id=2 ), models.StudentsInfo( name=\"Tom\", gender=\"male\", age=18, fk_student_id=2, fk_class_id=1 ), models.StudentsInfo( name=\"Mary\", gender=\"female\", age=16, fk_student_id=3, fk_class_id=3 ), models.StudentsInfo( name=\"Anna\", gender=\"female\", age=17, fk_student_id=4, fk_class_id=1 ), models.StudentsInfo( name=\"Bobby\", gender=\"male\", age=18, fk_student_id=6, fk_class_id=2 ), ) ) models.session.commit() # 关闭链接，亦可使用session.remove()，它将回收该链接 models.session.close() JOIN查询 INNER JOIN： # 获取链接池、ORM表对象 import models result = models.session.query( models.StudentsInfo.name, models.StudentsNumberInfo.number, models.ClassesInfo.number ).join( models.StudentsNumberInfo, models.StudentsInfo.fk_student_id == models.StudentsNumberInfo.id ).join( models.ClassesInfo, models.StudentsInfo.fk_class_id == models.ClassesInfo.id ).all() print(result) # [('Jack', 160201, 1602), ('Tom', 160101, 1601), ('Mary', 160301, 1603), ('Anna', 160102, 1601), ('Bobby', 160202, 1602)] # 关闭链接，亦可使用session.remove()，它将回收该链接 models.session.close() LEFT JOIN只需要在每个JOIN中指定isouter关键字参数为True即可： session.query( 左表.字段, 右表.字段 ) .join( 右表, 链接条件, isouter=True ).all() RIGHT JOIN需要换表的位置，SQLALchemy本身并未提供RIGHT JOIN，所以使用时一定要注意驱动顺序，小表驱动大表（如果不注意顺序，MySQL优化器内部也会优化）： session.query( 左表.字段, 右表.字段 ) .join( 左表, 链接条件, isouter=True ).all() UNION&UNION ALL 将多个查询结果联合起来，必须使用filter()，后面不加all()方法。 因为all()会返回一个列表，而filter()返回的是一个查询对象，此外，必须单拿某一个字段，不能不指定字段直接query()： # 获取链接池、ORM表对象 import models students_name = models.session.query(models.StudentsInfo.name).filter() students_number = models.session.query(models.StudentsNumberInfo.number)\\ .filter() class_name = models.session.query(models.ClassesInfo.name).filter() result = students_name.union_all(students_number).union_all(class_name) print(result.all()) # [ # ('Jack',), ('Tom',), ('Mary',), ('Anna',), ('Bobby',), # ('160101',), ('160102',), ('160201',), ('160202',), ('160301',), ('160302',), # ('one year one class',), ('one year three class',), ('one year two class',) # ] # 关闭链接，亦可使用session.remove()，它将回收该链接 models.session.close() 子查询 子查询使用subquery()实现，如下所示，查询每个班级中年龄最小的人： # 获取链接池、ORM表对象 import models from sqlalchemy import func # 子查询中所有字段的访问都需要加上c的前缀 # 如 sub_query.c.id、 sub_query.c.name等 sub_query = models.session.query( # 使用label()来为字段AS一个别名 # 后续访问需要通过sub_query.c.alias进行访问 func.min(models.StudentsInfo.age).label(\"min_age\"), models.ClassesInfo.id, models.ClassesInfo.name ).join( models.ClassesInfo, models.StudentsInfo.fk_class_id == models.ClassesInfo.id ).group_by( models.ClassesInfo.id ).subquery() result = models.session.query( models.StudentsInfo.name, sub_query.c.min_age, sub_query.c.name ).join( sub_query, sub_query.c.id == models.StudentsInfo.fk_class_id ).filter( sub_query.c.min_age == models.StudentsInfo.age ) print(result.all()) # [('Jack', 17, 'one year two class'), ('Mary', 16, 'one year three class'), ('Anna', 17, 'one year one class')] # 关闭链接，亦可使用session.remove()，它将回收该链接 models.session.close() 正反查询 上面我们都是通过JOIN进行查询的，实际上我们也可以通过逻辑字段relationship进行查询。 下面是正向查询的示例，正向查询是指从有relationship逻辑字段的表开始查询： # 查询所有学生的所在班级，我们可以通过学生的from_class字段拿到其所在班级 # 另外，对于学生来说，班级只能有一个，所以have_student应当是一个对象 # 获取链接池、ORM表对象 import models students_lst = models.session.query( models.StudentsInfo ).all() for row in students_lst: print(f\"\"\" student name : {row.name} from : {row.from_class.name} \"\"\") # student name : Mary # from : one year three class # student name : Anna # from : one year one class # student name : Bobby # from : one year two class # 关闭链接，亦可使用session.remove()，它将回收该链接 models.session.close() 下面是反向查询的示例，反向查询是指从没有relationship逻辑字段的表开始查询： # 查询所有班级中的所有学生，学生表中有relationship，并且它的backref为have_student，所以我们可以通过班级.have_student来获取所有学生记录 # 另外，对于班级来说，学生可以有多个，所以have_student应当是一个序列 # 获取链接池、ORM表对象 import models classes_lst = models.session.query( models.ClassesInfo ).all() for row in classes_lst: print(\"class name :\", row.name) for student in row.have_student: print(\"student name :\", student.name) # class name : one year one class # student name : Jack # student name : Anna # class name : one year two class # student name : Tom # class name : one year three class # student name : Mary # student name : Bobby # 关闭链接，亦可使用session.remove()，它将回收该链接 models.session.close() 总结，正向查询的逻辑字段总是得到一个对象，反向查询的逻辑字段总是得到一个列表。 反向方法 使用逻辑字段relationship可以直接对一些跨表记录进行增删改查。 由于逻辑字段是一个类似于列表的存在（仅限于反向查询，正向查询总是得到一个对象），所以列表的绝大多数方法都能用。 - append() - clear() - copy() - count() - extend() - index() - insert() - pop() - remove() - reverse() - sort() 下面不再进行实机演示，因为我们上面的几张表中做了很多约束。 # 比如 # 给老师增加班级 result = session.query(Teachers).first() # extend方法： result.re_class.extend([ Classes(name=\"三年级一班\",), Classes(name=\"三年级二班\",), ]) # 比如 # 减少老师所在的班级 result = session.query(Teachers).first() # 待删除的班级对象,集合查找比较快 delete_class_set = { session.query(Classes).filter_by(id=7).first(), session.query(Classes).filter_by(id=8).first(), } # 循换老师所在的班级 # remove方法： for class_obj in result.re_class: if class_obj in delete_class_set: result.re_class.remove(class_obj) # 比如 # 清空老师所任教的所有班级 # 拿出一个老师 result = session.query(Teachers).first() result.re_class.clear() 查询案例 1）查看每个班级共有多少学生： JOIN查询： # 获取链接池、ORM表对象 import models from sqlalchemy import func result = models.session.query( models.ClassesInfo.name, func.count(models.StudentsInfo.id) ).join( models.StudentsInfo, models.ClassesInfo.id == models.StudentsInfo.fk_class_id ).group_by( models.ClassesInfo.id ).all() print(result) # [('one year one class', 2), ('one year two class', 2), ('one year three class', 1)] # 关闭链接，亦可使用session.remove()，它将回收该链接 models.session.close() 正反查询： # 获取链接池、ORM表对象 import models result = {} class_lst = models.session.query( models.ClassesInfo ).all() for row in class_lst: for student in row.have_student: count = result.setdefault(row.name, 0) result[row.name] = count + 1 print(result.items()) # dict_items([('one year one class', 2), ('one year two class', 2), ('one year three class', 1)]) # 关闭链接，亦可使用session.remove()，它将回收该链接 models.session.close() 2）查看每个学生的入学、毕业年份以及所在的班级名称： JOIN查询： # 获取链接池、ORM表对象 import models result = models.session.query( models.StudentsNumberInfo.number, models.StudentsInfo.name, models.ClassesInfo.name, models.StudentsNumberInfo.admission, models.StudentsNumberInfo.graduation ).join( models.StudentsInfo, models.StudentsInfo.fk_class_id == models.ClassesInfo.id ).join( models.StudentsNumberInfo, models.StudentsNumberInfo.id == models.StudentsInfo.fk_student_id ).order_by( models.StudentsNumberInfo.number.asc() ).all() print(result) # [ # (160101, 'Tom', 'one year one class', datetime.date(2016, 9, 1), datetime.date(2021, 6, 15)), # (160102, 'Anna', 'one year one class', datetime.date(2016, 9, 1), datetime.date(2021, 6, 15)), # (160201, 'Jack', 'one year two class', datetime.date(2016, 9, 1), datetime.date(2021, 6, 15)), # (160202, 'Bobby', 'one year two class', datetime.date(2016, 9, 1), datetime.date(2021, 6, 15)), # (160301, 'Mary', 'one year three class', datetime.date(2016, 9, 1), datetime.date(2021, 6, 15)) # ] # 关闭链接，亦可使用session.remove()，它将回收该链接 models.session.close() 正反查询： # 获取链接池、ORM表对象 import models result = [] student_lst = models.session.query( models.StudentsInfo ).all() for row in student_lst: result.append(( row.number_info.number, row.name, row.from_class.name, row.number_info.admission, row.number_info.graduation )) print(result) # [ # (160101, 'Tom', 'one year one class', datetime.date(2016, 9, 1), datetime.date(2021, 6, 15)), # (160102, 'Anna', 'one year one class', datetime.date(2016, 9, 1), datetime.date(2021, 6, 15)), # (160201, 'Jack', 'one year two class', datetime.date(2016, 9, 1), datetime.date(2021, 6, 15)), # (160202, 'Bobby', 'one year two class', datetime.date(2016, 9, 1), datetime.date(2021, 6, 15)), # (160301, 'Mary', 'one year three class', datetime.date(2016, 9, 1), datetime.date(2021, 6, 15)) # ] # 关闭链接，亦可使用session.remove()，它将回收该链接 models.session.close() 3）查看David所教授的学生中年龄最小的学生： JOIN查询： # 获取链接池、ORM表对象 import models result = models.session.query( models.TeachersInfo.name, models.StudentsInfo.name, models.StudentsInfo.age, models.ClassesInfo.name ).join( models.ClassesAndTeachersRelationship, models.ClassesAndTeachersRelationship.fk_class_id == models.ClassesInfo.id ).join( models.TeachersInfo, models.ClassesAndTeachersRelationship.fk_teacher_id == models.TeachersInfo.id ).join( models.StudentsInfo, models.StudentsInfo.fk_class_id == models.ClassesInfo.id ).filter( models.TeachersInfo.name == \"David\" ).order_by( models.StudentsInfo.age.asc(), models.StudentsInfo.id.asc() ).limit(1).all() print(result) # [('David', 'Mary', 16, 'one year three class')] # 关闭链接，亦可使用session.remove()，它将回收该链接 models.session.close() 正反查询： # 获取链接池、ORM表对象 import models david = models.session.query( models.TeachersInfo ).filter( models.TeachersInfo.name == \"David\" ).first() student_lst = [] # 反向查询拿到任教班级，反向是一个列表，所以直接for for row in david.mid: cls = row.mid_to_class # 通过任教班级，反向拿到其下的所有学生 cls_students = cls.have_student # 遍历学生 for student in cls_students: student_lst.append( ( david.name, student.name, student.age, cls.name ) ) # 筛选出年龄最小的 min_age_student_lst = sorted( student_lst, key=lambda tpl: tpl[2])[0] print(min_age_student_lst) # ('David', 'Mary', 16, 'one year three class') # 关闭链接，亦可使用session.remove()，它将回收该链接 models.session.close() 4）查看每个班级的负责人是谁，以及任课老师都有谁： JOIN查询： # 获取链接池、ORM表对象 import models from sqlalchemy import func # 先查任课老师 sub_query = models.session.query( models.ClassesAndTeachersRelationship.fk_class_id.label(\"class_id\"), func.group_concat(models.TeachersInfo.name).label(\"have_teachers\") ).join( models.ClassesInfo, models.ClassesAndTeachersRelationship.fk_class_id == models.ClassesInfo.id ).join( models.TeachersInfo, models.ClassesAndTeachersRelationship.fk_teacher_id == models.TeachersInfo.id ).group_by( models.ClassesAndTeachersRelationship.fk_class_id ).subquery() result = models.session.query( models.ClassesInfo.name.label(\"class_name\"), models.TeachersInfo.name.label(\"leader_teacher\"), sub_query.c.have_teachers.label(\"have_teachers\") ).join( models.TeachersInfo, models.ClassesInfo.fk_teacher_id == models.TeachersInfo.id ).join( sub_query, sub_query.c.class_id == models.ClassesInfo.id ).all() print(result) # [('one year one class', 'David', 'Jason,David'), ('one year two class', 'Jason', 'David'), ('one year three class', 'Lisa', 'David,Lisa')] # 关闭链接，亦可使用session.remove()，它将回收该链接 models.session.close() 正反查询： # 获取链接池、ORM表对象 import models result = [] # 获取所有班级 classes_lst = models.session.query( models.ClassesInfo ).all() for cls in classes_lst: cls_message = [ cls.name, cls.leader_teacher.name, [], ] for row in cls.mid: cls_message[-1].append(row.mid_to_teacher.name) result.append(cls_message) print(result) # [['one year one class', 'David', ['David', 'Jason']], ['one year two class', 'Jason', ['David']], ['one year three class', 'Lisa', ['David', 'Lisa']]] # 关闭链接，亦可使用session.remove()，它将回收该链接 models.session.close() 原生SQL 查看执行命令 如果一条查询语句是filter()结尾，则该对象的__str__方法会返回格式化后的查询语句： print( models.session.query(models.StudentsInfo).filter() ) SELECT `studentsInfo`.id AS `studentsInfo_id`, `studentsInfo`.name AS `studentsInfo_name`, `studentsInfo`.gender AS `studentsInfo_gender`, `studentsInfo`.age AS `studentsInfo_age`, `studentsInfo`.fk_student_id AS `studentsInfo_fk_student_id`, `studentsInfo`.fk_class_id AS `studentsInfo_fk_class_id` FROM `studentsInfo` 执行原生命令 执行原生命令可使用session.execute()方法执行，它将返回一个cursor游标对象，如下所示： # 获取链接池、ORM表对象 import models cursor = models.session.execute( \"SELECT * FROM studentsInfo WHERE id = (:uid)\", params={'uid': 1}) print(cursor.fetchall()) # 关闭链接，亦可使用session.remove()，它将回收该链接 models.session.close() Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:46 "},"前端专栏/summary.html":{"url":"前端专栏/summary.html","title":"前端专栏","keywords":"","body":" HTML CSS JavaScript jQuery Vue3 Webpack5 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:48 "},"前端专栏/HTML/summary.html":{"url":"前端专栏/HTML/summary.html","title":"HTML","keywords":"","body":" 基础知识 声明系标签 结构系标签 文本系标签 链接系标签 列表系标签 表格系标签 表单系标签 媒体系标签 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:48 "},"前端专栏/HTML/基础知识.html":{"url":"前端专栏/HTML/基础知识.html","title":"基础知识","keywords":"","body":"基础介绍 HTML全称为htyper text markup language，即超文本标记语言。 超文本：即超出了纯文字文本的范畴，它可以包含图片、链接、音乐等非文字元素 标记语言：由标签构成的语言，特点是学习简单上手容易 它最早诞生于1990年，由物理学家蒂姆·伯纳斯-李所创建，在1989年的时候蒂姆·伯纳斯-李就曾在一份备忘录中提出一个基于互联网的超文本系统这样的概念，并且在1990年规定出了HTML并在同年写出了浏览器与软件： 版本 年份 HTML 1991 HTML+ 1993 HTML 2.0 1995 HTML 3.2 1997 HTML 4.01 1999 XHTML 1.0 2000 HTML5 2012 XHTML5 2013 浏览器的作用 其实我们平时上网的过程就是一个不断上传、下载的过程。 浏览器会将我们输入的网址进行解析并请求服务器，服务器将资源返回后浏览器再将资源进行渲染并展示，最终构成了五彩缤纷的页面。 这里推荐大家统一使用Chrome浏览器，它应该算是目前前端开发人员首推的浏览器。 无论是渲染、调试等都是十分方便的，你可以打开浏览器后按f12得到控制台，在这里你可以做任何你想做的事。 而关于IDE的选择就有很多，你可以使用webstorm或者vscode。 认识文档树 我们拿一段最简单的HTML举例，可以暂时不用管他的内容，只看它的结构： Document HELLO WORLD 通过观察上面的这一小段代码，可以看出一个标准的HTML文档内容至少包含三部分，分别是最外部的标签，内部的标签和标签，而一个页面呈现的内容都会在标签中进行书写。 如果按照结构进行划分，那么我们就会得到一颗倒置的多叉树： 文档声明是什么 早期的浏览器种类繁杂，相同的代码在不同浏览器下的渲染结果都不相同。 为了避免这种差异化，万维网联盟（W3C）出台了一系列标准化的规范，如下这行代码： 就是声明该文档为HTML文档，告诉浏览器应当采用HTML标准模式进行渲染，如果不添加此标签代表使用浏览器自带的模式，也被称为怪异模式进行渲染，因此后面的学习中一定要将它加上。 怪异模式：BackCompat，浏览器使用自己的解析标准进行页面渲染 标准模式：CSS1Comapt，浏览器采用W3C的解析标准进行页面渲染 认识标签 什么是标签 标签是由一对儿尖括号包裹的单词构成，如就是一个标签。 标签分为闭合标签和自闭和标签。 闭合标签必须要有开始标签和结束标签，如： 自闭和标签则不需要结束标签，如： 自闭和标签我们通常会在后面加上一条斜杠，来更加容易区分： 标签名字不能以数字开头。 标签本身不区分大小写，如和渲染效果都是相同的，但是为了可读性更加推荐使用全小写。 此外，标签支持嵌套，如：，但是不支持交叉嵌套，如。 注释标签 注释标签是指不会被浏览器渲染的标签，作用是让人更好的理解这段代码的意思。 它以结尾。 内联标签 内联（inline）标签也被称为行内标签，它具有以下的一些特点： 不独占一行，可以和其他内联标签处于同一行上 不可设置宽度和高度，内联标签的宽高都是固定的 宽高本身是其内联标签文字或者图片的高度，不可以被改变 内联标签只能容纳文本或者嵌套其他的内联标签，不可嵌套块级标签 特殊的几个内联标签： img、input可以设置宽高，它们拥有内联标签和块级标签的特性，因此也被称为内联块级标签（inline-block） 块级标签 块级标签（block）常用于布局中，它具有以下的一些特点： 块级标签独占一行，这一行中不可并列其他的标签 可以设置宽度和高度 宽度的缺省值是容器的100%，除非设定一个宽度，换而言之就是一行占满 块级标签可以容纳文本或者嵌套其他的任何标签 特殊的几个块级标签： h~系、dt、p标签中只能包含内联标签，不能包含块级标签 认识属性 什么是属性 每个标签都能带上一些属性，这些属性或有特殊意义，或是开发人员自定义的用来存放某些特殊值的容器。 属性通常是以键值对形式出现，例如 gender=“male” 属性只能出现在开始标签或者自闭和标签中，不能出现在结束标签中 属性名字必须全部小写，属性值必须使用双引号或者单引号包裹，例如 gender=“male” 如果属性值合属性名一样，可以直接写属性名，例如 readonly id id属性是HTML4.0之后加入的，作用是用于定位某一个特定的标签，每一个标签的id属性在文档中必须是唯一的。 id属性在命名时，如果有多个单词则推荐使用 - 进行分割，这个主要涉及到与Js中window对象的冲突。 class class属性的作用是为一组相同功能的标签打上标识，用于对其添加CSS样式。 class属性在命名时，如果有多个单词则推荐使用 _ 进行分割，主要与id属性做区分。 文档渲染 渲染方式 浏览器的渲染是自上而下的，也就是说书写在HTML文档顶部的标签会比书写在HTML文档底部的标签先渲染到。 这个尤为重要，特别是后期学习CSS和JS的时候，它们的引入标签一般都要放在下面才能正确的找到并操纵HTML标签。 当然你也可以做一些特殊的处理，这里按下不表。 特殊字符 文档渲染的时候，有些字符不会被渲染出来。如多个空格仅显示一个，多个p标签仅一个生效等： h f 输入不会正常渲染等： 这个时候我们需要用到一些特殊字符来进行渲染，如下表所示： 特殊字符 含义 &nbsp; 空格 &lt; 小于号 &gt; 大于号 > &quot; 双引号 '' &copy; 圆圈c © &reg; 圆圈r ® &trade; 商标™ &amp; 符号& 流式排列 文档渲染的时候会按照自左向右自上而下的排列方式进行排列，这种排列方式也被称之为文档流排列。 如下所示，内联标签一行可以有多个，而块级标签独占一行。 标签修复 当一个HTML文档没有任何内容，仅只有一段文字时，浏览器会自动生成HTML结构并将文字放入body标签中： hello world 标签移动 所有的页面上展示的内容都要写在body标签中，如果写在了外面浏览器会自动将该内容移动进body标签里： Document this is title 渲染结果，h1标签被加入了body标签内： 表格处理 table标签中不允许放入非表格系的其他内容，否则浏览器在渲染时会将该内容放出去： Document this is title this is table 渲染结果，h1标签被移出了table标签内： 其他的知识 缩进规范 由于前端代码比较繁琐，故缩进推荐使用2空格进行缩进。 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:48 "},"前端专栏/HTML/声明系标签.html":{"url":"前端专栏/HTML/声明系标签.html","title":"声明系标签","keywords":"","body":"!DOCTYPE html 指定文档格式为HTML格式，浏览器会根据W3C的HTML标准格式渲染该文档中的内容。 该标签为必加标签。 html 根标签 HTML内容书写区域，也被称为根标签，所有的内容都应该写到他的内部。 属性：lang = “en” 表示页面是英文格式，翻译页面时会读取此值来获取当前页面是什么语言编写。 head 头部信息 该标签的作用是专门提供一下网页的配置信息，如网页的标题，检索内容，解码格式等等。 该部分内容虽然不会在页面展示，但也起到非常重要的作用。 title 页面标题 title标签用于指定网页的标题： link 页面图标 link标签可以设置网页标题上的图标： meta 元信息 meta标签可提供有关页面的元信息（meta-information），它能针对性的设置搜索引擎和更新频度相关的描述和关键词。 该标签位于head标签中，是一个自闭和标签。 它所提供的信息是用户不可见的。 字符编码 meta标签设置charset属性，可指定浏览器解析该文档时所使用的字符编码： Document 页面刷新 meta标签的http-equiv属性可用于页面刷新，指定该属性值为“Refresh”即可，此外你还应当在content属性中设置刷新频率。 下面这个示例中是五秒刷新一次页面，使用meta标签进行页面刷新的应用场景非常少，可忽略不计。 Document 页面跳转 meta标签的http-equiv属性还可用于页面跳转，指定该属性值为“Refresh”即可，此外你还应当在content属性中设置几秒后进行跳转，以及跳转的url，使用;进行分割。 下面这个示例中是两秒后跳转到google，使用meta标签进行页面跳转的应用场景非常少，可忽略不计。 Document 关键字筛选 meta标签的name属性可用于指定页面关键字，用于搜索引擎收录与关键字搜索。 如下所示，需要设置name属性为keywords以及在content中写入关键词即可： 网站描述 meta标签的name属性可用于书写网站描述信息，用于搜索引擎收录与网站分类。 如下所示，需要设置name属性为Description以及在content中写入网站描述即可： IE渲染 IE浏览器是前端开发领域最难搞的浏览器，因为它有一种自己的渲染规则，且每个IE版本的渲染规则都不一样。 meta标签的http-equiv属性设置为\"X-UA-Compatible”，即可告诉IE浏览器用最高级的渲染模式渲染当前页面： --> Document 国产浏览器渲染 一般的国产浏览器都会支持IE内核（兼容模式）和webkit内核（高速模式），且默认都是以兼容模式对页面进行渲染。 meta标签的name属性设置为”renderer”且content设置为“webkit”后，即可告诉国产浏览器用高速模式渲染当前页面： Document 触屏缩放 meta标签还可以设置页面是否支持触屏缩放的功能，只需将name设置为“viewport”以及在content中添加对应的选项即可。 如下所示： Document 常见的选项有： width=device-width：宽度按照设备屏幕宽度进行自适应 initial-scale=1.0：初始显示的缩放比例 minimum-scale=0.5：最小缩放比例 maximum-scale=1.0：最大缩放比例 user-scalable=yes：是否支持触屏缩放 常见的设置 上面就是关于head部分最常见的设置，最后放上一个模板： HTML学习 HELLO WORLD body 页面主体 body标签为页面主体标签，用户能看到的内容都包含在body标签内。 它里面能够书写的标签非常多，为了方便记忆我将它们分为了7类，如下所示： 文本系标签 结构系标签 链接系标签 列表系标签 表格系标签 表单系标签 媒体系标签 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:48 "},"前端专栏/HTML/结构系标签.html":{"url":"前端专栏/HTML/结构系标签.html","title":"结构系标签","keywords":"","body":"header 页眉标签 header标签代表一块内容区域的头部，一个页面中可以有一个或多个header标签。 它是一个块级标签： nav 导航标签 nav标签代表一块内容区域的导航，一个页面中可以有一个或多个nav标签。 它是一个块级标签： main 主内容标签 mian标签代表主要内容区域，一个页面中可以有一个或多个main标签，但通常只会定义一个。 它是一个块级标签： footer 页脚标签 footer标签代表一块内容区域的页脚，一个页面中可以有一个或多个footer标签，通常与header标签相对应。 它是一个块级标签： article 子内容标签 article标签代表一块子内容区域，一个页面中可以有一个或多个article标签。 它是一个块级标签： section 区块标签 article标签代表一个区块，一般是一组相似内容的排列组合，它可以有多个。 它是一个块级标签： aside 附加区域标签 aside标签代表一个附加内容块，可以放一些与主体内容无关的内容，如轮播图、广告、公告等。 它是一个块级标签： div 通用容器标签 div标签没有明确的界限来规定它做什么，与span标签类似。 上面标签能做的它都能做，所以他变成了一个万能的容器标签。 div标签是一个块级标签，你打开页面看见的都是它： Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:48 "},"前端专栏/HTML/文本系标签.html":{"url":"前端专栏/HTML/文本系标签.html","title":"文本系标签","keywords":"","body":"基础文本系标签 h~ 标题标签 h系列的标题标签拥有6个，即h1 - h6。 h系列标签会根据等级的大小，字体的粗细会发生相应的变化，h1最大、h6最小。 它是一个块级的自闭和标签，其内部只能嵌套内联标签，不能嵌套块级标签 Document h1 element h2 element h3 element h4 element h5 element h6 element 渲染结果： h~ 系列标签拥有一个属性 align，若为 \"center\" 时则标题会居中显示。 p 段落标签 p标签用于定义一段文本的内容，具有换行的功能。 p标签内只能存放文字系、图片系、表单系标签，其他的一律不要放进来，此外还需要注意p标签与br标签的区别。 它是一个块级标签： Document This is p element This is p element 渲染结果： br 换行标签 br标签用于对内容进行换行，注意与p标签的区别。 它是一个内联标签： Document This is p element This is p element this is a text this is a text 渲染结果： hr 水平线 hr标签会生成一条水平线，主要是用于对内容区域的划分。 它是一个块级标签： Document this is p element this is p element center 居中显示 center标签会将它内部的元素进行居中处理，h5中已经不推荐使用了。 它是一个块级标签： Document h1 element center h2 element don't center 渲染结果： font 普通文字 font标签没什么特别的效果，只有一个语义规定它应该包裹一串文字。被font包裹的文字可设置字体、尺寸和颜色，但是不推荐设置。 它是一个内联标签。 属性表： 属性 值 描述 color rgb(x, x, x) or #xxxxxx or color_name 设置字体颜色 face font_family 设置字体样式 size number 设置字体带下，1-7 如下所示： Document this is font 渲染结果： pre 原样显示 浏览器在渲染时，会对显示进行特殊处理，如多个空格压缩成一个。 此时可以选择使用pre标签对显示内容进行包裹，这样浏览器就不会特殊处理这一段显示内容了。 它是一个块级标签： Document A B C D E F 渲染结果： span 文本容器 span标签用于存放一些文本，它的语义并不是很明确，属于一个模糊的定位。 被span标签包裹的文本有极大的可能性后期会通过CSS进行样式修改，但若单纯使用HTML则没有任何明显的功能。 它是一个内联标签： Document #span-1{ color: red; font-style: italic; text-shadow: #ddd 5px 5px 0.4px; font-size: 22px; font-weight: bold; } This is a text 搭配CSS的渲染效果： 描述文本系标签 time 时间文本 time标签根据语义来进行区分的话可以用于存放时间类型的文本。 它是一个内联标签： Document current time 2016-02-18 渲染效果： abbr 描述文本 abbr标签用于存放一些具有描述的文本，它拥有一个title属性，title属性中可以放入一些描述信息。 当鼠标悬浮在abbr标签上，就可以显示title中所定义的描述信息。 它是一个内联标签： Document I want to say hello world 渲染效果，虽然具有下划线但是不必在意，后期CSS会帮你干掉他： sup - sub 角标 sup和sub用于定义上下角标，在书写一些数学公式时有用。 它们都是内联标签： Document sup : 3 2 sub : 3 2 渲染效果： code 代码文本 code标签中应当存放一些代码相关的文本，但是他没有任何特殊处理。 所以我们可以在外部套上pre标签，来达到代码原样显示的目的，这样代码的缩进才不会发生混乱。 它是内联标签： Document Here is a js code function show(){ console.log(\"hello world\"); } show() 渲染结果： progress 进度条 progress可生成一个进度条，它具有2个属性。 max：进度条长度 value：当前进度 后期可配合Js来进行控制。 它是一个内联标签： Document 渲染结果： address 地址信息 address用于设置地址信息。一般放在footer页脚中。 它是一个块级标签： Document 地址 : 北京市海淀区 渲染结果： 强调文本系标签 em - i 比较重要 em和i标签都意味着这段文字比较重要。 它们同属于内联标签： Document this is em element this is i element 渲染结果： strong - b 非常重要 strong和b标签都意味着这段文字非常重要。 它们同属于内联标签： Document this is strong element this is b element 渲染结果： del - s 已废弃 del和s标签都意味着这段文字已经废弃。 它们同属于内联标签： Document this is strong element this is b element 渲染结果： ins - u 已修正 ins和u标签都意味着这段文字已经修正，常和del与s标签搭配使用。 它们同属于内联标签： Document 原价：998 现价：9.8 渲染结果： mark 值得记录 mark标签都意味着这段文字值得记录，会以突出的方式进行显示。 它是一个内联标签： Document 普通文本 值得记录 渲染结果： 引用文本系标签 cite 引用信息 cite标签通常表示它所包含的文本对某个参考文献的引用，或文章作者的名字。 它属于块级标签： Document --再别康桥 &nbsp;&nbsp;轻轻的我走了，正如我轻轻地来 渲染结果： blockquote 块引用 blockquote标签通常来表示该段内容引用至其他地方。 它属于块级标签： Document --狂人日记 凡事总需研究，才会明白，古来时常吃人，我也还记得，可是不甚清楚。 我翻开历史一查，这历史没有年代，歪歪斜斜的每页上都写着“仁义道德”几个字。 我横竖睡不着，仔细看了半夜，才从字缝里看出来，满本都写着两个字是“吃人”！ 渲染结果： q 行内应用 q标签用于表示行内引用文本，在大部分浏览器中会加上引号。 它属于内联标签： Document --狂人日记 凡事总需研究，才会明白，古来时常吃人，我也还记得，可是不甚清楚。 我翻开历史一查，这历史没有年代，歪歪斜斜的每页上都写着“仁义道德”几个字。 我横竖睡不着，仔细看了半夜，才从字缝里看出来，满本都写着两个字是“吃人”！ 鲁迅先生的吃人一词用的恰到好处！ 渲染效果： Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-12-01 16:30:00 "},"前端专栏/HTML/链接系标签.html":{"url":"前端专栏/HTML/链接系标签.html","title":"链接系标签","keywords":"","body":"a 超链接 基本使用 a标签可定义一个超链接，用于从当前页面跳转到另一个页面。 a标签最重要的属性为href属性，它指向链接的目标。 它是一个内联标签： Document go to google search 渲染结果： 可以看见它虽然有一个下划线，但是不必在意，后期我们可以用CSS干掉他。 默认行为 如果一个a标签没有设置href属性的值，则默认它会刷新当前页面。 你可以给该属性的值设置为#或者“javascript:void(0)”以阻止它的默认行为： Document Don't Refresh 锚点定位 我们可以将a标签的href属性值设置为另一个标签的id属性，这样就可以做到锚点定位，href属性设置锚点的时候必须以#号跟上id的格式进行设置。 锚：指得是a标签的href属性 锚点：指的是被链接的标签id值 如下所示： Document goto chapter one goto chapter two goto chapter third goto chapter four Chapter One Chapter Two Chapter Third Chapter Four 拨打电话 针对移动端用户，a标签也可以用于拨打电话： Document call mobile customer service 渲染结果： 下载文件 如果a标签的href属性跟上一个下载链接地址，则可以下载到浏览器无法处理的文件。 如果要下载图像则需要后台语言先告知浏览器mime的类型： Document download image 常用属性 以下是a标签的常用属性： 属性 值 描述 href url 规定链接指向的url target _blank, _parent, _self, _top 规定在何处打开链接文档 title text 规定链接的标题描述 target属性是非常重要的，它有常用的4个属性，如下释义： _blank：在新窗口中打开链接文档 _parent：在父窗口中打开链接文档 _self：在当前窗口中打开链接文档（默认值） _top：在顶级窗口中打开链接文档 而title属性作用是在鼠标悬浮到a标签上时展示链接标题描述，这里不再例举。 img 图像资源 基本使用 img标签可使用src属性来链接一个图像资源，当前页面中会展示出该图像。 它是一个内联块级标签： Document 渲染结果： 三种格式 src属性支持3种格式的资源： base64位数据流格式 相对路径格式：./ 或者 ../ 网络资源格式：http:// 注意！它不支持file://，因为Unix下没有盘符的概念。 对于第一种，你可以打开网站图片数据流在线转换后传入图片获得base64位的数据流，然后添加至img标签的src属性中查看效果，这里不再进行演示。 等比缩放 如果要保证图像的等比例缩放，请只设置width和height属性其中一个。 Document 渲染结果： 图像链接 我们可以让a标签来包裹img标签，达到图像链接的目的。 前提是，a标签必须使用CSS将它设置为内联块级标签，以便内部嵌套img标签。 Document a{ display: inline-block; } 渲染效果： 常用属性 下面是img标签中常见的属性： 属性 值 描述 alt text 当图像加载失效后，将显示该属性值以替换图像 src url 图像的链接资源 width px、% 设置图像的宽度 height px、% 设置图像的高度 title text 设置图像的悬停文本 iframe 内联框架 基本使用 iframe标签的src属性可以将另外的整个页面都拿过来显示，类似于画中画的概念。 它是一个块级标签： Document Welcome to bilibili 渲染效果： 应用场景 钓鱼网站、伪Ajax请求。 iframe在实际开发中用的较少，但是在某些特定的场景下搭配一些其他的技术可达到令人意想不到的效果。 常用属性 下面是iframe标签中常见的属性： 属性 值 描述 name frame_name 规定iframe的名称 src url 规定在iframe中显示文档的url scrolling yes、no、auto 规定是否在iframe中显示滚动条 width px、% 规定iframe的宽度 height px、% 规定iframe的高度 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:48 "},"前端专栏/HTML/列表系标签.html":{"url":"前端专栏/HTML/列表系标签.html","title":"列表系标签","keywords":"","body":"ul - li 无序列表 基本使用 ul和li标签用于定义一个无序列表。 它们都是块级标签，使用ul来嵌套li标签，并在li标签中书写列表排列的元素. 你可以在li中书写任意元素，如a标签、纯文本、图片等： Document Unordered list go to google go to biying go to bilibili go to youtube 渲染结果： 样式修改 ul标签和li标签都可以修改样式，它们均有一个属性type，该属性可以定义以下的值： disc：实心圆（默认样式） circle：空心圆 square：实现块 1：数字列表（仅li支持设置） A：大写英文字母列表（仅li支持设置） a：小写英文字母列表（仅li支持设置） I：大写罗马字母列表（仅li支持设置） i：小写罗马字母列表（仅li支持设置） 如下所示： Document Unordered list set li styles separately DISC CIRCLE SQUARE Number Uppercase English letter Lowercase English letter Uppercase Rome letter Lowercase Rome letter Unordered list set ul styles unite SQUARE SQUARE SQUARE 渲染结果： 注意！当ul和li同时设置样式时，以li的样式为准。 ol - li 有序列表 基本使用 ol和li标签用于定义一个有序列表。 它们都是块级标签，使用ol来嵌套li标签，并在li标签中书写列表排列的元素。 你可以在li中书写任意元素，如a标签、纯文本、图片等： Document Ordered list go to google go to biying go to bilibili go to youtube 渲染结果： 样式修改 同ul一样，ol也支持修改列表样式，它的type属性共有以下8个值选项： disc：实心圆（默认样式） circle：空心圆 square：实现块 1：数字列表 A：大写英文字母列表 a：小写英文字母列表 I：大写罗马字母列表 i：小写罗马字母列表 我们单独设置li标签，来看一下不同的样式效果： Document Ordered list DISC CIRCLE SQUARE Number Uppercase English letter Lowercase English letter Uppercase Rome letter Lowercase Rome letter 渲染结果： 注意！当ol和li同时设置样式时，以li的样式为准。 升序降序 有序列表之所以称为有序，是因为它可以按照列表的排列对列表编号进行升序或者降序。 只需要使用ol标签的reversed属性进行设置即可，如果添加了该属性则是降序，不添加则为升序： Document asc A B C D E desc A B C D E 渲染结果： 起始值设定 给ul标签设置start属性，可用于生成初始编号，后续生成的编号都按照该初始编号进行生成： Document asc SQUARE SQUARE SQUARE SQUARE 渲染结果： dl - dt - dd 自定义列表 基本使用 使用dl、dt、dd来构建一个自定义列表，常见于小说章节预览、首页文章排列中。 dl用于声明这是一个自定义列表。 dt用于定义这是一个标题。 dd用于定义一个段落。 如下所示： Document dl dt dd Chapter One this is chapter one content ... Chapter Two this is chapter two content ... 渲染结果： Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:48 "},"前端专栏/HTML/表格系标签.html":{"url":"前端专栏/HTML/表格系标签.html","title":"表格系标签","keywords":"","body":"table 表格标签 table标签用于定义一个表格。 它是一个块级标签，内部可用于嵌套的元素较多： caption - 表格标题 thead - 表头结构（仅语义化标签，无实际作用） tbody - 表体结构（仅语义化标签，无实际作用） tfoot - 表尾结构（仅语义化标签，无实际作用） th - 表头单元格 td - 表体单元格 tr - 表行 如下所示，定义一个4行3列的表格： Document this is table name age gender Jack 18 male Mary 19 female .. .. .. 渲染结果： 边框合并 table标签应当设置的2个属性： border=\"1\" style=\"border-collapse:collapse;\" border：表格线的宽度，单位是px border-collapse：边框合并 这样看起来会好看许多： 表格大小 table标签可设置width和height属性，因此我们可以适当调整表格的大小： ... 渲染结果： 表格位置 表格的位置可以通过table标签的align属性来设置： left：表格居左 center：表格居中 right：表格居右 如下所示： ... 单元格合并 每个td或者th标签都有2个属性，rowspan和clospan，它们能够控制单元格的合并。 rowspan：纵向合并单元格（行合并） clospan：横向合并单元格（列合并） 如下所示： Document this is table name age gender other Jack 18 male Mary 19 female this is footage 渲染结果： Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:48 "},"前端专栏/HTML/表单系标签.html":{"url":"前端专栏/HTML/表单系标签.html","title":"表单系标签","keywords":"","body":"form 表单 基本介绍 form表单可用于向服务端提交数据，它是一个块级标签。 我们常见的登录框、留言板等很多功能都是通过form表单完成的，使用form表单进行数据提交会导致页面的刷新。 下面将采用flask框架作为后端，使用form表单进行一次数据提交。 后端代码，注意！表单action提交时不会触发浏览器的同源策略，所以后端并不需要做CORS： from flask import Flask from flask import request app = Flask(__name__) @app.route(\"/get\", methods=['GET']) def get_handler(): return f\"{request.args}\" @app.route(\"/post\", methods=['POST']) def post_handler(): return f\"{request.form}\" if __name__ == \"__main__\": app.run(debug=True) 前端代码： Document username password male female submit 整体效果如下： 前端提交的数据会被后端的服务器所接收到。 action 提交地址 form表单中action属性可设置表单内容的提交地址。 它指向一个url，一般情况下我们都会加上完整url，但如果你是前后端混合开发项目的话则可以不用加完整url。 下面这个是完整路径，如果点击提交表单它会朝这个url发起请求： 如果你把他改为非完整路径，它会朝当前页面发起请求，注意观察下面与上述地址栏中的端口变化： method 提交方式 form表单中的method属性可设置表单提交时的HTTP请求方式。 有2种选项： GET请求（form提交时的默认选择） POST请求 它们的区别如下。 GET请求： 没有请求体 数据必须控制在1KB之内 请求的数据会暴露在地址栏中（?之后，以&进行分割） POST请求： 有请求体 数据的大小没有上限 请求的数据不会暴露在地址栏中，因此相较于GET请求更加安全 以下行为将会触发GET请求： 地址栏直接输入地址并访问 点击页面a标签进行链接跳转 默认的form表单提交方式 img的图像资源请求 说的更直白一点，GET请求不能上传文件，但是POST请求可以上传文件。 enctype 数据编码 form表单中的enctype属性可设置表单提交时对于提交数据的编码方式。 application/x-www-form-urlencoded：url编码格式，也是form表单默认的编码格式，它不允许上传文件，一般配合GET方式使用 multipart/form-data：不对字符进行编码，它允许上传文件，一般配合POST方式进行使用 text/plain：将空格转换为“+”号，但不对特殊字符进行编码 url编码格式的特点： 将空格转换为 \"+\" 加号，特殊符号转换为 ASCII HEX 值 一言以蔽之，若想上传文件，则必须使用POST请求方式 + multipart/form-data的编码方式： target 提交结果 form表单中的target属性可设置表单提交后会在哪里打开action的提交结果。 有以下5个值： _blank：在新窗口中打开action的提交结果 _parent：在父窗口中打开action的提交结果 _self：在当前窗口中打开action的提交结果（默认值） _top：在顶级窗口中打开action的提交结果 framename：在内联框架iframe中打开action的提交结果 这个属性其实很少用到，但是该属性可以搭配一些其他的技术做到无页面刷新提交的功能，因此这里例举一下，后面也会有所介绍。 示例如下，提交后将会在新的页面打开提交结果： novalidate 取消验证 form表单中的novalidate属性可设置表单提交时不会验证填入数据的合法性。 有的input框可以设置为必填，如果一个必填的input框没有填入内容则在提交时浏览器将提示必须填写该字段，我们可以通过设定novalidate来取消这个验证功能。 如下是设置了提交验证的表单： submit 当点击提交时浏览器会提示你填入该字段： 如果为form表单加上了novalidate属性后，它将会直接提交，注意观察地址栏中的变化： submit 点击提交后页面会刷新一次，这代表已经绕过验证成功提交了： input 输入框 基本介绍 input标签为表单输入框，它是一个内联块级标签。 input框有多种形态，只需要设置属性type的值即可，如下表所示： 属性值 表现形式 对应代码 text 文本输入框 password 密码输入框 number 数字输入框 date 日期输入框 > checkbox 复选框 radio 单选框 submit 提交按钮 reset 重置按钮 button 普通按钮 hidden 隐藏输入框 file 文件选择框 image 图像域 list 数据列表栏 text 文本输入框 文本输入框可输入任何内容，它有2个最重要的属性name和value。 当form表单点击提交时，文本输入框会将输入的值赋值给value属性，并将name属性和value属性组成一组键值对提交给后端。 如果没有显式的设置value，那么这个文本输入框的内容是空的，当你输入内容后它会自动添加value属性并将所输入内容赋值给该属性： 渲染结果： 如果显式的设置了value，那么它就会作为默认值显示在文本输入框中： 渲染结果： 我们一般都不会这样做，而是利用placeholder属性来提示用户应该输入什么内容，placeholder属性在form表单提交时并不会被收集： 渲染结果： 除此之外，你可以使用required属性来规定该输入框是必填项，前提是form表单验证已被打开它才会生效： 如果使用了readonly属性，则该输入框就会变为只读，它通常和value设置的默认值搭配使用： 渲染结果： 你也可以使用disabled禁止该输入框，用户只能看到灰色被禁用的输入框，不能进行内容输入： 渲染结果： password 密码输入框 密码输入框和文本输入框差不多，不同的是输入内容时浏览器会用黑色实心圆遮蔽掉用户键入的内容： 渲染结果： 其他的属性和文本输入框通用。 number 数字输入框 数字输入框仅能够输入数字，不能输入其他的字符，可用于输入手机号： 其他的属性和文本输入框通用。 date 日期输入框 日期输入框可以上传一个年月日。 当input的type为datetime-local时，可以上传一份本地化的时间（年月日时分秒） 当input的type为date时，可以上传一份标准化的世界时间（年月日） 当input的type为month时，可以上传年份和月份 当input的type为time时，可以上传小时和分钟数 当input的type为week时，可以上传年份和周数 除此之外，你可以利用min属性设置开始时间，max属性设置结束时间，step属性设置步长即多少时间一个间隔： 如下所示： 渲染结果： checkbox 复选框 复选框常用于勾选兴趣爱好，一般来说都要具有多个。 像这种复选框或者单选框之类的，都应该显式的设置value，不然提交的数据则为空。 注意，一组复选框内的name应该都相同，而value则应该不同，如下所示： basketball: football: volleyball: 渲染结果： 当点击提交后，它会以列表的方式将所勾选的checkbox的value进行整合，类似于下面这种格式： { \"hobby\" : [\"basketball\", \"football\"] } 此外，如果你想让某个复选框设置为默认的，可为它添加checked属性即可： basketball: 这样在渲染页面时，该复选框就会被选中： 在某些特殊的情况下我们只会设置一个复选框，如用户必须点击已阅读协议后才能进行下一步操作，此时你可以将该复选框设置为required，即必填，然后搭配JavaScript做到这样的效果，这里不再例举。 radio 单选框 单选框的使用与复选框基本相同。 必须显式的设置value，且name要一致： male: female: 提交 渲染结果： 此外，如果想设置默认值，则在radio上加上checked属性即可。 如果想设置多个radio中必须至少选择一个，则在任意一个同组的radio上添加属性required即可。 submit 提交按钮 input的type设置为submit后，可用于提交表单的内容，你可以为其设置value属性值来指定按钮显示内容： 当点击该按钮后，form表单将发送数据至后端。 渲染结果： reset 重置按钮 input的type设置为reset后，可用于清空表单的内容，你可以为其设置value属性值来指定按钮显示内容： 当点击该按钮后，form表单中所有以填项都会被清空。 渲染结果： button 普通按钮 input的type设置为button后，可用于与JavaScript代码进行交互，你可以为其设置value属性值来指定按钮显示内容： Document \"use strict\"; document.querySelector(\"input[type=button]\").addEventListener(\"click\", () => { console.log(\"click in button\") }) 为该按钮绑定Js事件，点击按钮后将触发Js事件。 渲染结果： hidden 隐藏输入框 隐藏输入框可用于存储一些用户不可见的数据，如用户的ID号等信息，这在修改用户密码时很常用。 在进行form表单提交时，它将一起提交给后端： Document old password : new password : submit button 提交后的结果： ImmutableMultiDict([('user-id', '31926'), ('old_password', '123'), ('new_password', '456')]) file 文件选择框 当input的属性为file时，可用于上传文件。 注意，如想成功上传文件，则： form表单的method必须为POST form表单的enctype必须为multipart/form-data 如下示例，需要注意文本选择框也必须设置name属性，否则将无法上传文件： Document avatar : submit button 渲染结果如下： 后端flask可用request.files进行文件接收，以下是接收内容： ImmutableMultiDict([('avatar', )]) 我们为文本选择框新增属性multiple，用于一次性上传多个文件： avatar : 除此之外，我们也可以为文本框新增属性accept，用来指定允许上传文件的mime类型： avatar : 这样在文件选择时，你只能选择png或者gif格式的图片了： Image 图像域 图像域使用较少，因此不再举例，它类似于img标签和submit的集合体。 用于创建一个图片提交按钮，在点击时除了添加所有表单项之外，还会将鼠标位于图片上的坐标进行发送。 datalist 数据列表 通过数据列表，我们可以展示一些信息供用户选择，它由3种标签构成分别是input、datalist、option。 input首先设置为文本输入框，然后添加属性list并给定一个关键字，此外你还需要设置name属性。 而后输入datalist标签，该标签的id和文本输入框的list关键字一致。 在datalist标签中嵌套option标签，并设置value值，这样数据列表就做好了： Document city: Beijing Shanghai Tianjin Chongqing submit button 渲染结果： 注意！数据列表中一次只能选定一个选项。 input的常见属性 下表中将例举input中常见的属性： 属性 值 描述 name field_name 表单提交时的键 value text 表单提交时的值 placeholder text 输入提示 checked checked radio和checkbox默认选中 readonly readonly 只读 disabled disabled 禁用 required required 必填 size number 定义输入框显示宽度 min number 定义输入的字段最小值 max number 定义输入的字段最大值 pattern regexp 对输入内容进行正则验证 oninvalid JavaScript 当正则验证失败后运行的代码 autocomplete on 、off 自动记录键入输入历史 以下是常用属性举例： Document placeholder male: female: checked readonly disabled required size:3 min:10 max:100 email autocomplete submit button label 标签 基本介绍 label标签通常与input标签绑定使用，它将作为input标签的标注出现，它是一个块级标签。 label有一个特殊的属性，for，该属性的值应当与被绑定的input标签id值相同。 我们看一个简单的例子来理解label标签的作用，下面这个例子中是没有label标签的，当点击关键字“male”或者“female”时，浏览器不会自动聚焦到radio上： Document male: female: 渲染结果： 如果使用label标签作为radio的标注，则点击label标签文本时，浏览器将会自动的聚焦在radio标签上： Document male: female: select 选择框 基本介绍 select标签与optgroup标签（可选）和option标签搭配可作出选择框的效果。 它类似于数据列表，但比数据列表更加强大，以下是这3个标签的可选常用属性。 首先是select标签，它最少要设定一个属性name，作为键与option的value进行搭配： 属性 值 描述 name text 规定发往服务器的选项键 multiple multiple 规定下拉列表是否可以多选 autofocus autofocus 页面加载完成后文本区域自动获取焦点 disabled disabled 禁用该下拉列表 required required 规定文本区域是必填的 size number 规定下拉列表中可见选项的数目 其次是optgroup标签，这是一个可选标签，也就是说选择框的组成它并不是必须的： 属性 值 描述 label text 为选项组规定描述 disabled disabled 禁用该选项组 最后是option标签，它最少要设定一个属性value，作为值与select标签的name进行搭配： 属性 值 描述 value text 规定发往服务器的选项值 label text 定义当使用optgroup时所使用的标注 selected selected 规定默认选中的选项 disabled disabled 规定此选项应当在首次加载时禁用 单项选择框 下面是一个单项选择框的示例： Document city: Beijing Shanghai Tianjin Chongqing NewYork SanFrancisco LosAngeles Miami submit button 渲染结果： 多项选择框 如果为select标签新增multiple属性，则该选择框可变为多选： Document city: Beijing Shanghai Tianjin Chongqing NewYork SanFrancisco LosAngeles Miami submit button 渲染结果： 默认选中 当option标签设置为selected后，该标签会被默认选中： Document city: Beijing Shanghai Tianjin Chongqing NewYork SanFrancisco LosAngeles Miami submit button 渲染结果： textarea 文本域 textarea标签与文本输入框类似，但是能够输入更多的内容。 它是一个内联标签，以下是常用属性： 属性 值 描述 name text 规定发往服务器的选项键 autofocus autofocus 规定在页面加载后文本区域自动获得焦点 maxlength number 规定该文本域所支持输入的最大字符数 placeholder text 规定描述文本区域预期值的简短提示 rows number 规定文本域的可见行数，即高度 cols number 规定文本域的可见列数，即宽度 required required 必填 readonly readonly 只读 disabled disabled 禁用 如下所示： Document submit button 渲染结果： fieldset - legend 美化标签 fieldset和legend标签都是块级标签，没什么特别明显的作用就是为了美化元素。 fieldset：为被包裹元素外加上一个框，主要为字段进行逻辑分组 legend：作为fieldset标签的标题出现 如下所示： Document 用户信息 用户名: 密码: 性别 male: female: 其他信息 爱好 篮球 足球 排球 个人介绍 居住城市 北京 上海 天津 重庆 纽约 旧金山 洛杉矶 迈阿密 提交 渲染结果： button 按钮 button标签是一个块级标签，它有一个非常重要的属性type，可设置以下3个常用值： submit：作用和相同，如果不指定type，默认就是它 button，作用和相同 reset，作用和相同 相较于input的按钮，我更倾向于使用button，因为它的语义更加明确。 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:48 "},"前端专栏/HTML/媒体系标签.html":{"url":"前端专栏/HTML/媒体系标签.html","title":"媒体系标签","keywords":"","body":"video 视频 video标签可用于播放视频，但是他的效果并不是很好，所以推荐使用一些第三方插件，如： 阿里云播放器 video.js 以下是viedo标签的常用属性，它是一个块级标签： 属性 描述 autoplay 视频自动播放，即视频加载完后会立即播放而不是等待用户进行手动点击 preload 视频预加载，设置为auto即可，它会根据网络情况自动加载视频 controls 视频播放按键，该属性是必须的 height 视频窗口高度 width 视频窗口宽度 loop 视频循环播放 muted 视频播放时静音 poster 视频未播放时显示的图像 src 视频地址 代码如下： Document 渲染结果： audio 音频 audio标签主要用于音频播放，它和video标签基本类似。 以下是audio标签的常用属性，它是一个块级标签： 属性 描述 autoplay 音频自动播放，即音频加载完后会立即播放而不是等待用户进行手动点击 preload 音频预加载，设置为auto即可，它会根据网络情况自动加载视频 controls 音频播放按键，该属性是必须的 loop 音频循环播放 muted 音频播放时静音 src 音频地址 具体效果这里不再演示。 source 媒介元素 有些浏览器不支持多媒体格式，我们可以在video标签或者audio标签中嵌套进source标签，让浏览器支持该种格式的媒体： 使用时注意source标签的src和type属性即可。 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:48 "},"前端专栏/CSS/summary.html":{"url":"前端专栏/CSS/summary.html","title":"CSS","keywords":"","body":" 基础知识 选择器 属性继承 常见单位 文本控制 数据样式 背景处理 盒子模型 浮动布局 定位布局 弹性布局 栅格布局 变形动画 过渡时间 帧动画 响应式布局 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:48 "},"前端专栏/CSS/基础知识.html":{"url":"前端专栏/CSS/基础知识.html","title":"基础知识","keywords":"","body":"CSS介绍 基本介绍 CSS全称为Cascading Style Sheet，译为层叠样式表。 它能够为HTML进行样式美化以及页面布局。 如果将单纯的HTML所构成的页面当做一副素描画，那么CSS的作用就是为这幅素描画进行上色处理。 当然CSS也能对HTML文档进行布局，让其不再使用默认的文档流排列方式，而是利用CSS让元素进行自由的组合、排列。 值得一提的是在早期没有出现CSS时，对HTML布局我们大多会使用table标签来进行，但是CSS诞生后就不会那么做了，使用CSS布局更加的方便。 关于CSS的学习可分为三大块： 如何选择标签元素 如何操纵标签元素 如何对页面进行布局 版本更迭 CSS1 1994年，哈肯·维姆·莱和伯特·波斯合作设计CSS。他们在1994年首次在芝加哥的一次会议上第一次展示了CSS的建议。 1996年[11]12月发表的CSS1的要求有：[13] 支持字体的大小、字形、强调 支持字的颜色、背景的颜色和其他元素 支持文章特征如字母、词和行之间的距离 支持文字的排列、图像、表格和其他元素 支持边缘、围框和其他关于排版的元素 支持id和class CSS2-2.1 1998年[11]5月W3C发表了CSS2[14]，其中包括新的内容如： 绝对的、相对的和固定的定比特素、媒体型的概念、 双向文件和 一个新的字体。 CSS2.1修改了CSS2中的一些错误，删除了其中基本不被支持的内容和增加了一些已有的浏览器的扩展内容。[15] CSS3 CSS3标准已部分公布，但仍未全部制订完毕，还会有其它新内容继续加入。W3C网站上有专页展示CSS3发展的进展[16]。 CSS3的标志。 CSS3分成了不同类别，称为“modules”。而每一个“modules”都有于CSS2中额外增加的功能，以及向后兼容。CSS3早于1999年已经开始制订。[17]直到2011年6月7日，CSS 3 Color Module终于发布为W3C Recommendation。[18] CSS3里增加了不少功能，如：“border-radius”、“text-shadow”、“transform”以及“transition”。CSS3亦支持动画（animation）及立体（preserved-3d）。 部分属性（例如旋转类属性（如：transform），动画类属性，立体类属性），由于现时不同浏览器支持程度不同，需要加上不同的浏览器前缀来区分。 CSS4 W3C于2011年9月29日开始了设计CSS4[19][20]。直至现时只有极少数的功能被部分网页浏览器支持，如使用在HTML而非SVG上的pointer-events[21]。 CSS4增加了一些更方便的选择器，并简化了一些现有选择器的用法。 如何使用CSS 行内式 直接在HTML标签元素中添加style属性并书写CSS代码的方式即为行内式。 行内式并不推荐使用，它对后期维护造成了一些很大的困惑，且代码复用性也较低： Document HELLO WORLD 渲染结果： 嵌入式 在head标签中内嵌style标签，并在style标签中书写CSS代码的方式被称为嵌入式。 嵌入式在调试代码时使用很方便，但是后期项目上线应该将CSS代码和HTML做好分离： Document span:nth-child(1){ background-color: red; color: white; padding: 5px; font-style: italic; } HELLO WORLD 渲染结果： 链接式 在head标签中内嵌子标签link，利用link标签来链接一个已经书写好的CSS样式文件的方式被称为链接式。 链接式是实际生产中最常用的导入CSS样式的方式。 HTML文档： Document HELLO WORLD CSS文件： span:nth-child(1){ background-color: red; color: white; padding: 5px; font-style: italic; } 渲染结果： 导入式 在head标签中内嵌子标签style，style标签中利用CSS所提供的语法@import url(“path”)来导入一个已经书写好的CSS样式文件的方式被称为导入式。 导入式的方式在整合CSS代码时比较常见，如下所示。 HTML文档： Document @import url(\"./all_style.css\"); HELLO WORLD HELLO CSS 整合的CSS文件，all_style.css： @import url(\"./style1.css\"); @import url(\"./style2.css\"); 单独的CSS文件，style1.css： span:nth-child(1){ background-color: red; color: white; padding: 5px; font-style: italic; } 单独的CSS文件，style2.css： div:nth-of-type(1){ background-color: blue; color: white; padding: 5px; font-style: italic; margin-top: 5px; } 渲染结果： 样式重置 所有的HTML都有一些自带的样式，比如body文档有边距并不是直接铺满整个屏幕的，ol、ul等默认样式都是黑色实心圆、a标签有下划线等。 在实际的项目开发中，我们应当将这些默认样式全部取消掉，因此有人专门做了一个CSS文件，名为CSS Rest即为CSS样式重置，在编写CSS代码之前，我们应当先导入这个文件： /* http://meyerweb.com/eric/tools/css/reset/ v2.0 | 20110126 License: none (public domain) */ html, body, div, span, applet, object, iframe, h1, h2, h3, h4, h5, h6, p, blockquote, pre, a, abbr, acronym, address, big, cite, code, del, dfn, em, img, ins, kbd, q, s, samp, small, strike, strong, sub, sup, tt, var, b, u, i, center, dl, dt, dd, ol, ul, li, fieldset, form, label, legend, table, caption, tbody, tfoot, thead, tr, th, td, article, aside, canvas, details, embed, figure, figcaption, footer, header, hgroup, menu, nav, output, ruby, section, summary, time, mark, audio, video { margin: 0; padding: 0; border: 0; font-size: 100%; font: inherit; vertical-align: baseline; } /* HTML5 display-role reset for older browsers */ article, aside, details, figcaption, figure, footer, header, hgroup, menu, nav, section { display: block; } body { line-height: 1; } ol, ul { list-style: none; } blockquote, q { quotes: none; } blockquote:before, blockquote:after, q:before, q:after { content: ''; content: none; } table { border-collapse: collapse; border-spacing: 0; } 注释语法 CSS中若要添加注释，格式如下： /* Comment */ 它可以支持多行注释。 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:48 "},"前端专栏/CSS/选择器.html":{"url":"前端专栏/CSS/选择器.html","title":"选择器","keywords":"","body":"基本选择器 * 通用选择器 *会选择所有元素，无视层级。常用于做样式清除，如内边距、外边距清除等。 示例如下，将所有的标签元素文本设置为红色： Document * { color: red; } span element mark element time element p element 渲染结果： E 名字选择器 名字选择器可通过标签名进行选择，无视层级。 示例如下，仅将p标签的文本设置为红色： Document p { color: red; } span element mark element time element p element 渲染结果： # ID选择器 根据标签的id属性来选择元素，无视层级，因HTML标签的id属性具有唯一性，故该选择器每次只能选择一个元素。 它以#作为关键字，后面跟上id即可。 示例如下，将id属性为a的标签文本设置为红色： Document #a { color: red; } span element mark element time element p element 渲染结果： . 类选择器 根据标签的class属性来选择元素，无视层级，因HTML标签的class属性不具有唯一性，故该选择器一次可以选择多个元素。 它以 . 作为关键字，后面跟上class即可。 示例如下，将class属性为inline的标签文本设置为红色： Document .inline { color: red; } span element mark element time element p element 渲染结果： 组合选择器 Feature 交集选择器 交集选择器可以从一组具有特性的共同的元素中取出一个具有独特特征的元素。 示例如下，有2个div： 一个div的id为a 一个div的class为a 若我们想选择其中的一个进行渲染，则必须要使用到交集选择器： 标签名字是div且id是a的标签会选择出第一个div 标签名字是div且class是a的标签会选择出第二个div 由于这种性质，交集选择器也可被称为特征选择器，示例如下： Document div#a { color: blue; } div.a { color: red; } div-id-a div-class-a 渲染结果： E, F 并集选择器 并集选择器可通过逗号来一次选取多个元素。 示例如下，将mark和time标签的文本设置为红色： Document mark, time { color: red; } span element mark element time element p element 渲染结果： E F 后代选择器 后代选择器可以寻找某个元素下的特定元素，它的寻找层级是没有上限的，关键字为空格， 示例如下，我们需要寻找div中嵌套的article中的id为a的mark标签，可直接通过后代选择器进行查找： Document div mark#a { color: red; } time element mark element time element mark element p element 渲染结果： E > F 子代选择器 子代选择器可以寻找某个元素子级下的特定元素，它的寻找层级为1层，关键字为>。 示例如下，我们需要寻找div中嵌套的article中的id为a的mark标签，通过子代查找器就必须严格的对元素关系进行书写，不能跨代： Document div>article>mark#a { color: red; } time element mark element time element mark element p element 渲染结果： E + F 同级毗邻选择器 E+F会查找紧随E元素后的F元素。 即通过哥哥元素找紧挨着自己的弟弟元素。 示例如下： Document /* div的后面必须是p，p的前面也必须是div */ div+p { color: red; } div p div p p 渲染结果： E ~ F 同级多跨选择器 E~F会查找在E元素后的所有F元素。 即通过哥哥元素找自己的所有弟弟元素。 示例如下： Document /* div后面的所有p */ div~p { color: red; } div span p p article p 渲染结果： 伪类选择器 动态伪类选择器 动态伪类选择器是比较常用的一种伪类选择器，如表所示： 选择器 类型 功能描述 E:link 链接伪类选择器 选择匹配的E元素，而且匹配元素被定义了超链接并未被访问过。常用于链接锚点上 E:visited 链接伪类选择器 选择匹配的E元素，而且匹配元素被定义了超链接并已被访问过。常用于链接锚点上 E:active 用户行为选择器 选择匹配的E元素，且匹配元素被激活。常用于链接锚点和按钮上 E:hover 用户行为选择器 选择匹配的E元素，且用户鼠标停留在元素E上。IE6及以下浏览器仅支持a:hover E:focus 用户行为选择器 选择匹配的E元素，而且匹配元素获取焦点时的行为 动态伪类选择器主要针对a标签： Document /* 没点过是红色 */ a:link { color: red; } /* 点击时是绿色 */ a:active { color: green; } /* 点过后是蓝色 */ a:visited { color: blue; } /* 鼠标悬浮时出现阴影 */ a:hover { box-shadow: #ddd 10px 2px 3px; } /* 获得焦点时显示边框 */ a:focus { border: 1px solid red; } click me 目标伪类选择器 目标伪类选择器只有1个，如表所示： 选择器 功能描述 :target 匹配a标签所指向的锚点 这个常用在a标签上，当点击这个a标签后，与这个a标签对应的锚点标签发生变化，示例如下： Document :target { background-color: red; } link first first element link second second element link third third element 渲染结果： 状态伪类选择器 状态伪类选择器主要针对input标签，如表所示： 选择器 示例 说明 :enabled input:enabled 选择每个启用的 input 元素 :disabled input:disabled 选择每个禁用的 input 元素 :checked input:checked 选择每个被选中的 input 元素 :required input:required 选择包含required属性的元素 :optional input:optional 选择不包含required属性的元素 :valid input:valid 选择验证通过的表单元素 :invalid input:invalid 选择验证不通过的表单 这些都很好理解，所以这里就不再进行演示了。 否定伪类选择器 否定伪类选择器只有1个，如表所示： 选择器 功能描述 E:not(F, G) 匹配所有E元素，包含F或者G条件的除外，如果直接使用:not(ele, ele)则相当于反选所有标签 示例如下，选择所有class属性为a的元素，h1排除在外： Document .a:not(h1) { color: red; } h1 element p element div element 渲染结果： 结构伪类选择器 结构伪类选择器是最常用的选择器，如表所示： 择器 功能描述 :root 匹配根元素，即html标签 E:first-child 匹配E元素，并且E元素要作为第一个子元素出现 E:last-child 匹配E元素，并且E元素要作为最后的子元素出现 E:nth-child(n) 根据位置匹配正数第n个子元素E。其中n可以是整数（1，2，3）、关键字（even，odd）、可以是公式（2n+1）,而且n值起始值为1，而不是0 E:nth-last-child(n) 根据位置匹配倒数第n个子元素E。此选择器与E:nth-child(n)选择器计算顺序刚好相反，但使用方法都是一样的，其中：nth-last-child(1)始终匹配最后一个元素，与last-child等同 E:nth-of-type(n) 根据类型匹配正数第n个E元素 E:nth-last-of-type(n) 根据类型匹配倒数第n个E元素 E:first-of-type 根据类型匹配第一个E元素 E:last-of-type 根据类型匹配最后一个E元素 E:only-child 匹配独生子E元素 E:only-of-type 匹配只有一个孩子的E元素 E:empty 匹配没有孩子的E元素 注意事项： 参数n可以是从1开始的数字 可以是公式，如（2n+1） 可以是odd，它将选择所有奇数项（从1开始计数） 可以是even，它将选择所有的偶数项（从1开始计数） 这些选择器刚开始理解可能很难，但是用习惯了后会发现真的非常方便。 下面是案例代码： Document :root { /* 直接使用root，选择的是html标签 */ background-color: wheat; } h1:first-child { /* h1必须是第一个子元素，刚好body标签的第一个子元素就是h1 */ color: blue; font-size: 3rem; } main:last-child { /* main必须是最后一个子元素，刚好body标签的最后一个子元素就是main */ border: 1px solid #ddd; background-color: aqua; } main p:nth-child(2) { /* 选择main标签下的第二个子标签，该子标签必须为p */ background-color: red; } ul li:nth-last-child(2) { /* 选择ul标签下的倒数第二个子标签，该子标签必须为li */ background-color: aquamarine; } ul li:nth-of-type(1) { /* 选择ul标签下的第一个子标签，该子标签必须为li */ background-color: deeppink; } ul li:nth-last-of-type(3) { /* 选择ul标签下的倒数第三个子标签，该子标签必须为li */ background-color: deepskyblue; } li:first-of-type { /* 第一个出现的li标签 */ font-size: 1.5rem; } li:last-of-type { /* 最后一个出现的li标签 */ font-size: .9rem; } aside:only-child { /* 选择是独生子的标签，且该标签必须是aside标签 */ font-size: 1.8rem; } footer:only-of-type { /* 选择只有一个儿子的标签，且该标签必须是footer标签 */ background-color: aquamarine; } section:empty { /* 选择没有后代的标签(也包括文本)，且改标签必须是section */ height: 2rem; border: red 1px solid; } hello world li-1 li-2 li-3 div p article aside 属性选择器 属性选择器经常用到，使用它的时候应该考虑到和其他选择器一起搭配使用，如交集选择器。 选择器 功能描述 [attribute] 用于选取带有指定属性的元素 [attribute=value] 用于选取带有指定属性和值的元素 [attribute~=value] 用于选取属性值中包含指定词汇的元素 [attribute|=value] 用于选取带有以指定值开头的属性值的元素，该值必须是整个单词 [attribute^=value] 匹配属性值以指定值开头的每个元素 [attribute$=value] 匹配属性值以指定值结尾的每个元素 [attribute*=value] 匹配属性值中包含指定值的每个元素 示例如下，匹配type为text的input标签： Document input[type=text]{ background-color: red; } 渲染结果： 如果想匹配checked或者disabled这种属性名和属性值一样的标签元素，则只需要输入属性名即可，总而言之，每一个[]都是一个属性，通过多个属性的查找，即可进行高精度筛选： Document input[type=text][disabled]{ background-color: red; } 渲染结果： 文本选择器 文本选择器用的比较少，如表所示： 选择器 功能描述 ::first-line 匹配文本首行 ::first-letter 匹配文本首字母 ::selection 匹配被鼠标划中的文本 如下示例： Document blockquote::first-line{ color:blue; } blockquote::first-letter{ font-size: 2rem; } blockquote::selection{ background-color: yellow; } --狂人日记 凡事总需研究，才会明白，古来时常吃人，我也还记得，可是不甚清楚。 我翻开历史一查，这历史没有年代，歪歪斜斜的每页上都写着“仁义道德”几个字。 我横竖睡不着，仔细看了半夜，才从字缝里看出来，满本都写着两个字是“吃人”！ 渲染结果： 文本插入器 文本插入器有2个： 插入器 描述 ::before 使用 contnet 属性生成额外的内容并插入在标记中，插在前面 ::after 使用 content 属性生成额外的内容并插入在标记中，插在后面 相当于在被选中标签中再插入2个普通的inline标签，注意这2个标签的content的属性是必须的，它规定被插入标签的内容。 此外还需要注意，新插入的内容会改变原标签的大小，所以谨慎使用。 示例如下： Document div { color: yellowgreen; } div::before { content: \"before\"; color: deeppink; } div::after { content: \"after\"; color: deepskyblue; } &nbsp;mid&nbsp; 渲染结果： Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:48 "},"前端专栏/CSS/属性继承.html":{"url":"前端专栏/CSS/属性继承.html","title":"属性继承","keywords":"","body":"选择器优先级 不同的选择器具有优先级，如果一个元素同时被多个选择器所选择且设置了同名样式时，它会按照优先级来判定应用哪一个选择器的样式。 如果优先级相同，则下面的选择器生效，常见优先级示例： 行内式渲染：1000 id选择器：100 class选择器：10 name选择器：1 当使用组合选择器时，优先级会进行累加，如下所示： Document /* 有同名属性时会根据优先级排定应用哪一个属性 */ h1 { /* 优先级 = 1 */ color: blue; background-color: red; } h1#title { /* 优先级 = 1 + 100 */ color: white; } HELLO WORLD 最终结果，同名属性color会渲染为第二个选择器： !important 我们可以使用!important关键字来强制更改优先级，让其优先级变的无限高。 有2个需要注意的地方： 如果同名样式都设置成!important，则!important带来的优先级提升会相互抵消，依旧按照选择器优先级来选择最终样式的渲染 如果2个同名样式的选择器优先级相同，还是按照后者覆盖前者的特性进行渲染 所以说，!important不能滥用，大量使用!important可能导致你代码可读性变差： Document /* 有同名属性时会根据优先级排定应用哪一个属性 */ h1 { /* 优先级 = 1 + 无限 */ color: blue !important; background-color: red; } h1#title { /* 优先级 = 1 + 100 */ color: white; } HELLO WORLD 最终结果： 属性继承 对于子标签来说，其父级别或更高级别标签的某些样式是可以被继承的，如： 颜色相关样式 字体相关样式 文本相关样式 但是对于盒模型中的一些属性，如内外边距、浮动等是不能被继承的。 继承而来的属性无限趋于0，可直接被替换掉，并且不能使用!important来提升被继承属性标签的优先级，!!mportant只能影响自身。 如下所示，当div的background-color设置为red，color设置为white后，其内部嵌套标签也会继承到这些属性： Document div{ background-color: red; color: wheat; } h1 h2 h3 h4 h5 h6 渲染结果： 我们可以保留一些继承项，并覆盖掉一些继承项，如下所示： Document div{ background-color: red; color: wheat; } div :nth-child(odd){ background-color: blue; } h1 h2 h3 h4 h5 h6 渲染结果： Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:48 "},"前端专栏/CSS/常见单位.html":{"url":"前端专栏/CSS/常见单位.html","title":"常见单位","keywords":"","body":"像素大小 px px是固定的像素单位，如果你的网页要在多端进行使用那么尽可能的少使用它，它不具有响应式的特性。 如下所示： Document div:first-of-type{ font-size: 12px; } div:last-of-type{ font-size: 18px; } 字号设置：12px 字号设置：18px 渲染结果： % 百分数是子元素相对于父元素设置的大小，比如父元素的大小是18px，那么子元素设置为50%就是9px，如下所示： Document main{ font-size: 18px; } div:first-of-type{ font-size: 50%; } div:last-of-type{ font-size: 200%; } 字号设置：main 18px 字号设置：50% = 9px 字号设置：200% = 32px 渲染结果： em em和百分号类似，它也是相较于父元素设置子元素的大小，1em相当于100%，0.5rem相当于50%。 注意，如果是0.x开头的，可直接简写为.x，如下所示： Document main{ font-size: 18px; } div:first-of-type{ font-size: .5em; } div:last-of-type{ font-size: 2em; } 字号设置：main 18px 字号设置：.5em = 9px 字号设置：2em = 36px 渲染结果： rem rem是em的升级版，也是推荐使用的方式。所有的大小设置不会按照父元素的值变化而变化，而是统一以html文档的值做参照。 默认的Chorme浏览器的html文档字号大小为16px，如果某个元素设置为.5rem则是8px。 如下所示： Document :root{ font-size: 16px; } div:first-of-type{ font-size: .5rem; } div:last-of-type{ font-size: 2rem; } 字号设置：html 16px 字号设置：.5em = 8px 字号设置：2em = 32px 渲染结果： 颜色格式 #xxxxxx #xxxxxx（x为16进制数）中所有的x均相同时，可简写为#xxx。 如下所示： Document div:first-of-type{ color: #ddd; } div:last-of-type{ color: #ff0000; } 颜色设置：#ddd 颜色设置：#FF0000 渲染结果： word 可以直接用单词来设置颜色，如color:red;或者color:blue;等。 如下所示： Document div:first-of-type{ color: blue; } div:last-of-type{ color: red; } 颜色设置：blue 颜色设置：red 渲染结果： rgb(xxx, xxx, xxx) rgb是三原色，红绿蓝。格式为color:rgb(0~255, 0~255, 0~255)，括号中的数字也可以用单词代替。 如下所示： Document div:first-of-type { color: rgb(0, 0, 255); } div:last-of-type { color: rgb(255, 0, 0); } 颜色设置：blue 颜色设置：red 渲染结果： rgba(xxx, xxx, xxx, n) rgba相较于rgb来说，括号中多了第4位数值n，n的范围为0-1，用于指定透明度。 如下所示： Document div:first-of-type { color: rgba(0, 0, 255, .5); } div:last-of-type { color: rgba(255, 0, 0, .8); } 颜色设置：blue 透明度：50% 颜色设置：red 透明度：80% 渲染结果： RGB颜色对照表 以下是RGB颜色对照表： 图片格式 常见的图片格式有jpg、jpeg、png、gif、svg、tif、tiff等，它们都有不同的用途，以下是对这些格式的图片简单描述： jpg/jpeg：最适合保存照片或栩栩如生的图像。 绝大多数计算机和网络用户主要使用 JPEG 文件在线上传、下载或查看图像。保存在 JPEG 中可以压缩照片并使用相当小的文件大小，从而可以更快地下载和上传。这意味着使用 jpeg 可以获得高质量的图像，不会占用大量空间。从网络上传或下载图像时，JPEG 应该是首选的存储文件 png：最适合使用透明背景截屏和保存 PNG 文件主要供图形设计师、使用品牌和徽标的营销人员以及有大量空间在计算机上保存内容的网络用户使用。PNG 通常用于在图像上编辑图像，或在图像上编辑文本。这是因为保存为 PNG 允许将图像或图形放在透明背景上，因此可以创建徽标覆盖。对于线条或文本，PNG 还提供比 jpeg 更“清晰”的图像，因此它们也经常用于屏幕截图。由于 PNG 与 JPEG 文件相比占用了相当多的空间，因此最好避免使用它们，除非您需要透明的背景图像，或者文件大小不是问题 svg：最适合保存需要以数字方式放大或缩小的图形 SVG 文件主要由 Web 设计人员使用，这些设计人员处理的图像和图形将在许多不同大小的媒体上显示和使用。保存在 SVG 中可以实现无缝缩放，或允许图形在不同大小的屏幕上清晰显示（或在屏幕上放大）而不会损失图像质量或“像素化”。徽标通常使用 SVG 文件创建，因为徽标通常显示在视网膜屏幕上，或者需要在不降低质量的情况下放大和缩小 gif：最适合保存颜色有限的图像或短动画，或颜色有限的图形 历史上，GIF 文件主要用于存储颜色有限的图形或图像，不会占用大量存储空间。在当今世界，GIF 主要用作互联网上、消息平台之间来回以及流行文化中的有趣、短循环动画。尽管动画 GIF 占用的存储空间比视频少得多，但它们比 SVG 或 PNG 占用更多的空间。这个存储问题，除了动画循环的一些断断续续的交付（和有限的色谱）之外，还可能使 GIF 动画文件不如 SVG 或 PNG 文件受欢迎 tif、tiff：最适合保存将用于打印的图像 TIFF 文件主要由处理印刷材料的图形设计师使用。在使用数字媒体（网络使用的图像和图形、电子邮件等）时，TIFF 很可能不是您的首选媒体，因为它明显缺乏数字支持。虽然保存在 TIFF 中允许保存图层并在图形或照片中表示许多颜色，但它并不是所有 Web 浏览器或应用程序都支持的文件，并且它不能很好地压缩，因此仅适用于打印用 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:48 "},"前端专栏/CSS/文本控制.html":{"url":"前端专栏/CSS/文本控制.html","title":"文本控制","keywords":"","body":"基础设置 字体家族 font-family 使用font-family可定义多个字体，浏览器会按照从左至右的顺序进行查找这些字体。 为什么需要定义多个字体？原因是如果你只使用了一种字体而恰好用户的计算机中并没有该字体就会降低显示效果。 代码示例： Document :root { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; } English display result 中文显示结果 渲染结果： 自定义字体 @font-face 我们可以自定义一些字体，但是在使用自定义字体时应该先导入字体文件。 注意，字体文件导入后应当进行format，告知浏览器字体文件所代指字体的格式。 如下表所示： 字体文件后缀 format .otf opentype .woff woff .ttf truetype .eot Embedded-opentype 代码示例： Document /* 自定义一个字体*/ @font-face { /* 字体名字：mineFont */ font-family: \"mineFont\"; /* 导入字体文件并格式化，可以多设置几个url，字体文件可以是网络的，也可以是本地的 */ src: url(\"./ALLEGRO.ttf\") format(\"truetype\"), url(\"./ALLEGRO.ttf\") format(\"truetype\"); } :root { /* 优先使用自定义字体 */ font-family: 'mineFont', 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; } English display result 中文显示结果 渲染结果： 字体粗细 font-weight 使用font-weight可设置字体的粗细，它既可以指定数字（100-900），也可以指定单词。 它可设置的值如下表所示： 单词 数字 lighter（细） 100与lighter相同 normal（正常） 400与normal相同 bold（较粗） 700与bold相同 bolder（特粗） 900与bolder相同 代码示例： Document p:nth-of-type(1) { font-weight: 100; } p:nth-of-type(2) { font-weight: lighter; } p:nth-of-type(3) { font-weight: 400; } p:nth-of-type(4) { font-weight: normal; } p:nth-of-type(5) { font-weight: 700; } p:nth-of-type(6) { font-weight: bold; } p:nth-of-type(7) { font-weight: 900; } p:nth-of-type(8) { font-weight: bolder; } 100 lighter（细） 400 normal（正常） 700 bold（较粗） 900 bolder（特粗） 渲染结果： 字号大小 font-size 使用font-weight可设置字号的大小，可以使用单词、px、%、em、rem进行设置。 它可指定单词如下表所示： 单词 描述 xx-small 最小 x-small 较小 small 小 medium 中等 large 大 x-large 较大 xx-large 最大 代码示例： Document :root{ font-size: 16px; } p:nth-child(1){ font-size: xx-small; } p:nth-of-type(2) { font-size: x-small; } p:nth-of-type(3) { font-size: small; } p:nth-of-type(4) { font-size: medium; } p:nth-of-type(5) { font-size: large; } p:nth-of-type(6) { font-size: x-large; } p:nth-of-type(7) { font-size: xx-large; } 字号设置: xx-small 字号设置：x-small 字号设置：small 字号设置：medium 字号设置：large 字号设置：x-large 字号设置：xx-large 渲染结果： 文本颜色 color 使用color可设置文本的颜色，可以使用单词、rgb、rgba、#16进制色进行设置。 代码示例： Document p:first-of-type { color: red; } p:nth-of-type(2) { color: rgb(255, 0, 0); } p:nth-of-type(3) { color: rgba(255, 0, 0, 0.5); } p:last-of-type { color: #ff0000; } 文本颜色：red 文本颜色：rgb(255, 0, 0) 文本颜色：rgba(255, 0, 0, 0.5) 文本颜色：#ff0000 渲染结果： 文本行高 line-height 当一段文本放在一个标签中，默认会以标签左上角为起始点进行文本渲染。 如果我们想让文本垂直居中于元素内，可以使用 line-height: element-height 的设置。 代码示例： Document div { background-color: #ddd; color: #000; height: 10rem; width: 10rem; } div:last-of-type { line-height: 10rem; } p { font-style: italic; color: #bbb; margin: 20px 0; } 默认文本按照左上角为起始点 this is a text 将line-height设置为元素高度可令文本垂直居中 this is a text 渲染结果： 文本倾斜 font-style 使用font-style可令文本样式发生改变。 normal：正常 italic：倾斜 代码示例： Document p:first-of-type{ font-style: normal; } p:last-of-type{ font-style: italic; } 正常：normal 倾斜：italic 渲染结果： 组合定义 font 使用font可一次性定义上面的设置，语法如下： div { font : 文本倾斜 倾斜方式 字号大小/文本行高 字体 \"字体1\", \"字体2\"; } 注意，文本颜色不能进入组合定义之中，除此之外还需要留意： 必须要指定字号的大小 必须要指定文本的行高 代码示例： Document p:first-of-type { font: italic bold 1em/1.5 'Courier New', Courier, monospace; color: red; } p:nth-of-type(2) { font: italic bold /1.5 'Courier New', Courier, monospace; } p:last-of-type{ font: italic bold 1em/ 'Courier New', Courier, monospace; } 倾斜：italic 粗细：bold 字号：1em/行高:1.5 字体：'Courier New', Courier, monospace 颜色：rgba(255,0,0,.5) 失败，未定义字号大小 失败，未定义文本行高 渲染结果： 文本样式 字型设置 font-variant 使用font-variant可定义字型，让字型看起来不太一样。 它可设置的值如下表所示： 值 描述 normal 默认值，标准的字型 small-caps 浏览器会显示小型大写的字 inherit 从父元素继承font-variant的值 \u0014\u0014\u0014\u0014\u0014\u0014\u0003代码示例： Document p:first-of-type { font-variant: normal; } p:last-of-type { font-variant: small-caps; } 默认值 normal 小型大写 small-caps 渲染结果： 字母大小写 text-transform 使用text-transform可对文本的字母做大小写转换。 它可设置的值如下表所示： 值 描述 capitalize 首字母大写 uppercase 全字母大写 lowercase 全字母小写 代码示例： Document p:first-of-type { text-transform: capitalize; } p:nth-of-type(2) { text-transform: uppercase; } p:last-of-type { text-transform: lowercase; } capitalize uppercase lowercase 渲染结果： 文本线条 text-decoration 我们可以使用text-decoration来清除a标签自带的下划线。 它可设置的值如下表所示： 值 描述 none 无任何线条样式 underline 文本下的一条线 overline 文本上的一条线 line-through 文本中的一条线 blink 定义闪烁的文本 inherit 从父元素继承text-decoration的值 代码示例： Document a:first-of-type{ text-decoration: none; } p:first-of-type { text-decoration: underline; } p:nth-of-type(2) { text-decoration: overline; } p:last-of-type { text-decoration: line-through; } underline overline line-through 清除a标签样式：none 渲染结果： 文本阴影 text-shadow 使用text-shadow可对一段文本添加阴影效果。 设置参数顺序如下： 阴影颜色 水平偏移量 垂直偏移量 模糊度 代码示例： Document h1{ text-shadow: #ddd 15px 15px 6px; font-size: 3rem; font-style: italic; font-weight: bolder; } HELLO WORLD 渲染结果： 空白处理 white-space 由于浏览器的渲染特性，故出现多个空白时只会显示一个。 我们可以使用white-space来控制文本中的空白显示。 它可设置的值如下表所示： 值 描述 pre 原样显示，类似于pre标签 nowrap 不保留文本换行 pre-wrap 保留空白，保留换行 pre-line 合并空白，保留换行 代码示例： Document p:nth-of-type(1) { white-space: pre; } p:nth-of-type(2) { white-space: nowrap; } p:nth-of-type(3) { white-space: pre-wrap; } p:nth-of-type(4) { white-space: pre-line; } p { border: 1px solid black; width: 300px; height: 100px; padding: 10px; } mark { border-bottom: 1px solid black; border-top-left-radius: 30%; background-color: black; color: white; transform: translate(0, 1rem); padding: 5px; } pre 原样显示 A B C D E F nowrap 合并空白，禁止换行 A B C D E F pre-wrap 保留空白，保留换行 A B C D E F pre-wrap 合并空白，保留换行符 A B C D E F 渲染结果： 文本溢出 text-overflow 一个有宽度的容器中，如果一个文本字数超过了容器宽度，是不会进行换行的，这样就会发生溢出。 如下所示： Document p{ width: 80px; } ABCDEFGHIJKLMNOPQRSTUVWXYZ 我们可以使用 overflow-wrap: break-word 来让文本自动换行： Document p{ width: 80px; overflow-wrap: break-word; } ABCDEFGHIJKLMNOPQRSTUVWXYZ 或者可以设置 overflow: hidden 以及 text-overflow: ellipsis 来让超出容器宽度的文本隐藏并使用 … 进行代替。 注意，overflow: hidden 必须设置在 text-overflow: ellipsis 的上面。 Document p{ width: 80px; overflow: hidden; text-overflow: ellipsis; } ABCDEFGHIJKLMNOPQRSTUVWXYZ 渲染结果： 段落控制 文本缩进 text-indent 使用text-indent可进行文本缩进，单位可以是px、em或者rem。 代码示例： Document p { border: 1px dotted #ddd; text-indent: 2rem; font-size: 2rem; } 你好，世界 渲染结果： 水平对齐 text-align 使用text-align可对文本在容器内部的水平对齐方式进行设定。 它可设置的值如下表所示： 值 描述 left 左对齐 right 右对齐 center 水平居中对齐 代码示例： Document div { background-color: #ddd; color: #000; width: 150px; height: 150px; display: inline-block; } div:nth-of-type(1){ text-align: left; } div:nth-of-type(2){ text-align: center; } div:nth-of-type(3){ text-align: right; } left center right 渲染结果： 若想文字水平+垂直居中，可指定 line-height: element-height 和 text-align: center： Document div { background-color: #ddd; color: #000; width: 150px; height: 150px; display: inline-block; } div:nth-of-type(1){ line-height: 150px; text-align: center; } center 渲染结果： 垂直对齐 vertical-align 如果要在图片附近放上一段文本，那么你可以使用vertical-align定义该文本相较于图片的位置进行渲染。 vertical-align仅支持inline与inline-block标签，一般来说都是用图片和文字的垂直对齐方式，此外它还可以让表格单元格的内容进行垂直居中 它可设置的值如下表所示： 值 描述 top 文本相较于图片顶部进行对齐 middle 文本相较于图片中部进行对齐 bottom 文本相较于图片底部进行对齐 sub 图片垂直对齐文本的下标 super 图片垂直对齐文本的上标 text-top 图片与文本顶端对齐 text-bottom 图片与文本底端对其 % 使用 line-height 属性的百分比值来排列此元素，允许使用负值 inherit 从父元素继承vertical-align的值 代码示例： Document div { border: 1px dotted #ddd; padding: 1rem; font-size: 12px; } img { width: 100px; } body div:nth-of-type(1) img { vertical-align: top; } body div:nth-of-type(2) img { vertical-align: middle; } body div:nth-of-type(3) img { vertical-align: bottom; } top middle bottom 渲染结果： 单词间距 word-spacing 使用word-spacing来控制单词与单词之间的间距，单位可以是px、em或者rem。 代码示例： Document p { word-spacing: 1rem; } this is p element 渲染结果： 字符间距 letter-spacing 使用letter-spacing来控制字符与字符之间的间距，单位可以是px、em或者rem。 代码示例： Document p { letter-spacing: 1rem; } this is p element 渲染结果： 排版模式 writing-mode 如果想对文本进行排版，可使用writing-mode。 它可设置的值如下表所示： 值 描述 horizontal-tb 水平方向、自上而下进行排版 vertical-rl 垂直方向、自右而左进行排版 vertical-lr 垂直方向，自左而右进行排版 代码示例： Document p { writing-mode: vertical-rl; width: 8rem; height: 8rem; overflow-wrap: break-word; } 日照香炉生紫烟，遥看瀑布挂前川，飞流直下三千尺，疑似银河落九天。 渲染结果： Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:48 "},"前端专栏/CSS/数据样式.html":{"url":"前端专栏/CSS/数据样式.html","title":"数据样式","keywords":"","body":"表格 绘制表格 display 我们除了可以使用table标签进行表格绘制外，在CSS3中display也同样支持表格的绘制。 如下表所示： 样式规则 说明 table 对应 table table-caption 对应 caption table-row 对应 tr table-cell 对应 th 或 td table-row-group 对应 tbody table-header-group 对应 thead table-footer-group 对应 tfoot 代码示例： Document body main { display: table; border: 1px solid #ddd; } body main li { border: 1px solid #ddd; padding: 0.5rem; } body main h5 { display: table-caption; background-color: #bbb; padding: 0.5rem; text-align: center; } body main header { display: table-header-group; } body main header ul { display: table-row; } body main header ul li { display: table-cell; font-weight: bold; } body main section { display: table-row-group; } body main section ul { display: table-row; } body main section ul li { display: table-cell; } body main footer { display: table-footer-group; } body main footer ul { display: table-row; } body main footer ul li { display: table-cell; } user message name gender age Ken male 19 Jack male 18 Mary female 18 ... ... ... 渲染结果： 表格标题 caption-side 在table中使用caption-side来设置表格标题的位置。 值可以是top或者bottom，默认是top。 代码示例： Document table { caption-side: bottom; border: 1px solid #ddd; } table caption, table th, table td { border: 1px solid #ddd; padding: .5rem; } table caption { background-color: #bbb; } table th { font-weight: bold; } user message name gender age Ken male 19 Jack male 18 Mary female 18 ... ... ... 渲染结果： 内容对齐 text-align vertical-align 对于th，td的内容，我们可以在th、td中使用text-align以及vertical-align进行位置控制。 Ps：我个人更喜欢使用padding和text-align来使单元格根据内容而自动发生变化，而不是像下面的例子一样定死宽高。 水平对齐text-align： 值 描述 left 左对齐 right 右对齐 center 居中对齐 垂直对齐vertical-align： 属性 说明 top 顶对齐 middle 垂直居中 bottom 底部对齐 代码示例： Document table { caption-side: top; border: 1px solid #ddd; } table caption, table th, table td { border: 1px solid #ddd; } table caption { background-color: #bbb; } table th { font-weight: bold; } table th, table td { height: 3rem; width: 5rem; /* 水平、垂直居中 */ text-align: center; vertical-align: middle; } user message name gender age Ken male 19 Jack male 18 Mary female 18 ... ... ... 渲染结果： 颜色设置 我们可以为table中的任何HTML元素进行颜色设置。 代码示例： Document table { caption-side: top; border: 1px solid #ddd; } table caption, table th, table td { border: 1px solid #ddd; padding: .5rem; } table caption { background-color: #bbb; } table th { font-weight: bold; } table tbody tr:nth-child(odd) { background-color: #eee; } user message name gender age Ken male 19 Jack male 18 Mary female 18 ... ... ... 渲染结果： 边框间距 border-spacing 我们可以在table中使用border-spacing来设置表格边框与单元格边框的间距。 它有2个值，1个值对应上下边框、1个值对应左右边框，单位可以是px、em、rem、%等。 代码示例： Document table { caption-side: top; border: 1px solid #ddd; border-spacing: 2px 2px; /* 注意！在css reset文件中会进行边框合并 所以要想看见border-spacing的效果，必须取消边框合并 */ border-collapse: unset; } table caption, table th, table td { border: 1px solid #ddd; padding: .5rem; } table caption { background-color: #bbb; } table th { font-weight: bold; } table tbody tr:nth-child(odd) { background-color: #eee; } user message name gender age Ken male 19 Jack male 18 Mary female 18 ... ... ... 渲染结果： 边框合并 border-collapse 在table中使用border-collapse：collapse让表格边框与单元格边框进行合并。 如果使用了边框合并，边框间距失效。 注意！如果你使用了css reset文件，则该设置默认是打开的。 代码示例： Document table { caption-side: top; border-collapse: collapse; border: 1px solid #ddd; } table caption, table th, table td { border: 1px solid #ddd; padding: .5rem; } table caption { background-color: #bbb; } table th { font-weight: bold; } table tbody tr:nth-child(odd) { background-color: #eee; } user message name gender age Ken male 19 Jack male 18 Mary female 18 ... ... ... 渲染结果： 隐藏单元格 empty-cells 在table中使用empty-cells：hide来隐藏没有内容的单元格。 代码示例，由于tfoot中的td没有内容，所以他们将会被隐藏： Document table { caption-side: top; border-collapse: collapse; border: 1px solid #ddd; empty-cells: hide; } table caption, table th, table td { border: 1px solid #ddd; padding: .5rem; } table caption { background-color: #bbb; } table th { font-weight: bold; } table tbody tr:nth-child(odd) { background-color: #eee; } user message name gender age Ken male 19 Jack male 18 Mary female 18 渲染结果： 无边框表格 如果要使用无边框表格，可以利用选择器让左右边框隐藏。 代码示例： Document table { caption-side: top; border-collapse: collapse; border: 1px solid #ddd; } table caption, table th, table td { border: 1px solid #ddd; border-left-style: unset; border-right-style: unset; padding: .5rem; } table caption { background-color: #bbb; } table th { font-weight: bold; } table tbody tr:nth-child(odd) { background-color: #eee; } user message name gender age Ken male 19 Jack male 18 Mary female 18 ... ... ... 渲染结果： 数据表格 表格中可以嵌套input标签，通过:hover对tr做一些样式上的调整，比如变色、鼠标变小等。 代码示例： Document table { caption-side: top; border-collapse: collapse; border: 1px solid #ddd; empty-cells: hide; } table caption, table th, table td { border: 1px solid #ddd; border-left-style: unset; border-right-style: unset; padding: .5rem; } table caption { background-color: #bbb; } table th { font-weight: bold; } table tbody tr:nth-child(odd) { background-color: #eee; } table tbody tr:hover { background-color: #aaa; } table tbody tr * { cursor: pointer; } table tfoot tr td { text-align: right; } user message name gender age male female male female male female 渲染结果： 列表 列表符号 list-style-type 使用list-style-type对整个列表的标记设置样式，你也可以单独的为li标签的标记样式进行设置。 它们可设置的值如下所示： 值 描述 none 无标记 disc 默认，标记是实心圆 circle 标记是空心圆 square 标记是实心方块 decimal 标记是数字 decimal-leading-zero 0 开头的数字标记，如：01、02、03 等 lower-roman 小写罗马数字，如：i、 ii、 iii、 iv、 v 等 upper-roman 大写罗马数字，如：I、 II、 III、IV、V 等 lower-alpha 小写英文字母The marker is lower-alpha，如：a、b、c、d、e 等 upper-alpha 大写英文字母The marker is upper-alpha，如：A、B、C、D、E 等 lower-greek 小写希腊字母，如：alpha、beta、gamma 等 lower-latin 小写拉丁字母，如：a、 b、 c、 d、 e 等 upper-latin 大写拉丁字母，如：A、 B、 C、 D、 E 等 hebrew 传统的希伯来编号方式 armenian 传统的亚美尼亚编号方式 georgian 传统的乔治亚编号方式，如：an、 ban、 gan 等 cjk-ideographic 简单的表意数字 hiragana 标记是：a、 i、 u、 e、 o、 ka、 ki 等（日文片假名） katakana 标记是：A、 I、U、 E、 O、 KA、 KI 等（日文片假名） hiragana-iroha 标记是：i、ro、 ha、 ni、 ho、 he、 to 等（日文片假名） katakana-iroha 标记是：I、 RO、 HA、 NI、 HO、 HE、 TO等（日文片假名） 比如将所有的样式去除： ul { list-style-type: none; } 将标记定义为渐变色或者是img图片： ul { list-style-image: linear-gradient(to right, deeppink, deepskyblue); } 符号位置 list-style-position 使用list-style-position来定义列表标记符号的位置。 它可设置的值如下表所示： 值 描述 inside 内部 outside 外部 内部示例： ul { list-style-type: square; list-style-position: inside; } 外部示例： ul { list-style-type: square; list-style-position: outside; } 组合定义 list-style 使用list-style来一次性定义list-style-type与list-style-position。 代码示例： ul { list-style: square outside; } 渲染结果： 背景符号 我们可以先将每个li标签的list-style-type设置为none。 然后再对li标签增加背景图片，背景图片先调小然后设置为居左不重复，并配以文本缩进，让它来代替列表标记。 代码示例： ul li{ list-style: inside none; background: url(\"./img-002.png\") no-repeat; background-size: 1rem 1rem; text-indent: 2rem; } 渲染结果： 除此之外，我们也可以为li标签增加多个背景，一个背景做列表的标记符号，一个背景做li的标签背景。 代码示例： ul li { list-style: inside none; background: url(\"./img-002.png\") no-repeat, url(\"./width_background_image.jpeg\") no-repeat 1.8rem; background-size: 1rem 1rem, 80%; text-indent: 2rem; margin-bottom: .5rem; } 渲染结果： 追加内容 基本使用 ::after ::before 我们可以使用选择器::after向后追加内容，以及::before向前追加内容。 使用这2个选择器时一定要指定content属性，它们的content属性值将被加至被选择元素的content区域内。 注意，增加内容后会改变盒模型的面积大小，所以可能会引发布局混乱，谨慎使用。 代码示例： Document span{ border: 1px solid #ddd; } span:hover::before{ content: \"before \"; color: deeppink; } span:hover::after{ content: \" after\"; color: deepskyblue; } mid 渲染结果，可以发现盒模型被撑大了： 提取属性 attr() 在::before和::after中的content中，我们可以使用attr()方法提取出标签的属性值用作提示信息。 如下示例，当用户鼠标放到a标签上，会自动提取href属性并作为链接提示： Document a:hover::after { content: \"go to \"attr(href); background-color: #555; color: #fff; position: relative; top: 1.8rem; padding: .2rem; border-radius: 1rem; } link 渲染结果： 自定义输入框 原本的输入框比较丑，我们可以给他做出一些改变： 代码示例： Document div.fields { width: 170px; position: relative; } div.fields input[name=username] { outline: none; border: none; text-align: center; vertical-align: middle; /* 继承div宽度 */ width: 100%; } div.fields::after{ content: \"\"; display: block; /* 继承div宽度 */ width: 100%; height: 1px; background: linear-gradient(to right, white, blue, red, green, pink, white); } div.fields:hover::before{ /* 标签的属性如果是data-开头，则代表该属性专门用于被CSS或者JS提取的 */ content: attr(data-placeholder); position: absolute; top: -2rem; left: 0; color: #555; font-size: .5rem; } Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:48 "},"前端专栏/CSS/背景处理.html":{"url":"前端专栏/CSS/背景处理.html","title":"背景处理","keywords":"","body":"背景样式 纯色背景 background-color 使用background-color可定义纯色背景。 代码示例： Document div:nth-of-type(1){ background-color: red; color: #fff; font-style: italic; font-size: 3rem; padding: 2rem; width: 300px; text-align: center; } hello world 渲染结果： 图片背景 background-image 使用background-image: url(“path”)可定义图片背景。 图片背景本身不会改变盒模型的大小，这与在盒子中插入img标签是不同的。 代码示例： Document div:nth-of-type(1){ background-image: url(\"./width_background_image.jpeg\"); color: #fff; font-style: italic; font-size: 3rem; padding: 2rem; width: 300px; text-align: center; } hello world 渲染结果： 背景剪裁 background-clip 我们可以将背景设置为盒子的某一区域，比如content区域或者padding区域或者border区域。 请使用background-clip来进行指定。 它可设置的值如下表所示： 值 描述 border-box 包括边框 padding-box 不含边框，仅包含内边距与内容区域 content-box 不含边框、内边距，仅包含内容区域 代码示例： Document div:nth-of-type(1){ background-color: red; background-clip: content-box; color: #fff; font-style: italic; font-size: 3rem; padding: 2rem; width: 300px; text-align: center; border: 1px solid #ddd; } hello world 渲染结果： 背景重复 background-repeat 如果背景图小于盒子，那么默认会重复使用背景图铺满整个盒子。 我们可以使用background-repeat为它指定如何重复。 它可设置的值如下表所示： 值 描述 repeat 水平、垂直重复（默认） repeat-x 水平重复 repeat-y 垂直重复 no-repeat 不重复 space 背景图片对称均匀分布 代码示例，取消重复，并让背景图居中： Document div:nth-of-type(1){ background-image: url(\"./width_background_image.jpeg\"); background-repeat: no-repeat; background-position: center; color: #fff; font-style: italic; font-size: 3rem; padding: 2rem; width: 600px; text-align: center; border: 1px solid #ddd; } hello world 渲染结果： 背景滚动 background-attachment 使用background-attachment来设置背景是否固定。 它可设置的值如下表所示： 值 描述 scroll 背景跟随滚动条进行滚动 fixed 背景固定 背景位置 background-position 使用background-position来设置背景图居于容器中的位置。 它可设置的值如下表所示： 值 描述 left 左对齐 right 右对齐 center 居中对齐 top 顶部对齐 bottom 底部对齐 除开使用单词进行设置，也可以使用百分号进行设置，还可以同时设置2个值。 设置 left center为水平居左、垂直居中 设置 right center为水平居右，垂直居中 设置 center left 为水平居中，垂直居左 设置 center right 为水平居中，垂直居右 代码示例，使用%进行设置，50%为居中： Document div:nth-of-type(1){ background-image: url(\"./width_background_image.jpeg\"); background-repeat: no-repeat; background-position: 30% 50%; color: #fff; font-style: italic; font-size: 3rem; padding: 2rem; width: 600px; text-align: center; border: 1px solid #ddd; } hello world 渲染结果： 背景尺寸 background-size 使用background-size来定义背景尺寸，可以是单词、px、em、rem以及%。 如果该属性是用单词设置，一个词就可以搞定 如果该属性是用其他单位设置，需要2个值，一个是背景高度，一个是背景宽度 它可设置的单词如下表所示： 值 描述 cover 背景完全覆盖容器，可能会产生背景溢出 contain 背景不溢出容器，可能会产生容器部分留白 宽度固定高度自动的设置是最常用的： background-size: 50% auto; 代码示例，采用cover的单词选项： Document div:nth-of-type(1){ background-image: url(\"./width_background_image.jpeg\"); background-repeat: no-repeat; background-position: 50% 50%; background-size: cover; color: #fff; font-style: italic; font-size: 3rem; padding: 2rem; width: 600px; text-align: center; border: 1px solid #ddd; } hello world 渲染结果： 多个背景 background-image 我们可以一次指定多个背景，当指定多个背景之后，其他的属性要想作用到多个背景上，需要使用逗号对其进行分割： background-image: url(\"path1\"), url(\"path2\"); background-size: img_1_size, img_2_size; 代码示例： Document div:nth-of-type(1) { background-color: red; background-image: url(\"./img-001.jpeg\"), url(\"img-002.png\"); background-repeat: no-repeat, no-repeat; background-position: 4%, 96%; background-size: 40px, 40px; color: #fff; font-style: italic; font-size: 3rem; padding: 2rem; width: 300px; text-align: center; } hello world 渲染结果： 组合定义 background 使用background来进行组合定义。 推荐顺序为：颜色、图片地址、是否重复、背景剪裁、背景尺寸、是否跟随滚动。 如： background: color url(\"path\") no-repeat border-box center scroll; 也可以一次指定多个背景： background: url(\"path1\") left 50% no-repeat, url(\"path2\") right 100% no-repeat red; 代码示例： Document div:nth-of-type(1){ background: red url(\"./width_background_image.jpeg\") no-repeat border-box center scroll; color: #fff; font-style: italic; font-size: 3rem; padding: 2rem; width: 600px; text-align: center; border: 1px solid #ddd; } hello world 渲染结果： 背景阴影 box-shadow 使用box-shadow对盒子元素设置背景阴影。 设置参数顺序如下： 阴影颜色 水平偏移量 垂直偏移量 模糊度 代码示例： Document div:nth-of-type(1) { width: 100px; height: 100px; background-color: #eee; border: 1px solid #ddd; border-radius: 50%; box-shadow: rgba(100, 100, 100, .5) 10px 10px 5px; } 渲染结果： 颜色渐变 线性渐变 linear-gradient 渐变一般都是在背景颜色中进行使用，格式为background: linear-gradient(方向, 颜色, 颜色, ...); 下面这个示例中没有指定方向，所以方向是从上到下： /* 深粉到深空蓝 */ background: linear-gradient(deeppink, deepskyblue); 使用 deg 来改变渐变的角度，如果为负数则代表反方向： /* 倾斜30°，深粉到深空蓝 */ background: linear-gradient(30deg, deeppink, deepskyblue); 使用 to 方向1 方向2 来改变渐变的方向，但是它不能和倾斜同时用： /* 向右渐变，深粉到深空蓝 */ background: linear-gradient(to right, deeppink, deepskyblue); /* 向左渐变，深粉到深空蓝 */ background: linear-gradient(to left, deeppink, deepskyblue); /* 向左上方渐变，深粉到深空蓝 */ background: linear-gradient(to left top, deeppink, deepskyblue); /* 向右下方渐变，深粉到深空蓝 */ background: linear-gradient(to right bottom, deeppink, deepskyblue); 同时，我们也可以设置多颜色渐变，以及颜色透明度： Document div { width: 200px; height: 50px; margin-bottom: 1rem; } div:nth-of-type(1) { background: linear-gradient(90deg, #03001e 0%, #7303c0 33%, #ec38bc 66%, #fdeff9 100%); } div:nth-of-type(2) { background: linear-gradient(90deg, #feac5e 0%, #c779d0 50%, #4bc0c8 100%); } div:nth-of-type(3) { background: linear-gradient(90deg, #ada996 0%, #f2f2f2 33%, #dbdbdb 66%, #eaeaea 100%); } div:nth-of-type(4) { background: linear-gradient(90deg, #833ab4 0%, #fd1d1d 50%, #fcb045 100%); } 渲染结果： 径向渐变 radial-gradient 径向渐变的格式为 background: radial-gradient(方向, 宽度, 颜色, 颜色, ...); 它是从元素内部中心点向外进行扩散的渐变方式。 /* 深粉到深空蓝 */ background: radial-gradient(deeppink, deepskyblue); 我们可以设置渐变色的宽度。 /* 深粉到深空蓝 */ background: radial-gradient(20px 20px, deeppink, deepskyblue); 也可以使用 at 方向1 方向2 来进行渐变方向的控制。 /* 向右上方进行渐变，深粉到深空蓝, 深粉渐变标识位100px */ background: radial-gradient(at right top, deeppink 100px, deepskyblue); 我们依然可以设置很多的颜色来进行渐变： /* 从底部向中部进行渐变 */ background: radial-gradient(at bottom center, red, green ,blue ,yellow); 标识位 当未指定标识位时，渐变的过程是十分均匀的，一旦指定了标识位就会发生突变。 如下所示： /* 无标识位 */ background: linear-gradient(90deg, deeppink, deepskyblue); /* 单方设置标识位 */ background: linear-gradient(90deg, deeppink 50%, deepskyblue); /* 双方设置标识位 */ background: linear-gradient(90deg, deeppink 50%, deepskyblue 50%); 使用径向渐变加标识位绘制小太阳： 代码如下： Document div { width: 200px; height: 200px; border-radius: 50%; background: radial-gradient(red 10%, yellow 30%, black 70%) } 中间点阈值 所谓中间点阈值，指的就是两个颜色渐变的时候，从哪个点开始让一个颜色渐变到另一个颜色。 比如这个示例，红色标识位为60%，蓝色标识位为40%，渐变的中间点阈值就只能变成0了。 再比如这个示例，单方设置了标识位，那么它的阈值就是由系统产生的，所以我们才能看见它渐变的效果。 怎么设置中间点阈值呢？看下面这段代码： /* 0%就是中间点阈值，当设置为0后那么红色变蓝色会由0%的位置开始 */ background: linear-gradient(90deg, red ,0%, blue); 所以结果是： 将中间点阈值改为20%： /* 我们的中间点阈值是20%，先是红色占了10%，那么可观测范围中中间点阈值也就只有10%了，所以渐变区域为10% */ background: linear-gradient(90deg, red 10% ,20%, blue 80%); 重复的线性渐变 repeating-linear-gradient 要想使用线性渐变重复，请利用repeating-linear-gradient进行设置。 /* 一个格子为 75px */ background: repeating-linear-gradient(90deg, blue, 25px, red 50px); 如果我们想要生硬渐变过程，可以再随便加一个颜色充当过渡。 /* 过渡色和第一个渐变色的标志位设置为一样即可 */ background: repeating-linear-gradient(90deg, blue, 25px, yellow 25px, 25px, red 50px); 重复的径向渐变 repeating-radial-gradient 要想使用线性渐变重复，请利用repeating-radial-gradient进行设置。 background: repeating-radial-gradient(20px 20px, red 0%, yellow 20%, blue 30%, green 50%); 渲染结果： Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:48 "},"前端专栏/CSS/盒子模型.html":{"url":"前端专栏/CSS/盒子模型.html","title":"盒子模型","keywords":"","body":"盒子元素 基本介绍 每一个标签都可以看做一个盒子，在网页的布局中也是大盒子不断的嵌套小盒子。 每个盒子模型都包含以下名词： content：内容区域，可以由width与height来进行宽高设置，是盒子模型体积组成部分之一 padding：内边距，指的是content与border之间的距离，是盒子模型体积组成部分之一 border：边框，边框也算整个盒子模型的体积组成之一 margin：外边距，指的是该盒子与另一个盒子之间的距离 如下图所示： 一个盒子的可视面积由3部分所构成（content、padding、border）。 对其中任何一部分进行数值加减，都会影响到整个盒子可视面积的改变。 Ps：margin不可视，但它属于盒模型整体面积一部分。 宽高设置 我们很少来规定一个盒子的固定大小，基本都是由内容进行撑开。 内容区域可以通过width和height来设置宽高。 注意：使用width和height设计出的盒子仅针对content区域 如果后续对padding或者border进行修改都会改变整个盒子的大小从而引发整个页面的混乱，如果我们增加了padding或者border的数值，就需要减去content的width以及height的数值，反之亦然 代码示例： Document div { background-color: #ddd; width: 100px; height: 100px; } 渲染结果： 盒子整体占用面积： 如何手动计算一个标准盒模型的可视面积？公式如下： 宽度 = width + padding-left + padding-right + border-left + border-right 高度 = height + padding-top + padding-bottom + border-top + border-bottom 如果是计算整体占用面积，还需要加上margin。 box-sizing 默认的width和height设置的值仅针对内容区域，如果我们使用box-sizing来声明该盒子为边框盒子的话那么width和height设置值的应用范围就是整个盒子。 也就是说，如果你是边框盒子，那么后续对padding、border的修改都不会导致整体盒模型可视面积的变化了。 这个声明是强烈推荐使用的，它的出现让手动计算盒子可视面积的时代一去不复返。 box-sizing仅能设置2个值： box-sizing：border-box 边框盒子 box-sizing：content-box 内容盒子（默认值） 以下是内容盒子和边框盒子的对比： Document div { width: 200px; height: 200px; padding: 10px; text-align: center; line-height: 200px; font-weight: lighter; } div:first-of-type { border: 1px double #ddd; background-color: #ddd; } div:last-of-type { box-sizing: border-box; border: 1px double #eee; background-color: #eee; } content-box h-w:242px border-box h-w:200px 外边距 间距修改 如果想修改盒子的外边距，可使用margin进行修改，单位可以是px、em、rem以及%。 margin后面可以跟上1个至4个值，如下所示： 1个值：设置 (margin-top、margin-bottom、margin-left、margin-right) 的值 上下左右 2个值：设置 (margin-top、margin-bottom) | (margin-left、margin-right) 的值 上下 左右 3个值： 设置 (margin-top) | (margin-left、margin-right) | (margin-bottom) 的值 上 左右 下 4个值：设置 (margin-top) |( margin-right) | (margin-bottom) | (margin-left) 的值 上 右 下 左 或者你也可以单独的设置4个方向。 代码示例： Document p{ background-color: #bbb; height: 100px; width: 100%; } div { background-color: #ddd; width: 100px; height: 100px; display: inline-block; margin-top: 50px; margin-bottom: 50px; } div:nth-of-type(2){ margin: 50px; } 渲染结果： 盒子居中 当大盒子中嵌套了一个小盒子时，如果我们想让小盒子水平居中可对小盒子设置margin: auto。 Ps：如果小盒子想要垂直居中，就必然涉及到塌陷问题，这个后面会慢慢探讨。 代码示例： Document main { width: 100%; background-color: #bbb; height: 2rem; } div { height: 1rem; width: 1rem; background-color: #eee; margin: auto; } 渲染结果： 负值设置 当小盒子的margin-left或者margin-right有负值设置时，小盒子可能会跑出大盒子外面。 代码示例： Document main { width: 300px; height: 300px; background-color: #bbb; margin: auto; } div { height: 100px; width: 100px; background-color: #eee; margin: 0 -50px; } 渲染结果： 同级纵向合并 同级纵向合并是指2个并列的（无嵌套关系）的盒子一个设置margin-bottom、另一个设置margin-top的话会比较这2个值的大小，然后取最大值进行设置。 如下所示： 代码示例： Document div{ margin: auto; width: 100px; height: 100px; } div:nth-child(1){ background-color: #ddd; margin-bottom: 40px; } div:nth-child(2){ background-color: #eee; margin-top: 20px; } 结果展示： 越级纵向合并 当一个子级盒子想去设置margin-top或者margin-bottom与父盒子保持一定距离时，那么这个父盒子就必须要拥有一些内容。 若父盒子没有任何内容，子盒子就会不断的向上找，找父盒子的兄弟、找父盒子的父亲，直至找到html标签为止。 如下这个示例，由于父盒子中没有任何内容，子盒子在设置margin-top:20px后不仅没有拉开与父盒子之前的距离，反而让父盒子与html文档拉开了距离： Document html { background-color: deepskyblue; } main{ width: 200px; height: 200px; background-color: #ddd; } div { width: 100px; height: 100px; background-color: #eee; margin-top: 20px; } 如果父盒子有内容，就不会发生越级纵向合并问题了，现在往父盒子中加入了一个空格符号再看看结果。 可以看到子盒子与父盒子的距离拉开了： Document html { background-color: deepskyblue; } main{ width: 200px; height: 200px; background-color: #ddd; } div { width: 100px; height: 100px; background-color: #eee; margin-top: 20px; } &nbsp; 内边距 间距修改 内边距关键词是padding，我们可以使用padding来定义内边距。 使用规则和margin一样： Document div{ margin:50px; padding: 10px; background-color: #ddd; } content 渲染结果： 盒子居中 使用padding配合margin: auto，我们可以快速的让小盒子居中在大盒子内部。 大盒子不设置height，而是使用padding撑开 小盒子设置margin：auto 代码示例： Document main{ background-color: #ddd; padding: 10px; } div{ background-color: #eee; height: 20px; width: 20px; margin: auto; } 渲染结果： 边框设计 边框样式 使用border-style定义边框样式。 它可设置的值如下表所示： 值 描述 none 定义无边框 dotted 定义点状边框。在大多数浏览器中呈现为实线 dashed 定义虚线。在大多数浏览器中呈现为实线 solid 定义实线 double 定义双线。双线的宽度等于 border-width 的值 groove 定义 3D 凹槽边框。其效果取决于 border-color 的值 ridge 定义 3D 垄状边框。其效果取决于 border-color 的值 inset 定义 3D inset 边框。其效果取决于 border-color 的值 outset 定义 3D outset 边框。其效果取决于 border-color 的值 边框宽度 以下属性可用于定义边框宽度，它们的值可以是px、em、rem、%。 属性名称 说明 border-top-width 顶边宽度 border-right-width 右边宽度 border-bottom-width 下边宽度 border-left-width 左边宽度 border-width 四边宽度 边框颜色 使用以下属性可用于定义边框颜色，它们的值可以是单词、rgb、rgba、#16进制色。 属性名称 说明 border-top-color 顶边颜色 border-right-color 右边颜色 border-bottom-color 下边颜色 border-left-color 左边颜色 border-color 四边颜色 组合定义 使用以下属性可对边框样式、边框宽度、边框颜色进行组合定义。 可以一次只定义一条边，也可以定义四边： 属性名称 说明 border-top 顶边 border-right 右边 border-bottom 下边 border-left 左边 border 四边 代码示例： Document div { height: 80px; width: 100px; background-color: #eee; margin: 20px; display: inline-block; text-align: center; line-height: 80px; font-weight: lighter; } div:nth-of-type(1) { border: 3px dotted #bbb; } div:nth-of-type(2) { border: 3px dashed #bbb; } div:nth-of-type(3) { border: 3px solid #bbb; } div:nth-of-type(4) { border: 3px double #bbb; } div:nth-of-type(5) { border: 3px groove #bbb; } div:nth-of-type(6) { border: 3px ridge #bbb; } div:nth-of-type(7) { border: 3px inset #bbb; } div:nth-of-type(8) { border: 3px outset #bbb; } dotted dashed solid double groove ridge inset outset 渲染结果： 圆角边框 使用以下属性对边框单角或者四角设置为圆角，圆角支持px、%等单位。 属性 说明 border-top-left-radius 上左角 border-top-right-radius 上右角 border-bottom-left-radius 下左角 border-bottom-right-radius 下右角 border-radius 全部角 代码示例： Document div { height: 200px; width: 200px; background-color: #eee; margin: 20px; border: 1px dotted #bbb; border-radius: 50%; } 渲染结果： 外轮廓线 基础设置 外轮廓线与边框的使用一模一样，但是它不是盒子面积构成的一部分。 所以： 外轮廓线显示在边框外面 外轮廓线不会影响页面布局 此外，外轮廓线没有圆角设计。 我们可以使用outline来进行外轮廓线的组合定义，如下所示： Document div { height: 200px; width: 200px; background-color: #eee; margin: 20px; outline: 1px solid #bbb; } 渲染结果： input设置 input框在选中（focus）时会出现一个外轮廓线，非常的不美观： 我们可以做一些其他的设置，让它更好看： 代码如下： Document input{ border: none; background-color: #eee; } input:focus{ outline: 1px inset #bbb; } div{ margin-bottom: 1rem; } display 特性置换 通过display属性，我们可以将一个标签的特性进行置换。 它可设置的值如下表所示： 值 描述 inline 转换为内联标签 block 转换为块级标签 inline-block 转换为内联块级标签 代码示例： Document :not(hr, body, html) { margin: 1rem; border: 1px solid #ddd; } aside { display: inline; width: 200px; } span { display: block; } a { display: inline-block; height: 24px; } block -> inline block -> inline inline -> block inline -> block inline -> inline_block inline -> inline_block 渲染结果： 隐藏标签 使用display: none后，元素将被隐藏，它不会留下被隐藏元素的空间位置。 代码示例： Document div { width: 100px; height: 100px; } div:nth-of-type(1) { background-color: #ddd; display: none; } div:nth-of-type(2) { background-color: #eee; } 渲染结果： visibility 使用visibility: hidden后，元素将被隐藏，它会留下被隐藏元素的空间位置，实际上就是元素可见度设置为0。 代码示例： Document div { width: 100px; height: 100px; } div:nth-of-type(1) { background-color: #ddd; visibility: hidden; } div:nth-of-type(2) { background-color: #eee; } 渲染结果： overflow 使用overflow: hidden后，容器中溢出的内容将会被隐藏： Document div { width: 100px; height: 100px; overflow: hidden; background-color: #ddd; } ABCDEFGHIJKLMNOPQRSTUVWXYZ 或者你也可以将overflow的值设置为auto，这样容器就会出现滚动条（scroll）： Document div { width: 100px; height: 100px; overflow: auto; background-color: #ddd; } ABCDEFGHIJKLMNOPQRSTUVWXYZ 尺寸定义 min-w h&max-w h min-width与min-height常用于嵌套关系之中。 举个例子，一个大盒子中要放入一张图片，那么这张图片应该占据大盒子的多少空间呢？ min-width：定义元素的最小宽度 min-height：定义元素的最大高度 max-width：定义元素的最大宽度 max-height：定义元素的最大高度 注意： 子元素在使用时min-width会继承父元素的width 优先级问题：min-width > max-width > width 优先级问题：min-height > max-height > height 优先级问题是指元素同时设置这3个属性时，浏览器会选用哪一个。 代码示例： Document main { width: 200px; height: 200px; background-color: #ddd; } div { background-color: #eee; min-height: 90%; max-width: 90%; } 渲染结果： fill-available 设置w、h为fill-available的子元素会填满整个父元素可用空间。 在chorme浏览器中使用该属性时需要加上前缀 -webkit 进行样式书写。 width: -webkit-fill-available; height: -webkit-fill-available; 代码示例： Document main { width: 200px; height: 200px; background-color: #ddd; } div { background-color: #eee; width: -webkit-fill-available; height: -webkit-fill-available; } 渲染结果： fit-content 设置w、h为fit-content的容器，不管有多少内容都不会造成溢出。 他会根据内容的宽高自动调整整个容器的宽高，常用于移动端。 width: fit-content; height: fit-content; 代码示例： Document div { width: fit-content; height: fit-content; background-color: #ddd; } ABCDEFGHIJKLMNOPQRSTUVWXYZ 渲染结果： min-content&max-content min-content和max-content也是移动端使用较多。 它会根据元素内容来自动设置content区域大小： width: min-content; height: min-content; width: max-content; height: max-content; 代码示例： Document div:nth-of-type(1) { width: min-content; height: min-content; background-color: #ddd; } div:nth-of-type(2) { width: min-content; height: min-content; background-color: #eee; } ABCDEFGHIJKLMNOPQRSTUVWXYZ ABCDEFGHIJKLMNOPQRSTUVWXYZ 渲染结果： Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:48 "},"前端专栏/CSS/浮动布局.html":{"url":"前端专栏/CSS/浮动布局.html","title":"浮动布局","keywords":"","body":"浮动布局 基本介绍 浮动布局是CSS早期最常使用的一种布局方式。 说白了就是使元素进行漂浮，从而脱离默认文档流排列的一种技术手段。 使用浮动布局应该注意以下几点： 浮动应当发生在一个大盒子内部（body标签也可以看做一个大盒子） 浮动后的元素会影响后面未浮动元素的排列方式 浮动元素会自动转换为inline-block状态 浮动元素只会在父盒子的content区域，不会溢出到父盒子的padding区域 当一个父盒子中所有的元素都进行浮动后，可能会造成父盒子高度塌陷的问题 使用浮动 对一个元素使用float就可以让该元素漂浮起来，它可以指定以下一些方向： 选项 说明 left 向左浮动 right 向右浮动 none 不浮动 注意！使用向右浮动会发生倒序排列，1234变为4321，而左浮动则是正序排列。 如果你不想右浮动改变他们的排列顺序，则可以将它们全部包装在一个父级标签中，将父级标签右浮动，再将子标签做浮动。 如下图所示： 文档流 文档流排列是一种自上而下，自左向右的排列方式。 对于block块级元素来说，它应该是独占一行的。 代码示例： Document * { box-sizing: border-box; } main { width: 230px; padding: .5rem; border: 1px solid #000; } main div { width: 100px; height: 100px; } main div:nth-of-type(1) { border: 1px solid blue; } main div:nth-of-type(2) { background-color: red; } 渲染结果： 空间占用 在同级情况下，排列在前的一个标签如果进行浮动设置从而脱离了文档流，那么排列在后的标签会占用之前标签的位置。 如下所示，排列在前的蓝框div如果float: left后，排列在后的红色背景div会向上顶，占用掉之前蓝框div所在的空间位置，而蓝框div则漂浮在了红色背景div的上方。 main div:nth-of-type(1) { border: 1px solid blue; float: left; } 如果排列在前的蓝框div设置为float: right后，排列在后的红色背景div依旧会向上顶，占用掉之前蓝框div所在的空间位置。 main div:nth-of-type(1) { border: 1px solid blue; float: right; } 如果我们对排列在后的红色背景div进行浮动设置的话，排列在前的标签并不会受此影响，但会出现父级高度塌陷问题，即父级盒子的高度会出现令人意外的情况： main div:nth-of-type(2) { background-color: red; float: right; } 状态转换 设置为浮动的元素都会变为inline-block状态。 如下所示，对一个inline标签进行浮动，它变的可以设置宽高了，对一个block标签进行浮动，它变的不会独占一行了： 代码示例： Document * { box-sizing: border-box; } main { width: 230px; padding: .5rem; border: 1px solid #000; /* 为了防止父盒子塌陷，所以这里给他定一个高度 */ height: 200px; } main span, div { width: 100px; height: 100px; text-align: center; line-height: 100px; } main span { float: left; border: 1px solid blue; } main div{ float: right; background-color: red; } inline block 浮动边界 父盒子中的浮动元素始终会位于父盒子的content区域中，不会超出padding区域。 如下所示： content：蓝色 padding：绿色 margin：黄色 代码示例： Document * { box-sizing: border-box; } main { width: 230px; padding: .5rem; border: 1px solid #000; /* 为了防止父盒子塌陷，所以这里给他定一个高度 */ height: 200px; } main span, div { width: 100px; height: 100px; text-align: center; line-height: 100px; } main span { float: left; border: 1px solid blue; } main div{ float: right; background-color: red; } inline block 清除浮动 塌陷问题 当一个没有高度的父盒子中所有子元素都进行漂浮后，父盒子会产生高度塌陷的问题： Document * { box-sizing: border-box; } main { width: 230px; padding: .5rem; border: 1px solid #000; } main div { width: 100px; height: 100px; } main div:nth-of-type(1) { border: 1px solid blue; float: left; } main div:nth-of-type(2) { background-color: red; float: right; } 父盒子出现高度塌陷后，会影响整体布局的混乱。 这是正常情况下的布局： Document * { box-sizing: border-box; } main { width: 440px; padding: .5rem; border: 1px solid #000; height: 120px; } main div { border: 1px solid blue; float: left; width: 100px; height: 100px; margin-right: 5px; text-align: center; line-height: 100px; color: #fff; background-color: deeppink; } img img img img this is description message this is description message this is description message this is description message 这是高度塌陷后出现的布局情况： Document * { box-sizing: border-box; } main { width: 440px; padding: .5rem; border: 1px solid #000; /* height: 120px; */ } main div { border: 1px solid blue; float: left; width: 100px; height: 100px; margin-right: 5px; text-align: center; line-height: 100px; color: #fff; background-color: deeppink; } img img img img this is description message this is description message this is description message this is description message 解决这个问题的方案非常简单，就是给父盒子设定一个固定的高度，但这样做是不现实的。 我们以下面这个京东滚动条来进行说明，仔细观察它的结构你会发现它其实就是一个a标签中套着img，和我们上面所示例的布局情况非常相似。 a标签是设置为float：left的，这就意味着黑框的div部分可能会出现高度塌陷问题，让整个页面都乱掉： 如果你为黑框div设置了一个高度，假如后续新一轮方案中img高度发生变化后我们还需要调整div的高度，显然是非常麻烦的。 所以，为父盒子设置高度解决塌陷问题是不可取的。 clear 内墙法 我们可以使用 clear 内墙法来解决父盒子高度塌陷的问题。 步骤如下： step01：在父盒子中加入一个不浮动的空白块级标签，放在所有浮动元素的下面 step02：为该标签新增 clear 属性，并配置选项 clear可设置的选项值如下表所示： 值 描述 left 左边远离浮动元素 right 右边远离浮动元素 both 左右都远离浮动元素 它的意思是该标签的某个方向不允许有浮动元素，如果有就另起一行。 下面是设置了clear内墙法后的父盒子，不再产生高度塌陷问题了： 我们注意看下面这段代码，clear元素必须是块级元素，且必须设置在浮动元素的下面，因为浮动元素只会影响排列在后的标签，并不会影响排列在前的标签： Document * { box-sizing: border-box; } main { width: 230px; padding: .5rem; border: 1px solid #000; } main div { width: 100px; height: 100px; } main div:nth-of-type(1) { border: 1px solid blue; float: left; } main div:nth-of-type(2) { background-color: red; float: right; } .clearfix { /* clear:both 代表如果两边有浮动，我就另起一行，不占据漂浮元素的空间位置 */ clear: both; } 伪元素 内墙法 clear 内墙法虽然能够很好的解决父盒子高度塌陷问题，但是使用非常麻烦。 我们需要为每一个有浮动元素的父盒子都建立一个空标签并新增clearfix类，整个步骤还是比较繁琐的。 所以可以使用伪元素内墙法，使用::after插入器为父盒子自动创建一个元素。 注意，一定要使用::after才有效，因为它是将文本插入到浮动元素的后面，如果使用::before是没有效果的，浮动元素并不会影响之前元素的排列方式。 伪元素内墙法应该是个人比较推崇的一种方式，他非常的简单。 代码示例： Document * { box-sizing: border-box; } main { width: 230px; padding: .5rem; border: 1px solid #000; } main div { width: 100px; height: 100px; } main div:nth-of-type(1) { border: 1px solid blue; float: left; } main div:nth-of-type(2) { background-color: red; float: right; } .clearfix::after { content: \"\"; display: block; /* clear:both 代表如果两边有浮动，我就另起一行，不占据漂浮元素的空间位置 */ clear: both; } overflow 最后这种方式更加的简单，只需要为父盒子设置 overflow: auto; 或者overflow: hidden; 即可解决高度塌陷问题。 它会触发一个BFC机制来解决高度塌陷问题，但可能会产生子元素内容丢失的情况。 具体BFC机制比较麻烦，这里不进行探讨，会用就行： 代码示例： Document * { box-sizing: border-box; } main { width: 230px; padding: .5rem; border: 1px solid #000; } main div { width: 100px; height: 100px; } main div:nth-of-type(1) { border: 1px solid blue; float: left; } main div:nth-of-type(2) { background-color: red; float: right; } .clearfix { /* overflow会触发BFC机制，缺点是可能会造成浮动元素部分内容缺失 */ overflow: auto; } 浮动环绕 基本介绍 浮动环绕就是让文本内容对浮动元素进行环绕，类似于word中的排版环绕。 如果浮动元素是img，则img链接图片必须是具有透明度的png格式图片。 下面是效果展示： 距离控制 对浮动元素使用shape-outside可进行浮动元素与同级文本之间的距离控制。 它可设置的值如下表所示： 值 说明 margin-box 外边距环绕 padding-box 内边距环绕 border-box 边框 content-box 内容环绕 1）外边距环绕，文字依照浮动元素的外边距进行环绕： 2）内边距环绕，文字依照浮动元素的内边距进行环绕： 3）边框环绕文，字依照浮动元素的边框进行环绕： 4）内容环绕，文字依照浮动元素的内容进行环绕： 代码示例： Document main { width: 22rem; } main img { width: 50px; float: left; padding: .5rem; margin: 1rem; border: 3px solid #bbb; shape-outside: content-box; /* shape-outside: border-box; shape-outside: padding-box; shape-outside: margin-box; */ } .clearfix { overflow: auto; } 滑稽起源于百度贴吧，由百度团队设计，最初名字叫“斜眼笑”。由于其可以同时表达多种复杂的感情，2012年时已被在极易引战的贴吧广泛应用。 2012年10月，有微博网友发了张小孩儿怕打针缩墙角的照片，将害怕这种情绪表现得非常到位，被灵魂画手描了个形，做成最初的【墙角害怕】。 2016年10月，“滑稽”表情抱枕正式登陆日本亚马逊，售价1550日元，约合人民币101元。 内移距离 shape-outside除了可以使用上面的单词来控制浮动元素与文本之间的距离外，还可以使用inset手动指定浮动元素的内移距离。 指定顺序为：上、右、下、左 代码示例： Document main { width: 22rem; } main img { width: 50px; float: left; padding: .5rem; margin: 1rem; border: 3px solid #bbb; shape-outside: inset(0px -30px 0px 50px) border-box; } .clearfix { overflow: auto; } 滑稽起源于百度贴吧，由百度团队设计，最初名字叫“斜眼笑”。由于其可以同时表达多种复杂的感情，2012年时已被在极易引战的贴吧广泛应用。 2012年10月，有微博网友发了张小孩儿怕打针缩墙角的照片，将害怕这种情绪表现得非常到位，被灵魂画手描了个形，做成最初的【墙角害怕】。 2016年10月，“滑稽”表情抱枕正式登陆日本亚马逊，售价1550日元，约合人民币101元。 环绕模式 浮动元素的shape-outside还可以指定文本环绕模式： 它可设置的值如下表所示： 值 说明 circle 圆形 ellipse 椭圆 polygon 多边形 1）正圆外边距环绕： 2）椭圆外边距环绕： 3）多边形外边距环绕： 代码示例： Document main { width: 22rem; } main img { width: 50px; float: left; padding: .5rem; margin: 1rem; border: 3px solid #bbb; shape-outside: polygon(50% 0, 100% 100%, 0 100%) margin-box; /* 正圆外边距环绕 shape-outside: circle(50%) margin-box; 椭圆外边距环绕： shape-outside: ellipse(50% 80%) margin-box; 多边形外边距环绕： shape-outside: polygon(50% 0, 100% 100%, 0 100%) margin-box; */ } .clearfix { overflow: auto; } 滑稽起源于百度贴吧，由百度团队设计，最初名字叫“斜眼笑”。由于其可以同时表达多种复杂的感情，2012年时已被在极易引战的贴吧广泛应用。 2012年10月，有微博网友发了张小孩儿怕打针缩墙角的照片，将害怕这种情绪表现得非常到位，被灵魂画手描了个形，做成最初的【墙角害怕】。 2016年10月，“滑稽”表情抱枕正式登陆日本亚马逊，售价1550日元，约合人民币101元。 显示区域 对浮动元素使用clip-path可控制其显示的形状。 它可设置的值如下表所示： 值 说明 circle 圆形 ellipse 椭圆 polygon 多边形 1）圆形 2）椭圆形 3）多边形 代码示例： Document main { width: 22rem; } main div { width: 50px; height: 50px; float: left; padding: .5rem; margin: 1rem; background-color: #eee; clip-path: polygon(50% 0, 100% 100%, 0 100%); /* 代表正圆，圆心在中间 clip-path: clip-path: circle(50% at center); 代表椭圆，圆心在右边 两个数，一个代表宽度，一个代表高度，圆心在右上角 clip-path: ellipse(50% 80% at 100% 0); 代表三角形 clip-path: polygon(50% 0, 100% 100%, 0 100%); */ } .clearfix { overflow: auto; } 滑稽起源于百度贴吧，由百度团队设计，最初名字叫“斜眼笑”。由于其可以同时表达多种复杂的感情，2012年时已被在极易引战的贴吧广泛应用。 2012年10月，有微博网友发了张小孩儿怕打针缩墙角的照片，将害怕这种情绪表现得非常到位，被灵魂画手描了个形，做成最初的【墙角害怕】。 2016年10月，“滑稽”表情抱枕正式登陆日本亚马逊，售价1550日元，约合人民币101元。 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:48 "},"前端专栏/CSS/定位布局.html":{"url":"前端专栏/CSS/定位布局.html","title":"定位布局","keywords":"","body":"定位布局 基本介绍 CSS中，定位布局是非常常见的技术手段，它可以将任意元素放在页面中任意的位置上。 早期的页面基本都是由浮动+定位布局来完成的。 我们以京东为例，这就是一个非常好的定位布局小例子： 定位布局虽然常用但是不能滥用，他可能会出现一些意料之外的情况，我们应该只对一些特定元素进行定位，而对不需要定位的元素则可对其使用默认文档流和浮动的手段进行布局排列。 定位类型 position 使用position对一个元素进行定位。 它可设置的值如下表所示： 值 描述 static 默认定位，即文档流布局定位 relative 相对定位，仍然是文档流定位 absolute 绝对定位，脱离文档流 fixed 固定定位，脱离文档流 sticky 粘性定位 位置偏移 一个被定位的元素可以进行上下左右的偏移，你可以指定方向与偏移距离。 可指定方向如下表所示，偏移距离单位可以是px、em、rem、%等： 方向 描述 top 距离顶边 bottom 距离下边 left 距离左部 right 距离右边 相对定位 relative 示例演示 相对定位relative是相对元素原本的位置进行偏移控制。 当元素发生偏移时，原空间位置保留（不脱离文档流，其他元素不会顶上来）。 这是原本位置： 对第一个元素进行相对定位后，向右偏移30px，向下偏移10px。可以发现p标签并没有顶上去： 代码示例： Document main { width: 200px; height: 200px; border: 1px solid #bbb; background-color: #ddd; } main div:nth-of-type(1) { width: 100px; height: 100px; border: 1px solid #bbb; /* position: relative; top: 20px; left: 30px; */ } main p:nth-of-type(1) { border: 1px solid #bbb; font-weight: lighter; } this is p element 绝对定位 absolute 示例演示 绝对定位absolute是脱离文档流的定位方式，你可以将它理解为可以偏移到任意位置的漂浮。 被绝对定位后的元素拥有inline-block的特性。 被绝对定位的元素是会影响同级的正常排列的文档流元素的，即后面的元素会自动向上补齐。 此外，子元素的绝对定位不会影响父元素的整体高度，这与浮动布局不同，浮动布局中子元素的float会导致父元素的高度塌陷问题，这点在绝对定位中是不存在的。 下面我们将演示绝对定位的脱离文档流特点。 这是原本位置： 对第一个元素进行绝对定位后，向右偏移30px，向下偏移10px。可以发现p标签顶上去了： 代码示例： Document main { width: 200px; height: 200px; border: 1px solid #bbb; background-color: #ddd; } main div:nth-of-type(1) { width: 100px; height: 100px; border: 1px solid #bbb; /* position: absolute; top: 20px; left: 30px; */ } main p:nth-of-type(1) { border: 1px solid #bbb; font-weight: lighter; } this is p element 参照元素 绝对定位的元素不受文档流的控制，所以默认它会按照页面左上角进行定位以及偏移。 但是如果被绝对定位元素的父元素设置了relative或者fixed以及sticky定位的话，则该绝对定位子元素将会参照此父元素左上角位置进行定位以及偏移。 下面这个示例中，父元素没有设置为relative或者fixed以及sticky定位，子元素的绝对定位会以页面左上角作为参照点： Document body{ border: 2px solid #bbb; } main { width: 200px; height: 200px; border: 1px solid #bbb; background-color: #ddd; margin-top: 100px; margin-left: 100px; } main div:nth-of-type(1) { width: 100px; height: 100px; border: 1px solid #bbb; position: absolute; top: 20px; left: 30px; } 下面这个示例中，父元素设置了relative定位，子元素的绝对定位会以父元素左上角作为参照点： Document body{ border: 2px solid #bbb; } main { width: 200px; height: 200px; border: 1px solid #bbb; background-color: #ddd; margin-top: 100px; margin-left: 100px; position: relative; } main div:nth-of-type(1) { width: 100px; height: 100px; border: 1px solid #bbb; position: absolute; top: 20px; left: 30px; } 所以，当一个子元素要设置为absolute绝对定位时，父元素应当设置为relative相对定位。 居中定位 如果想对绝对定位的子元素设置水平垂直居中，则可以： top设置为50% left设置为50% margin-left设置为子元素宽度的一半 margin-right设置为子元素宽度的一半 如下示例： 代码演示： Document main { width: 200px; height: 200px; border: 1px solid #bbb; background-color: #ddd; position: relative; } main div:nth-of-type(1) { width: 100px; height: 100px; border: 1px solid #bbb; position: absolute; left: 50%; top: 50%; margin-left: -50px; margin-top: -50px; } 默认位置 如果被定位的子元素没有设置任何偏移，那么它将会受到父元素padding等属性的影响。 但是使用定位的元素一般都会进行偏移设置。 示例如下： Document main { width: 200px; height: 200px; border: 1px solid #bbb; background-color: #ddd; position: relative; } main div:nth-of-type(1) { width: 100px; height: 100px; border: 1px solid #bbb; position: absolute; } 跟随滚动 无论是绝对定位抑或是相对定位的元素，都会随着滚动条发生滚动。 Document main { width: 200px; height: 200px; border: 1px solid #bbb; background-color: #ddd; position: relative; /* Y轴滚动条 */ overflow-y: scroll; } main div:nth-of-type(1) { width: 100px; height: 100px; border: 1px solid #bbb; position: absolute; left: 50%; top: 50%; margin-left: -50px; margin-top: -50px; } main p:nth-of-type(1){ /* p元素比main要长，才能滚动 */ height:1000px; } z-index 如果2个同级别的元素都进行定位且位置相同。那么后定位的元素会层叠在先定位的元素之上，这个时候我们就需要用到z-index来改变层叠优先级。 默认所有元素的层叠优先级均为0，较大优先级的元素会显示在上方。 如下示例，后定位的元素是矩形div，他会显示在圆形div的上方，当我们改变圆形div的z-index后，圆形div会显示在矩形div的上方： Document main { width: 200px; height: 200px; border: 1px solid #bbb; background-color: #ddd; position: relative; /* Y轴滚动条 */ overflow-y: scroll; } main div { width: 100px; height: 100px; border: 1px solid #bbb; position: absolute; } main div:nth-of-type(1) { border-radius: 50%; background-color: deeppink; z-index: 1; } main div:nth-of-type(2) { background-color: deepskyblue; } 固定定位 fixed 固定定位fixed是脱离文档流的定位方式。 固定定位的元素不会随着滚动条进行滚动，他的偏移参照点是页面左上角。 如下所示，我们使用a标签锚点与固定定位，实现快速返回页面顶部的按钮功能： Document div { height: 200px; } div:nth-of-type(1) { background-color: red; } div:nth-of-type(2) { background-color: blue } div:nth-of-type(3) { background-color: green; } div:nth-of-type(4) { background-color: yellow; } div:nth-of-type(5) { background-color: pink; } button { position: fixed; bottom: 2rem; right: 2rem; box-shadow: 5px 5px 5px #555; } go to top 粘性定位 sticky 同级粘性定位 同级粘性定位sticky是会进行层叠的，后面的粘性定位元素不会挤掉上面的粘性定位元素。 同级指的就是不同的粘性定位元素粘的是同一个父级元素。 Document section { overflow-y: scroll; width: 250px; height: 180px; text-align: center; } section h2 { padding: 13px; color: #fff; font-weight: bolder; position: sticky; top: 0; } section h2:nth-of-type(1) { background-color: orange; } section h2:nth-of-type(2) { background-color: blue; } section h2:nth-of-type(3) { background-color: yellowgreen; } section img { width: 130px; margin-top: 1rem; } HTML CSS JavScript 非同级粘性定位 非同级粘性定位sticky是不会进行层叠的，后面的粘性定位元素会挤掉上面的粘性定位元素。 非同级指的就是不同的粘性定位元素粘的不是同一个父级元素。 Document section { overflow-y: scroll; width: 250px; height: 180px; text-align: center; } section h2 { padding: 13px; color: #fff; font-weight: bolder; position: sticky; top: 0; } section article:nth-of-type(1) h2 { background-color: orange; } section article:nth-of-type(2) h2 { background-color: blue; } section article:nth-of-type(3) h2 { background-color: yellowgreen; } section img { width: 130px; margin-top: 1rem; } HTML CSS JavScript 导航条示例 使用浮动 + 定位布局，来快速构建一个导航条： Document * { box-sizing: border-box; } :root { font-size: 16px; } .clearfix::after { content: \"\"; display: block; clear: both; } header { padding: 1rem; background: #1b1b1b; color: #fff; position: fixed; width: 100%; } header nav section div { cursor: pointer; padding: 0.5rem; z-index: 1; } header nav section div:hover { background: #eee; border-radius: 20px; color: #000; } header nav section:nth-of-type(1) { float: left; } header nav section:nth-of-type(1) div { float: left; } header nav section:nth-of-type(2) { float: right; } header nav section:nth-of-type(2) div { float: left; margin-left: 1rem; } header nav section:nth-of-type(2) div:nth-of-type(2), header nav section:nth-of-type(2) div:nth-of-type(3) { position: relative; } header nav section:nth-of-type(2) div:nth-of-type(2) ul, header nav section:nth-of-type(2) div:nth-of-type(3) ul { position: absolute; left: 5px; background: #eee; color: #000; font-size: 0.8rem; padding: 0.5rem; display: none; } header nav section:nth-of-type(2) div:nth-of-type(2) ul li, header nav section:nth-of-type(2) div:nth-of-type(3) ul li { margin-top: 0.6rem; padding: 1px; } header nav section:nth-of-type(2) div:nth-of-type(2) ul li:hover, header nav section:nth-of-type(2) div:nth-of-type(3) ul li:hover { background-color: #1b1b1b; color: #fff; } header nav section:nth-of-type(2) div:nth-of-type(2):hover ul, header nav section:nth-of-type(2) div:nth-of-type(3):hover ul { display: block; } main { background: #e3e2e2; height: 80vh; } footer { background: #5a5a5a; height: 20vh; } 首页 我的关注 我的收藏 默认收藏 观看最多 点赞最多 个人设置 头像设置 界面设置 资料设置 退出登录 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:48 "},"前端专栏/CSS/弹性布局.html":{"url":"前端专栏/CSS/弹性布局.html","title":"弹性布局","keywords":"","body":"弹性布局 基本介绍 弹性布局flex是CSS3新增的一种布局方式，相较于浮动布局，弹性布局在开发效率与维护性上都远胜前者。 flex全称为flexible box，因此也被称之为弹性盒子。 学习弹性布局最主要从2个方面入手： 弹性容器：被设置为display: flex或display: inline-flex的容器元素 弹性元素：弹性容器中包裹的元素 一个大的弹性容器中可以包含多个小的弹性容器，我们可以控制弹性容器中元素的排列方式，也可以为弹性元素进行单独的区域划分以及改变其排列方式，总之而言使用弹性盒模型布局非常方便。 弹性容器 容器声明 使用display: flex或者display: inline-flex声明一个元素为弹性容器。 flex：容器本身是block状态，但是其内部的弹性元素是inline-block状态 inline-flex：容器本身是inline-block状态，内部的弹性元素也是inline-block状态 flex，可以看见容器本身是独占一行的，容器内元素div变为inline-block状态： inline-flex，容器本身不会独占一行，容器内元素div变为inline-block状态： Document main{ display:inline-flex; background-color:#ddd; } main div{ width: 50px; height: 50px; background: #eee content-box; padding: .5rem; text-align: center; line-height: 50px; } 1 2 3 this is span element 排列方式 flex-direction 我们可以在弹性容器中设置flex-direction来控制容器内部弹性元素的排列方式。 它可设置的值如下表所示： 值 描述 row 从左到右水平排列元素（默认值） row-reverse 从右向左水平排列元素 column 从上到下垂直排列元素 column-reverse 从下到上垂直排列元素 1） 从左到右水平排列元素（默认值），row： 2）从右向左水平排列元素，row-reverse： 3）从上到下垂直排列元素，column： 4）从下到上垂直排列元素，column-reverse： 代码示例： Document main{ display:flex; flex-direction: row; /* flex-direction: row; flex-direction: row-reverse; flex-direction: column; flex-direction: column-reverse; */ width:300px; height:300px; background-color:#ddd; } main div{ width: 50px; height: 50px; background: #eee content-box; padding: .5rem; text-align: center; line-height: 50px; } 1 2 3 是否换行 flex-wrap 当一个弹性容器中的弹性元素太多时，默认是不会进行换行的而是挤压内部的弹性元素。 我们可以使用flex-wrap来规定弹性元素是否换行显示，并且还可以指定是否反向换行。 它可设置的值如下表所示： 值 描述 nowrap 元素不拆行或不拆列（默认值） wrap 容器元素在必要的时候拆行或拆列 wrap-reverse 容器元素在必要的时候拆行或拆列，但是以相反的顺序 1）水平方向row排列与不换行nowrap（默认设置）： 2）水平方向row排列与换行wrap： 3）水平方向row排列与反向换行： 代码示例： Document main{ display:flex; flex-direction: row; /* flex-direction: row; flex-direction: row-reverse; flex-direction: column; flex-direction: column-reverse; */ flex-wrap: wrap-reverse; /* flex-wrap: wrap; flex-wrap: wrap-reverse; */ width:300px; height:300px; background-color:#ddd; } main div{ width: 50px; height: 50px; background: #eee content-box; padding: .5rem; text-align: center; line-height: 50px; } 1 2 3 4 5 6 7 8 9 组合定义 flex-flow 使用flex-flow可进行组合定义，它提供了对flex-direction与flex-wrap的简写。 示例： flex-flow: row column; 轴与排列 轴的介绍 一个弹性容器拥有2根轴： 主轴 交叉轴（从轴） 轴是根据排列方式flex-direction值的不同来进行变化而并非是一成不变的。 常见变化如下所示： 1）如果flex-direction为row，则主轴为水平轴，交叉轴为垂直轴： 2）如果flex-direction为column，则主轴为垂直轴，交叉轴为水平轴： 此外，如果flex-direction为row-reverse或者column-reverse，那么轴的起始位置和结束位置也会发生变化。 这里不在举例，因为使用的比较少。 主轴控制 justify-content justify-content用于控制弹性元素在主轴上的排列方式。 它可设置的值如下表所示： 值 描述 flex-start 弹性元素排列从主轴起始点开始（默认值） flex-end 弹性元素排列从主轴结束点开始 center 弹性元素排列从弹性盒子中心点开始 space-between 第一个元素靠起点，最后一个元素靠终点，余下元素平均分配空间 space-around 每个元素两侧的间隔相等，所以，项目之间的间隔比项目与边框的间隔大一倍 space-evenly 元素间距离平均分配 1）flex-start 弹性元素排列从主轴起始点开始（默认值）： 2）flex-end 弹性元素排列从主轴结束点开始： 3）center 弹性元素排列从弹性容器中心点开始： 4）space-between 第一个元素靠起点，最后一个元素靠终点，余下元素平均分配空间： 5）space-around 每个元素两侧的间隔相等，所以，项目之间的间隔比项目与边框的间隔大一倍： 6）space-evenly 元素间距离平均分配： 代码示例： Document main{ display:flex; flex-flow: row wrap; justify-content: space-evenly; width:300px; height:300px; background-color:#ddd; } main div{ width: 50px; height: 50px; background: #eee content-box; padding: .5rem; text-align: center; line-height: 50px; } 1 2 3 4 5 6 7 8 9 交叉轴元素控制 align-items align-items用于控制弹性元素在交叉轴上的排列方式。 该设置仅在弹性元素只有一行时适用。 它可设置的值如下表所示： 值 描述 stretch 元素被拉伸以适应容器（默认值） center 元素位于容器的中心 flex-start 元素位于容器的交叉轴开头（默认值） flex-end 元素位于容器的交叉轴结尾 注意，如果弹性元素设置了 width | height | min-height | min-width | max-width | max-height ，将影响stretch的结果，因 stretch优先级低于宽高设置。 1）stretch 元素被拉伸以适应容器（默认值）： 2）center 元素位于容器的中心： 3）flex-start 元素位于容器的交叉轴开头（默认值）： 4）flex-end 元素位于容器的交叉轴结尾： 代码示例： Document main{ display:flex; flex-flow: row; justify-content: space-evenly; align-items: flex-end; /* align-items: stretch; align-items: center; align-items: flex-start; */ width:300px; height:300px; background-color:#ddd; } main div{ width: 50px; /* 如果验证stretch，请取消弹性元素的高度设置 */ height: 50px; background: #eee content-box; padding: .5rem; text-align: center; line-height: 50px; } 1 2 3 4 交叉轴内容控制 align-content align-content只适用于多行显示的弹性容器，它能够控制每一行（注意不是弹性元素）在交叉轴上的排列方式。 该设置仅在弹性元素具有多行时适用。 它可设置的值如下表所示： 值 描述 stretch 将空间平均分配给内容 flex-start 内容紧靠交叉轴起点 flex-end 内容紧靠交叉轴终点 center 内容从弹性容器中心开始 space-between 第一行元素靠起点，最后一行元素靠终点，余下元素平均分配空间 space-around 每行元素两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍 space-evenly 元素行间距离平均分配 1）stretch 将空间平均分配给内容： 2）flex-start 内容紧靠交叉轴起点： 3）flex-end 内容紧靠交叉轴终点： 4）center 内容从弹性容器中心开始： 5）space-between 第一行元素靠起点，最后一行元素靠终点，余下元素平均分配空间： 6）space-around 每行元素两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍： 7）space-evenly 元素行间距离平均分配： 代码示例： Document main { display: flex; flex-flow: row wrap; justify-content: space-evenly; align-content: space-evenly; /* align-content: stretch; align-content: flex-start; align-content: flex-end; align-content: center; align-content: space-between; align-content: space-evenly; */ width: 300px; height: 300px; background-color: #ddd; } main div { width: 50px; height: 50px; background: #eee content-box; padding: .5rem; text-align: center; line-height: 50px; } 1 2 3 4 5 6 7 8 9 弹性元素 交叉轴控制 align-self align-self用于控制单个弹性元素在交叉轴上的排列方式。 注意区分align-items与align-content和align-self的区别： align-items：弹性容器中设置，控制单行 align-content：弹性容器中设置，控制多行 align-self：弹性元素中设置，控制自己，即一个元素 它们的优先级如下： align-items 由于align-self的优先级小于align-content，故设置了align-content后就不要再使用align-self设置单个弹性元素的排列方式了。 它可设置的值如下表所示： 值 描述 stretch 元素被拉伸以适应容器（默认值） flex-start 元素紧靠主轴起点 flex-end 元素紧靠主轴终点 center 元素从弹性容器中心开始 示例如下，仅改变元素 1 在交叉轴的排列方式。 代码示例： Document main { display: flex; flex-flow: row wrap; justify-content: space-evenly; align-items: flex-end; width: 300px; height: 300px; background-color: #ddd; } main div { width: 50px; height: 50px; background: #eee content-box; padding: .5rem; text-align: center; line-height: 50px; } main div:nth-of-type(1){ align-self: center; } 1 2 3 4 增加自身可用空间 flex-grow 对弹性元素使用flex-grow，将弹性容器内部可用空间分配给该弹性元素，可以使用整数或小数声明空间占比。 如下示例，弹性容器的排列方式为row，content宽度为300px，其内部共有3个弹性元素，将它们的空间占用分别划分为1、3、6。 即将弹性容器整体宽度300px分为10份，然后按照1、3、6的比例分配给每个弹性元素。 计算规则： 弹性容器总宽度 / (元素1占比 + 元素2占比 + 元素3占比) * 要算的元素占比 元素1占用宽度为 ： 300 / (1 + 3 + 6) * 1 = 30px 元素2占用宽度为 ： 300 / (1 + 3 + 6) * 3 = 90px 元素3占用宽度为 ： 300 / (1 + 3 + 6) * 6 = 180px Document main { display: flex; flex-flow: row wrap; width: 300px; background-color: #ddd; } main div { background: #eee content-box; text-align: center; line-height: 50px; } main div:nth-of-type(1) { flex-grow: 1; background-color: deeppink; } main div:nth-of-type(2) { flex-grow: 3; background-color: deepskyblue; } main div:nth-of-type(3) { flex-grow: 6; background-color: violet; } 1 2 3 如果弹性元素设置了宽度，请把弹性容器宽度 - 所有弹性元素宽度总和后再按照flex-grow进行分配。 下面每个弹性元素的宽度为50px，总宽度为150px，弹性容器的宽度为300px，余下可分配空间为300px - 150px。 计算规则： 弹性容器剩余宽度 / (元素1占比 + 元素2占比 + 元素3占比) * 要算的元素占比 元素1占用宽度为 ： 150 / (1 + 3 + 6) * 1 = 15px + 50px（已有宽度） 元素2占用宽度为 ： 150 / (1 + 3 + 6) * 3 = 45px + 50px（已有宽度） 元素3占用宽度为 ： 150 / (1 + 3 + 6) * 6 = 90px + 50px（已有宽度） Document main { display: flex; flex-flow: row wrap; width: 300px; background-color: #ddd; } main div { background: #eee content-box; text-align: center; line-height: 50px; width: 50px; } main div:nth-of-type(1) { flex-grow: 1; background-color: deeppink; } main div:nth-of-type(2) { flex-grow: 3; background-color: deepskyblue; } main div:nth-of-type(3) { flex-grow: 6; background-color: violet; } 1 2 3 缩小自身可用空间 flex-shrink 与flex-grow相反flex-shrink是在弹性容器装不下元素时定义的缩小值。 注意！要取消弹性容器的换行，flex-shrink才能生效，否则无效，装不下时就直接换行了 计算规则如下： 溢出空间 = 元素1宽度 + 元素2宽度 + 元素n宽度 - 弹性容器宽度 最终尺寸 = 溢出空间 - (溢出空间 / (元素1宽度 * 元素1缩放比例 + 元素2宽度 * 元素2缩放比例 + 元素n宽度 * 元素n缩放比例) * 待计算元素的缩放比例 ) * 待计算元素宽度 如下示例，我们在宽度为300px且排列方式为row的弹性容器中放下了3个宽度为150px的弹性元素。很明显弹性容器会压缩器内部的弹性元素。 各个弹性元素的缩放比例为1， 3， 6。 开始套用规则进行计算： 溢出空间：3 * 150 - 300 = 150 元素1最终尺寸：150 - ( 150 / (150 * 1 + 150 * 3 + 150 * 6) * 1 ) * 150 = 135px 元素2最终尺寸：150 - ( 150 / (150 * 1 + 150 * 3 + 150 * 6) * 3 ) * 150 = 105px 元素3最终尺寸：150 - ( 150 / (150 * 1 + 150 * 3 + 150 * 6) * 6 ) * 150 = 60px Document main { display: flex; flex-flow: row nowrap; width: 300px; background-color: #ddd; } main div { background: #eee content-box; text-align: center; line-height: 50px; width: 150px; } main div:nth-of-type(1) { flex-shrink: 1; background-color: deeppink; } main div:nth-of-type(2) { flex-shrink: 3; background-color: deepskyblue; } main div:nth-of-type(3) { flex-shrink: 6; background-color: violet; } 1 2 3 定义基准尺寸 flex-basis 如果将轴的宽度看做100%，我们可以对弹性元素使用flex-basis来定义它占据主轴的百分比。 使用时需要注意一点，该项设置的优先级大于width和height。 如下所示，主轴宽度为300px，3个弹性元素占比为20%，20%，60%： Document main { display: flex; flex-flow: row nowrap; width: 300px; background-color: #ddd; } main div { background: #eee content-box; text-align: center; line-height: 50px; } main div:nth-of-type(1) { flex-basis: 20%; background-color: deeppink; } main div:nth-of-type(2) { flex-basis: 20%; background-color: deepskyblue; } main div:nth-of-type(3) { flex-basis: 60%; background-color: violet; } 1 2 3 组合定义 flex 使用flex可对flex-grow、flex-sharink以及flex-basis进行简写。 即：增容比例、缩容比例、基准尺寸占比。 在这其中，基准尺寸占比的优先级最大。 建议不要仅在flex中设置单独的1个值。 如下示例： Document main { display: flex; flex-flow: row nowrap; width: 300px; background-color: #ddd; } main div { background: #eee content-box; text-align: center; line-height: 50px; } main div:nth-of-type(1) { /* 增容比例、缩容比例、基准尺寸占比 */ flex: 1 0 40%; background-color: deeppink; } main div:nth-of-type(2) { flex: 3 1 20%; background-color: deepskyblue; } main div:nth-of-type(3) { flex: 3 1 20%; background-color: violet; } 1 2 3 元素排序优先级 order 所有的弹性元素优先级默认均为0，优先级越低越靠近主轴起始点。 Document main { display: flex; flex-flow: row nowrap; width: 300px; background-color: #ddd; } main div { background: #eee content-box; text-align: center; line-height: 50px; } main div:nth-of-type(1) { order: 3; flex-grow: 1; background-color: deeppink; } main div:nth-of-type(2) { order: 2; flex-grow: 1; background-color: deepskyblue; } main div:nth-of-type(3) { order: 1; flex-grow: 1; background-color: violet; } A-order 3 B-order 2 C-order 1 文本元素 文本也可以作为弹性元素。 Document main { display: flex; flex-flow: row nowrap; justify-content: center; align-items: center; width: 300px; height: 300px; background-color: #ddd; font-size: 4rem; } text 绝对定位 绝对定位的元素是不会参与到弹性布局中的。 可以看见弹性容器中绝对定位的元素交叉轴拉伸是不起作用的： Document main { display: flex; flex-flow: row nowrap; justify-content: center; align-items: stretch; width: 300px; height: 300px; background-color: #ddd; position: relative; } main div{ background-color: #eee; padding: .5rem; } main div:nth-child(2){ position: absolute; left: 1rem; top: 3rem; } stream absolute 自动空间 使用margin-right: auto可令弹性元素自动撑开余下的空间。 如下这个案例，我们是水平排列方式，要将滑稽头像放在最右边，但是对于滑稽这个弹性元素来说没有那种能够将自己放在水平主轴结束位置的选项。 所以我们可以对左边的ul弹性元素使用margin-right: auto;来进行自动将右边撑开： 或者也可以对header使用justify-content: space-between，达到相同的效果。 Document header { display: flex; flex-flow: row nowrap; width: 60%; background-color: #f3f3f3; box-shadow: 0 0 5px rgba(0, 0, 0, .2); /* 二选一 justify-content*: space-between */ } header ul { display: flex; /* 二选一 */ margin-right: auto; } header ul li { padding: 1rem; } header img { width: 3rem; margin-right: 1rem; border-radius: 50%; } 主页 我的关注 我的文章 我的好友 微信布局 使用弹性布局快速搭建微信布局： Document :root { background-color: #ccc; } header, main, footer { display: flex; flex-flow: row nowrap; padding: 0 1rem; border-bottom: 1px solid #bbb; justify-content: space-between; align-items: center; } header { height: 10vh; } main { height: 80vh; } main ul { width: 100%; display: flex; flex-flow: column nowrap; /* 优先级大于 align-items */ align-self: flex-start; } main ul li { margin-top: 3rem; display: flex; align-items: center; } main ul li:last-of-type { align-self: flex-end; } main ul li *:last-child { margin-left: .5rem; } main ul li i.icon-huaji, main ul li i.icon-mojinghuaji { font-size: 2rem; color: green; background-color: #ddd; } main ul li span { background-color: #fff; border: 1px solid #aaa; padding: .4rem; border-radius: 10px; } footer { height: 10vh; } footer i { font-size: 2rem !important; } footer input { height: 50%; } &lt; 大神 ... 老弟在吗？ 一起去看电影 哥我不去了，今天没时间 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:48 "},"前端专栏/CSS/栅格布局.html":{"url":"前端专栏/CSS/栅格布局.html","title":"栅格布局","keywords":"","body":"栅格布局 基本介绍 CSS的栅格布局也被称为网格布局(Grid Layout)，它是一种新兴的布局方式。 栅格布局是一个二维系统，这意味着它可以同时处理列和行，与弹性布局相似，栅格系统也是由栅格容器包裹栅格元素进行使用。 对于栅格布局来说，它的思想实际上非常简单，将一块区域绘制成格子，然后将元素填进去即可。 作为学习者应该从下面两个角度来学习栅格布局： 怎么样画出栅格容器 怎么样将元素放进栅格容器中的某一区域 　值得一提的是，现在的一些旧版浏览器对于栅格布局并没有较好的支持性，所以这项技术的应用场景其实相比于传统式的浮动布局以及弹性布局来说会少一些。 栅格容器 容器声明 使用display: grid或者display: inline-gid声明一个元素为栅格容器。 grid：块级栅格容器，独占一行 inline-grid：内联块级栅格容器，不独占一行 首先声明grid，即块级栅格容器，可以看见容器本身是独占一行的： 其次是inline-grid，即内联块级栅格容器，容器本身不会独占一行： 代码示例： Document main { border: solid 5px silver; /* 声明容器 */ display: inline-grid; /* display: grid; display: inline-grid; */ /* 划分行列 */ grid-template-rows: repeat(3, 100px); grid-template-columns: repeat(3, 100px); } main div { background: blueviolet content-box; padding: 10px; border: 1px #000 dashed; text-align: center; line-height: 80px; color: #fff; } 1 2 3 4 5 6 7 8 9 this is span element 栅格容器之行列划分 划分行列 光有栅格容器没有用，我们还需要为栅格容器划分行列以及指定宽度。 grid-template-rows：划分行数 grid-template-columns：划分列数 下面介绍几种划分行列的方式。 固定宽高 如我们想画一个2行3列固定宽高的栅格容器，可以使用下面的方法进行绘制： grid-template-rows: 100px 100px; grid-template-columns: 100px 100px 100px; 渲染结果，高度200px，款度300px： 代码示例： Document main { border: solid 5px silver; /* 声明容器 */ display: inline-grid; /* 划分行列 */ grid-template-rows: 100px 100px; grid-template-columns: 100px 100px 100px; } main div { background: blueviolet content-box; padding: 10px; border: 1px #000 dashed; text-align: center; line-height: 80px; color: #fff; } 1 2 3 4 5 6 百分比宽高 使用百分比来绘制行列线，使用这种方式你必须先指定栅格容器的宽高。 如下面示例中为一个300 * 300的栅格容器绘制出2行4列的线条： grid-template-rows: 50% 50%; grid-template-columns: 25% 25% 25% 25%; 渲染结果： 代码示例： Document main { border: solid 5px silver; width: 300px; height: 300px; /* 声明容器 */ display: inline-grid; /* 划分行列 */ grid-template-rows: 50% 50%; grid-template-columns: 25% 25% 25% 25%; } main div { background: blueviolet content-box; padding: 10px; border: 1px #000 dashed; text-align: center; line-height: 150px; color: #fff; } 1 2 3 4 5 6 7 8 重复划分 若每行或每列的间距是相同的，则直接可以使用重复绘制更加简便的划分行列。 grid-template-rows: repeat(3, 100px); grid-template-columns: repeat(3, 100px); 代码示例： Document main { border: solid 5px silver; /* 声明容器 */ display: inline-grid; /* 划分行列 */ grid-template-rows: repeat(3, 100px); grid-template-columns: repeat(3, 100px); } main div { background: blueviolet content-box; padding: 10px; border: 1px #000 dashed; text-align: center; line-height: 80px; color: #fff; } 1 2 3 4 5 6 7 8 9 我们也可以重复绘制不同宽度的单元格，比如奇数项的列要宽一点，偶数项的列要窄一点： grid-template-rows: repeat(3, 100px); grid-template-columns: repeat(2, 100px 50px); 代码示例： Document main { border: solid 5px silver; /* 声明容器 */ display: inline-grid; /* 划分行列 */ grid-template-rows: repeat(3, 100px); /* 重复2次， 奇数项列宽为100px、偶数项列宽为50px 最终总列数 = 重复次数 * 后面跟上的个数 即 2 * 2 = 4列 */ grid-template-columns: repeat(2, 100px 50px); } main div { background: blueviolet content-box; padding: 10px; border: 1px #000 dashed; text-align: center; line-height: 80px; color: #fff; } 1 2 3 4 5 6 7 8 9 10 11 12 自动划分 自动划分是指不指定划分多少行或者列，而是只给他一个行列占比的具体数值，它会自动根据容器的大小来进行划分。 我们想在一个宽和高都是300px的栅格容器中进行绘制，而每个单元格的宽高都是100px，那就设置一下交给他自动绘制。 grid-template-rows: repeat(auto-fill, 100px); grid-template-columns: repeat(auto-fill, 100px); 代码示例： Document main { width: 300px; height: 300px; border: solid 5px silver; /* 声明容器 */ display: inline-grid; /* 划分行列 */ grid-template-rows: repeat(auto-fill, 100px); grid-template-columns: repeat(auto-fill, 100px); } main div { background: blueviolet content-box; padding: 10px; border: 1px #000 dashed; text-align: center; line-height: 80px; color: #fff; } 1 2 3 4 5 6 7 8 9 比例划分 如果你的栅格容器已设置宽高，则我们可以按照空间比例进行行列划分。单位是fr。 如下所示，这是一个3行3列的栅格容器，第一行和最后一行的高度都为3fr，中间一行的高度为4fr，第一列和最后一列的宽度都为2fr，中间一列的宽度为6fr： grid-template-rows: 3fr 4fr 3fr; grid-template-columns: 2fr 6fr 2fr; 代码示例： Document main { width: 300px; height: 300px; border: solid 5px silver; /* 声明容器 */ display: inline-grid; /* 划分行列 */ grid-template-rows: 3fr 4fr 3fr; grid-template-columns: 2fr 6fr 2fr; } main div { background: blueviolet content-box; padding: 10px; border: 1px #000 dashed; text-align: center; line-height: 80px; color: #fff; } 1 2 3 4 5 6 7 8 9 组合定义 grid-template是grid-template-rows、grid-template-columns、grid-template-areas 的三个属性的简写。 但是我们目前还没有介绍到grid-template-areas，所以仅演示用grid-template来划分行列。 如下将采用组合定义的方式构建出一个3行3列宽高均为100px的栅格容器： 注意：先行后列 grid-template: repeat(3, 100px) / repeat(3, 100px); 代码示例： Document main { border: solid 5px silver; /* 声明容器 */ display: inline-grid; /* 划分行列 先行后列 */ grid-template: repeat(3, 100px) / repeat(3, 100px); } main div { background: blueviolet content-box; padding: 10px; border: 1px #000 dashed; text-align: center; line-height: 80px; color: #fff; } 1 2 3 4 5 6 7 8 9 minmax划分 如果你的栅格容器设置了宽高，且栅格容器中单元格的宽高大于整体栅格容器的宽高就会发生溢出现象。 我们在划分行列时，可以指定minmax，为行线或者列线设定一个动态的取值数值来防止溢出的发生。 上面这个例子中，栅格容器宽高为200px 300px，但是行列划分时设定是3列3行100px，所以就造成了列溢出。 此时我们可以在列划分时设置minmax来进行单元格的自动缩容或者扩容： 释义：列线3根，最小取值范围为50px，最大取值范围为100px grid-template: repeat(3, 100px) / repeat(3, minmax(50px, 100px)); 栅格容器之间距定义 行间距 row-gap 栅格容器中每一个元素，现在看是紧密挨在一起的。我们可以对栅格元素本身进行margin或者padding来将彼此之前撑开留出间隙，也可以使用栅格容器提供的方法。 使用row-gap设置行间距。 Document * { padding: 0; margin: 0; } body { padding: 100px; } main { width: 300px; /* height: 300px; */ border: solid 5px silver; display: grid; /* 行数，列数 */ grid-template: repeat(3,100px)/repeat(3,minmax(50px,100px)); /* 行间距 */ row-gap:30px ; } section { background-color: blueviolet; background-clip: content-box; padding: 10px; border: dashed 1px black; text-align: center; line-height: 78px; color: #fff; } 1 2 3 4 5 6 7 8 9 列间距 columns-gap 使用column-gap定义列间距。 Document * { padding: 0; margin: 0; } body { padding: 100px; } main { width: 300px; /* height: 300px; */ border: solid 5px silver; display: grid; /* 行数，列数 */ grid-template: repeat(3,100px)/repeat(3,minmax(50px,100px)); /* 列间距 */ column-gap:30px ; } section { background-color: blueviolet; background-clip: content-box; padding: 10px; border: dashed 1px black; text-align: center; line-height: 78px; color: #fff; } 1 2 3 4 5 6 7 8 9 组合定义 gap 使用gap规则可以一次定义行、列间距，如果间距一样可以只设置一个值。 Document * { padding: 0; margin: 0; } body { padding: 100px; } main { width: 300px; /* height: 300px; */ border: solid 5px silver; display: grid; /* 行数，列数 */ grid-template: repeat(3,100px)/repeat(3,minmax(50px,100px)); /* 行列间距 */ gap:30px ; } section { background-color: blueviolet; background-clip: content-box; padding: 10px; border: dashed 1px black; text-align: center; line-height: 78px; color: #fff; } 1 2 3 4 5 6 7 8 9 栅格容器之栅格线命名 基础知识 可以发现，其实最少有2条线的数据就可以定位一个栅格元素所在的位置。 如果我们想将元素放入正中间，可以这样设置： 行线开始位：2号线开始或者1号线结束位置 列线开始位：2号线开始或者1号线结束位置 行线结束位：3号线开始或者2号线结束位置 列线结束位：3号线开始或者2号线结束位置 那么这样，我们就可以将元素定位在该容器正中，并且大小只占据1个单元格。 独立命名 我们可以为每一条栅格线都进行独立命名，现在就来将上面的伪代码实现一下。 grid-template-rows: [r1-start] 100px [r1-end r2-start] 100px [r2-end r3-start] 100px [r3-end]; grid-template-columns: [c1-start] 100px [c1-end c2-start] 100px [c2-start c3-start] 100px [c3-end]; 每条线可以有多个名字，在使用的时候可以使用其任意的且具有的名字。 当我们需要定位的时候，使用如下格式对一个元素进行定位： grid-row-start: r2-start; grid-column-start:c1-end; grid-row-end: r2-end; grid-column-end: c3-start; 注意！默认的栅格容器是不会展示栅格线的，此时需要打开浏览器的检查功能就会看到栅格线。 Document * { padding: 0; margin: 0; } body { padding: 100px; } main { width: 300px; /* height: 300px; */ border: solid 5px silver; display: grid; /* 行数，列数 */ grid-template-rows: [r1-start] 100px [r1-end r2-start] 100px [r2-end r3-start] 100px [r3-end]; grid-template-columns: [c1-start] 100px [c1-end c2-start] 100px [c2-start c3-start] 100px [c3-end]; } section { background-color: blueviolet; background-clip: content-box; padding: 10px; border: dashed 1px black; text-align: center; line-height: 78px; color: #fff; grid-row-start: r2-start; grid-column-start: c1-end; grid-row-end: r2-end; grid-column-end: c3-start; } 中间 自动命名 对于重复设置的栅格容器系统会为它自动命名，使用时使用r1、c2的方式定位栅格。 r代表行 c代表列 重复设置，命名前缀： grid-template-rows: repeat(3, [r-start] 100px [r-end]); grid-template-columns: repeat(3, [c-start] 100px [c-end]); 在使用自动命名的栅格线进行定位时，应该按照如下格式： grid-row-start: r-start 2; grid-column-start: c-start 2; grid-row-end: r-start 2; grid-column-end: c-end 2; Document * { padding: 0; margin: 0; } body { padding: 100px; } main { width: 300px; /* height: 300px; */ border: solid 5px silver; display: grid; /* 行数，列数 */ grid-template-rows: repeat(3, [r-start] 100px [r-end]); grid-template-columns: repeat(3, [c-start] 100px [c-end]); } section { background-color: blueviolet; background-clip: content-box; padding: 10px; border: dashed 1px black; text-align: center; line-height: 78px; color: #fff; grid-row-start: r-start 2; grid-column-start: c-start 2; grid-row-end: r-start 2; grid-column-end: c-end 2; } 中间 栅格元素之元素定位 定位方法 我们可以使用以下方法对栅格元素进行定位，但是关于如何定位又分为很多种。 选项 描述 grid-row-start 行开始栅格线 grid-row-end 行结束栅格线 grid-column-start 列开始栅格线 grid-column-end 列结束栅格线 栅格线位置定位 栅格线位置定位实际上就是数数，在水平的第几根线，在垂直的第几根线。 还是老办法，规定行开始线位置与行结束线位置以及列开始线位置和列结束线位置。 如下，可以看到，单纯的就是数数，非常的简单粗暴。 grid-row-start: 2; grid-column-start: 2; grid-row-end: 2; grid-column-end: 2; Document * { padding: 0; margin: 0; } body { padding: 100px; } main { width: 300px; /* height: 300px; */ border: solid 5px silver; display: grid; /* 行数，列数 */ grid-template-rows: repeat(3, 100px); grid-template-columns: repeat(3, 100px); } section { background-color: blueviolet; background-clip: content-box; padding: 10px; border: dashed 1px black; text-align: center; line-height: 78px; color: #fff; grid-row-start: 2; grid-column-start: 2; grid-row-end: 2; grid-column-end: 2; } 中间 栅格线名称定位 我们说过栅格线有独立命名和自动命名。 根据栅格线名称也可以进行定位，这里不再举例，具体参见栅格线命名一章。 偏移量定位 这个其实也比较简单，我们只需要指定行线的开始位置以及列线的开始位置即可，关于结束为止也是数数，使用span来数，往后走一根线还是两根线。 grid-row-start: 1; grid-column-start: 1; /\\ 代表从行线开始位置向后数3根线 */* grid-row-end: span 3; /\\ 代表从列线开始位置向后数3根线 */* grid-column-end: span 3; Document * { padding: 0; margin: 0; } body { padding: 100px; } main { width: 300px; /* height: 300px; */ border: solid 5px silver; display: grid; /* 行数，列数 */ grid-template-rows: repeat(3, 100px); grid-template-columns: repeat(3, 100px); } section { background-color: blueviolet; background-clip: content-box; padding: 10px; border: dashed 1px black; text-align: center; line-height: 300px; color: #fff; grid-row-start: 1; grid-column-start: 1; /* 代表从行线开始位置向后数3根线 */ grid-row-end: span 3; /* 代表从列线开始位置向后数3根线 */ grid-column-end: span 3; } 全占 简写模式 可以使用grid-row设置行开始栅格线，使用grid-column设置结束栅格线。 grid-row: 3/span 3; grid-column: 2/span 3; Document * { padding: 0; margin: 0; } body { padding: 100px; } main { width: 300px; /* height: 300px; */ border: solid 5px silver; display: grid; /* 行数，列数 */ grid-template-rows: repeat(3, 100px); grid-template-columns: repeat(3, 100px); } section { background-color: blueviolet; background-clip: content-box; padding: 10px; border: dashed 1px black; text-align: center; line-height: 78px; color: #fff; grid-row: 3/span 3; grid-column: 2/span 3; } 右下角两格 极简模式 grid-area是对上面的简写模式grid-row以及grid-column的再次简写，它的语法结构如下： 行线开始/列线开始/行线结束/列线结束 grid-area: 2/1/span 1/span 3; Document * { padding: 0; margin: 0; } body { padding: 100px; } main { width: 300px; /* height: 300px; */ border: solid 5px silver; display: grid; /* 行数，列数 */ grid-template-rows: repeat(3, 100px); grid-template-columns: repeat(3, 100px); } section { background-color: blueviolet; background-clip: content-box; padding: 10px; border: dashed 1px black; text-align: center; line-height: 78px; color: #fff; grid-area: 2/1/span 1/span 3; } 中间三格 bootstrap 栅格原理 bootstrap中的栅格系统将整个栅格容器分为了12个块，其实它的原理非常简单。 我们用目前所学的知识也能开发类似的组件，如下图： Document * { padding: 0; margin: 0; } body { padding: 100px; } .row { padding: 10px; width: 600px; border: solid 5px silver; display: grid; grid-template-columns: repeat(12, 1fr); gap: 10px 10px; } .col-1 { grid-column-end: span 1; } .col-2 { grid-column-end: span 2; } .col-3 { grid-column-end: span 3; } .col-4 { grid-column-end: span 4; } .col-5 { grid-column-end: span 5; } .col-6 { grid-column-end: span 6; } .col-7 { grid-column-end: span 7; } .col-8 { grid-column-end: span 8; } .col-9 { grid-column-end: span 9; } .col-10 { grid-column-end: span 10; } .col-11 { grid-column-end: span 11; } .col-12 { grid-column-end: span 12; } [class^=\"col-\"] { background-color: blueviolet; background-clip: content-box; height: 30px; text-align: center; color: #fff; } col-8 col-4 col-4 col-4 col-4 col-6 col-6 栅格容器之栅格区域 基础介绍 栅格区域说白了就是一堆栅格的单元格组成的区域，一个单元格也是一个区域。 我们可以使用栅格区域更方便的放置元素而不用再慢慢的数线放置，栅格区域放置元素通常用在大布局上。 使用grid-template-areas声明栅格区域时需要注意一点，栅格区域放置元素必须是矩形的。 你不能这样放置这样的一个元素： 区域命名 来看一个简单的案例，如何使用grid-template-areas对栅格区域进行命名并填充元素。 Document * { padding: 0; margin: 0; } body { padding: 100px; } main { width: 300px; /* height: 300px; */ border: solid 5px silver; display: grid; /* 行数，列数 */ grid-template-rows: repeat(3, 100px); grid-template-columns: repeat(3, 100px); grid-template-areas: \"top top top\" \"mid mid mid\" \"bottom bottom bottom\"; /* 由于绘制了9*9的单元格，我们必须给每个单元格进行了命名 ，而且一定要是这种格式*/ } main * { background-clip: content-box; padding: 10px; border: dashed 1px black; } main header { /* 完整的写法，推荐使用下面的简写方式*/ /* grid-area: top-start/top-start//top-start/top-end/top-end/top-end; */ grid-area: top; background-color: blueviolet; } main article { grid-area: mid; background-color: violet; } main footer { grid-area: bottom; background-color: yellowgreen; } 自动命名 栅格容器中的每个单元格的列行线都会根据单元格名称自动进行命名，如下图所示： 按图中这种命名来进行实验： Document * { padding: 0; margin: 0; } body { padding: 100px; } main { width: 300px; /* height: 300px; */ border: solid 5px silver; display: grid; /* 行数，列数 */ grid-template-rows: repeat(3, 100px); grid-template-columns: repeat(3, 100px); grid-template-areas: \"top-left top-center top-right\" \"mid-left mid-center mid-right\" \"bottom-left bottom-center bottom-right\"; /* 由于绘制了9*9的单元格，我们必须给每个单元格进行了命名 ，而且一定要是这种格式*/ } main * { background-clip: content-box; padding: 10px; border: dashed 1px black; } main div:first-of-type { grid-area: top-left-start/top-left-start/mid-center-end/mid-center-end; background-color: blueviolet; } main div:last-of-type { grid-area: bottom-left-start/bottom-left-start/bottom-right-end/bottom-right-end; background-color: violet; } 占位命名 栅格区域命名占位就是说有的区域不想给他取名，那么就直接.就行。 为什么要这么做呢？看下图以及代码就能理解，我们在进行区域划分的时候就想好了这一块区域是来干什么的，应该有多大，那么多余的地方直接.占位即可。 Document * { padding: 0; margin: 0; } body { padding: 100px; } main { width: 300px; /* height: 300px; */ border: solid 5px silver; display: grid; /* 行数，列数 */ grid-template-rows: repeat(3, 100px); grid-template-columns: repeat(3, 100px); grid-template-areas: \"top top top\" \"mid mid .\" \"bottom . .\"; /* 由于绘制了9*9的单元格，我们给每个单元格进行了命名 ，一定要是这种格式*/ } main * { background-clip: content-box; padding: 10px; border: dashed 1px black; } main header { /* 完整的写法，推荐使用下面的简写方式*/ /* grid-area: top-start/top-start//top-start/top-end/top-end/top-end; */ grid-area: top; background-color: blueviolet; } main article { grid-area: mid; background-color: violet; } main footer { grid-area: bottom; background-color: yellowgreen; } 栅格元素之元素排序 排序方式 默认情况下，整个栅格元素都是以行（水平）进行填充排序，我们可以在容器中设置grid-auto-flow属性可以改变元素排序的方式。 值 描述 column 按列排序 row 按行排列 Document * { padding: 0; margin: 0; } body { padding: 100px; } main { width: 300px; height: 300px; border: solid 5px silver; display: grid; /* 行数，列数 */ grid-template: repeat(3, 100px)/repeat(3, 100px); /* 排序方式：垂直 */ grid-auto-flow: column; } section { background-color: blueviolet; background-clip: content-box; padding: 10px; border: dashed 1px black; text-align: center; line-height: 78px; color: #fff; } 1 2 3 4 5 6 7 8 9 空间填充 当元素在栅格中放不下时，将会发生换行产生留白，使用grid-auto-flow: row dense; 可以执行填充空白区域操作。 如下图，产生了两个空间。 当设置之后可以发现，1和2的位置都没变，3和4填充了上来： Document * { padding: 0; margin: 0; } body { padding: 100px; } main { width: 300px; height: 300px; border: solid 5px silver; display: grid; /* 行数，列数 */ grid-template: repeat(3, 100px)/repeat(3, 100px); /* 排序方式：水平 是否填充空间：填充 */ grid-auto-flow: row dense; } section { background-color: blueviolet; background-clip: content-box; padding: 10px; border: dashed 1px black; text-align: center; line-height: 78px; color: #fff; } main section:nth-of-type(1) { /* 列线 第1根开始往后数2根的区域 */ grid-column: 1/span 2; } main section:nth-of-type(2) { /* 列线 第2根开始往后数2根的区域 */ grid-column: 2/span 2; } 1 2 3 4 对齐方式 对齐选项 可以通过属性方便的定义栅格容器内栅格元素的对齐方式，可用值包括 start | end | center | stretch | space-between | space-evenly | space-around。 下面是提供对齐的属性： 属性 描述 对象 align-items 栅格内所有元素的垂直排列方式 栅格容器 justify-items 栅格内所有元素的横向排列方式 栅格容器 justify-content 所有栅格在容器中的水平对齐方式，容器有额外空间时 栅格容器 align-content 所有栅格在容器中的垂直对齐方式，容器有额外空间时 栅格容器 align-self 元素在栅格中垂直对齐方式 栅格元素 justify-self 元素在栅格中水平对齐方式 栅格元素 下面是属性中可填入的值： 值 描述 start 元素按排序方式顺序排列 end 元素按排序方式倒序排列 center 元素在容器中 space-between 第一个元素靠起点，最后一个元素靠终点，余下元素平均分配空间 space-around 每个元素两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍 space-evenly 元素间距离平均分配 整体区域对齐 其实这些和弹性布局中的用法都差不多，可以看一下前一章写的弹性布局，那么这里就举例一个平均分配吧。 平均分布指的是，栅格容器中的栅格区域（即单元格），在栅格容器中的对齐方式。 注意：栅格容器一定要有多余空间。 指定所有区域对齐方式使用justify-content与align-content： Document * { padding: 0; margin: 0; } body { padding: 100px; } main { width: 600px; /* 宽度和高度要足够大 */ height: 600px; border: solid 5px silver; display: grid; /* 行数，列数 */ grid-template: repeat(3, 100px)/repeat(3, 100px); /* 水平平均 */ justify-content: space-evenly; /* 垂直平均 */ justify-content: space-evenly; align-content: space-evenly; } section { background-color: blueviolet; background-clip: content-box; padding: 10px; border: dashed 1px black; text-align: center; line-height: 78px; color: #fff; } 1 2 3 4 5 6 7 8 9 所有元素对齐 指的是栅格区域中具体的栅格元素的对齐方式，比如说一个单元格太大了，那么里面内容又太小了该怎么做。 指定所有栅格区域中的具体元素使用：justify-items与align-items 注意：栅格区域一定要有多余空间。 Document * { padding: 0; margin: 0; } body { padding: 100px; } main { width: 300px; height: 300px; border: solid 5px silver; display: grid; /* 行数，列数 */ grid-template: repeat(3, 100px)/repeat(3, 100px); /* 控制具体元素在单元格中的位置 */ justify-items: center; align-items: center; } section { background-color: blueviolet; background-clip: content-box; padding: 10px; border: dashed 1px black; text-align: center; color: #fff; width: 30px; height: 30px; line-height: 30px; } 1 2 3 4 5 6 7 8 9 单个元素对齐 如果想控制单个元素对齐方式，使用justify-self与align-self即可。 注意：盛放该元素的栅格区域一定要有多余空间。 Document * { padding: 0; margin: 0; } body { padding: 100px; } main { width: 300px; height: 300px; border: solid 5px silver; display: grid; /* 行数，列数 */ grid-template: repeat(3, 100px)/repeat(3, 100px); /* 控制具体元素在单元格中的位置 */ justify-items: center; align-items: center; } section { background-color: blueviolet; background-clip: content-box; padding: 10px; border: dashed 1px black; text-align: center; color: #fff; width: 30px; height: 30px; line-height: 30px; } main section:nth-of-type(1) { justify-self: end; align-self: end; } main section:nth-of-type(2) { justify-self: start; align-self: end; } main section:nth-of-type(4) { justify-self: end; align-self: start; } main section:nth-of-type(5) { justify-self: start; align-self: start; } 1 2 3 4 5 6 7 8 9 简写模式 1）place-content用于控制栅格中所有区域的对齐方式，语法如下： place-content: 2）place-items用于控制所有区域中所有元素的对齐方式，语法如下： place-items: 3）place-self用于控制区域中单个元素的对齐方式，语法如下： place-self: Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:48 "},"前端专栏/CSS/变形动画.html":{"url":"前端专栏/CSS/变形动画.html","title":"变形动画","keywords":"","body":"前言 在开始介绍CSS变形动画之前，可以先了解一下学习了它之后能做什么，有什么用，这样你看这篇文章可能会有一些动力。 学习了CSS变形动画后，你可以为你的页面做出很多炫酷的效果，如一个3D的魔方，一个很酷的旋转菜单等等。 在本章节中将会采用大量的实例进行演示，相信你如果看完这篇文章后写出的页面会更加的吸引眼球。 基础知识 坐标系统 首先我们要学习的变形动画，想达到在上图中出现的3D效果单纯的X与Y两个轴是实现不了的，还需要加入一条纵深轴，即Y轴的参与才有一个3D的视觉感受。 那么如何来理解X,Y,Z这三条轴的关系呢？可以看一下下面这张图。 X轴代表水平轴 Y轴代表垂直轴 Z轴代表纵深轴 X和Y轴都非常好理解，怎么理解这个Z轴呢？ CSS的中文名称叫做层叠样式表，那么它肯定是一层一层的。之前学习过z-index就是用来设置层的优先级，优先级越高越在上面，也可以理解为离我们肉眼越近，它把优先级低的层给盖住了，所以Z轴可以理解为我们观察的视角与被观察物体之间的一条轴。 Z轴数值越大，说明观测距离越远。 Z轴的数值可以无限大，所以设置的时候一定要小心。 变形操作 可以使用transform规则控制元素的变形操作，包括元素移动、旋转、倾斜、3D转换等等。 下表中是CSS提供的变形动作，在接下来的学习中将会对一个变形动作进行详解。 选项 说明 none 定义不进行转换。 translate(x,y) 定义 2D 转换。 translate3d(x,y,z) 定义 3D 转换。 translateX(x) 定义转换，只是用 X 轴的值。 translateY(y) 定义转换，只是用 Y 轴的值。 translateZ(z) 定义 3D 转换，只是用 Z 轴的值。 scale(x,y) 定义 2D 缩放转换。 scale3d(x,y,z) 定义 3D 缩放转换。 scaleX(x) 通过设置 X 轴的值来定义缩放转换。 scaleY(y) 通过设置 Y 轴的值来定义缩放转换。 scaleZ(z) 通过设置 Z 轴的值来定义 3D 缩放转换。 rotate(angle) 定义 2D 旋转，在参数中规定角度。 rotate3d(x,y,z,angle) 定义 3D 旋转。 rotateX(angle) 定义沿着 X 轴的 3D 旋转。 rotateY(angle) 定义沿着 Y 轴的 3D 旋转。 rotateZ(angle) 定义沿着 Z 轴的 3D 旋转。 skew(x-angle,y-angle) 定义沿着 X 和 Y 轴的 2D 倾斜转换。 skewX(angle) 定义沿着 X 轴的 2D 倾斜转换。 skewY(angle) 定义沿着 Y 轴的 2D 倾斜转换。 perspective(n) 为 3D 转换元素定义透视视图。 变形叠加 这其实是一个坑点，在使用变形中一定要注意，重复对元素设置变形操作时只在元素的原形态上操作。 我们可以先看一下下面的案例，不懂代码没关系，懂这个意思就行了。 默认处理 下面设置了两次移动，并不会移动550px 而是只移动50px。 我们在元素中先设置了右移500px，鼠标放上去时再往右移动50px，可是下面却出现了向左移动的场景，这是因为对div进行了位置居中处理，它必须要按照之前居中的位置进行50px的移动。而不是按照居中后设置的500px的地方再进行向右移动50px。 上面这句话有点绕，总之。上面设置了，位置改变了，下面再设置，不会按照已改变的位置进行变化，而是按照原位置。 代码示例： Document * { margin: 0; padding: 0; box-sizing: border-box; list-style: none; } body { height: 100vh; width: 100vw; background-color: aliceblue; display: flex; justify-content: center; align-items: center; } div { width: 200px; height: 200px; background-color: blueviolet; /* 意思就是说按x轴移动500px */ transform: translateX(500px); /* 过渡时间2s */ transition: 2s; } div:hover { /* 意思就是说按x轴移动50px */ transform: translateX(50px); } 伪类叠加 还是设置两次移动，如果移动的方向都一样，且伪类设置的移动比原本的移动多一点，就在原本的基础上直接进行变形，而不用再找开始位置了。 我们还是拿上面的案例，只不过伪类移动的数值将50px改为600px，比第一次设置大100px，那么此时他就不会再往左走，而是直接在原有基础上进行叠加，向右移动100px。 代码示例： Document * { margin: 0; padding: 0; box-sizing: border-box; list-style: none; } body { height: 100vh; width: 100vw; background-color: aliceblue; display: flex; justify-content: center; align-items: center; } div { width: 200px; height: 200px; background-color: blueviolet; /* 意思就是说按x轴移动500px */ transform: translateX(500px); /* 过渡时间2s */ transition: 2s; } div:hover { /* 意思就是说按x轴移动600px */ transform: translateX(600px); } 内联元素 内联元素即行级元素，inline元素是不能参与变形的，将其转为 inline-block 或 block 以及弹性元素时才可以产生变化效果。 :hover伪类 鼠标移动到某一元素上发生的用户行为。 当该行为出现时，我们可以为它指定一些参数的改变。 如下，改变颜色。 :target伪类 意思就是说你点击一个\\，该\\标签中的href指向的锚点标签会发生变化。 点击第一个\\元素，与之相对的锚点元素发生变化。 点击第二个\\元素，与第一个\\元素相对的锚点变化停止，与第二个\\元素相对的锚点发生变化。 代码示例： Document * { padding: 0; margin: 0; list-style: none; box-sizing: border-box; } body { width: 100vw; height: 100vh; display: flex; flex-flow: column; justify-content: center; align-items: center; } div { width: 200px; height: 200px; display: flex; justify-content: center; align-items: center; color: #fff; font-size: 2em; } div:nth-child(1) { background: red; } div:nth-child(2) { background: blue; } #div-1:target { background-color: green; } #div-2:target { background-color: black; } 原本颜色：红 原本颜色：蓝 让div-1变绿 让div-2变黑 最后注意一点 事件元素上放过渡时间，:hover上放具体的事件，如移动，旋转，倾斜等操作。 如果你设置了移动却将过渡时间放在了:hover里面，那么就会出现下面这种情况。 可以看见，直勾勾的就回来了，这种效果显然不是我们想要的。 代码示例： Document * { padding: 0; margin: 0; list-style: none; box-sizing: border-box; } body { width: 100vw; height: 100vh; display: flex; justify-content: center; align-items: center; } main { width: 400px; height: 200px; border: 1px solid #ccc; display: flex; justify-content: center; align-items: center; /* 为了设置第一个div的中心点，所以这里设置一个定位，让子元素的绝对定位参照该元素进行偏移 */ position: relative; } div:first-child { height: 8px; width: 8px; background-color: black; z-index: 1; border-radius: 50%; /* 脱离文档流并居中 */ position: absolute; left: 50%; top: 50%; margin-left: -4px; margin-top: -4px; } div:last-child { height: 100px; width: 100px; background-color: blueviolet; /* 过渡时间1s,应该放这里，而不是:hover上面 */ /* transition: 1s; */ } div:last-child:hover { transform: translateX(100px); } 移动元素 沿X轴移动时正值向右移动、负值向左移动 沿Y轴移动时正值向下移动、负值向上移动 如果使用百分数将控制元素的原尺寸计算百分比然后移动 可同时设置多个值，解析器会从左向右依次执行 变形是在原基础上更改，即第二次设置值时不是在第一次值上变化 translateX 控制元素在X轴上的移动，正值向右、负值向左。 如，我们下面设置translateX(100px)，过渡时间为1s。 代码示例： Document * { padding: 0; margin: 0; list-style: none; box-sizing: border-box; } body { width: 100vw; height: 100vh; display: flex; justify-content: center; align-items: center; } main { width: 400px; height: 200px; border: 1px solid #ccc; display: flex; justify-content: center; align-items: center; /* 为了设置第一个div的中心点，所以这里设置一个定位，让子元素的绝对定位参照该元素进行偏移 */ position: relative; } div:first-child { height: 8px; width: 8px; background-color: black; z-index: 1; border-radius: 50%; /* 脱离文档流并居中 */ position: absolute; left: 50%; top: 50%; margin-left: -4px; margin-top: -4px; } div:last-child { height: 100px; width: 100px; background-color: blueviolet; /* 过渡时间1s,应该放这里，而不是:hover上面 */ transition: 1s; } div:last-child:hover { transform: translateX(100px); } translateY 控制元素在X轴上的移动，正值向下、负值向上。 如，我们下面设置translateY(100px)，过渡时间为1s。 代码示例： Document * { padding: 0; margin: 0; list-style: none; box-sizing: border-box; } body { width: 100vw; height: 100vh; display: flex; justify-content: center; align-items: center; } main { width: 200px; height: 400px; border: 1px solid #ccc; display: flex; justify-content: center; align-items: center; /* 为了设置第一个div的中心点，所以这里设置一个定位，让子元素的绝对定位参照该元素进行偏移 */ position: relative; } div:first-child { height: 8px; width: 8px; background-color: black; z-index: 1; border-radius: 50%; /* 脱离文档流并居中 */ position: absolute; left: 50%; top: 50%; margin-left: -4px; margin-top: -4px; } div:last-child { height: 100px; width: 100px; background-color: blueviolet; /* 过渡时间1s,应该放这里，而不是:hover上面 */ transition: 1s; } div:last-child:hover { transform: translateY(100px); } translate translate是translateX以及translateY的简写模式，第一个值控制X移动，第二个值控制Y移动。 一句话，设置X与Y轴的移动，注意，这个方法中不包含Z轴，因为一旦有Z轴参与就会变为3D效果。 代码示例： Document * { padding: 0; margin: 0; list-style: none; box-sizing: border-box; } body { width: 100vw; height: 100vh; display: flex; justify-content: center; align-items: center; } main { width: 400px; height: 400px; border: 1px solid #ccc; display: flex; justify-content: center; align-items: center; /* 为了设置第一个div的中心点，所以这里设置一个定位，让子元素的绝对定位参照该元素进行偏移 */ position: relative; } div:first-child { height: 8px; width: 8px; background-color: black; z-index: 1; border-radius: 50%; /* 脱离文档流并居中 */ position: absolute; left: 50%; top: 50%; margin-left: -4px; margin-top: -4px; } div:last-child { height: 100px; width: 100px; background-color: blueviolet; /* 过渡时间1s,应该放这里，而不是:hover上面 */ transition: 1s; } div:last-child:hover { /* 先设置X轴，再设置Y轴 */ transform: translate(100px, 100px); } 百分比移动 当要移动的元素宽高为100px时，如果使用50%进行移动，则代表移动50px。 代码示例： Document * { padding: 0; margin: 0; list-style: none; box-sizing: border-box; } body { width: 100vw; height: 100vh; display: flex; justify-content: center; align-items: center; } main { width: 400px; height: 400px; border: 1px solid #ccc; display: flex; justify-content: center; align-items: center; /* 为了设置第一个div的中心点，所以这里设置一个定位，让子元素的绝对定位参照该元素进行偏移 */ position: relative; } div:first-child { height: 8px; width: 8px; background-color: black; z-index: 1; border-radius: 50%; /* 脱离文档流并居中 */ position: absolute; left: 50%; top: 50%; margin-left: -4px; margin-top: -4px; } div:last-child { height: 100px; width: 100px; background-color: blueviolet; /* 过渡时间1s,应该放这里，而不是:hover上面 */ transition: 1s; } div:last-child:hover { /* 先设置X轴，再设置Y轴 */ transform: translate(50%, 50%); } 元素居中 我们之前介绍过很多元素居中的方法，如定位操作，弹性盒模型，其实使用移动也可以达到元素居中的效果。 给你丢一套模板。 /* 让子元素脱离文档流并参照副父级元素偏移。这是定位+margin的居中方法 */ position: absolute; left: 50%; top: 50%; /* left和top设置子元素宽高的负的50%就行 */ margin-left: -3px; margin-top: -3px; /* 这是弹性盒模型控制元素居中的方法 */ display: flex; justify-content: center; align-items: center; /* 让子元素脱离文档流并参照副父级元素偏移。这是定位+移动的居中方法 */ position: absolute; left: 50%; top: 50%; /* X和Y设置子元素宽高的负的50%就行 */ transform: translate(-50%, -50%); translateZ 控制Z轴移动，正数向外（距离我们近）、负数向里移动（距离我们远）。因为Z轴是透视轴没有像X/Y一样的固定尺寸，所以不能使用百分数。 代码示例： Document * { padding: 0; margin: 0; list-style: none; box-sizing: border-box; } body { width: 100vw; height: 100vh; display: flex; justify-content: center; align-items: center; } main { width: 200px; height: 200px; display: flex; justify-content: center; align-items: center; border: 1px solid #ccc; /* 如果将Z轴移动的:hover放在div上，我们不方便一直将鼠标放在div上面，故我们设置成放在main上面让div进行Z轴移动 */ /* 为了更好的视觉效果，我们给main容器做一个透视 ,并且让它按照Y轴旋转60度，按Z轴放大5倍*/ transform: perspective(900px) rotateY(60deg) scaleZ(5); /* 使用 transform-style 用于控制3d透视 */ transform-style: preserve-3d; } main:hover div:nth-child(2) { transform: translateZ(-100px); } div { height: 100px; width: 100px; background-color: blueviolet; /* 让子元素脱离文档流并参照副父级元素偏移。这是定位+移动的居中方法 */ position: absolute; left: 50%; top: 50%; transform: translate(-50%, -50%); } div:nth-child(1) { background-color: yellow; } div:nth-child(2) { background-color: blueviolet; /* 过渡时间1s */ transition: 1s; } translate3d 用于同时控制X/Y/Z轴的移动，三个值必须输入如果某个轴不需要移动时设置为零。 代码示例： Document * { padding: 0; margin: 0; list-style: none; box-sizing: border-box; } body { width: 100vw; height: 100vh; display: flex; justify-content: center; align-items: center; } main { width: 200px; height: 200px; display: flex; justify-content: center; align-items: center; border: 1px solid #ccc; /* 如果将Z轴移动的:hover放在div上，我们不方便一直将鼠标放在div上面，故我们设置成放在main上面让div进行Z轴移动 */ /* 为了更好的视觉效果，我们给main容器做一个透视 ,并且让它按照Y轴旋转60度，按Z轴放大5倍*/ transform: perspective(900px) rotateY(60deg) scaleZ(5); /* 使用 transform-style 用于控制3d透视 */ transform-style: preserve-3d; } main:hover div:nth-child(2) { /* 由于Z轴可以无限远，所以不能用百分比 */ transform: translate3d(50%, 50%, 100px); } div { height: 100px; width: 100px; background-color: blueviolet; /* 让子元素脱离文档流并参照副父级元素偏移。这是定位+移动的居中方法 */ position: absolute; left: 50%; top: 50%; transform: translate(-50%, -50%); } div:nth-child(1) { background-color: yellow; } div:nth-child(2) { background-color: blueviolet; /* 过渡时间1s */ transition: 1s; } 渐变输入框 代码示例： Document * { padding: 0; margin: 0; list-style: none; box-sizing: border-box; } body { width: 100vw; height: 100vh; display: flex; justify-content: center; align-items: center; background: #34495e; } #form-style-gradient { width: 200px; height: 200px; display: flex; flex-flow: column; justify-content: center; align-items: center; border: 1px solid #ccc; } #form-style-gradient label input { padding: 10px; outline: none; border: none; background-color: #ecf0f1; } #form-style-gradient label { width: 80%; position: relative; overflow: hidden; margin-bottom: 20px; display: flex; flex-flow: column; justify-content: center; align-self: center; } #form-style-gradient label::before { content: ''; position: absolute; /* 移动到最下面 */ left: 0; bottom: 0; height: 2px; width: 100%; background: linear-gradient(to right, white, #1abc9c, #f1c40f, #e74c3c, white); /* 移动到label标签外，然后会被隐藏掉 */ transform: translateX(-100%); transition: 2s; } #form-style-gradient label:hover::before { /* 移动回来 */ transform: translateX(100%); } 页面切换 代码示例： Document * { padding: 0; margin: 0; } a { text-decoration: none; } body { display: flex; width: 100vw; height: 100vh; flex-direction: column; } main { position: relative; background: #f3f3f3; flex: 1; overflow: hidden; } nav { display: flex; justify-content: space-around; align-items: center; height: 8vh; text-align: center; background: #34495e; } nav a { flex: 1; font-size: 1.3em; text-transform: uppercase; font-weight: bold; opacity: .8; color: white; } nav a:nth-child(2) { border-right: solid 1px #aaa; border-left: solid 1px #aaa; } main>div { position: absolute; left: 0; top: 0; width: 100%; height: 100%; transition: all 1s; z-index: 1; background: #f3f3f3; opacity: 0; display: flex; flex-direction: column; justify-content: center; align-items: center; transform: translate(0, -100%); color: white; font-size: 2em; } main>div:target { opacity: 1; transform: translate(0%, 0%); } main>div:nth-of-type(1):target { background: #3498db; } main>div:nth-of-type(2):target { background: #9b59b6; } main>div:nth-of-type(3):target { background: #16a085; } div i[class^=\"fa\"] { font-size: 100px; color: white; } houdunren.com home video live 缩放元素 比如数值为2时表示为原尺寸的两倍。 数值为.5时为原尺寸的一半。 scaleX 按X轴缩放一半。 代码示例： Document * { padding: 0; margin: 0; list-style: none; box-sizing: border-box; } body { width: 100vw; height: 100vh; display: flex; justify-content: center; align-items: center; } main { width: 400px; height: 200px; border: 1px solid #ccc; display: flex; justify-content: center; align-items: center; /* 为了设置第一个div的中心点，所以这里设置一个定位，让子元素的绝对定位参照该元素进行偏移 */ position: relative; } div:first-child { height: 8px; width: 8px; background-color: black; z-index: 1; border-radius: 50%; /* 脱离文档流并居中 */ position: absolute; left: 50%; top: 50%; margin-left: -4px; margin-top: -4px; } div:last-child { height: 100px; width: 100px; background-color: blueviolet; /* 过渡时间1s,应该放这里，而不是:hover上面 */ transition: 1s; } div:last-child:hover { transform: scaleX(.5); } scaleY 按Y轴缩放一半。 代码示例： Document * { padding: 0; margin: 0; list-style: none; box-sizing: border-box; } body { width: 100vw; height: 100vh; display: flex; justify-content: center; align-items: center; } main { width: 200px; height: 400px; border: 1px solid #ccc; display: flex; justify-content: center; align-items: center; /* 为了设置第一个div的中心点，所以这里设置一个定位，让子元素的绝对定位参照该元素进行偏移 */ position: relative; } div:first-child { height: 8px; width: 8px; background-color: black; z-index: 1; border-radius: 50%; /* 脱离文档流并居中 */ position: absolute; left: 50%; top: 50%; margin-left: -4px; margin-top: -4px; } div:last-child { height: 100px; width: 100px; background-color: blueviolet; /* 过渡时间1s,应该放这里，而不是:hover上面 */ transition: 1s; } div:last-child:hover { transform: scaleY(.5); } scale 使用 scale 可同时设置 X/Y 轴的缩放，如果只设置一个值时表示两轴缩放相同。 使用数值定义缩放，如 .5 表示缩小一半，2 表示放大两倍。 代码示例： Document * { padding: 0; margin: 0; list-style: none; box-sizing: border-box; } body { width: 100vw; height: 100vh; display: flex; justify-content: center; align-items: center; } main { width: 200px; height: 400px; border: 1px solid #ccc; display: flex; justify-content: center; align-items: center; /* 为了设置第一个div的中心点，所以这里设置一个定位，让子元素的绝对定位参照该元素进行偏移 */ position: relative; } div:first-child { height: 8px; width: 8px; background-color: black; z-index: 1; border-radius: 50%; /* 脱离文档流并居中 */ position: absolute; left: 50%; top: 50%; margin-left: -4px; margin-top: -4px; } div:last-child { height: 100px; width: 100px; background-color: blueviolet; /* 过渡时间1s,应该放这里，而不是:hover上面 */ transition: 1s; } div:last-child:hover { transform: scale(.5, 2); } scaleZ 沿Z轴缩放元素，需要有3D透视才可以查看到效果。 代码示例： Document * { padding: 0; margin: 0; list-style: none; box-sizing: border-box; } body { width: 100vw; height: 100vh; display: flex; justify-content: center; align-items: center; } main { width: 200px; height: 200px; display: flex; justify-content: center; align-items: center; border: 1px solid #ccc; /* 如果将Z轴移动的:hover放在div上，我们不方便一直将鼠标放在div上面，故我们设置成放在main上面让div进行Z轴移动 */ /* 为了更好的视觉效果，我们给main容器做一个透视 ,并且让它按照Y轴旋转60度，按Z轴放大5倍*/ transform: perspective(900px) rotateY(45deg) scaleZ(5); /* 使用 transform-style 用于控制3d透视 */ transform-style: preserve-3d; } main:hover div:nth-child(2) { /* 放大5倍 */ transform: scaleZ(5); } div { height: 100px; width: 100px; background-color: blueviolet; /* 让子元素脱离文档流并参照副父级元素偏移。这是定位+移动的居中方法 */ position: absolute; left: 50%; top: 50%; transform: translate(-50%, -50%); } div:nth-child(1) { background-color: yellow; } div:nth-child(2) { background-color: blueviolet; /* 过渡时间1s */ transition: 1s; transform: translateZ(100px); } scale3d 沿X/Y/Z三个轴缩放元素。 代码示例： Document * { padding: 0; margin: 0; list-style: none; box-sizing: border-box; } body { width: 100vw; height: 100vh; display: flex; justify-content: center; align-items: center; } main { width: 200px; height: 200px; display: flex; justify-content: center; align-items: center; border: 1px solid #ccc; /* 如果将Z轴移动的:hover放在div上，我们不方便一直将鼠标放在div上面，故我们设置成放在main上面让div进行Z轴移动 */ /* 为了更好的视觉效果，我们给main容器做一个透视 ,并且让它按照Y轴旋转60度，按Z轴放大5倍*/ transform: perspective(900px) rotateY(45deg) scaleZ(5); /* 使用 transform-style 用于控制3d透视 */ transform-style: preserve-3d; } main:hover div:nth-child(2) { /* 放大5倍 */ transform: scale3d(.5, .5, .5); } div { height: 100px; width: 100px; background-color: blueviolet; /* 让子元素脱离文档流并参照副父级元素偏移。这是定位+移动的居中方法 */ position: absolute; left: 50%; top: 50%; transform: translate(-50%, -50%); } div:nth-child(1) { background-color: yellow; } div:nth-child(2) { background-color: blueviolet; /* 过渡时间1s */ transition: 1s; transform: translateZ(100px); } 菜单缩放 代码示例： Document * { margin: 0; padding: 0; list-style: none; box-sizing: border-box; text-decoration: none; } body { height: 100vh; width: 100vw; display: flex; flex-flow: column; justify-content: center; align-items: center; } main { width: 100px; } div i { display: inline-block; background: darkgray; font-size: 30px !important; display: flex; justify-content: center; align-items: center; } ul { display: flex; flex-flow: column; justify-content: center; align-items: center; border: 1px solid #ddd; text-transform: uppercase; /* 基点设置为左上 */ transform-origin: left top; /* 鼠标放上去有个小手 */ cursor: pointer; /* 透明度 */ opacity: .6; transform: scale(0); transition: 1s; } ul>* { margin: 3px; } main:hover ul { transform: scale(1); } 我的资料 我的关注 我的收藏 相册放大 代码示例： Document * { margin: 0; padding: 0; list-style: none; box-sizing: border-box; text-decoration: none; } body { height: 100vh; width: 100vw; display: flex; justify-content: center; align-items: center; background-color: deepskyblue; } img { height: 100px; /* 高斯模糊 */ filter: blur(10px); transform: scale(.6); transition: .5s; /* 鼠标小手 */ cursor: pointer; border: 3px double black; } img:hover { filter: none; transform: scale(1.3); } 旋转元素 使用CSS可以控制元素按照不同坐标轴进行旋转。 rotateX 控制元素按照X轴进行旋转操作。单位为deg，即°度的意思。 按水平轴发生旋转，如果旋转90deg 将不可见。 正数向上翻，负数向下翻。 如何让他可见呢？我们只需要将父级容器也旋转一下，并加上透视3D效果即可。 代码示例： Document * { padding: 0; margin: 0; list-style: none; box-sizing: border-box; } body { width: 100vw; height: 100vh; display: flex; justify-content: center; align-items: center; } main { width: 400px; height: 200px; border: 1px solid #ccc; display: flex; justify-content: center; align-items: center; /* 使用 transform-style 用于控制3d透视 */ transform-style: preserve-3d; /* 为了更好的视觉效果，我们给main容器做一个透视 ,并且让它按照X轴旋转-45度 */ transform: perspective(900px) rotateX(-45deg); /* 为了设置第一个div的中心点，所以这里设置一个定位，让子元素的绝对定位参照该元素进行偏移 */ position: relative; } div { height: 100px; width: 150px; background-color: blueviolet; display: flex; justify-content: center; align-items: center; color: #fff; font-size: 14px; /* 过渡时间1s,应该放这里，而不是:hover上面 */ transition: 1s; } div:hover { transform: rotateX(90deg); } 将按照X轴旋转90deg rotateY 按垂直轴发生旋转，如果旋转90deg 将不可见。 正数向右翻，负数向左翻。 代码示例： Document * { padding: 0; margin: 0; list-style: none; box-sizing: border-box; } body { width: 100vw; height: 100vh; display: flex; justify-content: center; align-items: center; } main { width: 400px; height: 200px; border: 1px solid #ccc; display: flex; justify-content: center; align-items: center; /* 为了设置第一个div的中心点，所以这里设置一个定位，让子元素的绝对定位参照该元素进行偏移 */ position: relative; } div { height: 100px; width: 150px; background-color: blueviolet; display: flex; justify-content: center; align-items: center; color: #fff; font-size: 14px; /* 过渡时间1s,应该放这里，而不是:hover上面 */ transition: 1s; } div:hover { transform: rotateY(90deg); } 将按照Y轴旋转90deg rotateZ 按Z轴旋转元素，效果就是沿X/Y轴的平面旋转。 代码示例： Document * { padding: 0; margin: 0; list-style: none; box-sizing: border-box; } body { width: 100vw; height: 100vh; display: flex; justify-content: center; align-items: center; } main { width: 400px; height: 200px; border: 1px solid #ccc; display: flex; justify-content: center; align-items: center; /* 使用 transform-style 用于控制3d透视 */ transform-style: preserve-3d; /* 为了更好的视觉效果，我们给main容器做一个透视 ,并且让它按照X轴旋转-45度 */ transform: perspective(900px) rotateX(-45deg); /* 为了设置第一个div的中心点，所以这里设置一个定位，让子元素的绝对定位参照该元素进行偏移 */ position: relative; } div { height: 100px; width: 150px; background-color: blueviolet; display: flex; justify-content: center; align-items: center; color: #fff; font-size: 14px; /* 过渡时间1s,应该放这里，而不是:hover上面 */ transition: 1s; } div:hover { transform: rotateZ(90deg); } 将按照Z轴旋转90deg rotate 在X与Y轴平面旋转，效果与使用 rotateZ 相同。 代码示例： Document * { padding: 0; margin: 0; list-style: none; box-sizing: border-box; } body { width: 100vw; height: 100vh; display: flex; justify-content: center; align-items: center; } main { width: 400px; height: 200px; border: 1px solid #ccc; display: flex; justify-content: center; align-items: center; /* 使用 transform-style 用于控制3d透视 */ transform-style: preserve-3d; /* 为了更好的视觉效果，我们给main容器做一个透视 ,并且让它按照X轴旋转-45度 */ transform: perspective(900px) rotateX(-45deg); /* 为了设置第一个div的中心点，所以这里设置一个定位，让子元素的绝对定位参照该元素进行偏移 */ position: relative; } div { height: 100px; width: 150px; background-color: blueviolet; display: flex; justify-content: center; align-items: center; color: #fff; font-size: 14px; /* 过渡时间1s,应该放这里，而不是:hover上面 */ transition: 1s; } div:hover { transform: rotate(90deg); } 将按照Z轴旋转90deg rotate3d 同时设置X/Y/Z轴的旋转向量值来控制元素的旋转。 需要同时设置如下四个参数。 这个是按照向量进行旋转的，比如第四个参数是90deg，那么前三个参数填1就代表各转90°。 rotate3d(tx,ty,tz,angle) 1）只转X/Y轴 2）只转Y/Z轴 3）X/Y/Z都转 代码示例： Document * { padding: 0; margin: 0; list-style: none; box-sizing: border-box; } body { width: 100vw; height: 100vh; display: flex; justify-content: center; align-items: center; } main { width: 400px; height: 200px; border: 1px solid #ccc; display: flex; justify-content: center; align-items: center; /* 使用 transform-style 用于控制3d透视 */ transform-style: preserve-3d; /* 为了更好的视觉效果，我们给main容器做一个透视 ,并且让它按照X轴旋转-45度 */ transform: perspective(900px) rotateX(-45deg); /* 为了设置第一个div的中心点，所以这里设置一个定位，让子元素的绝对定位参照该元素进行偏移 */ position: relative; } div { height: 100px; width: 150px; background-color: blueviolet; display: flex; justify-content: center; align-items: center; color: #fff; font-size: 14px; /* 过渡时间1s,应该放这里，而不是:hover上面 */ transition: 1s; } div:hover { /* X/Y/Z */ transform: rotate3d(1, 1, 1, 180deg); } X/Y/Z 180° 参数顺序 可以同时设置多个旋转规则，顺序不同结果也会不同。 如下，先按X轴转90，再按Y轴转60 div:hover { transform: rotateX(90deg) rotateY(60deg); } 代码示例： Document * { padding: 0; margin: 0; list-style: none; box-sizing: border-box; } body { width: 100vw; height: 100vh; display: flex; justify-content: center; align-items: center; } main { width: 400px; height: 200px; border: 1px solid #ccc; display: flex; justify-content: center; align-items: center; /* 使用 transform-style 用于控制3d透视 */ transform-style: preserve-3d; /* 为了更好的视觉效果，我们给main容器做一个透视 ,并且让它按照X轴旋转-45度 */ transform: perspective(900px) rotateX(-45deg); /* 为了设置第一个div的中心点，所以这里设置一个定位，让子元素的绝对定位参照该元素进行偏移 */ position: relative; } div { height: 100px; width: 150px; background-color: blueviolet; display: flex; justify-content: center; align-items: center; color: #fff; font-size: 14px; /* 过渡时间1s,应该放这里，而不是:hover上面 */ transition: 1s; } div:hover { transform: rotateX(90deg) rotateY(60deg); } X 90° Y 60° 旋转文字 代码示例： Document * { margin: 0; padding: 0; list-style: none; box-sizing: border-box; } body { height: 100vh; width: 100vw; display: flex; justify-content: center; align-items: center; } main { width: 100px; height: 100px; display: flex; flex-flow: column; justify-content: center; align-items: center; background-color: blueviolet; } main p { display: flex; justify-content: center; align-items: center; color: white; } main p span { width: 50%; height: 50%; padding: 5px; font-size: 1em; box-shadow: 0 2px 10px rgba(0, 0, 0, .3); border-radius: 50%; /* 过渡时间 */ transition: 1s; display: flex; justify-content: center; align-items: center; } main p span:first-of-type { color: green; background-color: yellow; } main p span:nth-of-type(2) { color: yellow; background-color: green; } main p span:nth-of-type(3) { color: white; background-color: deeppink; } main p span:last-of-type { color: red; background-color: rgb(140, 173, 155); } main:hover p span:nth-of-type(odd) { transform: rotate(360deg); } main:hover p span:nth-of-type(even) { transform: rotate(-360deg); } CSS 3 动画 电子时钟 这个层级有点多，每个刻度都是一个元素，每个刻度之间距离都是30°，然后再加上3根针就好了。 其实应该分四层，一层做事件驱动，一层做最下面的黑色背景，一层做红色下面的指针，一层做红色。 我就做了三层，所以事件驱动就只能放在\\上了。 样式有点丑，别介意... 代码示例： Document * { margin: 0; padding: 0; box-sizing: border-box; list-style: none; } body { height: 100vh; width: 100vw; display: flex; justify-content: center; align-items: center; } main { height: 400px; width: 400px; background-color: #000; border-radius: 50%; position: relative; } main div { height: 5%; width: 5%; background-color: green; border-radius: 50%; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); z-index: 3; } main ul:nth-of-type(1) { height: 80%; width: 80%; background-color: red; border-radius: 50%; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); z-index: 2; } main ul:nth-of-type(1) li { background-color: #fff; position: absolute; top: 50%; left: 50%; /* 全部按照上方开始转 */ transform-origin: top; transition: 10s; } body:hover main ul:nth-of-type(1) li:nth-child(1) { transform: rotate(360deg) } main ul:nth-of-type(1) li:nth-child(1) { /* 秒针 */ width: 5px; height: 46%; } main ul:nth-of-type(1) li:nth-child(2) { /* 分针 */ width: 5px; height: 40%; transform: rotate(10deg); } main ul:nth-of-type(1) li:nth-child(3) { /* 分针 */ width: 10px; height: 30%; transform: rotate(60deg); } main ul:nth-of-type(2) { height: 95%; width: 90%; border-radius: 50%; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); z-index: 1; } main ul:nth-of-type(2) li { width: 10px; height: 100%; background-color: #fff; position: absolute; top: 50%; left: 50%; } main ul:nth-of-type(2) li:nth-child(1) { /* 由于不会叠加，所以我们需要在每个元素中设置 */ transform: translate(-50%, -50%) rotate(0deg); } main ul:nth-of-type(2) li:nth-child(2) { transform: translate(-50%, -50%) rotate(30deg); } main ul:nth-of-type(2) li:nth-child(3) { transform: translate(-50%, -50%) rotate(60deg); } main ul:nth-of-type(2) li:nth-child(4) { transform: translate(-50%, -50%) rotate(90deg); } main ul:nth-of-type(2) li:nth-child(5) { transform: translate(-50%, -50%) rotate(120deg); } main ul:nth-of-type(2) li:nth-child(6) { transform: translate(-50%, -50%) rotate(150deg); } 倾斜元素 倾斜元素的单位也是deg，即为度数°。 skewX 按X轴倾斜60deg 代码示例： Document * { padding: 0; margin: 0; list-style: none; box-sizing: border-box; } body { width: 100vw; height: 100vh; display: flex; justify-content: center; align-items: center; } main { width: 400px; height: 200px; border: 1px solid #ccc; display: flex; justify-content: center; align-items: center; /* 为了设置第一个div的中心点，所以这里设置一个定位，让子元素的绝对定位参照该元素进行偏移 */ position: relative; } div:first-child { height: 8px; width: 8px; background-color: black; z-index: 1; border-radius: 50%; /* 脱离文档流并居中 */ position: absolute; left: 50%; top: 50%; margin-left: -4px; margin-top: -4px; } div:last-child { height: 100px; width: 100px; background-color: blueviolet; /* 过渡时间1s,应该放这里，而不是:hover上面 */ transition: 1s; } div:last-child:hover { transform: skewX(60deg); } skewY 按Y轴倾斜60deg 代码示例： Document * { padding: 0; margin: 0; list-style: none; box-sizing: border-box; } body { width: 100vw; height: 100vh; display: flex; justify-content: center; align-items: center; } main { width: 200px; height: 400px; border: 1px solid #ccc; display: flex; justify-content: center; align-items: center; /* 为了设置第一个div的中心点，所以这里设置一个定位，让子元素的绝对定位参照该元素进行偏移 */ position: relative; } div:first-child { height: 8px; width: 8px; background-color: black; z-index: 1; border-radius: 50%; /* 脱离文档流并居中 */ position: absolute; left: 50%; top: 50%; margin-left: -4px; margin-top: -4px; } div:last-child { height: 100px; width: 100px; background-color: blueviolet; /* 过渡时间1s,应该放这里，而不是:hover上面 */ transition: 1s; } div:last-child:hover { transform: skewY(60deg); } skew 同时设置X/Y轴倾斜操作，不指定第二个参数时Y轴倾斜为零。 代码示例： Document * { padding: 0; margin: 0; list-style: none; box-sizing: border-box; } body { width: 100vw; height: 100vh; display: flex; justify-content: center; align-items: center; } main { width: 400px; height: 400px; border: 1px solid #ccc; display: flex; justify-content: center; align-items: center; /* 为了设置第一个div的中心点，所以这里设置一个定位，让子元素的绝对定位参照该元素进行偏移 */ position: relative; } div:first-child { height: 8px; width: 8px; background-color: black; z-index: 1; border-radius: 50%; /* 脱离文档流并居中 */ position: absolute; left: 50%; top: 50%; margin-left: -4px; margin-top: -4px; } div:last-child { height: 100px; width: 100px; background-color: blueviolet; /* 过渡时间1s,应该放这里，而不是:hover上面 */ transition: 1s; } div:last-child:hover { transform: skew(60deg, 60deg); } 按钮特效 代码示例： Document * { padding: 0; margin: 0; list-style: none; box-sizing: border-box; } body { width: 100vw; height: 100vh; display: flex; justify-content: center; align-items: center; } div { display: flex; justify-content: center; align-items: center; padding: 10px 50px; border: 5px double #ddd; box-shadow: 0 3px 8px rgba(0, 0, 0, .3); background: #fa7d09; color: #fff; cursor: pointer; position: relative; overflow: hidden; z-index: 0; } div::before { content: \"\"; background: #679b9b; height: 100%; position: absolute; /* 必须设置宽度，倾斜才会生效 */ width: 0; align-self: center; transform: skewX(-45deg); transition: all .8s; z-index: -1; } div:hover::before { width: 200%; } 按钮 立体按钮 代码示例： Document * { padding: 0; margin: 0; list-style: none; box-sizing: border-box; text-decoration: none; } body { width: 100vw; height: 100vh; display: flex; justify-content: center; align-items: center; } a { width: 100px; height: 30px; font-size: 12px; background: #900d0d; color: white; text-align: center; line-height: 30px; position: relative; transform: skew(25deg, 0) rotate(-15deg); } a::after { content: \"\"; background: #900d0d; height: 100%; width: 10px; position: absolute; left: -10px; transform: skew(0, -45deg) translate(0, 5px); } a::before { content: \"\"; background: #900d0d; height: 10px; width: 100%; position: absolute; bottom: -10px; left: 0; transform: skew(-45deg, 0) translate(-5px, 0); } 一砖下去可能要命 变形基点 使用 transform-origin 设置元素的X/YZ操作的基点，用于控制旋转、倾斜等操作。 可以使用百分比，也可使用英文单词进行修改。 百分比是按照变形元素的宽高进行取值。 旋转默认以元素中心进行旋转，改变基点后可控制旋转点位置 元素移动不受变形基点所影响 平面旋转 transform-origin: bottom right;将基点改在右下。 代码示例： Document * { padding: 0; margin: 0; list-style: none; box-sizing: border-box; } body { width: 100vw; height: 100vh; display: flex; justify-content: center; align-items: center; } main { width: 400px; height: 200px; border: 1px solid #ccc; display: flex; justify-content: center; align-items: center; /* 使用 transform-style 用于控制3d透视 */ transform-style: preserve-3d; /* 为了更好的视觉效果，我们给main容器做一个透视 ,并且让它按照X轴旋转-45度 */ transform: perspective(900px) rotateX(-45deg); /* 为了设置第一个div的中心点，所以这里设置一个定位，让子元素的绝对定位参照该元素进行偏移 */ position: relative; } div { height: 100px; width: 220px; background-color: blueviolet; display: flex; justify-content: center; align-items: center; color: #fff; font-size: 14px; /* 过渡时间1s,应该放这里，而不是:hover上面 */ transition: 1s; /* 修改基点 */ transform-origin: bottom right; } main:hover div { transform: rotate(90deg); } 将按照Z轴旋转90deg 基点在右下 倾斜控制 我们依然按照右下进行倾斜。 代码示例： Document * { padding: 0; margin: 0; list-style: none; box-sizing: border-box; } body { width: 100vw; height: 100vh; display: flex; justify-content: center; align-items: center; } main { width: 400px; height: 200px; border: 1px solid #ccc; display: flex; justify-content: center; align-items: center; /* 为了设置第一个div的中心点，所以这里设置一个定位，让子元素的绝对定位参照该元素进行偏移 */ position: relative; } div:first-child { height: 8px; width: 8px; background-color: black; z-index: 1; border-radius: 50%; /* 脱离文档流并居中 */ position: absolute; left: 50%; top: 50%; margin-left: -4px; margin-top: -4px; } div:last-child { height: 100px; width: 100px; background-color: blueviolet; /* 过渡时间1s,应该放这里，而不是:hover上面 */ transition: 1s; /* 基点改在右下 */ transform-origin: bottom right; } div:last-child:hover { transform: skewX(60deg); } 三维旋转 三维旋转需要新增Y轴的基点，还是老规矩，Y轴的基点不能使用百分比。 代码示例： Document * { padding: 0; margin: 0; list-style: none; box-sizing: border-box; } body { width: 100vw; height: 100vh; display: flex; justify-content: center; align-items: center; } main { width: 400px; height: 200px; border: 1px solid #ccc; display: flex; justify-content: center; align-items: center; /* 使用 transform-style 用于控制3d透视 */ transform-style: preserve-3d; /* 为了更好的视觉效果，我们给main容器做一个透视 ,并且让它按照X轴旋转-45度 */ transform: perspective(900px) rotateX(-45deg); /* 为了设置第一个div的中心点，所以这里设置一个定位，让子元素的绝对定位参照该元素进行偏移 */ position: relative; } div { height: 100px; width: 210px; background-color: blueviolet; display: flex; justify-content: center; align-items: center; color: #fff; font-size: 14px; /* 过渡时间2s,应该放这里，而不是:hover上面 */ transition: 2s; /* 基点 */ transform-origin: right center 100px; } main:hover div { /* X/Y/Z */ transform: rotate3d(1, 1, 1, 720deg); } X right/Y center/Z 100px 720° 新年贺卡 使用变形基点，然后加上旋转元素即可。 代码示例： Document * { padding: 0; margin: 0; list-style: none; box-sizing: border-box; } body { width: 100vw; height: 100vh; display: flex; justify-content: center; align-items: center; } div { width: 200px; height: 150px; background: #fa7d09; display: flex; justify-content: center; align-items: center; color: #fff; font-size: 25px; position: relative; transform-style: preserve-3d; transform: perspective(600px) rotateX(35deg) rotateY(15deg); } div:after { content: \"新年\"; height: 100%; width: 50%; position: absolute; background-color: #fa1616; left: 0; transition: 1s; transform-origin: center left; display: flex; justify-content: flex-end; align-items: center; } div:before { content: \"快乐\"; height: 100%; width: 50%; position: absolute; background-color: #fa1616; right: 0; transition: 1s; transform-origin: center right; display: flex; justify-content: flex-start; align-items: center; } div:hover::before { transform: rotateY(180deg); } div:hover::after { transform: rotateY(-180deg); } 祝你年年有余 动感菜单 这个应该是最难的一个了，那么首先我们要有一个大圆。 鼠标放上去之后所有的小圆跟随大圆的中心点旋转转出来，然后小圆也进行旋转，围绕自身的中心点。 代码示例： Document * { padding: 0; margin: 0; list-style: none; } body { display: flex; justify-content: center; align-items: center; width: 100vw; height: 100vh; } nav { width: 400px; height: 400px; display: flex; justify-content: center; align-items: center; cursor: pointer; } nav::before { content: \"\"; background: #e74c3c; border-radius: 50%; width: 200px; height: 200px; position: absolute; box-shadow: 3px 3px 0px #34495e; } nav::after { content: \"点我\"; background: #e74c3c; border-radius: 50%; width: 200px; height: 200px; display: flex; justify-content: center; align-items: center; position: absolute; font-size: 3em; color: #fff; } nav:hover ul { transform: scale(1); } ul { transition: .5s; transform: scale(0); width: 300px; height: 300px; border-radius: 50%; } ul li { width: 80px; height: 80px; background: #e49; border-radius: 50%; position: absolute; display: flex; justify-content: center; align-items: center; font-size: 2em; color: #fff; transition: 1s; transform-origin: 150px 150px; } ul li span { display: flex; justify-content: center; align-items: center; transition: 1s; } ul li span i { font-size: 1.6em !important; } nav:hover li:nth-of-type(1) { transform: rotate(60deg); } nav:hover li:nth-of-type(2) { transform: rotate(120deg); } nav:hover li:nth-of-type(3) { transform: rotate(180deg); } nav:hover li:nth-of-type(4) { transform: rotate(240deg); } nav:hover li:nth-of-type(5) { transform: rotate(300deg); } nav:hover li:nth-of-type(6) { transform: rotate(360deg); } /* 解决小图标倾斜 */ nav:hover li:nth-of-type(1) span { transform: rotate(300deg); } nav:hover li:nth-of-type(2) span { transform: rotate(600deg); } nav:hover li:nth-of-type(3) span { transform: rotate(900deg); } nav:hover li:nth-of-type(4) span { transform: rotate(1200deg); } nav:hover li:nth-of-type(5) span { transform: rotate(1500deg); } nav:hover li:nth-of-type(6) span { transform: rotate(1800deg); } 透视景深 perspective 使用 perspective 来控制元素的透视景深 perspective 规则为舞台元素控制景深， perspective 属性为控制单个元素 舞台透视 perspective 规则用于将父级整个做为透视元素，会造成里面的每个子元素的透视是不一样的。就像现实中摆一排杯子，是使用统一透视的，每个杯子的透视不一样，造成有大有小。 代码示例： Document * { padding: 0; margin: 0; list-style: none; } body { display: flex; justify-content: center; align-items: center; width: 100vw; height: 100vh; } main { width: 400px; height: 200px; /* 给整个台子做透视 */ perspective: 200px; position: relative; border: solid 5px silver; display: flex; justify-content: center; align-items: center; } main div { width: 50%; height: 50%; background-color: blueviolet; display: flex; justify-content: center; align-items: center; color: #fff; margin: 20px; transform: rotateY(60deg); } 车1 车2 单独透视 perspective 函数用于为元素设置单独透视，下面是为元素单独设置透视参数，每个元素的透视效果是一样的。 代码示例： Document * { padding: 0; margin: 0; list-style: none; } body { display: flex; justify-content: center; align-items: center; width: 100vw; height: 100vh; } main { width: 400px; height: 200px; position: relative; border: solid 5px silver; display: flex; justify-content: center; align-items: center; } main div { width: 50%; height: 50%; background-color: blueviolet; display: flex; justify-content: center; align-items: center; color: #fff; margin: 20px; /* 给每个车做透视，现在每辆车都以相同的角度对着你 */ transform: perspective(100px) rotateY(60deg); } 车1 车2 立方体 代码示例： Document * { padding: 0; margin: 0; box-sizing: border-box; list-style: none; } body { background: #34495e; } main { position: absolute; left: 50%; top: 50%; width: 200px; height: 200px; transform-style: preserve-3d; transform-origin: 50% 50% 50px; transform: translate(-50%, -50%) rotateY(0deg); transition: 2s; } main:hover { transform: translate(-50%, -50%) rotate3d(1, 1, 0, 180deg); } div { position: absolute; width: 200px; height: 200px; background: #000; display: flex; justify-content: center; align-items: center; font-size: 4em; } div:nth-child(1) { transform-origin: right; background: #1abc9c; transform-origin: bottom; transform: translateY(-200px) rotateX(-90deg); opacity: .8; } div:nth-child(2) { transform-origin: right; background: #27ae60; transform-origin: top; transform: translateY(200px) rotateX(90deg); opacity: .8; } div:nth-child(3) { transform-origin: bottom; background: #e67e22; transform-origin: right; transform: translateX(-200px) rotateY(90deg); opacity: .8; } div:nth-child(4) { transform-origin: top; background: #8e44ad; transform-origin: left; transform: translateX(200px) rotateY(-90deg); opacity: .8; } div:nth-child(5) { transform-origin: left bottom; background: #ecf0f1; opacity: .8; } div:nth-child(6) { transform-origin: left bottom; background: #ecf0f1; opacity: .5; transform: translateZ(200px); } 1 2 3 4 5 6 3D透视 transform-style 使用 transform-style 用于控制3d透视。 应用于舞台即变形元素的父级元素 设置 overflow:visible 时 preserve-3d 才无效 选项 描述 flat 2D平面舞台 preserve-3d 3D透视舞台 三维图集 代码示例： Document body { background: #34495e; } main { position: absolute; width: 400px; height: 200px; left: 50%; top: 50%; transform-style: preserve-3d; transform-origin: center center -300px; transform: translate(-50%, -50%) rotateX(-45deg); transition: 2s; } body:hover main { transform: translate(-50%, -50%) rotateX(-45deg) rotateY(900deg); } div { position: absolute; width: 100%; height: 100%; transform-origin: center center -300px; overflow: hidden; background: content-box; padding: 10px; opacity: .5; } div:nth-child(1) { background-color: #ade498; transform: rotateY(60deg); } div:nth-child(2) { background-color: #d3de32; transform: rotateY(120deg); } div:nth-child(3) { background-color: #ffffdd; transform: rotateY(180deg); } div:nth-child(4) { background-color: #006a71; transform: rotateY(240deg); } div:nth-child(5) { background-color: #fe91ca; transform: rotateY(300deg); } div:nth-child(6) { background-color: #cffe0f; transform: rotateY(360deg); } 观看视角 perspective-origin perspective-origin用于控制视线的落点，就像我们眼睛看物体时的聚焦点。可以理解眼镜看物体的位置，比如看一台汽车，是在看车头左边看还是车头右边看。 需要设置 perspective 透视后才可以看到效果。 一般设置在舞台元素上来控制子元素 取值 说明 x-axis 定义该视图在 x 轴上的位置。默认值：50%。可能的值：left、center、right、length、% y-axis 定义该视图在 y 轴上的位置。默认值：50%。可能的值：top、center、bottom、length、% 隐藏背面 backface-visibility 使用 backface-visibility 用于控制是否可以看到元素的背面。 一般设置在元素上而不是舞台元素上 需要舞台元素（父级元素）设置 transform-style: preserve-3d 选项 说明 visible 背面可见 hidden 背面隐藏 翻转卡片 下面使用隐藏背面与透视技术制作的翻转卡片效果。 代码示例： Document * { padding: 0; margin: 0; box-sizing: border-box; } main { position: absolute; width: 100vw; height: 100vh; transition: 2s; transform-style: preserve-3d; } main.login { transform: perspective(900px) rotateY(0deg); } main.register { transform: perspective(900px) rotateY(180deg); } div { position: absolute; width: 100%; height: 100%; font-size: 5em; display: flex; flex-direction: column; justify-content: center; align-items: center; backface-visibility: hidden; transition: 2s; text-transform: uppercase; color: white; } div span { text-transform: lowercase; letter-spacing: .2em; font-size: .2em; color: #2c3e50; } div:nth-child(1) { background: #2ecc71; transform: rotateY(0deg); } div:nth-child(2) { background: #e74c3c; transform: rotateY(180deg); } nav { position: absolute; width: 100%; height: 100%; z-index: 99; text-align: center; display: flex; align-items: flex-end; justify-content: center; padding-bottom: 30px; } nav a { padding: 10px; text-decoration: none; font-size: 1em; background: #000; color: white; margin-right: 10px; cursor: pointer; left: 0; top: 0; } login houdunren.com register houdunren.com 登录 注册 function change(t) { switch (t) { case 'login': $(\"main\").removeClass().addClass('login'); break; case 'register': $(\"main\").removeClass().addClass('register'); break; } } Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:48 "},"前端专栏/CSS/过渡时间.html":{"url":"前端专栏/CSS/过渡时间.html","title":"过渡时间","keywords":"","body":"过渡时间 基础知识 在了解CSS过渡时间之前，你应该先了解一下CSS的变形动画，可以参考之前的一篇博客。 我们的元素在属性发生变化时，如果没有特地的为它设置过渡时间，整个变化过程其实是以毫秒级别进行的，过程非常快，肉眼不易察觉。 故我们要学习CSS过渡时间，来让它的变化过程更加平滑。 动画属性 不是所有css属性都有过渡效果，查看支持动画的CSS属性 ，一般来讲有中间值的属性都可以设置动画如宽度、透明度等。 可以看一下下面这个例子，比如边框的样式就不支持过渡效果，而其他的诸如背景颜色，高度宽度等等都是支持过渡效果的。 可以看到，在鼠标放上去的瞬间，边框的样式就发生变化了，而不是再跟随过渡时间进行渐变。 而其他的属性，诸如背景颜色，圆角等都是跟随过渡时间进行渐变的。 代码示例： Document * { margin: 0; padding: 0; } body { display: flex; justify-content: center; align-items: center; height: 100vh; width: 100vw; } div { height: 50px; width: 50px; background: #747d8c; border: 10px solid #ff6348; /* 添加过渡时间 1s */ transition: 1s; } body:hover div { background: #5352ed; border: 10px dotted #ffa502; width: 100px; height: 100px; border-radius: 50%; transform: translate(100px, 100px); } 元素状态 初始形态 指当页面加载后的样式状态，下面是表单设置的初始样式。 变化形态 指元素由初始状态变化后的状态，比如鼠标放上、表单获得焦点后的形态。 代码示例： Document * { padding: 0; margin: 0; } body { background: #2c3e50; display: flex; flex-direction: column; justify-content: center; align-items: center; box-sizing: border-box; width: 100vw; height: 100vh; • padding: 20px; } input { border: solid 5px #e67e22; height: 60px; width: 400px; margin-bottom: 20px; transition: 2s; } input:hover { border: solid 5px #000 !important; } input:focus { background: #e67e22; } input:checked { position: relative; width: 60px; height: 60; border: none; } input:checked::before { content: '⩗'; color: white; display: flex; justify-content: center; align-items: center; font-size: 3em; position: absolute; left: 0; top: 0; right: 0; bottom: 0; box-sizing: border-box; background: #3498db; } 过渡效果 transition-property 用于设置哪些属性应用过渡效果。 默认值为all即所有属性都发生过渡效果 多个属性使用逗号分隔 当我们使用该选项时，注意要和transition-duration搭配使用才能生效，这个才是非简写的过渡时间。 transition只是一种简写形式，如果使用transition-duration与transition进行搭配使用，则不会生效transition-duration。 属性设置 注意看，下面的这张图片里transition-duration只设置了圆角与透明度，其他的诸如宽度高度背景颜色等均未设置，所以在鼠标放上去的一瞬间未设置的属性立刻产生了变化，而圆角和透明度是随着过渡时间渐渐变化的。 代码示例： Document * { margin: 0; padding: 0; box-sizing: border-box; } body { display: flex; justify-content: center; align-items: center; width: 100vw; height: 100vh; } main { width: 400px; height: 400px; display: flex; justify-content: center; align-items: center; } div { width: 100px; height: 100px; background: #f39c12; transition-property: border-radius, opacity; /* 这个才是真正的设置过渡时间， transition只是简写形式 */ transition-duration: 1s; opacity: .5; } main:hover div { border-radius: 50%; width: 150px; height: 150px; background: #2ecc71; opacity: 1; } 禁用属性 当设置transition-property:none;后，所有的变化形态均不会跟随过渡时间发生变化。 也就是说全部都是瞬发完成。 代码示例： Document * { margin: 0; padding: 0; box-sizing: border-box; } body { display: flex; justify-content: center; align-items: center; width: 100vw; height: 100vh; } main { width: 400px; height: 400px; display: flex; justify-content: center; align-items: center; } div { width: 100px; height: 100px; background: #f39c12; transition-property: none; /* 这个才是真正的设置过渡时间， transition只是简写形式 */ transition-duration: 1s; opacity: .5; } main:hover div { border-radius: 50%; width: 150px; height: 150px; background: #2ecc71; opacity: 1; } 结束事件 transitionend 用于控制过渡结束后执行的JS事件，简写属性会触发多次如 border-radius 会触发四次事件，不难理解因为可以为border-bottom-left-radius 等四个属性独立设置过渡，所以就会有四次事件。 属性 说明 propertyName 结束过渡样式 elapsedTime 过渡需要的时间 pseudoElement 过渡的伪元素 isTrusted true:用户触发，false:脚本触发 我们只需要有JS来监听该事件即可，如下图。 当我们检测的\\标签过渡时间结束后触发了transitionend事件，然后才显示出了恭候多时的字样。 　　 代码示例： Document * { margin: 0; padding: 0; box-sizing: border-box; } body { display: flex; justify-content: center; align-items: center; width: 100vw; height: 100vh; background-color: #57606f; } main { width: 400px; height: 400px; display: flex; justify-content: center; align-items: center; } div { width: 100px; height: 100px; background: #f39c12; transition-duration: 1s; position: relative; } div:after { content: \"恭候多时\"; color: #fff; width: 100%; font-size: 1.4em; display: flex; justify-content: center; align-items: center; position: absolute; bottom: -50px; transform: scale(0); transition-duration: 1s; } main:hover div { transform: rotate(360deg); } main:hover div.show-after::after { transform: scale(1) skew(360deg); } // 检测div的 transitionend 事件 document.querySelector('div').addEventListener('transitionend', function (e) { console.log(e); // 给div添加class为show-after document.querySelector('div').className = 'show-after'; }) 此时查看一下浏览器控制台，正好对应上表中的属性。 过渡时间 transition-duration 用于设置过渡时间，需要注意以下几点： 可使用单位为 ms毫秒、s秒 默认值为0s不产生过渡效果 一个值时，所有属性使用同样的时间 二个值时，奇数属性使用第一个，偶数属性使用第二个 变化属性数量大于时间数量时，后面的属性再从第一个时间开始重复使用 统一时间 让所有动画的变形在统一时间内完成： 代码示例： Document * { padding: 0; margin: 0; } body { background: #2c3e50; display: flex; flex-direction: column; justify-content: center; align-items: center; box-sizing: border-box; width: 100vw; height: 100vh; padding: 80px; } main { width: 400px; height: 400px; } div { width: 150px; height: 150px; background-color: #34495e; border-radius: 50%; opacity: 0.2; transition-property: background-color, transform, opacity, border-radius; transition-duration: 3s; } div:hover { opacity: 1; border-radius: 0; transform: scale(2) rotate(180deg); background-color: #e67e22; } 两个时间 下面共有四个属性并设置了两个时间值，1,3属性使用第一个值，2,4属性使用第二个值。 ... div { width: 150px; height: 150px; border-radius: 50%; opacity: 0.2; transition-property: background-color, transform, opacity, border-radius; transition-duration: 200ms, 5s; } ... 多个时间 下面共有四个属性并设置了三个时间值，1,2,3属性使用1,2,3时间值，第四个属性再从新使用第一个时间值。 ... div { width: 150px; height: 150px; border-radius: 50%; opacity: 0.2; transition-property: background-color, transform, opacity, border-radius; transition-duration: 200ms, 5s, 2s; } ... 不同时间 可以为初始与变化状态设置不同的时间。 下面是将hover设置为3s，当鼠标放上时变化时间为3s。 初始设置为1s即表示变化到初始状态需要1s。 代码示例： Document * { padding: 0; margin: 0; } body { background: #2c3e50; display: flex; flex-direction: column; justify-content: center; align-items: center; box-sizing: border-box; width: 100vw; height: 100vh; padding: 80px; } main { width: 400px; height: 400px; } div { width: 150px; height: 150px; background-color: #e67e22; border-radius: 50%; transition-property: background-color, transform, opacity, border-radius; /* 结束时间，变回初始状态 如果只有该时间，则过渡时间也采用它 */ transition-duration: 1s; } div:hover { border-radius: 0; transform: scale(2) rotate(180deg); background-color: #e67e22; /* 过渡时间 */ transition-duration: 3s; } 过渡速率 transition-timing-function 用于设置整体过渡效果的速度，可在 https://cubic-bezier.com 网站在线体验效果差异。 默认参数 以下是常见的transition-timing-function过渡效果： 值 描述 linear 规定以相同速度开始至结束的过渡效果（等于 cubic-bezier(0,0,1,1)） ease 开始慢，然后快，慢下来，结束时非常慢（cubic-bezier(0.25,0.1,0.25,1)）。默认值 ease-in 开始慢，结束快（等于 cubic-bezier(0.42,0,1,1)） ease-out 开始快，结束慢（等于 cubic-bezier(0,0,0.58,1)） ease-in-out 中间快，两边慢（等于 cubic-bezier(0.42,0,0.58,1)） cubic-bezier(n,n,n,n) 在 cubic-bezier 函数中定义自己的值 差异对比 我们用linear和ease来做一个对比，左边是linear，右边是ease。 其实他们的过渡时间都是一模一样的，只是视觉上有所差异。 代码示例： Document * { margin: 0; padding: 0; box-sizing: border-box; } body { height: 100vh; width: 100vw; display: flex; justify-content: center; align-items: center; } main { height: 400px; width: 400px; display: flex; justify-content: center; align-items: center; border: 1px solid #ddd; } main div { height: 100px; width: 100px; margin: 20px; transition-duration: 3s; } main div:nth-child(1) { background-color: #ff4757; transition-timing-function: linear; } main div:nth-child(2) { background-color: #3742fa; transition-timing-function: ease; } main:hover div { width: 150px; height: 150px; border-radius: 50%; } 贝塞尔曲线 其实不管是linear或者是ease都是由贝塞尔曲线来完成的。 我们需要设置四个值 cubic-bezier(\\, \\, \\, \\)来控制曲线速度，可在 https://cubic-bezier.com 网站在线体验效果。 　　如以下是我自己调的一个数值，右边的那个，对比的是linear。 代码示例： Document * { margin: 0; padding: 0; box-sizing: border-box; } body { height: 100vh; width: 100vw; display: flex; justify-content: center; align-items: center; } main { height: 400px; width: 400px; display: flex; justify-content: center; align-items: center; border: 1px solid #ddd; } main div { height: 100px; width: 100px; margin: 20px; transition-duration: 3s; } main div:nth-child(1) { background-color: #ff4757; transition-timing-function: linear; } main div:nth-child(2) { background-color: #3742fa; transition-timing-function: cubic-bezier(.17, .67, .88, -0.47); } main:hover div { width: 150px; height: 150px; border-radius: 50%; } 步进速度 过渡使用阶梯化呈现，有点像现实生活中的机械舞，下面是把过渡分3步完成。 选项 说明 steps(n, start) 设置n个时间点，第一时间点变化状态 steps(n, end) 设置n个时间点，第一时间点初始状态 step-start 等于steps(1,start)，可以理解为从下一步开始 step-end 等于steps(1,end)，可以理解为从当前步开始 start总是先走，end总是后走。 代码示例： Document * { margin: 0; padding: 0; box-sizing: border-box; } body { height: 100vh; width: 100vw; display: flex; justify-content: center; align-items: center; } main { height: 400px; width: 800px; display: flex; border: 1px solid #ddd; position: relative; } main div { width: 200px; height: 100%; border: 1px solid #ddd; } main::after { content: \"START\"; height: 30%; width: 25%; background: #ff4757; color: #fff; font-size: 2em; /* 过渡时间2s */ transition: 2s; /* 相当于把2s分成三步走 */ transition-timing-function: steps(3, start); position: absolute; top: 0; display: flex; justify-content: center; align-items: center; } main::before { content: \"END\"; height: 30%; width: 25%; background: #70a1ff; color: #fff; font-size: 2em; /* 过渡时间2s */ transition: 2s; /* 相当于把2s分成三步走 */ transition-timing-function: steps(3, end); position: absolute; bottom: 0; display: flex; justify-content: center; align-items: center; } main:hover::before { transform: translateX(600px); } main:hover::after { transform: translateX(600px); } 时钟效果 其实步进这样一帧一帧的来走非常时候做时钟，那么这里就做一个非常简陋的时钟吧。 代码示例： Document * { margin: 0; padding: 0; box-sizing: border-box; } body { height: 100vh; width: 100vw; display: flex; justify-content: center; align-items: center; } main { height: 400px; width: 400px; display: flex; position: relative; background: #ffa502; box-shadow: 3px 3px 3px #2f3542; border-radius: 50%; } main::after { content: \"\"; height: 20px; width: 20px; border-radius: 50%; position: absolute; left: 50%; top: 50%; transform: translate(-50%, -50%); background: #1e90ff; } main::before { content: \"\"; height: 48%; width: 6px; position: absolute; left: 50%; bottom: 50%; transform: translate(-50%, 0); background: #1e90ff; transition-duration: 60s; transition-timing-function: steps(60, start); transform-origin: bottom; } main:hover::before { transform: translateX(-50%) rotate(360deg); } 延迟过渡 transition-delay 用于设置延迟过渡的时间。 默认为0s即立刻开始过渡 值可以为负数 变化属性数量大于时间数量时，后面的属性再从第一个时间开始重复使用 基本使用 下面设置了延迟时间为1s，当鼠标放上时产生变化。 代码示例： Document * { padding: 0; margin: 0; } body { background: #2c3e50; display: flex; flex-direction: column; justify-content: center; align-items: center; box-sizing: border-box; width: 100vw; height: 100vh; padding: 80px; } main { width: 400px; height: 400px; } div { width: 150px; height: 150px; background-color: #e67e22; border-radius: 50%; transition-property: background-color, transform, opacity, border-radius; transition-duration: 1s; transition-delay: 1s; } div:hover { border-radius: 0; transform: scale(2) rotate(180deg); background-color: #e67e22; } 多值延迟 可以设置不同属性的延迟时间。 代码示例： Document * { padding: 0; margin: 0; } body { background: #2c3e50; display: flex; flex-direction: column; justify-content: center; align-items: center; box-sizing: border-box; width: 100vw; height: 100vh; padding: 80px; } main { width: 400px; height: 400px; } div { width: 150px; height: 150px; background-color: #fff; /* 一一对应 */ transition-property: background-color, transform, border-radius; transition-duration: 1s, 2s, 3s; transition-delay: 1s, 3s, 5s; } div:hover { border-radius: 50%; transform: scale(2) rotate(180deg); background-color: #e67e22; } 使用负值 下例圆角属性的过渡时间为4s，设置延迟为 -4s，表示鼠标放上时直接显示在4s上的效果。如果设置为-2s显示圆角变形一半的效果。 即对圆角来说不产生过渡，是瞬发的。 代码示例： Document * { padding: 0; margin: 0; } body { background: #2c3e50; display: flex; flex-direction: column; justify-content: center; align-items: center; box-sizing: border-box; width: 100vw; height: 100vh; padding: 80px; } main { width: 400px; height: 400px; } div { width: 150px; height: 150px; background-color: #fff; transition-property: background-color, transform, border-radius; transition-duration: 1s, 2s, 4s; transition-delay: 1s, 2s, -4s; } div:hover { border-radius: 50%; transform: scale(2) rotate(180deg); background-color: #e67e22; } 组合定义 transition 可以使用transition 指令将过渡规则统一设置，需要注意以下几点。 必须设置过渡时间 延迟时间放在逗号或结束前 如果只设置一个数值，那么该数值会认为是过渡时间 transition: border-radius linear 2s 0s, background 2s 2s, width linear 2s 4s, height linear 2s 4s; /* 参与过渡的动画 贝塞尔曲线 过渡时间 延迟时间 */ 点赞案例 代码示例： Document body { width: 100vw; height: 100vh; display: flex; justify-content: center; align-items: center; background: #ecf0f1; } div { position: relative; width: 100px; height: 100px; cursor: pointer; display: flex; justify-content: center; align-items: center; } div i.fa { font-size: 100px; position: absolute; transition: all .5s; color: #ddd; } div.heart i.fa { font-size: 400px; color: #e74c3c; opacity: 0; } div.heart i.fa:nth-child(2) { font-size: 80px; color: #e74c3c; opacity: 1; } function heart() { $(\"div\").toggleClass('heart'); } Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:48 "},"前端专栏/CSS/帧动画.html":{"url":"前端专栏/CSS/帧动画.html","title":"帧动画","keywords":"","body":"基础知识 通过定义一段动画中的关键点、关键状态来创建动画。@Keyframes相比transition对动画过程和细节有更强的控制。 过渡动画是两个状态间的变化，帧动画可以处理动画过程中不同时间的细节变化， 对过渡动画理解后再学习习帧动画会非常容易，也可以把帧动画理解为多个帧之间的过渡动画。 关键帧 使用@keyframes 规则配置动画中的各个帧 from 表示起始点 to表示终点 可以使用百分数如 20% 代表动画运行到20%处 基本使用 下面使用 @keyframes 定义了动画叫 radius 并配置了两个帧动作from/to ，然后在main:hover div中使用animation-name 引用了动画并使用animation-duration声明执行三秒。 注意：动画命名不要使用CSS关键字如 none 可以看到上面的动画是从30%的圆角过渡到了50%的圆角，但是整个动画的结束是瞬间结束，并不完美。 不要着急，下面会介绍各种方法让你的帧动画随心所欲。 代码示例： Document * { margin: 0; padding: 0; list-style: none; box-sizing: border-box; } body { height: 100vh; width: 100vw; display: flex; justify-content: center; align-items: center; } main { height: 200px; width: 200px; display: flex; justify-content: center; align-items: center; border: 1px solid #ddd; } div { height: 100px; width: 100px; background: #5352ed; } main:hover div { /* 一组帧的名字 */ animation-name: radius; /* 动画时长 */ animation-duration: 3s; } @keyframes radius { from { border-radius: 30%; } to { border-radius: 50%; } } 时间点 帧动画需要定义在不同时间执行的动作，开始与结束可以使用 form/to 或 0%/100% 声明。 必须添加百分号，25%是正确写法 时间点没有顺序要求，即100%写在25%前也可以 未设置0%与100% 时将使用元素原始状态 你可以这么理解，目前所学的一组帧动画它的运行应该是这样的 初始状态 ---> 0% 或者 from ---> 100% 或者 to ---> 初始状态 　所以现在看上面的动画，就知道为什么看起来比较生硬了。 物体移动 下面定义不同时间点来让物体元素移动一圈，下例中可以不设置from/to 系统将定义为元素初始状态。 代码示例： Document * { margin: 0; padding: 0; list-style: none; box-sizing: border-box; } body { height: 100vh; width: 100vw; display: flex; justify-content: center; align-items: center; } main { height: 400px; width: 400px; display: flex; justify-content: flex-start; align-items: flex-start; border: 1px solid #ddd; } div { height: 100px; width: 100px; background: #5352ed; } main:hover div { /* 一组帧的名字 */ animation-name: move; /* 动画时长 */ animation-duration: 3s; } @keyframes move { /* 初始状态 ---> 帧 ---> 初始状态 */ 25% { transform: translate(300px, 0); } 50% { transform: translate(300px, 300px); } 75% { transform: translate(0, 300px); } } 同时声明 时间点可以动画样式一样时可以一起声明，下面将25%/75%背景一起声明。 代码示例： Document * { margin: 0; padding: 0; list-style: none; box-sizing: border-box; } body { height: 100vh; width: 100vw; display: flex; justify-content: center; align-items: center; } main { height: 400px; width: 400px; display: flex; justify-content: flex-start; align-items: flex-start; border: 1px solid #ddd; } div { height: 100px; width: 100px; background: #5352ed; } main:hover div { /* 一组帧的名字 */ animation-name: move; /* 动画时长 */ animation-duration: 3s; } @keyframes move { /* 初始状态 ---> 帧 ---> 初始状态 */ 25% { transform: translate(300px, 0); } 50% { transform: translate(300px, 300px); } 75% { transform: translate(0, 300px); } 25%, 75% { background: #ff4757; } 50%, 100% { background: #5352ed; } } 使用动画 使用animation-name 规则可以在元素身上同时使用多个动画。 使用多个动画时用逗号分隔多个 动画有相同属性时，后面动画的属性优先使用 基本使用 代码示例： Document * { margin: 0; padding: 0; list-style: none; box-sizing: border-box; } body { height: 100vh; width: 100vw; display: flex; justify-content: center; align-items: center; } main { height: 400px; width: 400px; display: flex; justify-content: flex-start; align-items: flex-start; border: 1px solid #ddd; } div { height: 100px; width: 100px; background: #5352ed; } main:hover div { /* 一组帧的名字 可以使用多组帧*/ animation-name: move, radius; /* 动画时长 */ animation-duration: 3s; } @keyframes move { /* 初始状态 ---> 帧 ---> 初始状态 */ 25% { transform: translate(300px, 0); } 50% { transform: translate(300px, 300px); } 75% { transform: translate(0, 300px); } /* 相同设置，前者不生效 */ 25%, 75% { background: #ff4757; } 50%, 100% { background: #5352ed; } } @keyframes radius { 25% { border-radius: 50%; } 50% { border-radius: 30%; } 75% { border-radius: 50%; } /* 相同设置后者覆盖前者，所以移动时的颜色会变为下面两种 */ 25%, 75% { background: #ffa502; } 50%, 100% { background: #2ed573; } } 动画时间 使用 animation-duration 可以声明动画播放的时间，即把所有帧执行一遍所需要的时间。 可以使用m秒，ms毫秒时间单位 可为不同动画单独设置执行时间 如果动画数量大于时间数量，将重新从时间列表中计算 。 如一个动画有Move,Radius,Background 而时间是1s,2s，那么Move的时间是1s，Radius的时间是2s，Background的时间从头开始数，又是1s. 效果体验 如下图的过渡时间，圆角是六秒完成，背景色是四秒完成，移动是两秒完成，但是他们的开始时间都是一样的。 代码示例： Document * { margin: 0; padding: 0; list-style: none; box-sizing: border-box; } body { height: 100vh; width: 100vw; display: flex; justify-content: center; align-items: center; } main { height: 400px; width: 400px; display: flex; justify-content: center; align-items: flex-start; border: 1px solid #ddd; } div { height: 100px; width: 100px; background: #5352ed; } main:hover div { /* 一组帧的名字 可以使用多组帧*/ animation-name: radius, background, move; /* 动画时长 圆角是六秒完成，背景色是四秒完成，移动是两秒完成，但是他们的开始时间都是一样的 */ animation-duration: 6s, 4s, 2s; /* 将动画停留在最后一帧 */ animation-fill-mode: forwards; } @keyframes radius { to { border-radius: 50%; } } @keyframes background { to {} } @keyframes move { to { transform: translate(0, 150px); } } 动画属性 不是所有css属性都有过渡效果，查看支持动画的CSS属性 ，一般来讲有中间值的属性都可以设置动画如宽度、透明度等。 如何理解中间值？ 比如，一个元素的宽度从100px变为200px，那么它们之间就有中间值。 而一个元素的边框样式从实心线变为虚心线，他们就没有中间值。 效果体验 看下面这张图，从实心线变为虚心线是瞬间变化，而背景颜色的改变却是跟着动画时间来进行渐变的。 代码示例： Document * { margin: 0; padding: 0; list-style: none; box-sizing: border-box; } body { height: 100vh; width: 100vw; display: flex; justify-content: center; align-items: center; } main { height: 400px; width: 400px; display: flex; justify-content: center; align-items: flex-start; border: 1px solid #ddd; } div { height: 100px; width: 100px; background: #5352ed; } main:hover div { /* 一组帧的名字 可以使用多组帧*/ animation-name: radius, background, move; /* 动画时长 圆角是六秒完成，背景色是四秒完成，移动是两秒完成，但是他们的开始时间都是一样的 */ animation-duration: 6s, 4s, 2s; /* 将动画停留在最后一帧 */ animation-fill-mode: forwards; } @keyframes radius { to { border-radius: 50%; } } @keyframes background { to {} } @keyframes move { to { transform: translate(0, 150px); } } 中间值 可以看下下面这个例子，左边的块from与to设置的尺寸单位没有中间值，所以是瞬间变大。 而右边块的from与to设置的尺寸单位是具有中间值的，所以是跟随动画时间进行渐变。 代码示例： Document * { margin: 0; padding: 0; list-style: none; box-sizing: border-box; } body { height: 100vh; width: 100vw; display: flex; justify-content: center; align-items: center; } main { height: 400px; width: 400px; display: flex; justify-content: space-evenly; align-items: center; border: 1px solid #ddd; } main div:nth-child(1) { background: #5352ed; } main div:nth-child(2) { background: #ff4757; } main:hover div:nth-child(1) { /* 一组帧的名字 可以使用多组帧*/ animation-name: size-percentage; /* 动画时长 */ animation-duration: 2s; /* 将动画停留在最后一帧 */ animation-fill-mode: forwards; } main:hover div:nth-child(2) { /* 一组帧的名字 可以使用多组帧*/ animation-name: size-px; /* 动画时长 */ animation-duration: 2s; /* 将动画停留在最后一帧 */ animation-fill-mode: forwards; } @keyframes size-percentage { from { width: 200px; height: 200px; } /* px 与 % 之间没有中间值，所以是瞬间出现 */ to { width: 50%; height: 50%; } } @keyframes size-px { from { width: 100px; height: 100px; } /* 有中间值，跟随动画时间进行渐变 */ to { width: 200px; height: 200px; } } 重复动画 使用animation-iteration-count 规则设置动画重复执行次数，可以给一个数字。当设置值为 infinite 表示无限循环执行。 可同时设置元素的多个动画重复，使用逗号分隔 如果动画数量大于重复数量定义，后面的动画将重新计算重复 效果体验 如下面这个案例，移动的次数是一次，而变化圆角是无限次。 代码示例： Document * { margin: 0; padding: 0; list-style: none; box-sizing: border-box; } body { height: 100vh; width: 100vw; display: flex; justify-content: center; align-items: center; } main { height: 400px; width: 400px; display: flex; justify-content: flex-start; align-items: flex-start; border: 1px solid #ddd; } div { height: 100px; width: 100px; background: #5352ed; } main:hover div { /* 一组帧的名字 可以使用多组帧*/ animation-name: move, radius; /* 动画时长 */ animation-duration: 3s; /* 代表移动只走一遍，随后就不断的圆角变化，进入死循环 */ animation-iteration-count: 1, infinite; } @keyframes move { /* 初始状态 ---> 帧 ---> 初始状态 */ 25% { transform: translate(300px, 0); } 50% { transform: translate(300px, 300px); } 75% { transform: translate(0, 300px); } /* 相同设置，前者不生效 */ 25%, 75% { background: #ff4757; } 50%, 100% { background: #5352ed; } } @keyframes radius { 25% { border-radius: 50%; } 50% { border-radius: 30%; } 75% { border-radius: 50%; } /* 相同设置后者覆盖前者，所以移动时的颜色会变为下面两种 */ 25%, 75% { background: #ffa502; } 50%, 100% { background: #2ed573; } } 心动感觉 使用循环动画绘制心动效果。 代码示例： Document * { margin: 0; padding: 0; list-style: none; box-sizing: border-box; } body { height: 100vh; width: 100vw; display: flex; justify-content: center; align-items: center; } main { height: 400px; width: 400px; display: flex; justify-content: center; align-items: center; border: 1px solid #ddd; } main i.iconfont { font-size: 100px; color: red; } main:hover i { /* 添加一组帧动画 */ animation-name: xin; /* 时间 */ animation-duration: .5s; /* 循环次数 死循环 */ animation-iteration-count: infinite; } @keyframes xin { to { opacity: .5; font-size: 120px; } 20% { opacity: .6; font-size: 130px; } 40% { opacity: .7; font-size: 140px; } 60% { opacity: .8; font-size: 150px; } 80% { opacity: .9; font-size: 160px; } to { opacity: 1; font-size: 140px; } } 动画方向 使用 animation-direction 控制动画运行的方向。 选项 说明 normal 从0%到100%运行动画 reverse 从100%到0%运行动画 alternate 先从0%到100%，然后从100%到0% alternate-reverse 先从100%到0%，然后从0%到100% 效果对比 代码示例： Document * { margin: 0; padding: 0; list-style: none; box-sizing: border-box; } body { height: 100vh; width: 100vw; display: flex; justify-content: center; align-items: center; } main { height: 400px; width: 800px; display: flex; justify-content: space-evenly; align-items: center; border: 1px solid #ddd; } main i.iconfont { font-size: 100px; color: red; position: relative; } main:hover i { /* 添加一组帧动画 */ animation-name: xin; /* 时间 */ animation-duration: .5s; /* 循环次数 死循环 */ animation-iteration-count: infinite; } main i:nth-child(1):after { content: \"normal\"; font-size: 15px; color: white; position: absolute; left: 50%; top: 50%; transform: translate(-50%, -50%); } main i:nth-child(2):after { content: \"normal-reverse\"; font-size: 15px; color: white; position: absolute; left: 50%; top: 50%; transform: translate(-50%, -50%); } main i:nth-child(3):after { content: \"alternate\"; font-size: 15px; color: white; position: absolute; left: 50%; top: 50%; transform: translate(-50%, -50%); } main i:nth-child(4):after { content: \"alternate-reverse\"; font-size: 15px; color: white; position: absolute; left: 50%; top: 50%; transform: translate(-50%, -50%); } main:hover i:nth-child(1) { /* 0-100 */ animation-direction: normal; } main:hover i:nth-child(2) { /* 100-0 */ animation-direction: reverse; } main:hover i:nth-child(3) { /* 0-100 100-0 */ animation-direction: alternate; } main:hover i:nth-child(4) { /* 100-0 0-100 */ animation-direction: alternate-reverse; } @keyframes xin { to { opacity: .5; font-size: 120px; } 20% { opacity: .6; font-size: 130px; } 40% { opacity: .7; font-size: 140px; } 60% { opacity: .8; font-size: 150px; } 80% { opacity: .9; font-size: 160px; } to { opacity: 1; font-size: 140px; } } 弹跳球 alternate-reverse是100-0 0-100，因此非常适合用来做弹跳球。 我们先把球和阴影都定义在下方，然后使用alternate-reverse将球转移到上方即可。 代码示例： Document * { margin: 0; padding: 0; list-style: none; box-sizing: border-box; } body { height: 100vh; width: 100vw; display: flex; justify-content: center; align-items: center; } main { height: 400px; width: 400px; display: flex; flex-flow: column; justify-content: flex-end; align-items: center; border: 1px solid #ddd; } main div { height: 100px; width: 100px; background: linear-gradient(45deg, #7bed9f, #2ed573, #1e90ff, #3742fa); border-radius: 50%; } main section { width: 140px; height: 20px; background: #2f3542; border-radius: 75%; /* 高斯模糊 */ filter: blur(3px); } main:hover div { /* 添加一组帧动画 */ animation-name: beat; /* 动画时间 */ animation-duration: 1s; /* 运动方式 100-0 0-100 */ animation-direction: alternate-reverse; /* 死循环 */ animation-iteration-count: infinite; } main:hover section { /* 添加一组帧动画 */ animation-name: size; /* 动画时间 */ animation-duration: 1s; /* 运动方式 100-0 0-100 */ animation-direction: alternate-reverse; /* 死循环 */ animation-iteration-count: infinite; } @keyframes beat { from { background: linear-gradient(90deg, #7bed9f, #2ed573, #1e90ff, #3742fa); width: 140px; } to { transform: translateY(-280px); } } @keyframes size { to { width: 70px; } } 延迟动画 使用 animation-delay 规则定义动画等待多长时间后执行。 我们可以为多个动画指定不同的延迟时间，与动画时间的使用规则相同。 效果体验 延迟动画 圆角3s后执行，背景色2s后执行，移动1s后执行 代码示例： Document * { margin: 0; padding: 0; list-style: none; box-sizing: border-box; } body { height: 100vh; width: 100vw; display: flex; justify-content: center; align-items: center; } main { height: 400px; width: 400px; display: flex; justify-content: center; align-items: flex-start; border: 1px solid #ddd; } div { height: 100px; width: 100px; background: #5352ed; } main:hover div { /* 一组帧的名字 可以使用多组帧*/ animation-name: radius, background, move; /* 动画时长 */ animation-duration: 2s; /* 延迟动画 圆角3s后执行，背景色2s后执行，移动1s后执行*/ animation-delay: 3s, 2s, 1s; /* 将动画停留在最后一帧 */ animation-fill-mode: forwards; } @keyframes radius { to { border-radius: 50%; } } @keyframes background { to { background-color: #ffa502; } } @keyframes move { to { transform: translate(0, 150px); } } 动画速率 系统属性 使用animation-timing-function来控制动画速率 值 描述 linear 规定以相同速度开始至结束的过渡效果（等于 cubic-bezier(0,0,1,1)）。 ease 开始慢，然后快，慢下来，结束时非常慢（cubic-bezier(0.25,0.1,0.25,1)）默认值。 ease-in 开始慢，结束快（等于 cubic-bezier(0.42,0,1,1)） ease-out 开始快，结束慢（等于 cubic-bezier(0,0,0.58,1)） ease-in-out 中间快，两边慢（等于 cubic-bezier(0.42,0,0.58,1)） cubic-bezier(n,n,n,n) 在 cubic-bezier 函数中定义自己的值 可以在帧中单独定义，将影响当前帧的速率 贝塞尔曲线 其实不管是linear或者是ease都是由贝塞尔曲线来完成的。 我们需要设置四个值 cubic-bezier(\\, \\, \\, \\)来控制曲线速度，可在 https://cubic-bezier.com 网站在线体验效果。 效果体验 代码示例： Document * { margin: 0; padding: 0; list-style: none; box-sizing: border-box; } body { height: 100vh; width: 100vw; display: flex; justify-content: center; align-items: center; } main { height: 400px; width: 400px; display: flex; justify-content: space-evenly; align-items: flex-end; border: 1px solid #ddd; } div { padding: 10px; height: 100%; width: 25%; text-align: center; background: #ff4757 content-box; color: white; } main:hover div { /* 一组帧的名字 可以使用多组帧*/ animation-name: move; /* 动画时长 */ animation-duration: 3s; /* 重复动画 死循环 */ animation-iteration-count: infinite; } main:hover div:nth-child(1) { animation-timing-function: linear; } main:hover div:nth-child(2) { animation-timing-function: ease; } main:hover div:nth-child(3) { animation-timing-function: ease-in; } main:hover div:nth-child(4) { animation-timing-function: ease-out; } main:hover div:nth-child(5) { animation-timing-function: ease-in-out; } @keyframes move { to { height: 0; } } linear ease ease-in ease-out ease-in-out 弹跳球 ease-out是开始快，结束慢，而ease-in是结束快，开始慢。因此这两个组合做弹跳小球刚好。 代码示例： Document * { margin: 0; padding: 0; list-style: none; box-sizing: border-box; } body { height: 100vh; width: 100vw; display: flex; justify-content: center; align-items: center; } main { height: 400px; width: 400px; display: flex; flex-flow: column; justify-content: space-between; align-items: center; border: 1px solid #ddd; } main div { height: 100px; width: 100px; background: linear-gradient(45deg, #eccc68, #ffa502, #ff6b81, #ff4757); border-radius: 50%; } main section { width: 70px; height: 20px; background: #2f3542; border-radius: 75%; /* 高斯模糊 */ filter: blur(3px); } main:hover div { /* 添加一组帧动画 */ animation-name: beat; /* 动画时间 */ animation-duration: 3s; /* 死循环 */ animation-iteration-count: infinite; } main:hover section { /* 添加一组帧动画 */ animation-name: size; /* 动画时间 */ animation-duration: 3s; /* 死循环 */ animation-iteration-count: infinite; } @keyframes beat { 0% { background: linear-gradient(60deg, #eccc68, #ffa502, #ff6b81, #ff4757); transform: translateY(0px); animation-timing-function: ease-in; width: 100px; } 30% { background: linear-gradient(120deg, #eccc68, #ffa502, #ff6b81, #ff4757); transform: translateY(50px); animation-timing-function: ease-in; width: 100px; } 60% { background: linear-gradient(240deg, #eccc68, #ffa502, #ff6b81, #ff4757); transform: translateY(100px); animation-timing-function: ease-in; width: 100px; } 80% { background: linear-gradient(300deg, #eccc68, #ffa502, #ff6b81, #ff4757); transform: translateY(150px); animation-timing-function: ease-in; width: 100px; } 95% { background: linear-gradient(340deg, #eccc68, #ffa502, #ff6b81, #ff4757); transform: translateY(200px); animation-timing-function: ease-in; width: 100px; } 15%, 45%, 70%, 85%, 100% { width: 140px; transform: translateY(280px); animation-timing-function: ease-out; } } @keyframes size { 0% { width: 80px; } 30% { width: 85px; } 60% { width: 95px; } 80% { width: 110px; } 95% { width: 120px; } 15%, 45%, 70%, 85%, 100% { width: 140px; } } 按钮提交 这个需要用到盒子阴影，一个元素可以有多个阴影。 盒子阴影的设置规则如下： 水平偏移度/垂直偏移度/模糊度/颜色 对于颜色而言可以使用currentColor来获取当前盒子的color属性。 代码示例： Document * { margin: 0; padding: 0; list-style: none; box-sizing: border-box; } body { height: 100vh; width: 100vw; display: flex; justify-content: center; align-items: center; } main { height: 400px; width: 400px; display: flex; justify-content: center; align-items: center; border: 1px solid #ddd; } main button { height: 40px; width: 100px; background-color: #747d8c; color: white; display: flex; justify-content: center; align-items: center; } main button::after { content: ''; display: inline-block; height: 3px; width: 3px; margin-left: 5px; } /* Js中可换成点击事件 */ button:hover::after { /* 添加一组帧动画 */ animation-name: point; /* 动画时间 */ animation-duration: 2s; /* 死循环 */ animation-iteration-count: infinite; /* 动画速率 */ animation-timing-function: linear; } @keyframes point { 60% { box-shadow: none; } 30% { box-shadow: 3px 0 currentColor; } 60% { box-shadow: 3px 0 currentColor, 9px 0 currentColor; } to { box-shadow: 3px 0 currentColor, 9px 0 currentColor, 15px 0 currentColor; } } 提交 步进速度 过渡使用阶梯化呈现，有点像现实生活中的机械舞，下面是把过渡分3步完成。 选项 说明 steps(n,start) 设置n个时间点，第一时间点变化状态 steps(n,end) 设置n个时间点，第一时间点初始状态 step-start 等于steps(1,start)，可以理解为从下一步开始 step-end 等于steps(1,end)，可以理解为从当前步开始 start总是先走，end总是后走. 代码示例： Document * { margin: 0; padding: 0; box-sizing: border-box; } body { height: 100vh; width: 100vw; display: flex; justify-content: center; align-items: center; } main { height: 400px; width: 800px; display: flex; border: 1px solid #ddd; position: relative; } main div { width: 200px; height: 100%; border: 1px solid #ddd; } main::after { content: \"START\"; height: 30%; width: 25%; background: #ff4757; color: #fff; font-size: 2em; position: absolute; top: 0; display: flex; justify-content: center; align-items: center; } main::before { content: \"END\"; height: 30%; width: 25%; background: #70a1ff; color: #fff; font-size: 2em; position: absolute; bottom: 0; display: flex; justify-content: center; align-items: center; } main:hover::after { /* 添加一组动画帧 */ animation-name: move; /* 步进动画，3步 */ animation-timing-function: steps(3, start); /* 动画时长2s */ animation-duration: 2s; } main:hover::before { /* 添加一组动画帧 */ animation-name: move; /* 步进动画，3步 */ animation-timing-function: steps(3, end); /* 动画时长2s */ animation-duration: 2s; } @keyframes move { to { transform: translateX(600px); } } 播放状态 使用 animation-play-state 可以控制动画的暂停与运行。 选项 说明 paused 鼠标放上时暂停 running 鼠标放上时运行 轮播图 代码示例： Document * { padding: 0; margin: 0; } body { width: 100vw; height: 100vh; display: flex; justify-content: center; align-items: center; background: #2c3e50; } main { width: 400px; border: solid 5px #ddd; border-width: 5px 0 5px 0; overflow: hidden; position: relative; } main:hover section { animation-play-state: paused; } main:hover ul::before { animation-play-state: paused; } section { width: 1600px; height: 200px; display: flex; flex-direction: row; animation-name: slide; animation-duration: 4s; animation-iteration-count: infinite; animation-timing-function: steps(4, end); } section div { width: 400px; height: 200px; overflow: hidden; } section div img { width: 100%; } ul { width: 200px; position: absolute; list-style: none; display: flex; justify-content: center; align-items: center; z-index: 3; bottom: 20px; left: 50%; transform: translateX(-50%); } ul li { font-size: 2em; font-weight: bold; color: white; width: 50px; height: 50px; border-radius: 50%; border: solid 3px transparent; box-sizing: border-box; display: flex; justify-content: center; align-items: center; z-index: 2; background: rgba(0, 0, 0, .3); box-shadow: 0 0 3px rgba(0, 0, 0, 1); } ul::before { content: ''; width: 50px; height: 50px; border-radius: 50%; position: absolute; background: #e74c3c; left: 0; animation-name: num; animation-duration: 4s; animation-iteration-count: infinite; animation-timing-function: steps(4, end); z-index: 1; } @keyframes slide { from { transform: translateX(0px); } to { transform: translateX(-100%); } } @keyframes num { 100% { transform: translateX(200px); } } 1 2 3 4 填充模式 animation-fill-mode 用于定义动画播放结束后的处理模式，是回到原来状态还是停止在动画结束状态。 选项 说明 none 需要等延迟结束，起始帧属性才应用 backwards 动画效果在起始帧，不等延迟结束 forwards 结束后停留动画的最后一帧 both 包含backwards与forwards规则，即动画效果在起始帧，不等延迟结束，并且在结束后停止在最后一帧 效果对比 代码示例： Document * { margin: 0; padding: 0; box-sizing: content-box; } body { display: flex; justify-content: center; align-items: center; height: 100vh; width: 100vw; } main { display: flex; justify-content: space-evenly; align-items: center; height: 200px; width: 800px; border: 1px solid #ddd; } div { height: 80px; width: 200px; background: #000 content-box; padding: 10px; display: flex; justify-content: space-evenly; align-items: center; color: #fff; position: relative; } main:hover div { /* 添加一组帧动画 */ animation-name: background; /* 运行时间 */ animation-duration: 3s; /* 延迟时间 */ animation-delay: 2s; } main div:nth-child(1)::before { content: \"等待延迟 不停留最后一帧\"; display: flex; justify-content: space-evenly; align-items: center; color: red; font-weight: bolder; position: absolute; top: -20px; } main div:nth-child(2)::before { content: \"不等待延迟 不停留最后一帧 \"; display: flex; justify-content: space-evenly; align-items: center; color: red; font-weight: bolder; position: absolute; top: -20px; } main div:nth-child(3)::before { content: \"等待延迟 停留最后一帧 \"; display: flex; justify-content: space-evenly; align-items: center; color: red; font-weight: bolder; position: absolute; top: -20px; } main div:nth-child(4)::before { content: \"不等待延迟 停留最后一帧 \"; display: flex; justify-content: space-evenly; align-items: center; color: red; font-weight: bolder; position: absolute; top: -20px; } main:hover div:nth-child(1) { animation-fill-mode: none; } main:hover div:nth-child(2) { animation-fill-mode: backwards; } main:hover div:nth-child(3) { animation-fill-mode: forwards; } main:hover div:nth-child(4) { animation-fill-mode: both; } @keyframes background { from { background-color: #ff6348; } 30% { background-color: #ffa502; } 60% { background-color: #eccc68; } to { background-color: #2ed573; } } none backwards forwards both 简写模式 和CSS中的其他属性一样，可以使用animation组合定义帧动画。animation 属性是一个简写属性，用于设置六个动画属性： animation-name 帧动画名字 animation-duration 帧动画运行时间 animation-timing-function 帧动画速率 animation-delay 帧动画播放状态（暂停/运行） animation-iteration-count 帧动画循环次数 animation-direction 延迟时间 必须存在 animation-duration属性，否则过渡时间为0没有动画效果。 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:48 "},"前端专栏/CSS/响应式布局.html":{"url":"前端专栏/CSS/响应式布局.html","title":"响应式布局","keywords":"","body":"媒体查询 媒体查询是响应式布局中非常常用的一种手段，在学习媒体查询之前要先了解什么是响应式。 所谓响应式即在不同尺寸屏幕设备上响应的内容不同 相信在之前你写的页面在PC端看非常华丽工整，但是一拿到移动端全部乱了套，这就是因为没有对页面做响应式处理。 Media Queries能在不同的条件下使用不同的样式，使页面在不同在终端设备下达到不同的渲染效果。 媒体类型 选项 说明 all 所有媒体类型 screen 用于电脑屏幕，平板电脑，智能手机等 print 打印设备 speech 应用于屏幕阅读器等发声设备 另外还有很多设备类型，如tty, tv, projection, handheld, braille, embossed, aural 等等，但是这些类型已经被废弃。 可以使用 link 与 style 中定义媒体查询 也可以使用 @import url(screen.css) screen 形式媒体使用的样式 可以用逗号分隔同时支持多个媒体设备 未指定媒体设备时等同于all style 下面我们来感受一下在screen屏幕设备与print打印设备上同一个元素给出的不同响应。 在screen上响应出红色，而在print上响应出绿色。 我们平时用的style并未指定media，此时默认为all，即所有媒体设备。 代码示例： Document h1 { color: red; } h1 { color: green; } 屏幕设备上显示红色打印设备上显示绿色 link 在 link 标签中通过 media 属性可以设置样式使用的媒体设备。 common.css 没有指定媒体所以全局应用 screen.css 应用在屏幕设备 print.css 应用在打印设备 我们平时用的link并未指定media，此时默认为all，即所有媒体设备。 代码示例： Document 屏幕设备上显示红色打印设备上显示绿色 @import 使用@import 可以引入指定设备的样式规则。文件中引入一个样式文件，在这个文件中再引入其他媒体的样式文件。 /* 引入全局的CSS样式 */ /* 在全局的CSS样式中分别导入不同设备的CSS样式 */ @import url(screen.css) screen; @import url(print.css) print; @media 可以使用 @media 做到更细的控制，即在一个样式表中为多个媒体设备定义样式。 代码示例： Document @media screen { /* 屏幕设备 */ h1 { color: red; } } @media print { /* 打印设备 */ h1 { color: green; } } 屏幕设备上显示红色打印设备上显示绿色 多媒体支持 前面已经说过，如果没有进行限制media则默认是all，all代表全部，如果我们只想让一部分媒体设备应用样式，则可以使用逗号将它们分开。 @import url(screen.css) screen,print; @media screen,print {...} 查询条件 可以使用不同条件限制使用的样式 注意：条件表达式需要放在扩号中 逻辑与 需要满足多个条件时才使用样式，多个条件使用and 连接。下例中满足以下要求才使用样式。 横屏显示 宽度不能超过768px 代码示例： Document @media screen and (orientation: landscape) and (max-width: 768px) { /* 屏幕设备 必须是宽屏 宽度小于768px */ h1 { color: red; } } 必须是屏幕设备并且宽度小于768px 逻辑或 多个或条件查询使用,逗号连接，不像其他程序中使用 or 语法。 下面的示例中如果设备是横屏显示或宽度不超768px时就使用样式规则。 代码示例： Document @media screen and (orientation: landscape), screen and (max-width: 768px) { /* 屏幕设备 必须是横屏 宽度小于768px */ h1 { color: red; } } 必须是屏幕设备并且是横屏显示 或者是屏幕设备并且宽度小于768px 逻辑非 not 表示不应用样式，即所有条件都满足时不应用样式。 必须将not写在查询的最前面 代码示例： Document @media not screen { h1 { color: red; } } 如果是屏幕设备则不应用 反之 如果是不是屏幕设备则应用 only 用来排除不支持媒体查询的浏览器。 对支持媒体查询的设备，正常调用样式，此时就当only不存在 对不支持媒体查询的设备不使用样式 only 和 not 一样只能出现在媒体查询的开始 /* 必须支持媒体查询 必须是屏幕设备并且是横屏显示还有最小宽度为768px */ @media only screen and (orientation: landscape) and (max-width: 768px) { ... } 查询特性 根据查询特性筛选出使用样式的设备。 常用特性 下面列出常用的媒体查询特性 特性 说明 orientation: landscape \\ portrait landscape横屏，portrait竖屏 width 设备宽度 height 设备高度 min-width 最小宽度（可以理解为大于该数值即成立） max-width 最大宽度（可以理解为小于该数值即成立） min-height 最小高度（可以理解为大于该数值即成立） max-height 最大高度（可以理解为小于该数值即成立） 使用示例 　　在设备宽度为568px时使用样式 @media only screen and (width:568px) { ... } 　　在设备大于 569px时使用样式 @media only screen and (min-width:569px) { ... } 　　橫屏设备并且宽度大于569px时使用样式 @media only screen and (orientation: landscape) and (min-width:569px) { ... } 响应尺寸 设备像素 不同设备的像素尺寸差异很大，比如2K的27寸屏幕与4K的27寸屏幕的像素数量是不一样的。如果我们编写CSS时还要判断设备的物理像素就会很麻烦。 我们希望编写CSS时还是按照以往方式编写，至于具体绘制到屏幕上使用的具体像素让浏览器或小程序等自动计算就可以，这是最佳解决方案。 使用以下代码可以轻松解决上面的问题了。（ 在\\标签中插入） 初始样式 有些标签默认含有内外边距，且不同浏览器大小也不一样。为了统一我们可以重置标签的CSS默认样式。 最简单的方式就是使用插件css-reset完成 自动响应 实际操作中不同设备只能取宽或高一个尺寸为响应处理，一般情况下我们取宽度响应，高度自动处理。小尺寸时高度产生滚动条，这并不影响什么。 计算公式： 使用rem单位来处理响应，因为改变rem单位会影响所有使用rem的元素，这确实非常的方便。 rem是在根元素中定义的font-size rem用来在多个设备响应处理时使用 html元素也可以使用:root选择器选择 另外还有一个单位即vw与vh 100vw表示100%设备宽度 100vh代表100%设备高度 因为使用了vw宽度系统会根据不同设备自动计算rem :root{ font-size:15px; } Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:48 "},"前端专栏/JavaScript/summary.html":{"url":"前端专栏/JavaScript/summary.html","title":"JavaScript","keywords":"","body":" 基础介绍 变量与常量 运算符相关 分支结构 流程控制 Number Boolean undefined&null String Array Map&WeakMap Set&WeakSet 函数相关 函数闭包 面向对象 this指向 属性特征 属性代理 原型继承 class语法糖 JSON Symbol Date Math RegExp window对象 DOM操作 Event操作 空间坐标 XmlHttpRequest JSONP 伪Ajax请求 Promise 手动实现Promise 异常处理 模块封装 综合练习 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:48 "},"前端专栏/JavaScript/基础介绍.html":{"url":"前端专栏/JavaScript/基础介绍.html","title":"基础介绍","keywords":"","body":"基础知识 语言介绍 JavaScript是一种属于网络的动态、弱类型脚本语言，广泛应用于WEB开发领域，常用来为网页添加各式各样的动态功能，为用户提供更流畅美观的页面效果。 HTML、CSS、JavaScript的关系为： HTML定义网页结构 CSS提供网页表现 JavaScript提供网页行为 它的设计思路如下： 借鉴C语言基本语法 借鉴Java语言的数据类型和内存管理 借鉴Scheme语言，将函数作为“一等公民” 借鉴Self语言，使用基于原型（prototype）的继承机制 1995年2月，Netscape（网景）公司加入了一位年轻的小伙伴Brendan Eich（布兰登·艾奇），此时Netscape急需一款能够能够针对其自家产品Netscape Navigation浏览器的脚本语言，于是Brendan Eich便开发出了LiveScript。 后期Netscape与Sun（太阳）公司合作，将这款语言更名为JavaScript并在1995年12月正式发布。 其实Brendan Eich在接到任务并设计出JavaScript仅仅花费了10天，这使得在未来很长一段时间里JavaScript的语法非常混乱，甚至可以说千奇百怪... 之后，Netscape公司的头号大敌，Microsoft（微软）为了抢占浏览器脚本语言市场在JavaScript发布后的1996年8月推出了JScript。 为了使脚本语言不再混乱，1996年11月，网景公司将JavaScript提交给欧洲计算机制造商协会进行标准化。ECMA-262的第一个版本于1997年6月被ECMA组织采纳。 ECMA是欧洲计算机制造商协会由Sum、微软、NetScape公司的程序员组成 ECMAScript是由ECMA-262标准化的脚本语言的名称 JavaScript官方也将JavaScript称作为ECMAScript。 尽管JavaScript和JScript与ECMAScript兼容，但它包含超出ECMAScript的功能。 适用场景 JavaScript是一款一专多能的语言，非常适合学习使用。 它的主要适用场景如下： 可以做为浏览器网页端开发 可以作为服务端后台语言使用Node.js 移动端手机APP开发，如Facebook的 React Native、uniapp、PhoneGap、IONIC 跨平台的桌面应用程序，如使用 electronjs 发展历史 1994年Netscape（网景）公司发布了Navigator浏览器1.0版本，市场占用率超过90% 1995年发布了JavaScript语言 1996年JS在 Navigator浏览器中使用 1996年微软发布JScript在IE3.0中使用 1996年11月网景公司将JS提交给ECMA(国际标准化组织)成为国际标准，用于对抗微软。 由ECMA的第39号技术专家委员会（Technical Committee 39，简称TC39）负责制订ECMAScript标准，成员包括Microsoft、Mozilla、Google等大公司。 1997年ECMA发布ECMA-262标准，推出浏览器标准语言 ECMAScript 1.0 ECMAScript 是标准而Javascript是实现 ... 2009年ECMAScript 5.0发布 2011年ECMAScript5.1发布，成为ISO国际标准，从而推动所有浏览器都支持 ... 2015年ECMAScript6发布，更名为ECMAScript 2015。 2016年ECMAScript7发布，ECMAScript2016 2017年ECMAScript8发布，ECMAScript2017 2018年ECMAScript9发布，ECMAScript2018 2019年ECMAScript10，ECMAScript2019 2020年ECMAScript11，ECMAScript2020 .... 从2015年开始 tc39委员会决定每年发布新的ECMAScript版本。 推荐工具 学习JavaScript推荐工具有2个： vscode chrome vscode作为大前端开发利器，应付JavaScript轻轻松松不在话下，并且其本身就是基于JavaScript来开发的。 chrome应当是前端工程师最常用的浏览器没有之一，它的功能非常强大，因此也是学习JavaScript的重要工具之一。 引入方式 嵌入式 在HTML文档中使用标签，并且在该标签中嵌入JavaScript代码即可。 关于type等文档类型声明可写可不写。 Document \"use strict\" console.log(\"hello world\"); 引入式 在HTML文档中使用标签，并且利用该标签src属性引入一个js文件。 关于type等文档类型声明可写可不写。 Document 延迟加载 观察上面2个示例可以发现我们的JavaScript代码总是书写在HTML和CSS代码之后。 这是因为浏览器的渲染是自上而下的，所以我们在对元素节点进行操纵时应当将标签放在尾部。 如果放在头部将会导致无法读取到节点对象。 下面介绍3种方式，可以让放在头部并防止问题的发生。 1）defer延迟加载，仅针对引入式使用。 只需要为标签加上defer属性即可： Document hello world 2）window对象的onload事件绑定，可针对嵌入式、引用式使用。 必须等待HTML文档先渲染完毕后，再自动执行JavaScript代码： Document window.onload = function () { console.log(document.querySelector(\"p\")); document.querySelector(\"p\").style.cssText = \"color:red; font-size:2rem;\" } hello world 3）使用setTimeout进行异步处理，可针对嵌入式、引用式使用。 只需要将执行代码包裹在setTimeout之中，它就能在同步渲染完成HTML文档之后再执行JavaScript代码： Document setTimeout(function () { console.log(document.querySelector(\"p\")); document.querySelector(\"p\").style.cssText = \"color:red; font-size:2rem;\" }) hello world 代码注释 单行注释 将//放在语句前，即可完成单行注释： // this is comment console.log(\"hello world\"); 多行注释 将语句包裹在/**/中间，即可完成多行注释： /* this is comment you can see hello world */ console.log(\"hello world\"); 自动分号 分号规范 一段语句结束后，应当在结尾加上分号; 这并不是强制性的，仅作为一种规范。 如果你不加分号，解释器也可以通过ASI规则进行解析并进行自动断句，一般情况下并不会出现什么错误。 除了下面的语句，JavaScript中其他的语句在结尾后都应该加上分号： 循环语句：for、while 分支语句：if、switch、try 函数声明（非函数表达式，即自执行函数） 如下所示： (function () { console.log(\"hello world\"); alert(\"hello world\"); document.write(\"hello world\"); })(); 意义作用 JavaScript库部署上线前，一般会对代码进行压缩将它变为一行。 此时如果不加分号进行手动断句，被压缩后的代码执行时解释器可能出现解析错误的情况。 因此保持手动加分号是一个良好的习惯。 运行模式 普通模式 如果直接开始编写JavaScript代码，则是普通模式运行： console.log(\"ordinary mode\"); 严格模式 如果在书写代码前加上“use strict”;则是严格模式运行： \"use strict\"; console.log(\"ordinary mode\"); 我们也可以单独的为某个函数使用严格模式： function show(){ \"use strict\"; console.log(\"strict mode run function\"); } show(); 差异对比 主流框架都采用严格模式，严格模式也是未来JavaScript的标准，所以建议代码编写时都在严格模式下进行。 它们的差异如下： 1）严格模式下变量必须使用关键字声明，未声明的变量不允许赋值，这在非严格模式下是允许的： \"use strict\"; userName = \"YunYa\" console.log(userName); // Uncaught ReferenceError: userName is not defined 2）严格模式下的关键词不允许当做变量名使用，否则抛出异常，这在非严格模式下是允许的： \"use strict\"; let try = \"data\" console.log(try); // Uncaught SyntaxError: Unexpected strict mode reserved word 3）严格模式下的函数形参不可出现多次同名的重复定义，这在非严格模式下是允许的： \"use strict\"; function show(param, param) { console.log(param); } show(1, 1); // Uncaught SyntaxError: Duplicate parameter name not allowed in this context 4）严格模式下不允许链式赋值，这在非严格模式下是允许的： \"use strict\"; let a = b = c = 1; console.log(a); console.log(b); console.log(c); // Uncaught ReferenceError: c is not defined 5）严格模式下的解构赋值必须先进行变量的关键字声明，这在非严格模式下是可以省略的： \"use strict\"; let { name, gender } = { \"name\": \"Jack\", \"gender\": 18 } console.log(name, gender); // Jack 18 有趣的JavaScript JavaScript是一门非常有趣的语言，在非严格模式下你可以看到花样百出的结果。 网络上有一张非常形象的图，Thanks for inventing JavaScript正好阐述了这一切： Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:48 "},"前端专栏/JavaScript/变量与常量.html":{"url":"前端专栏/JavaScript/变量与常量.html","title":"变量与常量","keywords":"","body":"变量声明 命名规则 JavaScript由于是动态语言，所以他的变量标识符可以保存所有类型的数据。 命名规则： 变量名必须以字母、下划线或者$开始，后面可以跟上字母、数字、下划线 不要使用关键字来做变量名，比如true、if、while、class等 推荐使用驼峰式命名 以下是JavaScript中常见的30个关键字： var let const if else switch case default for while do in break continue try catch finally throw true else null void with typeof instanceof function class new this return 声明赋值 变量必须先声明后使用，可以使用let、var关键字进行声明。 更推荐使用let进行变量声明，它是ES6后推出的新的变量声明方式，相较于var来说更优秀。 1）先声明、后赋值、再使用： \"use strict\"; let username username = \"Jack\" console.log(username); // Jack 2）声明并赋值再使用： \"use strict\"; let username = \"Jack\" console.log(username); // Jack 常量声明 命名规则 常量的命名规则与变量基本一致，但是使用的声明关键字有所不同。 常量在命名和使用时，应当注意以下一些规则： 常量名建议全部大写 常量一经声明后不可更改 常量在声明时必须同时赋值 声明赋值 常量必须先声明后使用，可以使用const关键字进行声明。 注意！常量在声明时必须同时赋值，不能先声明后赋值： \"use strict\"; const PI = 3.1415926 console.log(PI); // 3.1415926 常量一经声明后将不允许更改，否则会抛出异常。 \"use strict\"; const PI = 3.1415926 PI = 3.1415926 console.log(PI); // Uncaught TypeError: Assignment to constant variable. var let const 三大作用域 JavaScript中拥有3大作用域： 全局作用域：函数外，只有一个 局部作用域：函数内，可有多个 块级作用域：循环语句内，可有多个 不同的声明方式，声明出的变量会有不同的效果。 下面会逐一进行介绍。 window对象 window对象是一个全局对象，这意味着你可以在代码中的任何地方调用到它。 如下示例，在函数show中能调用到window： \"use strict\"; function show(){ console.log(window); } show() // Window {window: Window, self: Window, document: document, name: \"Jack\", location: Location, …} 它的作用是存储一些全局方法，全局变量。如alert()就是一个全局方法。 我们可以通过window.alert()来调用它，也可以直接简写为alert()： \"use strict\"; function show(){ alert(\"i can call alert method\"); window.alert(\"i can call alert method too\"); } show(); 1）非严格模式下，未使用关键字声明的变量将被存储到window对象中，这可能造成变量污染。 如下所示我们在局部作用域中定义了userName变量，但是在外部的全局作用域下也能调用到它，这显然十分的不合理： function show(){ userName = \"Jack\" // 等同于 window.userName = \"Jack\" } show(); console.log(userName); 2）在全局作用域中使用var声明定义的变量会被存放至window对象中，但是在局部作用域中使用var声明定义的变量不会被存放到window对象中： \"use strict\"; function show(){ var userName = \"Jack\" console.log(window.userName); } show(); var userName = \"Tom\"; console.log(window.userName); // undefined // Tom 3）使用let声明定义的变量不会被存放至window对象中： \"use strict\"; function show(){ let userName = \"Jack\" console.log(window.userName); } show(); let userName = \"Tom\"; console.log(window.userName); // undefined // undefined 4）使用const声明定义的常量不会被存放至window对象中： \"use strict\"; function show(){ const userName = \"Jack\" console.log(window.userName); } show(); const userName = \"Tom\"; console.log(window.userName); // undefined // undefined 变量提升 仅有var关键字声明的变量具有变量提升的功能。 它是指在代码运行之前，解释器会先将所有var声明定义的变量提到最前面进行初始化，检测变量名是否符合规范。 变量提升会造成一个问题，使用var声明的变量可以先使用、后定义，最终得到的结果是undefined，并不会抛出异常： \"use strict\"; console.log(userName); var userName = \"Jack\" // undefined 如果是使用let声明定义变量，则直接抛出异常，不会得到undefined，这才是我们所期望的结果： \"use strict\"; console.log(userName); let userName = \"Jack\" // Uncaught ReferenceError: Cannot access 'userName' before initialization TDZ暂时性死区 仅有let、const关键字声明的变量、常量具有TDZ暂时性死区的功能。 它其实就一个作用，let和const声明定义的变量、常量必须先定义后使用，否则就会抛出异常。 1）let具有TDZ暂时性死区的功能，所以必须先定义变量后进行使用，否则抛出异常： \"use strict\"; console.log(userName); let userName = \"Jack\" // Uncaught ReferenceError: Cannot access 'userName' before initialization 2）const具有TDZ暂时性死区的功能，所以必须先定义常量后进行使用，否则抛出异常： \"use strict\"; console.log(PI); const PI = \"Jack\" // Uncaught ReferenceError: Cannot access 'PI' before initialization 3）var不具有TDZ暂时性死区的功能，当没有先定义变量后使用时，通过变量提升机制得到的结果为undefined： \"use strict\"; console.log(userName); var userName = \"Jack\" // undefined 重复定义 在同一个作用域下，使用var声明定义的变量可以重复进行定义，但是let和const声明定义的变量、常量不能重复定义。 1）var可以在同一作用域下重复定义相同变量： \"use strict\"; var userName = \"Jack\" var userName = \"Tom\" console.log(userName); // Tom 2）let不可以在同一作用域下重复定义相同变量： \"use strict\"; let userName = \"Jack\" let userName = \"Tom\" console.log(userName); // Uncaught SyntaxError: Identifier 'userName' has already been declared 3）const不可以在同一作用域下重复定义相同常量： \"use strict\"; const userName = \"Jack\" const userName = \"Tom\" console.log(userName); // Uncaught SyntaxError: Identifier 'userName' has already been declared 块级作用域 仅有let关键字声明的变量具有块级作用域的功能。 块级作用域常出现在循环语句中。 如下所示，由于var关键字声明的变量不具有块级作用域，故可能出现变量污染的情况。 \"use strict\"; for (var i = 0; i let关键字声明的变量具有块级作用域，所以上述这种变量污染的情况可以避免，它会直接抛出一个异常： \"use strict\"; for (let i = 0; i 差异总结 上面介绍了这么多，其实就想说明1点。 不要使用var声明变量，应当使用let 以下是var、let、const的差异对照表： 声明关键字 window对象（弊端） 变量提升（缺点） TDZ暂时性死区（优点） 重复定义（缺点） 块级作用域（优点） var 全局作用域下定义的变量会存放到window对象中，非全局作用域下定义的变量不会存放到window对象中 有 无 允许 无 let 不会存放到window对象中 无 有 不允许 有 const 不会存放到window对象中 无 有 不允许 无 对象分类 值与引用 JavaScript中的所有数据类型可以分为2类，分别是值类型和object引用类型。 值类型作为基本数据类型，是直接存放在栈区内存中的，而引用类型则是存放在堆区内存中。 值类型（基本数据类型）： number、boolean、null、undefined、string 引用类型： object、array、function 它们的区别如下： 值类型是按值访问，操作的就是它们实际所保存的值，当赋值、传递时也都是传递的值本身 引用类型是按引用访问，操作时，解释器需要先从栈中读取内存地址，然后再顺藤摸瓜地找到保存在堆内存中的值，赋值、传递时也都是传递对象指针，而不是值本身 如图所示： typeof typeof用于判断基本的值类型，它可能返回的结果如下： number、boolean、undefined、string、function、object 示例演示： \"use strict\"; let num = 1; console.log(typeof num); let bool = true; console.log(typeof bool); let undef = undefined; console.log(typeof undef); let str = \"string\"; console.log(typeof str); let func = function () { return 1 + 1 }; console.log(typeof func); let obj = { x: 1, y: 2 }; console.log(typeof obj); // number // boolean // undefined // string // function // object instanceof Instanceof会返回布尔值，主要判定当前对象是否是某个对象的实例。 它比typeof更加强大，比如typeof不能区分数组，但是instanceof可以。 示例演示： \"use strict\"; let num = 1; console.log(num instanceof Number); let bool = true; console.log(bool instanceof Boolean); let str = \"string\"; console.log(str instanceof String); let func = function () { return 1 + 1 }; console.log(func instanceof Function); let obj = { x: 1, y: 2 }; console.log(obj instanceof Object); let ary = [1, 2, 3]; console.log(ary instanceof Array); // false // false // false // true // true // true 注意！instanceof如果判断字面量的基本数据类型，会返回false。 如果对象生成不是字面量形式而是完整的实例化形式就会返回true。 \"use strict\"; let num = new Number(1); console.log(num instanceof Number); let bool = new Boolean(true); console.log(bool instanceof Boolean); let str = new String(\"string\"); console.log(str instanceof String); let func = function () { return 1 + 1 }; console.log(func instanceof Function); let obj = { x: 1, y: 2 }; console.log(obj instanceof Object); let ary = [1, 2, 3]; console.log(ary instanceof Array); // true // true // true // true // true // true Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:48 "},"前端专栏/JavaScript/运算符相关.html":{"url":"前端专栏/JavaScript/运算符相关.html","title":"运算符相关","keywords":"","body":"算数运算符 四则运算 以下是常见的四则运算符 符号 意义 + 加法运算 - 减法运算 * 乘法运算 / 除法运算 ** 幂运算 % 求余运算 代码示例，普通的四则运算会生成新的值： \"use strict\"; let x = 3; let y = 2; console.log( x + y, x - y, x * y, x / y, x ** y, x % y, ); // 5 1 6 1.5 9 1 增量运算 以下是常见的增量运算符,： 符号 意义 += 增量加法运算 -= 增量减法运算 *= 增量乘法运算 /= 增量除法运算 **= 增量幂运算 %= 增量求余运算 代码示例，增量运算是在某个值原有的基础上做操作： \"use strict\"; let x = 3; let y = 2; console.log( x += y, //eq x = x + y | x = 3 + 2 x -= y, //eq x = x - y | x = 5 - 2 x *= y, //eq x = x * y | x = 3 * 2 x /= y, //eq x = x / y | x = 6 / 2 x **= y, //eq x = x ** y | x = 3 ** 2 x %= y, //eq x = x % y | x = 9 % 2 ); // 5 3 6 3 9 1 一元运算 一元运算有前置和后置的区别。 前置运算： ++i --i 后置运算： i-- i++ 它们都相当于在原有基础上+1或者-1的操作，类似于i += 1和i -= 1。 在平时使用时，两者没有什么区别，但是参与数学运算时会有一些区别。 1）前置运算的操作会先于表达式进行执行： \"use strict\"; let x = 0; console.log(++x + 30); // 第一步 x + 1 = 1 然后再 1 + 30 // 31 2）后置运算的操作会后于表达式进行执行： \"use strict\"; let x = 0; console.log(x++ + 30); // 第一步：0 + 30 = 30 第二步：计算完了对x进行+1，不过此时的x对计算结果已经没有影响了 // 30 赋值运算符 普通赋值 赋值符号为=，以下是普通赋值： \"use strict\"; let x = 0; console.log(x); // 0 平行赋值 可以进行平行赋值，一次为多个标识符进行赋值： \"use strict\"; let x = 1, y = 2, z = 3; console.log(x, y, z); // 1 2 3 链式赋值 在非严格模式下，可以进行链式赋值，多个标识符引用同一个对象： let a = b = c = 1; console.log(a); console.log(b); console.log(c); // 1 // 1 // 1 严格模式下你可以这样做： \"use strict\"; let a, b, c; a = b = c = 1; console.log(a); console.log(b); console.log(c); // 1 // 1 // 1 交叉赋值 可以进行交叉赋值，将2个标识符所指向的对象进行互换，注意使用交叉赋值时必须用[]对标识符进行包裹： \"use strict\"; let x = 1; let y = 2; [x, y] = [y, x]; console.log(x); console.log(y); // 2 // 1 比较运算符 符号意义 比较运算符的返回结果总是为true或者false，一般是用于比较2个相同类型的值的大小。 常用于条件分支结构中： 符号 意义 > 大于 小于 == 形式等于 === 类型形式等于 != 形式不等于 !== 类型形式不等于 >= 大于或者等于 小于或者等于 这里着重说明一下，比较运算符两侧如果一个是数字类型，一个是其他类型，会将其它类型转换成数字类型。 形式等于、类型形式等于、形式不等于、类型形式不等于的区别。 形式只判断2个值长的一不一样，不关心他们是否是同一类型，而类型形式则必须长的一样的同时类型也必须一样 或者说形式判定时会进行隐式转换，将对比的值统一转换为相同类型后再进行对比 如下所示： \"use strict\"; console.log(1 == \"1\"); console.log(1 === \"1\"); console.log(1 != \"1\"); console.log(1 !== \"1\"); // true // false // false // true 注意，当2侧对比的值均为引用类型时，得到的结果永远为false，此时你可以将它们全部转换为string类型后再对比： \"use strict\"; console.log( [1, 2, 3] == [1, 2, 3], [1, 2, 3] === [1, 2, 3], { k1: \"v1\" } == { k1: \"v1\" }, { k1: \"v1\" } === { k1: \"v1\" } ); console.log( [1, 2, 3].toString() == [1, 2, 3].toString(), [1, 2, 3].toString() === [1, 2, 3].toString(), { k1: \"v1\" }.toString() == { k1: \"v1\" }.toString(), { k1: \"v1\" }.toString() === { k1: \"v1\" }.toString() ); // false false false false // true true true true 逻辑运算符 符号意义 JavaScript中的常见逻辑运算符有3个： 单词 意义 ! 非，统一取反 && 与，一真一假取一假，两个为真才取真 || 或，一真一假取一真，两个为假才取假 它们的优先级是，! > && > ||。 比如，! true && false || true时，第一个true是给!计算还是给&&进行计算呢？ 根据优先级来看，它应该是给!进行计算，推算流程如下： !true && false || true false && false || true false || true true 短路运算 如果一次逻辑运算中的逻辑运算符号全部为&&或者||则会从左至右依次进行逻辑运算。 如果每一次都进行运算是很消耗时间的，所以这个时候出现了短路机制。 and = && or = || 如图所示： Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:48 "},"前端专栏/JavaScript/分支结构.html":{"url":"前端专栏/JavaScript/分支结构.html","title":"分支结构","keywords":"","body":"if 多条if语句会逐行进行判断，条件为真则执行其下的代码块，条件为假则略过： if(条件判断){ 逻辑代码; } if(条件判断){ 逻辑代码; } if(条件判断){ 逻辑代码; } 示例演示： \"use strict\"; let userAge = prompt(\"Please enter your age:\").trim(); if (userAge = 18 && userAge = 30 && userAge = 60 && userAge = 80) { console.log(\"can still meal\"); } else if代表如果怎样就怎样，else代表否则怎样就怎样。 一组if/else只会执行其中的一个。 以下是JavaScript中if/else语法： if(条件判断){ 逻辑代码; } else{ 逻辑代码; } 示例演示： \"use strict\"; let userInput = Number(prompt(\"Enter any character, determine if it is a numeric string:\").trim()); if (!Number.isNaN(userInput)) { console.log(\"Is a digital string\"); } else { console.log(\"Not a digital string\"); } else if 多条if会按顺序依次执行，对每一条if语句都进行判定，而如果使用else if则只会从多条逻辑判定中取出最先为true的进行执行，后续的判定将不会被执行。 也就是说，if/else if/else三者只会执行一个。 语法如下： if(条件判断){ 逻辑代码; } else if(条件判断){ 逻辑代码; } else{ 逻辑代码; } 示例演示： \"use strict\"; let userAge = prompt(\"Please enter your age:\").trim(); if (userAge switch switch是一种结构更加清晰的流程控制语句。 基本语法如下： 如果case后表达式或结果等于switch括号后的值，将执行此case代码块 break或者return关键字会终止switch的执行，每个case代码块后都应该加上它们中的一个 如果case执行后缺少break或return则接着执行后面的语句 当没有任何case被匹配时，将执行default后的代码块 default尽量放在最下面，如果放在上面需要在后面加上break或return switch (值){ case \"选项\": 逻辑代码; break case \"选项\": 逻辑代码; break default: 默认行为; } 示例演示： \"use strict\"; let userName = prompt(\"Please enter your name:\").trim(); switch(userName){ case \"Jack\": console.log(\"hello Jack\"); break case \"Tom\": console.log(\"hello Tom\"); break default: console.log(\"who are you\"); } 多个case可以共用一个代码块： \"use strict\"; let userGender = prompt(\"Please enter your gender\").trim(); switch (userGender) { case \"male\": case \"female\": console.log(\"I see\"); break default: console.log(\"I don't know\"); } 其实在case后可以跟随表达式，case还具有if的功能。 但是注意switch括号中一定要写上true，否则会走default： \"use strict\"; let userAge = Number(prompt(\"Please enter your age:\").trim()); switch(true){ case Number.isNaN(userAge) || userAge = 80: console.log(\"illegal\"); break case userAge 三元表达式 三元表达式中有三个重要的元素： 条件是第一元素 　 条件成立返回的值是第二元素 　 条件不成立返回的值是第三元素 JavaScript中三元表达式语法如下： ? : ; 示例如下： \"use strict\"; let userAge = Number(prompt(\"Please enter your name:\").trim()); userAge >= 18 ? console.log(\"adult\") : console.log(\"underage\"); 可选链 可选链操作符( ?. )允许读取位于连接对象链深处的属性的值，而不必明确验证链中的每个引用是否有效。?. 操作符的功能类似于 . 链式操作符，不同之处在于，在引用为空(nullish ) (null 或者 undefined) 的情况下不会引起错误，该表达式短路返回值是 undefined。与函数调用一起使用时，如果给定的函数不存在，则返回 undefined。 当尝试访问可能不存在的对象属性时，可选链操作符将会使表达式更短、更简明。在探索一个对象的内容时，如果不能确定哪些属性必定存在，可选链操作符也是很有帮助的。 ? 示例如下，只有当x为array时，才执行接下来的操作： \"use strict\"; let x = [1, 2, 3]; // 取值 let item = x?.[1]; console.log(item); // 调用方法 x?.push(4); console.log(x); // 2 // [1, 2, 3, 4] Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:48 "},"前端专栏/JavaScript/流程控制.html":{"url":"前端专栏/JavaScript/流程控制.html","title":"流程控制","keywords":"","body":"while 当程序需要重复做一件事情时，可使用while循环。 条件为真时进入循环体，条件为假时退出循环体。 注意避免死循环。 \"use strict\"; let count = 0; while (count++ do/while do while循环与while循环非常相似，它会在循环体代码执行一次后再进行条件判断，若条件为真则继续执行，条件为假则退出执行。 也就是说，do while循环会至少执行一次循环体代码： \"use strict\"; let count = 6; do { // 执行一次 console.log(count); } while (count++ for for语句只要判断条件为true就会一直执行。 我们可以用它来遍历数组、字符串、对象等容器类型的数据： \"use strict\"; let ary = [\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\"]; for (let i = 0; i for/in for/in在迭代遍历具有index的对象（数组、字符串）时，迭代变量拿到的全是索引。 for/in更适合遍历object，它只会拿到key。 切记不要用for/in来遍历DOM对象集合，它会拿出该对象所包含的全部内容！ 1）遍历数组时，迭代变量拿到的全是索引： \"use strict\"; let ary = [\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\"]; for (let idx in ary) { console.log(ary[idx]); } // A // B // C // D // E // F // G 2）遍历对象时，迭代变量拿到的全是key： \"use strict\"; let obj = { k1: \"v1\", k2: \"v2\", k3: \"v3\" }; for (let k in obj) { console.log(obj[k]); } // v1 // v2 // v3 3）遍历DOM对象集合NodeList时，会发现遍历出很多我们并不关心的数据项，如NodeList的长度、所包含方法等，所以不要用for/in来遍历DOM对象集合： // HTML 1 2 3 4 5 6 // JavaScript \"use strict\"; let nodeList = document.querySelectorAll(\"p\"); for (let idx in nodeList) { console.log(nodeList[idx]); } // 1 // 2 // 3 // 4 // 5 // 6 // 下面都是我们不关心的数据项，方法、长度 // ƒ entries() { [native code] } // ƒ keys() { [native code] } // ƒ values() { [native code] } // ƒ forEach() { [native code] } // 6 // f item() { [native code] } for/of for/of是ES6中新推出的语法。 它仅适用于遍历可迭代对象，内置可迭代对象有：String、Array、TypedArray、Map、Set 若要遍历其他对象则需要创建出迭代器后方能使用for/of 1）迭代遍历数组、字符串时迭代变量只会拿到数据项本身，不会拿到索引： \"use strict\"; let ary = [\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\"]; for (let item of ary) { console.log(item); } // A // B // C // D // E // F // G 2）迭代遍历object时，要手动创建一个迭代器才能迭代： \"use strict\"; let obj = { k1: \"v1\", k2: \"v2\", k3: \"v3\" }; for (let [k,v] of Object.entries(obj)) { console.log(k, v); } // k1 v1 // k2 v2 // k3 v3 3）遍历DOM对象集合时，只会遍历出元素本身，不会遍历出NodeList所包含的方法、长度： // HTML 1 2 3 4 5 6 // JavaScript \"use strict\"; let nodeList = document.querySelectorAll(\"p\"); for (let element of nodeList) { console.log(element); } // 1 // 2 // 3 // 4 // 5 // 6 continue continue用于跳过本次循环。 如下所示，在遍历遇到奇数项时跳过： \"use strict\"; for (let i = 10; i > 0; i--) { if ((i % 2)) { continue; } console.log(i); } // 10 // 8 // 6 // 4 // 2 break break用于跳出当前循环。 如下所示，当i等于5时终止循环： \"use strict\"; let i = 0 while (i label 当有多层循环嵌套时，我们可以为每一层循环设置一个label。 当使用break label的时候就可直接跳出多层循环。 注意！该方法很少使用到，因为他会降低代码可读性： \"use strict\"; outer: for (let i = 0; i Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:48 "},"前端专栏/JavaScript/Number.html":{"url":"前端专栏/JavaScript/Number.html","title":"Number","keywords":"","body":"基本声明 JavaScript中的Number类型包含整数和浮点数。 以下是使用类实例化的形式进行对象声明： \"use strict\"; let age = new Number(12); console.log(`value : ${age}\\ntype : ${typeof age}`); // value : 12 // type : number 也可以选择使用更方便的字面量形式进行对象声明： \"use strict\"; let age = 12; console.log(`value : ${age}\\ntype : ${typeof age}`); // value : 12 // type : number 若new Number()时没有传入参数，则生成0： \"use strict\"; let age = new Number(); console.log(`value : ${age}\\ntype : ${typeof age}`); // value : 0 // type : number NaN NaN表示一个无效的数值，它不能使用==与其他值做对比。 你可以通过Number.isNaN()方法或者Object.is()方法判定一个值是否属于NaN： \"use strict\"; let v = 123.4; console.log(Number.isNaN(v)); console.log(Object.is(v, NaN)); // false // false 类型转换 基本转换 基本上所有类型都可以隐式的转换为Number类型，区别在于有的会转换为有效数值，有的会转换为无效数值NaN。 1）非数字串的string类型转换为number得到的结果是NaN，即无效数字： \"use strict\"; console.log( Number(\"string\") ); // NaN 2）如果是纯数字串的string类型，则可以转换为number： \"use strict\"; console.log( Number(\"1000\"), ); // 1000 3）true会转换为1，false会转换为0： \"use strict\"; console.log( Number(true), Number(false) ); // 1 0 4）空的array会转换为0，空的object会转换为NaN： \"use strict\"; console.log( Number([]), Number({}) ); // 0 NaN 5）如果array的长度为1，且数据项为number或者数字字符串类型，会直接进行提取，否则将转换为NaN： \"use strict\"; console.log( Number([100]), // 长度为1，且数据项类型为number Number([\"100\"]), // 长度为1，且数据项类型为数字串 Number([\"100\", 100]), ); // 100 100 NaN 6）JavaScript是弱类型语言，故number类型可以和str的纯数字串做四则运算，加法运算得到的结果是string，其他的运算得到的结果都是number或NaN： \"use strict\"; console.log( 100 + \"3\", 100 - \"3\", 100 * \"3\", 100 / \"3\" ); // 1003 97 300 33.333333333333336 // string number number number 强转整数 parseInt() 如果一个string类型即包含数字又包含其他字符，则可通过parseInt()方法进行强制转换。 parseInt()：提取字符串中的整数部分并将其转换为number类型 示例如下： \"use strict\"; let digitalString = \"123.4this is string\" console.log(parseInt(digitalString)); // 123 强转浮点数 parseFloat() 如果一个string类型即包含数字又包含其他字符，则可通过parseFloat()方法进行强制转换。 parseFloat()：提取字符串中的浮点数部分并将其转换为number类型 示例如下： \"use strict\"; let digitalString = \"123.4this is string\" console.log(parseFloat(digitalString)); // 123.4 类型判断 整数判定 isInteger() 使用isInteger()方法判断一个值是否是整数。 返回一个布尔值。 \"use strict\"; let v = 123.4; console.log(Number.isInteger(v)); // false NaN判定 isNaN() 使用isNaN()方法判断一个值是否有效。 返回一个布尔值。 \"use strict\"; let v = 123.4; console.log(Number.isNaN(v)); // false 浮点舍入 toFixed() 使用toFixed()方法对数值进行四舍五入的操作，可指定保留小数点后的位数： \"use strict\"; let v = 123.4344; console.log(v.toFixed()); console.log(v.toFixed(2)); // 123 // 123.43 浮点精度 基本上所有的编程语言中浮点数都有精度问题，当然JavaScript也不例外： \"use strict\"; let n1 = 0.1; let n2 = 0.2; let v = n1 + n2; console.log(v); // 0.30000000000000004 这是因为计算机以二进制处理值类型，上面的0.1和0.2转换为2进制后是无穷的： \"use strict\"; let n1 = 0.1; let n2 = 0.2; let v = n1 + n2; console.log(n1.toString(2)); console.log(n2.toString(2)); // 0.0001100110011001100110011001100110011001100110011001101 // 0.001100110011001100110011001100110011001100110011001101 我们可以使用toFixed()方法来进行小数截取： \"use strict\"; let n1 = 0.1; let n2 = 0.2; let v = (n1 + n2).toFixed(2); console.log(v); // 0.30 或者用一些第三方库进行操作，如decimal.js： // HTML部分 // Js部分 \"use strict\"; let n1 = 0.1; let n2 = 0.2; let v = Decimal.add(n1, n2).valueOf(); console.log(v); // 0.3 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:48 "},"前端专栏/JavaScript/Boolean.html":{"url":"前端专栏/JavaScript/Boolean.html","title":"Boolean","keywords":"","body":"基本声明 boolean的值被称为布尔值，常用于分支流程中，仅有2种表现形式： true：代表条件为真 false：代表条件为假 以下是使用类实例化的形式进行对象声明： \"use strict\"; let bool = new Boolean(true); console.log(`value : ${bool}\\ntype : ${typeof bool}`); // value : true // type : boolean 也可以选择使用更方便的字面量形式进行对象声明： \"use strict\"; let bool = true; console.log(`value : ${bool}\\ntype : ${typeof bool}`); // value : true // type : boolean 若new Boolean()时没有传入参数，则生成false： \"use strict\"; let bool = new Boolean(); console.log(`value : ${bool}\\ntype : ${typeof bool}`); // value : false // type : boolean 类型转换 显式转换 使用 !! 或Boolean()将任意类型对象包裹均能获得其布尔值的表现形式。 !代表取反，2个!!刚好获得布尔值对象 如下所示： \"use strict\"; console.log(!![]); console.log(!!{}); console.log(!!\"\"); console.log(!!\"0\"); console.log(!!\"1\"); console.log(!!0); console.log(!!1); // true // true // false // true // true // false // true 隐式转换 基本上所有类型都可以隐式转换为Boolean类型。 1）boolen与number比较时，true等同于1，false等同于0： \"use strict\"; console.log(3 > true); console.log(0 > false); // true // false 2）boolen与数字串比较时，两边都会转换为number后再进行比较： \"use strict\"; console.log(\"3\" > true); console.log(\"0\" > false); // true // false 3）boolen与array比较时，两边都会转换为number后再进行比较： \"use strict\"; console.log([3] > true); console.log([0] > false); // true // false 4）NaN和布尔值的比较结果都是false： \"use strict\"; console.log(NaN == true); console.log(NaN == false); // false // false 5）非空的string布尔值为true、空的string布尔值为false： \"use strict\"; console.log(!!\"str\"); console.log(!!\"\"); // true // false 6）引用类型的布尔值总为true，无论它其中是否有值，如array和object，以及map和set： \"use strict\"; console.log(!![]); console.log(!![1, 2, 3]); console.log(!!{}); console.log(!!{ x: 1, y: 2 }); console.log(!!new Map()); console.log(!!new Map([[\"x\", 1], [\"y\", 2]])); console.log(!!new Set()); console.log(!!new Set([1, 1, 2, 2, 3, 3])); // true // true // true // true // true // true // true // true 7）要判断容器类型是否为空，则需要通过length或者size以及其他方法进行判断，如下所示： \"use strict\"; console.log(!![].length); console.log(!![1, 2, 3].length); console.log(!!Object.keys({}).length); console.log(!!Object.keys({ x: 1, y: 2 }).length); console.log(!!new Map().size); console.log(!!new Map([[\"x\", 1], [\"y\", 2]]).size); console.log(!!new Set().size); console.log(!!new Set([1, 1, 2, 2, 3, 3]).size); // false // true // false // true // false // true // false // true Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:48 "},"前端专栏/JavaScript/undefined&null.html":{"url":"前端专栏/JavaScript/undefined&null.html","title":"undefined&null","keywords":"","body":"两者关系 在ECMA中认为null与undefined是相等的。 它们均代表没有、未定义、未初始的意思。 它们等同于Go语言的nil，Python的None。 但是2者之间还是有一些语义上的区别的。 undefined undefined常用于代表未定义。 1）定义好变量，未进行赋值，此时如果使用该变量得到的结果是undefined： \"use strict\"; let userName; console.log(userName); // undefined 2）函数无返回值： \"use strict\"; function demo(){} let result = demo(); console.log(result); // undefined null null代表未引用任何对象，常在初始化变量中使用。 某些情况下你可能还没想好这个变量存什么值但确定它后续能存值的时候下可用null进行变量初始化。 null本身是属于object，也就是引用类型 \"use strict\"; let userName = null; let userAge = null; // 请求后端获得数据 userName = \"Jack\"; userAge = 18; Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:48 "},"前端专栏/JavaScript/String.html":{"url":"前端专栏/JavaScript/String.html","title":"String","keywords":"","body":"基本声明 字符串是JavaScript中非常常见的一种数据类型。 以下是使用类实例化的形式进行对象声明，注意typeof会返回object： \"use strict\"; let str = new String(\"hello world\"); console.log(`value : ${str}\\ntype : ${typeof str}`); // value : hello world // type : object 也可以选择使用更方便的字面量形式进行对象声明，用英文状态下的单引号、双引号将数据项进行包裹即可： \"use strict\"; let str = \"hello world\"; console.log(`value : ${str}\\ntype : ${typeof str}`); // value : hello world // type : string 若new String()时没有传入参数，则生成空字符串： \"use strict\"; let str = new String(); console.log(`value : ${str}\\ntype : ${typeof str}`); // value : // type : object 模板字面量 ${} ` JavaScript中没有format方法进行字符串格式化，但是可以通过模板字面量来达到相同的功能。 语法如下，使用字符串2侧使用`进行包裹，并使用${变量 or 函数 or 表达式}来进行格式化。 \"use strict\"; let userName = prompt(\"please enter your name:\").trim(); console.log(`hello ${userName}, welcome home`); // 用户输入: Jack // 打印结果: hello Jack, welcome home 此外，模板字面量中可以直接使用换行操作，这里不再举例。 模板拆解 模板拆解是指定义一个函数，该函数可以提取出模板字符串中的普通字符串与格式化变量。 代码示例： \"use strict\"; let userName = \"Jack\"; let userAge = 18; function func(s, ...f) { // s:普通字符串 // f:格式化变量 console.log(s); // (3) [\"name:\", \",age:\", \"\", raw: Array(3)] console.log(f); // (2) [\"Jack\", 18] } func`name:${userName},age:${userAge}`; 特殊的\\ 在普通的声明字符串中，\\后面一般都会跟上一个特殊字符。 该字符具有特殊的意义，如\\n代表换行，\\t代表制表符等，这种具有特殊意义的\\char组合被称为转义字符。 常见的转义字符如下表所示： 转义字符 意义 ASCII码值（十进制） \\a 响铃(BEL) 007 \\b 退格(BS) ，将当前位置移到前一列 008 \\f 换页(FF)，将当前位置移到下页开头 012 \\n 换行(LF) ，将当前位置移到下一行开头 010 \\r 回车(CR) ，将当前位置移到本行开头 013 \\t 水平制表(HT) （跳到下一个TAB位置） 009 \\v 垂直制表(VT) 011 \\ 代表一个反斜线字符''' 092 \\' 代表一个单引号（撇号）字符 039 \\\" 代表一个双引号字符 034 ? 代表一个问号 063 \\0 空字符(NUL) 000 \\ddd 1到3位八进制数所代表的任意字符 三位八进制 \\xhh 十六进制所代表的任意字符 十六进制 类型转换 string支持与boolean、number进行转换，这是最常见的操作： \"use strict\"; let str = \"string\"; console.log( !!str, Number(str) ); // true NaN string也支持转换为array： \"use strict\"; let str = \"string\"; console.log( Array(str), ); // [\"string\"] 四则运算 四则运算中用的比较多的就是string与string之间的运算以及string与number之间的运算。 1）string与string的四则运算只有+得到的结果是string，其他得到的结果均为number或者NaN： \"use strict\"; console.log( \"3\" + \"3\", \"3\" - \"3\", \"3\" * \"3\", \"3\" / \"3\", ); // 33 0 9 1 // string number number number 2）string与number的四则运算只有+得到的结果是string，其他得到的结果均为number或者NaN： \"use strict\"; console.log( \"3\" + 3, \"3\" - 3, \"3\" * 3, \"3\" / 3, ); // 33 0 9 1 // string number number number 索引切片 string底层是以一种连续的顺序结构存储数据项，故可以使用索引（index）单个数据项进行获取等操作。 JavaScript中只有正向索引，没有负向索引 正向索引起始值从0开始 如下所示： ----------------------------| | A | B | C | D | E | F | G | ----------------------------| | 0 | 1 | 2 | 3 | 4 | 5 | 6 | ----------------------------| 如下所示，取出第3个元素： \"use strict\"; let v = \"ABCDEFG\"; console.log(v[3]); // D 如果想取出最后一个元素，可以搭配length属性： \"use strict\"; let v = \"ABCDEFG\"; let len = v.length; console.log(v[len - 1]); // G 长度获取 length length 获取字符串长度： \"use strict\"; let str = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"; let len = str.length; console.log(len); // 26 大小写转换 转全大写 toUpperCase() toUpperCase() 将字符串转换为全大写： \"use strict\"; let str = \"abcdefghijklmnopqrstuvwxyz\"; console.log(str.toUpperCase()); // ABCDEFGHIJKLMNOPQRSTUVWXYZ 转全小写 toLowerCase() toLowerCase() 将字符串转换为全小写： \"use strict\"; let str = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"; console.log(str.toLowerCase()); // abcdefghijklmnopqrstuvwxyz 空白移除 移除两侧空白 trim() trim() 移除字符串两侧的空白： \"use strict\"; let str = \" mid \"; console.log(str.trim()); // mid 移除左侧空白 trimLeft() trimLeft() 移除字符串左侧的空白： \"use strict\"; let str = \" mid \"; console.log(str.trimLeft()); // mid 移除右侧空白 trimRight() trimRight() 移除字符串右侧的空白: \"use strict\"; let str = \" mid \"; console.log(str.trimRight()); // mid 元素获取 单字符获取 charAt() charAt() 通过索引值获取单字符，与[idx]效果相同： \"use strict\"; let str = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"; console.log( // 取出A str.charAt(0), str[0], // 取出Z str.charAt(str.length - 1), str[str.length - 1], // 取出X str.charAt(str.length - 3), str[str.length - 3], ); // A A Z Z X X 字符转Unicode charCodeAt() charCodeAt() 通过索引值获取单字符的Unicode编码，如果str本身就是单字符，则不用填入索引值： \"use strict\"; let str = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"; console.log( // 取出A的字符编码 65 str.charCodeAt(0), // 取出Z的字符编码 90 str.charCodeAt(str.length - 1), // 取出X的字符编码 88 str.charCodeAt(str.length - 3), ); // 单字符不用填索引值 console.log(\"Z\".charCodeAt()); // 65 90 88 // 90 Unicode转字符 fromCharCode() fromCharCode() 可将Unicode编码转换为字符，通常对应charCodeAt()使用。 可理解为根据ASCII码值将Number转换为String： \"use strict\"; console.log(String.fromCharCode(65)); // A 切片操作 截取子串 slice() slice() 字符串按照索引切片，顾头不顾尾。 start：索引开始的位置 end：索引结束的位置，若不指定该值，则全切 \"use strict\"; let str = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"; console.log( // 拿出全部 str.slice(0), // 拿出A-W str.slice(0, str.length - 3) ); // ABCDEFGHIJKLMNOPQRSTUVWXYZ // ABCDEFGHIJKLMNOPQRSTUVW 截取子串 substr() 获取从指定位置开始并具有指定长度的子字符串。 form：从哪个位置开始切 length：切几个，若不指定该值，则全切 \"use strict\"; let str = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"; console.log( // 拿出全部 str.substr(0), // 从B开始切，向后数5-1个 str.substr(1, 5) ); // ABCDEFGHIJKLMNOPQRSTUVWXYZ // BCDEF 截取子串 substring() substring() 字符串按照索引切片，顾头不顾尾。 start：索引开始的位置 end：索引结束的位置，若不指定该值，则全切 \"use strict\"; let str = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"; console.log( // 拿出全部 str.substring(0), // 拿出A-W，与slice()相同 str.substring(0, str.length - 3) ); // ABCDEFGHIJKLMNOPQRSTUVWXYZ // ABCDEFGHIJKLMNOPQRSTUVW 查找相关 左侧搜索子串 indexOf() indexOf() 从左侧开始向右查找子串，若子串存在则返回子串开始的索引位置，若子串不存在则返回-1，第2参数为从哪个位置开始找。 searchString：要被搜索的子串 position：从哪里开始搜索 \"use strict\"; let str = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"; console.log( // 能找到，返回子串开始的索引位置 str.indexOf(\"FGH\"), // 找不到，返回-1 str.indexOf(\"abc\") ); // 5 // -1 右侧搜索子串 lastIndexOf() lastIndexOf() 从右侧开始向右查找子串，若子串存在则返回子串开始的索引位置，若子串不存在则返回-1，第2参数为从哪个位置开始找。 searchString：要被搜索的子串 position：从哪里开始搜索 \"use strict\"; let str = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"; console.log( // 能找到，返回子串开始的索引位置 str.lastIndexOf(\"FGH\"), // 找不到，返回-1 str.lastIndexOf(\"abc\") ); // 5 // -1 是否包含子串 search() search() 通过正则表达式搜索子串，若子串存在则返回子串开始的索引位置，若子串不存在则返回-1。 \"use strict\"; let str = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"; console.log( // 能找到，返回子串开始的索引位置 str.search(\"Z$\"), // 找不到，返回-1 str.search(\"^B\") ); // 25 // -1 是否包含子串 includes() includes() 查看字符串中是否包含子串，若子串存在则返回true，若子串不存在则返回false，可指定查找位置。 searchString：要被搜索的子串 position：从哪里开始搜索 \"use strict\"; let str = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"; console.log( // 能找到，返回true str.includes(\"ABC\"), // 找不到，返回false str.includes(\"abc\") ); // true // false 特定子串开头 startsWith() startsWith() 查看字符串是否以特定子串开头，返回true或者false，可指定开头索引的查找位置。 \"use strict\"; let str = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"; console.log( // 是否已ABC开头 str.startsWith(\"ABC\"), // 索引5处是否已FGH开头 str.includes(\"FGH\", 5) ); // true // true 特定子串结尾 endsWith() endsWith() 查看字符串是否以特定子串结尾，返回true或者false，可指定结尾索引的查找位置。 \"use strict\"; let str = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"; console.log( // 是否已XYZ结尾 str.endsWith(\"XYZ\"), // 索引5处是否已FGH结尾 str.includes(\"FGH\", 5) ); // true // true 替换与重复生成 替换子串 replace() replace() 替换字符串中的子串为新串，默认只替换一次，返回新的字符串。 searchValue：被替换的子串 replaceValue：替换的子串 \"use strict\"; let str = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"; console.log( // 将XYZ替换为xyz str.replace(\"XYZ\", \"xyz\"), ); // ABCDEFGHIJKLMNOPQRSTUVWxyz 重复生成 repeat() repeat() 重复生成字符串： \"use strict\"; let str = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"; console.log( // 将str重复生成3次 str.repeat(3), ); // ABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZ 将电话号码中间4位隐藏： \"use strict\"; let str = \"13899320641\"; console.log( str.replace(str.slice(3, 7), \"*\".repeat(4)) ); // 138****0641 拆分与拼接 拆分字符串 split() split() 拆分字符串为数组。 separator：根据那个子串进行拆分 limit：指定数组中存入的拆分结果数量 默认数组会将所有拆分结果都进行存入： \"use strict\"; let str = \"hello, world, hello, JavaScript\"; console.log( // 以,进行拆分 str.split(\",\") ); // [\"hello\", \" world\", \" hello\", \" JavaScript\"] 指定数组仅存入拆分结果的前2个： \"use strict\"; let str = \"hello, world, hello, JavaScript\"; console.log( str.split(\",\", 2) ); // [\"hello\", \" world\"] 字符串拼接 concat() concat() 拼接字符串，类似于 string + string 的操作： \"use strict\"; let str = \"hello\"; console.log( // 相当于 str + , + world str.concat(\",\", \"world\"), ); // hello,world Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:48 "},"前端专栏/JavaScript/Array.html":{"url":"前端专栏/JavaScript/Array.html","title":"Array","keywords":"","body":"基本声明 数组创建 以下是使用类实例化的形式进行对象声明： \"use strict\"; let ary = new Array(1, 2, 3); console.log(ary); // [ 1, 2, 3 ] 也可以选择使用更方便的字面量形式进行对象声明，利用[]对数据项进行包裹，并且使用逗号将数据项之间进行分割： \"use strict\"; let ary = [1, 2, 3]; console.log(ary); // [ 1, 2, 3 ] 若new Array()时没有传入参数，则生成空数组： \"use strict\"; let ary = new Array(); console.log(ary); // [] Array.of() 在使用类实例化的形式进行对象声明时，若数组只想有1个数据项元素，则可通过Array.of()进行创建。 否则创建的是一个长度为填入值的空数组： \"use strict\"; let ary1 = Array.of(3); // 创建出只有一个数据项元素3的数组 console.log(ary1); let ary2 = new Array(3); // 创建出长度为3的空数组 console.log(ary2); // [ 3 ] // [ ] Array.fill() 若想创建一个数组中具有相同数据项元素的数组，则可通过Array.fill()进行创建。 如下示例，该数组中的数据项元素全部为A： \"use strict\"; let ary = new Array(5).fill(\"A\"); console.log(ary); // [ 'A', 'A', 'A', 'A', 'A' ] 多维数组 当一个数组中嵌套另一个数组时，该数组即为多维数组： \"use strict\"; let ary = [1, 2, 3, [\"A\", \"B\", \"C\"]]; console.log(ary); // [ 1, 2, 3, [ 'A', 'B', 'C' ] ] 不可变数组 数组是引用类型，使用const声明后依旧能改变数组中元素的值： \"use strict\"; const ary = [1, 2, 3]; ary[0] = \"A\"; console.log(ary); // [ 'A', 2, 3 ] 你可以使用Object.freeze()方法将数组包裹起来，让该数组变为不可变数组： \"use strict\"; const ary = [1, 2, 3]; Object.freeze(ary); ary[0] = \"A\"; console.log(ary); // TypeError: Cannot assign to read only property '0' of object '[object Array]' 类型转换 数组转字符串 1）大部分数据类型都可以使用toString()方法将自身转换为字符串： \"use strict\"; let ary = [\"A\", \"B\", \"C\"]; let strArray = ary.toString(); console.log(strArray); console.log(typeof strArray); // A,B,C // string 2）也可以通过String()将数组包裹起来，这样做会将数组转换为字符串： \"use strict\"; let ary = [\"A\", \"B\", \"C\"]; let strArray = String(ary); console.log(strArray); console.log(typeof strArray); // A,B,C // string 3）join()方法也可以将数组转换为字符串，你需要指定元素之间的链接字符： \"use strict\"; let ary = [\"A\", \"B\", \"C\"]; let strArray = ary.join(\"-\"); console.log(strArray); console.log(typeof strArray); // A-B-C // string 类数组转数组 通过Array.form()方法可以将类数组转换为数组。 类数组是指具有length属性或者是可迭代的对象 Array.form()具有2个参数： arrayLike：待转换为数组的类数组 callbackfn：回调函数，它会对类数组中的元素挨个挨个的做操作，最终会将return的值加入到新数组中 如下示例，将DOM对象集合的NodeList转换为数组： // HTML代码里6个P标签，内容是 1 2 3 4 5 6 \"use strict\"; let nodeList = document.querySelectorAll(\"p\"); let nodeInnerTextArray = Array.from(nodeList, (element, index) => { return \"p -> \" + element.innerText }) console.log(nodeInnerTextArray); // [\"p -> 1\", \"p -> 2\", \"p -> 3\", \"p -> 4 \", \"p -> 5 \", \"p -> 6\"] 索引使用 单元素操作 在String一章节中我们介绍过索引的基本使用。由于String类型是不可变的，所以你只能通过索引进行数据项获取。 而Array是可变类型，所以你可以利用索引对元素进行增删改查。 JavaScript中的[]索引语法仅支持单元素操作，不能进行切片 1）获取单元素，直接使用ary[idx]即可： \"use strict\"; let ary = [\"A\", \"B\", \"C\", \"D\", \"E\"]; // 获取第一个 console.log(ary[0]); // 获取最后一个 console.log(ary[ary.length - 1]); // A // E 2）增加单元素，如果增加单元素的索引位置大于数组已有的最大索引位置，则之前的位置都会用empty进行占位。其实empty就是undefined： \"use strict\"; let ary = [\"A\", \"B\", \"C\", \"D\", \"E\"]; // ary -> current max index = 4 ary[8] = \"I\"; console.log(ary); // empty = undefined console.log(ary[6]); // [ 'A', 'B', 'C', 'D', 'E', , 'I' ] // undefined 3）修改单元素，如果要修改的索引位置大于数组已有的最大索引位置，则相当于增加单元素。 \"use strict\"; let ary = [\"A\", \"B\", \"C\", \"D\", \"E\"]; ary[0] = \"a\"; console.log(ary); // [ 'a', 'B', 'C', 'D', 'E' ] 4）删除单元素，使用delete配合[idx]来删除单个元素，被删除的元素位置会用undefined进行占位，即整个数组不会缩容。若要删除的索引位置大于数组已有的最大索引位置，则无效： \"use strict\"; let ary = [\"A\", \"B\", \"C\", \"D\", \"E\"]; // 索引1处变为undefined delete ary[1]; // 并不会抛出异常 delete ary[8]; console.log(ary); // [ 'A', , 'C', 'D', 'E' ] 实现元素位置调整 通过索引的操作，实现一个元素位置调整函数： \"use strict\"; function move(array, beforePosition, toPosition) { if (beforePosition = array.length) { throw new Error(\"move position error\"); } let beforeValue = array[beforePosition]; let toValue = array[toPosition]; array[beforePosition] = toValue; array[toPosition] = beforeValue; } let ary = [\"C\", \"B\", \"A\", \"D\"]; move(ary, 0, 2); console.log(ary); // [ 'A', 'B', 'C', 'D' ] ...语法 数组合并 …语法可用于拆解一个数组。 如下所示，新数组由2个旧的数组合并而成： \"use strict\"; let ary1 = [\"A\", \"B\", \"C\"], ary2 = [\"D\", \"E\", \"F\"]; let newArray = [...ary1, ...ary2]; console.log(newArray); // [ 'A', 'B', 'C', 'D', 'E', 'F' ] 解构赋值 对一个数组进行解构赋值时，变量名外部必须由[]进行包裹，且变量名与元素一一对应： \"use strict\"; let ary = [\"Jack\", \"18\", \"male\"]; let [userName, age, gender] = ary; console.log(userName); console.log(age); console.log(gender); // Jack // 18 // male 若你想一个变量接收多个被解构的元素，可使用...语法接收它们： \"use strict\"; let ary = [\"Jack\", \"18\", \"male\", \"basketball\", \"football\", \"volleyball\"]; let [userName, age, gender, ...hobby] = ary; console.log(userName); console.log(age); console.log(gender); console.log(hobby); // Jack // 18 // male // [ 'basketball', 'football', 'volleyball' ] 某些变量对你来说没用，可使用_作为匿名变量进行占位，或者直接使用,放弃接收它： \"use strict\"; let ary = [\"Jack\", \"18\", \"male\", \"basketball\", \"football\", \"volleyball\", \"1.92m\", \"80kg\"]; // basketball使用匿名变量接收， football和volleyball直接舍弃 let [userName, age, gender, _, , , height, weight] = ary; console.log(userName); console.log(age); console.log(gender); console.log(height); console.log(weight); // Jack // 18 // male // 1.92m // 80kg 类数组转数组 使用…语法也可以实现类数组转数组，如下所示： \"use strict\"; let nodeList = document.querySelectorAll(\"p\"); let nodeInnerTextArray = new Array(...nodeList).map((element, index) => { return \"p -> \" + element.innerText }) console.log(nodeInnerTextArray); // [\"p -> 1\", \"p -> 2\", \"p -> 3\", \"p -> 4 \", \"p -> 5 \", \"p -> 6\"] 迭代器方法 keys() 返回所有元素的索引值： \"use strict\"; let ary = [ 'A', 'B', 'C', 'D', 'E', 'F' ]; let aryIdx = ary.keys(); while (1){ let iterItem = aryIdx.next(); if(iterItem.done === false){ console.log(iterItem.value); continue } break } // 0 // 1 // 2 // 3 // 4 // 5 values() 返回所有元素的值本身： \"use strict\"; let ary = [ 'A', 'B', 'C', 'D', 'E', 'F' ]; let aryEle = ary.values(); while (1){ let iterItem = aryEle.next(); if(iterItem.done === false){ console.log(iterItem.value); continue } break } // A // B // C // D // E // F entries() 以数组形式返回所有元素的索引值与值本身： \"use strict\"; let ary = ['A', 'B', 'C', 'D', 'E', 'F']; let aryIE = ary.entries(); while (1) { let iterItem = aryIE.next(); if (iterItem.done === false) { console.log(iterItem.value); continue } break } // [ 0, 'A' ] // [ 1, 'B' ] // [ 2, 'C' ] // [ 3, 'D' ] // [ 4, 'E' ] // [ 5, 'F' ] 长度获取 length length 获取数组长度： \"use strict\"; let ary = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L']; let len = ary.length; console.log(len); // 12 循环遍历 for 根据数组长度结合for循环来遍历整个数组： \"use strict\"; let ary = ['A', 'B', 'C', 'D', 'E', 'F']; for (let i = 0; i for/in for/in迭代时的迭代变量是数组的索引值： \"use strict\"; let ary = ['A', 'B', 'C', 'D', 'E', 'F']; for (let idx in ary) { console.log(ary[idx]); } // A // B // C // D // E // F for/of for/of迭代时的迭代变量是数组的值本身： \"use strict\"; let ary = ['A', 'B', 'C', 'D', 'E', 'F']; for (let item of ary) { console.log(item); } // A // B // C // D // E // F 配合迭代器方法entries()和解构赋值，可同时拿到索引和值： \"use strict\"; let ary = ['A', 'B', 'C', 'D', 'E', 'F']; for (let [idx, item] of ary.entries()) { console.log(idx, item); } // 0 'A' // 1 'B' // 2 'C' // 3 'D' // 4 'E' // 5 'F' forEach() forEach()用于递归的操作元素，并根据操作修改原数组中的元素。 使用该方法时需要绑定一个回调函数，该回调函数没有返回结果。 注意与map()方法的区别，该方法是对数组进行原地操作，不会生成新的数组。 回调函数共有3个参数： value：被遍历的元素值本身 index：被遍历的元素索引值 array：被遍历的数组本身 如下示例，对原数组每个数据项+100： \"use strict\"; let ary = [1, 2, 3, 4, 5]; ary.forEach((element, idx, ary)=>{ ary[idx] += 100; }) console.log(ary); // [ 101, 102, 103, 104, 105 ] 反向遍历 for循环也可用于反向遍历，如下所示： \"use strict\"; let ary = ['A', 'B', 'C', 'D', 'E', 'F']; for(let i=ary.length; i>=0; i--){ console.log(ary[i]); } // F // E // D // C // B // A 元素管理 压入尾部 push() 将元素追加至数组尾部： \"use strict\"; let ary = ['A', 'B', 'C', 'D', 'E', 'F']; ary.push(\"G\", \"H\", \"I\", \"J\", \"K\") console.log(ary); // [ 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K' ] 弹出尾部 pop() 将数组尾部最后一个元素弹出并返回，它将引起数组的缩容，并不会使用undefined进行占位： \"use strict\"; let ary = ['A', 'B', 'C', 'D', 'E', 'F']; let lastElement = ary.pop(); console.log(lastElement); console.log(ary); // F // [ 'A', 'B', 'C', 'D', 'E' ] 压入头部 unshift() 将元素插入至数组头部： \"use strict\"; let ary = ['A', 'B', 'C', 'D', 'E', 'F']; ary.unshift(\"1\", \"2\", \"3\", \"4\", \"5\") console.log(ary); // [ '1', '2', '3', '4', '5', 'A', 'B', 'C', 'D', 'E', 'F' ] 弹出头部 shift() 将数组头部第一个元素弹出并返回，它将引起数组的缩容，并不会使用undefined进行占位： \"use strict\"; let ary = ['A', 'B', 'C', 'D', 'E', 'F']; let firstElement = ary.shift(); console.log(firstElement); console.log(ary); // A // [ 'B', 'C', 'D', 'E', 'F' ] 切片方法 slice() 使用slice()方法对数组进行切片，顾头不顾尾。 start：索引开始的位置 end：索引结束的位置，若不指定该值，则全切 \"use strict\"; let ary = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z']; console.log( // 拿出全部 ary.slice(0), // 拿出A-W ary.slice(0, ary.length - 3) ); 万能方法 splice() 使用splice()方法对原数组中的元素进行添加、删除、替换操作。 1）删除元素，返回值为被删除的元素数组： 第一个参数：从哪里开始删除 第二个参数：删除几个元素 \"use strict\"; let ary = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L']; let delElementArray = ary.splice(0, 3); // 从第0个元素开始删，删3个 console.log(delElementArray); console.log(ary); // [ 'A', 'B', 'C' ] // [ 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L' ] 2）向末尾添加元素，配合length属性进行操作： \"use strict\"; let ary = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L']; // 从最后一个位置删，删除0个，并新增M、N、O元素至数组尾部 ary.splice(ary.length, 0, \"M\", \"N\", \"O\") console.log(ary); // [ 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O' ] 3）向头部插入元素： \"use strict\"; let ary = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L']; // 从第一个位置删，删除0个，并插入1, 2, 3, 4, 5元素至数组尾部 ary.splice(0, 0, \"1\", \"2\", \"3\", \"4\", \"5\"); console.log(ary); // [ '1', '2', '3', '4', '5', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L' ] 4）先删除元素，再添加元素到头部： \"use strict\"; let ary = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L']; // 从第一个位置删，删3个，并且新增元素到头部 let delElementArray = ary.splice(0, 3, \"1\", \"2\", \"3\", \"4\", \"5\"); console.log(delElementArray); console.log(ary); // [ 'A', 'B', 'C' ] // [ '1', '2', '3', '4', '5', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L' ] 数组清空 数组清空的方法有很多。 1）将数组的length属性改为0即可： \"use strict\"; let ary = [\"A\", \"B\", \"C\"]; ary.length = 0; console.log(ary); // [] 2）改变变量的标识符指向，旧的数组会自动被GC机制清理掉： \"use strict\"; let ary = [\"A\", \"B\", \"C\"]; ary = [] console.log(ary); // [] 3）使用pop()或者shift()方法来清空数组： \"use strict\"; let ary = [\"A\", \"B\", \"C\"]; while(ary.pop()){}; console.log(ary); // [] 4）使用splice()方法来清空数组： \"use strict\"; let ary = [\"A\", \"B\", \"C\"]; ary.splice(0, ary.length); console.log(ary); // [] 查找元素 左侧搜索元素 indexOf() 从左侧开始向右查找元素，若元素存在则返回该元素首次出现的索引位置，若元素不存在则返回-1，第2参数为从哪个位置开始找。 searchElement：要被搜索的元素 fromIndex：从哪里开始搜索 \"use strict\"; let ary = [\"A\", \"B\", \"C\"]; console.log( // 能找到，返回元素的索引位置 ary.indexOf(\"B\"), // 找不到，返回-1 ary.indexOf(\"Z\") ); // 1 // -1 右侧搜索元素 lastIndexOf() 从右侧开始向右查找元素，若元素存在则返回该元素首次出现的索引位置，若元素不存在则返回-1，第2参数为从哪个位置开始找。 searchElement：要被搜索的元素 fromIndex：从哪里开始搜索 \"use strict\"; let ary = [\"A\", \"B\", \"C\"]; console.log( // 能找到，返回元素的索引位置 ary.lastIndexOf(\"B\"), // 找不到，返回-1 ary.lastIndexOf(\"Z\") ); // 1 // -1 是否包含元素 includes() 查看数组中是否包含某个元素，若该元素存在则返回true，若该元素不存在则返回false，可指定查找位置。 searchElement：要被搜索的元素 fromIndex：从哪里开始搜索 \"use strict\"; let ary = [\"A\", \"B\", \"C\"]; console.log( // 能找到，返回true ary.includes(\"B\"), // 找不到，返回false ary.includes(\"Z\") ); // true // false 元素查找 find() 查看数组中是否包含某个元素，若该元素存在则返回该元素，若该元素不存在则返回undefined。 predicate：回调函数，当该函数的return结果为true时，将返回被遍历的元素值本身 thisArg：如果提供，它将用作每次调用predicate的this值，如果未提供，则使用undefined find()常用于查找引用类型的数据，比如我们要查找多维数组时，includes()是查找不到的，此时就可以使用find()进行查找： \"use strict\"; let ary = [1, 2, 3, [\"A\", \"B\", \"C\"]]; let result = ary.find((element, index, array) => { return [\"A\", \"B\", \"C\"].toString() == element }) console.log(result); // [ 'A', 'B', 'C' ] 索引查找 findIndex() 查看数组中是否包含某个元素，若该元素存在则返回该元素在数组中的索引，若该元素不存在则返回undefined。 predicate：回调函数，当该函数的return结果为true时，将返回被遍历的元素在数组中的索引 thisArg：如果提供，它将用作每次调用predicate的this值，如果未提供，则使用undefined findIndex()常用于查找引用类型的数据，比如我们要查找多维数组时，includes()是查找不到的，此时就可以使用find()进行查找： \"use strict\"; let ary = [1, 2, 3, [\"A\", \"B\", \"C\"]]; let result = ary.findIndex((element, index, array) => { return [\"A\", \"B\", \"C\"].toString() == element }) console.log(result); // 3 find原理 以下是find()和findIndex()的原理： \"use strict\"; function find(array, callbackfn) { for (let item of array) { // 如果被可迭代对象返回true，则返回被遍历的值 if (callbackfn(item) === true) { return item } } return undefined } let ary = [1, 2, 3, [\"A\", \"B\", \"C\"]]; let result = find(ary, element => { return [\"A\", \"B\", \"C\"].toString() == element }) console.log(result); // [ 'A', 'B', 'C' ] 我们可以将该函数稍作修改后添加进Array的原型中，这样所有的Array实例都能调用该方法了： \"use strict\"; Array.prototype.findItem = function (callbackfn) { // this = 调用该方法的数组 for (let item of this) { if (callbackfn(item) === true) { return item } } return undefined } let ary = [1, 2, 3, [\"A\", \"B\", \"C\"]]; let result = ary.findItem(element => { return [\"A\", \"B\", \"C\"].toString() == element }) console.log(result); // [ 'A', 'B', 'C' ] 反转排序 数组翻转 reverse() reverse()方法用于将数组进行翻转，它并不会生成新的数组，而是在原数组基础上做操作： \"use strict\"; let ary = [\"A\", \"B\", \"C\", \"D\", \"E\", \"F\"]; ary.reverse(); console.log(ary); // [ 'F', 'E', 'D', 'C', 'B', 'A' ] 元素排序 sort() sort()方法可对数组中的元素项进行排序，默认按照从小到大的升序排列进行排序，它并不会生成新的数组，而是在原数组基础上做操作： \"use strict\"; let ary = [3, 2, 5, 1, 4]; ary.sort(); console.log(ary); // [ 1, 2, 3, 4, 5 ] 配合reverse()方法，实现倒序排列： \"use strict\"; let ary = [3, 2, 5, 1, 4]; ary.sort().reverse(); console.log(ary); // [ 5, 4, 3, 2, 1 ] 为sort()方法指定回调函数，实现自定义规则排序。 回调函数接收2个参数，a和b 若回调函数返回的是负数，则a排在b之前 若回调函数返回的是正数，则a排在b之后 若回调函数返回的是0，则代表a和b相等，不进行位置调整 如下所示： \"use strict\"; let ary = [3, 2, 5, 1, 4]; ary.sort((a, b)=>{ // a - b 升序排列 // b - a 降序排列 return b - a; }); console.log(ary); // [ 5, 4, 3, 2, 1 ] 实例演示 按照薪资待遇从大到小进行排序： \"use strict\"; let ary = [ { name: \"Jack\", salary: 2000 }, { name: \"Tom\", salary: 5000 }, { name: \"Mary\", salary: 3000 }, { name: \"Ken\", salary: 8000 }, ]; ary.sort((a, b) => { // a - b 升序排列 // b - a 降序排列 return b.salary - a.salary; }); console.log(ary); // [ // { name: 'Ken', salary: 8000 }, // { name: 'Tom', salary: 5000 }, // { name: 'Mary', salary: 3000 }, // { name: 'Jack', salary: 2000 } // ] 排序原理 以下是排序原理实现： \"use strict\"; Array.prototype.sortItem = function (callback) { // this = 调用该方法的数组 for (let a in this) { for (let b in this) { // 如果调用结果小于0，则意味着a小于b，需要调整位置 if (callback(this[a], this[b]) { return a - b }) console.log(ary); // [ 5, 4, 3, 2, 1 ] 合并拆分 数组合并为字符串 join() 使用join()方法，将数组合并为字符串，它会产生一个新的字符串并返回： 你需要指定元素之间的链接字符： \"use strict\"; let ary = [\"www\", \"google\", \"com\"]; let str = ary.join(\".\"); console.log(str); // www.google.com 字符串拆分为数组 split() 使用split()方法，将字符串合并为数组，它会产生一个新的数组并返回。 你需要指定依据那个字符进行拆分，并且指定拆分次数。 具体示例参见String一章： \"use strict\"; let str = \"www.google.com\"; let ary = str.split(\".\"); console.log(ary); // [ 'www', 'google', 'com' ] 链接多个数组 concat() 使用concat()方法，将多个数组进行链接合并，它会产生一个新的数组并返回。 \"use strict\"; let ary = [1, 2, 3]; let newAry = ary.concat([4, 5, 6], [7, 8, 9]); console.log(newAry); // [ 1, 2, 3, 4, 5, 6, 7, 8, 9 ] 扩展方法 全部为真 every() every()用于递归的检测元素，所有检测为true结果才为true，若有一个检测结果为false则直接返回false。 使用该方法时需要要绑定一个回调函数，该回调函数必须返回true或者false。 回调函数共有3个参数： value：被遍历的元素值本身 index：被遍历的元素索引值 array：被遍历的数组本身 如下示例，检测班级中所有JavaScript成绩都及格的同学： \"use strict\"; let ary = [ {name : \"Tom\", js : 98}, {name : \"Jack\", js : 67}, {name : \"Tom\", js : 58}, ]; let result = ary.every((item, idx, array)=>{ return item.js >= 60 }) console.log(result); // false 内部实现原理： \"use strict\"; Array.prototype.everyItem = function (callbackfn) { // this = 调用该方法的数组 for (let [index, item] of this.entries()) { if (!callbackfn(item, index, this)) { return false } } return true } let ary = [ { name: \"Tom\", js: 98 }, { name: \"Jack\", js: 67 }, { name: \"Tom\", js: 59 }, ]; let result = ary.everyItem((item, idx, array) => { return item.js >= 60 }) console.log(result); // false 一个为真 some() some()用于递归的检测元素，所有检测为false结果才为false，若有一个检测结果为true则直接返回true。 使用该方法时需要绑定一个回调函数，该回调函数必须返回true或者false。 回调函数共有3个参数： value：被遍历的元素值本身 index：被遍历的元素索引值 array：被遍历的数组本身 如下示例，检测用户输入的内容是否包含敏感词汇： Document \"use strict\"; const detect = [\"蛤蟆\", \"维尼熊\", \"跳跳虎\"]; let inputElement = document.querySelector(\"input[name=username]\"); inputElement.addEventListener(\"keyup\", function (event) { let content = event.target.value; let result = detect.some((item, index, array) => { return detect.indexOf(content) >= 0; }) if (result) { inputElement.value = \"\"; inputElement.placeholder = \"请不要输入敏感词汇\"; } }) 内部实现原理： \"use strict\"; Array.prototype.someItem = function (callbackfn) { // this = 调用该方法的数组 for (let [index, item] of this.entries()) { if (callbackfn(item, index, this)) { return true } } return false } let ary = [ { name: \"Tom\", js: 98 }, { name: \"Jack\", js: 67 }, { name: \"Tom\", js: 59 }, ]; let result = ary.someItem((item, idx, array) => { return item.js 元素过滤 filter() filter()用于递归的检测元素，所有检测结果为true的元素添加至新的数组中，检测结果为false的元素丢弃。 当检测完毕后会返回新的数组。 使用该方法时需要绑定一个回调函数，该回调函数必须返回true或者false。 回调函数共有3个参数： value：被遍历的元素值本身 index：被遍历的元素索引值 array：被遍历的数组本身 如下示例，筛选出班级中所有JavaScript成绩都及格的同学： \"use strict\"; let ary = [ { name: \"Tom\", js: 98 }, { name: \"Jack\", js: 67 }, { name: \"Tom\", js: 59 }, ]; let result = ary.filter((item, idx, array) => { return item.js >= 60 }) console.log(result); // [ { name: 'Tom', js: 98 }, { name: 'Jack', js: 67 } ] 内部实现原理： \"use strict\"; Array.prototype.filterItem = function (callbackfn) { // this = 调用该方法的数组 let newArray = [] for (let [index, item] of this.entries()) { if (callbackfn(item, index, this)) { newArray.push(item); } } return newArray } let ary = [ { name: \"Tom\", js: 98 }, { name: \"Jack\", js: 67 }, { name: \"Tom\", js: 59 }, ]; let result = ary.filterItem((item, idx, array) => { return item.js >= 60 }) console.log(result); // [ { name: 'Tom', js: 98 }, { name: 'Jack', js: 67 } ] 遍历操作 map() map()用于递归的操作元素，并将操作完成后的元素添加进新数组中，当操作完毕后会返回新的数组。 使用该方法时需要绑定一个回调函数，该回调函数可有返回结果，也可以没有返回结果，若没返回结果新数组则为空。 注意与forEach()方法的区别，该方法不会对原数组造成任何改变，只会生成新的数组。 回调函数共有3个参数： value：被遍历的元素值本身 index：被遍历的元素索引值 array：被遍历的数组本身 如下示例，对原数组每个数据项+100，生成新的数组并返回，原数组并不受影响： \"use strict\"; let ary = [1, 2, 3, 4, 5]; let result = ary.map((element, idx, ary) => { return element += 100; }) console.log(result); console.log(ary); // [ 101, 102, 103, 104, 105 ] // [ 1, 2, 3, 4, 5 ] 内部实现原理： \"use strict\"; Array.prototype.mapItem = function (callbackfn) { // this = 调用该方法的数组 let newArray = [] for (let [index, item] of this.entries()) { newArray.push(callbackfn(item, index, this)); } return newArray } let ary = [1, 2, 3, 4, 5]; let result = ary.mapItem((element, idx, ary) => { return element += 100; }) console.log(result); console.log(ary); // [ 101, 102, 103, 104, 105 ] // [ 1, 2, 3, 4, 5 ] 多元素操作 reduce() reduce()方法有1个初始值，你可以指定该初始值或者不指定。 每次对数组进行遍历后，都会使用回调函数处理该遍历项，并且将该遍历项与初始值进行操作。 常用于累积运算，如累加，累乘等。 除此之外，还有个reduceRight()方法，它是从右向左的遍历，而reduce()方法是从左向右的遍历。 回调函数的参数： prev：上次调用回调函数返回的结果 cur：被遍历的元素值本身 index：被遍历的元素索引值 array：被遍历的数组本身 下面代码示例。 1）统计元素在数组中出现的次数： \"use strict\"; function getCount(ary, item) { return ary.reduce((prev, cur, index, array) => { return prev += (cur === item ? 1 : 0) }, 0) } let ary = [1, 2, 3, 4, 4, 5, 6]; console.log(getCount(ary, 4)); // 2 2）返回数组中最大元素： \"use strict\"; function getMax(ary) { return ary.reduce((prev, cur, index, array) => { return prev > cur ? prev : cur }) } let ary = [1, 2, 3, 4, 4, 5, 6]; console.log(getMax(ary)); // 6 3）进行累加操作： \"use strict\"; function getMax(ary) { return ary.reduce((prev, cur, index, array) => { return prev > cur ? prev : cur }) } // 创建一个数组，长度是100全是空的，然后获取其下索引值 // 再通过 ...语法展开到新的数组中，这个新数组的元素就 // 变为了0-99 let ary = [...Array(100).keys()]; let result = ary.reduce((prev, cur, index, array) => { return prev + cur }) console.log(result); // 4950 4）在100的基础上进行累加操作： \"use strict\"; function getMax(ary) { return ary.reduce((prev, cur, index, array) => { return prev > cur ? prev : cur }) } let ary = [...Array(11).keys()]; let result = ary.reduce((prev, cur, index, array) => { return prev + cur }, 100) console.log(result); // 155 内部实现原理： \"use strict\"; Array.prototype.reduceMethod = function (callbackfn, initialValue = undefined) { // this = 调用该方法的数组 for (let [index, item] of this.entries()) { initialValue = callbackfn(initialValue, item, index, this); } return initialValue } let ary = [...Array(11).keys()]; let result = ary.reduceMethod((prev, cur, index, array) => { return prev + cur }, 100) console.log(result) // 155 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:48 "},"前端专栏/JavaScript/Map&WeakMap.html":{"url":"前端专栏/JavaScript/Map&WeakMap.html","title":"Map&WeakMap","keywords":"","body":"Map 基本介绍 Map是一组键值对的结构，用于解决以往不能用对象做键的问题，它在ES6中被引入。 Map拥有极快的查找速度 对比Object，它的键可以是任意类型 其实Map和Object非常相似，但是Object的键只能是String或者Symbol类型，Map在这方面就显得没有这么严苛。 以下是Map和Object的区别对比： 对比项 Map Object 意外的键 Map默认情况下不包含任何键，只包含显式插入的键 Object有一个prototype对象，原型链上的键名可能和你已有对象中的键名发生冲突，虽然ES5开始可以用object.create(null)来创建一个没有原型的对象，但是这种用法不太常见 键的类型 Map的键可以是任意类型，包含函数、对象或任意基本类型 Object中键的类型必须是String或者Symbol 键的顺序 Map中的键是有序的，先插入的k-v排列在前，后插入的k-v排列在后 Object中的键是无序的。注意：自ECMAScript 2015规范以来，对象确实保留了字符串和Symbol键的创建顺序； 因此，在只有字符串键的对象上进行迭代将按插入顺序产生键 Size Map的键值对个数可以通过size属性轻松的进行获取 Object的键值对个数只能手动进行计算 迭代 Map遵循了 可迭代协议，所以可以直接被迭代 Object需要手动的创建出迭代器后才能够对其进行迭代 性能 在频繁增删键值对的场景下表现更好 在频繁添加和删除键值对的场景下未作出优化 声明定义 使用Map()加上嵌套的二维数组即可声明出一个Map容器： \"use strict\"; let map = new Map([ [\"k1\", \"v1\"], [\"k2\", \"v2\"], [\"k3\", \"v3\"], ]); console.log(map instanceof Map); console.log(map); console.log(map.get(\"k1\")); // true // Map { 'k1' => 'v1', 'k2' => 'v2', 'k3' => 'v3' } // v1 Map的键必须是不同的对象，若相同内存地址的对象作为Map中的多个键，将会引发键冲突。 换而言之，Map中的键必须是唯一的。 1）ary1和ary2的内存地址不同，故不会发生键冲突： \"use strict\"; let ary1 = [1, 2, 3]; let ary2 = [1, 2, 3]; let map = new Map([ [ary1, \"v1\"], [\"k2\", \"v2\"], [ary2, \"v3\"], ]); console.log(map instanceof Map); console.log(map); // true // Map { [ 1, 2, 3 ] => 'v1', 'k2' => 'v2', [ 1, 2, 3 ] => 'v3' } 2）ary1和ary2的内存地址相同，将会引发键冲突： \"use strict\"; let ary1 = [1, 2, 3]; let ary2 = ary1; let map = new Map([ [ary1, \"v1\"], [\"k2\", \"v2\"], [ary2, \"v3\"], ]); console.log(map instanceof Map); console.log(map); // true // Map { [ 1, 2, 3 ] => 'v3', 'k2' => 'v2' } 获取数量 size 使用size属性可获取当前Map容器中的键值对数量： \"use strict\"; let map = new Map([ [\"k1\", \"v1\"], [\"k2\", \"v2\"], [\"k3\", \"v3\"], ]); console.log(map.size); // 3 新增数据 set() 使用set()方法为Map容器新增一组键值对： \"use strict\"; let map = new Map(); for (let i = 1; i 'v1', 'k2' => 'v2', 'k3' => 'v3' } 元素检测 has() 使用has()方法可检测当前Map容器中是否存在某个键，返回布尔值。 注意，如果键是引用类型则必须要使用原本键对象的引用才行，单纯的形式相似总会返回false \"use strict\"; let ary = [1, 2, 3]; let map = new Map([ [ary, \"v1\"], [\"k2\", \"v2\"], [\"k3\", \"v3\"], ]); // 同一引用，返回true console.log(map.has(ary)); // 非同一引用，返回false console.log(map.has([1, 2, 3])); // true // false 获取元素 get() 使用get()方法根据键获取值，若键不存在则返回undefined： \"use strict\"; let map = new Map([ [\"k1\", \"v1\"], [\"k2\", \"v2\"], [\"k3\", \"v3\"], ]); console.log(map.get(\"k1\")); console.log(map.get(\"k8\")); // v1 // undefined 删除元素 delete() 使用delete()方法根据键来删除Map容器中的一组键值对。 若删除成功则返回true，否则返回false： \"use strict\"; let map = new Map([ [\"k1\", \"v1\"], [\"k2\", \"v2\"], [\"k3\", \"v3\"], ]); console.log(map.delete(\"k8\")); console.log(map.delete(\"k1\")); // false // true 清空容器 clear() 使用clear()方法可清空Map容器： \"use strict\"; let map = new Map([ [\"k1\", \"v1\"], [\"k2\", \"v2\"], [\"k3\", \"v3\"], ]); map.clear(); console.log(map); // Map {} 数组转换 可使用…语法或者Array.form()将Map容器转换为二维数组： \"use strict\"; let map = new Map([ [\"k1\", \"v1\"], [\"k2\", \"v2\"], [\"k3\", \"v3\"], ]); let ary1 = new Array(...map); let ary2 = Array.from(map); console.log(ary1); console.log(ary2); // [ [ 'k1', 'v1' ], [ 'k2', 'v2' ], [ 'k3', 'v3' ] ] // [ [ 'k1', 'v1' ], [ 'k2', 'v2' ], [ 'k3', 'v3' ] ] 遍历操作 迭代器方法 使用以下3个方法都可创建出Map迭代器。 kes() values() entries() 示例如下： \"use strict\"; let map = new Map([ [\"k1\", \"v1\"], [\"k2\", \"v2\"], [\"k3\", \"v3\"], ]); console.log(map.keys()); console.log(map.values()); console.log(map.entries()); // [Map Iterator] { 'k1', 'k2', 'k3' } // [Map Iterator] { 'v1', 'v2', 'v3' } // [Map Iterator] { [ 'k1', 'v1' ], [ 'k2', 'v2' ], [ 'k3', 'v3' ] } for/of 由于Map本身属于可迭代对象，所以你可以直接使用for/of对其进行遍历操作。 这么做将拿到k-v，它们会以数组的形式返回： \"use strict\"; let map = new Map([ [\"k1\", \"v1\"], [\"k2\", \"v2\"], [\"k3\", \"v3\"], ]); for(let kv of map){ console.log(kv); } // [ 'k1', 'v1' ] // [ 'k2', 'v2' ] // [ 'k3', 'v3' ] forEach() 使用forEach()方法也可对Map容器进行遍历操作。 它与Array的forEach()方法使用基本相同。 \"use strict\"; let map = new Map([ [\"k1\", \"v1\"], [\"k2\", \"v2\"], [\"k3\", \"v3\"], ]); map.forEach((key, value) => { console.log(key, value); }) // v1 k1 // v2 k2 // v3 k3 WeakMap 基本介绍 WeakMap和Map非常相似，它也是根据键值对的形式来进行数据的存取。 但它和Map也有一些不同之处，如下所示： WeakMap中的键必须是对象（引用类型） WeakMap中的键是无序的 WeakMap中的键是弱引用的，也就是说WeakMap中的键并不会增加键源对象的引用计数 在GC机制运行时，如果键源对象在其他地方被删除，WeakMap中也会删除掉该键值对 因为WeakMap中的键是弱引用的，故WeakMap不包含keys()、values()、entries()等方法和size属性，同时WeakMap是不可被迭代的 由于WeakMap中的键是弱引用的特性，故我们可以用它来保存一些经常存取的数据。 当键源对象在外部被删除后，WeakMap中的键值对也会删除，以此达到动态视图的功能。 声明定义 使用WeakMap()加上嵌套的二维数组即可声明出一个WeakMap容器。 注意！键必须是引用类型，若是值类型则会抛出异常 \"use strict\"; let ary = [1, 2, 3]; let obj = { k1: \"v1\", k2: \"v2\" }; let map = new Map([[\"k1\", \"v1\"], [\"k2\", \"v2\"]]); let wMap = new WeakMap([ [ary, \"v1\"], [obj, \"v2\"], [map, \"v3\"], ]) console.log(wMap); // WeakMap {{…} => \"v2\", Map(2) => \"v3\", Array(3) => \"v1\"} WeakMap的键必须是不同的对象，若相同内存地址的对象作为WeakMap中的多个键，将会引发键冲突。 换而言之，WeakMap中的键必须是唯一的。 1）ary1和ary2的内存地址不同，故不会发生键冲突： \"use strict\"; let ary1 = [1, 2, 3]; let ary2 = [1, 2, 3]; let obj = { k1: \"v1\", k2: \"v2\" }; let wMap = new WeakMap([ [ary1, \"v1\"], [obj, \"v2\"], [ary2, \"v3\"], ]) console.log(wMap); // WeakMap {{…} => \"v2\", Array(3) => \"v1\", Array(3) => \"v3\"} 2）ary1和ary2的内存地址相同，将会引发键冲突： \"use strict\"; let ary1 = [1, 2, 3]; let ary2 = ary1; let obj = { k1: \"v1\", k2: \"v2\" }; let wMap = new WeakMap([ [ary1, \"v1\"], [obj, \"v2\"], [ary2, \"v3\"], ]) console.log(wMap); // WeakMap {Array(3) => \"v3\", {…} => \"v2\"} 常用操作 WeakMap容器仅包含3个可用的方法： set()：新增一组键值对，其中键必须是引用类型 delete()：删除一组键值对 has()：根据键判断键值对是否存在于WeakMap容器中 弱引用 对于GC机制的引用计数法来说，存在于WeakMap中的对象键并不会为其增加引用计数，因此这种特性也被称为弱引用。 当WeakMap中对象键在外部的引用计数为0后，WeakMap内部中该键值对也会被清除，如下所示： \"use strict\"; let ary = [1, 2, 3]; let obj = { k1: \"v1\", k2: \"v2\" }; let map = new Map([[\"k1\", \"v1\"], [\"k2\", \"v2\"]]); let wMap = new WeakMap([ [ary, \"v1\"], [obj, \"v2\"], [map, \"v3\"], ]) console.log(wMap); // 引用计数归0 ary = undefined; // 等待GC机制运行，3s后打印结果 setTimeout(() => { console.log(wMap); }, 3000); // WeakMap {{…} => \"v2\", Map(2) => \"v3\", Array(3) => \"v1\"} // WeakMap {{…} => \"v2\", Map(2) => \"v3\"} Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:48 "},"前端专栏/JavaScript/Set&WeakSet.html":{"url":"前端专栏/JavaScript/Set&WeakSet.html","title":"Set&WeakSet","keywords":"","body":"Set 基本介绍 Set是一种具有去重特性的容器，它可以存入任意类型的数据。它在ES6中被引入。 Set常用来操纵数据，而非存储数据。 你可以将Set理解为只有key没有value的map Set中的元素会进行严格类型检测存储，即数字字符串不等于数字 Set中存储的值具有唯一性，即Set本身能对元素进行去重 Set中存入的元素是有序的，即先存入的元素在遍历时会先被遍历到 声明定义 使用Set()时传入一个数组即可声明出一个Set容器： \"use strict\"; let set = new Set([ new Number(1), new String(\"1\"), new Boolean(true), new Array(\"A\", \"B\", \"C\"), new Map([[\"k1\", \"v1\", \"k2\", \"v2\"]]) ]); console.log(set instanceof Set); console.log(set); // true // Set { // [Number: 1], // [String: '1'], // [Boolean: true], // [ 'A', 'B', 'C' ], // Map { 'k1' => 'v1' } // } 去重特性 如果一个相同内存地址的对象多次被存入Set中，则只会保留一个。 1）ary1和ary2的内存地址不同，故不会触发Set的去重特性： \"use strict\"; let ary1 = [1, 2, 3]; let ary2 = [1, 2, 3]; let set = new Set([ ary1, ary2, ]); console.log(set); // Set { [ 1, 2, 3 ], [ 1, 2, 3 ] } 2）ary1和ary2的内存地址相同，将会触发Set的去重特性： \"use strict\"; let ary1 = [1, 2, 3]; let ary2 = ary1; let set = new Set([ ary1, ary2, ]); console.log(set); // Set { [ 1, 2, 3 ] } 获取数量 size 使用size属性可获取当前Set容器中的元素数量： \"use strict\"; let set = new Set([ new Number(1), new String(\"1\"), new Boolean(true), new Array(\"A\", \"B\", \"C\"), new Map([[\"k1\", \"v1\", \"k2\", \"v2\"]]) ]); console.log(set.size); // 5 新增元素 add() 使用add()方法为Set容器新增元素项： \"use strict\"; let set = new Set(); for (let i = 1; i 元素检测 has() 使用has()方法可检测当前Set容器中是否存在某个元素项，返回布尔值。 注意，如果元素是引用类型则必须要使用原本元素对象的引用才行，单纯的形式相似总会返回false \"use strict\"; let ary = [1, 2, 3]; let set = new Set([ ary, \"v2\", \"v3\", ]); // 同一引用，返回true console.log(set.has(ary)); // 非同一引用，返回false console.log(set.has([1, 2, 3])); // true // false 删除元素 delete() 使用delete()方法根据键来删除Set容器中的某个元素项。 若删除成功则返回true，否则返回false： \"use strict\"; let set = new Set([ \"v1\", \"v2\", \"v3\", ]); console.log(set.delete(\"v8\")); console.log(set.delete(\"v1\")); // false // true 清空容器 clear() 使用clear()方法可清空Set容器： \"use strict\"; let set = new Set([ \"v1\", \"v2\", \"v3\", ]); set.clear(); console.log(set); // Set {} 数组转换 可使用…语法或者Array.form()将Set容器转换为数组。 我们可以利用Set的去重特性来剔除掉数组中的重复数据项，如下示例： \"use strict\"; let ary = [1, 1, 2, 2, 3, 3]; ary = Array.from(new Set(ary)); console.log(ary); // [ 1, 2, 3 ] 交差并集 通过集合和数组的转换，可实现多集合之间求交差并集操作。 1）交集，求出2个集合之间共有的部分： \"use strict\"; let set1 = new Set([1, 2, 3]); let set2 = new Set([2, 3, 4]); let intersection = new Set( Array.from(set1).filter((item, index, array) => { return set2.has(item); }) ) console.log(intersection); // Set { 2, 3 } ，2）差集，求出一个集合独有的部分： \"use strict\"; let set1 = new Set([1, 2, 3]); let set2 = new Set([2, 3, 4]); let difference = new Set( Array.from(set1).filter((item, index, array) => { return !set2.has(item); }) ) console.log(difference); // Set { 1 } 3）并集，将多个集合合并成一个集合，共有元素只取一次： \"use strict\"; let set1 = new Set([1, 2, 3]); let set2 = new Set([2, 3, 4]); let union = new Set([...set1, ...set2]); console.log(union); // Set { 1, 2, 3, 4 } 遍历操作 迭代器方法 使用以下3个方法都可创建出Set迭代器。 kes() values() entries() 示例如下： \"use strict\"; let set = new Set([ \"v1\", \"v2\", \"v3\", ]); console.log(set.keys()); console.log(set.values()); console.log(set.entries()); // SetIterator {\"v1\", \"v2\", \"v3\"} // SetIterator {\"v1\", \"v2\", \"v3\"} // SetIterator {\"v1\" => \"v1\", \"v2\" => \"v2\", \"v3\" => \"v3\"} for/of 由于Set本身属于可迭代对象，所以你可以直接使用for/of对其进行遍历操作。 \"use strict\"; let set = new Set([ \"v1\", \"v2\", \"v3\", ]); for(let v of set){ console.log(v); } // v1 // v2 // v3 forEach() 使用forEach()方法也可对Set容器进行遍历操作。 它与Array的forEach()方法使用基本相同。 \"use strict\"; let set = new Set([ \"v1\", \"v2\", \"v3\", ]); set.forEach((item, _, set) => { console.log(item); }) // v1 // v2 // v3 WeakSet 基本介绍 WeakSet和Set非常相似，它也具有去重的特性。 但它和Set也有一些不同之处，如下所示： WeakSet中的元素项必须是对象（引用类型） WeakSet中的元素是无序的 WeakSet中的元素是弱引用的，也就是说WeakSet中的元素并不会增加源对象的引用计数 在GC机制运行时，如果源对象在其他地方被删除，WeakSet中也会删除掉该元素 因为WeakSet的元素是弱引用的，故WeakSet不包含keys()、values()、entries()等方法和size属性，同时WeakSet是不可被迭代的 声明定义 使用WeakSet()时传入一个数组即可声明出一个WeakSet容器： \"use strict\"; let ary = new Array([1, 2, 3]); let map = new Map([[\"k1\", \"v1\"]]); let obj = new Object({\"k1\" : \"v1\"}); let wSet = new WeakSet([ ary, map, obj, ]); console.log(wSet instanceof WeakSet); console.log(wSet); // true // WeakSet {Map(1), {…}, Array(1)} 常用操作 WeakMap容器仅包含3个可用的方法： add()：新增一个元素 delete()：删除一个元素 has()：判断某个元素是否存在于WeakSet容器中 弱引用 对于GC机制的引用计数法来说，存在于WeakSet中的元素并不会为其增加引用计数，因此这种特性也被称为弱引用。 当WeakSet中元素在外部的引用计数为0后，WeakSet内部中该元素也会被清除，如下所示： \"use strict\"; let ary = new Array([1, 2, 3]); let map = new Map([[\"k1\", \"v1\"]]); let obj = new Object({\"k1\" : \"v1\"}); let wSet = new WeakSet([ ary, map, obj, ]); console.log(wSet); // 引用计数归0 ary = undefined; // 等待GC机制运行，3s后打印结果 setTimeout(() => { console.log(wSet); }, 3000); // WeakSet {Map(1), {…}, Array(1)} // WeakSet {Map(1), {…}} Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:48 "},"前端专栏/JavaScript/函数相关.html":{"url":"前端专栏/JavaScript/函数相关.html","title":"函数相关","keywords":"","body":"自定义函数 对象声明 JavaScript中的函数其实是Function的实例对象，因此我们可以采用实例化的方式来定义函数： \"use strict\"; // new Function(\"参数\", \"函数体代码\"); let func = new Function(\"param1\", \"param2\", \"console.log(param1, param2);\"); func(1, 2); // 1 2 标准声明 对象声明的方式太过麻烦，因此推荐使用function标准语法进行函数定义： \"use strict\"; function func(param1, param2){ console.log(param1, param2); } func(1, 2); // 1 2 变量赋值 也可以先使用function声明出一个匿名函数，再将该匿名函数绑定给某个变量或常量。 注意这种方式需要在代码结尾处加上分号： \"use strict\"; let func = function (param1, param2) { console.log(param1, param2); }; func(1, 2); // 1 2 匿名执行 使用以下方式将声明出一个匿名自执行函数（IIFE），它只会执行一次。 注意这种方式需要在代码结尾处加上分号： \"use strict\"; (function (param1, param2) { console.log(param1, param2); })(1, 2); // 1 2 使用函数 函数名加括号即可调用该函数。 若函数没有显式的进行return，则默认返回undefined： \"use strict\"; function show() { } let result = show(); console.log(result); // undefined 函数提升 标准声明的函数具有函数提升的特性，即可以先使用、后声明函数，这显然不是我们想看到的结果。 但是匿名函数则不会有这种特性，因此更建议使用变量赋值的方式来进行函数声明： \"use strict\"; func(1, 2); function func(param1, param2){ console.log(param1, param2); } // 1 2 函数提升比var变量提升优先级更高，如果标准声明的函数和var赋值声明的函数名字相同时，var赋值声明的函数会被GC所清理： \"use strict\"; func(); function func(){ console.log(\"run standard func\"); } var func = function(){ console.log(\"run var func\"); } // run standard func 更加建议使用let进行函数的赋值声明，它将带来2点好处： TDZ暂时性死区意味着必须先定义再使用let所赋值声明的函数 不会将函数名存入到window对象中 \"use strict\"; let func = function(){ console.log(\"run let func\"); } func(); // run let func 不过一般只要谨记不论是变量或是函数必须先定义后使用的规范时，即可使用标准声明定义函数。 参数相关 参数传递 在参数进行传递时，要注意以下几点： 实参和形参必须一一对应 实参数量若大于形参数量时，多余的实参将忽略掉，并不会报错 形参数量若大于实参数量时，未传入实参的形参值将为undefined 我们可以使用funcName.length来获取需要传递形参的数量。 \"use strict\"; function show(param1, param2, param3){ console.log(param1); console.log(param2); console.log(param3); } // 1.获取形参数量 console.log(show.length); // 3 // 2.实参多，形参少，不会抛出异常 show(\"A\", \"B\", \"C\", \"D\", \"E\"); // A B C // 3.实参少，形参多，未传递形参的值将变为undefined show(\"A\", \"B\"); // A B undefined 默认形参 默认形参是ES6新引进的语法，在使用时需要注意默认形参必须放在最后，当该形参没有实参传递时将采用所设定的默认值，当有实参传递时将采用实参所传递进来的值： \"use strict\"; function show(param1, param2, param3=\"default parameter\"){ console.log(param1); console.log(param2); console.log(param3); } // 实参少，形参多，未传递形参的值将采用默认形参 show(\"A\", \"B\"); // A B default parameter 在ES6之前，我们会这么来定义默认形参： \"use strict\"; function show(param1, param2, param3){ // 定义默认形参 param3 = param3 || \"default parameter\"; console.log(param1); console.log(param2); console.log(param3); } // 实参少，形参多，未传递形参的值将采用默认形参 show(\"A\", \"B\"); // A B default parameter ...语法 …语法形参是ES6新引进的语法。 当不确定使用者会传递进多少实参时，可用...语法接收所有多余的传递进来的参数： \"use strict\"; function show(x, y, ...args){ console.log(args); } show(\"A\", \"B\", \"C\", \"D\", \"E\"); // [ 'C', 'D', 'E' ] 数组解构传参 当实参是一个数组时，形参可以对其进行解构： \"use strict\"; // b c d都是默认形参 function show(a, [b, c, d] =\"default parameter\"){ console.log(a); console.log(b); console.log(c); console.log(d); } show(\"A\", [\"B\", \"C\"]); // A // B // C // undefined 对象解构传参 当实参是一个对象时，形参可以对其进行解构： \"use strict\"; // b c d都是默认形参 function show(a, { b, c, d = \"default parameter\" }) { console.log(a); console.log(b); console.log(c); console.log(d); } show(\"A\", { b: \"B\", c: \"C\" }); // A // B // C // default parameter arguments 使用arguments查看使用者传递的所有实参。 即使该实参未被形参接收到： \"use strict\"; function show(x, y){ console.log(arguments); } show(\"A\", \"B\", \"C\", \"D\", \"E\"); // [Arguments] { '0': 'A', '1': 'B', '2': 'C', '3': 'D', '4': 'E' } 注意！arguments本身是属于Arguments对象，并不是一个数组，但是我们可以将它转换为数组后再做操作。 高阶函数 一等公民 function是JavaScript中的一等公民，所以函数可以被赋值、传参、被当做返回值return、被当做容器中的数据项进行存储。 赋值 函数可以被赋值： \"use strict\"; let f1 = function () { console.log(\"run\"); } let f2 = f1; let f3 = f2; f1(); f2(); f3(); // run // run // run 传参 函数可以被当做参数传递给另一个函数： \"use strict\"; function f1(){ console.log(\"run f1\"); } function f2(f){ console.log(\"run f2\"); f(); } f2(f1); // run f2 // run f1 返回值 函数可以被当做返回值： \"use strict\"; function wrapper(){ console.log(\"run wrapper\"); return function(){ console.log(\"run inner\"); } } wrapper()(); // run wrapper // run inner 数据项 函数可以被当做容器的数据项： \"use strict\"; let ary = [ function(item){console.log(`func${item} run`);}, function(item){console.log(`func${item} run`);}, function(item){console.log(`func${item} run`);}, ] for(let [idx, func] of ary.entries()){ func(idx); } // func0 run // func1 run // func2 run 递归函数 递归函数即自己调用自己的函数。 主要用于数量不确定的循环操作 要有退出时机否则会陷入无限递归的过程 以下示例将用递归函数来解决汉诺塔问题： \"use strict\"; function hanoi(n, a, b, c) { if (n) { hanoi(n - 1, a, c, b); console.log(`moving from ${a} to ${c}`); hanoi(n - 1, b, a, c); } } hanoi(3, \"A\", \"B\", \"C\"); // moving from A to C // moving from A to B // moving from C to B // moving from A to C // moving from B to A // moving from B to C // moving from A to C 以下示例将用递归函数来打印倒三角： \"use strict\"; function show(num) { if (!num) { return } console.log(\"*\".repeat(num)); show(num - 1); } show(5); // ***** // **** // *** // ** // * 回调函数 回调函数是指在某些特定情况下会被其他函数所调用的函数，比如处理键盘事件、鼠标事件等函数都是回调函数： Document click me \"use strict\"; let btn = document.querySelector(\"#btn\"); let section = btn.nextElementSibling.nextElementSibling; btn.addEventListener(\"click\", function (event) { let r = Math.floor(Math.random() * 255); let g = Math.floor(Math.random() * 255); let b = Math.floor(Math.random() * 255); let a = Math.random().toFixed(1); console.log(a); section.style.backgroundColor = `rgba(${r}, ${g}, ${b}, ${a})`; }) 箭头函数 箭头函数是常规函数的一种简写形式。 在使用递归调用、构造函数、事件处理器时不建议使用箭头函数。 函数无形参时使用空括号即可，函数体代码块过短可直接省略花括号 函数体代码块如果只有一句，且为单一的表达式形式时可不必显示return，它会自动进行return 函数只有1个形参时可省略花括号，但如果有多个参数时不可省略 以下是3个箭头函数的定义案例： \"use strict\"; // 函数无形参时使用空括号即可，函数体代码块过短可直接省略花括号 let show = () => console.log(\"run function show\"); // 函数体代码块如果只有一句，且为单一的表达式形式时可不必显示return，它会自动进行return let add = (x, y) => x + y; // 函数只有1个形参时可省略花括号，但如果有多个参数时不可省略 let warning = msg => console.log(msg); show(); console.log(add(1, 2)); warning(\"warning message\"); // run function show // 3 // warning message 上面只是介绍箭头函数的用法，个人在实际使用时不论什么情况下都会加上return，这算是一种习惯吧。 模板函数 模板拆解是指定义一个模板函数，该函数可以提取出模板字符串中的普通字符串与格式化变量。 注意！模板函数会自动进行执行。 代码示例： \"use strict\"; let userName = \"Jack\"; let userAge = 18; function func(s, ...f) { // s:普通字符串 // f:格式化变量 console.log(s); // (3) [\"name:\", \",age:\", \"\", raw: Array(3)] console.log(f); // (2) [\"Jack\", 18] } func`name:${userName},age:${userAge}`; Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:48 "},"前端专栏/JavaScript/函数闭包.html":{"url":"前端专栏/JavaScript/函数闭包.html","title":"函数闭包","keywords":"","body":"作用域 作用域介绍 在JavaScript中，所有的标识符（变量名、常量名、函数名、类名）都有一个作用范围。 这个作用范围即被称之为作用域。 举个简单的例子： 清华大学的校规只在清华大学范围内生效 那么清华大学就是清华校规的作用域 全局作用域 全局作用域即是在全局下定义标识符的作用范围。 在JavaScript中，全局作用域中的标识符全局有效，在任何作用域下都能进行访问。 生命周期：代码运行时自动产生，代码运行完毕后自动销毁 数量：至多一个 下列代码中，全局作用域中自定义的标识符有： userName userAge show \"use strict\"; let userName = \"Jack\"; let userAge = 18; function show(){ console.log(userName); } show(); // Jack 由于全局作用域中的标识符全局有效，故在局部作用域中也能对其进行访问。 局部作用域 局部作用域即是在函数或者类下定义标识符的作用范围。 在JavaScript中，局部作用域中的标识符局部有效，外部作用域不能够进行访问。 生命周期：函数体代码执行时产生，函数体代码执行完毕后销毁 数量：可有多个 下列代码中，局部作用域中自定义的标识符有： count message \"use strict\"; let userName = \"Jack\"; let userAge = 18; function show(){ let count = 1; let message = \"this is a message\"; console.log(count); console.log(message); } show(); // 外部作用域不能访问内部作用域 // console.log(count); // console.log(message); // 1 // this is a message 由于局部作用域中的标识符局部有效，故只有在局部作用域中才能对其进行访问，外部作用域是访问不到的。 块级作用域 块级作用域即是在for循环下定义标识符的作用范围，且只有const、let作为迭代变量声明时才具有块级作用域。 在JavaScript中，块级作用域中的标识符局部有效，外部作用域不能够进行访问。 生命周期：循环体代码执行时产生，循环体代码执行完毕后销毁 数量：可有多个 下列代码中，块级作用域中自定义的标识符有： i currentItem \"use strict\"; let userName = \"Jack\"; let userAge = 18; for (let i = 0; i 由于块级作用域中的标识符局部有效，故只有在块级作用域中才能对其进行访问，外部作用域是访问不到的。 标识符查找顺序 先到自身的作用域中查找，如果没有再到定义自己作用域的作用域中进行查找。 示例如下，局部作用域需要使用userName，发现自己有就用自己的，自己没有就往上找： \"use strict\"; let userName = \"Jack\"; let userAge = 18; function show() { let userName = \"Tom\"; // 在show的局部作用域中定义了匿名自执行函数 (function () { // ↑ 向上找，定义自己的作用域中去找 console.log(userName); }()); } show(); // Tom 闭包函数 若一个函数中嵌套定义并返回了另一个函数，那个这个函数即被称为闭包函数。 内部函数在外部被进行使用时其父函数的命名空间并不会被销毁而是依旧存活： \"use strict\"; // 全局作用域下定义的标识符：wrapper innerFunction result // wrapper局部作用域下定义的标识符: funcName .. 匿名函数 function wrapper() { let funcName = \"wrapper\"; return function () { return funcName } } let innerFunction = wrapper(); // 外部要使用内层函数，故wrapper的命名空间不会被销毁 let result = innerFunction(); console.log(result); // wrapper 基于这个特性，异步提交网络请求、处理DOM事件才变得可行。 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:48 "},"前端专栏/JavaScript/面向对象.html":{"url":"前端专栏/JavaScript/面向对象.html","title":"面向对象","keywords":"","body":"Object 基本声明 JavaScript中一切皆对象，我们可以自定义一个对象将一组功能进行整合。 对象声明方式为： 使用{}对键值对进行包裹，键值对采用k:v的形式分割，多个键值对之间使用逗号进行分割。 在声明对象时，需要注意以下2点： 键只能是String类型或者Symbol类型 键没有被引号包裹时，会自动将其转换为String类型 代码如下： \"use strict\"; let obj = { userName: \"Jack\", userAge: 18, userGender: \"male\", getInfo: function () { return `name:${this.userName}\\nage:${this.userAge}\\ngender:${this.userGender}` } }; let userMessage = obj.getInfo(); console.log(userMessage); // name:Jack // age:18 // gender:male 注意！对象是引用类型，故传递时只会传递引用地址，并不会传递值本身。 访问语法 不管是对象内部还是对象外部，我们都可以使用点来访问某个属性或方法。 如下所示： \"use strict\"; let obj = { userName: \"Jack\", userAge: 18, userGender: \"male\", getInfo: function () { return `name:${this.userName}\\nage:${this.userAge}\\ngender:${this.userGender}` } }; console.log(obj.userName); console.log(obj.userAge); console.log(obj.userGender); // Jack // 18 // male 你也可以使用[]来进行访问，但是这样的做法很少见： \"use strict\"; let obj = { userName: \"Jack\", userAge: 18, userGender: \"male\", getInfo: function () { return `name:${this.userName}\\nage:${this.userAge}\\ngender:${this.userGender}` } }; console.log(obj[\"userName\"]); console.log(obj[\"userAge\"]); console.log(obj[\"userGender\"]); // Jack // 18 // male 变量属性 当对象中的某个键是一个变量时，在声明时必须使用[]对变量名进行包裹，并且在访问时也需要使用[]对变量名进行包裹。 如下所示： \"use strict\"; let userName = Symbol(\"username\"); let obj = { [userName]: \"Jack\", userAge: 18, userGender: \"male\", getInfo: function () { return `name:${this.userName}\\nage:${this.userAge}\\ngender:${this.userGender}` } }; // 注意2者区别，变量键不加引号 // 普通键需要加上引号 console.log(obj[userName]); console.log(obj[\"userAge\"]); console.log(obj[\"userGender\"]); // Jack // 18 // male this介绍 当在对象内部要访问某个属性时，可以通过this进行访问。 this在大多数情况下总是指向当前对象，它相当于Python中的self： \"use strict\"; let obj = { userName: \"Jack\", userAge: 18, userGender: \"male\", method: function () { // this指向当前object console.log(this); } }; obj.method(); // { userName: 'Jack', // userAge: 18, // userGender: 'male', // method: [Function: method] } 箭头方法 在定义方法时，不要使用箭头函数进行定义，因为箭头函数没有this指向，他会根据上层作用域的this指向来定义，所以在箭头函数中使用this返回的永远都是window对象： \"use strict\"; let obj = { userName: \"Jack\", userAge: 18, userGender: \"male\", method:()=>{ console.log(this); } }; obj.method(); // window 简写形式 在ES6中，如果对象的键值对相同，则可以进行简写： \"use strict\"; let userName = \"Jack\"; let userAge = 18; let userGender = \"male\"; let obj = { userName, userAge, userGender, method() { console.log(\"run method...\"); } }; console.log(obj.userName); console.log(obj.userAge); console.log(obj.userGender); // Jack // 18 // male 创建对象 工厂函数 当一个函数中返回一组结构相似的对象时，该函数即可被称为工厂函数。 使用工厂函数创建对象时具有以下2点优势： 减少重复创建相同类型对象的代码 修改工厂函数的方法将影响所有同类对象 使用工厂函数，实现类似于class的功能： \"use strict\"; function Person(userName, userAge, userGender = \"male\") { return { userName, userAge, userGender, getInfo() { return `name:${this.userName}\\nage:${this.userAge}\\ngender:${this.userGender}`; } } } let insJack = Person(\"Jack\", 18); let insTom = Person(\"Tom\", 19); let insMary = Person(\"Mary\", 17, \"male\"); console.log(insJack.getInfo()); console.log(insTom.getInfo()); console.log(insMary.getInfo()); // name:Jack // age:18 // gender:male // name:Tom // age:19 // gender:male // name:Mary // age:17 // gender:male 构造函数 构造函数的作用也是用于创建对象，它比工厂函数更常用。 该函数不必显式的return一个对象，而是在使用时通过new关键字来生成一个对象。 构造函数命名风格必须采用大驼峰形式 构造函数在使用时必须通过new来创建对象 构造函数拥有this，该this不必手动声明，系统会自动生成 构造函数中的this总是指向当前创建的对象 构造函数说白了就是其他语言中的class，当然这里面还有一些非常大的区别，后面会进行介绍，如下所示： \"use strict\"; function Person(userName, userAge, userGender = \"male\") { this.userName = userName; this.userAge = userAge; this.userGender = userGender; this.getInfo = function () { return `name:${this.userName}\\nage:${this.userAge}\\ngender:${this.userGender}`; }; } let insJack = new Person(\"Jack\", 18); let insTom = new Person(\"Tom\", 19); let insMary = new Person(\"Mary\", 17, \"male\"); console.log(insJack.getInfo()); console.log(insTom.getInfo()); console.log(insMary.getInfo()); // name:Jack // age:18 // gender:male // name:Tom // age:19 // gender:male // name:Mary // age:17 // gender:male 类型转换 Symbol.toPrimitive() 如果对象内部定义了Symbol.toPrimitive()方法，它将用来处理所有的转换场景： \"use strict\"; let obj = { num: 100, [Symbol.toPrimitive]: function () { return this.num; } } console.log(1 + obj); // 101 valueOf() 对象内部定义的valueOf()方法可将对象转换任意类型： \"use strict\"; let obj = { num: 100, valueOf() { return this.num; } } console.log(1 + obj); // 101 toString() 对象内部定义的toString()方法也可将对象转换成任意类型，但是一般我们会将该对象转换为String类型以符合该方法的语义： \"use strict\"; let obj = { num: 100, description: \"this is a object\", toString(){ return this.description; } } // 模板字面量，自动调用toString方法 console.log(`${obj}`); // this is a object 解构语法 解构赋值 基本使用，外部必须由{}进行包裹： \"use strict\"; let obj = { userName: \"Jack\", userAge: 18, userGender: \"male\", userHobby: [\"basketball\", \"football\", \"volleyball\"] } // 完整写法 { 键名:赋值的变量名, ...} let { userName: n, userAge: a, userGender: g, userHobby: hobby } = obj; console.log(n, a, g, hobby); // Jack 18 male [ 'basketball', 'football', 'volleyball' ] // 简写形式，接收解构的变量名必须和键名一致 let {userName, userAge, userGender, userHobby} = obj; console.log(userName, userAge, userGender, userHobby); // Jack 18 male [ 'basketball', 'football', 'volleyball' ] 若你想一个变量接收多个被解构的元素，可使用...语法接收它们： \"use strict\"; let obj = { userName: \"Jack\", userAge: 18, userGender: \"male\", userHobby: [\"basketball\", \"football\", \"volleyball\"] } let {userName, ...other} = obj; console.log(userName, other); // Jack // { userAge: 18, userGender: 'male', userHobby: [ 'basketball', 'football', 'volleyball' ] } 此外，你也可以不填入某个需要被解构赋值的键名来达省略获取的目的： \"use strict\"; let obj = { userName: \"Jack\", userAge: 18, userGender: \"male\", userHobby: [\"basketball\", \"football\", \"volleyball\"] } let {userName, userAge} = obj; console.log(userName, userAge); // Jack 18 嵌套解构 解构多层嵌套的对象： \"use strict\"; let obj = { userName: \"Jack\", userAge: 18, userGender: \"male\", userHobby: { first: \"basketball\", second: \"football\", last: \"volleyball\" } } let { userName, userHobby: { // { 键名:赋值的变量名, ...} first: userFirstHobby, second: userSecondHobby, last: userLastHobby } } = obj; console.log(userName, userFirstHobby, userSecondHobby, userLastHobby); // Jack basketball football volleyball 默认解构 可以为一个变量设置默认值，如果解构的对象中有该变量作为键名则取消默认值采用对象中键对应的值。 \"use strict\"; let obj = { userName: \"Jack\", userAge: 18, userGender: \"male\", userHobby: { first: \"basketball\", second: \"football\", last: \"volleyball\" } } let {userName, userDesc=\"self introduction\"} = obj; console.log(userName, userDesc); // Jack self introduction 对象合并 ...语法 通过…语法，可让多个不同的对象合并成一个对象： \"use strict\"; let obj_1 = { k1: \"v1\", k2: \"v2\", }; let obj_2 = { k3: \"v3\", k4: \"v4\", }; let new_obj = { ...obj_1, ...obj_2 }; console.log(new_obj); // { k1: 'v1', k2: 'v2', k3: 'v3', k4: 'v4' } assign() 通过Object.assign()方法，可让多个不同的对象合并成一个对象： \"use strict\"; let obj_1 = { k1: \"v1\", k2: \"v2\", }; let obj_2 = { k3: \"v3\", k4: \"v4\", }; let new_obj = Object.assign(obj_1, obj_2); console.log(new_obj); // { k1: 'v1', k2: 'v2', k3: 'v3', k4: 'v4' } 对象遍历 迭代器方法 使用以下3个方法都可创建出Object迭代器，它们都会返回一个数组对象。 Object.kes() Object.values() Object.entries() 示例如下： \"use strict\"; let obj = { k1: \"v1\", k2: \"v2\", k3: \"v3\", }; console.log(Object.keys(obj)); console.log(Object.values(obj)); console.log(Object.entries(obj)); // [ 'k1', 'k2', 'k3' ] // [ 'v1', 'v2', 'v3' ] // [ [ 'k1', 'v1' ], [ 'k2', 'v2' ], [ 'k3', 'v3' ] ] for/in for/in拿到的结果始终是key： \"use strict\"; let obj = { k1: \"v1\", k2: \"v2\", k3: \"v3\", }; for (let k in obj) { console.log(k, \"->\", obj[k]); } // k1 -> v1 // k2 -> v2 // k3 -> v3 for/of 由于Object本身不属于可迭代对象，所以我们只能通过Object.kes()、Object.values()、Object.entries()手动创建出迭代器后再进行遍历操作，如下所示： \"use strict\"; let obj = { k1: \"v1\", k2: \"v2\", k3: \"v3\", }; for (let [k, v] of Object.entries(obj)) { console.log(k, \"->\", v); } // k1 -> v1 // k2 -> v2 // k3 -> v3 属性管理 添加属性 . 通过.语法直接为对象添加属性或方法； \"use strict\"; let obj = {}; obj.k1 = \"v1\"; console.log(obj.k1); // v1 删除属性 delete 使用delete可以删除非保护的属性： \"use strict\"; let obj = { k1: \"v1\", k2: \"v2\", k3: \"v3\", }; delete obj.k1; console.log(obj); // { k2: 'v2', k3: 'v3' } 计算属性 对象属性可以通过表达式计算定义，这在动态设置属性或执行属性方法时很好用。 \"use strict\"; let id = 1; let obj = { [`id-${id++}`]: id, [`id-${id++}`]: id, [`id-${id++}`]: id, [`id-${id++}`]: id, }; console.log(obj); // { 'id-1': 2, 'id-2': 3, 'id-3': 4, 'id-4': 5 } 属性封装 有一些属性我们不希望外部直接获取到，如age属性，我们可以为其进行封装： \"use strict\"; let obj = { userName: \"Jack\", userGender: \"male\", __userData: { userAge: 18, }, getAge() { return this.__userData.userAge; } }; console.log(obj.getAge()); // 18 构造函数形式： \"use strict\"; let Person = function (userName, userGender, userAge) { this.userName = userName; this.userGender = userGender; this.__userData = { userAge, } this.getAge = function(){ return this.__userData.userAge; } }; let ins = new Person(\"Jack\", \"male\", 18); console.log(ins.getAge()); // 18 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:48 "},"前端专栏/JavaScript/this指向.html":{"url":"前端专栏/JavaScript/this指向.html","title":"this指向","keywords":"","body":"this是什么 this是JavaScript中的一个关键字。 一般我们会在函数或者方法中来对它进行使用。 this和Python中的self非常像，但是又不大一样，它使用范围更广，并且自身也代表多重含义。 对于新手来说this可能是非常难迈过的一道坎，因为它的变化实在太多了，但是当你真正理解它后其实不难掌握它变化的规律。 常见this指向情况 全局环境下的this 1）严格模式中，全局环境下this指向为window对象： \"use strict\"; console.log(this); // window 2）非严格模式中，全局环境下this指向为window对象： console.log(this); // window 普通函数的this 1）严格模式中，普通函数下this指向为undefined： \"use strict\"; function show(){ console.log(this); } show(); // undefined 2）非严格模式中，普通函数下this指向为window对象： function show(){ console.log(this); } show(); // window 箭头函数的this 箭头函数没有this，大部分情况下它会继承上层作用域的this。 1）严格模式中，箭头函数下this指向为window，因为它的上层是全局作用域： \"use strict\"; let show = () => { console.log(this); } show(); // window 2）非严格模式中，箭头函数下this指向为window，因为它的上层是全局作用域： let show = () => { console.log(this); } show(); // window 对象中的this 1）严格模式中，对象下this指向当前对象： \"use strict\"; let obj = { show : function(){ console.log(this); } }; obj.show(); // { show: [Function: show] } 2）非严格模式中，对象下this指向当前对象： let obj = { show : function(){ console.log(this); } }; obj.show(); // { show: [Function: show] } 构造函数的this 1）严格模式中，构造函数下this指向构造完成后的实例对象： \"use strict\"; function A(param){ this.param = param; console.log(this); } new A(\"x\"); new A(\"y\"); // A { param: 'x' } // A { param: 'y' } 2）非严格模式中，构造函数下this指向构造完成后的实例对象： function A(param){ this.param = param; console.log(this); } new A(\"x\"); new A(\"y\"); // A { param: 'x' } // A { param: 'y' } 普通方法的this 1）严格模式中，对象的普通方法下this指向当前对象： \"use strict\"; let obj = { show : function(){ console.log(this); } }; obj.show(); // { show: [Function: show] } 2）非严格模式中，对象的普通方法下this指向当前对象： let obj = { show : function(){ console.log(this); } }; obj.show(); // { show: [Function: show] } 箭头方法的this 1）严格模式中，对象的箭头方法下this指向window对象，实际上它是跟随的obj指向，即跟随上层： \"use strict\"; let obj = { show: () => { console.log(this); } }; obj.show(); // window 2）非严格模式中，对象的箭头方法下this指向window对象，实际上它是跟随的obj指向，即跟随上层： let obj = { show: () => { console.log(this); } }; obj.show(); // window 普通闭函数的this 在包函数是个普通函数的情况下，若闭函数是普通函数则可能发生如下情况。 1）严格模式中，普通闭函数的this指向undefied： \"use strict\"; let obj = { show: function () { (function(){ console.log(this); }()) } }; obj.show(); // undefined 2）非严格模式中，普通闭函数的this指向window： let obj = { show: function () { (function(){ console.log(this); }()) } }; obj.show(); // window 箭头闭函数的this 在包函数是个普通函数的情况下，若闭函数是箭头函数则可能发生如下情况。 1）严格模式中，箭头闭函数的this跟随上层包函数的this指向： \"use strict\"; let obj = { show: function () { let inner = () => { console.log(this); } inner(); } }; obj.show(); // { show: [Function: show] } 2）非严格模式中，箭头闭函数的this跟随上层包函数的this指向： let obj = { show: function () { let inner = () => { console.log(this); } inner(); } }; obj.show(); // { show: [Function: show] } 普通事件回调函数的this 1）严格模式中，普通事件回调函数的this指向事件源本身，即元素本身： Document click me \"use strict\"; document.querySelector(\"button\").addEventListener(\"click\", function (event) { console.log(this); // click me }) 2）非严格模式中，普通事件回调函数的this指向事件源本身，即元素本身： Document click me document.querySelector(\"button\").addEventListener(\"click\", function (event) { console.log(this); // click me }) 箭头事件回调函数的this 1）严格模式中，箭头事件回调函数的this指向window对象，实际上它是跟随的addEventListener指向，即跟随上层： Document click me \"use strict\"; document.querySelector(\"button\").addEventListener(\"click\", event => { console.log(this); // window }) 2）非严格模式中，箭头事件回调函数的this指向window对象，实际上它是跟随的addEventListener指向，即跟随上层：： Document click me document.querySelector(\"button\").addEventListener(\"click\", event => { console.log(this); // window }) 若想在箭头事件回调函数中获取事件源本身，可使用event.target属性： Document click me \"use strict\"; document.querySelector(\"button\").addEventListener(\"click\", event => { console.log(event.target); // click me console.log(this); // window }) 根据上下文改变指向 我们谨记一个规律即可，对象下的this永远指向当前对象（特殊情况下除外，如代理器）。 换个简单的说法，我们可以看谁调用了个方法，那么就是谁就是this。 示例1： \"use strict\"; function show(){ console.log(this); } // 等同于 window.show(); 故this为window; 但是严格模式下普通函数的this不能为window，所以是undefined show(); // undefined 示例2： \"use strict\"; let obj = { show(){ console.log(this); } } // obj.show() 那么show中的this就指向obj obj.show(); // { show: [Function: show] } 示例3： \"use strict\"; let obj = { show: () => { console.log(this); } } // 等同于 window.obj.show()，show是箭头函数，跟随上层obj的指向，故指向window obj.show(); // window 示例4： \"use strict\"; let obj = { show: function(){ let inner = function(){ console.log(this); } // 虽然let声明的对象不会存放到window中，但若inner()前面没有任何调用者，则默认还是window // 但是严格模式下普通函数的this不能为window，所以是undefined inner(); } } obj.show(); // undefined 示例5： \"use strict\"; let obj = { show: function(){ let self = this; let inner = function(){ // 向上查找，this为obj对象 self.func(); } inner(); }, func:function(){ // 等同于obj.func() 故结果是obj对象 console.log(this); } } obj.show(); // { show: [Function: show], func: [Function: func] } 示例6： \"use strict\"; function show() { console.log(this); } let obj = { show }; // 等同于 window.show(); 故this为window; 但是严格模式下普通函数的this不能为window，所以是undefined show(); // undefined // obj.show() 那么show中的this就指向obj obj.show(); // { show: [Function: show] } 相信这6个例子看完后，你对this的指向已经了如指掌了。 改变this指向 call() 通过call()方法，让原本函数的this指向发生变化。 thisArg：新的this指向对象 argArray：需要为函数传递的参数 特点：立即执行。 如下示例，通过call()方法改变函数setAttribute()的this指向，让它为obj增添属性： \"use strict\"; function setAttribute(userName, userAge){ this.userName = userName; this.userAge = userAge; } let obj = {} // 将setAttribute的this指向改为obj，达到为obj增添属性的功能 setAttribute.call(obj, \"Jack\", 19); console.log(obj); // { userName: 'Jack', userAge: 19 } apply() apply()方法和call()的特性以及参数都一样，唯一不同的是在为函数传递参数时必须传递数组。 thisArg：新的this指向对象 argArray：需要为函数传递的参数，必须传递数组，内部会进行解构 特点：立即执行。 如下示例，通过apply()方法改变函数setAttribute()的this指向，让它为obj增添属性： \"use strict\"; function setAttribute(userName, userAge){ this.userName = userName; this.userAge = userAge; } let obj = {} // 必须传递数组 setAttribute.apply(obj, [\"Jack\", 19]); console.log(obj); // { userName: 'Jack', userAge: 19 } bind() bind()方法也可以用来改变this指向，不同的是它会返回一个新的函数，也就是说它不是立即执行的。 bind()方法的参数传递有很多种，我们只需要记住一种即可，如下示例： \"use strict\"; function setAttribute(userName, userAge){ this.userName = userName; this.userAge = userAge; } let obj = {} // 返回新函数 // 第一步，告诉需要将this对象改变成谁 let newSetAttribute = setAttribute.bind(obj); // 第二步，调用新函数，参数正常传递即可 newSetAttribute(\"Jack\", 18) console.log(obj); // { userName: 'Jack', userAge: 19 } 它们能做什么 上述介绍的三个方法用处非常大，搭配原型链可做到方法借用。 String本身没有forEach()方法，但是Array却有，我们利用上述3个方法改变this指向做到方法借用： \"use strict\"; let str = \"ABCDEF\" // 借用Array原型对象中的forEach方法，改变this指向为str，并绑定回调即可 Array.prototype.forEach.call(str, (value, index, str) => { console.log(value, index); }); // A 0 // B 1 // C 2 // D 3 // E 4 // F 5 图表总结 以下是常见this指向情况的表总结，针对实在不能理解this指向的同学，下面的情况可以预防90%的情况： 调用环境 window对象 undefined 当前对象或未来返回的实例对象 上层this指向 事件源DOM对象 全局环境 严格/非严格模式：√ 普通函数 非严格模式：√ 严格模式：√ 箭头函数 因为跟随上层this指向，所以这里是√ 严格/非严格模式：√ 对象 严格/非严格模式：√ 构造函数 严格/非严格模式：√ 普通方法 严格/非严格模式：√ 箭头方法 严格/非严格模式：√ 普通闭函数 非严格模式：√ 严格模式：√ 箭头闭函数 严格/非严格模式：√ 普通事件回调函数 严格/非严格模式：√ 箭头事件回调函数 因为跟随上层this指向，所以这里很大概率是√ 严格/非严格模式：√ 若想了解更多，可参照官方文档和阮一峰大神的文章。 官方文档 this指向的原理 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:48 "},"前端专栏/JavaScript/属性特征.html":{"url":"前端专栏/JavaScript/属性特征.html","title":"属性特征","keywords":"","body":"特征介绍 对象下每一个属性都具有一些特征。 我们可以通过设定这些特征来定制该属性是否能被删除、修改、遍历。 常见属性特征如下表所示： 特征 描述 默认值 configurable 是否能使用delete删除属性、是否允许修改属性特征、是否能够修改访问器属性 true enumerable 属性是否可被遍历到 true writable 属性是否可修改 true value 属性的默认值 undefined 查看特征 单一查看 使用Object.getOwnPropertyDescriptor()方法来查看对象下某一属性的特征： \"use strict\"; function Person(userName, userAge) { this.userName = userName; this.userAge = userAge; this.getInfo = function () { return `name : ${this.userName}\\nage : ${this.userAge}`; }; } let ins = new Person(\"Ken\", 18); let userNameFeature = Object.getOwnPropertyDescriptor(ins, \"userName\"); console.log(userNameFeature); // { // value: 'Ken', 值 // writable: true, 可修改 // enumerable: true, 可被遍历 // configurable: true 可配置 // } 查看全部 使用Object.getOwnPropertyDescriptors()方法来查看对象下所有属性的特征： \"use strict\"; function Person(userName, userAge) { this.userName = userName; this.userAge = userAge; this.getInfo = function () { return `name : ${this.userName}\\nage : ${this.userAge}`; }; } let ins = new Person(\"Ken\", 18); let instanceAttributeFeature = Object.getOwnPropertyDescriptors(ins); console.log(instanceAttributeFeature); // { // userName: // { value: 'Ken', // writable: true, // enumerable: true, // configurable: true }, // userAge: // { value: 18, // writable: true, // enumerable: true, // configurable: true }, // getInfo: // { value: [Function], // writable: true, // enumerable: true, // configurable: true } // } 设置特征 单一设置 使用Object.defineProperty()方法来对设置对象下某一属性的特征。 如下所示，userAge属性将变得不能被遍历到、不能被删除、不可再进行特征配置： \"use strict\"; function Person(userName, userAge) { this.userName = userName; this.userAge = userAge; this.getInfo = function () { return `name : ${this.userName}\\nage : ${this.userAge}`; }; Object.defineProperty(this, \"userAge\", { value: 19, // 此处的修改拥有更高的优先级 writeable: false, // 不可修改 enumerable: false, // 不可被遍历 configurable: false, // 不可再进行特征配置，不可删除，不可修改访问属性的设置 }) } let ins = new Person(\"Ken\", 18); // 不可被遍历 console.log(Object.entries(ins)); // [ [ 'userName', 'Ken' ], [ 'getInfo', [Function] ] ] // 不可修改，严格模式下抛出异常 ins.userAge = 20; // 不可删除，严格模式下抛出异常 delete ins.userAge; // 不可再进行特征配置，严格模式下抛出异常 Object.defineProperty(ins, \"userAge\", { configurable: true, }) 设置全部 使用Object.defineProperties()方法来对设置对象下全部属性的特征。 \"use strict\"; function Person(userName, userAge) { this.userName = userName; this.userAge = userAge; this.getInfo = function () { return `name : ${this.userName}\\nage : ${this.userAge}`; }; Object.defineProperties(this, { userName : { value : \"---\" + this.userName + \"---\" // 此处的修改拥有更高的优先级 }, userAge: { value: 19, // 此处的修改拥有更高的优先级 writeable: false, // 不可修改 enumerable: false, // 不可被遍历 configurable: false, // 不可再进行特征配置，不可删除，不可修改访问属性的设置 } }) } let ins = new Person(\"Ken\", 18); // 不可被遍历 console.log(Object.entries(ins)); // [ [ 'userName', '---Ken---' ], [ 'getInfo', [Function] ] ] // 不可修改，严格模式下抛出异常 ins.userAge = 20; // 不可删除，严格模式下抛出异常 delete ins.userAge; // 不可再进行特征配置，严格模式下抛出异常 Object.defineProperty(ins, \"userAge\", { configurable: true, }) 禁止添加 禁止方法 使用Object.preventExtensions()方法来对禁止再向该对象添加新属性。 \"use strict\"; function Person(userName, userAge) { this.userName = userName; this.userAge = userAge; this.getInfo = function () { return `name : ${this.userName}\\nage : ${this.userAge}`; }; // 禁止添加新属性，必须放置最后一行设置 Object.preventExtensions(this); } let ins = new Person(\"Ken\", 18); // 禁止添加新属性！抛出异常 ins.userGender = \"male\"; 判断方法 使用Object.isExtensible()方法来查看是否能向该对象中添加新属性。 \"use strict\"; function Person(userName, userAge) { this.userName = userName; this.userAge = userAge; this.getInfo = function () { return `name : ${this.userName}\\nage : ${this.userAge}`; }; // 禁止添加新属性，必须放置最后一行设置 Object.preventExtensions(this); } let ins = new Person(\"Ken\", 18); console.log(Object.isExtensible(ins)); // false 封闭对象 封闭方法 使用Object.seal()方法来封闭一个对象。 它相当于将configurable设置为false，并且会禁止添加新属性。 所体现的结果为： 不能使用delete删除属性 不能修改属性特征 不能修改访问器属性 不能添加新的属性 但是还可以修改已有属性的值，如下所示： \"use strict\"; function Person(userName, userAge) { this.userName = userName; this.userAge = userAge; this.getInfo = function () { return `name : ${this.userName}\\nage : ${this.userAge}`; }; // 封闭该对象 Object.seal(this); } let ins = new Person(\"Ken\", 18); // 可以修改已有的属性值 ins.userAge = 22; console.log(ins.userAge); // 不能删除已有属性 delete ins.userName; // 不能修改属性特征 Object.defineProperty(ins, \"userName\", { configurable : true, }) // 不能添加新的属性 ins.userGender = \"male\"; 判断方法 使用Object.isSealed()方法来判断一个对象是否已封闭。 \"use strict\"; function Person(userName, userAge) { this.userName = userName; this.userAge = userAge; this.getInfo = function () { return `name : ${this.userName}\\nage : ${this.userAge}`; }; // 封闭该对象 Object.seal(this); } let ins = new Person(\"Ken\", 18); console.log(Object.isSealed()); // true 不可变对象 冻结方法 使用Object.freeze()方法来冻结一个对象。 它相当于将configurable设置为false，并且会禁止添加新属性，禁止修改已有属性。 所体现的结果为： 不能使用delete删除属性 不能修改属性特征 不能修改访问器属性 不能添加新的属性 不能修改已有属性 如下所示： \"use strict\"; function Person(userName, userAge) { this.userName = userName; this.userAge = userAge; this.getInfo = function () { return `name : ${this.userName}\\nage : ${this.userAge}`; }; // 冻结该对象 Object.freeze(this); } let ins = new Person(\"Ken\", 18); // 不能修改已有的属性值 ins.userAge = 22; // 不能删除已有属性 delete ins.userName; // 不能修改属性特征 Object.defineProperty(ins, \"userName\", { configurable : true, }) // 不能添加新的属性 ins.userGender = \"male\"; 判断方法 使用Object.isFrozen()方法来判断一个对象是否已冻结。 \"use strict\"; function Person(userName, userAge) { this.userName = userName; this.userAge = userAge; this.getInfo = function () { return `name : ${this.userName}\\nage : ${this.userAge}`; }; // 冻结该对象 Object.freeze(this); } let ins = new Person(\"Ken\", 18); console.log(Object.isFrozen(ins)); // true Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:48 "},"前端专栏/JavaScript/属性代理.html":{"url":"前端专栏/JavaScript/属性代理.html","title":"属性代理","keywords":"","body":"属性代理 Getter/Setter Getter/Setter是JavaScript中用于提供属性代理的语法： Getter规定获取某属性时的运行逻辑 Setter规定设置某属性时的运行逻辑 注意！属性必须在普通属性和代理属性中二选一，同名属性无法同时设置为普通属性和代理属性。 如下示例，我们将实例属性userAge进行封装，并为其配置属性代理器set和get。 在设置时新的userAge值时类型必须是number，在获取时总是返回一个年龄段而不返回具体年龄： \"use strict\"; function Person(userName, userAge) { return { userName, __userData: { userAge, }, set userAge(value) { // value就是新设定的值，这里规定它必须是number类型且小于等于100岁大于0岁 if (typeof value === \"number\" && (value 0)) { // 这里一定要将被代理属性进行封装。因为 // this.userAge = value 或 this[\"userAge\"] // 都将会引发无限递归，因此，属性必须在普通属性和代理属性中二选一 this.__userData.userAge = value; return } throw new Error(\"error! type or age range error\"); }, get userAge() { let age = this.__userData.userAge; switch (true) { case age 静态方法 使用get实现一个伪属性，即不存在的属性，它实际上是一个方法，但是不加括号就可以自动运行。 如下示例，获取书籍总价格： \"use strict\"; let bookShop = { bookList: [ { book_name: \"JavaScript\", price: 99 }, { book_name: \"CSS3\", price: 80 }, { book_name: \"HTML5\", price: 72 }, ], get total() { return this.bookList.reduce((prev, cur, index, array) => { return prev + cur.price; }, 0) } }; console.log(bookShop.total); // 251 描述符代理 更推荐使用描述符进行代理，做到代理属性与普通属性的分离。 利用Object.defineProperties()方法完成： \"use strict\"; function Person(userName, userAge) { this.__userData = { userAge, userName }; Object.defineProperties(this, { userName: { set(value) { console.log(\"run set userName()\"); // 描述符代理中的this指向被代理对象 this.__userData.userName = value; }, get() { console.log(\"run get userName()\"); return this.__userData.userName } }, userAge: { set(value) { console.log(\"run set userAge()\"); this.__userData.userAge = value; }, get() { console.log(\"run get userAge()\"); return this.__userData.userAge } }, }) } // 这里不会触发代理 let ins = new Person(\"Jack\", 32); console.log(ins.userName); console.log(ins.userAge); ins.userName = \"Tom\"; ins.userAge = 18; // run get userName() // Jack // run get userAge() // 32 // run set userName() // run set userAge() 对象代理 Proxy Getter/Setter是对对象内部属性代理，一次只能设置一个。 而通过Proxy可直接为对象进行代理，如下所示： 注意！Proxy的set()方法应该返回一个布尔值，否则将会抛出异常： \"use strict\"; function Person(userName, userAge) { this.userName = userName; this.userAge = userAge; } let ins = new Person(\"Jack\", 32); // 实例化代理 const insProxy = new Proxy(ins, { get(obj, attribute) { console.log(\"run Proxy get()\"); // 不能使用.语法进行设置，因为attribute是一个String类型 return obj[attribute]; }, set(obj, attribute, value) { // set方法必须返回布尔值 console.log(\"run Proxy set()\"); try { obj[attribute] = value; return true } catch (e) { console.error(e); return false } } }); // 访问任何属性，都会触发代理 console.log(insProxy.userName); console.log(insProxy.userAge); insProxy.userName = \"Tom\"; insProxy.userAge = 18; // run Proxy get() // Jack // run Proxy get() // 32 // run Proxy set() // run Proxy set() 函数代理 Proxy还可以作为函数代理进行使用，当作为函数代理时会执行Proxy中所定义的apply()方法。 该方法包含3个参数： 被代理函数本身 上下文对象 参数 如下所示，使用函数代理统计某函数运行时长，实现类似于装饰器的功能： \"use strict\"; function factorial(num) { return num == 1 ? 1 : num * factorial(num - 1); } let proxy = new Proxy(factorial, { apply(func, obj, args) { // 添加运行时间计算的功能 console.time(\"run\"); func.apply(obj, args); console.timeEnd(\"run\"); } }); proxy.apply(this, [1, 2, 3]); // 参数传递必须是数组。 // run: 0.198ms 实用案例 双向绑定 以下是通过属性代理实现Vue等前端框架数据绑定的特性： Document \"use strict\"; function View(obj) { this.obj = obj; this.init = function () { this.obj.el = document.querySelector(this.obj.el); this.obj.el.querySelectorAll(\"[v-model]\").forEach(element => { element.addEventListener(\"keyup\", (event) => { let bind = event.target.getAttribute(\"v-model\"); let value = event.target.value; // 触发代理 this.proxy[bind] = value; // 测试 console.log(bind, \"=>\", this.obj.data[bind]); }); }); }; this.proxy = new Proxy(this.obj, { set(obj, attribute, value) { obj.data[attribute] = value; obj.el.querySelectorAll(`[v-model=${attribute}]`).forEach(element => { element.innerHTML = value; element.value = value; }) return true; } }); this.init(); } let app = new View({ el: \"#app\", data: { username: null, password: null, } }); 表单验证 使用代理来进行表单验证，验证规则写在标签属性中。 Document body { padding: 50px; background: #34495e; } input { border: solid 10px #ddd; height: 30px; } .error { border: solid 10px red; } \"use strict\"; //验证处理类 class Validate { max(value, len) { return value.length = len; } isNumber(value) { return /^\\d+$/.test(value); } } //代理工厂 function makeProxy(target) { return new Proxy(target, { get(target, key) { return target[key]; }, set(target, key, el) { const rule = el.getAttribute(\"rule\"); const validate = new Validate(); let state = rule.split(\",\").every(rule => { const info = rule.split(\":\"); return validate[info[0]](el.value, info[1]); }); el.classList[state ? \"remove\" : \"add\"](\"error\"); return true; } }); } const nodes = makeProxy(document.querySelectorAll(\"[validate]\")); nodes.forEach((item, i) => { item.addEventListener(\"keyup\", function () { nodes[i] = this; }); }); Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:48 "},"前端专栏/JavaScript/原型继承.html":{"url":"前端专栏/JavaScript/原型继承.html","title":"原型继承","keywords":"","body":"原型介绍 原型是什么 JavaScript中每个对象都有一个prototype原型对象，原型即是一个指向对象的指针。 我们知道OOP语言中有一个继承的概念，JavaScript不同于其他语言，它不是基于类的继承，而是基于原型的继承。 我们以构造函数举例： 构造函数的prototype属性即指向自己的原型对象，它的作用是为构造函数所创建出的实例对象提供公有方法和属性，且这些方法和属性是允许被继承的 实例对象的__proto__属性指向自己将要使用的原型对象 在每个构造函数的原型对象中，都有一个constructor键，它指向构造函数本身。 每个构造函数在生成时，都将会有一个默认继承了Object原型的原型对象。 如下图所示： 代码示例： \"use strict\"; function Person(userName){ this.userName = userName; } let ins = new Person(\"Jack\"); console.log(Person.prototype === ins.__proto__); console.log(ins.__proto__.__proto__ === Object.prototype); console.log(ins.__proto__.__proto__.constructor === Object); // true // true // true 获取原型对象 构造函数要获取自身的原型对象，使用属性prototype即可。 实例对象要获取原型链上第一个对象，使用属性__proto__或者Object.getPrototypeOf()方法即可。 \"use strict\"; function Person(userName){ this.userName = userName; } let ins = new Person(\"Jack\"); console.log(Person.prototype); console.log(ins.__proto__); console.log(Object.getPrototypeOf(ins)); // {constructor: ƒ} // {constructor: ƒ} // {constructor: ƒ} 一切皆对象 构造函数本身也是一个对象，因为JavaScript中一切皆对象。 构造函数所指向的原型对象是空函数，调用它将返回undefined： \"use strict\"; function Person(userName){ this.userName = userName; } let ins = new Person(\"Jack\"); console.log(Person.__proto__); // ƒ () { [native code] } 构造函数的prototype属性指向自身的原型对象，该原型对象会提供给其实例所调用的方法，如下示例： \"use strict\"; function Person(userName) { this.userName = userName; } // 为原型对象中新增一个方法show() Person.prototype.show = function(){ console.log(this); } let ins = new Person(\"Jack\"); ins.show(); // Person { userName: 'Jack' } 在原型中定义的方法是允许被继承的，在构造函数中所定义的方法是不允许继承的，接下来的继承章节中会专门指出两者之间的差距。 更改原型对象 更改原型对象的方式有很多种。 1）局部修改，添加新方法，在已有原型对象基础上进行改变。 它将影响所有其实例对象： \"use strict\"; function Person(userName) { this.userName = userName; } // 为原型对象中新增一个方法show() Person.prototype.show = function(){ console.log(this); } let ins = new Person(\"Jack\"); ins.show(); // Person { userName: 'Jack' } 2）全局修改，直接将构造函数的原型对象修改为新的一个原型对象。 它将影响所有其实例对象： \"use strict\"; function Person(userName) { this.userName = userName; } // 为原型对象中新增一个方法show() Person.prototype = { // 必须指定构造函数 constructor: Person, show() { console.log(this); } } let ins = new Person(\"Jack\"); ins.show(); // Person { userName: 'Jack' } 3）通过Object.setPrototypeOf()方法，将某个对象所使用的原型对象替换为另一个原型对象。 它将影响当前对象。 \"use strict\"; function Person(userName) { this.userName = userName; } let ins = new Person(\"Jack\"); // 更改ins所使用的原型对象 Object.setPrototypeOf(ins, { show() { console.log(this); } }) ins.show(); // 可以看到ins所使用的原型对象是不合格的，它没有constructor属性指向一个构造函数 console.log(ins.__proto__); // Person { userName: 'Jack' } // {show: ƒ} 原型链检测 instanceof运算符用于检测构造函数的prototype属性是否出现在某个实例对象的原型链上。 isPrototypeOf()方法用于测试一个对象是否存在于另一个对象的原型链上。 \"use strict\"; function Person(userName) { this.userName = userName; } let ins = new Person(\"Jack\"); // ins实例的原型链上是否包含Person的原型对象? 结果是true console.log(ins instanceof Person); // ins实例的原型链上是否包含Object的原型对象? 结果是true console.log(ins instanceof Object); // Person的原型对象是否在ins的原型链上出现过？结果是true console.log(Person.prototype.isPrototypeOf(ins)); // Object的原型对象是否在ins的原型链上出现过？结果是true console.log(Object.prototype.isPrototypeOf(ins)); // true // true // true // true 下面是instanceof的原理，其实就是不断的递归原型链并检测对象： function checkPrototype(obj, constructor) { if (!obj.__proto__) return false; if (obj.__proto__ == constructor.prototype) return true; return checkPrototype(obj.__proto__, constructor); } 使用hasOwnProperty()方法只检测对象自身所包含的属性或方法。 它不会检测原型链上继承而来的属性或方法，返回一个布尔值： \"use strict\"; // 创建原型对象 let prototypeObject = { k1: \"v1\" } // 创建对象 let A = { k2: \"v2\" }; // 修改A所使用的的原型对象 A.__proto__ = prototypeObject; console.log(A.hasOwnProperty(\"k1\")); console.log(A.hasOwnProperty(\"k2\")); // false // true 使用in检测当前对象是否能够调用某个属性或方法。 它会检测原型链上继承来的属性或方法，返回一个布尔值： \"use strict\"; // 创建原型对象 let prototypeObject = { k1: \"v1\" } // 创建对象 let A = { k2: \"v2\" }; // 修改A所使用的的原型对象 A.__proto__ = prototypeObject; console.log(\"k1\" in A); console.log(\"k2\" in A); console.log(\"k3\" in A); // false // true // false 属性遍历 for/in会按照原型链进行遍历，先遍历自身属性，然后遍历原型链： \"use strict\"; // 创建原型对象1,2,3 let prototypeObject_01 = { \"k1\": \"v1\" }; let prototypeObject_02 = { \"k2\": \"v2\", __proto__: prototypeObject_01 }; let prototypeObject_03 = { \"k3\": \"v3\", __proto__: prototypeObject_02 }; // 创建对象 let A = { \"k4\": \"v4\" } // 修改A所使用的的原型对象 A.__proto__ = prototypeObject_03; // 开始遍历 for (let k in A) { console.log(k); } // k4 // k3 // k2 // k1 原型借用 通过call()、apply()、bind()方法修改this指向，达到方法借用的目的。 String本身没有forEach()方法，但是Array却有，我们利用上述3个方法改变this指向做到方法借用： \"use strict\"; let str = \"ABCDEF\" // 借用Array原型对象中的forEach方法，改变this指向为str，并绑定回调即可 Array.prototype.forEach.call(str, (value, index, str) => { console.log(value, index); }); // A 0 // B 1 // C 2 // D 3 // E 4 // F 5 Object.create() 该方法用于创建对象。 参数1：指定该对象所使用的原型对象 参数2：该对象的具体内容，包含方法、属性等，以属性特征形式进行创建 若不填写参数2，则直接创建一个指定参数1原型的空对象 如下示例： \"use strict\"; // 创建无原型的对象 let no_prototype_obj = Object.create(null, { // 创建属性、方法 userName: { // 创建userName属性特征 value: \"Jack\", }, show: { // 创建show属性特征 value: function () { console.log(this.userName); } } }); no_prototype_obj.show(); console.log(no_prototype_obj.__proto__); // Jack // undefined // 创建有原型的对象，该对象指向Array的原型 let obj = Object.create(Array.prototype, { k1: { value: \" v1\", }, k2: { value: \" v2\", } }); console.log(obj); // Array {k1: \" v1\", k2: \" v2\"} 继承与多态 原型继承 JavaScript的继承是原型继承，且只有单继承没有多继承。 当一个对象要使用某个属性、方法时会先找自己，然后会不断的使用__proto__属性开始原型链查找。 我们可以对使用Object.setPrototypeOf()方法或者设置原型对象的__proto__属性达到原型继承的目的。 如下所示： \"use strict\"; // 3个构造函数 function A() { }; function B() { }; function C() { }; // 设置原型方法 A.prototype.f1 = function () { console.log(\"run A.prototype.f1()\"); }; B.prototype.f2 = function () { console.log(\"run B.prototype.f1()\"); }; C.prototype.f3 = function () { console.log(\"run C.prototype.f1()\"); }; // 原型继承 // B原型继承A原型 // Object.setPrototypeOf(B.prototype, A.prototype); // C原型继承B原型 // Object.setPrototypeOf(C.prototype, B.prototype); // 效果同上 // B原型继承A原型 B.prototype.__proto__ = A.prototype; // C原型继承B原型 C.prototype.__proto__ = B.prototype; // 创建实例 let ins = new C(); ins.f3(); ins.f2(); ins.f1(); // run C.prototype.f1() // run B.prototype.f1() // run A.prototype.f1() 图示如下： 方法覆写 由于查找顺序是由下而上，所以我们在最近的原型对象中写入同名方法就不会继续向上查找了。 \"use strict\"; // 3个构造函数 function A() { }; function B() { }; function C() { }; // 设置原型方法 A.prototype.show = function () { console.log(\"run A.prototype.show()\"); }; B.prototype.show = function () { console.log(\"run B.prototype.show()\"); }; // 原型继承 // B原型继承A原型 // Object.setPrototypeOf(B.prototype, A.prototype); // C原型继承B原型 // Object.setPrototypeOf(C.prototype, B.prototype); // 效果同上 // B原型继承A原型 B.prototype.__proto__ = A.prototype; // C原型继承B原型 C.prototype.__proto__ = B.prototype; // 创建实例 let ins = new C(); ins.show(); // run B.prototype.show() 为何要将方法写入原型中 我们也可以不把方法写入原型对象中，这样的方法是不能被继承的，但是其直属实例对象依旧可以调用： \"use strict\"; function A() { this.show = function () { console.log(\"A.constructor.show()\"); } } let ins = new A(); ins.show(); // A.constructor.show() 如下，构造函数B不能继承A的show()方法了： \"use strict\"; function A() { this.show = function () { console.log(\"A.constructor.show()\"); } } function B(){ } // 下面的方法都不行 // B.prototype.__proto__ = A.prototype; // B.prototype.__proto__ = A; let ins = new B(); ins.show(); // TypeError: ins.show is not a function // A.constructor.show() 如果你的构造函数和构造函数的原型对象中具有同名方法，那么会优先使用构造函数中的方法： \"use strict\"; // 3个构造函数 function A() { }; function B() { }; function C() { this.show = function(){console.log(\"run C.constructor.show()\");}}; // 设置原型方法 A.prototype.show = function () { console.log(\"run A.prototype.show()\"); }; B.prototype.show = function () { console.log(\"run B.prototype.show()\"); }; C.prototype.show = function () { console.log(\"run C.prototype.show()\"); }; // 原型继承 // B原型继承A原型 // Object.setPrototypeOf(B.prototype, A.prototype); // C原型继承B原型 // Object.setPrototypeOf(C.prototype, B.prototype); // 效果同上 // B原型继承A原型 B.prototype.__proto__ = A.prototype; // C原型继承B原型 C.prototype.__proto__ = B.prototype; // 创建实例 let ins = new C(); ins.show(); // run C.constructor.show() 多态体现 多态是指不同对象调用同一个方法但是会产生不同的结果。 JavaScript天生支持多态，如下所示： \"use strict\"; function User() { }; function Admin() { }; function Member() { }; function Enterprise() { }; // 开始继承 Admin.prototype.__proto__ = User.prototype; Member.prototype.__proto__ = User.prototype; Enterprise.prototype.__proto__ = User.prototype; // 添加原型方法 User.prototype.show = function () { return this.description() }; Admin.prototype.description = function () { return \"管理员\" }; Member.prototype.description = function () { return \"会员\" }; Enterprise.prototype.description = function () { return \"公司账户\" }; // 不同的对象都来调用description()方法，得到的结果都不一样 for (const ins of [new Admin(), new Member(), new Enterprise()]) { console.log(ins.show()); } // 管理员 // 会员 // 公司账户 深究继承 构造函数 如果多个构造函数在功能上极其相似，我们希望进行复用代码则可以利用其它函数来进行函数的构建。 如下所示： \"use strict\"; function basePerson(userName, userGender) { // 普通函数 // 注意！此时this指向undefined this.userName = userName; this.userGender = userGender; } basePerson.prototype.show = function () { return `name : ${this.userName}\\ngender : ${this.userGender}` } // 构造函数 function Man(userName) { // 构造函数this指向未来创建的实例对象，所以使用call来改变basePerson函数的this指向 basePerson.call(this, userName, \"male\"); } function Woman(userName) { // 构造函数this指向未来创建的实例对象，所以使用call来改变basePerson函数的this指向 basePerson.call(this, userName, \"female\"); } // 原型继承，让Man和Woman的原型都继承至basePerson的原型 Object.setPrototypeOf(Man.prototype, basePerson.prototype); Object.setPrototypeOf(Woman.prototype, basePerson.prototype); let j = new Man(\"Jack\"); let m = new Woman(\"Mary\"); console.log(j.show()); console.log(m.show()); // name : Jack // gender : male // name : Mary // gender : female 原型工厂 Object.setPrototypeOf()方法太长了，不好记，我们可以对Object.setPrototypeOf()方法进行封装，实现原型工厂： \"use strict\"; // 原型工厂 function inherit(child, parent) { // 亦可使用： // child.prototype.__proto__ = parent.prototype; Object.setPrototypeOf(child.prototype, parent.prototype); } // 创建构造函数 function A(){}; function B(){}; A.prototype.show = function(){console.log(\"run A.prototype.show()\");}; // B继承A inherit(B, A) let ins = new B(); ins.show(); // run A.prototype.show() 对象工厂 让构造函数复用和原型工厂结合，实现对象工厂： \"use strict\"; function User(name, age) { this.name = name; this.age = age; } User.prototype.show = function () { console.log(this.name, this.age); }; function Admin(name, age) { // 创建了一个新对象，该对象所使用原型指向User的原型对象 let instance = Object.create(User.prototype, {}); User.call(instance, name, age); instance.role = function () { console.log('admin.role'); } return instance; } let ins = Admin(\"管理员\", 19); ins.show(); // 管理员 19 MixIn机制 由于Js不支持多继承，所以想添加功能必须在某一个原型对象上不断的增加功能，这势必会让其本来的原型显得混乱不堪。 这种时候就可以使用Mixin机制来实现。 注意：Minin类应该当做工具箱来使用，而不应该作为其他类的父类被继承下来 super super属性用于在原型链上找某个属性，它智能在对象内部使用，如下示例： \"use strict\"; // 原型对象 let a = { username: \"云崖\" }; // 普通对象 let b = { __proto__: a, show() { console.log(super.username); // super会去找__proto__，相当于拿到a.username }, }; b.show(); // 云崖 本章总结 你只要捋清楚，构造函数、原型对象、实例对象之间的关系即可。 举个例子： 构造函数：爸爸 原型对象：爸爸的背包 实例对象：儿子 零食：方法或者属性 儿子要吃零食，肯定先找爸爸，爸爸身上没有就让儿子去背包里面翻，儿子如果在爸爸背包里面没翻到就会去爷爷的背包里面翻。 每个背包都有一张字体，指向这个背包的主人（constructor键）。 为什么要把零食放在背包？而不是放在人身上呢？因为如果你放在身上你的子孙后代就拿不到这包零食，但如果你放在背包里你的子孙后代就能拿到这包零食了。这就是JavaScript的原型继承本质了。 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:48 "},"前端专栏/JavaScript/class语法糖.html":{"url":"前端专栏/JavaScript/class语法糖.html","title":"class语法糖","keywords":"","body":"class 基本介绍 严格来说，JavaScript中是没有类这一个概念的。 ES6之前，我们可以通过构造函数模拟出其他语言中的类。 ES6之后，JavaScript引入了关键词class，使用它来书写面向对象的程序比用构造函数来书写面向对象的程序更加直观也更加方便。 class仅作为语法糖参与代码编写，它不是其他语言中你所认为的类，它归根结底其实还是函数。 使用class语法糖定义类，其书写的方法会全部写入到原型对象中，这个非常方便 class语法糖中书写的方法是不会被for/in遍历出来的，但是构造函数的书写方法for/in是能遍历出方法的 class代码块中默认使用严格模式进行代码执行 简单使用 使用class来定义类，命名应采用大驼峰式风格。 此外你还需要在类中书写constructor()构造方法，以接收实例对象时外部所传递的值。 类中的方法不必加上function前缀且会自动写入原型对象中，也不用使用逗号进行分割。 如下示例： \"use strict\"; class Person { constructor(userName, userAge, userGender) { this.userName = userName; this.userAge = userAge; this.userGender = userGender; } getInfo() { return `name : ${this.userName}\\nage : ${this.userAge}\\ngender : ${this.userGender}` } } let ins = new Person(\"Jack\", 18, \"male\"); console.log(ins); // Person { userName: 'Jack', userAge: 18, userGender: 'male' } 构造方法 constructor()构造方法不是必须要写的，只有当你需要为实例对象传递参数时才需要写上他。 即使你不写它系统内部也会通过super在原型链上找到该方法并执行。 相当于下面这条代码： constructor(...args){ super(...args); } 遍历差异 class中书写的方法是不会被遍历出来的，而构造函数的原型对象中书写的方法却可以被遍历出来。 这也是2者之间比较大的一个差异： \"use strict\"; class Person { constructor(userName, userAge, userGender) { this.userName = userName; this.userAge = userAge; this.userGender = userGender; } getInfo() { return `name : ${this.userName}\\nage : ${this.userAge}\\ngender : ${this.userGender}` } } let ins = new Person(\"Jack\", 18, \"male\"); for(let attr in ins){ console.log(ins[attr]); } // Jack // 18 // male 严格模式 class中书写的代码默认使用strict严格模式进行执行： class A { show() { (function () { console.log(this); }()) // 严格模式，闭函数指向undefined } } let ins = new A(); ins.show(); 原理剖析 JavaScript中没有类，所以class归根结底还是函数。 如下，这是class语法编写的类，获取它的类型结果为function： \"use strict\"; class Person { constructor(userName, userAge, userGender) { this.userName = userName; this.userAge = userAge; this.userGender = userGender; } getInfo() { return `name : ${this.userName}\\nage : ${this.userAge}\\ngender : ${this.userGender}` } } console.log(typeof Person); // function 上面这个定义与下面的构造函数定义相同： \"use strict\"; function Person(userName, userAge, userGender) { this.userName = userName; this.userAge = userAge; this.userGender = userGender; } Person.prototype.getInfo = function () { \"use strict\"; return `name : ${this.userName}\\nage : ${this.userAge}\\ngender : ${this.userGender}` }; Object.defineProperties(Person.prototype, { getInfo:{ enumerable: false, // 不可被遍历 } }); let ins = new Person(\"Jack\", 18, \"male\"); for(let attr in ins){ console.log(ins[attr]); } // Jack // 18 // male 两者一对比就会发现，class语法糖确实比构造函数+原型对象设置的方式书写代码要好很多。 类成员 类属性 类属性在JavaScript中其实应该称作静态属性，它不是为实例对象提供的而是为类本身提供的。 使用static进行声明即可： \"use strict\"; class Person { // 如果不加static，则会变成实例属性 static desc = \"Humanity\"; constructor(userName, userAge, userGender) { this.userName = userName; this.userAge = userAge; this.userGender = userGender; } getInfo() { return `name : ${this.userName}\\nage : ${this.userAge}\\ngender : ${this.userGender}` } } console.log(Person.desc); // Humanity 实现原理： \"use strict\"; function Person(userName, userAge, userGender) { this.userName = userName; this.userAge = userAge; this.userGender = userGender; } Person.desc = \"Humanity\" // ... console.log(Person.desc); 类方法 类方法和类属性都差不多，同样使用static进行声明： \"use strict\"; class Person { // 如果不加static，则会变成实例属性 static desc = \"Humanity\"; static help(){ return \"This is about class Person help information\" } constructor(userName, userAge, userGender) { this.userName = userName; this.userAge = userAge; this.userGender = userGender; } getInfo() { return `name : ${this.userName}\\nage : ${this.userAge}\\ngender : ${this.userGender}` } } console.log(Person.help()); // This is about class Person help information 实现原理： \"use strict\"; function Person(userName, userAge, userGender) { this.userName = userName; this.userAge = userAge; this.userGender = userGender; } Person.desc = \"Humanity\" Person.help = function () { return \"This is about class Person help information\" } // ... console.log(Person.help()); // This is about class Person help information 属性代理 Getter/Setter 使用get和set关键字定义用户在访问某一属性、设置某一属性时做的操作。 如下示例，我们将实例属性userAge进行封装，并为其配置属性代理器set和get。 在设置时新的userAge值时类型必须是number，在获取时总是返回一个年龄段而不返回具体年龄： \"use strict\"; class Person { // 定义绝对私有属性 #userAge; constructor(userName, userAge, userGender) { this.userName = userName; // 绝对私有，不允许外部访问或继承 this.#userAge = userAge; this.userGender = userGender; } set userAge(value) { if (typeof value === \"number\" && (value 0)) { this.#userAge = value; return } throw new Error(\"error! type or age range error\"); } get userAge() { let age = this.#userAge; switch (true) { case age 静态属性 BMI指数是用来衡量一个人的体重与身高对健康影响的一个指标，计算公式为： BMI指数计算公式: BMI = 体重(kg) / (身高m**2) BMI正常值在20至25之间，超过25为超重，30以上则属肥胖 身高或体重是不断变化的，因而每次想查看BMI值都需要通过计算才能得到，但很明显BMI听起来更像是一个特征而非功能。 所以我们可以利用get关键字来定义一个伪属性，它其实是一个方法： \"use strict\"; class Person { constructor(userName, userHight, userWeight) { this.userName = userName; this.userHight = userHight; this.userWeight = userWeight; } get bmi() { let v = this.userWeight / (this.userHight ** 2); switch (true) { case 20 25: return \"overweight\" default: return \"obesity\" } } } // 这里不会触发代理 let ins = new Person(\"Jack\", 1.75, 77); // 触发get console.log(ins.bmi); // normal 私有公有 public public指不受保护的、公开的属性。类的内部或外部及其子类均可访问或者修改该属性。 默认所有的属性都是public： class Person { constructor(name, age, gender) { this.name = name; this.age = age; this.gender = gender; } getInfo() { // ❶ 类的内部可以进行访问，也可以进行修改 return `name : ${this.name}\\nage : ${this.age}\\ngender : ${this.gender}` } setAge(age) { this.age = age; } } let person = new Person(\"Jack\", 18, \"male\"); // ❷ 类的外部也可以进行访问和修改 console.log(person.getInfo()); person.setAge(22); person.name = \"--Jack--\"; console.log(person.name); // ❸ 被继承的子类中也可以进行访问和修改 class Child extends Person { constructor(name, age, gender) { super(name, age, gender) this.name = \"Mary\"; // 可以修改 } } let child = new Child(\"Tom\", 12, \"male\"); console.log(child.getInfo()); private private指受保护的、私有的属性。仅能在当前类的内部访问或修改，外部的访问和修改是做不到的，但可通过类内部暴露的接口方法进行访问。 private属性经常与属性代理一起使用，使用#关键字定义私有属性即可： class Person { // 必须先声明私有属性 // 方法没有私有的一说，它们都是存在原型链上的，故不用声明 #name; #age; #gender; constructor(name, age, gender) { this.#name = name; this.#age = age; this.#gender = gender; } getInfo() { // ❶ 类的内部可以进行访问，也可以进行修改 return `name : ${this.#name}\\nage : ${this.#age}\\ngender : ${this.#gender}` } setAge(age) { this.age = age; } } let person = new Person(\"Jack\", 18, \"male\"); // ❷ 类的外部仅能通过类内部暴露的接口方法访问，直接访问是访问不到的 console.log(person.getInfo()); person.setAge(22); // person.#name = \"--Jack--\"; // console.log(person.#name); // ❸ 被继承的子类中不能进行访问和修改，但可以通过类内部暴露的接口方法进行访问和修改 class Child extends Person { constructor(name, age, gender) { super(name, age, gender) // this.#name = \"Mary\"; // 不可以修改 抛出异常！ } } let child = new Child(\"Tom\", 12, \"male\"); console.log(child.getInfo()); child.setAge(10); protected protected是指受保护的，半私有的属性。仅能在类的内部访问和修改，外部的访问和修改是做不到的，但它允许在子类中进行访问和修改。 下面介绍三种半私有封装方式。 下划线封装法 这是一种君子约定的封装法，使用单下划线进行封装。 它其实并不会有任何强制性措施，只是告诉使用者，请不要在外部使用该属性。 它仅作为提示功能，就像吸烟时烟盒上出现的吸烟有害健康，但还是可以抽： \"use strict\"; class Person { constructor(userName, userAge, userGender) { this.userName = userName; this._userAge = userAge; this._userGender = userGender; } getInfo() { return `name : ${this.userName}\\nage : ${this._userAge}\\ngender : ${this._userGender}` } } let ins = new Person(\"Jack\", 18, \"male\"); // 外部依然可以访问，君子约定而已 console.log(ins._userAge); console.log(ins._userGender); // 18 // male Symobl封装法 由于我们的代码都是在一个模块中进行封装的，所以使用Symbol()来进行私有封装非常的方便。 除非使用者打开源代码找到Symbol键，否则他只能通过提供的类内部暴露的接口方法来拿到数据。 \"use strict\"; let userAgeKey = Symbol(\"user userAge key\"); let userGenderKey = Symbol(\"user gender key\"); class Person { constructor(userName, userAge, userGender) { this.userName = userName; this[userAgeKey] = { userAge }; this[userGenderKey] = { userGender }; } getInfo() { // 仅能内部访问 return `name : ${this.userName}\\nage : ${this[userAgeKey].userAge}\\ngender : ${this[userGenderKey].userGender}` } } let ins = new Person(\"Jack\", 18, \"male\"); console.log(ins.getInfo()); // 外部若想访问，只能扒源码来找Symbol键 console.log(ins[userGenderKey].userGender); // name : Jack // age : 18 // gender : male // male WeakMap封装法 WeakMap有弱引用的特性，所以我们可以利用WeakMap来做私有封装。 它和Symbol封装法一样，使用者若想在外部访问被封装的实例变量，只能扒源码来找WeakMap容器： \"use strict\"; let wMap = new WeakMap(); class Person { constructor(userName, userAge, userGender) { this.userName = userName; wMap.set(this, { userAge, userGender, }) } getInfo() { // 仅能内部访问 return `name : ${this.userName}\\nage : ${wMap.get(this).userAge}\\ngender : ${wMap.get(this).userGender}` } } let ins = new Person(\"Jack\", 18, \"male\"); console.log(ins.getInfo()); // 外部若想访问，只能扒源码来找wMap容器 console.log(wMap.get(ins).userGender); // name : Jack // age : 18 // gender : male // male 类的继承 extends class通过extends关键字进行原型继承，JavaScript中只支持单继承不支持多继承。 注意，如果子类中有构造方法，那么一定要使用super()方法来调用父类的构造方法，否则将会抛出异常。 1）错误示例： \"use strict\"; class A { constructor(param) { this.param = param; } } class B extends A { // 未使用super调用父类构造方法，抛出异常 constructor(param) { this.param = param } } let ins = new B(\"x\"); console.log(ins); // ReferenceError: Must call super constructor in derived class before accessing 'this' or returning from derived constructor 2）正确示例： \"use strict\"; class A { constructor(param) { this.param = param; } } class B extends A { constructor(param) { super(param); } } let ins = new B(\"x\"); console.log(ins); // B {param: \"x\"} 3）或者你也可以不为super()方法传参： \"use strict\"; class A { show() { console.log(\"run show...\"); } } class B extends A { constructor(param) { super(); this.param = param; } } let ins = new B(\"x\"); console.log(ins); // B {param: \"x\"} 内部原理如下： \"use strict\"; function A() { }; A.prototype.show = function () { console.log(\"run show...\"); } function B(param) { A.call(this); this.param = param; } let ins = new B(\"x\"); console.log(ins); // B {param: \"x\"} super() super表示从当前原型中执行方法。 super一直指向当前对象 在构造方法中，super()一定要放在this声明的前面 super只能在类或对象的方法中使用，而不能在函数中使用，也就是说你应当使用ES6的简写语法表示该函数是一个方法，而不是利用函数关键字function进行声明 1）正确的super使用案例： \"use strict\"; class A { show() { console.log(\"run show...\"); } } class B extends A { constructor(param) { // 在构造方法中，super()一定要放在this声明的前面 super(); this.param = param; } run() { // super只能在类或对象的方法中使用，而不能在函数中使用 return super.show(); } } let ins = new B(\"x\"); ins.run(); // run show... 2）其他的super使用案例： \"use strict\"; let obj_1 = { show() { console.log(\"run show...\"); } }; let obj_2 = { __proto__: obj_1, // 由于run采用简写形式，故可以使用super run() { return super.show(); } } obj_2.run(); // run show... 3）失败的使用案例： \"use strict\"; let obj_1 = { show() { console.log(\"run show...\"); } }; let obj_2 = { __proto__: obj_1, // 出现问题，利用function定义了该方法就不能使用super run: function () { return super.show(); } } obj_2.run(); // SyntaxError: 'super' keyword unexpected here 继承类成员 extends关键字也可以继承类成员： \"use strict\"; class A { // 定义类属性 static desc = \"class A\"; } class B extends A{} console.log(B.desc); // class A Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:48 "},"前端专栏/JavaScript/JSON.html":{"url":"前端专栏/JavaScript/JSON.html","title":"JSON","keywords":"","body":"基本介绍 JSON格式是目前最火热的跨语言交互格式，它十分利于人的阅读和编写。 使用JSON数据格式是替换XML最佳方式，主流语言都很好的支持JSON格式。 JSON标准中要求使用双引号包裹属性，虽然有些语言不强制，但使用双引号可避免多程序间传输发生错误语言错误的发生。 序列化 序列化是指将数据转换为JSON字符串，一般是当前语言向其他语言传递信息时使用。 JavaScript中JSON序列化方法为JSON.stringify()。 参数释义： value：序列化的对象 replacer：指定保存的属性，如果为null则代表所有 space：格式化后对table空格的定义，默认是4空格 代码示例： \"use strict\"; let obj = { username: \"Jack\", age: 18, gender: \"male\" }; jString = JSON.stringify( obj, [\"username\", \"age\"], // 仅保留username、age属性 8 // table空格为8 ); console.log(jString); // { // \"username\": \"Jack\", // \"age\": 18 // } 反序列化 反序列化是指将JSON字符串转换为JavaScript中的数据类型，一般是当前语言接收其他语言传递信息时使用。 JavaScript中JSON反序列化方法为JSON.parse()。 参数释义： text：JSON字符串 reviver：回调函数，接收key、value参数，用于对反序列化出的数据进行二次处理 代码示例： \"use strict\"; let obj = { username: \"Jack\", age: 18, gender: \"male\" }; jString = JSON.stringify(obj); str = JSON.parse(jString, (k, v) => { if (k === \"gender\") { return v === \"male\" ? \"男\" : \"女\" } return v; }) console.log(str); // { username: 'Jack', age: 18, gender: '男' } Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:48 "},"前端专栏/JavaScript/Symbol.html":{"url":"前端专栏/JavaScript/Symbol.html","title":"Symbol","keywords":"","body":"Symbol介绍 Symbol对象是ES6中新引进的一种数据类型，主要作为对象的键而使用。 在ES6之前，对象的键必须是String类型，且不能重复。 在ES6之后，对象的键多了一种选择即Symbol对象，Symbol对象最大的特点就是具有唯一性。 唯一型Symbol 基本声明 Symbol没有构造函数，这使得我们不能new它，而是直接使用Symbol()即可。 Symbol对象具有唯一性，每个创建出的Symbol对象都是独一无二的： \"use strict\"; let first = Symbol(); let last = Symbol(); console.log(typeof first, typeof last); console.log(first === last); // symbol symbol // false 如图所示： 描述信息 在声明唯一型Symbol对象时，可以添加一段描述信息。 后面可以对唯一型Symbol对象使用description属性来获取这段描述信息，若没有描述信息时返回undefined。 如下所示，2个Symbol对象是不同的，但他们的描述信息是相同的： \"use strict\"; let first = Symbol(\"this is a description information\"); let last = Symbol(\"this is a description information\"); console.log(first === last); console.log(first.description === last.description); // false // true 引用型Symbol 基本声明 Symbol.for()方法用于创建一个全局引用的Symbol对象，后续再通过该方法创建的Symbol对象会引用第一个Symbol对象。 \"use strict\"; let first = Symbol.for(); let last = Symbol.for(); console.log(typeof first, typeof last); console.log(first === last); // symbol symbol // true 如图所示： 若2个Symbol.for()创建出的对象描述信息不同，则会认为是不同的Symbol对象： \"use strict\"; let first = Symbol.for(\"X\"); let last = Symbol.for(\"Y\"); console.log(typeof first, typeof last); console.log(first === last); // symbol symbol // false 如图所示： 描述信息 在声明引用型Symbol对象时，可以添加一段描述信息。 后面可以对引用型Symbol对象使用Symbol.keyFor()方法来获取这段描述信息，若没有描述信息时返回undefined。 注意，如果使用description属性获取引用型Symbol的描述信息的话，得到的结果永远是undefined： \"use strict\"; let first = Symbol.for(\"this is a first symbol description information\"); console.log(first.description); console.log(Symbol.keyFor(first)); // undefined // this is a first symbol description information 对象与Symbol 对象的Symbol键 JavaScript中对象的键如果直接声明内部会将其转变为String类型，这在某种程度上可能会引起键冲突问题。 对象键最好是唯一的，因此唯一型Symbol对象是最好的选择。 当我们想使用Symbol作为对象键时，需要注意1点： Symbol声明的对象键在访问使用时都不能利用.点语法进行操作，而是用利用[]语法进行操作，因为.点语法是操作字符串属性的 如下所示： \"use strict\"; \"use strict\"; let userNameKey = Symbol(\"userNameKey\"); let userAgeKey = Symbol(\"userAgeKey\"); let userGenderKey = Symbol(\"userGenderKey\"); let userMessage = { [userNameKey] : \"Jack\", [userAgeKey] : 18, [userGenderKey] : \"male\" } console.log(userMessage[userNameKey]); console.log(userMessage[userAgeKey]); console.log(userMessage[userGenderKey]); // Jack // 18 // male 遍历获取 Symbol类型的值不能被for/in、for/of遍历到。 普通的for/in、for/of、迭代器方法仅能获取对象下的String键： \"use strict\"; let userNameKey = Symbol(\"userNameKey\"); let userAgeKey = Symbol(\"userAgeKey\"); let userGenderKey = Symbol(\"userGenderKey\"); let userMessage = { [userNameKey] : \"Jack\", [userAgeKey] : 18, [userGenderKey] : \"male\", \"hobby\" : [\"basketball\", \"football\", \"volleyball\"] } for(let k in userMessage){ console.log(userMessage[k]); } for(let v of Object.values(userMessage)){ console.log(v); } // [ 'basketball', 'football', 'volleyball' ] // [ 'basketball', 'football', 'volleyball' ] 仅获取Symbol键 使用Object.getOwnPropertySymbols()获取对象下的所有Symbol键，注意仅是获取Symbol键而已： \"use strict\"; let userNameKey = Symbol(\"userNameKey\"); let userAgeKey = Symbol(\"userAgeKey\"); let userGenderKey = Symbol(\"userGenderKey\"); let userMessage = { [userNameKey]: \"Jack\", [userAgeKey]: 18, [userGenderKey]: \"male\", \"hobby\": [\"basketball\", \"football\", \"volleyball\"] } for (let k of Object.getOwnPropertySymbols(userMessage)) { console.log(userMessage[k]); } // Jack // 18 // male 获取所有的键 使用Reflect.ownKeys()获取对象下的所有键，注意仅是获取键而已： \"use strict\"; let userNameKey = Symbol(\"userNameKey\"); let userAgeKey = Symbol(\"userAgeKey\"); let userGenderKey = Symbol(\"userGenderKey\"); let userMessage = { [userNameKey]: \"Jack\", [userAgeKey]: 18, [userGenderKey]: \"male\", \"hobby\": [\"basketball\", \"football\", \"volleyball\"] } for (let k of Reflect.ownKeys(userMessage)) { console.log(userMessage[k]); } // [ 'basketball', 'football', 'volleyball' ] // Jack // 18 // male 半私有属性 我们可以使用Symbol不能被for/in以及for/of访问的特性，为类制作半私有属性以及提供访问接口。 \"use strict\"; let userAgeKey = Symbol(\"user userAge key\"); let userGenderKey = Symbol(\"user gender key\"); class Person { constructor(userName, userAge, userGender) { this.userName = userName; this[userAgeKey] = { userAge }; this[userGenderKey] = { userGender }; } getInfo() { // 仅能内部访问 return `name : ${this.userName}\\nage : ${this[userAgeKey].userAge}\\ngender : ${this[userGenderKey].userGender}` } } let ins = new Person(\"Jack\", 18, \"male\"); console.log(ins.getInfo()); // 外部若想访问，只能扒源码来找Symbol键 console.log(ins[userGenderKey].userGender); // name : Jack // age : 18 // gender : male // male Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:48 "},"前端专栏/JavaScript/Date.html":{"url":"前端专栏/JavaScript/Date.html","title":"Date","keywords":"","body":"基本介绍 JavaScript中提供了Date()对象，它用于对时间的管控。 Date()对象所包含的方法众多，下表将介绍一些常用的方法： 方法 描述 Date() 返回本地化当前完整日期的Date对象 getFullYear() 根据本地时间从Date对象中以四位数字格式返回年份 getMonth() 根据本地时间从Date对象中返回一年中的某一月（1 ~ 11） getDate() 根据本地时间从Date对象中返回一月中的某一天（1 ~ 31） getDay() 根据本地时间从Date对象中返回一周中的某一天（1 ~ 6） getHours() 根据本地时间从Date对象中返回当前天数中的的小时 (0 ~ 23) getMinutes() 根据本地时间从Date对象中返回当前小时中的分钟数 (0 ~ 59) getSeconds() 根据本地时间从Date对象中返回当前分钟数中的秒数 (0 ~ 59) getMilliseconds() 根据本地时间从Date对象中返回当前秒数中的的毫秒数 (0 ~ 999) setFullYear() 根据本地时设置Date对象中的年份（四位数字） setMonth() 根据本地时设置Date对象中月份 (0 ~ 11) setDate() 根据本地时设置Date对象中月的某一天 (1 ~ 31) setHours() 根据本地时设置Date对象中的小时 (0 ~ 23) setMinutes() 根据本地时设置Date对象中的分钟 (0 ~ 59) setSeconds() 根据本地时设置 Date 对象中的秒钟 (0 ~ 59) setMilliseconds() 根据本地时设置 Date 对象中的毫秒 (0 ~ 999) getUTCFullYear() 根据世界时间从Date对象中以四位数字格式返回年份 getUTCMonth() 根据世界时间从Date对象中返回一年中的某一月（1 ~ 11） getUTCDate() 根据世界时间从Date对象中返回一月中的某一天（1 ~ 31） getUTCDay() 根据世界时间从Date对象中返回一周中的某一天（0 ~ 6） getUTCHours() 根据世界时间从Date对象中返回当前天数中的的小时 (0 ~ 23) getUTCMinutes() 根据世界时间从Date对象中返回当前小时中的分钟数 (0 ~ 59) getUTCSeconds() 根据世界时间从Date对象中返回当前分钟数中的秒数 (0 ~ 59) getUTCMilliseconds() 根据世界时间从Date对象中返回当前秒数中的的毫秒数 (0 ~ 999) setUTCFullYear() 根据世界时设置Date对象中的年份（四位数字） setUTCMonth() 根据世界时设置Date对象中的月份 (0 ~ 11) setUTCDate() 根据世界时设置Date对象中月份的一天 (1 ~ 31) setUTCHours() 根据世界时设置Date对象中的小时 (0 ~ 23) setUTCMinutes() 根据世界时设置Date对象中的分钟 (0 ~ 59) setUTCSeconds() 根据世界时设置Date对象中的秒钟 (0 ~ 59) setUTCMilliseconds() 根据世界时设置Date对象中的毫秒 (0 ~ 999) toISOString 以ISO格式返回一个字符串值的日期 toLocaleString() 根据本地时间格式，把Date对象转换为字符串 toUCTString() 根据世界时间格式，把Date对象转换为字符串 toJson() 将时间对象格式化为JSON字符串 toDateString() 根据世界时间格式，把Date对象的日期部分转换为字符串 toLocalDateString() 根据本地时间格式，把Date对象的日期部分转换为字符串 toTimeString() 根据世界时间格式，把Date对象的时间部分转换为字符串 toLocalTimeString() 根据本地时间格式，把Date对象的时间部分转换为字符串 getTime() 根据本地时返回 1970 年 1 月 1 日至今的毫秒数，注意它返回的是Number类型 Date.parse() 返回 1970 年 1 月 1 日午夜到指定日期的毫秒数，注意它返回的是字符串类型 Date.UTC() 根据世界时返回 1970 年 1 月 1 日到指定日期的毫秒数，注意它返回的是字符串类型 setTime() 根据本地时以毫秒级别设置Date对象 getTimezoneOffset() 返回本地时间与格林威治标准时间 (GMT) 的分钟差 toString() 返回Date对象的字符表示值 valueOf() 返回Date对象的原始表示值 对象声明 以下例举最常见的使用方式： \"use strict\"; // 获取当前日期和时间，返回一个时间对象：Fri Jul 30 2021 20:18:01 GMT+0800 (中国标准时间) console.log(new Date()); // 也可以直接使用Date()，返回的是一个string类型，不能调用时间对象的方法：Fri Jul 30 2021 20:18:01 GMT+0800 (中国标准时间) console.log(Date()); // 获取本地时间戳：1627647554707 // 1970年1月1日凌晨8点0分0秒开始距离现在所经历过的时间，单位是毫秒 console.log(new Date() * 1); // 获取本地时间戳：1627647554707 console.log(Date.now()); // 填入参数，获取时间：Wed May 23 2018 12:00:12 GMT+0800 (中国标准时间) console.log(new Date(2018, 4, 23, 12, 0, 12, 13)); 时间统计 最通用的方法，以时间戳的毫秒为单位，结束时间减去开始时间： \"use strict\"; const sTime = Date.now(); for (let i = 0; i JavaScript独有的console系列方法，适用于控制台打印，单位也是毫秒： \"use strict\"; console.time(\"Statistics Time\") for (let i = 0; i 时间转换 以下是将时间对象转换为时间戳格式： \"use strict\"; const time = new Date(); // 可以与Number类型做运算得到时间戳 console.log(time * 1); console.log(Number(time)); // 可以调用时间对象内部提供的方法 console.log(time.valueOf()); console.log(time.getTime()); // 1627648373167 如果后端提供的时间戳格式，我们前端需要为它进行手动转换，如下所示，使用requestTime()函数模拟请求： \"use strict\"; function requestTime() { return new Date(1990, 2, 22, 13, 22, 19).getTime(); } const timestamp = requestTime(); console.log(new Date(timestamp)); // Thu Mar 22 1990 13:22:19 GMT+0800 (中国标准时间) 时间计算 以下是时间计算的相关演示： \"use strict\"; // 求5天后的3小时22分的时间 const time = new Date(1990, 2, 22, 13, 22, 19); // 5天后的时间 time.setDate(time.getDate() + 5); // 3小时 time.setHours(time.getHours() + 3); // 22分 time.setMinutes(time.getMinutes() + 22); // 最终结果 console.log(time); // Tue Mar 27 1990 16:44:19 GMT+0800 (中国标准时间) 时间格式化 有时候我们会觉得JavaScript提供给我们的格式不太好用，这个时候可以写一个函数自定义格式： \"use strict\"; function dateFormat(date, format = \"YYYY-MM-DD HH:mm:ss\") { const config = { YYYY: date.getFullYear(), // 获取年份 MM: date.getMonth() + 1, // 获取月份，月份+1是因为Js中的月份是0-11 DD: date.getDate(), // 获取天数 HH: date.getHours(), // 获取小时 mm: date.getMinutes(), // 获取分 ss: date.getSeconds() // 获取秒 }; for (const key in config) { format = format.replace(key, config[key]); } return format; } console.log(dateFormat(new Date(), \"YYYY年MM月DD日\")); // 2020年7月28日 moment.js Moment.js是一个轻量级的JavaScript时间库，它方便了日常开发中对时间的操作，提高了开发效率。 更多使用方法请访问 中文官网或英文官网。 在线引入： 1）获取当前时间： \"use strict\"; console.log(moment().format(\"YYYY-MM-DD HH:mm:ss\")); // 2021-07-30 20:45:58 2）时间计算： \"use strict\"; console.log(moment().add(10, \"days\").format(\"YYYY-MM-DD hh:mm:ss\")); // 2021-08-09 08:47:45 3）格式化时间： \"use strict\"; console.log(moment().format(\"YYYY-MM-DD HH:mm:ss\")); // 2021-07-30 20:45:58 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:48 "},"前端专栏/JavaScript/Math.html":{"url":"前端专栏/JavaScript/Math.html","title":"Math","keywords":"","body":"基本介绍 Math我们常叫它数学工具包，它没有构造函数所以不用new，直接使用其下所定义的数学或方法即可。 如： \"use strict\"; console.log(Math.PI); // 3.141592653589793 属性一览 以下是Math中提供的常用属性： 属性 描述 E 返回算术常量 e，即自然对数的底数（约等于2.718） LN2 返回 2 的自然对数（约等于0.693） LN10 返回 10 的自然对数（约等于2.302） LOG2E 返回以 2 为底的 e 的对数（约等于 1.414） LOG10E 返回以 10 为底的 e 的对数（约等于0.434） PI 返回圆周率（约等于3.14159） SQRT1_2 返回返回 2 的平方根的倒数（约等于 0.707） SQRT2 返回 2 的平方根（约等于 1.414） 方法一览 以下是Math中提供的常用方法： 方法 描述 abs(x) 返回数的绝对值 acos(x) 返回数的反余弦值 asin(x) 返回数的反正弦值 atan(x) 以介于 -PI/2 与 PI/2 弧度之间的数值来返回 x 的反正切值 atan2(y,x) 返回从 x 轴到点 (x, y) 的角度（介于 -PI/2 与 PI/2 弧度之间） ceil(x) 对数进行上舍入 cos(x) 返回数的余弦 exp(x) 返回 e 的指数 floor(x) 对数进行下舍入 log(x) 返回数的自然对数（底为e） max(x,y) 返回 x 和 y 中的最高值 min(x,y) 返回 x 和 y 中的最低值 pow(x,y) 返回 x 的 y 次幂 random() 返回 0 ~ 1 之间的随机数 round(x) 把数四舍五入为最接近的整数 sin(x) 返回数的正弦 sqrt(x) 返回数的平方根 tan(x) 返回角的正切 valueOf() 返回 Math 对象的原始值 取最大值 max() max()方法用于求出众多参数中的最大值： \"use strict\"; console.log(Math.max(1, 2, 3, 4)); // 4 取最小值 min() min()方法用于求出众多参数中的最小值： \"use strict\"; console.log(Math.min(1, 2, 3, 4)); // 1 对象求值 apply() 通过apply()搭配其他的一些方法，我们可以为数组、对象等进行求值。 如，求数组中的最大值： \"use strict\"; let ary = [1, 2, 3, 4]; console.log(Math.min.apply(Math, ary)); // 1 向上取整 ceil() 使用ceil()方法进行向上取整，它针对小数，即小数位只要不为0都向上进一位： \"use strict\"; let v = 33.01; console.log(Math.ceil(v)); // 34 向下取整 floor() 使用floor()方法进行向下取整，它针对小数，即抹除掉小数位： \"use strict\"; let v = 33.99; console.log(Math.floor(v)); // 33 四舍五入 round() 使用round()方法进行四舍五入： \"use strict\"; let v1 = 33.5; let v2 = 33.4; console.log(Math.round(v1)); console.log(Math.round(v2)); // 34 // 33 幂运算 pow() 使用pow()方法进行幂运算： \"use strict\"; let v = 3; // 等同于 3 ** 3，即 3*3*3 console.log(Math.pow(3, 3)); // 27 随机数 random() 1）直接使用random()方法会返回大于0小于1的浮点数： \"use strict\"; let v = Math.random(); console.log(v); // 0.20942996211521936 2）使用floor()方法搭配random()进行取整： \"use strict\"; let v = Math.floor(Math.random() * 5); console.log(v); 3）生成10 - 20 之间的整数，包括10，包括20： // 公式 Math.floor(Math.random() * (max - min + 1)) + min \"use strict\"; let v = Math.floor(Math.random() * (20 - 10 + 1)) + 10; console.log(v); 4）生成10 - 20 之间的整数，包括10，不包括20： // 公式 Math.floor(Math.random() * (max - min)) + min \"use strict\"; let v = Math.floor(Math.random() * (20 - 10)) + 10; console.log(v); 5）从数组中随机抽取一个元素项： \"use strict\"; let ary = [1, 2, 3, 4, 5]; const idx = Math.floor(Math.random() * ary.length); console.log(ary[idx]); 6）从数组中随机抽取索引 1 - 3 之间的元素，包括3： \"use strict\"; let ary = [1, 2, 3, 4, 5]; const idx = Math.floor(Math.random() * 3) + 1; console.log(ary[idx]); 7）从数组中随机抽取索引 1 - 3 之间的元素，不包括3： \"use strict\"; let ary = [1, 2, 3, 4, 5]; const idx = Math.floor(Math.random() * 2) + 1; console.log(ary[idx]); Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:48 "},"前端专栏/JavaScript/window对象.html":{"url":"前端专栏/JavaScript/window对象.html","title":"window对象","keywords":"","body":"window介绍 window是一个内置的全局对象，在其中存储了许多公用的方法。 所有的浏览器都支持window对象，它并不需要我们手动的进行创建。 JavaScript中一切皆对象，故浏览器中每一个HTML文档都对应一个window对象，如下图所示： 常用方法 window中的常用方法如下： 方法 描述 alert() 显示带有一段消息和一个确认按钮的警告框 confirm() 显示带有一段消息以及确认按钮和取消按钮的对话框 prompt() 显示可接收到用户输入的对话框 open() 打开一个新窗口并进入指定网址 close() 关闭浏览器窗口 setinterval() 按照指定的周期（以毫秒计）来调用函数或计算表达式，循环调用 clearInterval() 取消由 setInterval() 设置的 timeout setTimeout() 在指定的毫秒数后调用函数或计算表达式，只调用一次 clearTimeout() 取消由 setTimeout() 方法设置的 timeout scrollTo() 移动滚动条至指定位置 此外还有4个常用子对象： 对象 描述 history 存储当前窗口的浏览记录 location 存储当前窗口的页面信息 localStorage 存储在浏览器中的信息，具有持久性 sessionStorage 存储在当前窗口的信息，具有临时性 交互框系列 alert() 显示带有一段消息和一个确认按钮的警告框： \"use strict\"; alert(\"hello,world\"); // window为全局对象，不用加前缀 显示结果： confirm() 显示带有一段消息以及确认按钮和取消按钮的对话框。 点击确定是true，取消是false： \"use strict\"; let select = confirm(\"云崖是个帅哥对吗?\"); // window为全局对象，不用加前缀 console.log(select); // 点击确定是true，取消是false 显示结果： prompt() 显示可提示用户输入的对话框。 可用变量变量接收输入的内容： \"use strict\"; let message = prompt(\"请输入信息\"); // window为全局对象，不用加前缀 console.log(message); // HELLO,WORLD 显示结果： 窗口系列 open() open()方法用于打开一个新窗口并进入指定网址。 参数详解： url：新窗口打开的网址链接 _target：一个可选的字符串，它规定了新窗口的名称，或者从何处打开新窗口，如果你填入的参数在_self、_parent、_top、_blank或者已有窗口名称之间，它将在规定处打开新窗口，如果你填入了其他参数，它将视为该新窗口的名称 features：一个可选的字符串，声明了新窗口要显示的标准浏览器的特征。如果省略该参数，新窗口将具有所有标准特征。在窗口特征这个表格中，我们对该字符串的格式进行了详细的说明。 replace： 一个可选的布尔值。规定了装载到窗口的 URL 是在窗口的浏览历史中创建一个新条目，还是替换浏览历史中的当前条目。支持下面的值：true - URL 替换浏览历史中的当前条目。false - URL 在浏览历史中创建新的条目。 代码示例： \"use strict\"; open(\"http://www.google.com\"); // 打开一个新窗口，进入指定的网址 显示结果： close() close()方法用于关闭当前的浏览器窗口。 \"use strict\"; let select = confirm(\"点击确定关闭当前窗口\"); if (select) { close() }; 显示结果： 定时器系列 setInterval() 按照指定的周期（以毫秒计）来调用函数或计算表达式，循环调用。 \"use strict\"; setInterval(() => { console.log(\"hello,world\"); }, 3000); // 每隔3000毫秒运行一次 clearInterval() 取消由setInterval()设置的timeout，这代表将不会继续循环执行setInterval()中的代码。 以下示例将演示使用setInterval()与clearInterval()制作一个定时器。 Document 开始计时 停止计时 \"use strict\"; let tag = null; function start(ele) { if (tag == null) { let time = new Date().toLocaleString(); ele.previousElementSibling.value = time; } tag = setInterval(() => { let time = new Date().toLocaleString(); ele.previousElementSibling.value = time; // 上一个兄弟标签 }, 1000); } function end(ele) { clearInterval(tag); // 取消继续循环 tag = null; ele.previousElementSibling.previousElementSibling.value = \"继续计时\"; } 还有一个复杂版的： Document main { height: 100vh; width: 100vw; display: flex; flex-flow: column nowrap; justify-content: center; align-items: center; } main div:nth-of-type(1) { padding: 1rem; background-color: #ddd; font-weight: lighter; margin-bottom: .5rem; border-radius: 50%; width: 100px; height: 100px; display: flex; justify-content: center; align-items: center; } main div:nth-of-type(2) { display: flex; border: 1px solid #ddd; padding: .5rem; } main div:nth-of-type(2) button { margin-right: .5rem; } button { color: #444444; background: #F3F3F3; border: 1px #DADADA solid; padding: 5px 10px; border-radius: 2px; font-weight: bold; font-size: 9pt; outline: none; } button:hover { border: 1px #C6C6C6 solid; box-shadow: 1px 1px 1px #EAEAEA; color: #333333; background: #F7F7F7; } button:active { box-shadow: inset 1px 1px 1px #DFDFDF; } /* Blue button as seen on translate.google.com*/ button.blue { color: white; background: #4C8FFB; border: 1px #3079ED solid; box-shadow: inset 0 1px 0 #80B0FB; } button.blue:hover { border: 1px #2F5BB7 solid; box-shadow: 0 1px 1px #EAEAEA, inset 0 1px 0 #5A94F1; background: #3F83F1; } button.blue:active { box-shadow: inset 0 2px 5px #2370FE; } /* Orange button as seen on blogger.com*/ button.orange { color: white; border: 1px solid #FB8F3D; background: -webkit-linear-gradient(top, #FDA251, #FB8F3D); background: -moz-linear-gradient(top, #FDA251, #FB8F3D); background: -ms-linear-gradient(top, #FDA251, #FB8F3D); } button.orange:hover { border: 1px solid #EB5200; background: -webkit-linear-gradient(top, #FD924C, #F9760B); background: -moz-linear-gradient(top, #FD924C, #F9760B); background: -ms-linear-gradient(top, #FD924C, #F9760B); box-shadow: 0 1px #EFEFEF; } button.orange:active { box-shadow: inset 0 1px 1px rgba(0, 0, 0, 0.3); } /* Red Google Button as seen on drive.google.com */ button.red { background: -webkit-linear-gradient(top, #DD4B39, #D14836); background: -moz-linear-gradient(top, #DD4B39, #D14836); background: -ms-linear-gradient(top, #DD4B39, #D14836); border: 1px solid #DD4B39; color: white; text-shadow: 0 1px 0 #C04131; } button.red:hover { background: -webkit-linear-gradient(top, #DD4B39, #C53727); background: -moz-linear-gradient(top, #DD4B39, #C53727); background: -ms-linear-gradient(top, #DD4B39, #C53727); border: 1px solid #AF301F; } button.red:active { box-shadow: inset 0 1px 1px rgba(0, 0, 0, 0.2); background: -webkit-linear-gradient(top, #D74736, #AD2719); background: -moz-linear-gradient(top, #D74736, #AD2719); background: -ms-linear-gradient(top, #D74736, #AD2719); } 未计时 开始计时 停止计时 清空计时 \"use strict\"; let time = document.querySelector(\"time\"); let startBTN = document.querySelector(\"button[class=blue]\"); let stopBTN = document.querySelector(\"button[class=orange]\"); let resetBTN = document.querySelector(\"button[class=red]\"); let tag = null; let timeArray = [0, 0, 0]; let len = timeArray.length; function modifyTime() { // 修改显示时间 time.innerText = timeArray.map((value, index, array) => { let v = String(value); return v.length { // 防止多次点击计时后计时器加快的bug if(tag){ return } modifyTime(); event.target.innerText = \"正在计时\"; tag = setInterval(() => { if (timeArray[len - 1] != 60) { timeArray[len - 1] += 1; } else { timeArray[len - 1] = 1 timeArray[len - 2] += 1; } if (timeArray[len - 2] == 60) { timeArray[len - 2] = 0; timeArray[len - 3] += 1; } if (timeArray[len - 3] == 24) { clearInterval(tag) } modifyTime(); }, 1000) }) stopBTN.addEventListener(\"click\", event => { if (!tag) { alert(\"未开始计时!\") return } clearInterval(tag); tag = null; startBTN.innerText = \"继续计时\"; }) resetBTN.addEventListener(\"click\", event => { clearInterval(tag); tag = null; time.innerText = \"未计时\"; startBTN.innerText = \"开始计时\"; timeArray = [0, 0, 0]; }) setTimeout() 在指定的毫秒数后调用函数或计算表达式，只调用一次。 \"use strict\"; setTimeout(() => { console.log(\"hello,world\"); }, 3000); // 3000毫秒后打印一次hello，world clearTimeout() 取消由setTimeout()设置的timeout，这代表将不会继续循环执行setTimeout()中的代码。 \"use strict\"; let tag = setTimeout(() => { alert(\"HELLO,WORLD\"); }, 1000); // 一千毫秒后将打印HELLO,WORLD let select = confirm(\"如果您点击确定，会有一个弹窗在1s后向您打招呼，如果您点击取消，则没有弹窗向您打招呼。\"); if (select == false) { clearTimeout(tag); } // 由于同步任务在宏任务之前，所以先运行同步任务。 注意事项 setInterval()和setTimeout()虽然都是以毫秒进行计时，但是本身有一个最低限度。 setInterval()的最短间隔时间是10毫秒 setTimeout()的最短时间间隔是4毫秒，也就是说，小于4毫秒的时间间隔会被调整到4毫秒 此外，由于JavaScript是单线程的，所以定时器都不是立即执行，而是在所有同步任务执行完成后才会执行。 \"use strict\"; setTimeout(() => { console.log(\"4s\"); }, 4) for (let i = 0; i history对象 基本介绍 history是window对象的一个子对象，实际应用中比较少见。 它包含用户在当前浏览器窗口中访问过的URL，通过它提供的方法可以进行前进或者后退。 相当于浏览器中这2个按键： 方法如下所示： 方法 描述 back() 加载 history 列表中的前一个URL forward() 加载 history 列表中的下一个URL go() 加载 history 列表中的某个具体页面 pushState() 向 history 列表中压入一个URL，页面会进行跳转 replaceState() 先清空 histroy 列表，再向列表中压入一个URL，页面会进行跳转，但是无法进行back操作 每次用户访问过的url，都存储在history列表中，你可以将它理解为一个栈。 back()方法是出栈操作，forward()是进栈操作，而go()方法可以从栈中任意位置调出URL元素项： back() & forward() 以下有两个h5的页面，一个为主页一个为首页。 // 主页 跳转到子页 forward // 子页 back-返回到主页 显示结果： go() 使用go()也可以达到上述效果，但是里面参数要设置成+1或者-1，这样才会跳转最近一次的页面，如果设置大于1，则跳转最近n次的页面。 // 主页 跳转到子页 go(1) // 子页 go(-1)-返回到主页 显示结果： Localtion对象 基本介绍 location对象也是window对象下的一个子对象，它主要包含了当前页面的一些信息，如URL。 常用属性： 属性 描述 hash 设置或返回从井号 (#) 开始的 URL（锚） host 设置或返回主机名和当前 URL 的端口号 hostname 设置或返回当前 URL 的主机名 href 设置或返回完整的 URL ，如果设置href，则相当于在当前页打开新的文档 pathname 设置或返回当前 URL 的路径部分 port 设置或返回当前 URL 的端口号 protocol 设置或返回当前 URL 的协议 search 设置或返回从问号 (?) 开始的 URL（查询部分） 常用方法： 方法 描述 assign() 加载新的文档 reload() 重新加载当前文档 replace() 用新的文档替换当前文档 方法案例 以下是使用location对象下提供的方法案例： \"use strict\"; location.assign(\"http://www.google.com/\"); // 页面跳转访问google，不能通过浏览器自带的back按钮返回。 location.reload(); // 刷新当前页面，类似F5刷新功能 location.replace(\"http://www.google.com/\"); // 使用google来替换当前页面，不能通过浏览器自带的back返回 localStorage & sessionStorage 基本介绍 localStorage和sessionStorage都是window对象下的2个子对象。 后端中有些数据会存储在这2个地方，比如cookie，session-key等。 localStorage中存储的信息会永久保留在浏览器中，重置浏览器后信息清除 sessionStorage中存储的信息会临时保留在当前页面中，关闭页面后信息清除 以下是它们的操作方式： localStorage.attribute = value; // 新增或修改存储信息 del localStorage.attribute // 删除存储信息 如果通过第三方工具包如$cookie进行操作就很简单，它是将数据存储在localStorage中的： 名称 作用 clear 清空localStorage上存储的数据 getItem 读取数据 hasOwnProperty 检查localStorage上是否保存了变量x，需要传入x key 读取第i个数据的名字或称为键值(从0开始计数) length localStorage存储变量的个数 propertyIsEnumerable 用来检测属性是否属于某个对象的 removeItem 删除某个具体变量 setItem 存储数据 toLocaleString 将（数组）转为本地字符串 valueOf 获取所有存储的数据 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:48 "},"前端专栏/JavaScript/DOM操作.html":{"url":"前端专栏/JavaScript/DOM操作.html","title":"DOM操作","keywords":"","body":"DOM DOM的全称为Document Object Model即为文档对象模型。 DOM支持将HTML文档转换为JavaScript的对象进行操作。 节点对象 基本介绍 HTML文档中的任何内容在JavaScript中统称为DOM节点对象。 每个节点对象都包含若干操纵方法。以下是节点对象的常用知识： 节点对象可分为12种类型 根节点对象为document，即文档本身 所有的节点对象都是Node的实例 常见节点对象有根节点、元素节点、文本节点、注释节点 节点类型与编号如下所示： 节点类型 类型编号 元素节点 1 属性节点 2 文本节点 3 CDATA节点 4 实体引用名称节点 5 实体名称节点 6 处理指令节点 7 注释节点 8 文档节点 9 文档类型节点 10 文档片段节点 11 DTD声明节点 12 代码示例： Document \"use strict\"; console.log(document.body.nodeType); // 1 body标签，元素节点 let main = document.getElementById(\"main\"); console.log(main.attributes[0].nodeType); // 2 main标签的id属性也是一个节点。属性节点 console.log(main.firstChild.nodeType); // 3 main标签下的第一个子标签 即空白行。文本节点 console.log(main.lastChild.nodeType); // 3 main标签下的第一个子标签 即空白行。文本节点 console.log(main.COMMENT_NODE); // 8 main标签下的注释标签。 注释节点 console.log(document.nodeType); // 9 document也是一个节点。文档节点 console.log(document.childNodes.item(0).nodeType); // 10 文档类型节点 节点原型链 对每一种类型的节点对象进行原型链的攀升，可得到如下结论： 原型 说明 Object 根对象 EventTarget 提供事件支持 Node 提供parentNode等节点关系操作方法的支持 Element 提供getElementsByTagName()、querySelector()等节点查找方法的支持 HTMLElement 所有元素的基础类，提供className、nodeName等节点标准属性的支持 HTMLHeadingElement Head标题元素类 以下以元素节点标签为例，它的最终原型对象为ElementTarget.proptrpy： Document \"use strict\"; let main = document.getElementById(\"main\"); console.log(main.__proto__); console.log(main.__proto__.__proto__); console.log(main.__proto__.__proto__.__proto__); console.log(main.__proto__.__proto__.__proto__.__proto__); console.log(main.__proto__.__proto__.__proto__.__proto__.__proto__); 如图所示： 节点对象属性 nodeType 每个节点对象都有nodeType属性，它返回节点类型的编号。 节点类型 类型编号 元素节点 1 属性节点 2 文本节点 3 CDATA节点 4 实体引用名称节点 5 实体名称节点 6 处理指令节点 7 注释节点 8 文档节点 9 文档类型节点 10 文档片段节点 11 DTD声明节点 12 以下是nodeType属性的基本使用： Document \"use strict\"; console.log(document.querySelector(\"h1\").nodeType); // 1 使用对象原型进行检测： Document \"use strict\"; console.log(document.querySelector(\"h1\") instanceof Element); // true nodeName nodeName属性可供任何类型的节点对象使用，其作用是获取节点名称： 节点类型 类型编号 节点名称 元素节点 1 元素名称（返回值为全大写形式） 属性节点 2 属性名称 文本节点 3 #text 注释节点 8 #comment 表格释义： 对类型编号为1的元素节点对象使用nodeName属性，将返回元素名称 对类型编号为8的注释节点对象使用nodeName属性，将返回#comment 如下所示： Document hello，world 标题 文本 \"use strict\"; let h1 = document.querySelector(\"h1\"); let h2Attr = document.querySelector(\"h2\").attributes[0]; let comment = document.body.childNodes[5]; let text = document.body.childNodes[6]; // 获取为大写形式 console.log(h1.nodeName); // H1 console.log(h2Attr.nodeName); // class console.log(comment.nodeName); // #comment console.log(text.nodeName); // #text console.log(document.body.nodeName); // BODY tagName tagName属性只供元素节点对象使用，其作用是获取节点名称： tagName属性存在于Elment原型中 对元素节点使用tagName或nodeName没有任何差异 该属性获取的值都是全大写形式的 代码示例： Document hello，world 标题 文本 \"use strict\"; console.log(document.querySelector(\"h1\").tagName); // H1 console.log(document.body.tagName); // BODY nodeValue 使用nodeValue属性或data属性获取节点值。 它仅针对非元素节点使用，元素节点使用该属性总是返回null： Document hello，world 标题 文本 \"use strict\"; let h1 = document.querySelector(\"h1\"); let h2Attr = document.querySelector(\"h2\").attributes[0]; let comment = document.body.childNodes[5]; let text = document.body.childNodes[6]; console.log(h1.nodeValue); // null 元素节点获取不到值 console.log(h2Attr.nodeValue); // show console.log(comment.data); // 注释 console.log(text.data); // 文本 document对象 基本介绍 document是window的一个子对象，是由HTMLDocument实现的实例。 document对象的原型链中包含Node，所以可以使用所有节点操作方法与属性，如nodeType/nodeName等。 文档信息 系统为document对象提供了一些属性，可以快速获取一些常用信息。 属性 说明 title 获取和设置当前HTML文档标题 URL 获取当前HTML文档的URL domain 获取当前HTML文档的域名 referrer 获取当前HTML文档的来源地址 1）使用title属性可或获取和设置当前HTML文档标题： Document \"use strict\"; console.log(document.title); setTimeout(() => { document.title = \"DOM LEARN\" }, 1000); // 1s后修改页面title 2）使用URL属性可获取当前HTML文档的URL： Document \"use strict\"; console.log(document.URL); // http://localhost:5500/ 3）使用domain属性可获取当前HTML文档的域名： Document \"use strict\"; console.log(document.domain); // localhost 4）使用referrer属性可获取当前HTML文档的来源地址，可用于页面引流统计或者防盗链上： Document \"use strict\"; console.log(document.referrer); // http://localhost:5500/ 元素节点获取 手动获取所有元素节点 下面将通过使用节点的nodeType属性判断并获取所有的元素节点。 let html = [...document.childNodes].filter((node) => { if (node.nodeType === 1) { return node } })[0] console.log(html) 快速获取元素节点一览 如果只想获取元素节点，可通过下面的属性或方法进行快速获取。 属性/方法 描述 返回值 普通节点对象是否可调用 document.documentElement 获取html元素节点 node 否 document.body 获取body元素节点 node 否 document.head 获取head元素节点 node 否 document.links 获取a元素节点集合 HTMLCollection 否 document.anchors 获取具有name属性的a元素节点集合 HTMLCollection 否 document.forms 获取form元素节点集合 HTMLCollection 否 document.images 获取img元素节点集合 HTMLCollection 否 document.getElmentById() 根据id属性获取元素节点 node 否 document.getElmentByName() 根据name属性获取元素节点集合 NodeList 否 document.getElmentByTagName() 根据tagName属性获取元素节点集合 HTMLCollection 是 document.getElmentByClassName() 根据class属性获取元素节点集合 HTMLCollection 是 document.querySelectorAll() 根据CSS选择器获取元素节点集合 NodeList 是 document.querySelector() 根据CSS选择器获取元素节点 node 是 document.documentElement document.documentElement属性可获取HTML标签。 注意！仅能在document对象中使用该属性！ 它返回单一被选中的元素节点： Document \"use strict\"; console.log(document.documentElement); // html document.body document.body属性可获取body标签。 注意！仅能在document对象中使用该属性！ 它返回单一被选中的元素节点： Document \"use strict\"; console.log(document.body); // body document.head document.head属性可获取head标签。 注意！仅能在document对象中使用该属性！ 它返回单一被选中的元素节点： Document \"use strict\"; console.log(document.head); // head document.links document.links属性可获取所有的a标签。 注意！仅能在document对象中使用该属性！ 它返回HTMLCollection元素集合对象： Document first second last \"use strict\"; console.log(document.links); // HTMLCollection(3) [a, a, a] document.anchors document.anchors属性可获取所有具有name属性的的a标签锚点。 注意！仅能在document对象中使用该属性！ 它返回HTMLCollection元素集合对象： Document first second last \"use strict\"; console.log(document.anchors); // HTMLCollection(2) [a, a, first: a, second: a] document.forms document.links属性可获取所有的form标签。 注意！仅能在document对象中使用该属性！ 它返回HTMLCollection元素集合对象： Document \"use strict\"; console.log(document.forms); // HTMLCollection(3) [form, form, form] document.images document.images属性可获取所有的img标签。 注意！仅能在document对象中使用该属性！ 它返回HTMLCollection元素集合对象： Document \"use strict\"; console.log(document.images); // HTMLCollection(3) [img, img, img] document.getElmentById() document.getElmentById()方法可根据id属性获取元素节点。 注意！仅能在document对象中使用该方法！ 它返回单一被选中的元素节点： Document \"use strict\"; console.log(document.getElementById(\"div-1\")); // 拥有标准属性id的元素可做为window对象的属性进行访问，但注意不要与变量名进行重合，所以不推荐这种方式。 这也是为什么推荐在为标签id属性取名的时候用-进行分割而不是用_进行分割的原因。 Document \"use strict\"; console.log(first_div); // document.getElmentByName() document.getElmentByName()方法可根据name属性获取元素节点集合。 注意！仅能在document对象中使用该方法！ 该方法通常用于获取表单元素标签，但实际上只要有name属性的标签它都能获取到 它返回NodeList元素集合对象： Document \"use strict\"; let nameAttributeElementCollection = document.getElementsByName(\"username\") console.log(nameAttributeElementCollection); // NodeList(2) [input, p] document.getElmentByTagName() document.getElmentByTagName()方法可根据tagName属性获取元素节点集合。 注意！不论是document对象还是普通的节点对象都能使用该方法！ 元素名不区分大小写 可使用通配符*获取所有元素节点 它返回HTMLCollection元素集合对象： Document \"use strict\"; let divCollection = document.getElementsByTagName(\"div\"); console.log(divCollection); let timeCollection = divCollection[2].getElementsByTagName(\"time\"); console.log(timeCollection); // HTMLCollection(3) [div#div-1, div#div-2, div#div-3, div-1: div#div-1, div-2: div#div-2, div-3: div#div-3] // HTMLCollection [time] document.getElmentByClassName() document.getElmentByClassName()方法可根据class属性获取元素节点集合。 注意！不论是document对象还是普通的节点对象都能使用该方法！ 它返回HTMLCollection元素集合对象： Document 1 2 A B \"use strict\"; let nodeMain = document.getElementsByTagName(\"main\")[0]; let classListCollection = nodeMain.getElementsByClassName(\"list\") console.log(classListCollection); // HTMLCollection(3) [ul.list, li.list, li.list] querySelectorAll() document.querySelectorAll()方法可根据CSS Selectors获取元素节点集合。 注意！不论是document对象还是普通的节点对象都能使用该方法！ CSS的:checked选择器能够获取所有已被选中的radio、checkbox元素，而使用querySelectorAll(“:checked”)仅能获取所有默认被选中的radio、checkbox元素 它返回NodeList元素集合对象： Document 1 2 3 A B C \"use strict\"; console.log(document.querySelectorAll(\"main section article:first-of-type\")); // NodeList [article] console.log(document.querySelectorAll(\"main nav ul li\")); // NodeList(3) [li, li, li] console.log(document.querySelectorAll(\"main section article:nth-child(2)\")); // NodeList [article] querySelector() document.querySelector()方法可根据CSS Selectors获取元素节点。 注意！不论是document对象还是普通的节点对象都能使用该方法！ 如果有多个符合条件的元素，则只返回第一个，也就是说它相当于document.querySelectorAll()[0] CSS的:checked选择器能够获取所有已被选中的radio、checkbox元素，而使用querySelector(“:checked”)仅能获取一个默认被选中的radio、checkbox元素 它返回单一被选中的元素节点： Document 1 2 3 A B C \"use strict\"; console.log(document.querySelector(\"main:nth-child(2) ul li\")); // 1 表单项查找 组合查找 JavaScript为表单的查找提供了单独的属性接口： 使用document.forms可获取所有的表单元素 根据form的name属性获取单独的表单元素 使用form.elements可获取表单元素下的所有表单项元素 根据表单项的name属性使用form.elements.title可获取单独的表单项元素，它可以直接简写成form.name 针对form.name获取到radio或者checkbox，返回的结果将是一个集合而不是单独的表单项元素 示例如下： \"use strict\"; let formCollection = document.forms; // 获取所有表单 let formNode = formCollection.register; // 根据name获取某个表单 let formChildren = formNode.elements; // 拿到其下所有表单项 let username = formNode.elements.username; // 拿到name为username的表单项 console.log(formChildren); // HTMLFormControlsCollection(2) [input, input, username: input, pwd: input] console.log(username); // 获取被选中的单、复选框 单纯的使用:checked选择器，只会找到默认被选中的单选框、复选框、以及option，对于后续手动添加的单选框复选框是检测不到的。 若想获取所有被选中的单、复选框，只有循环单选框、复选框列表，判定其是否具有属性checked才行。 如下所示： 男 女 篮球 足球 排球 检测 \"use strict\"; let btnNode = document.querySelector(\"button\"); let radioAndCheckboxNodeList = document.forms.register.querySelectorAll(\"input[type=radio], input[type=checkbox]\"); btnNode.addEventListener(\"click\", (event) => { let checkedRadioCheckbox = Array.from(radioAndCheckboxNodeList).filter((element, index) => { return element.checked }) console.log(checkedRadioCheckbox); }); 获取select选中值 如果想获取select中被选中的option，则可使用以下方法： 先获取select标签 根据select节点的options属性获取其下所有的option的集合 循环遍历options集合，判断option是否具有selected属性 如下所示： 北京 上海 深圳 广州 检测 \"use strict\"; let btnNode = document.querySelector(\"button\"); let selectNode = document.forms.register.city; btnNode.addEventListener(\"click\", (event) => { let selectedOption = Array.from(selectNode.options).filter((element, index, array) => { return element.selected; }); console.log(selectedOption); }) 获取file的文件对象 如果想获取一个文件选择框中的文件对象，则可使用以下方法： 先获取input标签 根据input节点的files属性获取其下所有的已上传文件的集合 根据已上传文件集合的索引操作，获取你想要的文件对象 如下所示： 检测 \"use strict\"; let btnNode = document.querySelector(\"button\"); let fileInputNode = document.forms.register.avatar; btnNode.addEventListener(\"click\", (event) => { console.log(fileInputNode.files); // 可使用索引操作，获取你想要的文件对象 }); 元素节点筛选 属性筛选 matches() matches()方法验证某一个节点是否具有特定属性。 如下示例，我们获取了所有的元素节点，现在要通过Array原型借用filter()方法筛选出具有show属性的元素： Document \"use strict\"; let allElementNodeList = document.querySelectorAll(\"*\"); let showElementArray = Array.prototype.filter.call(allElementNodeList, (element, index, nodelst) => { return element.matches(\"[show]\"); }) console.log(showElementArray); // (2) [div, mark] 祖先筛选 closest() closest()方法会查找最近的符合选择器的祖先元素（包括自身）。 找祖先，看最近的祖先能不能被选择器选中，如果不能继续向上找。 如下示例，我们获取了.float元素，需要查找它的祖先中具有show属性的标签： Document \"use strict\"; let floatNode = document.querySelector(\".float\"); console.log(floatNode.closest(\".show\")); // ... 节点关系获取 普通节点关系获取一览 节点对象可通过以下属性可获取与其他节点之间关系。 它们包含文本节点与注释节点： 节点属性 描述 返回值 childNodes 获取子节点对象 node parentNode 获取父节点对象 NodeList firstChild 获取第一个子节点对象 node lastChild 获取最后一个子节点对象 node previousSibling 获取上一个兄弟节点对象 node nextSibling 获取下一个兄弟节点对象 node 由于使用的较少，这里不再进行演示，注意2点： 换行也包括在节点关系中，它是一个单独的#text文本节点 文本节点不能作为父节点，因为它不会嵌套任何子节点 元素节点关系获取一览 节点对象可通过以下属性获取与其他元素节点之间的关系。 它们不包含文本节点与注释节点，所以是非常常用的。 节点属性 描述 返回值 parentElement 获取父元素节点对象 node children 获取子元素节点对象 HTMLCollection childElementCount 获取子元素节点对象的数量 number firstElementChild 获取第一个子元素节点对象 node lastElementChild 获取最后一个子元素节点对象 node previousElementSibling 获取上一个兄弟元素节点对象 node nextElementSibling 获取下一个兄弟元素节点对象 node parentElment parentElment属性用于获取父元素节点对象，它返回单一被选中的元素节点： Document 1 2 3 4 5 6 7 \"use strict\"; let ulNode = document.querySelector(\"ul\"); console.log(ulNode.parentElement); // main children children属性用于获取子元素节点对象，它返回HTMLCollection元素集合对象： Document 1 2 3 4 5 6 7 \"use strict\"; let ulNode = document.querySelector(\"ul\"); console.log(ulNode.children); // HTMLCollection(7) [li#li-1, li#li-2, li#li-3, li#li-4, li#li-5, li#li-6, li#li-7, li-1: li#li-1, li-2: li#li-2, li-3: li#li-3, li-4: li#li-4, li-5: li#li-5, …] firstElementChild firstElementChild属性用于获取第一个子元素节点对象，它返回单一被选中的元素节点： Document 1 2 3 4 5 6 7 \"use strict\"; let ulNode = document.querySelector(\"ul\"); console.log(ulNode.firstElementChild); // li#li-1 lastElmentChild lastElementChild属性用于获取最后一个子元素节点对象，它返回单一被选中的元素节点： Document 1 2 3 4 5 6 7 \"use strict\"; let ulNode = document.querySelector(\"ul\"); console.log(ulNode.lastElementChild); // li#li-7 previousElementSibling previousElementSibling属性用于获取上一个兄弟元素节点对象，它返回单一被选中的元素节点： Document 1 2 3 4 5 6 7 \"use strict\"; let mainNode = document.querySelector(\"main\"); console.log(mainNode.previousElementSibling); // header nextElementSibling nextElementSibling属性用于获取下一个兄弟元素节点对象，它返回单一被选中的元素节点： Document 1 2 3 4 5 6 7 \"use strict\"; let mainNode = document.querySelector(\"main\"); console.log(mainNode.nextElementSibling); // footer 元素节点集合对象 基本介绍 JavaScript中共有2种元素节点集合对象，分别是NodeList和HTMLCollection。 它们的相同点在于： 都是类数组 都具有length属性 都可以用index进行元素项访问 都提供了item()方法来根据index操纵元素项 都实现了迭代器协议，可以通过for/of进行遍历 它们的不同点在于： NodeList是动态映射DOM的（querySelectorAll()方法获得的NodeList除外），而HTMLCollection不是 HTMLCollection提供了namedItem()方法来根据元素name属性、id属性提取元素项 NodeList提供了forEach()方法来进行遍历，但是HTMLCollection未提供该方法 两者对比而言，其实NodeList更加的优秀，它支持动态映射DOM这个就令HTMLCollection汗颜了。 length NodeList与HTMLCollection都包含length属性，记录了其中包含元素节点的数量： Document 1 2 3 \"use strict\"; let liNodeList = document.querySelectorAll(\"li\"); let liCollection = document.getElementsByTagName(\"li\"); console.log(liNodeList.length); console.log(liCollection.length); // 3 // 3 item() NodeList与HTMLCollection都提供了item()方法来根据索引获取元素： Document 1 2 3 \"use strict\"; let liNodeList = document.querySelectorAll(\"li\"); let liCollection = document.getElementsByTagName(\"li\"); console.log(liNodeList.item(0)); console.log(liCollection.item(0)); // 等同于 console.log(liNodeList[0]); console.log(liCollection[0]); namedItem() HTMLCollection提供了namedItem()方法来根据元素name属性、id属性提取元素项： Document 1 2 3 4 5 \"use strict\"; let divCollection = document.getElementsByTagName(\"div\"); console.log(divCollection.namedItem(\"div-name\")); console.log(divCollection.namedItem(\"div-id\")); // 1 // 2 动态映射 NodeList拥有动态映射的特征，也就是说当DOM上的元素对象发生改变后NodeList中的元素项也会发生改变。 注意：querySelectorAll()方法返回的NodeList是静态的 动态特性示例，在获取了NodeList后新增了一个标签插入文档中，可以发现NodeList也会新增标签： Document \"use strict\"; let divNodeList = document.getElementsByName(\"show\"); console.log(divNodeList.length); // 3 let newDiv = document.createElement(\"div\"); newDiv.setAttribute(\"name\", \"show\"); // div的name属性是特征属性，input的name是标准属性 document.body.append(newDiv); console.log(divNodeList.length); // 4 querySelectorAll()方法返回的NodeList是静态的： Document \"use strict\"; let divNodeList = document.querySelectorAll(\"[name=show]\"); console.log(divNodeList.length); // 3 let newDiv = document.createElement(\"div\"); newDiv.setAttribute(\"name\", \"show\"); // div的name属性是特征属性，input的name是标准属性 document.body.append(newDiv); console.log(divNodeList.length); // 3 数组转换 HTMLCollection和NodeList都可以转换为数组，我们以NodeList示例。 1）通过Array.form()方法将NodeList转换为数组： Document \"use strict\"; let divNodeList = document.querySelectorAll(\"[name=show]\"); let divNodeArray = Array.from(divNodeList); console.log(divNodeArray); // (3) [div, div, div] 2）通过…语法将NodeList转换为数组： Document \"use strict\"; let divNodeList = document.querySelectorAll(\"[name=show]\"); let divNodeArray = [...divNodeList]; console.log(divNodeArray); // (3) [div, div, div] 其实在通过Array.form()方法将NodeList转换为数组时，可对mapfn形参传入一个回调函数用以操作数据项。 如下所示，我们只提取元素节点的文本内容： Document A B C \"use strict\"; let ary = Array.from( document.querySelectorAll(\"div\"), (element, index) => { return element.innerText; } ); console.log(ary); // [\"A\", \"B\", \"C\"] 原型借用 HTMLCollection和NodeList都是类数组，所以可以很好的借用Array原型对象的方法。 如下示例，计算书籍总价格并写入到文档中： Document table#book-table { width: 300px; border: 1px solid #ddd; caption-side: top; border-collapse: collapse; } table#book-table th, td, caption { border: 1px solid #ddd; } table#book-table caption { background-color: #aaa; font-weight: bolder; padding: .3rem; } table#book-table tfoot td { font-weight: bolder; } table#book-table th, td { padding: .2rem; text-align: center; } table tbody tr:nth-child(odd) { background-color: #eee; } table tbody tr:hover { background-color: #aaa; } table tbody tr * { cursor: pointer; } book table book name book price JavaScript 32 HTML5 24 CSS3 36 total price \"use strict\"; let bookNodeList = document.querySelectorAll(\"[book]\"); let bookTotalPrice = Array.prototype.reduce.call(bookNodeList, (prev, cur, idx, nodelst) => { return prev + Number(cur.nextElementSibling.innerText); }, 0) document.querySelector(\"#total-price\").innerText = bookTotalPrice; 渲染结果： 对象遍历 NodeList和Collection都支持的遍历方式有： for遍历 for/of遍历 此外，NodeList还支持forEach()方法进行遍历。 这里不再进行演示，其实它们可以通过Array原型借用获得更好的遍历体验，如借用reduce()、map()、every()、some()等方法实现遍历。 节点对象创建 创建文本节点 document.createTextNode() 使用document.createTextNode()方法来创建文本节点对象： Document \"use strict\"; let textNode = document.createTextNode(\"HELLO WORLD\"); console.log(textNode); // \"HELLO WORLD\" console.log(textNode.nodeType); // 3 console.log(textNode.nodeName); // #text console.log(textNode.nodeValue); // HELLO WORLD 创建元素节点 document.createElement() 使用document.createElement()方法来创建元素节点对象： Document \"use strict\"; let elementNode = document.createElement(\"div\"); console.log(elementNode); // console.log(elementNode.nodeType); // 1 console.log(elementNode.nodeName); // DIV console.log(elementNode.nodeValue); // null 元素节点使用该属性总是返回null 克隆节点 node.cloneNode() 节点对象都拥有cloneNode()方法，旨在克隆出一个一模一样的节点。 如果它的deep参数为true，会进行递归的深度克隆。 注意，如果事件绑定是绑定在元素身上，则会连同事件一起拷贝 示例如下： Document A \"use strict\"; document.importNode function callbackfn(element, event) { let ascii = element.firstElementChild.innerText.charCodeAt(); let newDiv = element.cloneNode(true); newDiv.firstElementChild.innerText = String.fromCharCode(ascii + 1); element.after(newDiv); } 导入节点 document.importNode() document.importNode()和node.cloneNode()的功能基本相同，但是使用上有所不同。 importNode()方法仅能由document调用 cloneNode()方法可以由任何节点对象调用 document.importNode()方法有2个参数： node：传入要被拷贝的节点对象 deep：是否进行深度拷贝 值得注意的是，在部分IE浏览器上该方法的支持性并不如node.cloneNode()方法。 如下所示，将node.cloneNode()方法改变为document.importNode()，效果不会发生任何变化： Document A \"use strict\"; function callbackfn(element, event) { let ascii = element.firstElementChild.innerText.charCodeAt(); let newDiv = document.importNode(element, true); newDiv.firstElementChild.innerText = String.fromCharCode(ascii + 1); element.after(newDiv); } 元素节点内容 innerHTML 元素节点可通过innerHTML属性获取或设置标签中嵌套的内容。 如果是设置内容，它将触发浏览器解析器重新绘制DOM。 设置内容时，可以通过innerHTML为源标签创建一个嵌套标签，但不能创建标签 + JavaScript代码，这样做会抛出异常。 如下示例： Document HELLO WORLD \"use strict\"; let divNode = document.querySelector(\"div\"); // 获取内容 console.log(divNode.innerHTML); // HELLO WORLD // 设置内容 有效，只要不是标签即可 divNode.innerHTML = \"hello world\" // 最后DOM上渲染结果为 ： hello world outerHTML innerHTML只包含内容，而outerHTML包含标签本身。 如下图所示： 当要替换outerHTML时，它会将标签本身也一起替换： Document HELLO WORLD \"use strict\"; let divNode = document.querySelector(\"div\"); // 获取内容 console.log(divNode.outerHTML); // HELLO WORLD // 设置内容 有效，只要不是script标签即可 divNode.outerHTML = \"hello world\" // 最后DOM上渲染结果为 ： hello world innerText & textContent 元素节点可通过innerText或textContent属性获取或设置标签中嵌套的文本内容，注意与innerHTML的区别。 innerText和textContent属性的功能都一样，但是兼容性上有一些差别： textContent属性不被部分IE浏览器所支持 innerText属性不被部分FireFox浏览器所支持 在获取时，忽略标签本身，只获取其文本内容。 在设置时，不能设置嵌套标签，它将被当做普通文本进行对待。 示例如下： Document 外层文本内层文本 \"use strict\"; let divNode = document.querySelector(\"div\"); // 在获取时，忽略标签本身，只获取其文本内容。 console.log(divNode.innerHTML); // 外层文本内层文本 console.log(divNode.innerText); // 外层文本内层文本 // 在设置时，不能设置嵌套标签，它将被当做普通文本进行对待。 divNode.innerText = \"HELLO WORLD\" // 最后页面上会直接显示出 ： hello world，并不会做标签渲染 outerText 区别点同innerHTML和outerHTML相同。 即在替换时，是否连同标签本身一起替换。 Document 外层文本内层文本 \"use strict\"; let divNode = document.querySelector(\"div\"); divNode.outerHTML = \"不会解析成标签\"; 节点对象管理 推荐方法 在当前版本，JavaScript中对节点对象的管理主要使用以下方法，它们都支持插入、删除、替换文本节点和元素节点。 以下方法是任意节点对象都可调用的，其中也包括document对象： 方法 描述 append() 在节点内部的末尾添加新的元素节点对象或文本节点对象 prepend() 在节点内部的首部插入新的元素节点对象或文本节点对象 before() 在节点同级的前面插入新的元素节点对象或文本节点对象 after() 在节点同级的后面插入新的元素节点对象或文本节点对象 replaceWith() 将当前节点对象替换为新的元素节点对象或文本节点对象 append() 在节点内部的末尾添加新的元素节点对象或文本节点对象。 如图所示： 代码示例： Document unorder list start 1 2 3 unorder list end \"use strict\"; let ulNode = document.querySelector(\"ul\"); let newNode = document.createElement(\"li\"); newNode.innerText = \"append()\"; ulNode.append(newNode); 渲染结果： prepend() 在节点内部的首部插入新的元素节点对象或文本节点对象。 如图所示： 代码示例： Document unorder list start 1 2 3 unorder list end \"use strict\"; let ulNode = document.querySelector(\"ul\"); let newNode = document.createElement(\"li\"); newNode.innerText = \"prepend()\"; ulNode.prepend(newNode); 渲染结果： before() 在节点同级的前面插入新的元素节点对象或文本节点对象。 如图所示： 代码示例： Document unorder list start 1 2 3 unorder list end \"use strict\"; let ulNode = document.querySelector(\"ul\"); let newNode = document.createElement(\"h2\"); newNode.innerText = \"before()\"; ulNode.before(newNode); 渲染结果： after() 在节点同级的后面插入新的元素节点对象或文本节点对象。 如图所示： 代码示例： Document unorder list start 1 2 3 unorder list end \"use strict\"; let ulNode = document.querySelector(\"ul\"); let newNode = document.createElement(\"h2\"); newNode.innerText = \"after()\"; ulNode.after(newNode); 渲染结果： replaceWith() 将当前节点对象替换为新的元素节点对象或文本节点对象。 如图所示： 代码示例，将h1替换为mark，保留原本的内容： Document unorder list start 1 2 3 unorder list end \"use strict\"; setTimeout(() => { let h1NodeList = document.querySelectorAll(\"h1\"); h1NodeList.forEach((element, index, lst) => { let elementContent = element.innerHTML; let newNode = document.createElement(\"mark\"); newNode.innerHTML = elementContent; element.replaceWith(newNode); }) }, 5000); 渲染结果： 1）替换之前： 2）替换之后： 其他方法 上面介绍的5个节点管理方法可针对文本节点、也可针对元素节点，是最常用的节点管理方法，没有什么局限性。 而下面介绍的方法3个节点管理方法或只针对文本节点、或只针对元素节点，都有一定的局限性，因此不太常用。 这3个方法任意节点对象都可调用的，其中也包括document对象： insertAdjacentText()：只能将文本节点对象插入到节点的某个位置上，它不会对文本中的标签进行解析 insertAdjacentHTML()：只能将文本节点对象插入到节点的某个位置上，它可以对文本中的标签进行解析 insertAdjacentElement()：只能将元素节点对象插入到节点的某个位置上 这3个方法都有2个参数： InsertPosition：插入的位置 text、html、insertedElement：待插入的对象 其中，插入位置可指定的字符串如下所示： InsertPosition 描述 beforebegin 元素同级前面 afterend 元素同级后面 afterbegin 元素内部前面 beforeend 元素内部后面 代码示例： Document unorder list start 1 2 3 unorder list end \"use strict\"; let node = document.querySelector(\"ul\"); // 只能将文本节点对象插入到节点的某个位置上，它不会对文本中的标签进行解析 node.insertAdjacentText(\"beforeend\", \"new text\"); // 只能将文本节点对象插入到节点的某个位置上，它可以对文本中的标签进行解析 node.insertAdjacentHTML(\"beforeend\", \"new html li\"); // 只能将元素节点对象插入到节点的某个位置上 let newNode = document.createElement(\"li\"); newNode.innerHTML = \"new element li\" node.insertAdjacentElement(\"beforeend\", newNode); 渲染结果： 古老方法 下面是过去使用的操作节点的方法，现在不建议使用了，在阅读一些老旧代码时可参照此表： 方法 说明 appendChild() 添加子节点对象 insertBefore() 在同级的前面插入一个节点对象 removeChild() 删除子节点对象 replaceChild() 替换子节点对象 标准属性操作 什么是标准属性 标准属性即为HTML标签中自带的一些常见属性。 如：id、class、的name、value、readonly、disabled等。 一言以蔽之，只要不是自定义的标签属性都被称之为标准属性。 一些特殊的标准属性 一些标准属性的名字和JavaScript关键字有冲突，对此JavaScript对这些标准属性进行了重命名操作： 标准属性class被重命名为className 标准属性for被重命名为htmlFor 如何操纵标准属性 对元素节点对象使用点语法，跟上标准属性名即可。 标准属性的获取不一定完全是字符串，也有可能是布尔值 操作标准属性时，严格区分大小写 操作标准属性时，采用驼峰命名法，如readonly要变更为readOnly 如下所示： Document .blue { color: blue; } .tilt { font-style: italic; } HELLO WORLD \"use strict\"; let h1ElementNode = document.querySelector(\"h1\"); h1ElementNode.className = \"blue tilt\"; let inputElementNode = document.querySelector(\"input\"); console.log(inputElementNode.readOnly); // true console.log(inputElementNode.placeholder); // this is input element console.log(inputElementNode.value); // console.log(inputElementNode.type); // text 常见标准属性与设置 以下例举常见标准属性与值的设置： 标签类型 标准属性 值类型 全标签 id string 全标签 className string 全标签 hidden boolean href string target string src string alt string action string method string enctype string novalidate boolean name string value string placeholder string required boolean readonly boolean disabled boolean checked boolean multiple boolean selected boolean 特征属性操作 什么是特征属性 特征属性即我们为HTML标签自定义的一些属性。 一言以蔽之，只要不是自带的标签属性都被称之为特征属性 特征属性的操作方法 特征属性不能使用点语法进行操作，而是要用节点对象提供的方法进行操作。 特征属性的操作不区分大小写 特征属性的值都为string类型 节点属性操作常用方法如下所示，它们不仅支持操作标准属性，还支持操作特征属性： 方法 说明 getAttribute() 获取某一属性 setAttribute() 设置某一属性 removeAttribute() 删除某一属性 hasAttribute() 检测某一属性是否存在 getAttribute() 获取某一属性，支持获取标准、特征属性： Document \"use strict\"; let divNode = document.querySelector(\"div\"); // 标准属性获取 console.log(divNode.getAttribute(\"class\")); console.log(divNode.getAttribute(\"id\")); // 特征属性获取 console.log(divNode.getAttribute(\"data\")); // structure // div-1 // this is div setAttribute() 设置某一属性，支持设置标准、特征属性： Document \"use strict\"; let divNode = document.querySelector(\"div\"); // 设置标准属性 divNode.setAttribute(\"class\", \"c1 c2 c3\"); divNode.setAttribute(\"id\", \"div--1\"); // 设置特征属性 divNode.setAttribute(\"data\", \"new description\"); console.log(divNode); // removeAttribute() 删除某一属性，支持删除标准、特征属性： Document \"use strict\"; let divNode = document.querySelector(\"div\"); // 删除标准属性 divNode.removeAttribute(\"class\"); // 删除特征属性 divNode.removeAttribute(\"data\"); console.log(divNode); // hasAttribute() 检测某一属性是否存在，支持检测标准、特征属性： Document \"use strict\"; let divNode = document.querySelector(\"div\"); // 检测标准属性 console.log(divNode.hasAttribute(\"class\")); // 检测特征属性 console.log(divNode.hasAttribute(\"data\")); // true // true attributes返回所有属性 节点对象可使用attributes属性来返回所有的特征、标准属性。 attributes将返回一个NameNodeMap对象： Document \"use strict\"; let divNode = document.querySelector(\"div\"); console.log(divNode.attributes); // NamedNodeMap {0: class, 1: id, 2: data, class: class, id: id, data: data, length: 3} NameNodeMap是一个可迭代对象，你可以使用for/of迭代它或者直接使用index对其进行操作： Document \"use strict\"; let divNode = document.querySelector(\"div\"); let divNodeAttributes = divNode.attributes; console.log(divNodeAttributes[0]); // class=\"structure\" for (let v of Object.values(divNodeAttributes)) { console.log(v.nodeName, v.nodeValue); } // class structure // id div-1 // data this is div dataset 特征属性集 我们自定义的特征属性在某些时候很容易和标准属性名字发生冲突。 针对这种情况，我们只需要在特征属性定义时前面加上data-的前缀即可。 要获取这些特征属性时，可直接通过node.dataset属性集进行获取，属性集和以data-开头的特征属性之间拥有动态映射的关系，你可以在属性集中访问、修改、删除这些以data-开头的特征属性。 通过属性集去获取特征属性时，忽略data-的前缀 通过属性集去获取特征属性时，要按照小驼峰式命名法 通过属性集去操作特征属性时，DOM也会相应发生变化 1）只有data-开头的特征属性才会被加入属性集中，并且在属性集中存储这些特征属性时会去掉data-开头的前缀： Document HELLO WORLD \"use strict\"; let divNode = document.querySelector(\"div\"); let divDataSet = divNode.dataset; console.log(divDataSet); // DOMStringMap {position: \"left\", fontColor: \"#888\", fontSize: \"2rem\"} 2）属性集的删改操作都会影响到元素本身，这说明dataset具有动态响应的特性： Document HELLO WORLD \"use strict\"; let divNode = document.querySelector(\"div\"); let divDataSet = divNode.dataset; // 改 divDataSet.fontSize = \"30px\"; divDataSet.position = \"center\"; // 删 delete divDataSet.fontColor; console.log(divDataSet); // DOMStringMap {position: \"center\", fontSize: \"30px\"} console.log(divNode); // HELLO WORLD 样式设置 style 元素节点使用style属性可以单独的为某一个元素进行单一的样式设置。 当被设置的样式名有-分割时，应当采用小驼峰命名法： Document HELLO WORLD \"use strict\"; let divNode = document.querySelector(\"div\"); divNode.style.color = \"red\"; divNode.style.fontSize = \"2rem\"; divNode.style.fontStyle = \"italic\"; // HELLO WORLD style.cssText 元素节点使用style.cssText属性可以单独的为某一个元素进行多种样式设置。 Document HELLO WORLD \"use strict\"; let divNode = document.querySelector(\"div\"); divNode.style.cssText = \"color: red; font-size: 2rem; font-style: italic;\"; // HELLO WORLD setAttribute() 元素节点使用setAttribute()方法也可以单独的为某一个元素进行多种样式设置。 Document HELLO WORLD \"use strict\"; let divNode = document.querySelector(\"div\"); divNode.setAttribute(\"style\", \"color: red; font-size: 2rem; font-style: italic;\"); // HELLO WORLD classList 元素节点可以通过classList属性下提供的方法来切换已有的class可实现批量化的样式控制。 classList属性下可使用的方法如下表所示： 方法 描述 classList.contains() 检测某个class是否存在 classList.add() 新增一个或多个class classList.remove() 删除一个或多个class classList.toggle() 如果class以存在，则删除，如果class不存在，则新增，相当于切换 1）检测某个class是否存在： Document .ft { font: italic bold 1em/1.5 'Courier New', Courier, monospace; } .bg { background: red; } .show { display: block; } .hidden { display: none; } HELLO WORLD click me \"use strict\"; let divNode = document.querySelector(\"div\"); let btnNode = document.querySelector(\"button\"); btnNode.addEventListener(\"click\", (event) => { console.log(divNode.classList.contains(\"show\")); console.log(divNode.classList.contains(\"hidden\")); console.log(divNode.classList.contains(\"bg\")); console.log(divNode.classList.contains(\"ft\")); }); // false // false // true // true 2）新增class，可用空格进行分割，进而一次添加多个class： Document .ft { font: italic bold 1em/1.5 'Courier New', Courier, monospace; } .bg { background: red; } .show { display: block; } .hidden { display: none; } HELLO WORLD click me \"use strict\"; let divNode = document.querySelector(\"div\"); let btnNode = document.querySelector(\"button\"); btnNode.addEventListener(\"click\", (event) => { divNode.classList.add(\"bg\"); }); 3）删除class，可用空格进行分割，进而一次删除多个class： Document .ft { font: italic bold 1em/1.5 'Courier New', Courier, monospace; } .bg { background: red; } .show { display: block; } .hidden { display: none; } HELLO WORLD click me \"use strict\"; let divNode = document.querySelector(\"div\"); let btnNode = document.querySelector(\"button\"); btnNode.addEventListener(\"click\", (event) => { divNode.classList.remove(\"bg\"); }); 4）如果class以存在，则删除，如果class不存在，则新增，相当于切换： Document .ft { font: italic bold 1em/1.5 'Courier New', Courier, monospace; } .bg { background: red; } .show { display: block; } .hidden { display: none; } HELLO WORLD click me \"use strict\"; let divNode = document.querySelector(\"div\"); let btnNode = document.querySelector(\"button\"); btnNode.addEventListener(\"click\", (event) => { divNode.classList.toggle(\"show\"); divNode.classList.toggle(\"hidden\"); }); 样式获取 style 如果节点的样式是行内式的话，那么可以通过style属性单独的获取某一样式。 注意！仅针对行内式： Document HELLO WORLD \"use strict\"; let divNode = document.querySelector(\"div\"); console.log(divNode.style.color); console.log(divNode.style.fontSize); console.log(divNode.style.fontStyle); // red // 2rem // italic getComputedStyle() 通过getComputedStyle()方法，获取节点元素身上所有以生效的样式。 这是计算后的样式属性，所以取得的单位和定义时的可能会有不同。 参数释义： elt：要获取样式的元素节点对象 pseudoElt：获取的伪类样式 示例如下： Document HELLO WORLD \"use strict\"; let divNode = document.querySelector(\"div\"); console.log(getComputedStyle(divNode)); 可通过点语法获取单独的某个样式： Document HELLO WORLD \"use strict\"; let divNode = document.querySelector(\"div\"); console.log(getComputedStyle(divNode).color); console.log(getComputedStyle(divNode).fontSize); console.log(getComputedStyle(divNode).fontStyle); // rgb(255, 0, 0) // 32px // italic Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:48 "},"前端专栏/JavaScript/Event操作.html":{"url":"前端专栏/JavaScript/Event操作.html","title":"Event操作","keywords":"","body":"基础知识 事件作用 某些时候，我们希望用户在页面上做出一些行为后JavaScript能够自动的运行一段特定的代码。 如用户鼠标单击后放大图片、用户鼠标双击后改变文本颜色等需求均可使用事件来完成。 事件的使用总体分为2大部分： 如何给元素绑定事件 如何编写事件的处理逻辑 在JavaScript中对于事件的处理采用异步驱动形式进行，所以它的效率是非常高的，不必担心出现任何性能问题。 事件类型 事件拥有多种类型，比如文档事件、鼠标事件、键盘事件等。 不同类型的事件是不同的对象，他们会提供不同的属性来供开发人员使用。 事件对象 事件本身是一个对象，当一个事件发生时会自动的创建出该类型的事件对象，大多数情况下它都会被存储在window对象中。 我们可以通过window.event属性来调用出当前的事件对象。 所有的事件对象原型都继承了Event，Event为所有类型的事件对象提供了一些通用的属性及方法，如下所示： 属性 描述 Event.type 事件的类型，不区分大小写 Event.target 对事件原始目标的引用，这里的原始目标指最初派发（dispatch）事件时指定的目标 Event.currentTarget 当前正在执行事件的对象，如果有事件冒泡发生，它将是不断变化的 Event.cancelable 一个布尔值，表示事件是否可以取消 Event.bubbles 一个布尔值，用来表示该事件是否会在 DOM 中冒泡 Event.eventPhase 表示事件流正被处理到了哪个阶段 事件目标 事件目标分为2种，一种是引发事件的目标，一种是正在执行事件的目标。 event.target：它指向引发此处事件的源目标，是不会改变的 event.currentTarget：它指向事件正在执行的目标，是允许改变的，只有在冒泡行为产生后才能体现该属性的作用 为什么会有2种目标呢？ 这个就和事件执行周期有关了，因为元素是可以嵌套的，所以大多数事件在执行时都会产生多个目标对象。 事件周期 当一个事件被绑定且执行时，一定会有3个大阶段，为了方便后续探讨，我将它分为4个小阶段，分别是： 捕获阶段：事件从Window对象开始派发给源目标 目标阶段：事件到达源目标 传播阶段：事件开始在源目标上主动执行处理逻辑的回调函数，此时事件的执行目标等同于源目标 （这是一个自我划分的阶段） 冒泡阶段：事件从源目标上进行冒泡，被动执行父级相同事件的回调函数，此时事件的执行目标发生改变，源目标不变 如下图所示： 事件绑定 回调函数 一般来说我们在为一个元素添加一个事件监听后会为其绑定一个回调函数。 该回调函数会在事件发生后自动进行调用。 HTML on 直接在HTML代码中绑定事件回调函数，在绑定时必须添加括号。 它会在事件发生后自动进行执行，可传入参数this和event： this：事件源目标对象，即标签本身 event：当前的事件对象 需要注意this的执行是会根据回调函数形态的不同而发生变化的，具体可参照下面this指向一章节。 示例如下： click me \"use strict\"; function callbackfn(target, event) { console.log(\"run\"); } DOM on 也可以将事件回调函数绑定到DOM节点对象的属性中，有2点注意事项： 不能使用setAttribute()方法进行属性设置，因为它针对的是标签的普通、特征属性，而非Node节点本身的属性 属性名必须区分大小写 在绑定时，我们可指定形参event，它将在回调函数运行时自动传入当前的事件对象。 示例如下： click me \"use strict\"; let btnNode = document.querySelector(\"button\"); btnNode.onclick = function (event) { console.log(\"run\"); }; 监听绑定 addEventListener() 不论是HTML绑定还是DOM绑定都具有一定的缺陷，因此推荐使用ES6新增的addEventListener()方法进行事件绑定。 它的优点如下： 支持transtionend和DOMContentLoaded等事件类型的绑定 同一节点对象支持多次绑定相同事件，它会按照绑定顺序进行依次执行 支持对未来元素添加绑定事件 参数说明： 参数 描述 type 需要绑定的监听事件类型 listener 需要绑定的回调处理程序，如果是回调函数，可传入形参event options 定制选项 着重说明options的可定制选项： once：布尔值，如果为true代表只执行一次事件处理程序，默认是false capture：布尔值，表示listener会在该类型的事件捕获阶段传播到该元素时触发，默认是false passive：布尔值，如果为true代表用于不要在回调函数中使用event.preventDefault()，否则将抛出异常，默认是false 示例如下，添加一个只执行一次的事件，指定options的once为true即可： click me \"use strict\"; let btnNode = document.querySelector(\"button\"); btnNode.addEventListener(\"click\", function (event) { console.log(\"run\"); event.target.innerText = \"don't click me\"; }, { once: true }); removeEventListener() 使用removeEventListener()方法删除某个节点所绑定的事件及回调函数。 示例如下，左键单击按钮会令内容+1，右键单击按钮会令左键功能失效： 0 click me \"use strict\"; let btnNode = document.querySelector(\"button\"); let spanNode = document.querySelector(\"div span\"); function click(event) { spanNode.innerText = Number(spanNode.innerHTML) + 1; } function contextmenu(event) { btnNode.removeEventListener(\"click\", click); btnNode.disabled = true; // 禁止右键的弹出菜单 event.preventDefault(); } btnNode.addEventListener(\"click\", click); btnNode.addEventListener(\"contextmenu\", contextmenu); handleEvent() 如果事件处理的回调程序不是一个函数，而是一个对象的话，那么对象中的handleEvent()方法会在事件触发后自动进行执行： click me \"use strict\"; let btnNode = document.querySelector(\"button\"); class BTNEventHandle { constructor(node) { node.addEventListener(\"mousedown\", this); node.addEventListener(\"mouseup\", this); } handleEvent(event) { // 寻找同名方法 this.类型方法 // 并传递进事件对象和源目标对象 this[event.type](event, event.target); } mousedown(event, target) { console.log(\"按下了鼠标左键\"); } mouseup(event, target) { console.log(\"松开了鼠标左键\"); } } new BTNEventHandle(btnNode); this指向 如果回调函数是普通函数，那么this即指向事件的源目标对象。 如果回调函数是箭头函数，那么this即指向window对象。 示例如下： ordinary arrow \"use strict\"; let btnNodeOrdinary = document.querySelector(\"button:first-of-type\"); let btnNodeArrow = document.querySelector(\"button:last-of-type\"); btnNodeOrdinary.addEventListener(\"click\", function (event) { console.log(this); // ordinary }); btnNodeArrow.addEventListener(\"click\", event => { console.log(this); // Window }); event.target 如果想在箭头函数中拿到事件源目标对象，可使用event.target属性。 ordinary arrow \"use strict\"; let btnNodeOrdinary = document.querySelector(\"button:first-of-type\"); let btnNodeArrow = document.querySelector(\"button:last-of-type\"); btnNodeOrdinary.addEventListener(\"click\", function (event) { console.log(this); // ordinary console.log(event.target); // ordinary }); btnNodeArrow.addEventListener(\"click\", event => { console.log(this); // Window console.log(event.target); // ordinary }); 事件传播 HTML on和DOM on的方式都不支持为同一监听事件绑定多个回调函数： ordinary arrow \"use strict\"; // 总会执行第2个 let btnNodeOrdinary = document.querySelector(\"button:first-of-type\"); btnNodeOrdinary.onclick = ordinaryFunc01; btnNodeOrdinary.onclick = ordinaryFunc02; function arrowFunc01(target, event) { console.log(\"run arrow function 01\"); } function arrowFunc02(target, event) { console.log(\"run arrow function 02\"); } function ordinaryFunc01(event) { console.log(\"run ordinary function 01\"); } function ordinaryFunc02(event) { console.log(\"run ordinary function 02\"); } 但是addEventListener()支持为同一监听事件绑定多个回调函数，当事件发生时他会依次进行处理。 整个执行的过程我将其称之为事件传播过程： click me \"use strict\"; let btnNode = document.querySelector(\"button\"); btnNode.addEventListener(\"click\", event => { console.log(\"1\"); }); btnNode.addEventListener(\"click\", event => { console.log(\"2\"); }); btnNode.addEventListener(\"click\", event => { console.log(\"3\"); }); 如下图所示： on是什么意思 on其实就是开始监听的意思。 通过HTML属性或者DOM属性绑定回调函数时，需要在事件名前加入on，比如click就变为onclick，copy变为oncopy。 而使用事件监听的方式则不需要加上on，因为addEventListener()本身就有监听的功能。 默认行为 默认事件 某些元素会有一些默认监听的行为。 比如： 标签点击后会自动进行页面跳转 点击后会自动搜集表单项并提交 在某些场景下我们需要对这些具有默认行为的元素绑定事件，并且还要让其阻止默认行为的发生。 阻止默认 阻止默认行为一共有2个方案： 适用于任何场景：在回调函数中加上event.preventDefault()即可 仅适用于DOM on：在回调函数中return false即可 1）适用于任何场景：在回调函数中加上event.preventDefault()即可： click me \"use strict\"; function linkClick(target, event) { event.preventDefault(); }; 2）仅适用于DOM on：在回调函数中return false即可： click me \"use strict\"; let linkNode = document.querySelector(\"a\"); linkNode.onclick = function(event){ return false }; 左键双击选中文本 左键双击选中文本是一个常见的默认行为，我们只需要在元素身上添加上属性onselectstart=\"return false\"即可阻止选中： content \"use strict\"; let divNode = document.querySelector(\"div\"); divNode.addEventListener(\"dblclick\", event=>{ console.log(\"run\"); }); 右键单击打开菜单 右键单击打开菜单是一个常见的默认行为，我们只需要在元素身上添加上属性oncontextmenu=\"return false\"即可阻止选中： 点击鼠标右键试试? \"use strict\"; let divNode = document.querySelector(\"div\"); document.addEventListener(\"contextmenu\", event => { divNode.innerText = \"是不是发现不好使了?\" }); 冒泡行为 冒泡行为 元素是支持嵌套的，当子元素与父元素都绑定了相同的一个事件时，子元素事件触发后会进行事件的冒泡传递，也就是说父元素也会自动的执行这一事件，冒泡会一直到达HTML根元素标签。 大部分事件都会冒泡，但有的事件不会，如focus事件 event.target属性是对事件原始目标的引用，这里的原始目标指最初派发（dispatch）事件时指定的目标 event.currentTarget属性是当前执行事件的目标对象，如果有事件冒泡发生，它将是不断变化的 event.target和event.currentTarget的区别在于，谁引起了本次事件的产生，谁正在执行本次事件的处理 如下图所示： 示例演示： click me \"use strict\"; // 传播阶段 document.querySelector(\"main div button\").addEventListener(\"click\", event => { console.log(\"button click event callbackfn run 1\"); console.log(`current target : ${event.currentTarget.tagName}, target : ${event.target.tagName}`); }); document.querySelector(\"main div button\").addEventListener(\"click\", event => { console.log(\"button click event callbackfn run 2\"); console.log(`current target : ${event.currentTarget.tagName}, target : ${event.target.tagName}`); }); document.querySelector(\"main div button\").addEventListener(\"click\", event => { console.log(\"button click event callbackfn run 3\"); console.log(`current target : ${event.currentTarget.tagName}, target : ${event.target.tagName}`); }); // 冒泡阶段 document.querySelector(\"main div\").addEventListener(\"click\", event => { console.log(\"div click event callbackfn run\"); console.log(`current target : ${event.currentTarget.tagName}, target : ${event.target.tagName}`); }); document.querySelector(\"main\").addEventListener(\"click\", event => { console.log(\"main click event callbackfn run\"); console.log(`current target : ${event.currentTarget.tagName}, target : ${event.target.tagName}`); }); 执行结果： button click event callbackfn run 1 current target : BUTTON, target : BUTTON button click event callbackfn run 2 current target : BUTTON, target : BUTTON button click event callbackfn run 3 current target : BUTTON, target : BUTTON div click event callbackfn run current target : DIV, target : BUTTON main click event callbackfn run current target : MAIN, target : BUTTON 阻止冒泡 阻止事件冒泡的方法有2个： 在处理程序中添加event.stopPropagation() 在处理程序中添加event.stopImmediatePropagation() event.stopPropagation()用于阻止父元素的同事件监听回调不再执行。 event.stopImmediatePropagation()用于阻止父元素的同事件监听回调不再执行，并且相同元素的相同事件类型的监听事件也不再执行。 如下图所示： 根据不同的情况，选用不同的冒泡阻止方案。 一般来说使用event.stopPropagation()情况会更多一点： click me \"use strict\"; // 传播阶段 document.querySelector(\"main div button\").addEventListener(\"click\", event => { console.log(\"button click event callbackfn run 1\"); console.log(`current target : ${event.currentTarget.tagName}, target : ${event.target.tagName}`); event.stopPropagation(); }); document.querySelector(\"main div button\").addEventListener(\"click\", event => { console.log(\"button click event callbackfn run 2\"); console.log(`current target : ${event.currentTarget.tagName}, target : ${event.target.tagName}`); }); document.querySelector(\"main div button\").addEventListener(\"click\", event => { console.log(\"button click event callbackfn run 3\"); console.log(`current target : ${event.currentTarget.tagName}, target : ${event.target.tagName}`); }); // 冒泡阶段 document.querySelector(\"main div\").addEventListener(\"click\", event => { console.log(\"div click event callbackfn run\"); console.log(`current target : ${event.currentTarget.tagName}, target : ${event.target.tagName}`); event.stopPropagation(); }); document.querySelector(\"main\").addEventListener(\"click\", event => { console.log(\"main click event callbackfn run\"); console.log(`current target : ${event.currentTarget.tagName}, target : ${event.target.tagName}`); event.stopPropagation(); }); 执行结果： button click event callbackfn run 1 current target : BUTTON, target : BUTTON button click event callbackfn run 2 current target : BUTTON, target : BUTTON button click event callbackfn run 3 current target : BUTTON, target : BUTTON 事件捕获 captrue 事件执行周期由捕获 > 目标 > 传播 > 冒泡这4个阶段组成。 我们可以设置addEventListener()的options参数为true或{ capture: true } 让其在捕获阶段执行事件处理程序。 怎么样表述这一行为呢？其实同冒泡一样，它也必须建立在元素嵌套的基础上进行，当父元素和子元素都监听了同一个事件后，父元素会先执行第一个监听回调，然后再进行正常的逻辑，如下图所示： 事件捕获在实际使用中频率不高。 如下所示： click me \"use strict\"; document.querySelector(\"main\").addEventListener(\"click\", event => { console.log(\"main click event callbackfn run\"); }, { capture: true }); document.querySelector(\"main div\").addEventListener(\"click\", event => { console.log(\"div click event callbackfn run\"); }, { capture: true }); document.querySelector(\"main div button\").addEventListener(\"click\", event => { console.log(\"button click event callbackfn run\"); }, { capture: true }); 执行结果： main click event callbackfn run 1 current target : MAIN, target : BUTTON button click event callbackfn run current target : BUTTON, target : BUTTON div click event callbackfn run current target : DIV, target : BUTTON main click event callbackfn run 2 current target : MAIN, target : BUTTON main click event callbackfn run 3 current target : MAIN, target : BUTTON 事件代理 未来元素 我们想让所有已有的，包括未来可能会创建的元素都监听click事件，该怎么做呢？ 目前能掌握到最简单的方法就是先将已有的元素都添加上click事件，未来创建的元素在创建时也添加上click事件： 65 66 67 add new li \"use strict\"; let ulNode = document.querySelector(\"ul\"); let btnNode = document.querySelector(\"button\"); // 先将所有已有的li添加上事件 Array.prototype.forEach.call(ulNode.children, (element, index, lst) => { element.addEventListener(\"click\", liCallbackfn) }) // 添加新的标签，并为其绑定事件 btnNode.addEventListener(\"click\", event => { let lastLiNode = ulNode.lastElementChild; let lastText = lastLiNode.innerText; let newNode = document.createElement(\"li\"); newNode.innerText = Number.isNaN(Number.parseInt(lastText)) ? lastText.charCodeAt() + 1 : Number(lastText) + 1; newNode.addEventListener(\"click\", liCallbackfn); lastLiNode.after(newNode); }) function liCallbackfn(event) { event.target.innerText = String.fromCharCode(event.target.innerText); } 委托代理 上述的实现方案非常笨，我们可以借助事件冒泡的思路来完成一个事件委托的操作。 实现过程如下： 不为具体的子元素设置监听事件 将监听事件设置在父元素上，让父元素监听这一个事件 在子元素上点击时，这一行为必定发生在父元素的区域内，此时将触发父元素监听回调 父元素通过event.target判定事件发生源是否是指定的某子元素即可，如果是则开始正常执行回调逻辑，如果不是则不执行回调逻辑 实现代码： 65 66 67 add new li \"use strict\"; let ulNode = document.querySelector(\"ul\"); let btnNode = document.querySelector(\"button\"); // 直接给ul绑定事件 ulNode.addEventListener(\"click\", event => { // 如果事件目标是li，执行li的回调 if (event.target.tagName === \"LI\") { liCallbackfn(event); } }) // 添加新的标签 btnNode.addEventListener(\"click\", event => { let lastLiNode = ulNode.lastElementChild; let lastText = lastLiNode.innerText; let newNode = document.createElement(\"li\"); newNode.innerText = Number.isNaN(Number.parseInt(lastText)) ? lastText.charCodeAt() + 1 : Number(lastText) + 1; lastLiNode.after(newNode); }) function liCallbackfn(event) { event.target.innerText = String.fromCharCode(event.target.innerText); } 将事件代理进行完善，将它做成一个on方法并添加进Element原型对象中，使所有的DOM节点都能进行调用： 65 66 67 add new li \"use strict\"; Element.prototype.on = function (eventType, eventTarget, callbackfn) { this.addEventListener(eventType, event => { if (event.target.tagName === eventTarget.toUpperCase()) { callbackfn(event); } }) } let ulNode = document.querySelector(\"ul\"); let btnNode = document.querySelector(\"button\"); // 委托的DOM节点 代理的事件 事件目标 事件目标的回调函数 ulNode.on(\"click\", \"li\", (event) => { event.target.innerText = String.fromCharCode(event.target.innerText); }) // 添加新的标签 btnNode.addEventListener(\"click\", event => { let lastLiNode = ulNode.lastElementChild; let lastText = lastLiNode.innerText; let newNode = document.createElement(\"li\"); newNode.innerText = Number.isNaN(Number.parseInt(lastText)) ? lastText.charCodeAt() + 1 : Number(lastText) + 1; lastLiNode.after(newNode); }) 文档事件 常用事件 文档常用事件如下所示，它们一般绑定给window对象。 事件 描述 load 文档解析完成，且所有外部资源加载完成时 DOMContentLoaded 文档解析完成时 beforeunload 文档刷新或关闭时 unload 文档卸载时 load load事件会在文档解析完成，且所有外部资源加载完成时触发。 一般我们会将其作为JavaScript的入口函数使用： \"use strict\"; window.onload = function (event) { console.log(\"文档加载完成,外部资源加载完成\"); } DOMContentLoaded DOMContentLoaded事件会在文档解析完成时触发，它不需要等待所有外部资源加载完成。 该事件只能使用addEventListener()进行设置。 相较于load事件，它更适合作为JavaScript的入口函数，在jQuery库中就是采用该事件作为入口函数的： \"use strict\"; window.addEventListener(\"DOMContentLoaded\", function (event) { console.log(\"文档加载完成\"); }) beforeunload beforeunload事件会在文档刷新或关闭时触发。 在某些浏览器上，该事件的回调函数返回值将作为提示信息弹出，或者你可以通过event.returnValue进行设置 部分浏览器无法使用addEventListener()绑定该事件 必须在网页上做出更改后，刷新或关闭时才会弹出提示 所设定的值并不是一定会显示的，这与浏览器版本有关 该事件常见于一些小网站上，当然我印象最深的地方是拼多多： \"use strict\"; window.onbeforeunload = function (event) { // 兼容IE8和Firefox 4之前的版本 event.returnValue = '关闭提示'; // Chrome, Safari, Firefox 4+, Opera 12+ , IE 9+ return '关闭提示'; }; unload unload事件会在文档卸载时触发，它位于beforeunload事件之后。 此时不能使用alert()、confirm()等交互窗指令 发生错误也不会阻止页面关闭或刷新 如下示例： \"use strict\"; window.onunload = function (event) { console.log(\"刷新或关闭了\"); }; 表单事件 常用事件 可用于监听的表单事件如下表所示： 事件 描述 focus 元素获取焦点后触发 blur 元素失去焦点后触发 input 元素内容发生改变后触发 click 单击了某个表单项 change 元素内容发生改变并且失去焦点时触发 submit 提交表单时触发 注意，node.focus()和node.blur()可强制的让元素获取、失去焦点。 另外，如果input的type是submit，则可以调用submit()方法进行表单提交。 此外，如果input的type是file，则可以调用click()方法来选择文件。 鼠标事件 常用事件 可用于监听的鼠标事件如下表所示： 事件 描述 click 鼠标左键单击（同时触发mousedown以及mouseup） dblclick 鼠标左键双击 mousedown 鼠标左键、右键按下 mouseup 鼠标左键、右键松开 mouseover 鼠标移入时 mousemove 鼠标移动时 mouseout 鼠标移出时 mouseenter 鼠标移入时，不产生冒泡行为 mouseleave 鼠标移出时，不产生冒泡行为 copy 拷贝时 scroll 滚动时 测试代码： div:nth-child(1) { height: 200px; width: 200px; background-color: #ddd; overflow: scroll; } content \"use strict\"; class MouseEventTest { constructor(node) { // 添加测试项 node.addEventListener(\"copy\", this); node.addEventListener(\"scroll\", this); } handleEvent(event) { this[event.type](event.target, event); } click(target, event) { console.log(\"左键单击\"); } dblclick(target, event) { console.log(\"左键双击\"); } mousedown(target, event) { console.log(\"某个键按下\"); } mouseup(target, event) { console.log(\"某个键松开\"); } mouseover(target, event) { console.log(\"鼠标移入\"); } mousemove(target, event) { console.log(\"鼠标移动\"); } mouseout(target, event) { console.log(\"鼠标移出\"); } mouseenter(target, event) { console.log(\"鼠标移动入 不冒泡\"); } mouseleave(target, event) { console.log(\"鼠标移出, 不冒泡\"); } copy(target, event) { console.log(\"拷贝\"); } scroll(target, event) { console.log(\"滚动\"); } } new MouseEventTest(document.querySelector('div')) 事件属性 鼠标事件对象是MouseEvent，它派生自UIEvent，而UIEvent派生自Event。 该事件对象可调用属性如下： 属性 描述 MouseEvent.which 鼠标事件触发时按下的按键 MouseEvent.button 鼠标事件触发时是否按下了某个鼠标按键，将返回1个数值 MouseEvent.buttons 鼠标事件触发时是否按下了多个鼠标按键，将返回1个或N个数值 MouseEvent.altKey 鼠标事件触发时是否按下了alt键，返回Boolean值 MouseEvent.ctrlKey 鼠标事件触发时是否按下了ctrl键，返回Boolean值 MouseEvent.shiftKey 鼠标事件触发时是否按下了shift键，返回Boolean值 MouseEvent.metaKey 鼠标事件触发时是否按下了window键，返回Boolean值 MouseEvent.offsetX 鼠标位于当前目标元素中的X坐标 MouseEvent.offsetY 鼠标位于当前目标元素中的Y坐标 MouseEvent.pageX 鼠标位于当前整个文档中的X坐标 MouseEvent.pageY 鼠标位于当前整个文档中的Y坐标 MouseEvent.clientX 鼠标位于当前整个窗口中的X坐标 MouseEvent.clientY 鼠标位于当前整个窗口中的Y坐标 MouseEvent.screenX 鼠标位于当前整个屏幕中的X坐标 MouseEvent.screenY 鼠标位于当前整个屏幕中的Y坐标 MouseEvent.relatedTarget 鼠标事件的次要目标（如果有的话） relatedTarget属性主要针对mouseover、mouseout事件： mouseover：鼠标移入到当前元素之前在哪个元素身上 mouseout：鼠标移出到当前元素之后在哪个元素身上 当无来源，或移动到窗口外时值为null which属性的按键代号如下所示： 0：左键 1：中键 2：右键 在IE8之前版本中代号有所不同： 0：没有按下任何按键 1：按下左键 2：按下右键 3：同时按下左、右键 4：按下中键 5：同时按下左、中键 6：同时按下右、中键 7：3个按键同时按下 键盘事件 常用事件 可用于监听的键盘事件如下表所示： 事件 描述 keydown 按下某个键、长按时将重复触发 keyup 松开某个键 keypress 按下并松开某个键、长按时将重复触发 测试代码： div:nth-child(1) { height: 200px; width: 200px; background-color: #ddd; overflow: scroll; } \"use strict\"; class MouseEventTest { constructor(node) { // 添加测试项 node.addEventListener(\"keydown\", this); node.addEventListener(\"keyup\", this); node.addEventListener(\"keypress\", this); } handleEvent(event) { this[event.type](event.target, event); } keydown(target, event) { console.log(\"按下或长按了\"); } keyup(target, event) { console.log(\"松开了\"); } keypress(target, event) { console.log(\"按下并松开了\"); } } new MouseEventTest(document.querySelector('textarea')) 事件属性 鼠标事件对象是KeyboardEvent，它派生自UIEvent，而UIEvent派生自Event。 该事件对象可调用属性如下： 属性 描述 KeyboardEvent.key 返回按键字符 KeyboardEvent.code 返回按键编码 KeyboardEvent.keyCode 返回按键ASCII码 KeyboardEvent.altKey 键盘事件触发时是否按下了alt键，返回Boolean值 KeyboardEvent.ctrlKey 键盘事件触发时是否按下了ctrl键，返回Boolean值 KeyboardEvent.shiftKey 键盘事件触发时是否按下了shift键，返回Boolean值 KeyboardEvent.metaKey 键盘事件触发时是否按下了window键，返回Boolean值 KeyboardEvent.key释义： 按键字符，按键的字符含义表示，大小写不同。不能区分左右ALT等。不同语言操作系统下值会不同 KeyboardEvent.code释义： 按键编码，字符以Key开始，数字以Digit开始，特殊字符有专属名字。左右ALT键字符不同。 不同布局的键盘值会不同 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:48 "},"前端专栏/JavaScript/空间坐标.html":{"url":"前端专栏/JavaScript/空间坐标.html","title":"空间坐标","keywords":"","body":"基础知识 参考画布分为视口和文档2个概念。 网页很多都是多屏，所以文档尺寸一般大于视口尺寸 视口尺寸不包括浏览器工具条、菜单、标签、状态栏等 当打开控制台后，视口尺寸相应变小 文档坐标在页面滚动时不发生改变 视口坐标的操作需要考虑滚动条的位置 视口相当于postion:fixed，而文档相当于postion:absolute 如下图所示： 视口大小 以下属性均可获取视口大小： 属性 描述 window.innerWidth 窗口宽度（包含X轴滚动条、不常用） window.innerHeight 窗口高度（包含Y轴滚动条、不常用） document.documentElement.clientWidth 文档宽度 document.documentElement.clientHeight 文档高度 推荐使用document来获取文档可见区域的宽高，不包含浏览器工具条、菜单、标签、状态栏等： Height: Width: \"use strict\"; document.querySelector(\"div:nth-child(1)\").innerHTML += document.documentElement.clientHeight; document.querySelector(\"div:nth-child(2)\").innerHTML += document.documentElement.clientWidth; 单位均是px，即像素点。 元素信息 元素在页面中拥有多个描述几何数值的尺寸，如下所示： 属性说明： 属性 描述 offsetParent 获取该元素拥有绝对定位的父级元素，会一直向上找，body、tbale、th、td clientWidth 获取该元素的宽度尺寸，不包含边框，仅包含内边距和内容区域 clientHeight 获取该元素的高度尺寸，不包含边框，仅包含内边距和内容区域 clientLeft 表示一个元素的左边框的宽度 clientTop 表示一个元素的上边框的宽度 offsetWidth 获取该元素的宽度尺寸，包括内边距与边框和滚动条 offsetHeight 获取该元素的高度尺寸，包括内边距与边框和滚动条 offsetLeft 获取该元素从边框开始相对于offsetParent的X轴距离 offsetTop 获取该元素从边框开始相对于offsetParent的Y轴距离 scrollWidth 获取该元素的宽度尺寸，包括内边距与边框以及溢出区域的尺寸 scrollHeight 获取该元素的高度尺寸，包括内边距与边框以及溢出区域的尺寸 scrollLeft 获取水平滚动条左侧已经滚动的宽度 scrollTop 获取垂直滚动条顶部已经滚动的高度 代码示例： * { margin: 0; padding: 0; } body { display: flex; justify-content: center; align-items: center; } div { width: 200px; height: 200px; background-color: #eee; padding: 10px; margin: 10px; border: 1px solid #ddd; } \"use strict\"; let divNode = document.querySelector(\"div\"); console.log(divNode.offsetParent); console.log(divNode.clientWidth); // 220 console.log(divNode.clientHeight); // 220 console.log(divNode.clientLeft); // 1 console.log(divNode.clientTop); // 1 console.log(divNode.offsetWidth); // 222 console.log(divNode.offsetHeight); // 222 console.log(divNode.offsetLeft); // 638 console.log(divNode.offsetTop); // 96 你也可以使用getBoundingClientRect()方法来获取元素矩形信息，计算结果的矩形尺寸不包括外边距： * { margin: 0; padding: 0; } body { display: flex; justify-content: center; align-items: center; } div { width: 200px; height: 200px; background-color: #eee; padding: 10px; margin: 10px; border: 1px solid #ddd; } \"use strict\"; let divNode = document.querySelector(\"div\"); console.log(divNode.getBoundingClientRect()); // bottom: 237.4000005722046 // height: 222 // left: 637.7999877929688 // right: 859.7999877929688 // top: 15.40000057220459 // width: 222 // x: 637.7999877929688 // y: 15.40000057220459 对于inline元素来说，你可以使用getClientRects()方法来获取该元素每行所占据的尺寸： span { width: 200px; overflow: auto; } 网页很多都是多屏，所以文档尺寸一般大于视口尺寸,当打开控制台后，视口尺寸相应变小。网页很多都是多屏，所以文档尺寸一般大于视口尺寸,当打开控制台后，视口尺寸相应变小。网页很多都是多屏，所以文档尺寸一般大于视口尺寸,当打开控制台后，视口尺寸相应变小。 \"use strict\"; let span = document.querySelector('span') let info = span.getClientRects() console.log(info) 根据视口大小，行内文字可能会产生折叠，如产生折叠就会出现多行。 以下是2行时的信息： // 第一行信息 bottom: 29.33333396911621 height: 21.33333396911621 left: 8 right: 1683.5555419921875 top: 8 width: 1675.5555419921875 x: 8 y: 8 // 第二行信息 bottom: 50.66666793823242 height: 21.33333396911621 left: 8 right: 264 top: 29.33333396911621 width: 256 x: 8 y: 29.33333396911621 坐标判断 JavaScript提供了2种方法获取当前在视口某个坐标上的元素。 坐标都是从左上角进行计算的 如果指定的坐标点在视口外，将返回None 方法如下： 方法 描述 element.elementsFromPoint() 返回指定坐标点所在的元素集合 element.elementFromPoint() 返回指定坐标点所在的顶级元素 示例如下： * { margin: 0; padding: 0; } body, main, div, article { display: flex; justify-content: center; align-items: center; } main { width: 200px; height: 200px; background-color: #eee; padding: 10px; margin: 10px; border: 1px solid #ddd; } content \"use strict\" let position = [500, 200]; // 获取集合 console.log(document.elementsFromPoint(...position)); // (3) [main, body, html] // 获取顶级元素 console.log(document.elementFromPoint(...position)); // main 滚动控制 以下是用于控制元素滚动的相关方法或数学： 方法 说明 参数说明 window.pageXOffset 文档相对窗口水平滚动的像素距离 window.pageYOffset 文档相对窗口垂直滚动的像素距离 element.scrollLeft 获取和设置元素X轴滚动位置 属性，通过=进行设置 element.scrollTop 获取和设置元素Y轴滚动位置 属性，通过=进行设置 element.scrollLeft() 元素X轴滚动位置 方法，通过传参进行设置 element.scrollTop() 元素Y轴滚动位置 方法，通过传参进行设置 element.scrollBy() 按偏移量进行滚动内容 参数为对象，{top : 垂直偏移量, left : 水平偏移量, behavior : '滚动方式'} element.scroll() 以及element.scrollTo() 滚动到指定的具体位置 参数为对象，{top : X轴文档位置, left : Y轴文档位置, behavior : '滚动方式'} element.scrollIntoView(bool) 定位到顶部或底部 参数为true元素定位到顶部，为false定位到窗口底部 1）使用scrollBy()滚动文档： setInterval(() => { // 相当于每个3秒往下滚动30px，参照于上次所停留位置，smooth平滑滚动 document.documentElement.scrollBy({ top: 30, behavior: \"smooth\" }, 100); }, 3000); 2）使用scroll()滚动到指定位置： setInterval(() => { // 按照绝对位置，往下滚动30px，只走一次，smooth平滑滚动 document.documentElement.scroll({ top: 30, behavior: \"smooth\" }, 100); }, 3000); 3）使用scrollIntoView()方法实现滚动操作，参数可以是布尔值或对象。 参数为 true时顶部对齐，相当于{block: \"start\"} 参数为 false时底部对齐，相当于{block: “end\"} 定义 {behavior : smooth}为平滑滚动 Document section { height: 2000px; background: linear-gradient(to bottom, red, green, blue, yellow) } body button { position: fixed; bottom: 10%; width: 100px; height: 30px; } body button:first-of-type { right: 5%; } body button:last-of-type { left: 5%; } 头部 TOP BOTTOM 底部 \"use strict\"; document.querySelector(\"button.top\").addEventListener(\"click\", (event) => { let h1 = document.querySelector(\"header h1\"); h1.scrollIntoView({ behavior: \"smooth\", }) }); document.querySelector(\"button.bottom\").addEventListener(\"click\", (event) => { let h1 = document.querySelector(\"footer h1\"); h1.scrollIntoView({ behavior: \"smooth\", }) }) Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:48 "},"前端专栏/JavaScript/XmlHttpRequest.html":{"url":"前端专栏/JavaScript/XmlHttpRequest.html","title":"XmlHttpRequest","keywords":"","body":"基本介绍 XMLHttpRequest XMLHttpRequest是JavaScript中原生的，历史悠久的一种发送网络请求的方案。 基本上所有前端框架对于网络请求的部分都是基于它来完成的。 在没有学习XMLHttpRequest之前，与后端的交互我们都会使用来进行，但这样做会引起页面的刷新。 那么在学习了XMLHttpRequest之后，就可以使页面不刷新的同时和后端进行数据交互了，这是一种非常常用的技术，俗称ajax，因此要好好掌握。 在本章节中我们将了解XMLHttpRequest的基本用法，并且会实现一个与jQuery.ajax功能百分之九十相似的网络请求组件。 我是没有读过jQuery.ajax源码的，并且我也不是一个专精前端的程序员，所以后面的代码写的可能不太好，仅和大家在此做个交流。 后端代码 为了方便后续前后端交互的代码测试，我们后端采用Python-flask框架来完成。 IP：localhost PORT：5700 代码如下： from flask import Flask from flask import request from flask import make_response from flask import jsonify app = Flask(__name__) @app.after_request # 解决CORS跨域请求 def cors(response): response.headers['Access-Control-Allow-Origin'] = \"*\" if request.method == \"OPTIONS\": # 允许的请求头 response.headers[\"Access-Control-Allow-Headers\"] = \"Origin,Content-Type,Cookie,Accept,Token,authorization,user_head\" return response @app.route(\"/get\", methods=[\"get\"]) def get(): user_head = request.headers.get(\"user_head\") user_params = request.args print(user_params) return jsonify(user_params, user_head) @app.route(\"/post\", methods=[\"post\"]) def post(): user_head = request.headers.get(\"user_head\") user_params = request.form print(user_params) return jsonify(user_params, user_head) @app.route(\"/json\", methods=[\"post\"]) def json(): user_head = request.headers.get(\"user_head\") user_params = request.json return jsonify(user_params, user_head) @app.route(\"/file\", methods=[\"post\"]) def file(): file_obj = request.files.get(\"avatar\") if file_obj is None: return make_response(jsonify(\"unload avatar\"), 400) file_name = file_obj.filename file_obj.save(file_name) return jsonify(\"upload avatar success!!\") if __name__ == \"__main__\": app.run(host=\"localhost\", port=5700, debug=True) open() open()方法用于创建并返回一个请求对象（单纯创建，并不发送）。 参数释义： method：请求方式 url：请求地址 async：是否异步请求 注意：如果method为GET方式，则需要我们手动在url中添加参数 请求相关 send() send()方法用于发送一次网络请求。 参数释义： body：method为POST时携带的请求体数据，必须是字符串类型 注意：如果method为GET方式，则直接xhr.send(null)即可，因为GET请求没有请求体 setRequestHeader() setRequestHeader()方法用于设置请求头。 参数释义： header：请求头的key value：请求头的value 注意：每次只能设置一组请求头键值对，如果要设置多组请求头键值对请多次调用该方法 abort() abort()方法用于取消本次网络请求。 响应相关 getAllResponseHeaders() getAllResponseHeaders()方法用于获取所有响应头数据。 返回的数据类型为字符串。 getResponseHeader() getResponseHeader()方法用于获取响应头中指定header的value。 返回的数据类型为字符串。 status status属性用于返回服务端响应的HTTP响应状态码。 以下是常见的HTTP响应状态码： 200：请求成功 404：请求失败，请求的资源错误 500：请求失败，服务器内部出现错误 302：重定向 304：缓存优先 statesText statesText属性用于返回服务端响应的状态文本。 如OK、NotFound等字样。 responseText responseText属性用于返回响应体主体内容。 返回的数据类型为字符串。 回调函数 readyState readyState属性用于返回一个整数类型的状态值，它表明当前xhr对象的请求状态。 共有5种形态： 0：未初始化，尚未调用open()方法 1：已初始化，调用了open()方法，但还未调用send()方法 2：已发送，调用了send()方法，但还未收到服务端响应 3：已接收，已经收到了部分服务端响应数据 4：已完成，已经收到了全部服务端响应数据 readystatechange readystatechange事件用于设置xhr对象的readState状态发生改变时所执行的回调函数。 简单使用 contentType说明 contentType是HTTP协议中的一个请求头，它包含了浏览器告知后端服务器本次发送数据的格式。 它和表单的enctype参数类似，共有以下一些常见值的选项： 常见的媒体格式类型如下： text/html ： HTML格式 text/plain ：纯文本格式 text/xml ： XML格式 image/gif ：gif图片格式 image/jpeg ：jpg图片格式 image/png：png图片格式 以application开头的媒体格式类型： application/xhtml+xml ：XHTML格式 application/xml： XML数据格式 application/atom+xml ：Atom XML聚合格式 application/json： JSON数据格式 application/pdf：pdf格式 application/msword ： Word文档格式 application/octet-stream ： 二进制流数据（如常见的文件下载） application/x-www-form-urlencoded ： 中默认的enctype，form表单数据被编码为key/value格式发送到服务器（表单默认的提交数据的格式） 另外一种常见的媒体格式是上传文件之时使用的： multipart/form-data ： 在表单中进行文件上传时，就需要使用该格式 我们接下来会使用2种最主流的格式进行试验： application/x-www-form-urlencoded （默认的GET和POST数据格式） application/json（前端需要发送的JSON格式数据） GET请求 发送GET请求： \"use strict\"; let xhr = new XMLHttpRequest(); // 绑定回调函数 xhr.addEventListener(\"readystatechange\", () => { switch (xhr.readyState) { case 0: console.log(\"未初始化，尚未调用open()方法\"); break case 1: console.log(\"已初始化，调用了open()方法，但还未调用send()方法\"); break case 2: console.log(\"已发送，调用了send()方法，但还未收到服务端响应\"); break case 3: console.log(\"已接收，已经收到了部分服务端响应数据\"); break default: console.log(\"已完成，已经收到了全部服务端响应数据\"); if (xhr.statusText === \"OK\") { console.log(\"请求成功\"); console.log(xhr.status); console.log(xhr.statusText); console.log(xhr.responseText); } else { console.log(\"请求失败\"); console.log(xhr.status); console.log(xhr.statusText); console.log(xhr.responseText); } } }) // 请求方式，请求地址与参数，是否开启异步提交 提交的数据格式为url编码 xhr.open(\"GET\", \"http://localhost:5700/get?username=Jack&userage=18\", true); // 设置请求头，提交的数据格式为url编码 xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded; charset-UTF-8'); xhr.setRequestHeader('user_head', 'HELLO WORLD'); // 发送请求 xhr.send(null); POST请求 发送POST请求： \"use strict\"; let xhr = new XMLHttpRequest(); // 绑定回调函数 xhr.addEventListener(\"readystatechange\", () => { switch (xhr.readyState) { case 0: console.log(\"未初始化，尚未调用open()方法\"); break case 1: console.log(\"已初始化，调用了open()方法，但还未调用send()方法\"); break case 2: console.log(\"已发送，调用了send()方法，但还未收到服务端响应\"); break case 3: console.log(\"已接收，已经收到了部分服务端响应数据\"); break default: console.log(\"已完成，已经收到了全部服务端响应数据\"); if (xhr.statusText === \"OK\") { console.log(\"请求成功\"); console.log(xhr.status); console.log(xhr.statusText); console.log(xhr.responseText); } else { console.log(\"请求失败\"); console.log(xhr.status); console.log(xhr.statusText); console.log(xhr.responseText); } } }) // 请求方式，请求地址与参数，是否开启异步提交 xhr.open(\"POST\", \"http://localhost:5700/post\", true); // 设置请求头，提交的数据格式为url编码 xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded; charset-UTF-8'); xhr.setRequestHeader('user_head', 'HELLO WORLD'); // 发送请求，提交的数据格式为url编码 xhr.send(\"username=Jack&userage=18\"); JSON格式 JSON格式的数据只能由POST请求发起，并且contentType应设置为appliction/json。 示例如下： \"use strict\"; let xhr = new XMLHttpRequest(); // 绑定回调函数 xhr.addEventListener(\"readystatechange\", () => { switch (xhr.readyState) { case 0: console.log(\"未初始化，尚未调用open()方法\"); break case 1: console.log(\"已初始化，调用了open()方法，但还未调用send()方法\"); break case 2: console.log(\"已发送，调用了send()方法，但还未收到服务端响应\"); break case 3: console.log(\"已接收，已经收到了部分服务端响应数据\"); break default: console.log(\"已完成，已经收到了全部服务端响应数据\"); if (xhr.statusText === \"OK\") { console.log(\"请求成功\"); console.log(xhr.status); console.log(xhr.statusText); console.log(xhr.responseText); } else { console.log(\"请求失败\"); console.log(xhr.status); console.log(xhr.statusText); console.log(xhr.responseText); } } }) // 请求方式，请求地址与参数，是否开启异步提交 xhr.open(\"POST\", \"http://localhost:5700/json\", true); // 设置请求头 xhr.setRequestHeader('Content-Type', 'application/json'); xhr.setRequestHeader('user_head', 'HELLO WORLD'); // 发送请求 xhr.send(JSON.stringify({ \"k1\": \"v1\", \"k2\": \"v2\" })); 了解jQuery.ajax的原理 实现代码 原生的XmlHttpRequest所提供的方法太过于底层，因此我们可以对其进行封装。 这里以jQuery的Ajax为蓝本，实现一个类似功能的小组件，也是为了方便后期更加了解jQuery.Ajax()做准备。 我们准备实现的功能： 实现发送GET请求 实现发送POST请求 实现更加方便的添加请求头 实现发送JSON格式的请求数据 实现自动反序列化JSON格式的响应数据 实现文件上传 实现如下： \"use strict\"; class Ajax { constructor({ url, contentType, headers, data, beforeSend, dataFilter, success, error, complete, dataType = \"\", processData = true, type, method = type, traditional = false }) { // url：发送请求的地址，String类型 // type：发送请求的方式，String类型，它和method都可以使用 // method：发送请求的方式，String类型，它和type都可以使用 // contentType：数据编码格式，相当于form表单的enctype，String类型 // headers：设置的请求头，Object类型 // dataType：接收的响应数据类型，如果是json则自动进行反序列化，String类型 // data：发送的数据，post请求方式发送在请求体内，get请求发送会将其添加在url后，Object类型 // processData：如果为true，浏览器将采用application/x-www-form-urlencoded方式对数据进行编码，如果为false则按照传入的contentType为准，bool类型 // traditional：如果前端传递的是一个Array，如{\"k1\":[1,2,3,4]}则需要添加一个属性traditional:true，否则后端将接收不到该参数。（实际上接受的时候要使用request.POST.get(\"k1[]\")）来进行接受，这是有问题的 this.xhr = new XMLHttpRequest(); this.url = url; this.type = (type || method).toUpperCase(); this.method = method.toUpperCase(); this.headers = headers; this.contentType = processData && !contentType ? \"application/x-www-form-urlencoded\" : contentType; this.data = data; this.dataType = dataType.toLowerCase(); this.traditional = traditional; // beforeSend 在发送请求之前调用，并且传入一个XMLHttpRequest作为参数。 // dataFilter 在请求成功之后调用。传入返回的数据以及\"dataType\"参数的值。并且必须返回新的数据（可能是处理过的）传递给success回调函数，也就是说它会在success与error之前调用 // success 在请求成功之后调用。传入返回后的数据，以及包含成功代码的字符串 // error 在请求出错时调用。传入XMLHttpRequest对象，描述错误类型的字符串以及一个异常对象（如果有的话） // complete 当请求完成之后调用这个函数，无论成功或失败。传入XMLHttpRequest对象，以及一个包含成功或错误代码的字符串 this.beforeSend = beforeSend || function (xhr) { }; // 该函数默认会自动的根据dataType对象responseText进行解码 this.dataFilter = dataFilter || function (data, ty) { switch (ty) { case \"application/json\": case \"json\": this.xhr.responseJSON = JSON.parse(data); return this.xhr.responseJSON default: return data } }; this.success = success || function (data, statusText) { }; this.error = error || function (xhr, statusText) { }; this.complete = complete || function (xhr, statusText) { }; // 绑定回调函数 this.bindStateChangeEvent(); // 设置发送的数据并发送 this.setRequestData(); // 设置发送方式 this.setXhrOpen(); // 设置请求头 this.setRequestHeader(); // 发送请求 this.sendRequest(); } bindStateChangeEvent() { let data = \"\"; let textStatus = \"\"; // 绑定回调函数，这里采用匿名函数使this指向Object，否则this将指向xhr this.xhr.addEventListener(\"readystatechange\", () => { switch (this.xhr.readyState) { case 1: this.beforeSend(this.xhr); break case 4: // 回调函数dataFilter的dataType参数如果你设定了就传递设定的值，如果未设定就用响应头里的contentType进行传递 data = this.dataFilter(this.xhr.responseText, this.dataType || this.xhr.getResponseHeader(\"Content-Type\").toLowerCase()); if (this.xhr.statusText === \"OK\") { textStatus = \"success\"; this.success(data, textStatus); } else { textStatus = \"error\"; this.error(this.xhr, textStatus); } this.complete(this.xhr, textStatus); break } }); } setRequestData() { // 判断是否要进行url编码，有2种情况： // 1.contentType是application/x-www-form-urlencoded时需要url编码 // 2.传入的对象不是serialize()方法已经序列化好后的对象时不需要url编码 if (this.contentType === \"application/x-www-form-urlencoded\" && !Object.isFrozen(this.data)) { this.data = this.urlEncode(this.data); } } urlEncode() { return Object.entries(this.data).reduce((prev, cur, index, array) => { // key let key = cur[0]; // value：2种情况，如果value是普通字符串，则直接进行encodeURIComponent编码处理，如果是数组将按照 k1=v1&k2=v2 的方式进行编码，并且判断是否传入traditional let value = this.checkValueIsArray(cur); if (array.length - 1 === index) { // 判断是否是最后一位，如果是最后一位就加上& // traditional：如果前端传递的是一个Array，如{\"k1\":[1,2,3,4]}则需要添加一个属性traditional:true，否则后端将接收不到该参数。（实际上接受的时候要使用request.POST.get(\"k1[]\")）来进行接受，这是有问题的 return !this.traditional && cur[1] instanceof Array ? prev += `${key}[]=${value}` : prev += `${key}=${value}`; } else { return !this.traditional && cur[1] instanceof Array ? prev += `${key}[]=${value}&` : prev += `${key}=${value}&`; } }, \"\"); } checkValueIsArray(cur) { if (cur[1] instanceof Array) { cur[1].forEach((value, index, array) => { if (index != array.length - 1) { value = encodeURIComponent(value); array[index] = value + \"&\"; } else { array[index] = String(value); } }) // traditional：如果前端传递的是一个Array，如{\"k1\":[1,2,3,4]}则需要添加一个属性traditional:true，否则后端将接收不到该参数。（实际上接受的时候要使用request.POST.get(\"k1[]\")）来进行接受，这是有问题的，这里主要对数组中的第2个元素开始及其之后的所有元素进行url编码格式转换 return this.traditional ? cur[1].join(`${cur[0]}=`) : cur[1].join(`${cur[0]}[]=`) } else { return encodeURIComponent(cur[1]) } } setXhrOpen() { // 如果请求方式是GET请求，则在url后加上编码后的data，否则将只传递this.url // true参数为开启异步调用，也是默认的选项 this.xhr.open( this.method, this.method === \"GET\" ? this.url.concat(\"?\", this.data) : this.url, true ); } setRequestHeader() { // 在不上传文件的时候，请求头Content-Type是必须的 for (let [k, v] of Object.entries(this.headers)) { this.xhr.setRequestHeader(k, v); } if (this.contentType) { this.xhr.setRequestHeader(\"Content-Type\", this.contentType); } } sendRequest() { // 发送请求时，如果请求方式为GET将使用this.xhr.send(null)，否则将使用this.xhr.send(this.data) this.xhr.send(this.method === \"GET\" ? null : this.data); } } function getAjax(ajaxSettings) { return new Ajax(ajaxSettings); } function serialize(selector) { // 整体思路：先获取一个包含所有表单项对象，再将对象进行url编码 let formNode = document.querySelector(selector); let haveValueNodeObject = {}; Array.prototype.forEach.call(formNode.elements, (element, index, lst) => { switch (true) { // 多选或者单选select都将组成列表 case element.tagName === \"SELECT\": Array.prototype.forEach.call(element.options, (option, index, array) => { if (option.selected) { haveValueNodeObject[element.name] ? haveValueNodeObject[element.name].push(option.value) : haveValueNodeObject[element.name] = [option.value]; } }) break // 多选，组成列表 case element.type === \"checkbox\": if (element.checked) { haveValueNodeObject[element.name] ? haveValueNodeObject[element.name].push(element.value) : haveValueNodeObject[element.name] = [element.value]; } break // 单选 case element.type === \"radio\": if (element.checked) { haveValueNodeObject[element.name] = element.value } break // 其他的项目，注意文件对象不获取 default: if (element.name && element.type !== \"file\") { haveValueNodeObject[element.name] = element.value || \"\"; } } } ) // 冻结对象，代表已经经过序列化了，在发送数据时已避免url二次编码 // 这里是传入一个对象并且继承Ajax的原型对象，因为这样做才能在编码时使用checkValueIsArray方法 return Object.freeze(Ajax.prototype.urlEncode.call( { data: haveValueNodeObject, traditional: true, __proto__: Ajax.prototype }, )); } function serializeArray(selector) { // 提取form表单中的数据，并将其构建为一个name：value的数组 [{name:value}, {name:value}, {name:value}] let formNode = document.querySelector(selector); let haveValueArray = []; Array.prototype.forEach.call(formNode.elements, (element, index, lst) => { switch (true) { case element.tagName === \"SELECT\": Array.prototype.forEach.call(element.options, (option, index, array) => { if (option.selected) { haveValueArray.push({ \"name\": element.name, \"value\": option.value }); } }) break case element.type === \"checkbox\" || element.type === \"radio\": if (element.checked) { haveValueArray.push({ \"name\": element.name, \"value\": element.value }); } break default: if (element.name && element.type !== \"file\") { haveValueArray.push({ \"name\": element.name, \"value\": element.value }); } } } ) return haveValueArray; } window.$ = { ajax: getAjax, serialize, serializeArray }; 支持的上传格式 由于我们JavaScript的原生Ajax高度按照jQuery.ajax作为蓝本。所以常见的特性要与其保持一致。 如支持的原生上传数据格式实现： 仅支持上传k-v的对象，不支持上传数组（仅针对非JSON数据格式的发送） 前端上传的数据中，不允许出现对象嵌套的形式。如{\"k1\":{\"k1-1\":v1}}，这样只会得到{“k1” : “object”} 如果前端传递的是一个Array，如 {\"k1\":[1, 2, 3, 4]} 则需要添加一个属性 traditional:true，否则后端将接收不到该参数。（实际上接受的时候要使用request.POST.get(\"k1[]\")）来进行接受，这是有问题的 如果你上传的数据是json格式，当然就不会出现这些问题了。 如何发送GET请求 发送GET请求示例如下： $.ajax({ url: \"http://localhost:5700/get\", method: \"GET\", dataType: \"JSON\", headers: { \"user_head\": \"Hello World\" }, data: { name: \"Jack\", age: 18, gender: \"male\" }, success: (data, textStatus) => { console.log(\"成功\"); console.log(data); console.log(textStatus); }, error: (xhr, textStatus) => { console.log(\"失败\"); console.log(xhr); console.log(textStatus); }, complete: (xhr, textStatus) => { console.log(\"总是执行,此处可获取响应头\"); console.log(xhr); console.log(textStatus); } }) 如何发送POST请求 发送POST请求示例如下： $.ajax({ url: \"http://localhost:5700/post\", method: \"POST\", dataType: \"JSON\", headers: { \"user_head\": \"Hello World\" }, data: { name: \"Jack\", age: 18, gender: \"male\" }, success: (data, textStatus) => { console.log(\"成功\"); console.log(data); console.log(textStatus); }, error: (xhr, textStatus) => { console.log(\"失败\"); console.log(xhr); console.log(textStatus); }, complete: (xhr, textStatus) => { console.log(\"总是执行,此处可获取响应头\"); console.log(xhr); console.log(textStatus); } }) 如何发送JSON数据 发送JSON格式数据示例如下。 你需要手动指定contentType为application/json和手动的对上传数据进行序列化 如果你发送JSON格式的数据，是支持上传数组格式的数据的： $.ajax({ url: \"http://localhost:5700/json\", method: \"POST\", // 必须是POST dataType: \"JSON\", headers: { \"user_head\": \"Hello World\" }, contentType: \"application/json\", // 1.手动指定请求头中contentType的格式 data: JSON.stringify([1, 2, 3, 4, 5]), // 2.手动的对上传数据进行JSON序列化 success: (data, textStatus) => { console.log(\"成功\"); console.log(data); console.log(textStatus); }, error: (xhr, textStatus) => { console.log(\"失败\"); console.log(xhr); console.log(textStatus); }, complete: (xhr, textStatus) => { console.log(\"总是执行,此处可获取响应头\"); console.log(xhr); console.log(textStatus); } }) 如何提交form表单的数据 针对form表单提交的数据，我们可以使用封装好的2个函数serialize()和serializeArray()。 serialize()：提取form表单中的数据项，并对其做url编码处理，返回一个字符串，注意，它不会提取文件选择框 serializeArray()：提取form表单中的数据，并将其构建为一个name：value的数组，注意，它不会提取文件选择框，最终格式为 [{name : “attribute”, value : “input”}, {name : “attribute”, value : “input”}] 示例如下，如果是serialize()则直接提交即可： 用户名 密码 男 女 篮球 足球 排球 城市 北京 上海 深圳 上传头像 提交 document.querySelector(\"button\").addEventListener(\"click\", (event) => { $.ajax({ url: \"http://localhost:5700/post\", method: \"POST\", headers: { \"user_head\": \"Hello World\" }, data: $.serialize(\"#register\"), dataType: \"JSON\", success: (data, textStatus) => { console.log(\"成功\"); console.log(data); console.log(textStatus); }, error: (xhr, textStatus) => { console.log(\"失败\"); console.log(xhr); console.log(textStatus); }, complete: (xhr, textStatus) => { console.log(\"总是执行,此处可获取响应头\"); console.log(xhr); console.log(textStatus); } }) console.log($.serialize(\"#register\")); // username=%E4%BA%91%E5%B4%96&password=123&gender=male&hobby=basketball&hobby=football&city=shanghai&city=shenzhen }) 如果是serializeArray()，需要使用appliction/json的方式进行提交，因为该方法返回的是一个数组： 用户名 密码 男 女 篮球 足球 排球 城市 北京 上海 深圳 上传头像 提交 document.querySelector(\"button\").addEventListener(\"click\", (event) => { $.ajax({ url: \"http://localhost:5700/json\", method: \"POST\", headers: { \"user_head\": \"Hello World\" }, contentType: \"application/json\", // 1.手动指定请求头中contentType的格式 data: JSON.stringify($.serializeArray(\"#register\")), // 2.手动的对上传数据进行JSON序列化 dataType: \"JSON\", success: (data, textStatus) => { console.log(\"成功\"); console.log(data); console.log(textStatus); }, error: (xhr, textStatus) => { console.log(\"失败\"); console.log(xhr); console.log(textStatus); }, complete: (xhr, textStatus) => { console.log(\"总是执行,此处可获取响应头\"); console.log(xhr); console.log(textStatus); } }) console.log($.serializeArray(\"#register\")); // Array(7) // 0: {name: \"username\", value: \"云崖\"} // 1: {name: \"password\", value: \"123\"} // 2: {name: \"gender\", value: \"male\"} // 3: {name: \"hobby\", value: \"basketball\"} // 4: {name: \"hobby\", value: \"football\"} // 5: {name: \"city\", value: \"shanghai\"} // 6: {name: \"city\", value: \"shenzhen\"} }) 如何进行文件上传 如果要发送文件，我们需要借助FormData对象进行数据提交，以下是注意事项。 在表单中上传文件，必须要将enctype设置为multipart/form-data。 但是在使用XmlHttpRequest对象上传文件时，并不需要指定 contentType为multipart/form-data 格式，所以不添加contentType请求头。 contentType应设置为false，即不使用任何数据格式，不使用任何编码 processData应设置为false，不让浏览器做任何数据格式的编码 示例如下，我们使用FormData搭配serializeArray()方法实现一个真正意义上的异步提交表单： 用户名 密码 男 女 篮球 足球 排球 城市 北京 上海 深圳 上传头像 提交 document.querySelector(\"button\").addEventListener(\"click\", (event) => { // 获取上传的文件对象 let fileNode = document.querySelector(\"#avatar\"); let fileObj = fileNode.files[0]; // 使用FormData用于伪造form表单提交的数据 let fd = new FormData(); // 添加文件 fd.append(fileNode.name, fileObj); // 添加其他表单项 $.serializeArray(\"#register\").forEach((obj, index, array) => { fd.append(obj.name, obj.value); }); // 发送json格式数据 $.ajax({ url: \"http://localhost:5700/file\", method: \"POST\", headers: {\"user_head\": \"Hello World\"} data: fd, // 直接发送ForData对象即可 dataType: \"JSON\", contentType: false, // 必须设置为false processData: false, // 必须设置为false success: (data, textStatus) => { console.log(\"成功\"); console.log(data); console.log(textStatus); }, error: (xhr, textStatus) => { console.log(\"失败\"); console.log(xhr); console.log(textStatus); }, complete: (xhr, textStatus) => { console.log(\"总是执行,此处可获取响应头\"); console.log(xhr); console.log(textStatus); } }) }) Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:48 "},"前端专栏/JavaScript/JSONP.html":{"url":"前端专栏/JavaScript/JSONP.html","title":"JSONP","keywords":"","body":"同源策略 所有支持JavaScript的浏览器都不允许跨域请求资源的情况出现，这种策略被称为同源策略（Same origin policy）。 所谓同源无外乎同协议、同域名、同端口。 比如你在http://localhost:5500下发送一个请求去获取http://localhost:5700/的资源时浏览器会触发同源策略对服务端响应进行拦截。 如下图所示： 要突破同源策略只有使用CORS技术和JSONP技术，这里着重介绍JSONP。 突破同源策略的标签 JSONP适用于请求一些服务器上的公共开放接口，并不适用于内部项目开发，也就是说只有当你需要去某个服务器上取出一些开放数据时这项技术才会被使用到。 我们仔细的想想，是不是有一些标签可以发送网络请求并且无视同源策略呢？没错，在MDN Web Docs)中详细的记载了有哪些标签可以突破同源策略。 如（仅列举常见标签）： 除此之外,CSS中的@font-face字体引入也是允许突破同源策略的。 接下来该怎么做 我们可以利用JavaScript新建一个标签，并且通过src属性来访问远程服务端，那么这样就能获取到数据。 远程服务端会返回给你一个特定格式的字符串，如下所示： \"callbackfn('The data you want')\" 仔细观察不难发现，它是准备调用一个JavaScript中的函数。 如果你定义了该函数的话，当JavaScript解析返回结果时，将自动的执行该函数。 最后我们应该将这个无用的删除。 OK，到了这里我们要明白2点，整个JSONP其实是一个双向约定的过程，必须有2个必要条件： 作为服务方来说，你必须按照“callback(“other”)”的方式来定义请求的返回结果 作为请求方来说，你必须知道远程服务端返回的字符串格式，并且定义好该函数 整个JSONP请求过程图如下所示： 代码实现 前端代码实现，这里是用的vscode默认服务器打开的页面，端口号是5500： click me \"use strict\"; let btnNode = document.querySelector(\"button\"); let spanNode = document.querySelector(\"span\"); btnNode.addEventListener(\"click\", (event) => { let scriptNode = document.createElement(\"script\"); scriptNode.src = \"http://localhost:5700/\"; document.head.append(scriptNode); document.head.removeChild(scriptNode); }) function callbackfn(result) { spanNode.innerText = result; } 后端代码实现，这里采用Python的Flask框架作为后端，每次都返回一个随机数： from logging import debug, error from flask import Flask import random app = Flask(__name__) @app.route(rule=\"/\", methods=[\"GET\"], strict_slashes=False) def publicAPI(): number = random.randint(1, 100) return f\"callbackfn({number})\" if __name__ == \"__main__\": app.run(host=\"localhost\", port=5700, debug=True) 运行结果： Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:48 "},"前端专栏/JavaScript/伪Ajax请求.html":{"url":"前端专栏/JavaScript/伪Ajax请求.html","title":"伪Ajax请求","keywords":"","body":"基本介绍 我们都知道，使用表单提交数据时，会造成页面的刷新。 如果你想提交数据的同时不让页面进行刷新，则可用XMLHttpRequest发送异步网络请求。 但是在这里我们介绍一种搭配表单实现的伪Ajax请求，也能让页面不刷新的同时提交数据，它的兼容性是最好的，因为不需要借助XMLHttpRequest。 实现过程 首先，标签有一个target属性，它能规定在何处显示action URL的提交结果。 在target属性中，有一个可设置的选项为framename，即在内联框架中打开action的提交结果。 我们可以设置一个display为none的，并且将其与标签的target属性与的name属性进行绑定，这样提交后服务端的响应结果就会存储在这个标签中，接下来再通过JavaScript拿到中的响应内容即可。 注意！伪Ajax请求只能应用在前后端混合开发中，前后端分离项目中由于子页面与document主页面跨域，故不能获取到数据 也就是说，如果页面A和页面B不是来自同一个域，那么我们将不能在页面A上去获取页面B的数据，而就是一个单独的嵌套子页面 后端采用Python的Flask框架完成。 由于表单提交数据时并不会触发浏览器的同源策略，所以后端并不需要做CORS： from flask import Flask from flask import request from flask import make_response from flask import jsonify from flask.templating import render_template app = Flask(__name__, template_folder=\"./templates\") @app.route(rule=\"/\", methods=[\"GET\"]) def index(): return render_template(\"index.html\") @app.route(rule=\"/register\", methods=[\"POST\"]) def register(): user_message = { **request.values.to_dict() } avatar = request.files.get(\"avatar\") user_message[\"avatar\"] = \"uploaded success\" if avatar else \"no uploaded\" return jsonify(user_message) if __name__ == \"__main__\": app.run(host=\"localhost\", port=5700, debug=True) 前端的index.html代码： 用户名 密码 男 女 篮球 足球 排球 城市 北京 上海 深圳 上传头像 提交 \"use strict\"; let iframeNode = document.querySelector(\"iframe\"); iframeNode.addEventListener(\"load\", (event) => { // 从iframe表单中提取出内容 let submitResult = event.target.contentWindow.document.body.innerHTML; // 如果前后端分离，则因为同源策略的影响不能获取数据 document.querySelector(\"footer\").innerHTML = submitResult; }) 显示结果： 组件封装 其实伪Ajax请求用的比较少，因为它的局限性很强，就是只能在前后端混合开发时使用。 在这里我还是将它封装成一个组件，用于混合开发的朋友做一个参考，实现思路如下： 通过JavaScript创建一个，并添加name属性 接收一个表单，将其target属性设置为的name属性 注册一个回调函数 代码实现： 用户名 密码 男 女 篮球 足球 排球 城市 北京 上海 深圳 上传头像 提交 \"use strict\"; function foreAjax(selector, callbackfn = (resultText) => { }) { let node = document.querySelector(selector); let iframeNode = document.createElement(\"iframe\"); iframeNode.style.display = \"none\"; iframeNode.name = \"targetIframe\"; node.append(iframeNode); node.target = iframeNode.name; iframeNode.addEventListener(\"load\", event => { callbackfn(event.target.contentWindow.document.body.innerText); }) } // 使用方式 foreAjax(\"#register\", (resultText) => { console.log(resultText); }) Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:48 "},"前端专栏/JavaScript/Promise.html":{"url":"前端专栏/JavaScript/Promise.html","title":"Promise","keywords":"","body":"事件循环 基本介绍 JavaScript是一门单线程的编程语言，所以没有真正意义上的并行特性。 为了协调事件处理、页面交互、脚本调用、UI渲染、网络请求等行为对主线程造成的影响，事件循环（event loop）方案应运而生。 事件循环说白了就是一个不断的在等待任务、执行任务的方案。 在JavaScript中，根据执行方式的不同，有2种状态的任务，分别是同步任务和异步任务。 同步任务率先执行，而后执行异步任务，所有的异步任务由2个队列存储，分别是： 微任务队列 宏任务队列 主线程在执行完同步任务后，会不断的从这2个任务队列中按照先进先出的策略取出异步任务并执行。 并且在此期间也会有新的事件不断的加入至各个任务队列中，以此循环往复、永不阻塞。 如下图所示： 任务分类 宏任务包括： setInterval setTimeout setImmediate Node.Js独有 XHR callbackfn event callbackfn requestAnimationFrame UI rendering 微任务包括： Promise.then catch finally process.nextTick Node.Js独有 MutationObserver 执行顺序 根据任务的状态，任务的执行优先级也会有所不同，具体执行顺序如下所示： 同步任务（sync-task） 微任务（micro-task） 宏任务（macro-task） 而关于微任务和宏任务的执行，还有更详细的划分： 微任务队列中一旦有任务，将全部执行完成后再执行宏任务 宏任务队列中的任务在执行完成后，会检查微任务队列中是否有新添加的任务，如果有，那么将执行微任务队列中所有新添加的任务，如果没有则继续执行下一个宏任务 如下图所示： 代码测试： \"use strict\"; // 宏任务，每5s添加一个微任务并执行 setInterval(() => { async function foo() { return \"micro-task\" } async function bar() { let result = await foo(); console.log(result); } bar(); }, 5000); // 宏任务，每1s执行一次 setInterval(() => { console.log(\"macro-task\"); }, 1000); // 同步任务 (() => { console.log(\"hello world\"); })(); 测试结果，虽然同步任务的代码在最下面，但是它会最先执行，而每添加一个微任务时，宏任务的执行会被插队： Promise 认识Promise Promise是ES6中出现的新功能，用于在JavaScript中更加简单的实现异步编程。 我们可以使用new Promise()创建出一个Promise对象，它接收一个执行器函数，该函数需要指定resolve和reject参数用于改变当前Promise对象的执行状态。 由于Promise对象中执行器代码是属于同步任务，所以他会率先的进行执行，一个Promise对象拥有以下几种状态： fulfilled：任务完成、使用resolve改变了任务状态 rejected：任务失败、使用reject改变了任务状态，或任务执行中抛出了异常 pending：正在等待、未使用resolve或reject改变任务状态 注意，每个Promise对象的状态只允许改变一次！不可以多次更改。 示例如下。 1）Promise中执行器任务是同步任务，所以会率先执行： \"use strict\"; setInterval(() => { console.log(\"macro task 3\"); }, 1000) let task = new Promise((resolve, reject) => { console.log(\"sync task 1\"); }); console.log(\"sync task 2\"); // sync task 1 // sync task 2 // macro task 3 2）使用resolve()方法改变Promise对象的状态为fulfilled： \"use strict\"; let task = new Promise((resolve, reject) => { let x = Math.floor(Math.random() * 100) + 1; let y = Math.floor(Math.random() * 100) + 1; let result = x + y; // 返回结果为resolve()中的值 resolve(result); }); console.log(task); // Promise {: 83} 3）使用reject()方法改变Promise对象的状态为rejected， 它将引发一个异常： \"use strict\"; let task = new Promise((resolve, reject) => { let x = Math.floor(Math.random() * 100) + 1; let y = Math.floor(Math.random() * 100) + 1; let result = x + y; // 返回结果为reject()中的值 reject(\"error!\") }); console.log(task); // Promise {: \"error!\"} // Uncaught (in promise) error! 4）如果未使用resolve()或reject()方法改变Promise对象状态，那么该任务的状态将为pending： \"use strict\"; let task = new Promise((resolve, reject) => { let x = Math.floor(Math.random() * 100) + 1; let y = Math.floor(Math.random() * 100) + 1; let result = x + y; }); console.log(task); // Promise {} then() 我们可以在Promise对象后，添加一个用于处理任务状态的回调then()方法。 then()方法只有在Promise对象状态为fulfilled或者rejected时才会进行执行，它具有2个参数，接收2个回调函数： onfulfilled：Promise对象状态为fulfilled将执行该函数，具有1个参数value，接收Promise任务中resolve()所传递的值 onrejected：Promise对象状态为rejected将执行该函数，具有1个参数reason，接收Promise任务中reject()或异常发生时所传递的值 此外，then()方法是属于微任务，所以他会插在宏任务之前进行执行。 代码示例如下： 1）Promise对象状态为fulfilled，运行then()方法的第1个回调函数： \"use strict\"; let task = new Promise((resolve, reject) => { resolve(\"success\"); }).then( value => { console.log(value); }, reason => { console.log(reason); }); // success 2）Promise对象状态为rejected，运行then()方法的第2个回调函数： \"use strict\"; let task = new Promise((resolve, reject) => { throw new Error(\"error\"); }).then( value => { console.log(value); }, reason => { console.log(reason); }); // error then()链式调用 其实每一个then()都将返回一个全新的Promise，默认情况下，该Promise的状态是fulfilled。 此时就会产生一种链式关系，每一个then()都将返回一个新的Promise对象，而每个then()的作用又都是处理上个Promise对象的状态。 这意味着我们可以无限的链式排列then()，如下所示： 代码示例： \"use strict\"; let task = new Promise((resolve, reject) => { console.log(\"first Promise task status is fulfilled\"); resolve(\"success\"); }) .then( value => { console.log(\"then1 fulfilled\", value); return value }, reason => { console.log(reason); }) .then( value => { console.log(\"then2 fulfilled\", value); return value }, reason => { console.log(reason); }) .then( value => { console.log(\"then3 fulfilled\", value); return value }, reason => { console.log(reason); }); // first Promise task status is fulfilled // then1 fulfilled success // then2 fulfilled success // then3 fulfilled success then()的返回值 要想真正的了解链式调用，就必须搞明白每个then()在不同状态下的返回值对下一个then()的影响。 具体情况如下所示： 1）当前then()无返回值，则当前Promise状态则为fulfilled。 下一个then()的onfulfilled回调函数参数value为undefined： 代码示例： \"use strict\"; let task = new Promise((resolve, reject) => { console.log(\"first Promise task status is fulfilled\"); resolve(\"success\"); }) .then( value => { console.log(\"then1 fulfilled\", value); // success }, reason => { console.log(reason); }) .then( value => { console.log(\"then2 fulfilled\", value); // undefined }, reason => { console.log(reason); }); // first Promise task status is fulfilled // then1 fulfilled success // then2 fulfilled undefined 2）当前then()有返回值，则当前Promise状态则为fulfilled。 下一个then()的onfulfilled回调函数参数value为当前then()的返回值： 代码示例： let task = new Promise((resolve, reject) => { console.log(\"first Promise task status is fulfilled\"); resolve(\"success\"); }) .then( value => { console.log(\"then1 fulfilled\", value); // success return \"then1 value\" }, reason => { console.log(reason); }) .then( value => { console.log(\"then2 fulfilled\", value); // then1 value }, reason => { console.log(reason); }); // first Promise task status is fulfilled // then1 fulfilled success // then2 fulfilled then1 value 3）当前then()有返回值，且返回了一个状态为fulfilled的Promise对象。 下一个then()的onfulfilled回调函数参数value为当前then()中被返回Promise里resolve()所传递的值： 代码示例： \"use strict\"; let task = new Promise((resolve, reject) => { console.log(\"first Promise task status is fulfilled\"); resolve(\"success\"); }) .then( value => { console.log(\"then1 fulfilled\", value); // success return new Promise((resolve, reject) => { resolve(\"then1 Promise success\") }) }, reason => { console.log(reason); }) .then( value => { console.log(\"then2 fulfilled\", value); // then1 Promise success }, reason => { console.log(reason); }); // first Promise task status is fulfilled // then1 fulfilled success // then2 fulfilled then1 Promise success 4）当前then()有返回值，且返回了一个状态为rejected的Promise对象。 下一个then()的onrejected回调函数参数reason为当前then()中被返回Promise里reject()所传递的值，或者是被返回Promise里抛出异常的值： 代码示例： \"use strict\"; let task = new Promise((resolve, reject) => { console.log(\"first Promise task status is fulfilled\"); resolve(\"success\"); }) .then( value => { console.log(\"then1 fulfilled\", value); // success return new Promise((resolve, reject) => { reject(\"then1 Promise error\") }) }, reason => { console.log(reason); }) .then( value => { console.log(\"then2 fulfilled\", value); }, reason => { console.log(reason); // then1 Promise error }); // first Promise task status is fulfilled // then1 fulfilled success // then1 Promise error 5）当前then()有返回值，且返回了一个状态为pending的Promise对象。下一个then()则必须等待当前then()中被返回Promise对象状态发生改变后才能继续执行： 代码示例： \"use strict\"; let task = new Promise((resolve, reject) => { console.log(\"first Promise task status is fulfilled\"); resolve(\"success\"); }) .then( value => { console.log(\"then1 fulfilled\", value); // success return new Promise((resolve, reject) => { console.log(\"pending\"); }) }, reason => { console.log(reason); }) .then( value => { console.log(\"then2 fulfilled\", value); }, reason => { console.log(reason); }); // first Promise task status is fulfilled // then1 fulfilled success // pending 另外，如果在代码执行时抛出了异常，那么返回的Promise对象状态则为rejected，下一个then()的onrejected回调函数参数reason为当前then()中抛出异常的值，这里不再进行演示。 then()穿透 then()是具有穿透功能的，当一个then()没有指定需要被执行的回调函数时，它将继续冒泡向下传递： 代码示例： \"use strict\"; let task = new Promise((resolve, reject) => { console.log(\"first Promise task status is fulfilled\"); resolve(\"success\"); }) .then() .then( value => { console.log(\"then2 fulfilled\", value); }, reason => { console.log(reason); }); // first Promise task status is fulfilled // then2 fulfilled success catch() 每个then()都可以指定onrejected回调函数用于处理上一个Promise状态为rejected的情况。如果每个then()都进行这样的设置会显得很麻烦，所以我们只需要使用catch()即可。 catch()可以捕获之前所有Promise的错误执行，故建议将catch()放在最后。 catch()需要指定一个回调函数onrejected，具有1个参数reason，接收Promise任务中reject()或异常发生时所传递的值。 错误是冒泡传递的，如果没有任何一个then()定义onrejected的回调函数，那么错误将一直冒泡到catch()处进行处理： 代码示例： \"use strict\"; let task = new Promise((resolve, reject) => { console.log(\"first Promise task status is fulfilled\"); resolve(\"success\"); }) .then( value => { console.log(\"then1 fulfilled\", value); return value } ) .then( value => { console.log(\"then2 rejected\", value); throw new Error(\"error\"); }) .then( value => { console.log(\"then3 ...\", value); } ) .catch( reason => { console.log(reason); }); // first Promise task status is fulfilled // then1 fulfilled success // then2 rejected success // Error: error finally() finally()是无论任务处理成功或者失败都会执行，因此建议将它放在链式调用的最后面。 它需要指定一个回调函数onfinally，该回调函数没有任何参数： \"use strict\"; let task = new Promise((resolve, reject) => { console.log(\"first Promise task status is fulfilled\"); resolve(\"success\"); }) .then( value => { console.log(\"then1 fulfilled\", value); return value } ) .catch( reason => { console.log(reason); } ) .finally( () => { console.log(\"run\"); } ); // first Promise task status is fulfilled // then1 fulfilled success // run 扩展方法 resolve() resolve()方法用于快速返回一个状态为fulfilled的Promise对象，生产环境中使用较少： \"use strict\"; let task = Promise.resolve(\"success\"); console.log(task); // Promise {: \"success\"} reject() reject()方法用于快速返回一个状态为rejected的Promise对象，生产环境中使用较少： \"use strict\"; let task = Promise.reject(\"error\"); console.log(task); // Promise {: \"error\"} // Uncaught (in promise) error all() all()方法用于一次同时执行多个异步任务，并且必须确保这些任务是成功的。 all()方法接收的参数必须是可迭代类型，如Array、map、set 任何一个Promise状态为rejected，都将调用catch()方法 当所有任务成功执行后，将返回一个包含所有任务的执行结果数组 all()方法应用场景还是非常广泛的，如我们需要使用Ajax请求后端的书籍与价格信息时，不论是书籍获取失败还是价格获取失败，都将认为此次任务的失败。 示例如下： \"use strict\"; const getBookNameTask = new Promise((resolve, reject) => { // 模拟请求后端的书籍名称，需要花费3s setTimeout(() => { resolve(JSON.stringify( [\"HTML\", \"CSS\", \"JavaScript\"] )) }, 3000); }); const getBookPriceTask = new Promise((resolve, reject) => { // 模拟请求后端的书籍价格，需要花费5s setTimeout(() => { resolve(JSON.stringify( [98, 120, 40] )) }, 5000); }) // 执行任务 Promise.all( [getBookNameTask, getBookPriceTask] ) .then(value => { // 书籍和价格全部获取后才执行这里 // value = [\"[\\\"HTML\\\",\\\"CSS\\\",\\\"JavaScript\\\"]\", \"[98,120,40]\"] const bookNameArray = JSON.parse(value[0]); const bookPriceArray = JSON.parse(value[1]); const bookAndNameMap = new Map(); for (let i = 0; i { // 任何一个没获取到都执行这里 console.log(reason); }); allSettled() allSettled()方法和all()方法相似，都是用于同时执行多个异步任务，但是它并不关心所有任务是否都执行成功。 allSettled()的状态只会是fulfilled： \"use strict\"; const getBookNameTask = new Promise((resolve, reject) => { setTimeout(() => { reject(\"error! Can't query all books name\") }, 3000); }); const getBookPriceTask = new Promise((resolve, reject) => { setTimeout(() => { reject(\"error! Can't query all books price\") }, 5000); }) // 执行任务 Promise.allSettled( [getBookNameTask, getBookPriceTask] ) .then(value => { // 不管怎样都会执行这里 console.log(\"run me\"); }) race() race()也可同时执行多个任务，它仅会返回最快完成任务的执行结果。 以最快返回的任务结果为准 如果最快返回的任务状态为rejected，那么race()的状态也将视为rejected，此时将执行catch()方法 race()方法用的也比较多，如我们需要加载一些图片，这些图片在多个服务端上都有存储，但为了提高用户体验我们需要根据用户所在的地理位置选择最近的服务器，此时race()就派上了用场： \"use strict\"; const getCacheImages = new Promise((resolve, reject) => { setTimeout(() => { resolve(\"get cache images success!!\"); }, 1000); }) const getWebImages = new Promise((resolve, reject) => { setTimeout(() => { resolve(\"get web images success!!\"); }, 3000); }) // 创建任务 Promise.race( [getCacheImages, getWebImages] ) .then(value => { console.log(value); }) .catch(reason => { console.log(reason); }) // get cache images success!! async&await async async其实是new Promise()的语法糖简写形式。 在某一个函数前面加上async，运行该函数时将会返回一个Promise对象。 没有return：返回的Promise对象状态为fulfilled，下一个then()的onfulfilled回调函数参数value为undefined 直接return：返回的Promise对象状态为fulfilled，下一个then()的onfulfilled回调函数参数value为当前async函数的返回值 return了一个状态为fulfilled的Promise对象：下一个then()的onfulfilled回调函数参数value为当前async函数中被返回Promise里resolve()所传递的值 return了一个状态为rejected的Promise对象：下一个then()的onrejected回调函数参数reason为当前async函数中被返回Promise里reject()所传递的值，或者是被返回Promise里抛出异常的值 运行时抛出异常：返回的Promise对象状态为rejected，下一个then()的onrejected回调函数参数reason为当前async函数中抛出异常的值 示例演示： \"use strict\"; async function task() { return \"success\" } task().then(value => { console.log(value); }); // success await await其实是then()的另一种写法，它只能在async函数中使用。 await后面一般都会跟上一个Promise对象，如果不是Promise对象，将直接返回该值。 await使用必须在async函数中 await作为then()的语法糖形式，使用它编写代码将使代码变的更加优雅 如下所示，我们有3个任务，这3个任务必须是先通过用户ID获取人员姓名、再通过用户ID获取信息ID、最后再通过用户ID获取人员信息。 如果你用纯Promise+then()的方式进行代码编写，它将是这样的： \"use strict\"; const idAndName = new Map([ [1, \"Jack\"], [2, \"Tom\"], [3, \"Mary\"], ]); const personnelInformation = new Map([ [1, { gender: \"female\", age: 18, addr: \"TianJin\", desc: \"my name is Mary\" }], [2, { gender: \"male\", age: 21, addr: \"ShangHai\", desc: \"my name is Tom\" }], [3, { gender: \"male\", age: 18, addr: \"BeiJing\", desc: \"my name is Jack\" }], ]); const nameAndMessage = new Map([ [1, 3], [2, 2], [3, 1], ]) function getUserMessage(id) { let userName, messageId, message, str; new Promise((resolve, reject) => { // 获取姓名 if (idAndName.has(id)) { userName = idAndName.get(id); resolve(); } reject(`no information id : ${id}`); }) .then(() => { // 获取关系 messageId = nameAndMessage.get(id); }) .then(() => { // 获取信息 message = personnelInformation.get(messageId); }) .then(() => { // 进行渲染 str = `name : ${userName}`; for (let [k, v] of Object.entries(message)) { str += `${k} : ${v}`; } document.write(str) }) .catch(reason => { document.write(`${reason}`); }) } getUserMessage(3); 如果你使用async+awit的方式编写，那么它的逻辑就会清楚很多： \"use strict\"; const idAndName = new Map([ [1, \"Jack\"], [2, \"Tom\"], [3, \"Mary\"], ]); const personnelInformation = new Map([ [1, { gender: \"female\", age: 18, addr: \"TianJin\", desc: \"my name is Mary\" }], [2, { gender: \"male\", age: 21, addr: \"ShangHai\", desc: \"my name is Tom\" }], [3, { gender: \"male\", age: 18, addr: \"BeiJing\", desc: \"my name is Jack\" }], ]); const nameAndMessage = new Map([ [1, 3], [2, 2], [3, 1], ]) // 获取姓名 async function getName(id) { if (idAndName.has(id)) { return idAndName.get(id); } throw new Error(`no information id : ${id}`); } // 获取关系 async function getRelation(id) { return nameAndMessage.get(id); } // 获取信息 async function getMessage(messageId) { return personnelInformation.get(messageId); } // 入口函数，进行渲染 async function getUserMessage(id) { try { let userName = await getName(id); // 必须等待该函数执行完成才会继续向下执行 let messageId = await getRelation(id); let message = await getMessage(messageId); let str = `name : ${userName}`; for (let [k, v] of Object.entries(message)) { str += `${k} : ${v}`; } document.write(str) } catch (e) { document.write(`${e}`); } } getUserMessage(3); 异常处理 async+await的异常处理推荐使用try+catch语句将所有执行代码进行包裹，它将处理所有可能出现的异常，相当于在链式调用的最后面加上catch()方法： \"use strict\"; async function task01() { console.log(\"run task 01\"); } async function task02() { throw new Error(\"task02 error\"); console.log(\"run task 02\"); } async function task03() { console.log(\"run task 03\"); } async function main() { try { await task01(); await task02(); await task03(); } catch (e) { console.log(e); } } main(); 也可以在主函数外部使用catch()方法来处理异常，但是我并不推荐这么做。 \"use strict\"; async function task01() { console.log(\"run task 01\"); } async function task02() { throw new Error(\"task02 error\"); console.log(\"run task 02\"); } async function task03() { console.log(\"run task 03\"); } async function main() { await task01(); await task02(); await task03(); } main().catch(reason => { console.log(reason); }); 除此之外，你也可以使用try+catch语句块对单独的async函数语句块进行处理，预防可能出现的异常。 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:48 "},"前端专栏/JavaScript/手动实现Promise.html":{"url":"前端专栏/JavaScript/手动实现Promise.html","title":"手动实现Promise","keywords":"","body":"Promise状态实现 在原生Promise中具有三种状态，分别是 pending：未解决状态 fulfilled：已解决状态 rejected：解决失败状态 所以第一步，要先实现这三种状态。 并且在原生Promise中具有value用于记录执行函数resolve()与reject()中的值用于传递给then()方法。 所以我们要定义一个value： class AsyncPromise { static PENDING = \"pending\"; static FULFILLED = \"fulfilled\"; static REJECTED = \"rejected\"; constructor(executor) { this.status = AsyncPromise.PENDING; // 初始为准备状态 this.value = null; // 初始值 } } Promise执行函数 原生Promise的构造函数中会接收一个executor参数，该参数当是一个函数。 用于同步的执行当前任务，当任务完成后应该具有resolve()方法以及reject()方法来通知then()方法当前执行任务的执行状态并传递值。 class AsyncPromise { static PENDING = \"pending\"; static FULFILLED = \"fulfilled\"; static REJECTED = \"rejected\"; constructor(executor) { this.status = AsyncPromise.PENDING; // 初始状态为准备状态 this.value = null; // 初始值 executor(this.resolve, this.reject); // 传递形参，运行executor函数 } resolve(value) { this.status = AsyncPromise.FULFILLED; this.value = value; } reject(reason) { this.status = AsyncPromise.REJECTED; this.value = reason; } } 上面这样写在执行resolve()以及reject()时会出现问题，原因是this指向为undefiled(严格模式)。 \"use strict\"; let task = new AsyncPromise((resolve, reject) => { resolve(\"成功\") }) console.log(task); // undefined 这是由于我们在执行函数中调用了resolve()与reject()，故this指向为executor的函数上下文。 解决这个问题可以使用bind()来改变this指向。 class AsyncPromise { static PENDING = \"pending\"; static FULFILLED = \"fulfilled\"; static REJECTED = \"rejected\"; constructor(executor) { this.status = AsyncPromise.PENDING; // 初始状态为准备状态 this.value = null; // 初始值 executor(this.resolve.bind(this), this.reject.bind(this)); // 传递形参，运行executor函数 } resolve(value) { this.status = AsyncPromise.FULFILLED; this.value = value; } reject(reason) { this.status = AsyncPromise.REJECTED; this.value = reason; } } Promise状态限制 当前Promise状态只应该改变一次而不能多次改变，显然我们上面的代码不能做到这点限制。 \"use strict\"; let task = new AsyncPromise((resolve, reject) => { resolve(\"成功\"); reject(\"失败\"); // 对于原生Promise来说，状态只能改变一次。但是这里却允许两次改变，故是有问题的 }) console.log(task); // AsyncPromise {status: \"rejected\", value: \"失败\"} 所以这里要对代码加上限制。 class AsyncPromise { static PENDING = \"pending\"; static FULFILLED = \"fulfilled\"; static REJECTED = \"rejected\"; constructor(executor) { this.status = AsyncPromise.PENDING; // 初始状态为准备状态 this.value = null; // 初始值 executor(this.resolve.bind(this), this.reject.bind(this)); // 传递形参，运行executor函数 } resolve(value) { if (this.status == AsyncPromise.PENDING) { // 限制 this.status = AsyncPromise.FULFILLED; this.value = value; } } reject(reason) { if (this.status == AsyncPromise.PENDING) { // 限制 this.status = AsyncPromise.REJECTED; this.value = reason; } } } Promise执行异常 在执行函数executor中可能引发异常，这会让当前的Promise的状态改变为rejected。 所以在上面代码基础上需要加入try/catch进行处理。 当then()方法捕捉到执行函数executor中的异常时，可以让第二个参数的函数对其异常进行处理，但是我们目前还没实现then()，所以直接丢给reject()即可，当实现then()时自然会使用到reject()中传递过来的值。 class AsyncPromise { static PENDING = \"pending\"; static FULFILLED = \"fulfilled\"; static REJECTED = \"rejected\"; constructor(executor) { this.status = AsyncPromise.PENDING; // 初始状态为准备状态 this.value = null; // 初始值 try { executor(this.resolve.bind(this), this.reject.bind(this)); // 传递形参，运行executor函数 } catch (e) { this.status = AsyncPromise.REJECTED; // 异常发生改变状态 this.reject(e); // 记录异常信息 } } resolve(value) { if (this.status == AsyncPromise.PENDING) { // 限制 this.status = AsyncPromise.FULFILLED; this.value = value; } } reject(reason) { if (this.status == AsyncPromise.PENDING) { // 限制 this.status = AsyncPromise.REJECTED; this.value = reason; } } } then方法基础实现 原生的Promise状态改变后，可以执行其下的then()方法，所以我们需要来封装出一个then()方法。 then()方法接收两个函数，第一个函数onfulfilled用于处理上一个Promise的fulfilled状态，第二个函数onrejected用于处理上一个Promise的rejected状态。 并且then()方法中的这两个函数都应该具有一个形参，用于接收到Promise的resolve()或reject()中传递的值。 class AsyncPromise { static PENDING = \"pending\"; static FULFILLED = \"fulfilled\"; static REJECTED = \"rejected\"; constructor(executor) { this.status = AsyncPromise.PENDING; // 初始状态为准备状态 this.value = null; // 初始值 try { executor(this.resolve.bind(this), this.reject.bind(this)); // 传递形参，运行executor函数 } catch (e) { this.status = AsyncPromise.REJECTED; // 异常发生改变状态 this.reject(e); // 记录异常信息 } } resolve(value) { if (this.status == AsyncPromise.PENDING) { // 限制 this.status = AsyncPromise.FULFILLED; this.value = value; } } reject(reason) { if (this.status == AsyncPromise.PENDING) { // 限制 this.status = AsyncPromise.REJECTED; this.value = reason; } } then(onfulfilled, onrejected) { if (this.status == AsyncPromise.FULFILLED) { // 状态改变时执行 onfulfilled(this.value); } if (this.status == AsyncPromise.REJECTED) { // 状态改变时执行 onrejected(this.value); } } } then方法参数优化 上面已经说过，then()方法具有两个参数，这两个参数分别对应两个函数用来处理上一个Promsie的resolve()与reject()。 但是在原生Promise中，这两个方法可以不进行传递，所以我们需要对上述代码进行优化。 当then()方法中的某一个参数不为函数时，让它自动创建一个空函数。 class AsyncPromise { static PENDING = \"pending\"; static FULFILLED = \"fulfilled\"; static REJECTED = \"rejected\"; constructor(executor) { this.status = AsyncPromise.PENDING; // 初始状态为准备状态 this.value = null; // 初始值 try { executor(this.resolve.bind(this), this.reject.bind(this)); // 传递形参，运行executor函数 } catch (e) { this.status = AsyncPromise.REJECTED; // 异常发生改变状态 this.reject(e); // 记录异常信息 } } resolve(value) { if (this.status == AsyncPromise.PENDING) { // 限制 this.status = AsyncPromise.FULFILLED; this.value = value; } } reject(reason) { if (this.status == AsyncPromise.PENDING) { // 限制 this.status = AsyncPromise.REJECTED; this.value = reason; } } then(onfulfilled, onrejected) { if (typeof onfulfilled != \"function\") { // 如果传入的不是一个函数，默认创建空函数 onfulfilled = () => { }; } if (typeof onrejected != \"function\") { // 如果传入的不是一个函数，默认创建空函数 onrejected = () => { }; } if (this.status == AsyncPromise.FULFILLED) { // 状态改变时执行 onfulfilled(this.value); } if (this.status == AsyncPromise.REJECTED) { // 状态改变时执行 onrejected(this.value); } } } then方法异常捕获 当then()方法中处理fulfilled状态的函数onfulfilled或者处理rejected状态的函数onrejected在运行时出现异常应该进行捕获并且传递给下一个then()的处理rejected状态的函数onrejected。 这里我们先让所有的异常都交由当前then()处理rejected状态的函数onrejected，后面再进行优化。 class AsyncPromise { static PENDING = \"pending\"; static FULFILLED = \"fulfilled\"; static REJECTED = \"rejected\"; constructor(executor) { this.status = AsyncPromise.PENDING; // 初始状态为准备状态 this.value = null; // 初始值 try { executor(this.resolve.bind(this), this.reject.bind(this)); // 传递形参，运行executor函数 } catch (e) { this.status = AsyncPromise.REJECTED; // 异常发生改变状态 this.reject(e); // 记录异常信息 } } resolve(value) { if (this.status == AsyncPromise.PENDING) { // 限制 this.status = AsyncPromise.FULFILLED; this.value = value; } } reject(reason) { if (this.status == AsyncPromise.PENDING) { // 限制 this.status = AsyncPromise.REJECTED; this.value = reason; } } then(onfulfilled, onrejected) { if (typeof onfulfilled != \"function\") { // 如果传入的不是一个函数，默认创建空函数 onfulfilled = () => { }; } if (typeof onrejected != \"function\") { // 如果传入的不是一个函数，默认创建空函数 onrejected = () => { }; } if (this.status == AsyncPromise.FULFILLED) { // 状态改变时执行 try { // then处理成功的函数onfulfilled中出现异常，交由当前then处理失败的函数onrejected函数进行处理。这个后面会做优化 onfulfilled(this.value); } catch (e) { onrejected(e); } } if (this.status == AsyncPromise.REJECTED) { // 状态改变时执行 try { // then处理失败的函数onrejected中出现异常,交由当前then处理失败的函数onrejected函数进行处理。这个后面会做优化 onrejected(this.value); } catch (e) { onrejected(e); } } } } then方法异步执行 在原生的Promise中，executor函数是同步执行的，而then()方法是异步执行故排在同步执行之后。 但是我们的Promise却没有做到这一点，下面的实验将说明这个问题 \"use strict\"; let task = new AsyncPromise((resolve, reject) => { reject(\"失败\"); }).then( null, error => { console.log(error); // 先打印 失败 } ) console.log(\"hello,Promise\"); // 后打印 hello,Promise 最简单的解决方案就是为then()中处理成功或处理失败的函数运行外套上一个setTimeout，让其处理排在线程同步任务执行之后再进行执行。 class AsyncPromise { static PENDING = \"pending\"; static FULFILLED = \"fulfilled\"; static REJECTED = \"rejected\"; constructor(executor) { this.status = AsyncPromise.PENDING; // 初始状态为准备状态 this.value = null; // 初始值 try { executor(this.resolve.bind(this), this.reject.bind(this)); // 传递形参，运行executor函数 } catch (e) { this.status = AsyncPromise.REJECTED; // 异常发生改变状态 this.reject(e); // 记录异常信息 } } resolve(value) { if (this.status == AsyncPromise.PENDING) { // 限制 this.status = AsyncPromise.FULFILLED; this.value = value; } } reject(reason) { if (this.status == AsyncPromise.PENDING) { // 限制 this.status = AsyncPromise.REJECTED; this.value = reason; } } then(onfulfilled, onrejected) { if (typeof onfulfilled != \"function\") { // 如果传入的不是一个函数，默认创建空函数 onfulfilled = () => { }; } if (typeof onrejected != \"function\") { // 如果传入的不是一个函数，默认创建空函数 onrejected = () => { }; } if (this.status == AsyncPromise.FULFILLED) { // 状态改变时执行 setTimeout(() => { // 晚于线程同步任务执行 try { // then处理成功的函数onfulfilled中出现异常，交由当前then处理失败的函数onrejected函数进行处理。这个后面会做优化 onfulfilled(this.value); } catch (e) { onrejected(e); } }) } if (this.status == AsyncPromise.REJECTED) { // 状态改变时执行 setTimeout(() => { // 晚于线程同步任务执行 try { // then处理失败的函数onrejected中出现异常,交由当前then处理失败的函数onrejected函数进行处理。这个后面会做优化 onrejected(this.value); } catch (e) { onrejected(e); } }) } } } 执行函数异步阻塞 此时我们的代码仍然具有一个问题，即在执行函数executor中使用setTimeout时，下面的then()会进行阻塞。 这是因为当前Promise状态是pending而then()方法中并没有对pending状态进行处理的策略所导致的。 \"use strict\"; new AsyncPromise((resolve, reject) => { setTimeout(() => { resolve(\"成功\"); // 同步任务执行完三秒后才会改变当前Promise状态 }, 3000); }).then((success) => { // 但是这里先执行了then，Promise状态为pending，故发生阻塞 console.log(success); // 阻塞了，不打印 }) 既然当前Promise状态是pending，3秒后状态才发生改变，那么我们就可以通过不断的循环来看看它何时改变状态。 所以第一步是定义一个执行异步的数组。然后再将then()中处理正确的函数onfulfilled与处理错误的函数onrejected压进去。 class AsyncPromise { static PENDING = \"pending\"; static FULFILLED = \"fulfilled\"; static REJECTED = \"rejected\"; constructor(executor) { this.status = AsyncPromise.PENDING; // 初始状态为准备状态 this.value = null; // 初始值 this.callbacks = []; // 如果是一个异步操作，则放入该数组中 try { executor(this.resolve.bind(this), this.reject.bind(this)); // 传递形参，运行executor函数 } catch (e) { this.status = AsyncPromise.REJECTED; // 异常发生改变状态 this.reject(e); // 记录异常信息 } } resolve(value) { if (this.status == AsyncPromise.PENDING) { // 限制 this.status = AsyncPromise.FULFILLED; this.value = value; }) } } reject(reason) { if (this.status == AsyncPromise.PENDING) { // 限制 this.status = AsyncPromise.REJECTED; this.value = reason; } } then(onfulfilled, onrejected) { if (typeof onfulfilled != \"function\") { // 如果传入的不是一个函数，默认创建空函数 onfulfilled = () => { }; } if (typeof onrejected != \"function\") { // 如果传入的不是一个函数，默认创建空函数 onrejected = () => { }; } if (this.status == AsyncPromise.FULFILLED) { // 状态改变时执行 setTimeout(() => { // 晚于线程同步任务执行 try { // then处理成功的函数onfulfilled中出现异常，交由当前then处理失败的函数onrejected函数进行处理。这个后面会做优化 onfulfilled(this.value); } catch (e) { onrejected(e); } }) } if (this.status == AsyncPromise.REJECTED) { // 状态改变时执行 setTimeout(() => { // 晚于线程同步任务执行 try { // then处理失败的函数onrejected中出现异常,交由当前then处理失败的函数onrejected函数进行处理。这个后面会做优化 onrejected(this.value); } catch (e) { onrejected(e); } }) } if (this.status == AsyncPromise.PENDING) { // 如果当前Promise是等待处理状态，则将处理成功的函数与处理失败的函数压入异步数组。 this.callbacks.push({ onfulfilled, onrejected, }); } } } 当数组压入完成后，执行函数executor会去调用resolve()或者reject()改变当前Promise状态。 所以我们还需要在resolve()与reject()方法中对异步的数组处理函数进行调用。 class AsyncPromise { static PENDING = \"pending\"; static FULFILLED = \"fulfilled\"; static REJECTED = \"rejected\"; constructor(executor) { this.status = AsyncPromise.PENDING; // 初始状态为准备状态 this.value = null; // 初始值 this.callbacks = []; // 如果是一个异步操作，则放入该数组中 try { executor(this.resolve.bind(this), this.reject.bind(this)); // 传递形参，运行executor函数 } catch (e) { this.status = AsyncPromise.REJECTED; // 异常发生改变状态 this.reject(e); // 记录异常信息 } } resolve(value) { if (this.status == AsyncPromise.PENDING) { // 限制 this.status = AsyncPromise.FULFILLED; this.value = value; this.callbacks.map(callback => { // // 调用处理异步executor里resolve的方法。 callback.onfulfilled(value); }) } } reject(reason) { if (this.status == AsyncPromise.PENDING) { // 限制 this.status = AsyncPromise.REJECTED; this.value = reason; this.callbacks.map(callback => { // 调用处理异步executor里reject的方法。 callback.onrejected(reason); }) } } then(onfulfilled, onrejected) { if (typeof onfulfilled != \"function\") { // 如果传入的不是一个函数，默认创建空函数 onfulfilled = () => { }; } if (typeof onrejected != \"function\") { // 如果传入的不是一个函数，默认创建空函数 onrejected = () => { }; } if (this.status == AsyncPromise.FULFILLED) { // 状态改变时执行 setTimeout(() => { // 晚于线程同步任务执行 try { // then处理成功的函数onfulfilled中出现异常，交由当前then处理失败的函数onrejected函数进行处理。这个后面会做优化 onfulfilled(this.value); } catch (e) { onrejected(e); } }) } if (this.status == AsyncPromise.REJECTED) { // 状态改变时执行 setTimeout(() => { // 晚于线程同步任务执行 try { // then处理失败的函数onrejected中出现异常,交由当前then处理失败的函数onrejected函数进行处理。这个后面会做优化 onrejected(this.value); } catch (e) { onrejected(e); } }) } if (this.status == AsyncPromise.PENDING) { // 如果当前Promise是等待处理状态，则将处理成功的函数与处理失败的函数压入异步数组。 this.callbacks.push({ onfulfilled, onrejected, }); } } } 异步执行函数的then异常捕获 上面我们对同步执行函数executor调用then()方法中可能出现的异常进行了处理。 就是下面这一段代码。 if (this.status == AsyncPromise.FULFILLED) { // 状态改变时执行 setTimeout(() => { // 晚于线程同步任务执行 try { // then处理成功的函数onfulfilled中出现异常，交由当前then处理失败的函数onrejected函数进行处理。这个后面会做优化 onfulfilled(this.value); } catch (e) { onrejected(e); } }) } if (this.status == AsyncPromise.REJECTED) { // 状态改变时执行 setTimeout(() => { // 晚于线程同步任务执行 try { // then处理失败的函数onrejected中出现异常,交由当前then处理失败的函数onrejected函数进行处理。这个后面会做优化 onrejected(this.value); } catch (e) { onrejected(e); } }) } 但是我们还没有对异步执行函数executor调用then()方法中可能出现的异常进行处理。 if (this.status == AsyncPromise.PENDING) { // 如果当前Promise是等待处理状态，则将处理成功的函数与处理失败的函数压入异步数组。 this.callbacks.push({ onfulfilled, onrejected, }); } } 这会导致下面这样的使用场景出现问题。 \"use strict\"; new AsyncPromise((resolve, reject) => { setTimeout(() => { resolve(\"成功\"); }, 3000); }).then((success) => { throw new Error(\"自定义异常抛出\"); // 直接在处理成功状态的函数onfulfilled中抛出了异常，显然是不符合原生Promise的 }); 那么我们就来加上异常捕获即可，这里还是先传递给当前then()处理rejected状态的函数，后面会做修改。 因为原版Promise会传递给下一个then()中处理rejected状态的函数，而不是当前then()。 class AsyncPromise { static PENDING = \"pending\"; static FULFILLED = \"fulfilled\"; static REJECTED = \"rejected\"; constructor(executor) { this.status = AsyncPromise.PENDING; // 初始状态为准备状态 this.value = null; // 初始值 this.callbacks = []; // 如果是一个异步操作，则放入该数组中 try { executor(this.resolve.bind(this), this.reject.bind(this)); // 传递形参，运行executor函数 } catch (e) { this.status = AsyncPromise.REJECTED; // 异常发生改变状态 this.reject(e); // 记录异常信息 } } resolve(value) { if (this.status == AsyncPromise.PENDING) { // 限制 this.status = AsyncPromise.FULFILLED; this.value = value; this.callbacks.map(callback => { // // 调用处理异步executor里resolve的方法。 callback.onfulfilled(value); }) } } reject(reason) { if (this.status == AsyncPromise.PENDING) { // 限制 this.status = AsyncPromise.REJECTED; this.value = reason; this.callbacks.map(callback => { // 调用处理异步executor里reject的方法。 callback.onrejected(reason); }) } } then(onfulfilled, onrejected) { if (typeof onfulfilled != \"function\") { // 如果传入的不是一个函数，默认创建空函数 onfulfilled = () => { }; } if (typeof onrejected != \"function\") { // 如果传入的不是一个函数，默认创建空函数 onrejected = () => { }; } if (this.status == AsyncPromise.FULFILLED) { // 状态改变时执行 setTimeout(() => { // 晚于线程同步任务执行 try { // then处理成功的函数onfulfilled中出现异常，交由当前then处理失败的函数onrejected函数进行处理。这个后面会做优化 onfulfilled(this.value); } catch (e) { onrejected(e); } }) } if (this.status == AsyncPromise.REJECTED) { // 状态改变时执行 setTimeout(() => { // 晚于线程同步任务执行 try { // then处理失败的函数onrejected中出现异常,交由当前then处理失败的函数onrejected函数进行处理。这个后面会做优化 onrejected(this.value); } catch (e) { onrejected(e); } }) } if (this.status == AsyncPromise.PENDING) { // 如果当前Promise是等待处理状态，则将处理成功的函数与处理失败的函数压入异步数组。 this.callbacks.push({ onfulfilled: value => { try { // 异步executor改变状态对其then中的onfulfilled进行异常捕获 onfulfilled(value); } catch (e) { onrejected(e); } }, onrejected: value => { try { // 异步executor改变状态对其then中的onrejected进行异常捕获 onrejected(value); } catch (e) { onrejected(e); } } }); } } } then方法链式操作 对于原生的Promise来讲，每一个then()最后返回的都是一个新的Promise。所以才能达到支持不断的then()进行链式操作，所以我们也可以这样做。 class AsyncPromise { static PENDING = \"pending\"; static FULFILLED = \"fulfilled\"; static REJECTED = \"rejected\"; constructor(executor) { this.status = AsyncPromise.PENDING; // 初始状态为准备状态 this.value = null; // 初始值 this.callbacks = []; // 如果是一个异步操作，则放入该数组中 try { executor(this.resolve.bind(this), this.reject.bind(this)); // 传递形参，运行executor函数 } catch (e) { this.status = AsyncPromise.REJECTED; // 异常发生改变状态 this.reject(e); // 记录异常信息 } } resolve(value) { if (this.status == AsyncPromise.PENDING) { // 限制 this.status = AsyncPromise.FULFILLED; this.value = value; this.callbacks.map(callback => { // // 调用处理异步executor里resolve的方法。 callback.onfulfilled(value); }) } } reject(reason) { if (this.status == AsyncPromise.PENDING) { // 限制 this.status = AsyncPromise.REJECTED; this.value = reason; this.callbacks.map(callback => { // 调用处理异步executor里reject的方法。 callback.onrejected(reason); }) } } then(onfulfilled, onrejected) { if (typeof onfulfilled != \"function\") { // 如果传入的不是一个函数，默认创建空函数 onfulfilled = () => { }; } if (typeof onrejected != \"function\") { // 如果传入的不是一个函数，默认创建空函数 onrejected = () => { }; } return new AsyncPromise((resolve, reject) => { // 返回一个新的Promise if (this.status == AsyncPromise.FULFILLED) { // 状态改变时执行 setTimeout(() => { // 晚于线程同步任务执行 try { // then处理成功的函数onfulfilled中出现异常，交由当前then处理失败的函数onrejected函数进行处理。这个后面会做优化 onfulfilled(this.value); } catch (e) { onrejected(e); } }) } if (this.status == AsyncPromise.REJECTED) { // 状态改变时执行 setTimeout(() => { // 晚于线程同步任务执行 try { // then处理失败的函数onrejected中出现异常,交由当前then处理失败的函数onrejected函数进行处理。这个后面会做优化 onrejected(this.value); } catch (e) { onrejected(e); } }) } if (this.status == AsyncPromise.PENDING) { // 如果当前Promise是等待处理状态，则将处理成功的函数与处理失败的函数压入异步数组。 this.callbacks.push({ onfulfilled: value => { try { // 异步executor改变状态对其then中的onfulfilled进行异常捕获 onfulfilled(value); } catch (e) { onrejected(e); } }, onrejected: value => { try { // 异步executor改变状态对其then中的onrejected进行异常捕获 onrejected(value); } catch (e) { onrejected(e); } } }); } }); } } 现在我们的Promise已经支持then()的链式操作了，但是上面代码还是遗留了几个问题。 then()还没有返回值，返回普通值该怎么处理，返回一个新的Promise该怎么处理 没有异常传递，原生Promise中的then()当抛出异常时应该进行捕获并传递给下一个then() 不支持then()穿透 不支持类型限制 接下来继续对代码做出优化调整。 then中返回普通值 在原生的Promise中每一个then()所产生的Promise默认状态都是fulfilled，如果当前then()返回是一个值的话那么下一个then()将接受到该值。 这个也非常简单，代码接收一下每一个onfulfilled()与onrejected()的返回值就好，并使用resolve()改变状态为fulfilled以及将值进行传递给下一个then()。 class AsyncPromise { static PENDING = \"pending\"; static FULFILLED = \"fulfilled\"; static REJECTED = \"rejected\"; constructor(executor) { this.status = AsyncPromise.PENDING; // 初始状态为准备状态 this.value = null; // 初始值 this.callbacks = []; // 如果是一个异步操作，则放入该数组中 try { executor(this.resolve.bind(this), this.reject.bind(this)); // 传递形参，运行executor函数 } catch (e) { this.status = AsyncPromise.REJECTED; // 异常发生改变状态 this.reject(e); // 记录异常信息 } } resolve(value) { if (this.status == AsyncPromise.PENDING) { // 限制 this.status = AsyncPromise.FULFILLED; this.value = value; this.callbacks.map(callback => { // // 调用处理异步executor里resolve的方法。 callback.onfulfilled(value); }) } } reject(reason) { if (this.status == AsyncPromise.PENDING) { // 限制 this.status = AsyncPromise.REJECTED; this.value = reason; this.callbacks.map(callback => { // 调用处理异步executor里reject的方法。 callback.onrejected(reason); }) } } then(onfulfilled, onrejected) { if (typeof onfulfilled != \"function\") { // 如果传入的不是一个函数，默认创建空函数 onfulfilled = () => { }; } if (typeof onrejected != \"function\") { // 如果传入的不是一个函数，默认创建空函数 onrejected = () => { }; } return new AsyncPromise((resolve, reject) => { // 返回一个新的Promise if (this.status == AsyncPromise.FULFILLED) { // 状态改变时执行 setTimeout(() => { // 晚于线程同步任务执行 try { // then处理成功的函数onfulfilled中出现异常，交由当前then处理失败的函数onrejected函数进行处理。这个后面会做优化 let result = onfulfilled(this.value); resolve(result); } catch (e) { onrejected(e); } }) } if (this.status == AsyncPromise.REJECTED) { // 状态改变时执行 setTimeout(() => { // 晚于线程同步任务执行 try { // then处理失败的函数onrejected中出现异常,交由当前then处理失败的函数onrejected函数进行处理。这个后面会做优化 let result = onrejected(this.value); resolve(result); } catch (e) { onrejected(e); } }) } if (this.status == AsyncPromise.PENDING) { // 如果当前Promise是等待处理状态，则将处理成功的函数与处理失败的函数压入异步数组。 this.callbacks.push({ onfulfilled: value => { try { // 异步executor改变状态对其then中的onfulfilled进行异常捕获 let result = onfulfilled(value); resolve(result); } catch (e) { onrejected(e); } }, onrejected: value => { try { // 异步executor改变状态对其then中的onrejected进行异常捕获 let result = onrejected(value); resolve(result); } catch (e) { onrejected(e); } } }); } }); } } 这样我们的then()就支持返回普通值了。 \"use strict\"; new AsyncPromise((resolve, reject) => { setTimeout(() => { resolve(\"成功\"); }, 3000); }).then((success) => { return \"hello\"; }).then((success) => { console.log(success); // hello }); then中的异常传递 在上面的代码中，then()方法里的处理成功函数onfulfilled以及处理失败函数onrejected在代码执行时抛出的异常都会统一进行捕获并且传递给当前then()方法处理失败的函数onrejected。 这个与原生的Promise有出入，对于原生Promise来讲应该是传递给下一个then()进行处理而不是当前then()。 改动也非常简单，将原来发生异常传递的函数onrejected()改为reject()即可，这就是传递给下一个then()。 class AsyncPromise { static PENDING = \"pending\"; static FULFILLED = \"fulfilled\"; static REJECTED = \"rejected\"; constructor(executor) { this.status = AsyncPromise.PENDING; // 初始状态为准备状态 this.value = null; // 初始值 this.callbacks = []; // 如果是一个异步操作，则放入该数组中 try { executor(this.resolve.bind(this), this.reject.bind(this)); // 传递形参，运行executor函数 } catch (e) { this.status = AsyncPromise.REJECTED; // 异常发生改变状态 this.reject(e); // 记录异常信息 } } resolve(value) { if (this.status == AsyncPromise.PENDING) { // 限制 this.status = AsyncPromise.FULFILLED; this.value = value; this.callbacks.map(callback => { // // 调用处理异步executor里resolve的方法。 callback.onfulfilled(value); }) } } reject(reason) { if (this.status == AsyncPromise.PENDING) { // 限制 this.status = AsyncPromise.REJECTED; this.value = reason; this.callbacks.map(callback => { // 调用处理异步executor里reject的方法。 callback.onrejected(reason); }) } } then(onfulfilled, onrejected) { if (typeof onfulfilled != \"function\") { // 如果传入的不是一个函数，默认创建空函数 onfulfilled = () => { }; } if (typeof onrejected != \"function\") { // 如果传入的不是一个函数，默认创建空函数 onrejected = () => { }; } return new AsyncPromise((resolve, reject) => { // 返回一个新的Promise if (this.status == AsyncPromise.FULFILLED) { // 状态改变时执行 setTimeout(() => { // 晚于线程同步任务执行 try { let result = onfulfilled(this.value); resolve(result); } catch (e) { reject(e); // 传递给下一个then } }) } if (this.status == AsyncPromise.REJECTED) { // 状态改变时执行 setTimeout(() => { // 晚于线程同步任务执行 try { let result = onrejected(this.value); resolve(result); } catch (e) { reject(e); // 传递给下一个then } }) } if (this.status == AsyncPromise.PENDING) { // 如果当前Promise是等待处理状态，则将处理成功的函数与处理失败的函数压入异步数组。 this.callbacks.push({ onfulfilled: value => { try { let result = onfulfilled(value); resolve(result); } catch (e) { reject(e); // 传递给下一个then } }, onrejected: value => { try { let result = onrejected(value); resolve(result); } catch (e) { reject(e); // 传递给下一个then } } }); } }); } } 代码测试： \"use strict\"; new AsyncPromise((resolve, reject) => { setTimeout(() => { resolve(\"成功\"); }, 3000); }).then((success) => { throw new Error(\"新错误\"); }).then(null, error => { console.log(error); // 上一个then的错误成功由该then接收 }); then穿透功能实现 在原生的Promise中是支持then()的穿透传值的。 \"use strict\"; new Promise((resolve, reject) => { resolve(\"成功\"); }) .then() // 穿透 .then( success => { console.log(success); // 成功 }, error => { console.log(error); }) 但是我们的Promise却不支持。 \"use strict\"; new AsyncPromise((resolve, reject) => { resolve(\"成功\"); }) .then() // 不支持穿透 .then( success => { console.log(success); }, error => { console.log(error); }) 原因在于如果没有对then()进行传递参数，那么内部其实是会创建两个空函数。 我们只需要在空函数内部返回this.value即可。 class AsyncPromise { static PENDING = \"pending\"; static FULFILLED = \"fulfilled\"; static REJECTED = \"rejected\"; constructor(executor) { this.status = AsyncPromise.PENDING; // 初始状态为准备状态 this.value = null; // 初始值 this.callbacks = []; // 如果是一个异步操作，则放入该数组中 try { executor(this.resolve.bind(this), this.reject.bind(this)); // 传递形参，运行executor函数 } catch (e) { this.status = AsyncPromise.REJECTED; // 异常发生改变状态 this.reject(e); // 记录异常信息 } } resolve(value) { if (this.status == AsyncPromise.PENDING) { // 限制 this.status = AsyncPromise.FULFILLED; this.value = value; this.callbacks.map(callback => { // // 调用处理异步executor里resolve的方法。 callback.onfulfilled(value); }) } } reject(reason) { if (this.status == AsyncPromise.PENDING) { // 限制 this.status = AsyncPromise.REJECTED; this.value = reason; this.callbacks.map(callback => { // 调用处理异步executor里reject的方法。 callback.onrejected(reason); }) } } then(onfulfilled, onrejected) { if (typeof onfulfilled != \"function\") { // 如果传入的不是一个函数，默认创建空函数 onfulfilled = () => this.value; // 支持穿透 } if (typeof onrejected != \"function\") { // 如果传入的不是一个函数，默认创建空函数 onrejected = () => this.value; // 支持穿透 } return new AsyncPromise((resolve, reject) => { // 返回一个新的Promise if (this.status == AsyncPromise.FULFILLED) { // 状态改变时执行 setTimeout(() => { // 晚于线程同步任务执行 try { let result = onfulfilled(this.value); resolve(result); } catch (e) { reject(e); // 传递给下一个then } }) } if (this.status == AsyncPromise.REJECTED) { // 状态改变时执行 setTimeout(() => { // 晚于线程同步任务执行 try { let result = onrejected(this.value); resolve(result); } catch (e) { reject(e); // 传递给下一个then } }) } if (this.status == AsyncPromise.PENDING) { // 如果当前Promise是等待处理状态，则将处理成功的函数与处理失败的函数压入异步数组。 this.callbacks.push({ onfulfilled: value => { try { let result = onfulfilled(value); resolve(result); } catch (e) { reject(e); // 传递给下一个then } }, onrejected: value => { try { let result = onrejected(value); resolve(result); } catch (e) { reject(e); // 传递给下一个then } } }); } }); } } then返回Promise 原生的Promise支持返回一个新的Promise，但是我们的Promise现在还不支持。 其实也很简单，判断一下then()中两个函数返回的是不是一个新的Promise，如果是的话则使用其then()方法将其中resolve()或reject()的值进行传递。 class AsyncPromise { static PENDING = \"pending\"; static FULFILLED = \"fulfilled\"; static REJECTED = \"rejected\"; constructor(executor) { this.status = AsyncPromise.PENDING; // 初始状态为准备状态 this.value = null; // 初始值 this.callbacks = []; // 如果是一个异步操作，则放入该数组中 try { executor(this.resolve.bind(this), this.reject.bind(this)); // 传递形参，运行executor函数 } catch (e) { this.status = AsyncPromise.REJECTED; // 异常发生改变状态 this.reject(e); // 记录异常信息 } } resolve(value) { if (this.status == AsyncPromise.PENDING) { // 限制 this.status = AsyncPromise.FULFILLED; this.value = value; this.callbacks.map(callback => { // // 调用处理异步executor里resolve的方法。 callback.onfulfilled(value); }) } } reject(reason) { if (this.status == AsyncPromise.PENDING) { // 限制 this.status = AsyncPromise.REJECTED; this.value = reason; this.callbacks.map(callback => { // 调用处理异步executor里reject的方法。 callback.onrejected(reason); }) } } then(onfulfilled, onrejected) { if (typeof onfulfilled != \"function\") { // 如果传入的不是一个函数，默认创建空函数 onfulfilled = () => this.value; // 支持穿透 } if (typeof onrejected != \"function\") { // 如果传入的不是一个函数，默认创建空函数 onrejected = () => this.value; // 支持穿透 } return new AsyncPromise((resolve, reject) => { // 返回一个新的Promise if (this.status == AsyncPromise.FULFILLED) { // 状态改变时执行 setTimeout(() => { // 晚于线程同步任务执行 try { let result = onfulfilled(this.value); if (result instanceof AsyncPromise) { // 判断是否返回Promise对象 result.then(resolve, reject); } else { resolve(result); // 改变状态并将值交由下一个then接收 } } catch (e) { reject(e); // 传递给下一个then } }) } if (this.status == AsyncPromise.REJECTED) { // 状态改变时执行 setTimeout(() => { // 晚于线程同步任务执行 try { let result = onrejected(this.value); if (result instanceof AsyncPromise) { // 判断是否返回Promise对象 result.then(resolve, reject); } else { resolve(result); // 改变状态并将值交由下一个then接收 } } catch (e) { reject(e); // 传递给下一个then } }) } if (this.status == AsyncPromise.PENDING) { // 如果当前Promise是等待处理状态，则将处理成功的函数与处理失败的函数压入异步数组。 this.callbacks.push({ onfulfilled: value => { try { let result = onfulfilled(value); if (result instanceof AsyncPromise) { // 判断是否返回Promise对象 result.then(resolve, reject); } else { resolve(result); // 改变状态并将值交由下一个then接收 } } catch (e) { reject(e); // 传递给下一个then } }, onrejected: value => { try { let result = onrejected(value); if (result instanceof AsyncPromise) { // 判断是否返回Promise对象 result.then(resolve, reject); } else { resolve(result); // 改变状态并将值交由下一个then接收 } } catch (e) { reject(e); // 传递给下一个then } } }); } }); } } then的代码优化 可以观察到上面的then()方法中有很多重复代码，所以我们需要对重复代码做一下优化。 class AsyncPromise { static PENDING = \"pending\"; static FULFILLED = \"fulfilled\"; static REJECTED = \"rejected\"; constructor(executor) { this.status = AsyncPromise.PENDING; // 初始状态为准备状态 this.value = null; // 初始值 this.callbacks = []; // 如果是一个异步操作，则放入该数组中 try { executor(this.resolve.bind(this), this.reject.bind(this)); // 传递形参，运行executor函数 } catch (e) { this.status = AsyncPromise.REJECTED; // 异常发生改变状态 this.reject(e); // 记录异常信息 } } resolve(value) { if (this.status == AsyncPromise.PENDING) { // 限制 this.status = AsyncPromise.FULFILLED; this.value = value; this.callbacks.map(callback => { // // 调用处理异步executor里resolve的方法。 callback.onfulfilled(value); }) } } reject(reason) { if (this.status == AsyncPromise.PENDING) { // 限制 this.status = AsyncPromise.REJECTED; this.value = reason; this.callbacks.map(callback => { // 调用处理异步executor里reject的方法。 callback.onrejected(reason); }) } } then(onfulfilled, onrejected) { if (typeof onfulfilled != \"function\") { // 如果传入的不是一个函数，默认创建空函数 onfulfilled = () => this.value; // 支持穿透 } if (typeof onrejected != \"function\") { // 如果传入的不是一个函数，默认创建空函数 onrejected = () => this.value; // 支持穿透 } return new AsyncPromise((resolve, reject) => { // 返回一个新的Promise if (this.status == AsyncPromise.FULFILLED) { // 状态改变时执行 setTimeout(() => { // 晚于线程同步任务执行 this.parse(onfulfilled(this.value), resolve, reject); }) } if (this.status == AsyncPromise.REJECTED) { // 状态改变时执行 setTimeout(() => { // 晚于线程同步任务执行 this.parse(onrejected(this.value), resolve, reject); }) } if (this.status == AsyncPromise.PENDING) { // 如果当前Promise是等待处理状态，则将处理成功的函数与处理失败的函数压入异步数组。 this.callbacks.push({ onfulfilled: value => { this.parse(onfulfilled(value), resolve, reject); }, onrejected: value => { this.parse(onrejected(value), resolve, reject); } }); } }); } parse(result, resolve, reject) { try { if (result instanceof AsyncPromise) { // 判断是否返回Promise对象 result.then(resolve, reject); } else { resolve(result); // 改变状态并将值交由下一个then接收 } } catch (e) { reject(e); // 向下传递异常 } } } then返回类型限制 我们都知道then()会创建一个Promise并返回，但是原生的Promise不支持then()将自己创建的Promise进行返回 \"use strict\"; let task = new Promise((resolve, reject) => { resolve(\"成功\"); }) let then01 = task.then( // 由于then中的处理成功与处理失败的函数是属于异步执行。所以会先将创建好的Promise对象返回再运行其中的处理成功函数与处理失败函数。 success => { return p2; } ) // Uncaught (in promise) TypeError: Chaining cycle detected for promise # 但是我们的Promise还不支持这一点，所以需要改一改代码。 解决的思路也很简单，在运行失败或处理函数时判断一下本次返回的值是否等同于创建的Promise对象。 class AsyncPromise { static PENDING = \"pending\"; static FULFILLED = \"fulfilled\"; static REJECTED = \"rejected\"; constructor(executor) { this.status = AsyncPromise.PENDING; // 初始状态为准备状态 this.value = null; // 初始值 this.callbacks = []; // 如果是一个异步操作，则放入该数组中 try { executor(this.resolve.bind(this), this.reject.bind(this)); // 传递形参，运行executor函数 } catch (e) { this.status = AsyncPromise.REJECTED; // 异常发生改变状态 this.reject(e); // 记录异常信息 } } resolve(value) { if (this.status == AsyncPromise.PENDING) { // 限制 this.status = AsyncPromise.FULFILLED; this.value = value; this.callbacks.map(callback => { // // 调用处理异步executor里resolve的方法。 callback.onfulfilled(value); }) } } reject(reason) { if (this.status == AsyncPromise.PENDING) { // 限制 this.status = AsyncPromise.REJECTED; this.value = reason; this.callbacks.map(callback => { // 调用处理异步executor里reject的方法。 callback.onrejected(reason); }) } } then(onfulfilled, onrejected) { if (typeof onfulfilled != \"function\") { // 如果传入的不是一个函数，默认创建空函数 onfulfilled = () => this.value; // 支持穿透 } if (typeof onrejected != \"function\") { // 如果传入的不是一个函数，默认创建空函数 onrejected = () => this.value; // 支持穿透 } let promise = new AsyncPromise((resolve, reject) => { // 返回一个新的Promise if (this.status == AsyncPromise.FULFILLED) { // 状态改变时执行 setTimeout(() => { // 晚于线程同步任务执行 this.parse(promise, onfulfilled(this.value), resolve, reject); }) } if (this.status == AsyncPromise.REJECTED) { // 状态改变时执行 setTimeout(() => { // 晚于线程同步任务执行 this.parse(promise, onrejected(this.value), resolve, reject); }) } if (this.status == AsyncPromise.PENDING) { // 如果当前Promise是等待处理状态，则将处理成功的函数与处理失败的函数压入异步数组。 this.callbacks.push({ onfulfilled: value => { this.parse(promise, onfulfilled(value), resolve, reject); }, onrejected: value => { this.parse(promise, onrejected(value), resolve, reject); } }); } }); return promise; // 同步，先返回。onfulfilled与onrejected由于套了setTimeout，是异步执行。 } parse(promise, result, resolve, reject) { if (promise == result) { throw new TypeError(\"Chaining cycle detected\"); } try { if (result instanceof AsyncPromise) { // 判断是否返回Promise对象 result.then(resolve, reject); } else { resolve(result); // 改变状态并将值交由下一个then接收 } } catch (e) { reject(e); // 向下传递异常 } } } resolve与reject实现 使用 Promise.resolve() 方法可以快速的返回一个状态是fulfilled的Promise对象。 使用 Promise.reject() 方法可以快速的返回一个状态是rejected的Promise对象。 class AsyncPromise { static PENDING = \"pending\"; static FULFILLED = \"fulfilled\"; static REJECTED = \"rejected\"; constructor(executor) { this.status = AsyncPromise.PENDING; // 初始状态为准备状态 this.value = null; // 初始值 this.callbacks = []; // 如果是一个异步操作，则放入该数组中 try { executor(this.resolve.bind(this), this.reject.bind(this)); // 传递形参，运行executor函数 } catch (e) { this.status = AsyncPromise.REJECTED; // 异常发生改变状态 this.reject(e); // 记录异常信息 } } resolve(value) { if (this.status == AsyncPromise.PENDING) { // 限制 this.status = AsyncPromise.FULFILLED; this.value = value; this.callbacks.map(callback => { // // 调用处理异步executor里resolve的方法。 callback.onfulfilled(value); }) } } reject(reason) { if (this.status == AsyncPromise.PENDING) { // 限制 this.status = AsyncPromise.REJECTED; this.value = reason; this.callbacks.map(callback => { // 调用处理异步executor里reject的方法。 callback.onrejected(reason); }) } } then(onfulfilled, onrejected) { if (typeof onfulfilled != \"function\") { // 如果传入的不是一个函数，默认创建空函数 onfulfilled = () => this.value; // 支持穿透 } if (typeof onrejected != \"function\") { // 如果传入的不是一个函数，默认创建空函数 onrejected = () => this.value; // 支持穿透 } let promise = new AsyncPromise((resolve, reject) => { // 返回一个新的Promise if (this.status == AsyncPromise.FULFILLED) { // 状态改变时执行 setTimeout(() => { // 晚于线程同步任务执行 this.parse(promise, onfulfilled(this.value), resolve, reject); }) } if (this.status == AsyncPromise.REJECTED) { // 状态改变时执行 setTimeout(() => { // 晚于线程同步任务执行 this.parse(promise, onrejected(this.value), resolve, reject); }) } if (this.status == AsyncPromise.PENDING) { // 如果当前Promise是等待处理状态，则将处理成功的函数与处理失败的函数压入异步数组。 this.callbacks.push({ onfulfilled: value => { this.parse(promise, onfulfilled(value), resolve, reject); }, onrejected: value => { this.parse(promise, onrejected(value), resolve, reject); } }); } }); return promise; // 同步，先返回。onfulfilled与onrejected由于套了setTimeout，是异步执行。 } parse(promise, result, resolve, reject) { if (promise == result) { throw new TypeError(\"Chaining cycle detected\"); } try { if (result instanceof AsyncPromise) { // 判断是否返回Promise对象 result.then(resolve, reject); } else { resolve(result); // 改变状态并将值交由下一个then接收 } } catch (e) { reject(e); // 向下传递异常 } } static resolve(value) { return new AsyncPromise((resolve, reject) => { if (value instanceof AsyncPromise) { value.then(resolve, reject); } else { resolve(value); } }); } static reject(value) { return new AsyncPromise((resolve, reject) => { reject(value); }); } } all与race实现 使用Promise.all() 方法可以同时执行多个并行异步操作，比如页面加载时同进获取课程列表与推荐课程。任何一个 Promise 执行失败就会调用 catch方法，成功后返回 Promise 结果的有序数组。（Ps：我们这个Promise没有实现catch方法） 使用Promise.race() 处理容错异步，和race单词一样哪个Promise快用哪个，哪个先返回用哪个。 class AsyncPromise { static PENDING = \"pending\"; static FULFILLED = \"fulfilled\"; static REJECTED = \"rejected\"; constructor(executor) { this.status = AsyncPromise.PENDING; // 初始状态为准备状态 this.value = null; // 初始值 this.callbacks = []; // 如果是一个异步操作，则放入该数组中 try { executor(this.resolve.bind(this), this.reject.bind(this)); // 传递形参，运行executor函数 } catch (e) { this.status = AsyncPromise.REJECTED; // 异常发生改变状态 this.reject(e); // 记录异常信息 } } resolve(value) { if (this.status == AsyncPromise.PENDING) { // 限制 this.status = AsyncPromise.FULFILLED; this.value = value; this.callbacks.map(callback => { // // 调用处理异步executor里resolve的方法。 callback.onfulfilled(value); }) } } reject(reason) { if (this.status == AsyncPromise.PENDING) { // 限制 this.status = AsyncPromise.REJECTED; this.value = reason; this.callbacks.map(callback => { // 调用处理异步executor里reject的方法。 callback.onrejected(reason); }) } } then(onfulfilled, onrejected) { if (typeof onfulfilled != \"function\") { // 如果传入的不是一个函数，默认创建空函数 onfulfilled = () => this.value; // 支持穿透 } if (typeof onrejected != \"function\") { // 如果传入的不是一个函数，默认创建空函数 onrejected = () => this.value; // 支持穿透 } let promise = new AsyncPromise((resolve, reject) => { // 返回一个新的Promise if (this.status == AsyncPromise.FULFILLED) { // 状态改变时执行 setTimeout(() => { // 晚于线程同步任务执行 this.parse(promise, onfulfilled(this.value), resolve, reject); }) } if (this.status == AsyncPromise.REJECTED) { // 状态改变时执行 setTimeout(() => { // 晚于线程同步任务执行 this.parse(promise, onrejected(this.value), resolve, reject); }) } if (this.status == AsyncPromise.PENDING) { // 如果当前Promise是等待处理状态，则将处理成功的函数与处理失败的函数压入异步数组。 this.callbacks.push({ onfulfilled: value => { this.parse(promise, onfulfilled(value), resolve, reject); }, onrejected: value => { this.parse(promise, onrejected(value), resolve, reject); } }); } }); return promise; // 同步，先返回。onfulfilled与onrejected由于套了setTimeout，是异步执行。 } parse(promise, result, resolve, reject) { if (promise == result) { throw new TypeError(\"Chaining cycle detected\"); } try { if (result instanceof AsyncPromise) { // 判断是否返回Promise对象 result.then(resolve, reject); } else { resolve(result); // 改变状态并将值交由下一个then接收 } } catch (e) { reject(e); // 向下传递异常 } } static resolve(value) { return new AsyncPromise((resolve, reject) => { if (value instanceof AsyncPromise) { value.then(resolve, reject); } else { resolve(value); } }); } static reject(value) { return new AsyncPromise((resolve, reject) => { reject(value); }); } static all(value) { return new AsyncPromise((resolve, reject) => { const values = []; // 记录当前有多少promise状态是成功 promise.forEach((promise) => { promise.then(value => { values.push(value); if (values.length == promise.length) { resolve(values); // 如果都成功，当前all返回的promise则状态为fulfilled。 } }, reason => { reject(reason); // 如果有一个promise错误，则当前all返回的promise则为拒绝 }) }); }); } static race(value) { return new AsyncPromise((resolve, reject) => { value.forEach(promise => { promise.then(value => { // 如果循环中的promise状态为fulfilled，则当前的race创建的promise状态也为resolve resolve(value); }, reason => { reject(value); // 同上 }) }) }) } } Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:48 "},"前端专栏/JavaScript/异常处理.html":{"url":"前端专栏/JavaScript/异常处理.html","title":"异常处理","keywords":"","body":"异常处理 程序异常可分为逻辑异常和语法异常，对于初学者而言语法异常居多，随着不断的学习对语言越来越熟悉后语法异常减少逻辑异常增多。 在JavaScript中提供了对异常进行处理的语句，在适当的时候使用它们能够使程序变得更加健壮。 但是要注意不要滥用异常处理，它会使程序的可读性变差。 异常类型 所有的异常都是对象，在JavaScript中，常见异常类型有以下几种： 异常类型 简述 Error 基本异常，该异常作为所有异常的基类产生 EvalError eval错误，一般是由于不当的使用eval()函数产生 RangeError 范围错误，常见于Array中产生，如索引无效 ReferenceError 引用错误，常见于定义变量时产生，如变量名不存在 SyntaxError 语法错误 TypeError 类型错误 URIError 在使用encodeURI()或者decodeURI()因为URL格式不正确时，就会导致URIError错误。 异常捕获 try catch 使用try与catch语句进行捕获异常： try用于检测可能出现异常的代码块 catch用于处理捕捉到的异常，可指定参数获取异常信息 try/catch语句有一个包含一条或者多条语句的，0个或1个的catch代码块，catch代码块中的语句会在try代码块中抛出异常时执行。 如果try代码块中的语句（或者try代码块中调用的方法）一旦抛出了异常，那么执行流程会立即进入catch代码块。 如果try代码块没有抛出异常，catch代码块就会被跳过： \"use strict\"; try { console.log(username); } catch (e) { console.log(\"处理了一个异常:\", e); } // 处理了一个异常,ID: ReferenceError: username is not defined finally finally块包含了在try和catch块完成后、下面接着try/catch的语句之前执行的语句。 finally块无论是否抛出异常都会执行，如果抛出了一个异常，就算没有异常处理，finally块里的语句也会执行： \"use strict\"; try { console.log(username); } catch (e) { console.log(\"处理了一个异常,ID:\", e); } finally { console.log(\"无论有没有异常都会执行我\"); } // 处理了一个异常,ID: ReferenceError: username is not defined // 无论有没有异常都会执行我 主动异常 throw new Error 在某些时候我们需要主动抛出异常，使用throw语句抛出异常： \"use strict\"; throw new Error(\"这是一个错误\") // demo.js:3 Uncaught Error: 这是一个错误 表达式形式 你可以抛出任意表达式而不是特定一种类型的表达式。 下面的代码中抛出了几个不同类型的表达式： \"use strict\"; throw \"Error2\"; // String type throw 42; // Number type throw true; // Boolean type throw { toString: function () { return \"I'm an object!\"; } }; 自定义异常 原型继承 继承Error原型对象，可配置自定义的异常。 Error构造函数具有message可选参数，用于显示人类可阅读的错误描述信息。 如下所示： \"use strict\"; function MyError(message) { this.name = 'MyError'; this.message = message || 'Default Message'; this.stack = (new Error()).stack; } Object.setPrototypeOf(MyError, Error); // 继承Error原型对象 try { throw new MyError(); } catch (e) { console.log(e.name); // MyError console.log(e.message); // Default Message } try { throw new MyError(\"自定义异常被抛出\"); } catch (e) { console.log(e.name); // MyError console.log(e.message); // 自定义异常被抛出 } // MyError // Default Message // MyError // 自定义异常被抛出 类继承 使用class语法进行自定义异常： \"use strict\"; class MyError extends Error { constructor(message) { super(); this.name = \"MyError\"; this.message = message || 'Default Message'; this.stack = (new Error()).stack; } } try { throw new MyError(); } catch (e) { console.log(e.name); console.log(e.message); } try { throw new MyError(\"自定义异常被抛出\"); } catch (e) { console.log(e.name); console.log(e.message); } // MyError // Default Message // MyError // 自定义异常被抛出 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:48 "},"前端专栏/JavaScript/模块封装.html":{"url":"前端专栏/JavaScript/模块封装.html","title":"模块封装","keywords":"","body":"基础知识 历史背景 在早期时，JavaScript并没有模块这一个概念，通常是一个文档对应一个JS文件即可。 但是随着时间的推移和技术的发展，我们面临的需求也越来越大，此时将一些复用性较强的代码封装成模块变成了必要的趋势。 本章节中主要介绍原生的JavaScript封装的几种常用手段以及ES6新增的Module封装法。 window对象 假设你在一个文档中导入了多个JavaScript脚本文件，如果这些JavaScript脚本文件中不采用任何封装手段那么将会直接导致window环境污染的问题。 我们知道，所有函数名、var声明的变量名都会存放到window对象中，即使是多个JavaScript脚本文件中的函数名、变量名也不例外，只要在一个文档中引入它们，它们都会存放在这个文档的window对象中。 如下所示，我们将展示可能出现的环境污染问题： 1）demo1.js代码： \"use strict\"; var moduleName = \"demo1\"; function show() { console.log(\"hello demo1\"); } 2）demo2.js代码： \"use strict\"; var moduleName = \"demo2\"; function show() { console.log(\"hello demo2\"); } 3）HTML代码，注意，demo2引入在demo1之后，所以window对象中demo1的moduleName和show都被demo2的同名变量及函数覆盖掉了： \"use strict\"; console.log(moduleName); // demo2 show(); // hello demo2 整个过程如图所示： IIFE封装 针对上述问题，我们可以采取函数的作用域特性以及对象声明进行解决。 解决的办法就是利用自执行函数（IIFE），这在ES6之前是通用的解决策略，它总共分为2个步骤： 第一步：将所有代码包裹在一个自执行函数之中，这样var变量和函数就不会提升到window作用域下，且外部禁止访问自执行函数内部代码 第二步：向外部暴露接口，为window对象添加一组新的键值对 如下所示，使用IIFE进行对模块代码进行封装： 1）demo1.js代码： \"use strict\"; (function () { var moduleName = \"demo1\"; function show() { console.log(\"hello demo1\"); } window.demo1 = { \"moduleName\": moduleName, \"show\": show, }; })(); 2）demo2.js代码： \"use strict\"; (function () { var moduleName = \"demo2\"; function show() { console.log(\"hello demo2\"); } window.demo2 = { \"moduleName\": moduleName, \"show\": show, }; })(); 3）HTML代码： \"use strict\"; console.log(demo1.moduleName); // demo1 console.log(demo2.moduleName); // demo2 demo1.show(); // hello demo1 demo2.show(); // hello demo2 整个过程如图所示： ES6块级封装 ES6之前，模块封装的主流方式是IIFE，它利用了函数作用域 + 对象声明的方式解决了window环境污染问题。 但是在ES6之后，由于块级作用域的出现，故我们可以使用块级作用域来代替函数作用域，它更加简单也更加直白，但是其实它的本质也是和IIFE封装法相同，都是利用作用域 + 对象声明的特性来进行解决的。 如下所示，使用块级作用域进行对模块代码进行封装： 1）demo1.js代码，注意！仅有const和let具有块级作用域： \"use strict\"; { let moduleName = \"demo1\"; let show = function () { console.log(\"hello demo1\"); } window.demo1 = { // ES6新语法 moduleName, show, }; } 2）demo2.js代码，注意！仅有const和let具有块级作用域： \"use strict\"; (function () { var moduleName = \"demo2\"; function show() { console.log(\"hello demo2\"); } window.demo2 = { \"moduleName\": moduleName, \"show\": show, }; })(); 3）HTML代码： \"use strict\"; console.log(demo1.moduleName); // demo1 console.log(demo2.moduleName); // demo2 demo1.show(); // hello demo1 demo2.show(); // hello demo2 整个过程如图所示，它其实和IIFE封装法原理相同： ES6 module 上面的两种方式虽然都能达到模块封装的效果，但是我们依然有更好的选择。 下面将介绍极力推荐的ES6 module语法进行导入。 学习ES6 module从以下3个方面进行入手： 作为使用者，学会使用模块标签，并了解它的特性 作为使用者，如何导入模块中的某个功能 作用开发者，如何导出模块中的某个功能 模块标签 声明标签 模块标签，顾名思义我们需要使用该标签来导入模块，在JavaScript中所有以js后缀名结尾的文件都是一个模块。 声明标签只需要在标签中添加标准属性type=“module”即可： 注意！只有模块标签中才可以使用import系列语法，而普通标签中是不能使用的。 导入路径 导入路径必须使用相对路径导入，即使模块位于当前目录中也不可省略./前缀。 1）正确的导入路径： 2）错误的导入路径： 其实无论什么语言，在导入某个文件时都应该使用相对路径，而不是绝对路径，这是一个良好的行为习惯。 延迟解析 延迟解析是指在模块标签中的代码会在标准的标签以及添加了defer的之后执行。 如下所示，模块标签即使声明在最上方，但是它的代码也会最后执行： \"use strict\"; console.log(\"module\"); \"use strict\"; console.log(\"standard\"); \"use strict\"; console.log(\"defer\"); 执行结果： standard defer module 严格模式 模块标签中的所有代码都是按严格模式运行的，即使你没有声明use strict。 所以请注意变量声明以及this指向还有解构赋值等问题。 1）必须使用关键字声明变量： userName = \"Jack\"; // userName is not defined 2）留意this指向： (()=>{ console.log(this); })(); // undefined 3）解构赋值前也需要声明变量： let ary = [\"Jack\", \"18\", \"male\"]; let [name, age, gender] = ary; console.log(name); console.log(age); console.log(gender); // Jack // 18 // male 作用域 每个模块标签中的代码系统都会为其创建一个专属的作用域，禁止相互之间访问： \"use strict\"; let name = \"Jack\"; \"use strict\"; console.log(name); // Uncaught ReferenceError: name is not defined 而普通标签中的代码执行都会在全局作用域下，相互之间可以访问： \"use strict\"; let name = \"Jack\"; \"use strict\"; console.log(name); // Jack 预加载 模块在导入时就会将模块中的代码全部运行一次，后续再次导入时将不会重复运行，而是使用第一次的解析结果。 demo.js代码如下： \"use strict\"; console.log(\"hello demo\"); 模块标签，多次导入只运行一次： 普通标签，导入几次执行几次： 导出模块 基本介绍 我们可以使用export来将模块中的某个功能进行导出，导出方式分为以下几种： 单个导出 批量导出 默认导出 混合导出 别名导出 单个导出 在需要导出的功能前加上export关键字即可，如下所示，一次export只能导出一个功能： \"use strict\"; export let moduleName = \"demo\"; export function show() { console.log(\"hello demo\"); } export class Person { constructor(name, age) { this.name = name; this.age = age; } get info() { return `your name : ${this.name}`; } } 批量导出 我们可以使用export搭配{}来批量添加需要导出的功能。 这种方法应该是最常用的： \"use strict\"; let moduleName = \"demo\"; function show() { console.log(\"hello demo\"); } class Person { constructor(name, age) { this.name = name; this.age = age; } get info() { return `your name : ${this.name}`; } } export { moduleName, show, Person }; 注意！这个{}并不是一个对象，不能使用key:value的形式进行定义！ 默认导出 一个模块中，只能有一个默认导出。 也就是说，当你的模块只有一个对外部开放的接口的时，你可以使用默认导出。 如果默认导出的是一个类，那么该类就可以不用起名字，函数同理： \"use strict\"; export default class { constructor(name, age) { this.name = name; this.age = age; } get info() { return `your name : ${this.name}`; } } 混合导出 我们可以使用单个+默认导出和批量导出达到混合导出的功能，如下所示： \"use strict\"; let moduleName = \"demo\"; function show() { console.log(\"hello demo\"); } export default class { constructor(name, age) { this.name = name; this.age = age; } get info() { return `your name : ${this.name}`; } } export { moduleName, show }; 别名导出 使用as为导出的接口添加一个别名，如果别名为default则将该功能当做默认导出。 \"use strict\"; let moduleName = \"demo\"; function show() { console.log(\"hello demo\"); } class Person { constructor(name, age) { this.name = name; this.age = age; } get info() { return `your name : ${this.name}`; } } export { moduleName, show, Person as default }; 导入模块 基本介绍 使用import与from静态的导入一个模块，注意导入时应当将导入语句放在最顶层（如果有严格声明，则将导入语句放在严格声明语句之下）。 同时，导入模块的import/from语句只能在模块标签中使用，普通的标签中无法进行使用。 模块的导入分为以下几部分： 单个导入 批量导入 默认导入 混合导入 别名导入 动态导入 单个导入 单个导入的时候，使用import {} form “filePath.js”来导入模块中具体的功能。 一次可以导入一个，也可以导入多个。 注意，导入的接口名称应当和导出的接口名称一致，如下所示。 1）模块导出的代码： \"use strict\"; let moduleName = \"demo\"; function show() { console.log(\"hello demo\"); } class Person { constructor(name, age) { this.name = name; this.age = age; } get info() { return `your name : ${this.name}`; } } export { moduleName, show, Person }; 2）模块导入的代码： \"use strict\"; import { moduleName, show, Person } from \"./demo.js\"; console.log(moduleName); // demo show(); // hello demo let ins = new Person(\"Jack\", 18); console.log(ins.info); // your name : Jack 批量导入 使用import * as 别名 from “path”来导入一个模块中所有被导出的功能。 注意，在使用某个功能前，需要加上别名的前缀，然后点出功能，如下所示。 1）模块导出的代码： \"use strict\"; let moduleName = \"demo\"; function show() { console.log(\"hello demo\"); } class Person { constructor(name, age) { this.name = name; this.age = age; } get info() { return `your name : ${this.name}`; } } export { moduleName, show, Person }; 2）模块导入的代码： \"use strict\"; import * as demo from \"./demo.js\"; console.log(demo.moduleName); demo.show(); let ins = new demo.Person(\"Jack\", 18); console.log(ins.info); 默认导入 使用默认导入时不需要用{}来进行接收，可以使用任意一个名字来接收默认导出的接口。 如下所示。 1）模块导出的代码： \"use strict\"; export default class { constructor(name, age) { this.name = name; this.age = age; } get info() { return `your name : ${this.name}`; } } 2）模块导入的代码： \"use strict\"; import demoPerson from \"./demo.js\"; let ins = new demoPerson(\"Jack\", 18); console.log(ins.info); 混合导入 当一个模块中导出的又有默认导出的接口，又有其他的导出接口时，我们可以使用混合导入。 先为默认导出的接口取一个名字，然后在使用{}来接收其他的导出接口，注意{}中导入的接口名称应当和模块中非默认导出的接口名称一致，如下所示。 1）模块导出的代码： \"use strict\"; let moduleName = \"demo\"; function show() { console.log(\"hello demo\"); } class Person { constructor(name, age) { this.name = name; this.age = age; } get info() { return `your name : ${this.name}`; } } export { moduleName, show, Person as default }; 2）模块导入的代码： \"use strict\"; import demoPerson, { moduleName, show } from \"./demo.js\"; console.log(moduleName); show(); let ins = new demoPerson(\"Jack\", 18); console.log(ins.info); 别名导入 为了防止多个模块下接口名相同，我们可以使用as进行别名导入，在使用时也将按照别名的方式进行使用，如下所示。 1）模块导出的代码： \"use strict\"; let moduleName = \"demo\"; function show() { console.log(\"hello demo\"); } class Person { constructor(name, age) { this.name = name; this.age = age; } get info() { return `your name : ${this.name}`; } } export { moduleName, show, Person as default }; 2）模块导入的代码： \"use strict\"; import demoPerson, { moduleName as demoModuleName, show as demoShow } from \"./demo.js\"; console.log(demoModuleName); demoShow(); let ins = new demoPerson(\"Jack\", 18); console.log(ins.info); 动态导入 使用import/form的方式属于静态导入，必须将导入语句防止在最顶层，否则则抛出异常。 但在有些时候，我们想在某段特定代码执行后再导入某个模块的功能时，静态导入就不能完成需求了，此时你需要利用import()函数来实现动态导入按需加载，它将返回一个Promise对象，我们可以使用解构语法将模块中的接口一个一个全拿出来。 如下所示。 1）模块内容，demo.js代码： \"use strict\"; let n = Math.floor(Math.random() * (90 - 65 + 1)) + 65; function getStr() { return String.fromCharCode(n); } function getNumber() { return n; } export { getStr, getNumber }; 2）使用模块，在条件为真的情况下导入并使用模块的getStr()功能，在条件为假的情况下导入并使用模块的getNumber()功能： \"use strict\"; let condition = Math.floor((Math.random() * 100) + 1) % 2 === 0; if(condition){ import(\"./demo.js\").then( // 解构语法 ({ getStr }) => { console.log(getStr()); } ) } else{ import(\"./demo.js\").then( // 解构语法 ({ getNumber }) => { console.log(getNumber()); } ) } 合并封装 如果有多个小模块都需要被使用，我们可以将其合成一个大模块。 在使用时只需要导入大模块即可，如： login.js：包含登录相关的接口 register.js：包含注册相关的接口 user.js：包含登录和注册相关的所有接口 下面是整体结构： ├── index.html └── user ├── login.js ├── register.js └── user.js 接下来开始合并封装。 1）子模块，login.js： \"use strict\"; function verifyCodeLogin() { return \"Verification code login...\"; } function passwordLogin() { return \"Password login ...\"; } export { verifyCodeLogin, passwordLogin }; 2）子模块，register.js： \"use strict\"; function phoneRegister() { return \"phone register ...\" } function wechatRegister() { return \"wechat register ...\" } export { phoneRegister, wechatRegister } 3）总模块，user.js： import * as login from \"./login.js\"; import * as register from \"./register.js\"; export { login, register } 4）使用，index.html： \"use strict\"; import { login, register } from \"./user/user.js\"; // 登录 console.log( login.verifyCodeLogin() ); console.log( login.passwordLogin() ); // 注册 console.log( register.phoneRegister() ); console.log( register.wechatRegister() ); Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:48 "},"前端专栏/JavaScript/综合练习.html":{"url":"前端专栏/JavaScript/综合练习.html","title":"综合练习","keywords":"","body":"正反向 使用JavaScript完成正反向的效果： 实现如下： Document body { justify-content: center; align-items: center; display: flex; width: 100vw; height: 100vh; } main { justify-content: center; align-items: center; display: flex; flex-flow: column; border: 1px solid #ddd; padding: 10px; } 全选 取消 反选 爱好 篮球 足球 排球 \"use strict\"; window.onload = (event) => { bind(); } function bind() { document.querySelectorAll(\"button\").forEach((element) => { element.addEventListener(\"click\", select) }); } function select() { let choice = event.target.dataset.select; let inputList = document.getElementsByName(\"hobby\"); inputList.forEach((element) => { if (choice == \"all\") { // 全选 element.checked = true; } else if (choice == \"cancel\") { // 取消 element.checked = false; } else { // 反选 element.checked = !element.checked; } }); } 二级联动 使用JavaScript完成二级联动： 实现如下： Document 请选择省份 请选择城市 window.onload = (event) => { init(); } function init() { let data = { 浙江省: [\"杭州\", \"宁波\", \"嘉兴\"], 四川省: [\"成都\", \"绵阳\", \"德阳\"], 江苏省: [\"南京\", \"苏州\", \"无锡\"] }; // 模拟后台数据 let province = document.querySelector(\"[name='province']\"); let city = document.querySelector(\"[name='city']\"); for (let name of Object.keys(data)) { let option = document.createElement(\"option\"); option.value = name; option.innerText = name; province.append(option); } province.addEventListener(\"change\", function () { // 不用箭头函数，箭头函数指向window或undefined city.length = 1; // 每次更新内容,只留下 请选择城市 let provinceName = this.options[this.selectedIndex].value; // options所有的option标签，selectedIndex当前选中的option索引 let cityData = data[provinceName]; cityData.forEach((cityName) => { let option = document.createElement(\"option\"); option.value = cityName; option.innerText = cityName; city.append(option); }); }) } 如果联动过多，则可以使用async+await来优化层次结构，避免死亡嵌套。 元素拖动 有的时候，一些弹出的登录框是允许我们拖动的。 所以在这里我们也可以利用空间坐标等信息来实现一次元素拖动。 实现如下： main { width: 100px; height: 100px; background-color: red; position: absolute; z-index: 10; } main:hover { cursor: pointer; } \"use strict\"; let mainNode = document.querySelector(\"main\"); class MoveElement { constructor(node) { this.element = node; this.x = null; this.y = null; } handleEvent(event) { this[event.type](event); } mousedown(event) { // 要移动的距离 = 鼠标位置 - 元素位于文档的位置 this.x = event.clientX - this.element.offsetLeft; this.y = event.clientY - this.element.offsetTop; // 注意，这里移动一定要绑定在document上，如果绑定在要拖动元素上则会造成拖动卡顿的现象 document.addEventListener(\"mousemove\", this) } mouseup(event) { document.removeEventListener(\"mousemove\", this); } mousemove(event) { // 不断的计算新位置 let X = event.clientX - this.x; let Y = event.clientY - this.y; // 边界限制 X 水平轴 switch (true) { case X document.documentElement.clientWidth - this.element.offsetWidth: X = document.documentElement.clientWidth - this.element.offsetWidth; break } // 边界限制 Y 垂直轴 switch (true) { case Y document.documentElement.clientHeight - this.element.offsetHeight: Y = document.documentElement.clientHeight - this.element.offsetHeight; break } this.element.style.cssText = `left: ${X}px; top: ${Y}px`; } } // 传入要移动的元素 let move = new MoveElement(mainNode); mainNode.addEventListener(\"mousedown\", move); mainNode.addEventListener(\"mouseup\", move); 模态对话框 在有的场景中，当点击登录或者注册的按钮后整个页面会弹出登录和注册的一个窗口。其他部分均变为灰色，我们可以利用calss的增删改查来实现这一需求和功能。 模态对话框一般分为三层 第一层显示层，显示其他主要的信息，如页面主题等 第二层遮罩层，当点击某一特定按钮后触发 第三层功能层，登录或注册功能的功能均在此层 实现如下： Document * { margin: 0; padding: 0; } body { width: 100vw; height: 100vh; position: relative; } main { width: 100%; height: 100%; background: deeppink; } main button { position: absolute; right: 2%; top: 2%; } aside { width: 100%; height: 100%; background: darkslategray; opacity: .3; position: absolute; top: 0; z-index: 2; } article { padding: 10px; background-color: deepskyblue; position: fixed; left: 50%; top: 50%; transform: translate(-50%, -50%); z-index: 10; } article form * { margin: 5px; } .hidden { display: none; } 登录 欢迎登录 提交 取消 window.onload = (event) => { init(); } function init() { let showBTN = document.querySelector(\"main button\"); // 登录按钮 let hiddenBTN = document.querySelector(\"article.hidden form button[type='button']\"); // 取消按钮 let cover = document.querySelector(\"aside.hidden\"); let login = document.querySelector(\"article.hidden\"); showBTN.addEventListener(\"click\", () => { cover.classList.toggle(\"hidden\"); // 若有hidden则取消，没有则添加 login.classList.toggle(\"hidden\"); }); hiddenBTN.addEventListener(\"click\", () => { cover.classList.toggle(\"hidden\"); login.classList.toggle(\"hidden\"); }); } 左侧菜单栏 左侧三个菜单栏，点击任何一个隐藏另外两个。 用WeakMap来做一个容器，让其与对应的菜单标签建立联系 当点击一个标题时循环容器，将非事件目标的对应标签设置为隐藏，将事件目标的对应标签设置为显示 实现如下： Document * { margin: 0; padding: 0; list-style: none; } body { width: 100vw; height: 100vh; display: flex; } header { width: 30%; height: 100%; display: flex; flex-flow: column; justify-content: start; align-items: center; background-color: deeppink; cursor: pointer; } header nav { width: 95%; margin: 10px 0; } header nav h1 { display: flex; justify-content: center; background-color: #fff; box-shadow: 10px 10px 5px rgba(100, 100, 100, .5); } header nav ul li { display: flex; justify-content: center; color: #fff; margin: 5px 0; } header nav ul li:hover { text-decoration: underline; } main { width: 70%; height: 100%; background-color: deepskyblue; display: flex; justify-content: center; align-items: center; color: #fff; font-size: 50px; } .hidden { display: none; } HTML学习 HTML基础 HTML进阶 HTML高级 CSS学习 CSS基础 CSS进阶 CSS高级 JavaScript学习 JavaScript基础 JavaScript进阶 JavaScript高级 \"use strict\"; let h1NodeList = document.querySelectorAll(\"h1\"); let ulList = document.querySelectorAll(\"ul\"); let mainNode = document.querySelector(\"main\"); let wMap = new Map(); h1NodeList.forEach((ele, index, array) => { // 将h1和下面的ul标签做联系 wMap.set(ele, ele.nextElementSibling); ele.addEventListener(\"click\", (event) => { for (let [h1, ul] of wMap) { if (h1 === event.target) { ul.classList.remove(\"hidden\"); } else { ul.classList.add(\"hidden\"); } } }) }) ulList.forEach((ele, index, array) => { // 事件代理 ele.addEventListener(\"click\", (event) => { if (event.target.tagName === \"LI\") { mainNode.innerText = `您选择了 : ${event.target.innerText}`; } }); }) 滚动轮播图 滚动轮播图是最常见的由JavaScript实现的效果，这里我们将其做成一个插件的形式，方便日后使用。 实现如下： Document \"use strict\"; class Carousel { constructor(imageAndPathArray, parentElement, seconds = 1500) { if (!imageAndPathArray) { throw new Error(\"param error : imageAndPathArray\"); } if (imageAndPathArray.length > 12) { throw new Error(\"number error : Too many pictures\") } this.imageAndPathArray = imageAndPathArray; this.parentElement = parentElement ? document.querySelector(parentElement) : document.body; this.width = this.parentElement.clientWidth; this.height = this.parentElement.clientHight; this.seconds = seconds; this.frame = null; this.scrollDiagramUl = null; this.scrollBarUl = null; this.prev = null; this.next = null; // 导航图与导航按钮的关系容器 this.elementArray = new Array(); // 当前显示的元素 this.showElementIndex = 0; // 计时器 this.tag = null; // 生成样式 this.initStyle(); // 生成标签 this.initElements(); // 开始滚动 this.autoScroll(); // 按钮事件绑定 this.btnBindEvent(); } initElements() { // 整体标签，采用nav进行包裹 this.frame = document.createElement(\"nav\"); this.frame.id = \"container\"; // 添加轮播图时要放在同步任务后添加，这样可以避免渲染不及时出现错了 setTimeout(() => { this.parentElement.append(this.frame); }, 300) // 添加image滚动图ul this.scrollDiagramUl = document.createElement(\"ul\"); this.scrollDiagramUl.id = \"scroll_diagram\"; this.frame.append(this.scrollDiagramUl); // 添加下方滚动条ul this.scrollBarUl = document.createElement(\"ul\"); this.scrollBarUl.id = \"scroll_bar\"; this.scrollBarUl.className = \"clearfix\"; this.frame.append(this.scrollBarUl); // 添加上一页，下一页 this.prev = document.createElement(\"aside\"); this.next = document.createElement(\"aside\"); this.prev.innerHTML = \"\"; this.next.innerHTML = \"\"; this.prev.id = \"prev_diagram\"; this.next.id = \"next_diagram\"; this.frame.append(this.prev); this.frame.append(this.next); this.imageAndPathArray.forEach((obj, index, array) => { let { imagePath, targetURL } = obj; // 生成滚动图相关 let imageLi = document.createElement(\"li\"); let imageLink = document.createElement(\"a\"); let imageNode = document.createElement(\"img\"); imageLink.href = obj.targetURL || \"#\"; imageLink.target = imageLink.href.match(\"#\") ? \"_self\" : \"_blank\"; imageNode.src = obj.imagePath; imageLink.append(imageNode); imageLi.append(imageLink); this.scrollDiagramUl.append(imageLi); // 生成滚动条li let barLi = document.createElement(\"li\"); this.scrollBarUl.append(barLi); // 绑定关系 this.elementArray.push({ imageLi, barLi }) }); } initStyle() { let linkNode = document.createElement(\"link\"); linkNode.rel = \"stylesheet\"; linkNode.href = \"//at.alicdn.com/t/font_1953712_kcy11tbqhi.css\"; document.head.append(linkNode); let styleNode = document.createElement(\"style\"); document.head.append(styleNode); styleNode.append(` nav#container, nav#container * { box-sizing: border-box; padding: 0; margin: 0; } nav#container { position: relative; } nav#container ul#scroll_diagram { list-style: none; cursor: pointer; overflow:hidden; } nav#container ul#scroll_diagram li { display:none; } nav#container ul#scroll_diagram li a { display: inline-block; } nav#container ul#scroll_diagram li a img { width: 100%; } nav#container ul#scroll_bar { list-style: none; cursor: pointer; } nav#container ul#scroll_bar { position: absolute; left: 50%; top: 90%; transform: translate(-50%, -50%); z-index: 1; } nav#container ul#scroll_bar li { float: left; margin-right: ${this.width * 0.02}px; background-color: #eee; width: ${this.width * 0.04}px; height: ${this.width * 0.01}px; border-radius: 40px; transition: ${this.seconds * 0.3}ms; } nav#container aside#prev_diagram, nav#container aside#next_diagram { display: inline-block; position: absolute; top: 50%; z-index: 1; align-items: center; } nav#container aside#prev_diagram { left: 0; transform: translate(0, -50%); } nav#container aside#next_diagram { right: 0; transform: translate(0, -50%); } nav#container aside#prev_diagram i, nav#container aside#next_diagram i { background: #eee; opacity:.3; font-size: ${this.width * 0.04}px !important; text-align: center; cursor: pointer; } nav#container aside#prev_diagram i { border-top-right-radius: .6rem; border-bottom-right-radius: .6rem; } nav#container aside#next_diagram i { border-top-left-radius: .6rem; border-bottom-left-radius: .6rem; } nav#container aside#prev_diagram i:hover, nav#container aside#next_diagram i:hover { opacity:.6; } .clearfix::after { content: \"\"; display: block; clear: both; } .current_show_image_li { display: block !important; } .current_show_bar_li { background-color: #FF0000 !important; } `) } autoScroll() { // 先展示首页 if (this.tag === null) { this.show(this.elementArray[this.showElementIndex]); } this.tag = setInterval(() => { this.hidden(this.elementArray[this.showElementIndex]); this.showElementIndex { if (event.target.tagName === 'LI') { this.hidden(this.elementArray[this.showElementIndex]); this.showElementIndex = Array.prototype.indexOf.call(this.scrollBarUl.childNodes, event.target); this.clearScroll(); } }); this.prev.addEventListener(\"click\", (event) => { this.hidden(this.elementArray[this.showElementIndex]); this.showElementIndex = this.showElementIndex !== 0 ? this.showElementIndex - 1 : this.elementArray.length - 1; this.clearScroll(); }) this.next.addEventListener(\"click\", (event) => { this.hidden(this.elementArray[this.showElementIndex]); this.showElementIndex = this.showElementIndex !== this.elementArray.length - 1 ? this.showElementIndex + 1 : 0; this.clearScroll(); }) } clearScroll() { clearInterval(this.tag); this.tag = null; this.autoScroll(); } } let imageAndPathArray = [ { id: 1, \"imagePath\": \"./1.jpeg\", targetURL: \"http://www.baidu.com\" }, { id: 2, \"imagePath\": \"./2.jpeg\", targetURL: \"http://www.biying.com\" }, { id: 3, \"imagePath\": \"./3.jpeg\", targetURL: \"http://www.google.com\" }, ] // 在main下生成 new Carousel(imageAndPathArray, \"main\"); 头像预览 在注册时，我们应当让用户看见自己选择的头像。 那么实现这个需要借助JavaScript内置对象文件阅读器（FileReader），除此之外还需要准备一个默认头像。 最简单的实现过程： 创建一个img标签，默认头像放进去 创建一个input:file标签，并设置为隐藏 点击img标签时，将input:file设为选择状态，选择文件 上传头像后通过文件阅读器阅读出文件内容，并将它写在img标签中以替换默认头像 实现代码： Document img { width: 3rem; border-radius: 50%; border: 1px solid #ddd; } \"use strict\"; let imgNode = document.getElementById(\"upload-avatar\"); let inputFileNode = document.getElementById(\"avatar\"); imgNode.addEventListener(\"click\", event => { // 单击文件上传按钮 inputFileNode.click(); }) inputFileNode.addEventListener(\"change\", event => { if (inputFileNode.files.length > 0) { // 获取头像 let avatar = inputFileNode.files[0]; // 通过文件阅读器拿出头像 let fileReader = new FileReader(); // 异步操作，读取上传的图片 fileReader.readAsDataURL(avatar); // 当文件阅读器可读时，替换默认头像，它会将图像替换为base64位数据流格式 fileReader.addEventListener(\"load\", event => { imgNode.src = fileReader.result; }); } }) Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:48 "},"前端专栏/jQuery/summary.html":{"url":"前端专栏/jQuery/summary.html","title":"jQuery","keywords":"","body":" 基础介绍 选择器 筛选器 属性内容 文档操作 样式操作 事件操作 空间坐标 动画效果 插件扩展 网络请求 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:48 "},"前端专栏/jQuery/基础介绍.html":{"url":"前端专栏/jQuery/基础介绍.html","title":"基础介绍","keywords":"","body":"jQuery简介 jQuery是由美国大神John Resig基于JavaScript开发，旨在用更少的代码完成更多的事情。 jQuery是一个非常快速简洁的JavaScript第三方库，它能够让用户更加方便的选择DOM、处理事件、实现动画效果与前后端交互 jQuery十分的轻量级，这是其他的JavaScript框架所不及的，除此之外它还兼容CSS3，相较于原生的JavaScript来说对各种版本的浏览器都具有更好的兼容性 jQuery的官方文档特别齐全，各种应用说明十分详细，同时还具有很多成熟的插件可供选择 官方网站 官方文档 其实自从ES6版本发布以来，原生的JavaScript和jQuery的开发效率已经差不了多少了，随之而来的是jQuery的使用变的越来越少，甚至互联网上一度有人认为jQuery是一项过时的技术，这也是一个不争的实时，现在的主流框架都是Vue和React，但jQuery依然有它的用武之地，特别是维护或者翻新一些老旧项目时，如果你不了解jQuery，你可能会看的一头雾水。 总而言之，jQuery学习周期短，学习成本低，后期回报也不错，还是非常建议前端开发人员去研究的。 jQuery版本 jQuery主要分为1、2、3版本，先已更新到jQuery3.6。 1.x：兼容IE678，使用最为广泛的，官方只做BUG维护，功能不再新增。因此一般项目来说，使用1.x版本就可以了，最终版本：1.12.4 (2016年5月20日) 2.x：不兼容IE678，很少有人使用，官方只做BUG维护，功能不再新增。如果不考虑兼容低版本的浏览器可以使用2.x，最终版本：2.2.4 (2016年5月20日) 3.x：不兼容IE678，只支持最新的浏览器。需要注意的是很多老的jQuery插件不支持3.x版。目前该版本是官方主要更新维护的版本 在学习时推荐使用3.x版本，因为一些老旧的浏览器使用的人也越来越少了，如果有特殊的需求那么还是建议使用1.x版本进行开发。 jQuery引入 离线文件 jQuery离线版本可在官网中自行下载，在学习时推荐使用未压缩版本，正式的生产环境中则应该使用压缩版本。 下载完成后直接通过标签进行引入即可。 点我进入下载页： 在线引入 使用bootCDN提供的在线jQuery引入，能够省去下载步骤。 点我进入下载页： vscode代码片段 为了方便后期更加快速的导入jQuery，我们可以用vscode为其做一个代码片段。 \"jQueryImport\": { \"prefix\": \"$\", \"body\": [ \"\" ], \"description\": \"快速引入jQuery\" }, 当你在HTML文件中输入$的时候，将会自动提示是否快速输入body中的内容。 jQuery对象 基本介绍 如何使用jQuery呢？实际上我们只需要导入jQuery库，然后再使用$或者jQuery选择出想要的DOM节点即可。 $是jQuery的别名，直接使用$就相当于使用了jQuery对象 通过jQuery选择出的DOM节点，在命名时应当加上$的前缀 如下示例： Document HELLO WORLD \"use strict\"; let $div = $(\"div\"); // 也可通过jQuery(\"div\")达到相同的效果 console.log($div.text()); // HELLO WORLD 元素集合 使用jQuery提供的选择器选择出的DOM节点会被包装为jQuery对象，它是一个类似于NodeList的容器类型。 哪怕jQuery选择器只选择出了一个元素节点，它也会返回一个jQuery对象元素集合体。 你可以将它当做是始终使用了document.querySelectorAll()来选择的元素，无论怎样都不会返回一个具体的元素节点，只会返回NodeList元素集合。 此外，jQuery对象下所提供的方法和DOM节点所提供的方法并不互通，所以在变量命名时，一定要使用$来标识这到底是通过jQuery选择器选择出的结果还是原生JavaScript选择器选择出的结果。 如下所示，我们通过jQuery选择器选择到了2个，打印它们的innerText，在jQuery中，打印innerText需要使用text()方法： Document im a first div im a last div \"use strict\"; let $div = $(\"div\"); console.log($div.text()); // im a first divim a last div 注意它的打印结果，也就是说对jQuery对象使用任何方法其结果都会作用到jQuery对象内部所有的DOM元素节点身上。 它相当于下面这段由原生JavaScript所编写的代码： Document im a first div im a last div \"use strict\"; let divNodeList = document.querySelectorAll(\"div\"); let result = Array.prototype.reduce.call(divNodeList, (pre, cur, index, array) => { return pre + cur.innerText; }, \"\"); console.log(result); // im a first divim a last div 节点提取 如果你想从jQuery对象中提取某个DOM节点，可通过[]或者get()方法来进行提取，jQuery对象是具有length属性的，所以可以通过索引来对其进行操作。 Document im a first div im a last div \"use strict\"; let $div = $(\"div\"); let divNode = $div.get(0); console.log(divNode.innerText); // im a first div 它相当于对NodeList对象使用[]或者item()进行提取DOM节点一样。 Document im a first div im a last div \"use strict\"; let divNodeList = document.querySelectorAll(\"div\"); let divNode = divNodeList.item(0); console.log(divNode.innerText); // im a first div 布尔判定 jQuery对象属于引用对象，它是一个容器类型，所以在if判断时不管内部是否有内容都会返回true。 当你想要判断jQuery是否成功选择了某个元素节点时，如果单纯的用!!jQuery来进行判断，得到的结果总是true。 正确的判定方式应该是判断它的长度，!!jQuery.length才对。 如下所示： Document \"use strict\"; let $span = $(\"span\"); console.log(!!$span); console.log(!!$span.length); // true // false Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:48 "},"前端专栏/jQuery/选择器.html":{"url":"前端专栏/jQuery/选择器.html","title":"选择器","keywords":"","body":"基本选择器 * 通用选择器 使用*可以匹配所有元素。 它将返回一个jQuery对象，即包含所有被选中元素的集合容器。 body { padding: 1rem; } header main footer \"use strict\"; let $elements = $(\"*\"); $elements.css(\"color\", \"#aaa\"); console.log($elements); // jQuery.fn.init(10) [html, head, style, body, header, main, footer, script, script, script, prevObject: jQuery.fn.init(1)] E 名字选择器 根据tagName来匹配多个元素。 它将返回一个jQuery对象，即包含所有被选中元素的集合容器。 body { padding: 1rem; } header 1 2 3 footer \"use strict\"; let $elements = $(\"li\"); $elements.css(\"color\", \"#aaa\"); console.log($elements); // jQuery.fn.init(3) [li, li, li, prevObject: jQuery.fn.init(1)] # ID选择器 使用#可根据id属性来匹配一个元素。 它将返回一个jQuery对象，即包含所有被选中元素的集合容器。 body { padding: 1rem; } header 1 2 3 footer \"use strict\"; let $elements = $(\"#top\"); $elements.css(\"color\", \"#aaa\"); console.log($elements); // jQuery.fn.init [header#top] . 类选择器 使用.可根据class属性来匹配多个元素。 它将返回一个jQuery对象，即包含所有被选中元素的集合容器。 body { padding: 1rem; } header 1 2 3 A B C footer \"use strict\"; let $elements = $(\".odd_li\"); $elements.css(\"color\", \"#aaa\"); console.log($elements); // jQuery.fn.init(4) [li.odd_li, li.odd_li, li.odd_li, li.odd_li, prevObject: jQuery.fn.init(1)] 组合选择器 Feature 交集选择器 根据元素不同的特征进行高精度的匹配出一个或多个元素。 它将返回一个jQuery对象，即包含所有被选中元素的集合容器。 如下示例，仅返回第一个下的class为odd-li的标签： body { padding: 1rem; } header 1 2 3 A B C footer \"use strict\"; let $elements = $(\"ul:first-of-type() .odd_li\"); $elements.css(\"color\", \"#aaa\"); console.log($elements); // jQuery.fn.init(2) [li.odd_li, li.odd_li, prevObject: jQuery.fn.init(1)] E, F 并集选择器 使用逗号进行分割可一次性匹配多个元素。 它将返回一个jQuery对象，即包含所有被选中元素的集合容器。 如下示例，同时匹配标签和标签： body { padding: 1rem; } header 1 2 3 A B C footer \"use strict\"; let $elements = $(\"header, footer\"); $elements.css(\"color\", \"#aaa\"); console.log($elements); // jQuery.fn.init(2) [header, footer, prevObject: jQuery.fn.init(1)] E F 后代选择器 使用空格进行分隔可匹配某个元素所有后代的元素。 它将返回一个jQuery对象，即包含所有被选中元素的集合容器。 如下所示，返回标签的所有后代： body { padding: 1rem; } header 1 2 3 A B C footer \"use strict\"; let $elements = $(\"body *\"); $elements.css(\"color\", \"#aaa\"); console.log($elements); // jQuery.fn.init(14) [header, main, ul, li.odd_li, li, li.odd_li, ul, li.odd_li, li, li.odd_li, footer, script, script, script, prevObject: jQuery.fn.init(1)] E > F 子代选择器 使用>进行分割可匹配某个元素直系后代的元素。 它将返回一个jQuery对象，即包含所有被选中元素的集合容器。 如下所示，返回标签的直系后代： body { padding: 1rem; } header 1 2 3 A B C footer \"use strict\"; let $elements = $(\"body>*\"); $elements.css(\"color\", \"#aaa\"); console.log($elements); // jQuery.fn.init(6) [header, main, footer, script, script, script, prevObject: jQuery.fn.init(1)] E + F 同级毗邻选择器 使用+进行分割可匹配某个元素紧随其后的一个元素。 它将返回一个jQuery对象，即包含所有被选中元素的集合容器。 如下所示，返回标签的后一个标签： body { padding: 1rem; } header 1 2 3 A B C footer \"use strict\"; let $elements = $(\"header+*\"); $elements.css(\"color\", \"#aaa\"); console.log($elements); // jQuery.fn.init [main, prevObject: jQuery.fn.init(1)] E ~ F 同级多跨选择器 使用~进行分割可匹配某个元素紧随其后的所有元素。 它将返回一个jQuery对象，即包含所有被选中元素的集合容器。 如下所示，返回标签的后面所有标签： body { padding: 1rem; } header 1 2 3 A B C footer \"use strict\"; let $elements = $(\"header~*\"); $elements.css(\"color\", \"#aaa\"); console.log($elements); // jQuery.fn.init(5) [main, footer, script, script, script, prevObject: jQuery.fn.init(1)] 属性选择器 [attribute] 用于选取带有指定属性的元素。 它将返回一个jQuery对象，即包含所有被选中元素的集合容器: body { padding: 1rem; } header 1 2 3 A B C footer \"use strict\"; let $elements = $(\"[data-id]\"); $elements.css(\"color\", \"#aaa\"); console.log($elements); // jQuery.fn.init(6) [li, li, li, li, li, li, prevObject: jQuery.fn.init(1)] [attribute=value] 用于选取带有指定属性和值的元素。 它将返回一个jQuery对象，即包含所有被选中元素的集合容器:: body { padding: 1rem; } header 1 2 3 A B C footer \"use strict\"; let $elements = $(\"[data-id=li-1]\"); $elements.css(\"color\", \"#aaa\"); console.log($elements); // jQuery.fn.init [li, prevObject: jQuery.fn.init(1)] [attribute!=value] 用于选取不带有指定属性和值的元素，必须配合交集选择器使用。 它将返回一个jQuery对象，即包含所有被选中元素的集合容器:: body { padding: 1rem; } header 1 2 3 A B C footer \"use strict\"; let $elements = $(\"li[data-id!=li-1]\"); $elements.css(\"color\", \"#aaa\"); console.log($elements); // jQuery.fn.init(5) [li, li, li, li, li, prevObject: jQuery.fn.init(1)] [attribute^=value] 匹配属性值以指定值开头的每个元素。 它将返回一个jQuery对象，即包含所有被选中元素的集合容器:: body { padding: 1rem; } header 1 2 3 A B C footer \"use strict\"; let $elements = $(\"[data-id^=li]\"); $elements.css(\"color\", \"#aaa\"); console.log($elements); // jQuery.fn.init(6) [li, li, li, li, li, li, prevObject: jQuery.fn.init(1)] [attribute$=value] 匹配属性值以指定值结尾的每个元素。 它将返回一个jQuery对象，即包含所有被选中元素的集合容器: body { padding: 1rem; } header 1 2 3 A B C footer \"use strict\"; let $elements = $(\"[data-id$=C], [data-id$=3]\"); $elements.css(\"color\", \"#aaa\"); console.log($elements); // jQuery.fn.init(2) [li, li, prevObject: jQuery.fn.init(1)] [attribute*=value] 匹配属性值中包含指定值的每个元素。 它将返回一个jQuery对象，即包含所有被选中元素的集合容器: body { padding: 1rem; } header 1 2 3 A B C footer \"use strict\"; let $elements = $(\"[data-id*=B]\"); $elements.css(\"color\", \"#aaa\"); console.log($elements); // jQuery.fn.init [li, prevObject: jQuery.fn.init(1)] 结构伪类选择器 :root 匹配文档根元素，即标签。 它将返回一个jQuery对象，其中包含所有被选中的元素节点： body { padding: 1rem; } header 1 2 3 A B C footer \"use strict\"; let $elements = $(\":root\"); $elements.css(\"color\", \"#aaa\"); console.log($elements); // jQuery.fn.init [html, prevObject: jQuery.fn.init(1)] :header 匹配h~系列的标题元素。 它将返回一个jQuery对象，其中包含所有被选中的元素节点： body { padding: 1rem; } h1 element h2 element h3 element header 1 2 3 A B C footer \"use strict\"; let $elements = $(\":header\"); $elements.css(\"color\", \"#aaa\"); console.log($elements); // jQuery.fn.init(3) [h1, h2, h3, prevObject: jQuery.fn.init(1)] :parent 匹配含有后代的父元素，不论该后代是元素节点还是其他节点。 它将返回一个jQuery对象，其中包含所有被选中的元素节点： body { padding: 1rem; } header 1 2 3 A B C footer \"use strict\"; let $elements = $(\"header:parent\"); $elements.css(\"color\", \"#aaa\"); console.log($elements); // jQuery.fn.init [header, prevObject: jQuery.fn.init(1)] :empty 匹配不含有子元素或文本的元素。 它将返回一个jQuery对象，其中包含所有被选中的元素节点： body { padding: 1rem; } header 1 2 3 A B C footer \"use strict\"; let $elements = $(\":empty\"); $elements.css(\"color\", \"#aaa\"); console.log($elements); // jQuery.fn.init(2) [aside, script, prevObject: jQuery.fn.init(1)] :first 匹配第一个元素，只选一个。 它将返回一个jQuery对象，其中包含所有被选中的元素节点： body { padding: 1rem; } header 1 2 3 A B C footer \"use strict\"; let $elements = $(\"ul li:first\"); $elements.css(\"color\", \"#aaa\"); console.log($elements); // jQuery.fn.init [li, prevObject: jQuery.fn.init(1)] :last 匹配最后一个元素，只选一个。 它将返回一个jQuery对象，其中包含所有被选中的元素节点： body { padding: 1rem; } header 1 2 3 A B C footer \"use strict\"; let $elements = $(\"ul li:last\"); $elements.css(\"color\", \"#aaa\"); console.log($elements); // jQuery.fn.init [li, prevObject: jQuery.fn.init(1)] :first-of-type 按照类型匹配第一个元素，可选多个。 它将返回一个jQuery对象，其中包含所有被选中的元素节点： body { padding: 1rem; } header 1 2 3 A B C footer \"use strict\"; let $elements = $(\"ul li:first-of-type\"); $elements.css(\"color\", \"#aaa\"); console.log($elements); // jQuery.fn.init(2) [li, li, prevObject: jQuery.fn.init(1)] :last-of-type 按照类型匹配第一个元素，可选多个。 它将返回一个jQuery对象，其中包含所有被选中的元素节点： body { padding: 1rem; } header 1 2 3 A B C footer \"use strict\"; let $elements = $(\"ul li:last-of-type\"); $elements.css(\"color\", \"#aaa\"); console.log($elements); // jQuery.fn.init(2) [li, li, prevObject: jQuery.fn.init(1)] :first-child 匹配第一个子元素，可选多个。 它将返回一个jQuery对象，其中包含所有被选中的元素节点： body { padding: 1rem; } header 1 2 3 A B C footer \"use strict\"; let $elements = $(\"ul li:first-child\"); $elements.css(\"color\", \"#aaa\"); console.log($elements); // jQuery.fn.init(2) [li, li, prevObject: jQuery.fn.init(1)] :last-child 匹配最后一个子元素，可选多个。 它将返回一个jQuery对象，其中包含所有被选中的元素节点： body { padding: 1rem; } header 1 2 3 A B C footer \"use strict\"; let $elements = $(\"ul li:last-child\"); $elements.css(\"color\", \"#aaa\"); console.log($elements); // jQuery.fn.init(2) [li, li, prevObject: jQuery.fn.init(1)] :nth-child(n) 按照位置正序匹配父元素下第N个子元素： 参数N可以是从1开始的数字 可以是公式，如（2n+1） 可以是odd，它将匹配所有奇数项（从1开始计数） 可以是even，它将匹配所有的偶数项（从1开始计数） 它将返回一个jQuery对象，其中包含所有被选中的元素节点： body { padding: 1rem; } header 1 2 3 A B C footer \"use strict\"; let $elements = $(\"ul:nth-child(1) li:nth-child(odd)\"); $elements.css(\"color\", \"#aaa\"); console.log($elements); // jQuery.fn.init(2) [li, li, prevObject: jQuery.fn.init(1)] :nth-last-child(n) 按照位置倒序匹配父元素下第N个子元素： 参数N可以是从1开始的数字 可以是公式，如（2n+1） 可以是odd，它将匹配所有奇数项（从1开始计数） 可以是even，它将匹配所有的偶数项（从1开始计数） 它将返回一个jQuery对象，其中包含所有被选中的元素节点： body { padding: 1rem; } header 1 2 3 A B C footer \"use strict\"; let $elements = $(\"ul:nth-last-child(1) li:nth-last-child(odd)\"); $elements.css(\"color\", \"#aaa\"); console.log($elements); // jQuery.fn.init(2) [li, li, prevObject: jQuery.fn.init(1)] :nth-of-type(n) 按照类型正序匹配父元素下第N个子元素 参数N可以是从1开始的数字 可以是公式，如（2n+1） 可以是odd，它将匹配所有奇数项（从1开始计数） 可以是even，它将匹配所有的偶数项（从1开始计数） 它将返回一个jQuery对象，其中包含所有被选中的元素节点： body { padding: 1rem; } header 1 2 3 A B C footer \"use strict\"; let $elements = $(\"ul li:nth-of-type(odd)\"); $elements.css(\"color\", \"#aaa\"); console.log($elements); // jQuery.fn.init(4) [li, li, li, li, prevObject: jQuery.fn.init(1)] :nth-last-of-type(n) 按照类型倒序匹配父元素下第N个子元素 参数N可以是从1开始的数字 可以是公式，如（2n+1） 可以是odd，它将匹配所有奇数项（从1开始计数） 可以是even，它将匹配所有的偶数项（从1开始计数） 它将返回一个jQuery对象，其中包含所有被选中的元素节点： body { padding: 1rem; } header 1 2 3 A B C footer \"use strict\"; let $elements = $(\"ul li:nth-last-of-type(odd)\"); $elements.css(\"color\", \"#aaa\"); console.log($elements); // jQuery.fn.init(4) [li, li, li, li, prevObject: jQuery.fn.init(1)] :only-child 匹配出一个没有任何兄弟姐妹的子元素，即独生子元素。 它将返回一个jQuery对象，其中包含所有被选中的元素节点： body { padding: 1rem; } hello jQuery 1 2 3 A B C footer \"use strict\"; let $elements = $(\"h1:only-child\"); $elements.css(\"color\", \"#aaa\"); console.log($elements); // jQuery.fn.init [h1, prevObject: jQuery.fn.init(1)] :only-of-type 匹配出一个没有同类型兄弟姐妹的子元素。 它将返回一个jQuery对象，其中包含所有被选中的元素节点： body { padding: 1rem; } h1 h2 h2 1 2 3 A B C footer \"use strict\"; let $elements = $(\"header nav h1:only-of-type, header nav h2:only-of-type\"); $elements.css(\"color\", \"#aaa\"); console.log($elements); // jQuery.fn.init [h1, prevObject: jQuery.fn.init(1)] 索引伪类选择器 :odd 匹配所有索引值为奇数的元素，从0开始计数。 它将返回一个jQuery对象，其中包含所有被选中的元素节点： body { padding: 1rem; } header 1 2 3 A B C footer \"use strict\"; let $elements = $(\"ul li:odd\"); $elements.css(\"color\", \"#aaa\"); console.log($elements); // jQuery.fn.init(3) [li, li, li, prevObject: jQuery.fn.init(1)] :even 匹配所有索引值为偶数的元素，从0开始计数。 它将返回一个jQuery对象，其中包含所有被选中的元素节点： body { padding: 1rem; } header 1 2 3 A B C footer \"use strict\"; let $elements = $(\"ul li:even\"); $elements.css(\"color\", \"#aaa\"); console.log($elements); // jQuery.fn.init(3) [li, li, li, prevObject: jQuery.fn.init(1)] :eq(index) 匹配出等于索引值的元素。 它将返回一个jQuery对象，其中包含所有被选中的元素节点： body { padding: 1rem; } header 1 2 3 A B C footer \"use strict\"; let $elements = $(\"ul li:eq(2)\"); $elements.css(\"color\", \"#aaa\"); console.log($elements); // jQuery.fn.init [li, prevObject: jQuery.fn.init(1)] :gt(index) 匹配出大于索引值的元素。 它将返回一个jQuery对象，其中包含所有被选中的元素节点： body { padding: 1rem; } header 1 2 3 A B C footer \"use strict\"; let $elements = $(\"ul li:gt(2)\"); $elements.css(\"color\", \"#aaa\"); console.log($elements); // jQuery.fn.init(3) [li, li, li, prevObject: jQuery.fn.init(1)] :lt(index) 匹配出小于索引值的元素。 它将返回一个jQuery对象，其中包含所有被选中的元素节点： body { padding: 1rem; } header 1 2 3 A B C footer \"use strict\"; let $elements = $(\"ul li:lt(2)\"); $elements.css(\"color\", \"#aaa\"); console.log($elements); // jQuery.fn.init(2) [li, li, prevObject: jQuery.fn.init(1)] 表单元素选择器 测试代码 接下来的表单伪类选择器将在此代码上进行试验： CSS代码： * { padding: 0; margin: 0; box-sizing: border-box; } body { display: flex; width: 100vw; height: 100vh; justify-content: center; align-items: center; } form { min-width: 30%; border: 1px solid #ddd; padding: 1rem; } form div { margin-top: 0.5rem; } form div:nth-child(1) { display: flex; justify-content: center; align-items: center; } form div:nth-child(1) input[type=file] { display: none; } form div:nth-child(1) input[type=image] { border: 1px solid #ddd; border-radius: 50%; } form div:nth-child(2), form div:nth-child(3), form div:nth-child(4) { display: flex; justify-content: space-between; align-items: center; } form div:nth-child(2) input, form div:nth-child(3) input, form div:nth-child(4) input { flex-basis: 65%; } form div:nth-child(2) label, form div:nth-child(3) label, form div:nth-child(4) label { flex-basis: 35%; } form div:nth-child(5) :nth-child(even), form div:nth-child(6) :nth-child(even) { margin-right: 1rem; } form div:nth-child(7) select { margin-left: 1rem; width: 25%; } form div:nth-child(8) textarea { width: 100%; height: 12rem; resize: none; } HTML代码： username: password: confirm password: male: female: basketball football volleyball city BeiJing ShangHai TianJin ChongQing submit reset JavaScript代码： \"use strict\"; let $form = $(\"form\"); let $elements = $(\"要测试的选择器\"); $(\"input:image\").on(\"click\", jQEvent => { jQEvent.preventDefault(); $(\"input:file\").click(); }); $(\"input:file\").on(\"change\", jQEvent => { let $inputFileNode = $(\"input:file\"); let $inputImageNode = $(\"input:image\"); if ($inputFileNode.prop(\"files\").length > 0) { // 获取头像 let avatar = $inputFileNode.prop(\"files\")[0]; // 通过文件阅读器拿出头像 let fileReader = new FileReader(); // 异步操作，读取上传的图片 fileReader.readAsDataURL(avatar); // 当文件阅读器可读时，替换默认头像，它会将图像替换为base64位数据流格式 $(fileReader).on(\"load\", jQevent => { $inputImageNode.prop(\"src\", fileReader.result); }); } }); $(\"button:submit\").on(\"click\", jQEvent => { jQEvent.preventDefault(); SelectorTest(); }); $(\"button:reset\").on(\"click\", jQEvent => { $elements.css(\"outline\", \"none\"); }) function SelectorTest() { $elements.css(\"outline\", \"1px solid #ff0000\"); console.log($elements); } 当定义好选择器后，点击submit按钮将会以最直观的方式看见被匹配的元素项，如匹配默认选中的checked的元素： :input 匹配所有的、、、元素。 它将返回一个jQuery对象，其中包含所有被选中的元素节点： let $elements = $(\":input\"); // ... function SelectorTest() { $elements.css(\"outline\", \"1px solid #ff0000\"); console.log($elements); } // jQuery.fn.init(14) [input, input#avatar, input#username, input#password, input#re_password, input#male, input#female, input#baketball, input#football, input#volleyball, select#city, textarea, button, button, prevObject: jQuery.fn.init(1)] :text 匹配所有的单行文本框。 它将返回一个jQuery对象，其中包含所有被选中的元素节点： let $elements = $(\":text\"); // ... function SelectorTest() { $elements.css(\"outline\", \"1px solid #ff0000\"); console.log($elements); } // jQuery.fn.init [input#username, prevObject: jQuery.fn.init(1)] :password 匹配所有的密码框。 它将返回一个jQuery对象，其中包含所有被选中的元素节点： let $elements = $(\":password\"); // ... function SelectorTest() { $elements.css(\"outline\", \"1px solid #ff0000\"); console.log($elements); } // jQuery.fn.init(2) [input#password, input#re_password, prevObject: jQuery.fn.init(1)] :radio 匹配所有的单选框。 它将返回一个jQuery对象，其中包含所有被选中的元素节点： let $elements = $(\":radio\"); // ... function SelectorTest() { $elements.css(\"outline\", \"1px solid #ff0000\"); console.log($elements); } // jQuery.fn.init(2) [input#male, input#female, prevObject: jQuery.fn.init(1)] :checkbox 匹配所有的复选框。 它将返回一个jQuery对象，其中包含所有被选中的元素节点： let $elements = $(\":checkbox\"); // ... function SelectorTest() { $elements.css(\"outline\", \"1px solid #ff0000\"); console.log($elements); } // jQuery.fn.init(3) [input#baketball, input#football, input#volleyball, prevObject: jQuery.fn.init(1)] :submit 匹配所有的提交按钮，包括、。 而大多数浏览器中，默认的type就是submit，故也会匹配到。 它将返回一个jQuery对象，其中包含所有被选中的元素节点： let $elements = $(\":submit\"); // ... function SelectorTest() { $elements.css(\"outline\", \"1px solid #ff0000\"); console.log($elements); } // jQuery.fn.init [button, prevObject: jQuery.fn.init(1)] :reset 匹配所有的重置按钮，包括、。 它将返回一个jQuery对象，其中包含所有被选中的元素节点： let $elements = $(\":reset\"); // ... function SelectorTest() { $elements.css(\"outline\", \"1px solid #ff0000\"); console.log($elements); } // jQuery.fn.init [button, prevObject: jQuery.fn.init(1)] :button 匹配所有的按钮。 它将返回一个jQuery对象，其中包含所有被选中的元素节点： let $elements = $(\":button\"); // ... function SelectorTest() { $elements.css(\"outline\", \"1px solid #ff0000\"); console.log($elements); } // jQuery.fn.init(2) [button, button, prevObject: jQuery.fn.init(1)] :image 匹配所有的图像域。 它将返回一个jQuery对象，其中包含所有被选中的元素节点： let $elements = $(\":image\"); // ... function SelectorTest() { $elements.css(\"outline\", \"1px solid #ff0000\"); console.log($elements); } // jQuery.fn.init [input, prevObject: jQuery.fn.init(1)] :file 匹配所有的文件域。 它将返回一个jQuery对象，其中包含所有被选中的元素节点。 示例中的文件域是隐藏的，故看不见效果。 let $elements = $(\":file\"); // ... function SelectorTest() { $elements.css(\"outline\", \"1px solid #ff0000\"); console.log($elements); } // jQuery.fn.init [input#avatar, prevObject: jQuery.fn.init(1)] 表单状态选择器 :enabled 匹配所有默认可用的元素。 它将返回一个jQuery对象，其中包含所有被选中的元素节点： let $elements = $(\":enabled\"); // ... function SelectorTest() { $elements.css(\"outline\", \"1px solid #ff0000\"); console.log($elements); } // jQuery.fn.init(18) [input, input#avatar, input#username, input#password, input#re_password, input#male, input#female, input#baketball, input#football, input#volleyball, select#city, option, option, option, option, textarea, button, button, prevObject: jQuery.fn.init(1)] :disabled 匹配所有默认被禁用的元素。 它将返回一个jQuery对象，其中包含所有被选中的元素节点。 由于示例中没有默认被禁用的元素，故看不见效果。 let $elements = $(\":disabled\"); // ... function SelectorTest() { $elements.css(\"outline\", \"1px solid #ff0000\"); console.log($elements); } // jQuery.fn.init [prevObject: jQuery.fn.init(1)] :checked 匹配所有默认被选中的元素，包括checkbox、radio、以及，如果只想要匹配，建议使用:selected。 它将返回一个jQuery对象，其中包含所有被选中的元素节点： let $elements = $(\":checked\"); // ... function SelectorTest() { $elements.css(\"outline\", \"1px solid #ff0000\"); console.log($elements); } // jQuery.fn.init(3) [input#male, input#baketball, option, prevObject: jQuery.fn.init(1)] :selected 匹配所有默认被选中的元素。 它将返回一个jQuery对象，其中包含所有被选中的元素节点。 由于元素被放置在元素中，故看不见效果。 let $elements = $(\":selected\"); // ... function SelectorTest() { $elements.css(\"outline\", \"1px solid #ff0000\"); console.log($elements); } // jQuery.fn.init [option, prevObject: jQuery.fn.init(1)] 其他伪类选择器 :lang 语言 匹配出指定语言的所有元素。 :lang选择器，匹配有一个语言值等于所提供的语言代码，或以提供的语言代码开始，后面马上跟一个“- ”的元素。 例如，选择器$(\"div:lang(en)\")将匹配 and （和他们的后代），但不包括 对于HTML元素，语言值由lang属性决定，也可能由来自meta元素或HTTP头信息决定。 由于使用的较少，故在此不再举例。 它将返回一个jQuery对象，其中包含所有被选中的元素节点。 :target 锚点 匹配由文档URI的格式化识别码表示的目标元素。 如果文档的URI包含一个格式化的标识符，或hash， 然后:target选择器将匹配id和标识符相匹配的元素。 例如，给定的URI https://example.com/#foo，$( \"p:target\" )，将匹配元素。 它将返回一个jQuery对象，其中包含所有被选中的元素节点： link target click me $(\"a\").on(\"click\", (jQEvent) => { $(\":target\").css(\"background-color\", \"#aaa\"); }); :has(selector) 包含元素 匹配含有特定子元素的父元素，它将返回一个jQuery对象，其中包含所有被选中的元素节点： body { padding: 1rem; } ??? div \"use strict\"; // div的子标签必须是div let $elements = $(\"div:has(div)\"); $elements.css(\"color\", \"#aaa\"); console.log($elements); // jQuery.fn.init [div, prevObject: jQuery.fn.init(1)] :contains(text) 包含文本 匹配含有特定文本内容的父元素，它将返回一个jQuery对象，其中包含所有被选中的元素节点： body { padding: 1rem; } ??? div \"use strict\"; // div的文本内容必须是div let $elements = $(\"div:contains(div)\"); $elements.css(\"color\", \"#aaa\"); console.log($elements); // jQuery.fn.init [div, prevObject: jQuery.fn.init(1)] :hidden 隐藏 匹配所有不可见元素，或者type为hidden的元素。 它将返回一个jQuery对象，其中包含所有被选中的元素节点： :visible 可见 匹配所有可见元素。 它将返回一个jQuery对象，其中包含所有被选中的元素节点。 :not(seletctor) 反向 匹配所有不被(selector)选择到的元素。 它将返回一个jQuery对象，其中包含所有被选中的元素节点。 :focus 焦点 匹配正在被获取焦点的元素。 它将返回一个jQuery对象，其中包含所有被选中的元素节点。 :animated 动画 匹配所有正在执行动画的元素 它将返回一个jQuery对象，其中包含所有被选中的元素节点。 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:48 "},"前端专栏/jQuery/筛选器.html":{"url":"前端专栏/jQuery/筛选器.html","title":"筛选器","keywords":"","body":"获取子对象 first() 获取jQuery对象中的第一个DOM元素。 它将被包装成一个新的jQuery对象并返回。 body { padding: 1rem; } A B C D E \"use strict\"; let $elements = $(\"main div ul li\").first(); $elements.css(\"color\", \"#aaa\"); console.log($elements); // jQuery.fn.init [li, prevObject: jQuery.fn.init(5)] last() 获取jQuery对象中的最后一个DOM元素。 它将被包装成一个新的jQuery对象并返回。 body { padding: 1rem; } A B C D E \"use strict\"; let $elements = $(\"main div ul li\").last(); $elements.css(\"color\", \"#aaa\"); console.log($elements); // jQuery.fn.init [li, prevObject: jQuery.fn.init(5)] eq(index) 根据索引位置获取jQuery对象中指定的一个DOM元素，从0开始计数。 它将被包装成一个新的jQuery对象并返回。 body { padding: 1rem; } A B C D E \"use strict\"; let $elements = $(\"main div ul li\").eq(2); $elements.css(\"color\", \"#aaa\"); console.log($elements); // jQuery.fn.init [li, prevObject: jQuery.fn.init(5)] odd() 根据索引位置获取jQuery对象中奇数项的所有DOM元素，从0开始计数。 它将被包装成一个新的jQuery对象并返回。 body { padding: 1rem; } A B C D E \"use strict\"; let $elements = $(\"main div ul li\").odd(); $elements.css(\"color\", \"#aaa\"); console.log($elements); // jQuery.fn.init(2) [li, li, prevObject: jQuery.fn.init(5)] even() 根据索引位置获取jQuery对象中偶数项的所有DOM元素，从0开始计数。 它将被包装成一个新的jQuery对象并返回。 body { padding: 1rem; } A B C D E \"use strict\"; let $elements = $(\"main div ul li\").even(); $elements.css(\"color\", \"#aaa\"); console.log($elements); // jQuery.fn.init(2) [li, li, prevObject: jQuery.fn.init(5)] slice() 根据索引对jQuery对象进行切片，顾头不顾尾。 它将被包装成一个新的jQuery对象并返回。 body { padding: 1rem; } A B C D E \"use strict\"; let $elements = $(\"main div ul li\").slice(1, 4); $elements.css(\"color\", \"#aaa\"); console.log($elements); // jQuery.fn.init(3) [li, li, li, prevObject: jQuery.fn.init(5)] 增加子对象 add() 添加一个DOM元素至jQuery对象中，这将返回一个新的jQuery对象。 也可以添加一个jQuery对象至另一个jQuery对象中，它内部会遍历所有的DOM元素并进行添加，这将返回一个新的jQuery对象。 body { padding: 1rem; } A B C D E \"use strict\"; let $jQ = $(); let $jQAddDiv = $jQ.add(document.createElement(\"div\")); let $jQAddJQ = $jQ.add($(\"main div ul li\")); console.log($jQAddDiv); console.log($jQAddJQ); // jQuery.fn.init [div, prevObject: j…y.fn.init] // jQuery.fn.init(5) [li, li, li, li, li, prevObject: j…y.fn.init] 删除子对象 not() 删除一个与指定表达式匹配的DOM元素，并且返回一个新的jQuery对象。 body { padding: 1rem; } A B C D E \"use strict\"; let $elements = $(\"main div ul li\"); let $new_elements = $elements.not($(\"main div ul li:nth-child(1)\")); console.log($new_elements); // jQuery.fn.init(4) [li, li, li, li, prevObject: jQuery.fn.init(5)] 对象检测 is() 检测一个元素，或者一个jQuery对象是否被另一个jQuery对象所包含，返回Boolean类型： body { padding: 1rem; } A B C D E \"use strict\"; let $elements = $(\"main div ul li\"); // 检测DOM元素是否被jQuery对象所包含 console.log( $elements.is(document.querySelector(\"main div ul li:nth-child(2)\")) ); // 检测jQuery对象是否被另一个jQuery对象所包含 console.log( $elements.is($(\"main div ul li\").slice(1, 3)) ); // true // true 对象遍历 each() each()用于递归的操作DOM元素，并根据操作修改原jQuery中的DOM元素。 使用该方法时需要绑定一个回调函数，该回调函数没有返回结果。 注意与map()方法的区别，该方法是对jQuery对象进行原地操作，不会生成新的jQuery对象。 回调函数共有3个参数： index：被遍历的DOM元素索引值 value：被遍历的DOM元素本身 array：被遍历的原jQuery对象本身 此外，在普通回调函数中可使用this，这代表当前被遍历的DOM元素，如果是箭头回调函数，则会指向undefined。 如下所示，为原jQuery对象中每个DOM元素添加上特征属性data-order： body { padding: 1rem; } A B C D E \"use strict\"; let $elements = $(\"main div ul li\"); $elements.each((index, element, array) => { element.setAttribute(\"data-order\", Math.floor(Math.random() * 5) + 1); }) console.log($elements); // jQuery.fn.init(5) [li, li, li, li, li, prevObject: jQuery.fn.init(1)] filter() filter()用于递归的检测DOM元素，所有检测结果为true的DOM元素添加至新的jQuery对象中，检测结果为false的DOM元素丢弃。 当检测完毕后会返回新的jQuery对象。 使用该方法时需要绑定一个回调函数，该回调函数必须返回true或者false。 回调函数共有3个参数： index：被遍历的DOM元素索引值 value：被遍历的DOM元素本身 array：被遍历的原jQuery对象本身 此外，在普通回调函数中可使用this，这代表当前被遍历的DOM元素，如果是箭头回调函数，则会指向undefined。 如下示例，我们需要检测innerText为A的DOM被返回。 body { padding: 1rem; } A B C D E \"use strict\"; let $elements = $(\"main div ul li\"); let $conditionTrue = $elements.filter((index, element, array) => { return element.innerText === \"A\"; }) console.log($conditionTrue); // jQuery.fn.init [li, prevObject: jQuery.fn.init(5)] map() map()用于递归的操作DOM元素，并将操作完成后的DOM元素添加进jQuery对象中。 当操作完毕后会返回新的jQuery对象。 使用该方法时需要绑定一个回调函数，该回调函数可有返回结果，也可以没有返回结果，若没返回结果则新生成的jQuery则为空。 注意与each()方法的区别，该方法不会对原jQuery对象造成任何改变，只会生成新的jQuery对象。 回调函数共有3个参数： index：被遍历的DOM元素索引值 value：被遍历的DOM元素本身 array：被遍历的原jQuery对象本身 此外，在普通回调函数中可使用this，这代表当前被遍历的DOM元素，如果是箭头回调函数，则会指向undefined。 如下示例，遍历原jQuery对象中的所有DOM元素，提取其innerText并返回组成一个新的jQuery对象： body { padding: 1rem; } A B C D E \"use strict\"; let $elements = $(\"main div ul li\"); let $elementsText = $elements.map((index, element, array) => { return element.innerText; }) console.log($elementsText); // jQuery.fn.init(5) [\"A\", \"B\", \"C\", \"D\", \"E\", prevObject: jQuery.fn.init(5)] 层级关系获取 children() 子代 从子代元素筛选出符合条件的元素，返回一个新的jQuery对象： body { padding: 1rem; } A B C D E \"use strict\"; let $elements = $(\"main\"); let $li3 = $elements.children(\"div\").children(\"ul\").children(\"li\").eq(3); $li3.css(\"color\", \"#aaa\"); console.log($li3); // jQuery.fn.init [li, prevObject: jQuery.fn.init(5)] find() 后代 从后代元素筛选出符合条件的元素，返回一个新的jQuery对象： body { padding: 1rem; } A B C D E \"use strict\"; let $elements = $(\"main\"); let $li3 = $elements.find(\"div ul li\").eq(3); $li3.css(\"color\", \"#aaa\"); console.log($li3); // jQuery.fn.init [li, prevObject: jQuery.fn.init(5)] parent() 父级 获取或筛选父级元素，返回一个新的jQuery对象： body { padding: 1rem; } A B C D E \"use strict\"; let $elements = $(\"main div ul\"); let $parent = $elements.parent(); console.log($parent); // jQuery.fn.init [div, prevObject: jQuery.fn.init(1)] parents() 祖先 获取或筛选祖先级元素，返回一个新的jQuery对象： body { padding: 1rem; } A B C D E \"use strict\"; let $elements = $(\"main div ul\"); let $parents = $elements.parents(); console.log($parents); // jQuery.fn.init(4) [div, main, body, html, prevObject: jQuery.fn.init(1)] parentsUntill() 祖先区间 从当前对象开始，查找直系的所有祖先级标签，直到找到指定的祖先标签结束。 返回一个新的jQuery对象，若没有指定截止条件，将会一直向上查找到标签为止。 不会获取自身，不会获取符合指定条件的祖先标签 相当于孙子问爷爷，你的后代除了我还有谁，爷爷当然不会把自己算进去 示例如下： body { padding: 1rem; } A B C D E \"use strict\"; let $elements = $(\"main div ul\"); let $parentsUntil = $elements.parentsUntil(\"body\"); console.log($parentsUntil); // jQuery.fn.init(2) [div, main, prevObject: jQuery.fn.init(1)] closest() 条件祖先 查找最近的符合选择器的祖先元素（包括自身），返回一个新的jQuery对象。 找祖先，看最近的祖先能不能被选择器选中，如果不能继续向上找。 这与JavaScript中的closest()方法基本相同，但JavaScript中返回的是单个DOM元素，而jQuery中返回一个jQuery对象。 body { padding: 1rem; } A B C D E \"use strict\"; let $elements = $(\"main div ul\"); let $closest = $elements.closest(\"body\"); console.log($closest); // jQuery.fn.init [body, prevObject: jQuery.fn.init(1)] prev() 哥哥 获取或筛选当前元素同级中的前一个元素，返回一个新的jQuery对象。 body { padding: 1rem; } A B C D E \"use strict\"; let $elements = $(\"main div li\").eq(2).text(\"me\"); let $prev = $elements.prev().css({ \"color\": \"#aaa\" }); console.log($prev); // jQuery.fn.init [li, prevObject: jQuery.fn.init(1)] prevAll() 所有哥哥 获取或筛选当前元素同级中的前面所有元素，返回一个新的jQuery对象。 body { padding: 1rem; } A B C D E \"use strict\"; let $elements = $(\"main div li\").eq(2).text(\"me\"); let $prevAll = $elements.prevAll().css({ \"color\": \"#aaa\" }); console.log($prevAll); // jQuery.fn.init(2) [li, li, prevObject: jQuery.fn.init(1)] prevUntil() 哥哥区间 从当前对象开始，查找同级向前的所有标签，直到指定标签结束，返回一个新的jQuery对象。 返回一个新的jQuery对象，若没有指定截止条件，则相当于使用prevAll()方法。 不会获取自身，不会获取符合指定条件的哥哥标签 相当于弟弟问某一个哥哥，你的弟弟除了我还有谁，哥哥当然不会把自己算进去 示例如下： body { padding: 1rem; } A B C D E \"use strict\"; let $elements = $(\"main div li\").eq(4).text(\"me\"); let $prevUntil = $elements.prevUntil(\":contains(A)\").css({ \"color\": \"#aaa\" }); console.log($prevUntil); // jQuery.fn.init(3) [li, li, li, prevObject: jQuery.fn.init(1)] next() 弟弟 获取或筛选当前元素同级中的后一个元素，返回一个新的jQuery对象。 body { padding: 1rem; } A B C D E \"use strict\"; let $elements = $(\"main div li\").eq(2).text(\"me\"); let $next = $elements.next().css({ \"color\": \"#aaa\" }); console.log($next); // jQuery.fn.init [li, prevObject: jQuery.fn.init(1)] nextAll() 所有弟弟 获取或筛选当前元素同级中的后面所有元素，返回一个新的jQuery对象。 body { padding: 1rem; } A B C D E \"use strict\"; let $elements = $(\"main div li\").eq(2).text(\"me\"); let $nextAll = $elements.nextAll().css({ \"color\": \"#aaa\" }); console.log($nextAll); // jQuery.fn.init(2) [li, li, prevObject: jQuery.fn.init(1)] nextUntil() 弟弟区间 从当前对象开始，查找同级向后的所有标签，直到指定标签结束，返回一个新的jQuery对象。 返回一个新的jQuery对象，若没有指定截止条件，则相当于使用nextAll()方法。 不会获取自身，不会获取符合指定条件的弟弟标签 相当于哥哥问某一个弟弟，你的哥哥除了我还有谁，弟弟当然不会把自己算进去 示例如下： body { padding: 1rem; } A B C D E \"use strict\"; let $elements = $(\"main div li\").eq(0).text(\"me\"); let $nextUntil = $elements.nextUntil(\":contains(E)\").css({ \"color\": \"#aaa\" }); console.log($nextUntil); // jQuery.fn.init(3) [li, li, li, prevObject: jQuery.fn.init(1)] siblings() 所有兄弟 获取或筛选当前元素同级中的前面以及后面所有元素，返回一个新的jQuery对象。 body { padding: 1rem; } A B C D E \"use strict\"; let $elements = $(\"main div li\").eq(2).text(\"me\"); let $siblings = $elements.siblings().css({ \"color\": \"#aaa\" }); console.log($siblings); // jQuery.fn.init(4) [li, li, li, li, prevObject: jQuery.fn.init(1)] has() 必须有儿子 检测一个元素是否包含另一个元素，如果包含则返回一个新的jQuery对象，该jQuery对象中存有被检测的DOM元素。 以下示例将演示如果一个中包含则该的背景色变为红色。 ??? !!! ??? \"use strict\"; $(\"div\").has(\"span\").css(\"background-color\", \"red\"); 定位关系获取 offsetParent() 匹配出用于当前元素定位的祖先级节点元素，返回一个新的jQuery对象。 body { padding: 1rem; } main { position: relative; } main div ul { /* ul将按照main进行定位 */ position: absolute; } A B C D E \"use strict\"; let $elements = $(\"main div ul\"); let $offsetParent = $elements.offsetParent(); console.log($offsetParent); // jQuery.fn.init [main, prevObject: jQuery.fn.init(1)] 其他方法 addBack() 回链操作 addBack()方法将先前一次所选择的jQuery对象与最近一次所选择的jQuery对象中的元素进行合并，返回一个新的jQuery对象。 在jQuery1.8版本以下，该方法名为andSelf()。 jQuery对象中有一个prevObject属性，指向上一个链式操作的jQuery对象，如我先获取了包含的jQuery对象、再获取了包含的jQuery对象。 那么包含的jQuery对象的prevObject属性就指向包含标签的jQuery对象。 body { padding: 1rem; } A B C D E \"use strict\"; let $currentJq = $(\"main div ul\").find(\"li\"); let $prevjQ = $currentJq.prevObject; console.log($prevjQ); // jQuery.fn.init [ul, prevObject: jQuery.fn.init(1)] 回链操作addBack()方法的意思在于，同时操作当前的jQuery对象和上一个jQuery对象。 如我想为当前包含的jQuery对象和上一个包含的jQuery对象中的DOM元素都添加一个class属性，就可以使用到该方法： body { padding: 1rem; } A B C D E \"use strict\"; let $currentJq = $(\"main div ul\").find(\"li\"); $currentJq.addBack().addClass(\"ul_family\"); 最终的效果： A B C D E end() 回溯操作 对jQuery对象进行回溯，当我们操作完一组jQuery对象中的元素后又想拿到操作之前的原本jQuery对象就可使用此方法。 以下示例将展示选取所有的元素，查找并将子元素颜色，然后再使用end()回过来选取元素： Hello,how are you? \"use strict\"; console.log($(\"p\").find(\"span\").css(\"color\", \"red\").end()) // jQuery.fn.init [p, prevObject: jQuery.fn.init(1)] Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:48 "},"前端专栏/jQuery/属性内容.html":{"url":"前端专栏/jQuery/属性内容.html","title":"属性内容","keywords":"","body":"属性操作 标准属性 prop() 标准属性即为HTML标签中自带的一些常见属性。 如：id、class、的name、value、readonly、disabled等。 一言以蔽之，只要不是自定义的标签属性都被称之为标准属性。 prop()方法用于获取或者设置jQuery对象中DOM元素的标准属性与值。 一个参数：获取标准属性 两个参数：设置标准属性 一个字典：设置多个标准属性 示例如下： click me \"use strict\"; let $a = $(\"a\"); // 获取一个 console.log($a.prop(\"href\")); // 设置多个 console.log($a.prop( { href: \"http://www.google.com\", title: \"谷歌搜索\", target: \"_self\", } )); 特征属性 attr() 特征属性即我们为HTML标签自定义的一些属性。 一言以蔽之，只要不是自带的标签属性都被称之为特征属性。 attr()方法用于获取或者设置jQuery对象中DOM元素的特征属性与值。 一个参数：获取特征属性 两个参数：设置特征属性 一个字典：设置多个特征属性 示例如下： click me \"use strict\"; let $a = $(\"a\"); // 获取一个 console.log($a.attr(\"help\")); // 设置多个 console.log($a.attr( { help: \"help message\", fontSize: \"32px\" } )); 删除属性 removeAttr() removeAttr()方法用于删除jQuery对象中DOM元素的一个标准或特征属性，被删除的属性值将被置为undefined： click me \"use strict\"; let $a = $(\"a\"); // 删除标准属性 $a.removeAttr(\"href\"); $a.removeAttr(\"title\"); $a.removeAttr(\"target\"); // 删除特征属性 $a.removeAttr(\"help\"); $a.removeAttr(\"fontSize\"); 特征属性集 data() 我们自定义的特征属性在某些时候很容易和标准属性名字发生冲突。 针对这种情况，我们只需要在特征属性定义时前面加上data-的前缀即可。 要获取这些特征属性时，可直接通过$(selector).data()属性集进行获取。 通过属性集去获取特征属性时，忽略data-的前缀 仅能进行获取，不能进行设置，即使设置完成后也将不会被DOM渲染到标签上，但是属性集会进行更新 示例如下： click me \"use strict\"; let $a = $(\"a\"); // 设置一个特征属性集中的属性 $a.data(\"help\", \"help message\"); // 设置多个特征属性集中的属性 $a.data( { \"help\": \"i can help you\", \"font-size\": \"32px\" } ) // 获取一个特征属性集中的属性 console.log($a.data(\"help\")); // i can help you // 获取所有特征属性集中的属性 console.log($a.data()); // {help: \"i can help you\", fontSize: \"32px\"} // 属性集虽然更新了，但DOM节点元素本身并不会更新属性： // click me // 所以jQuery的data()方法仅能获取属性集中的特征属性，不要去进行设置，因为设置了也没用 removeData() 删除属性集中的一个属性。 不能是在HTML文档上设置的特征属性，必须由data()所设置。 click me \"use strict\"; let $a = $(\"a\"); // 目前的a标签属性集包括自带的：help和font-size console.log($a.data()); // {fontSize: \"2rem\", help: \"帮助信息\"} // 自己设置一个，它将不会被DOM渲染到标签上 $a.data(\"set\", \"attribute\"); console.log($a.data()); // {fontSize: \"2rem\", help: \"帮助信息\", set: \"attribute\"} // 只能删除自己设置的，不能删除自带的，即使你删除了自带的，也不会被DOM渲染到标签上 $a.removeData(\"set\"); $a.removeData(\"font-size\"); console.log($a.data()); // {help: \"帮助信息\"} // click me 节点内容 html() 获取或设置jQuery对象DOM元素中的HTML内容，并且也可以向标签中添加HTML内容，同时触发浏览器的解析器重绘DOM。 与JavaSctip中的innerHTML属性效果相同。 没有参数：获取内容 一个参数：设置内容 如下所示： HELLO WORLD \"use strict\"; // 获取 console.log($(\"main\").html()); // HELLO WORLD // 设置 $(\"main\").html(\"HELLO WORLD\") text() 获取或设置jQuery对象DOM元素中的文本内容，并且也可以向标签中添加文本内容，同时触发浏览器的解析器重绘DOM。 与JavaSctip中的innerText属性效果相同。 没有参数：获取内容 一个参数：设置内容 如下所示： HELLO WORLD \"use strict\"; // 获取 console.log($(\"main\").text()); // HELLO WORLD // 设置 $(\"main\").text(\"HELLO JavaScript\") 表单内容 val() 获取或设置jQuery对象DOM元素（常指input）的value值： 没有参数：获取value值 一个参数：设置value值 如下所示： \"use strict\"; // 设置 $(\":text\").val(\"learn\") // 获取 console.log($(\":text\").val()); // learn Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:48 "},"前端专栏/jQuery/文档操作.html":{"url":"前端专栏/jQuery/文档操作.html","title":"文档操作","keywords":"","body":"创建标签 $() 使用$()可创建出一个DOM元素，它将返回一个jQuery对象。 支持标签的嵌套创建 支持属性、内容的定义 如果创建的标签没有内容，且是闭合标签，则可以不用写后面的闭合部分 示例演示： \"use strict\"; // 1.支持标签的嵌套创建，支持属性、内容的定义 let $elements = $( ` HELLO WORLD ` ); // 2.如果创建的标签没有内容，且是闭合标签，则可以不用写后面的闭合部分 let $div = $(\"\"); console.log($elements); console.log($div); // jQuery.fn.init [main.demo] // jQuery.fn.init [div] 子级插入 prepend() 向jQuery对象中的每一个DOM元素内部的末尾插入新的内容，返回新的jQuery对象。。 let $div = $(\"\"); let $main = $(\"main\"); $main.prepend($div); console.log($main.get(0)); /* */ append() 向jQuery对象中的每一个DOM元素内部的开头插入新的内容，返回新的jQuery对象。。 let $div = $(\"\"); let $main = $(\"main\"); $main.append($div); console.log($main.get(0)); /* */ prependTo() 将新的内容插入至jQuery对象中的每一个DOM元素内部的末尾，返回新的jQuery对象。 注意与prepend()的区别： prepend()：在A的内部插入B prependTo()：把B插入至A的内部 如下所示： let $div = $(\"\"); let $main = $(\"main\"); $div.prependTo($main); console.log($main.get(0)); /* */ appendTo() 将新的内容插入至jQuery对象中的每一个DOM元素内部的开头，返回新的jQuery对象。 注意与append()的区别： append()：在A的内部插入B appendTo()：把B插入至A的内部 如下所示： let $div = $(\"\"); let $main = $(\"main\"); $div.appendTo($main); console.log($main.get(0)); /* */ 同级插入 before() 向jQuery对象中的每一个DOM元素同级的前面插入新的内容，返回新的jQuery对象。 let $div = $(\"\"); let $main = $(\"main\"); $main.before($div); /* */ after() 向jQuery对象中的每一个DOM元素同级的后面插入新的内容，返回新的jQuery对象。 let $div = $(\"\"); let $main = $(\"main\"); $main.after($div); /* */ insterBefer() 将新的内容插入至jQuery对象中的每一个DOM元素同级的前面，返回新的jQuery对象。 注意与befer()的区别： befer()：在A的前面插入B insterBeferTo()：把B插入至A的前面 如下所示： let $div = $(\"\"); let $main = $(\"main\"); $div.insertBefore($main); /* */ insertAfter() 将新的内容插入至jQuery对象中的每一个DOM元素同级的后面，返回新的jQuery对象。 注意与after()的区别： after()：在A的后面插入B insterAfterTo()：把B插入至A的后面 如下所示： let $div = $(\"\"); let $main = $(\"main\"); $div.insertAfter($main); /* */ 外部包裹 wrap() 将jQuery对象中的每一个标签外部包裹上另一个标签： HELLO HELLO HELLO let $span = $(\"span\"); $span.wrap(\"\"); /* HELLO HELLO HELLO */ wrapAll() 将jQuery对象中的所有标签外部包裹上另一个标签： HELLO HELLO HELLO let $span = $(\"span\"); $span.wrapAll(\"\"); /* HELLO HELLO HELLO */ wrapInner() 将每一个匹配的元素的内容（包括文本节点）用一个HTML结构包裹起来： HELLO HELLO HELLO let $span = $(\"span\"); $span.wrapInner(\"\") /* HELLO HELLO HELLO */ 外部移除 unwrap() 将jQuery对象中的每一个标签外部父级标签进行移除： HELLO HELLO HELLO let $span = $(\"span\"); $span.unwrap(); /* HELLO HELLO HELLO */ 替换操作 replaceWith() 将jQuery对象中的每一个标签替换为任意元素，可以是文本，也可以是标签： HELLO HELLO HELLO let $span = $(\"span\"); $span.replaceWith(`文本${$span.html()}文本`); /* 文本HELLO文本 文本HELLO文本 文本HELLO文本 */ replaceAll() 用一个任意元素，可以是文本将jQuery对象中的每一个标签替换： 注意与replaceWith()的区别： replaceWith()：把A替换为B replaceAll()：用B来替换A 如下所示： HELLO HELLO HELLO let $span = $(\"span\"); let $mark = $(`${$span.html()}`); $mark.replaceAll($span); /* HELLO HELLO HELLO */ 删除操作 empty() 删除jQuery对象中每个元素的子节点（不会删除自己），这个只属于清空操作。 HELLO HELLO HELLO let $span = $(\"span\"); $span.empty(); /* */ remove() 删除jQuery对象中的元素（连同自己和子类一同删除）。 HELLO HELLO HELLO let $span = $(\"span\"); $span.remove(); /* */ detach() 删除HTML文档中的标签元素，但会保留jQuery对象中的元素。 因为将来有可能再用到，保留所有子级标签，事件绑定，属性等。 HELLO HELLO HELLO let $span = $(\"span\"); $span.detach(); // 依旧保留jQuery对象中的元素，而remove()是全部删除干净 console.log($span); // S.fn.init(3) [span, span, span, prevObject: S.fn.init(1)] /* */ 克隆拷贝 clone() 用于拷贝节点，与JavaScript中的cloneNode()效果相同。 参数为true时会递归复制子节点即深拷贝，包括将原标签的事件等也一同进行拷贝。 function show(ele, jQevent) { ele.style.backgroundColor = \"blue\"; document.body.append($(\"div\").eq(0).clone(true).get(0)); } // 必须要取出单独DOM元素，否则每次都会成倍添加。 // 第一次 2个 第二次 4个 第三次 8个 // 因为jQuery对象是一个集合，而不是单独元素，每一次的克隆都会对jQuery对象进行遍历克隆。所以会成倍添加 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:48 "},"前端专栏/jQuery/样式操作.html":{"url":"前端专栏/jQuery/样式操作.html","title":"样式操作","keywords":"","body":"单一样式 css() CSS()方法用于获取或者设置jQuery对象中DOM元素的style。 一个参数：获取某个样式 两个参数：设置某个样式 一个字典：设置多个样式 注意，如果样式名称由多个单词组成，在设置或者获取的时候对样式名称的书写可以使用驼峰式，也可使用分割式，如： backgourndColor background-color 示例如下： main { font-size: 1rem; background-color: #ff0000; } main element \"use strict\"; let $main = $(\"main\"); // 获取一个 console.log($main.css(\"background-color\")); // 设置一个 $main.css(\"background-color\", \"#aaa\"); // 设置多个 $main.css({ \"font-size\": \"2rem\", \"border\": \"1px solid #ddd\", \"box-shadow\": \"rgba(100, 100, 100, .5) 10px 10px 5px\" }); 批量样式 hasClass() 检测jQuery对象中的任意一个DOM元素是否具有某一个class，返回boolean类型。 .demo { background: #ff0000; } 1 2 \"use strict\"; let $div = $(\"div\"); console.log($div.hasClass(\"demo\")); // true addClass() 统一为jQuery对象中的DOM元素添加一个或多个class： .demo { background: #ff0000; } 1 2 \"use strict\"; let $div = $(\"div\"); // 添加一个class $div.addClass(\"learn\"); // 添加多个class $div.addClass(\"jQ focus\"); // 1 // 2 removeClass() 统一为jQuery对象中的DOM元素删除一个或多个class： .demo { background: #ff0000; } 1 2 \"use strict\"; let $div = $(\"div\"); // 删除一个class $div.removeClass(\"demo\"); // 删除多个class $div.removeClass(\"learn jQ focus\"); // 1 // 2 toggleClass() 检测jQuery中的DOM元素里某个class属性是否存在。 如果存在、则删除掉该class 如果不存在，则添加该class .demo { background: #ff0000; } no have class demo no have class demo \"use strict\"; let $div = $(\"div\"); $div.on(\"click\", jQevent => { let $ele = $(jQevent.target); $ele.toggleClass(\"demo\"); $ele.hasClass(\"demo\") ? $ele.text(\"add class demo\") : $ele.text(\"remove class demo\"); }); Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:48 "},"前端专栏/jQuery/事件操作.html":{"url":"前端专栏/jQuery/事件操作.html","title":"事件操作","keywords":"","body":"事件对象 jQevent jQuery中的事件对象和原生JavaScript中的事件对象有所不同，它是在原生事件对象的基础上做了一次封装。 所以在绑定回调函数的参数上更推荐使用jQevent这个形参名来接收jQuery事件对象，而不是使用event。 属性方法 以下是jQevent中可调用的属性，仅例举常见属性： 属性 描述 jQevent.type 该属性保存此次事件的类型 jQevent.target 该属性指向引起本次事件发生的源对象 jQevent.currentTarget 该属性指向当前正在执行事件处理的对象 jQevent.timeStamp 该属性保存事件发生时的时间 jQevent.result 该属性保存最后一个回调函数的返回结果 jQevent.pageX 针对鼠标事件、鼠标相对于文档X轴的位置 jQevent.pageY 针对鼠标事件、鼠标相对于文档Y轴的位置 jQevent.which 针对键鼠事件、获取按下的按键编号 以下是jQevent中可调用的方法，仅例举常见方法： 方法 描述 jQevent.preventDefault() 阻止默认事件 jQevent.isDefaultPrevented() 判断是否阻止了默认事件 jQevent.stopPropagation() 阻止事件的冒泡传递 jQevent.isPropagationStopped() 判断是否阻止了事件的冒泡传递 jQevent.stopImmediatePropagation() 阻止事件的传播及冒泡 jQevent.isImmediatePropagationStopped() 判断是否阻止了事件的传播及冒泡 两者区别： jQevent.stopPropagation()：防止事件冒泡到DOM树上，也就是不触发的任何父级元素上的事件处理函数 jQevent.stopImmediatePropagation()：阻止剩余相同事件的处理函数执行，并且防止事件冒泡到DOM树上 如果有疑问，请前往JavaScript中Event操作查看详情。 事件监听 常用事件 以下例举常见的可用于监听的事件。 事件 描述 ready 文档准备就绪。不需要等待外部资源的加载 resize 浏览器窗口调整时 click 鼠标左键单击（同时触发mousedown以及mouseup） dblclick 鼠标左键双击 mousedown 鼠标左键、右键按下 mouseup 鼠标左键、右键松开 mouseover 鼠标移入时 mousemove 鼠标移动时 mouseout 鼠标移出时 mouseenter 鼠标移入时，不产生冒泡行为 copy 拷贝时 scroll 滚动时 focus 元素获取焦点后触发 blur 元素失去焦点后触发 input 元素内容发生改变后触发 click 单击了某个表单项 change 元素内容发生改变并且失去焦点时触发 submit 提交表单时触发 keydown 按下某个键、长按时将重复触发 keyup 松开某个键 keypress 按下并松开某个键、长按时将重复触发 on() 委托绑定 我们可以使用on()方法绑定事件的处理程序，它不仅仅可以为自身做绑定，也可以为未来元素做事件委托。 同addEventListener()方法一样，jQuery.fn.on()方法允许对同一个元素监听多次相同的事件 注意this指向问题，如果处理程序的回调函数是普通函数，那么this指向事件源jQevent.target，如果处理程序的回调函数是箭头函数，那么this指向undefined，此时可使用jQevent.target来指向事件源对象 如果我们的jQuery对象中有多个DOM元素，那么一次事件监听将作用到所有的DOM元素身上。 1）普通的事件绑定： ul li { margin-top: 1rem; height: 20px; width: 200px; background: #ddd; } \"use strict\"; let $li = $(\"ul li\"); // 绑定的元素 监听的事件 回调函数 $li.on(\"click\", jQevent => { let r = Math.floor(Math.random() * (255 + 1)); let g = Math.floor(Math.random() * (255 + 1)); let b = Math.floor(Math.random() * (255 + 1)); let a = Math.random().toFixed(1); $(jQevent.target).css(\"background\", `rgba(${r},${g},${b},${a})`); }); 2）为未来元素进行事件的委托代理： ul li { margin-top: 1rem; height: 20px; width: 200px; background: #ddd; } \"use strict\"; let $ul = $(\"ul\"); // 委托的元素 代理的事件 事件目标 事件目标的回调函数 $ul.on(\"click\", \"li\", jQevent => { let r = Math.floor(Math.random() * (255 + 1)); let g = Math.floor(Math.random() * (255 + 1)); let b = Math.floor(Math.random() * (255 + 1)); let a = Math.random().toFixed(1); $(jQevent.target).css(\"background\", `rgba(${r},${g},${b},${a})`); }); off() 解除绑定 使用off()方法解除被监听的或者被委托的事件。 1）解绑监听事件： ul li { margin-top: 1rem; height: 20px; width: 200px; background: #ddd; } Cancel binding \"use strict\"; let $li = $(\"ul li\"); let $btn = $(\"button\"); // 绑定的元素 监听的事件 回调函数 $li.on(\"click\", jQevent => { let r = Math.floor(Math.random() * (255 + 1)); let g = Math.floor(Math.random() * (255 + 1)); let b = Math.floor(Math.random() * (255 + 1)); let a = Math.random().toFixed(1); $(jQevent.target).css(\"background\", `rgba(${r},${g},${b},${a})`); }); $btn.on(\"click\", jQevent => { $li.off(\"click\"); }) 2）解除委托事件 ul li { margin-top: 1rem; height: 20px; width: 200px; background: #ddd; } Cancel binding \"use strict\"; let $ul = $(\"ul\"); let $btn = $(\"button\"); // 委托的元素 代理的事件 事件目标 事件目标的回调函数 $ul.on(\"click\", \"li\", jQevent => { let r = Math.floor(Math.random() * (255 + 1)); let g = Math.floor(Math.random() * (255 + 1)); let b = Math.floor(Math.random() * (255 + 1)); let a = Math.random().toFixed(1); $(jQevent.target).css(\"background\", `rgba(${r},${g},${b},${a})`); }); $btn.on(\"click\", jQevent => { $ul.off(\"click\", \"li\"); }) 其他绑定 方法示例 下面的这些接口不太常用，了解即可： 接口名称 描述 bind() 单独绑定，不支持事件代理 one() 绑定一次性事件，不支持事件代理 toggle() 用于绑定多个事件处理函数，在事件触发时依次执处理函数 trigger() 主动触发某个事件，它会触发默认行为与冒泡行为 triggerHandler() 主动触发某个事件，它不会触发默认行为与冒泡行为 bind() 以下示例将展示使用单独绑定根据点击来改变元素随机色： div { background-color: red; color: white; height: 100px; width: 100px; text-align: center; line-height: 100px; cursor: pointer; } 点我随机变色 \"use strict\"; $(\"div\").bind(\"click\", function (jQevent) { const r = Math.floor(Math.random() * (255 + 1)); const g = Math.floor(Math.random() * (255 + 1)); const b = Math.floor(Math.random() * (255 + 1)); const a = Math.random().toFixed(1); this.style.backgroundColor = `rgba(${r},${g},${b},${a})`; }); one() 以下示例将展示使用单次绑定第一次点击时改变元素随机色： div { background-color: red; color: white; height: 100px; width: 100px; text-align: center; line-height: 100px; cursor: pointer; } 点我随机变色 \"use strict\"; $(\"div\").one(\"click\", function (jQevent) { const r = Math.floor(Math.random() * (255 + 1)); const g = Math.floor(Math.random() * (255 + 1)); const b = Math.floor(Math.random() * (255 + 1)); const a = Math.random().toFixed(1); this.style.backgroundColor = `rgba(${r},${g},${b},${a})`; }); trigger() 以下示例将展示使用trigger()使input获得焦点，并且输入内容： 它不会阻止默认行为的发生 它不会阻止冒泡行为的传递 也就是说，当你点击按钮的时候，它会执行浏览默认的动作，也会执行你为input:focus绑定的动作。 所以你会观察到、先获取焦点、再改变了input的value值。 示例如下： get focus \"use strict\"; let $btn = $(\"button\"); let $input = $(\"input\"); $btn.on(\"click\", jQevent => { $input.eq(0).trigger(\"focus\"); }); $input.on(\"focus\", jQevent=>{ jQevent.target.value = \"OK\"; }); triggerHandler() 以下示例将展示使用triggerHandler()使input获得焦点，并且输入内容： 它将阻止默认行为的发生 它将阻止冒泡行为的传递 也就是说，当你点击按钮的时候，它不会执行浏览默认的动作，只会执行你为input:focus绑定的动作。 所以你会观察到、它不会获取焦点、而是直接改变input的value值。 示例如下： get focus \"use strict\"; let $btn = $(\"button\"); let $input = $(\"input\"); $btn.on(\"click\", jQevent => { $input.eq(0).triggerHandler(\"focus\"); }); $input.on(\"focus\", jQevent=>{ jQevent.target.value = \"OK\"; }); 入口函数 完整写法 jQuery的入口函数window.ready相当于window.addEventListener(\"DOMContentLoaded\", fn) 。 该事件会在文档解析完成时触发，它不需要等待所有外部资源加载完成。 而原生JavaScript中的window.onload(fn)则会等待所有外部资源加载完成后才触发。 如下所示： \"use strict\"; $(window).ready(function (jQevet) { console.log(\"文档加载完成\"); }); 简便写法 简写形式： \"use strict\"; $((jQevet) => { console.log(\"文档加载完成\"); }) Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:48 "},"前端专栏/jQuery/空间坐标.html":{"url":"前端专栏/jQuery/空间坐标.html","title":"空间坐标","keywords":"","body":"位置获取 视口位置 offset()方法可用于获取或者设置当前元素位于视口中的距离。 * { padding: 0; margin: 0; } div { width: 100px; height: 100px; border: 1px solid #ddd; transform: translate3d(100px, 100px, 0); } \"use strict\"; // 设置 $(\"div\").offset( { top: 120, left: 200 } ) // 获取 console.log($(\"div\").offset()); // {top: 120, left: 200} 父级位置 position()方法可用于获取当前元素对于已定位的父级元素的位置信息。ew56666 main { height: 400px; width: 400px; border: 1px solid #ddd; position: relative; } main div { height: 200px; width: 200px; border: 1px solid #eee; position: absolute; top: 20px; left: 20px; height: 20px; } \"use strict\"; // 获取 console.log( $(\"main div\").position() ); // {top: 20, left: 20} 元素尺寸 height() \\ width() height()和width()方法用于获取元素内容区域的宽高： div { height: 100px; width: 100px; padding: 5px; border: 5px solid #5da; } \"use strict\"; console.log( \"\".concat(\"height:\", $(\"div\").height(), \"px \", \"width:\", $(\"div\").width(), \"px\") ); // height:100px width:100px innerHeight() \\ innerWidth() innerHeight()和innerWidth()方法用于获取元素内容区域以及内边距之内的补白区域的宽高： div { height: 100px; width: 100px; padding: 5px; border: 5px solid #5da; } \"use strict\"; console.log( \"\".concat(\"innerHeight:\", $(\"div\").innerHeight(), \"px \", \"innerWidth:\", $(\"div\").innerWidth(), \"px\") ); // innerHeight:110px innerWidth:110px outerHeight() \\ outerWidth() outerHeight()和outerWidth()方法用于获取元素内容区域以及内边距之内的补白区域和边框区域的宽高： div { height: 100px; width: 100px; padding: 5px; border: 5px solid #5da; } \"use strict\"; console.log( \"\".concat(\"outerHeight:\", $(\"div\").outerHeight(), \"px \", \"outerWidth:\", $(\"div\").outerWidth(), \"px\") ); // outerHeight:120px outerWidth:120px 滚动条相关 scrollTop() 获取或设置当前对象的纵向滚动条的位置： main { height: 200px; width: 200px; overflow: scroll; border: 1px solid #ddd; } main div { height: 1000px; width: 1000px; background: linear-gradient(90deg, #feac5e 0%, #c779d0 50%, #4bc0c8 100%); } \"use strict\"; let x = $(\"main\").scrollLeft(); let y = $(\"main\").scrollTop(); setInterval(() => { x += 50; y += 50; // 每一秒X轴滚动条向右移动50 $(\"main\").scrollLeft(x); // 每一秒Y轴滚动条向下移动50 $(\"main\").scrollTop(y); }, 1000); scroolLeft() 获取或设置当前对象的横向滚动条的位置： main { height: 200px; width: 200px; overflow: scroll; border: 1px solid #ddd; } main div { height: 1000px; width: 1000px; background: linear-gradient(90deg, #feac5e 0%, #c779d0 50%, #4bc0c8 100%); } \"use strict\"; let x = $(\"main\").scrollLeft(); let y = $(\"main\").scrollTop(); setInterval(() => { x += 50; y += 50; // 每一秒X轴滚动条向右移动50 $(\"main\").scrollLeft(x); // 每一秒Y轴滚动条向下移动50 $(\"main\").scrollTop(y); }, 1000); Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:48 "},"前端专栏/jQuery/动画效果.html":{"url":"前端专栏/jQuery/动画效果.html","title":"动画效果","keywords":"","body":"基本效果 show()\\hide() 从左上角开始，向右下方渐变的进行显示和隐藏。 show()：显示 hide()：隐藏 参数释义： duration：动画执行完成所需的总毫秒数 complete：动画执行完毕后的回调函数 注意，元素隐藏后，是不占据文档流空间位置的，同级排列在后的元素会进行跟进补白。 示例如下： body div:nth-child(2) { margin-top: 1rem; } hide \"use strict\"; let $div = $(\"div\").eq(0); let $btn = $(\"div button\"); $btn.on(\"click\", event => { if ($btn.text() === \"hide\") { $div.hide(1000, () => { $btn.text(\"show\"); }) } else { $div.show(1000, () => { $btn.text(\"hide\"); }) } }) slideDown()\\slideUp() 自上而下渐变的进行显示和隐藏。 slideDown()：显示 slideUp()：隐藏 参数释义： duration：动画执行完成所需的总毫秒数 complete：动画执行完毕后的回调函数 注意，元素隐藏后，是不占据文档流空间位置的，同级排列在后的元素会进行跟进补白。 示例如下： body div:nth-child(2) { margin-top: 1rem; } slideUp \"use strict\"; let $div = $(\"div\").eq(0); let $btn = $(\"div button\"); $btn.on(\"click\", event => { if ($btn.text() === \"slideUp\") { $div.slideUp(1000, () => { $btn.text(\"slideDown\"); }) } else { $div.slideDown(1000, () => { $btn.text(\"slideUp\"); }) } }) slideToggle() 如果元素已隐藏，就显示，如果已显示，就隐藏。 它的表现效果和slideDown()&slideUp()相同。 参数释义： duration：动画执行完成所需的总毫秒数 complete：动画执行完毕后的回调函数 注意，元素隐藏后，是不占据文档流空间位置的，同级排列在后的元素会进行跟进补白。 如下所示： body div:nth-child(2) { margin-top: 1rem; } slideToggle-hide \"use strict\"; let $div = $(\"div\").eq(0); let $btn = $(\"div button\"); $btn.on(\"click\", event => { $div.slideToggle(1000, () => { $btn.text() === \"slideToggle-hide\" ? $btn.text(\"slideToggle-show\") : $btn.text(\"slideToggle-hide\"); }) }) 淡入淡出 fadeIn()\\fadeOut() 渐变的改变元素透明度，实现淡入淡出效果。 fadeIn()：透明度渐变为100%，即淡入 fadeOut()：透明度渐变为0%，即淡出 参数释义： duration：动画执行完成所需的总毫秒数 complete：动画执行完毕后的回调函数 注意，元素透明度为100%后，是不占据文档流空间位置的，同级排列在后的元素会进行跟进补白。 示例如下： body div:nth-child(2) { margin-top: 1rem; } fadeIn \"use strict\"; let $div = $(\"div\").eq(0); let $btn = $(\"div button\"); $btn.on(\"click\", event => { if ($btn.text() === \"fadeIn\") { $div.fadeIn(1000, () => { $btn.text(\"fadeOut\"); }) } else { $div.fadeOut(1000, () => { $btn.text(\"fadeIn\"); }) } }) fadeToggle() 如果元素已淡出，就淡入，如果已淡入，就淡出。 它的表现效果和fadeIn()&fadeOut()相同。 参数释义： duration：动画执行完成所需的总毫秒数 complete：动画执行完毕后的回调函数 注意，元素透明度为100%后，是不占据文档流空间位置的，同级排列在后的元素会进行跟进补白。 示例如下： body div:nth-child(2) { margin-top: 1rem; } fadeToggle-out \"use strict\"; let $div = $(\"div\").eq(0); let $btn = $(\"div button\"); $btn.on(\"click\", event => { $div.fadeToggle(1000, () => { $btn.text() === \"fadeToggle-out\" ? $btn.text(\"fadeToggle-in\") : $btn.text(\"fadeToggle-out\"); }) }) 自定义动画 animate() 使用animate()可对元素设置自定义动画。 参数释义： properties：一个Object，接收CSS自定义的CSS样式 duration：动画执行完成所需的总毫秒数 complete：动画执行完毕后的回调函数 示例如下： main { width: 250px; height: 250px; border: 1px solid #ddd; border-radius: 50%; position: relative; } \"use strict\"; setInterval(() => { let h = Math.floor(Math.random() * 256) + \"px\"; let w = Math.floor(Math.random() * 256) + \"px\"; let bw = Math.floor(Math.random() * 20) + \"px\"; $(\"main\").animate( // 动画执行后的最终样式 // border-width这种分割线形式的要变成小驼峰形式进行书写 { \"width\": w, \"height\": h, \"borderWidth\": bw }, // 动画执行时间 1000, // 动画执行完成后的回调函数 () => { console.log(\"callback run\"); }); }, 1000) Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:48 "},"前端专栏/jQuery/插件扩展.html":{"url":"前端专栏/jQuery/插件扩展.html","title":"插件扩展","keywords":"","body":"$的扩展 $.extend()用于为jQuery本身做扩展。 比如我们书写了一个插件，就可以使用$.extend()方法来合并该插件。 合并后的插件仅有$或者jQuery本身能够调用，jQuery的实例对象不能进行调用。 简而言之，jQuery.extend()相当于书写一个新的类方法，我们都知道类方法仅能由类本身调用： \"use strict\"; // 编写功能 function carousel() { console.log(\"generate carousel image\"); }; // 相当于jQuery.carousel = carousel $.extend({ carousel }); // 后续只有$或者jQuery能够调用该方法 $.carousel(); jQuery.carousel(); jQuery实例对象的扩展 jQuery.fn指向jQuery的原型，它里面存储的方法均能被jQuery实例对象所调用。 我们如果对jQuery.fn使用extend()方法，那么后续的jQuery实例对象都能够使用该方法，但jQuery对象本身不能使用。 简而言之，jQuery.fn.extend()相当于书写一个新的实例方法，我们都知道实例方法仅能由实例调用： 1 2 3 \"use strict\"; // 编写功能 function every(callback) { // this指向jQuery实例对象 for (let i = 0; i { return element.classList.contains(\"demo\"); }); console.log(result); Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:48 "},"前端专栏/jQuery/网络请求.html":{"url":"前端专栏/jQuery/网络请求.html","title":"网络请求","keywords":"","body":"后端代码 jQuery中的Ajax是对XmlHttpRequest的一层高级封装，使其使用更加简单。 为了方便后续前后端交互的代码测试，我们后端采用Python-flask框架来完成。 IP：localhost PORT：5700 代码如下： from flask import Flask from flask import request from flask import make_response from flask import jsonify app = Flask(__name__) @app.after_request # 解决CORS跨域请求 def cors(response): response.headers['Access-Control-Allow-Origin'] = \"*\" if request.method == \"OPTIONS\": # 允许的请求头 response.headers[\"Access-Control-Allow-Headers\"] = \"Origin,Content-Type,Cookie,Accept,Token,authorization,user_head\" return response @app.route(\"/get\", methods=[\"get\"]) def get(): user_head = request.headers.get(\"user_head\") user_params = request.args print(user_params) return jsonify(user_params, user_head) @app.route(\"/post\", methods=[\"post\"]) def post(): user_head = request.headers.get(\"user_head\") user_params = request.form print(user_params) return jsonify(user_params, user_head) @app.route(\"/json\", methods=[\"post\"]) def json(): user_head = request.headers.get(\"user_head\") user_params = request.json return jsonify(user_params, user_head) @app.route(\"/file\", methods=[\"post\"]) def file(): file_obj = request.files.get(\"avatar\") if file_obj is None: return make_response(jsonify(\"unload avatar\"), 400) file_name = file_obj.filename file_obj.save(file_name) return jsonify(\"upload avatar success!!\") if __name__ == \"__main__\": app.run(host=\"localhost\", port=5700, debug=True) 基本使用 以下是基本使用： $.ajax({ url: \"http://localhost:5700/get\", method: \"GET\", dataType: \"JSON\", headers: { \"user_head\": \"Hello World\" }, data: { name: \"Jack\", age: 18, gender: \"male\" }, success: (data, textStatus) => { console.log(\"成功\"); console.log(data); console.log(textStatus); }, error: (jqXHR, textStatus) => { console.log(\"失败\"); console.log(jqXHR); console.log(textStatus); }, complete: (jqXHR, textStatus) => { console.log(\"总是执行\"); console.log(jqXHR); console.log(textStatus); }, }) 参数释义： url：请求的地址 method：请求的方式，亦可使用type来进行定义 dataType：是否对后端返回的数据做JSON反序列化处理 headers：需要定制的请求头 data：需要发送的内容 success：请求成功后自动执行的回调函数 error：请求失败后自动执行的回调函数 complete：无论请求成功或者失败后都会执行自动执行的回调函数 在使用时的注意事项： 仅支持上传k-v的对象，不支持上传数组（仅针对非JSON数据格式的发送） 前端上传的数据中，不允许出现对象对象嵌套的形式。如{\"k1\":{\"k1-1\":v1}}，这样只会得到{“k1” : “object”} 如果前端传递的对象中键是一个Array，如 {\"k1\":[1, 2, 3, 4]} 则需要添加一个属性 traditional:true，否则后端将接收不到该参数。（实际上接受的时候要使用request.POST.get(\"k1[]\")）来进行接受，这是有问题的 jQuery.ajax在发送一次网络请求时，可指定以下5个回调钩子函数，它们会在适当的时候自动执行： beforeSend 在发送请求之前调用，并且传入一个XMLHttpRequest作为参数 dataFilter 在请求成功之后调用。传入返回的数据以及\"dataType\"参数的值。并且必须返回新的数据（可能是处理过的）传递给success回调函数，也就是说它会在success与error之前调用 success 在请求成功之后调用。传入返回后的数据，以及包含成功代码的字符串 error 在请求出错时调用。传入XMLHttpRequest对象，描述错误类型的字符串以及一个异常对象（如果有的话） complete 当请求完成之后调用这个函数，无论成功或失败。传入XMLHttpRequest对象，以及一个包含成功或错误代码的字符串 发送JSON JSON格式的数据只能由POST请求发起，除此之外还需要手动指定contentType为application/json和手动的对上传数据进行序列化。 如果你发送JSON格式的数据，是支持上传数组格式的数据的： $.ajax({ url: \"http://localhost:5700/json\", method: \"POST\", // 必须是POST dataType: \"JSON\", headers: { \"user_head\": \"Hello World\" }, contentType: \"application/json\", // 1.手动指定请求头中contentType的格式 data: JSON.stringify([1, 2, 3, 4, 5]), // 2.手动的对上传数据进行JSON序列化 success: (data, textStatus) => { console.log(\"成功\"); console.log(data); console.log(textStatus); }, error: (xhr, textStatus) => { console.log(\"失败\"); console.log(xhr); console.log(textStatus); }, complete: (xhr, textStatus) => { console.log(\"总是执行,此处可获取响应头\"); console.log(xhr); console.log(textStatus); } }) 获取表单 针对form表单提交的数据，我们可以使用jQuery对象的serialize()和serializeArray()方法。 serialize()：提取form表单中的数据项，并对其做url编码处理，返回一个字符串，注意，它不会提取文件选择框 serializeArray()：提取form表单中的数据，并将其构建为一个name：value的数组，注意，它不会提取文件选择框，最终格式为 [{name : “attribute”, value : “input”}, {name : “attribute”, value : “input”}] 示例如下，如果是serialize()则直接提交即可： 用户名 密码 男 女 篮球 足球 排球 城市 北京 上海 深圳 上传头像 提交 document.querySelector(\"button\").addEventListener(\"click\", (event) => { $.ajax({ url: \"http://localhost:5700/post\", method: \"POST\", headers: { \"user_head\": \"Hello World\" }, data: $(\"#register\").serialize(), dataType: \"JSON\", success: (data, textStatus) => { console.log(\"成功\"); console.log(data); console.log(textStatus); }, error: (xhr, textStatus) => { console.log(\"失败\"); console.log(xhr); console.log(textStatus); }, complete: (xhr, textStatus) => { console.log(\"总是执行,此处可获取响应头\"); console.log(xhr); console.log(textStatus); } }) console.log($(\"#register\").serialize()); // username=%E4%BA%91%E5%B4%96&password=123&gender=male&hobby=basketball&hobby=football&city=shanghai&city=shenzhen }) 如果是serializeArray()，需要使用appliction/json的方式进行提交，因为该方法返回的是一个数组： 用户名 密码 男 女 篮球 足球 排球 城市 北京 上海 深圳 上传头像 提交 document.querySelector(\"button\").addEventListener(\"click\", (event) => { $.ajax({ url: \"http://localhost:5700/json\", method: \"POST\", headers: { \"user_head\": \"Hello World\" }, contentType: \"application/json\", // 1.手动指定请求头中contentType的格式 data: JSON.stringify($(\"#register\").serializeArray()), // 2.手动的对上传数据进行JSON序列化 dataType: \"JSON\", success: (data, textStatus) => { console.log(\"成功\"); console.log(data); console.log(textStatus); }, error: (xhr, textStatus) => { console.log(\"失败\"); console.log(xhr); console.log(textStatus); }, complete: (xhr, textStatus) => { console.log(\"总是执行,此处可获取响应头\"); console.log(xhr); console.log(textStatus); } }) console.log($(\"#register\").serializeArray()); // Array(7) // 0: {name: \"username\", value: \"云崖\"} // 1: {name: \"password\", value: \"123\"} // 2: {name: \"gender\", value: \"male\"} // 3: {name: \"hobby\", value: \"basketball\"} // 4: {name: \"hobby\", value: \"football\"} // 5: {name: \"city\", value: \"shanghai\"} // 6: {name: \"city\", value: \"shenzhen\"} }) 发送文件 如果要发送文件，我们需要借助FormData对象进行数据提交，以下是注意事项。 在表单中上传文件，必须要将enctype设置为multipart/form-data。 但是在使用Ajax上传文件时，并不需要指定contentType为multipart/form-data，所以不添加contentType请求头。 contentType应设置为false，即不使用任何数据格式，不使用任何编码 processData应设置为false，不让浏览器做任何数据格式的编码 示例如下，我们使用FormData搭配serializeArray()方法实现一个真正意义上的异步提交表单： 用户名 密码 男 女 篮球 足球 排球 城市 北京 上海 深圳 上传头像 提交 document.querySelector(\"button\").addEventListener(\"click\", (event) => { // 获取上传的文件对象 let $fileNode = $(\"#avatar\"); let fileObj = $fileNode.get(0).files[0]; // 使用FormData用于伪造form表单提交的数据 let fd = new FormData(); // 添加文件 fd.append($fileNode.prop(\"name\"), fileObj); // 添加其他表单项 $(\"#register\").serializeArray().forEach((obj, index, array) => { fd.append(obj.name, obj.value); }); // 发送json格式数据 $.ajax({ url: \"http://localhost:5700/file\", method: \"POST\", headers: { \"user_head\": \"Hello World\" }, data: fd, // 直接发送ForData对象即可 dataType: \"JSON\", contentType: false, // 必须设置为false processData: false, // 必须设置为false success: (data, textStatus) => { console.log(\"成功\"); console.log(data); console.log(textStatus); }, error: (xhr, textStatus) => { console.log(\"失败\"); console.log(xhr); console.log(textStatus); }, complete: (xhr, textStatus) => { console.log(\"总是执行,此处可获取响应头\"); console.log(xhr); console.log(textStatus); } }) }) JSONP 如果你不了解JSONP，那么请参照JavaScript一章节中所介绍的JSONP相关知识。 jQuery中也对JSONP做好了封装，使用非常简单： click me \"use strict\"; let $btn = $(\"button\"); let $span = $(\"p span\") $btn.on(\"click\", (event) => { $.ajax({ url: \"http://localhost:5700/\", type: \"GET\", dataType: \"JSONP\", // 指定是一次JSONP的响应 jsonp: \"callback\", // 指定回调函数 }) }) function callbackfn(result) { $span.text(result); } 后端代码如下： from logging import debug, error from flask import Flask import random app = Flask(__name__) @app.route(rule=\"/\", methods=[\"GET\"], strict_slashes=False) def publicAPI(): number = random.randint(1, 100) return f\"callbackfn({number})\" if __name__ == \"__main__\": app.run(host=\"localhost\", port=5700, debug=True) 运行结果： Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:48 "},"前端专栏/TypeScript/summary.html":{"url":"前端专栏/TypeScript/summary.html","title":"TypeScript","keywords":"","body":" 基本介绍 类型相关 配置文件 面向对象 抽象基类 定义接口 泛型介绍 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:48 "},"前端专栏/TypeScript/基本介绍.html":{"url":"前端专栏/TypeScript/基本介绍.html","title":"基本介绍","keywords":"","body":"基础介绍 语言介绍 TypeScript出生名门，由大名鼎鼎的微软公司于2012年10月首次公开发布0.8版本。 它是一门基于JavaScript的静态、弱类型的扩展语言，在TypeScript中有一句非常出名的话，叫做TypeScript是JavaScript的一个超集。 这意味着，熟悉JavaScript的人不难上手TypeScript，你甚至可以将它理解为一个更优秀的JavaScript。 为什么要学习TypeScript？我之前也有过这种困惑，直至vue 3.x的发布坚定了我要学习它的想法。 众所周知，JavaScript是一门非常“随便”的语言，Thanks for inventing JavaScript这张图甚至可以排列到编程领域最出名的图片TOP10，由于JavaScript的随便，故项目后期的维护会变的非常困难。撸码一时爽，维护火葬场，几乎所有用过动态类型语言的程序员都会发出这种感叹。 在此环境下，微软公司推出了TypeScript、它相较于JavaScript增加了类型限制、类型检查、类型批注、类型推断、接口、枚举、元组、泛型、命名空间等特性，大大增强了项目的可维护性。 TypeScript的学习成本几乎可以忽略不计，如果你掌握了JavaScript并且接触过某些静态语言，如Java、Golang等，那么上手他将变得十分迅速。 发展历史 以下是TypeScript发展中的历史大事件： 2012-10：微软发布了 TypeScript 第一个版本（0.8），此前已经在微软内部开发了两年。 2014-04：TypeScript 发布了 1.0 版本。 2014-10：Angular 发布了 2.0 版本，它是一个基于 TypeScript 开发的前端框架。 2015-01：ts-loader 发布，webpack 可以编译 TypeScript 文件了。 2015-04：微软发布了 Visual Studio Code，它内置了对 TypeScript 语言的支持，它自身也是用 TypeScript 开发的。 2016-05：@types/react 发布，TypeScript 可以开发 React 应用了。 2016-05：@types/node 发布，TypeScript 可以开发 Node.js 应用了。 2016-09：TypeScript 发布了 2.0 版本。 2018-06：TypeScript 发布了 3.0 版本。 2019-02：TypeScript 宣布由官方团队来维护 typescript-eslint，以支持在 TypeScript 文件中运行 ESLint 检查。 2020-05：Deno 发布了 1.0 版本，它是一个 JavaScript 和 TypeScript 运行时。 2020-08：TypeScript 发布了 4.0 版本。 2020-09：Vue 发布了 3.0 版本，Vue 官方开始支持 TypeScript。 发展趋势 TypeScript适用于大型项目，虽然JavaScript拥有严格模式static，但它相较于TypeScript来说还是比较稀松的，TypeScript由于加入了类型限制，故可以规避掉很多由JavaScript语言特性所带来的坑。 从vue 3.x的发布可以看出TypeScript是未来前端发展的一个必然趋势，从Stack Overflow上看，TypeScript成为前端领域2021年最受欢迎的脚本编程语言，甚至已经远远的将JavaScript甩在了后面： Ts & Js TypeScript是基于JavaScript的，它会通过一个编译器将TypeScript代码编译为JavaScript代码，然后再交由JavaScript解析器进行解析和渲染。 默认情况下TypeScript编译器以ECMAScript 3（ES3）为目标，这意味着经过编译后的JavaScript代码为ES3标准，后续你也可以对其编译出的Js版本进行修改配置。 运行于任何平台上的任何网页浏览器都可以运行TypeScript。由于它仅仅是被编译为标准的JavaScript，一个脚本既可以被预编译为JavaScript，也可以通过为TypeScript包含JavaScript编译器实时编译。 Ts小结 什么是 TypeScript？ TypeScript 是添加了类型系统的 JavaScript，适用于任何规模的项目 TypeScript 是一门静态类型、弱类型的语言 TypeScript 是完全兼容 JavaScript 的，它不会修改 JavaScript 运行时的特性 TypeScript 可以编译为 JavaScript，然后运行在浏览器、Node.js 等任何能运行 JavaScript 的环境中 TypeScript 拥有很多编译选项，类型检查的严格程度由你决定 TypeScript 可以和 JavaScript 共存，这意味着 JavaScript 项目能够渐进式的迁移到 TypeScript TypeScript 增强了编辑器（IDE）的功能，提供了代码补全、接口提示、跳转到定义、代码重构等能力 TypeScript 拥有活跃的社区，大多数常用的第三方库都提供了类型声明 TypeScript 与标准同步发展，符合最新的 ECMAScript 标准（stage 3） 简单使用 安装node TypeScript的编译器基于Node.js开发，因此第一步你需要下载Node.js。 官方网站 下载完安装包后基本无脑下一步即可，直至安装完成后使用以下代码测试Node.js是否成功安装： $ node -v 下载TypeScript 接下来我们需要基于Node.js的npm来安装TypeScript，输入以下命令即可： $ npm -g install typescript 它会在全局环境中安装tsc命令，在安装完成后，只需输入tsc命令即可查看到一些TypeScript所提供的功能选项： $ tsc 现在让我们新建一个文件，以.ts结尾，在其中输入你的TypeScript代码： console.log(\"hello world\"); 可以发现我们输入的是JavaScript代码，这样做并不会有任何问题，因为TypeScript是JavaScript的一个超集。 编译JavaScript 下面，打开终端后输入以下命令即可，即可将TypeScript代码编译为JavaScript代码： $ tsc yourTypeScriptFilePath.ts 它会生成一个同名文件，但是以.js为后缀名结束的，后续你可以在文档中引入该JavaScript脚本文件。 使用ts-node 如果我们想直接运行TypeScript文件，则可以先下载一个ts-node，然后通过ts-node来直接运行TypeScript文件。 $ npm -g install ts-node 下载完成后你需要在当前ts项目根目录中新建tsconfig.json文件，并填入以下内容，以便支持console.log的打印： { \"compilerOptions\": { \"lib\": [ \"es6\", \"dom\", ], } } 使用ts-node运行ts文件： $ ts-node yourTypeScriptFilePath.ts Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:48 "},"前端专栏/TypeScript/类型相关.html":{"url":"前端专栏/TypeScript/类型相关.html","title":"类型相关","keywords":"","body":"类型声明 类型声明是静态语言的一大特性，同时也是TypeScript优于JavaScript最重要的一个点。 我们都知道，JavaScript是动态类型的语言，所谓动态就是指变量的类型是不确定的，是根据值的变化而变化的。 如果将变量比作一个房间，值比作一个人，那么就会出现一个很形象的比喻： JavaScript中的房间本身是没有任何限制的，不管是男生还是女生都可以入住，因此房间的属性是随入驻人员的性别变化而变化的 TypeScript中的房间是有限制的，如一个房间只能让女生住或者让男生住，因此房间在一开始投入使用时就有了严格的规范，不会根据入驻人员性别变化而变化 在TypeScript中，如何声明一个变量的类型？语法如下： let 变量 : 类型; // 仅声明 let 变量 : 类型 = 值; // 声明并赋值 这两者非常常用，如下所示我们声明了一个变量，它必须存入boolean类型的值： let bool: boolean; bool = true; 若后续值发生改变，新的值也必须是boolean类型，否则将出现编译错误： let bool: boolean; bool = \"string\"; // error TS2322: Type 'string' is not assignable to type 'boolean'. 基本类型 boolean 1）使用boolean定义一个布尔类型的变量，它只能存储boolean类型的值： let bool: boolean; bool = true; 2）注意，new Boolean()返回的是一个Boolean对象，并不是一个boolean类型的值，所以编译会出错： let bool: boolean; bool = new Boolean(1); // error TS2322: Type 'Boolean' is not assignable to type 'boolean'. // 'boolean' is a primitive, but 'Boolean' is a wrapper object. Prefer using 'boolean' when possible. 3）直接使用Boolean()是行得通的，因为它会返回一个boolean类型的值： let bool: boolean; bool = Boolean(\"string\"); number 1）使用number定义一个数值类型的变量，它只能存储number类型的值： let binaryLiteral: number = 0b1010; // 二进制 let octalLiteral: number = 0; // 八进制 let decLiteral: number = 10; // 十进制 let hexLiteral: number = 0xf00d; // 十六进制 let notANumber: number = NaN; // 非数字 let infinityNumber: number = Infinity; // 无穷大 let floatNumber: number = 3.14; // 浮点数 2）注意，new Number()返回的是一个Number对象，并不是一个number类型的值，所以编译会出错： let binaryLiteral: number = new Number(0b1010); // error TS2322: Type 'Number' is not assignable to type 'number'. // 'number' is a primitive, but 'Number' is a wrapper object. Prefer using 'number' when possible. 3）直接使用Number()是行得通的，因为它会返回一个number类型的值： let binaryLiteral: number = Number(\"0b1010\"); string 1）使用string定义一个字符串类型的变量，它只能存储string类型的值：： // 普通字符串 let userName: string = \"Jack\"; let userAge: number = 25; // 模板字符串 let userMessage: string = `my name is ${userName}\\nmy years old is${userAge}`; 2）注意，new String()返回的是一个String对象，并不是一个string类型的值，所以编译会出错： let userName: string = new String(\"Jack\"); // error TS2322: Type 'String' is not assignable to type 'string'. // 'string' is a primitive, but 'String' is a wrapper object. Prefer using 'string' when possible. 3）直接使用String()是行得通的，因为它会返回一个string类型的值： let userName: string = String([\"Jack\"]); null和undefined 1）使用null或者undefined定义空的、未表示的变量： let u: undefined = undefined; let n: null = null; 2）null和undefined是所有类型的子类型，也就是说这2种类型的值可以赋给任意类型的变量，这样做并不会产生编译错误： let u: number = undefined; let n: string = null; 引用类型 Array JavaScript中的数组能够存入任意类型的值，这在实际开发中是很少用到的，它可能降低数组的查找性能。 因此TypeScript中规定了数组在使用时，仅能存入同一个类型的值。 1）通过类型+方括号的形式来表示一个数组： let numberAry: number[]; numberAry = [1, 2, 3, 4, 5]; let strAry: string[]; strAry = [\"A\", \"B\", \"C\", \"D\"]; 2）我们也可以使用数组泛型（Array geneic）的形式来表示一个数组： let numberAry: Array; numberAry = [1, 2, 3, 4, 5]; let strAry: Array; strAry = [\"A\", \"B\", \"C\", \"D\"]; 3）下面是二维数组的表示： let ary: Array; ary = [[1, 2, 3], [4, 5, 6]]; let ary2:number[][]; ary2 = [[1, 2, 3], [4, 5, 6]]; 函数 JavaScript中函数形参数量和实参传入数量是没有任何限制的，你可以少传参数、也可以多传参数，这在TypeScript中是绝对不允许的。 1）TypeScript中允许对函数参数和返回值做出限制，如下所示，x和y所接收的参数必须是number类型，并且将返回一个number类型： function func(x: number, y: number): number { return x + y } 2）TypeScript中还可以使用函数表达式形式来表示一个函数，如下所示，注意不要将其与ES6中的箭头函数搞混了，=>number指的是该函数必须返回一个number类型： let func: (x: number, y: number) => number = function (x, y) { return x + y }; 3）有一些参数我们不确定需不需要每次都必须传递，因此可以在该参数后面加上?号，代表可选参数，可选参数必须在位置参数的后面： function func(x: number, y: number, z?: number): number { return z ? x + y + z : x + y } console.log(func(11, 22)); console.log(func(11, 22, 33)); // 33 // 66 4）ES6中的默认参数在TypeScript中依旧被支持，如下所示： function func(x: number, y: number, z: number = 33): number { return x + y + z } console.log(func(11, 22)); console.log(func(11, 22, 44)); // 66 // 77 5）ES6中的…扩展参数在TypeScript中也依旧被支持，如下所示： // 注意，args将是一个数组 function func(x: number, y: number, ...args: any[]): string { return `x : ${x}\\ny : ${y}\\nargs : ${args}` } console.log(func(1, 2, \"A\", \"B\", \"C\")); // x : 1 // y : 2 // args : A,B,C 对象 TypeScript中的对象用{}来进行表示，你可以规定对象中属性的名称以及属性值的类型。 1）使用{}定义对象，该对象中必须包含属性userName、userAge、getInfo： let userObject: { userName: string, userAge: number, getInfo: () => string }; userObject = { userName: \"Jack\", userAge: 18, getInfo: function() { return `name : ${this.userName}\\nage : ${this.userAge}` } } console.log(userObject.getInfo()); // name : Jack // age : 18 2）一些属性并不是必须要包含的，可以使用?将其变为可选： let userObject: { userName: string, userAge: number, hobby?: string[] }; userObject = {userName : \"Jack\", userAge : 19, hobby : [\"Basketball\", \"Football\", \"Volleyball\"]}; userObject = {userName : \"Ken\", userAge : 18}; 3）某些时候我们不确定一个对象中有哪些属性，因此可以使用[attrName: string] : any来表示所有出现的属性，其中[attrName: string]代表可以出现无限多的属性、any代表这些可能会出现的属性的值可以是任意类型： // 必须包含userName和userAge属性、其他的属性随意 let userObject: { userName: string, userAge: number, [attrName: string]: any }; userObject = { userName: \"Jack\", userAge: 19, gender: 1, city: \"BeiJing\" }; userObject = { userName: \"Ken\", userAge: 18 }; 4）使用readonly来定义只读属性，只读属性一经赋值后便不允许再次更改： let userObject: { userName: string, userAge: number, readonly userGender : string }; userObject = { userName: \"Jack\", userAge: 19, userGender: \"male\"}; userObject.userGender = \"female\"; // error TS2540: Cannot assign to 'userGender' because it is a read-only property. TypeScript独有类型 any any可以定义一个允许存储任意类型的变量，后续该变量在修改值时即使类型不同也不会出现编译错误。 1）定义一个能够存储任意类型的数组： let ary: any[] = [1, \"A\", new Map([[\"k1\", \"v1\"], [\"k2\", \"v2\"]])]; 2）变量如果在声明时未指定类型，它将默认识别为any类型： let o; o = 1; o = \"string\"; // 等价于 let o: any; o = 1; o = \"string\"; 3）o的类型是any，它可以将值间接赋给其他任意类型的变量： let o: any = 1; let s: string = o; console.log(s); console.log(typeof s); // 1 // number unknown unknown代表是存储了未知值类型的变量，后续修改值时即使类型不同也不会出现编译错误。但是一个unknown类型的变量不支持间接将值赋给其他类型的变量。 1）unknown同any类似，可以存储任意类型的值，并不会出现编译错误的情况： let un: unknown; un = 1; un = \"string\"; un = function (x: number, y: number): number { return x + y }; 2）但它不允许进行间接赋值操作，而any是允许的，故可以将unknown认为是一个安全的any，： let un: unknown = 1; let s: string = un; // error TS2322: Type 'unknown' is not assignable to type 'string'. union types 联合类型（Union types）代表该变量可被赋予众多选项类型或值中的任意一种。 1）多种类型的设置、使用|分割每种待选的类型： let sn: number | string; sn = 1; sn = \"string\"; 2）多种值的设置、使用|分割每个待选的值（不建议使用，更推荐使用enum枚举）： let gender: \"male\" | \"female\"; gender = \"male\"; gender = \"female\"; enum 枚举（Enum）代表了一种类型，该类型提供了众多值可供用户选择。 1）基本的使用，枚举类型中的值总是从0开始计数： enum Gender { male, // 0 female, // 1 unknown, // 2 } let userMessage: { userName: string, userAge: number, userGender: Gender }; userMessage = { userName: \"Jack\", userAge: 18, userGender: Gender.male }; // userGender = 0 console.log(userMessage); // { userName: 'Jack', userAge: 18, userGender: 0 } 2）自定义枚举类型中的生成值，如1男2女3未知更符合大多数人的思维： enum Gender { male = 1, female = 2, unknown = 3, } let userMessage: { userName: string, userAge: number, userGender: Gender }; userMessage = { userName: \"Jack\", userAge: 18, userGender: Gender.male }; // userGender = 1 console.log(userMessage); // { userName: 'Jack', userAge: 18, userGender: 1 } 3）枚举类型的实现原理，以下是经过编译后的JavaScript文件： var Gender; (function (Gender) { Gender[Gender[\"male\"] = 1] = \"male\"; Gender[Gender[\"female\"] = 2] = \"female\"; Gender[Gender[\"unknown\"] = 3] = \"unknown\"; })(Gender || (Gender = {})); var userMessage; userMessage = { userName: \"Jack\", userAge: 18, userGender: Gender.male }; // userGender = 1 console.log(userMessage); /* Gender： { '1': 'male', '2': 'female', '3': 'unknown', male: 1, female: 2, unknown: 3 } */ void void代表一个必须存储空值的变量，该变量仅能存储null和undefined。 void常用于表示一个没有返回值的函数： function func(ary: string[]): void { for (let i = 65; i never never代表一个永远没有值的变量，该变量不能存储任何值。 never常用于表示一个绝对会抛出异常的函数： function func(): never { throw new Error(\"error\"); } func(); tuple TypeScript中的数组中通常只会存放一种类型，并且数组的长度不是固定的。 而元组（Tuple）可以存放多种类型，且在定义时长度必须固定，后续不可进行修改，你可以理解为元组是一个不可变的数组，这句话不适用于Python但非常适用于TypeScript。 1）通过方括号包裹类型的形式来表示一个元组： let tpl: [number, string, number]; tpl = [1, \"string\", -1]; 2）不建议对元组使用push()等方法，虽然说这样是可行的但违背了元组这个数据类型出现的初衷。当push()时，元组定义的类型将变更为联合类型，这意味着你只能push()进number或者string类型的值： let tpl: [number, string, number]; tpl = [1, \"string\", -1]; // 不建议对元组进行修改 tpl.push(...[\"A\", \"B\", \"C\"]); console.log(tpl); // [ 1, 'string', -1, 'A', 'B', 'C' ] 其他知识 类型推导 如果一个变量在定义时没有指定类型，但是赋值了，TypeScript会自动对其进行类型推导： let ary = [1, 2, 3]; // 等价于 // let ary: array = [1, 2, 3]; console.log(ary instanceof Array); // true 注意与any的区别，any是在变量定义时没有指定类型并且没有赋值的时候才会出现： let o; // 等价于 // let o: any; o = 1; o = \"string\"; 类型断言 类型断言常用于联合类型或者any类型的判定中，在某些时候我们需要判断这个变量的具体类型时就可以使用类型断言。 使用方式是 变量 as 类型，如果断言不准确将会抛出异常，如果断言准确将会返回1，如下所示： let x: number | string; x = 1; x as number; // 会执行 console.log(\"x typeof number!\"); 如果类型断言不准确，将会抛出异常： let x: number | string; x = 1; x as string; // error TS2352: Conversion of type 'number' to type 'string' may be a mistake because neither type sufficiently overlaps with the other. If this was intentional, convert the expression to 'unknown' first. // 不会执行 console.log(\"x typeof number!\"); 注意，如果断言一个变量类型是any或者unknown，那么它将永远是成功的： let x: number | string; x = 1; x as any; console.log(\"x typeof any !\"); x as unknown; console.log(\"x typeof unknown !\"); x as string; // 不执行 console.log(\"x typeof string !\"); 类型别名 使用type为类型取一个别名，这样做方便了重复定义相同类型的变量： // 二维数组 type TwoDimensionArray = Array; let ary1: TwoDimensionArray; // 实际上就是指向 Array; ary1 = [[1, 2, 3], [4, 5, 6]]; let ary2: TwoDimensionArray; ary2 = [[7, 8, 9], [10, 11, 12]]; 内置对象 ECMAScript中提供的内置对象在TypeScript中也是支持定义的。 如：Boolean对象，Error对象、Date对象、RegExp对象等： let b: Boolean = new Boolean(1); let e: Error = new Error('Error occurred'); let d: Date = new Date(); let r: RegExp = /[a-z]/; 更多的内置对象，可以查看 MDN 的文档。 而他们的定义文件，则在 TypeScript 核心库的定义文件中。 除此之外，DOM和BOM中提供的内置对象在TypeScript中也是能够进行定义的。 如：document、HTMLElement、Event、NodeList、HTMLCollection等： let body: HTMLElement = document.body; let allDiv: NodeList = document.querySelectorAll('div'); document.addEventListener('click', function(e: MouseEvent) { // Do something }); Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:48 "},"前端专栏/TypeScript/配置文件.html":{"url":"前端专栏/TypeScript/配置文件.html","title":"配置文件","keywords":"","body":"项目目录 一个最基本的TypeScript项目，应当包含2个目录与一个文件： ./TypeScript/ ├── dist ├── src └── tsconfig.json dist：存放编译后的JavaScript脚本文件 src：存放源代码TypeScript脚本文件 tsconfig.json：存放TypeScript编译时所采用的配置文件 tsc编译命令 获取帮助 使用tsc --help命令获取帮助。以下例举常用选项： --init：在当前目录下自动创建一个tsconfig.json文件 -h：获得tsc命令的帮助信息 -w：观察被输入的ts文件，当有内容变更时它将自动完成编译 -v：打印编译器的版本信息 整个tsc命令可跟上的可选参数非常多，但这些参数我们都可以将它配置在tsconfig.json文件中，避免每次需要编译时的重复输入。 编译单个文件 在项目中使用以下命令来编译单个文件： $ tsc ./src/fileName.ts 编译完成后的js文件会位于被编译的ts文件目录下，也就是src目录中： ./TypeScript/ ├── dist ├── src │ ├── demo1.js │ └── demo1.ts └── tsconfig.json 编译整个项目 若直接使用tsc命令，它将编译该项目中所有的ts文件。 $ tsc 编译完成后的js文件会位于被编译的ts文件目录下，也就是src目录中： ./TypeScript/ ├── dist ├── src │ ├── demo1.js │ ├── demo1.ts │ ├── demo2.js │ ├── demo2.ts │ ├── demo3.js │ └── demo3.ts └── tsconfig.json 自动进行编译 如果你使用了tsc -w命令，它将开始检测当前项目中所有ts文件内容的改动，若有ts文件内容发生变更则将自动的进行编译。 $ tsc -w tsconfig.json 基本介绍 tsconfig.json是TypeScript文件在使用tsc命令编译时所依赖的配置文件。 它的内容格式为JSON，但是这个JSON格式文件中可以利用//来输入注释，这是与其他的JSON配置文件不同的地方。 我们可以在项目根目录下使用tsc --init命令来生成该文件，或者你可以选择手动创建该文件。 以下是我自己的配置文件，在下面会对配置项进行详细说明： { \"include\": [ \"./src/**/*\", // 仅编译src目录下的所有ts文件 ], \"exclude\": [ \"./src/test/**/*\", // 不编译src目录中test目录下所有的ts文件 ], \"compilerOptions\": { \"target\": \"ES6\", // 编译后生成的js版本为es6 \"module\": \"ES6\", // 模块使用规范为es6 \"lib\": [ // node环境中测试ts代码所需要使用的库 \"ES6\", \"DOM\" ], \"outDir\": \"./dist\", // 编译后生成的js文件存放路径 \"allowJs\": true, // 二次编译js文件 \"checkJs\": true, // 验证js文件语法 \"removeComments\": false, // 编译后的js文件删除注释信息 \"noEmitOnError\": true, // 如果编译时出现错误，编译将终止 \"strict\": true, // 启用TypeScript的严格模式 \"alwaysStrict\": true, // 启用JavaScript的严格模式 \"noFallthroughCasesInSwitch\": true, // 检测switch语句块是否正确的使用了break \"noImplicitReturns\": true, // 检测函数是否具有隐式的返回值 \"noUnusedLocals\": false, // 检测是否具有未使用的局部变量 \"noUnusedParameters\": false, // 检测是否具有未使用的函数参数 \"allowUnreachableCode\": true, // 检测是否具有永远不会运行的代码 } } 如果你想查看官方的说明，请移步官方文档 include 一级配置项，include。 在直接使用tsc命令编译整个项目的ts文件时，默认会将该项目下所有的以ts为后缀名的文件进行编译。 若指定了include，那么tsc命令则只编译指定目录下的ts文件： { \"include\": [ \"./src/**/*\", // 可跟上多个路径 ], } 默认：当前路径下所有的文件 **/* 路径：**代指所有目录，*代指所有文件 exclude 一级配置项，exclude。 指定不会被编译的文件目录： { \"exclude\": [ \"./src/test/**/*\", // 可跟上多个路径 ], } 默认值： [\"node_modules\", \"bower_components\", \"jspm_packages\", \"./dist\"] extends 一级配置项，extends。 使该配置文件继承某个配置文件中的配置项，一般情况下不会用到： { // \"extends\": \"/configs/base\", } files 一级配置项，files。 只编译指定的文件，只有在需要编译的文件较少时才会用到，一般情况下不会用到： { \"files\": [ \"./src/demo1.ts\", \"./src/demo2.ts\", ], } compilerOptions 一级配置项，compilerOptions。 它可以来指定编译器的选项，比如编译器编译后的js文件版本、编译器编译时所使用的模块化规范等等。 target 二级配置项，位于compilerOptions中。 用于指定ts文件编译为那个版本的js文件： { \"compilerOptions\": { \"target\": \"ES3\", } } 默认是ES3，你可以对其进行指定： \"ES3\", \"ES5\", \"ES6\", \"ES2015\", \"ES2016\", \"ES2017\", \"ES2018\", \"ES2019\", \"ES2020\", \"ES2021\", \"ESNext\" 释义： ES3：默认 ESNext：总是为最新的ECMAScript版本 module 二级配置项，位于compilerOptions中。 用于指定需要使用的模块化规范： { \"compilerOptions\": { \"module\": \"ES6\", } } 你可以指定的值如下所示： \"CommonJS\", \"AMD\", \"System\", \"UMD\", \"ES6\", \"ES2015\", \"ES2020\", \"ESNext\", \"None\" 推荐使用，ES6。 lib 二级配置项，位于compilerOptions中。 用于指定需要在项目中使用到的库： { \"compilerOptions\": { \"lib\": [ \"ES6\", \"DOM\" ], } } 一般情况下，如果在浏览器中直接进行代码测试的话，该配置项可以不选。 如果在node环境下，如在ts-node中进行代码测试时，通常需要指定加载DOM库，因为console系列的函数，包括document等都是由DOM库进行提供的，浏览器环境下这些库是内置的，而在node环境中，则没有这些库，所以需要我们手动加载。 outDir 二级配置项，位于compilerOptions中。 用于指定编译后文件所在的目录： { \"compilerOptions\": { \"outDir\": \"./dist\", } } 默认情况下编译后生成的js文件会和被编译的ts文件在同一个目录中，这是十分不理想的，而通过outDir的配置，能够让我们的项目层次结构更加分明，管理更加方便。 outFile 二级配置项，位于compilerOptions中。 用于指定将所有ts全局作用域下的代码编译到一个js文件中，默认是false： { \"compilerOptions\": { \"outFile\": \"./dist/all.js\", } } 如果配置了该选项，那么多个ts文件的代码会同时合并到一个js文件中，通常我们并不会这样进行设置。因为它可能导致一些意外情况的发生。 allowJs 二级配置项，位于compilerOptions中。 是否对js文件进行二次编译？默认为false： { \"compilerOptions\": { \"allowJs\": false, } } 也就是说，如果你没有写ts文件而是写了一个js文件，是否还需要重新生成一个js文件到指定的outDir目录中去？ 保持默认值即可。 checkJs 二级配置项，位于compilerOptions中。 检查js代码是否符合规范？默认为false： { \"compilerOptions\": { \"checkJs\": true, } } 建议修改为true。 removeComments 二级配置项，位于compilerOptions中。 是否在编译后的js文件中移除ts文件中的注释？默认为false： { \"compilerOptions\": { \"removeComments\": false, } } noEmit 二级配置项，位于compilerOptions中。 在编译完成后，需要禁止生成js文件吗？默认为false： { \"compilerOptions\": { \"noEmit\": false, } } 如果修改为true，则代表编译时仅验证ts语法是否正确，常用于测试中，不建议对其进行修改。 noEmitOnError 二级配置项，位于compilerOptions中。 在编译时，如果遇到错误，需要禁止生成js文件吗？默认为false： { \"compilerOptions\": { \"noEmitOnError\": true, } } 建议修改为true，也就是说你的ts代码有问题时将不会生成js文件。 strict 二级配置项，位于compilerOptions中。 是否采用TypeScript中的严格模式，如果为true，它将意味着alwaysStrict、noImplicitAny、noImplicitThis、strictNullChecks、strictBindCallApply、strictFunctionTypes、strictPropertyInitialization这些配置项均设置为true。 { \"compilerOptions\": { \"strict\": true, } } 推荐修改为true，良好的编码习惯是一个优秀的程序工程师所具备的基本素养。 alwaysStrict 二级配置项，位于compilerOptions中。 编译后的js文件是否开启严格模式？默认为false： { \"compilerOptions\": { \"alwaysStrict\": true, } } 推荐修改为true。 noImplicitAny 是否不允许ts代码中出现隐式的any类型？默认为false： { \"compilerOptions\": { \"noImplicitAny\": true, } } 推荐修改为true。 noImplicitThis 是否不允许ts代码中出现隐式的this使用？默认为false： { \"compilerOptions\": { \"noImplicitThis\": true, } } 推荐修改为true。 strictNullChecks 是否严格的检查ts代码中所出现的空值？默认为false： { \"compilerOptions\": { \"strictNullChecks\": true, } } 推荐修改为true。 strictFunctionTypes 是否严格的检查ts代码中函数类型？默认为false： { \"compilerOptions\": { \"strictFunctionTypes\": true, } } 推荐修改为true。 strictBindCallApply 是否严格的检查ts代码中bind、call和apply的参数列表？默认为false： { \"compilerOptions\": { \"strictBindCallApply\": true, } } 推荐修改为true。 strictPropertyInitialization 是否严格的检查ts代码中属性是否初始化？默认为false： { \"compilerOptions\": { \"strictPropertyInitialization\": true, } } 推荐修改为true。 noFallthroughCasesInSwitch 是否检查ts代码中switch是否包含了正确的break？默认为false： { \"compilerOptions\": { \"noFallthroughCasesInSwitch\": true, } } 推荐修改为true。 noImplicitReturns 是否检查ts代码中函数是否具有隐式的返回值？默认为false： { \"compilerOptions\": { \"noImplicitReturns\": true, } } 推荐修改为true。 noUnusedLocals 是否检查ts代码中具有未使用的局部变量？默认为false： { \"compilerOptions\": { \"noUnusedLocals\": true, } } 推荐修改为true。 noUnusedParameters 是否检查ts代码中具有未使用的函数参数？默认为false： { \"compilerOptions\": { \"noUnusedParameters\": true, } } 推荐修改为true。 allowUnreachableCode 是否检查ts代码中具有永远运行不到的代码？默认为false，它将忽略不可达的代码，如果为true时，不可达代码将引起异常： { \"compilerOptions\": { \"allowUnreachableCode\": true, } } 推荐修改为true。 allowSyntheticDefaultImports 允许对不包含默认导出的模块使用默认导入。这个选项不会影响生成的代码，只会影响类型检查。 { \"compilerOptions\": { \"allowSyntheticDefaultImports\": false, } } 默认是false，不建议进行修改。 这个选项很有意思，在ts中如果你要导入CommonJs的模块，向下面这样导入是最符合语法规范的： // CommonJs const http = require(\"http\") // EsMoudle import * as http from \"http\" 如果它为true，你可以直接这样进行导入： import http from \"http\" Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:48 "},"前端专栏/TypeScript/面向对象.html":{"url":"前端专栏/TypeScript/面向对象.html","title":"面向对象","keywords":"","body":"class 类的定义 我们直接开始介绍TypeScript中关于类的定义，其实它和JavaScript中差不多但是有一些差别。 我们先看JavaScript中的代码示例： \"use strict\"; class Person { constructor(name, age, gender) { this.name = name; this.age = age; this.gender = gender; } } 而TypeScript中由于变量具有类型，故在声明实例属性前必须先进行类型声明： enum UserGender { male = 1, female = 2, unknown = 3 } class Person { // 类型声明 public name: string; public age: number; public gender: UserGender; constructor(name: string, age: number, gender: UserGender) { this.name = name; this.age = age; this.gender = gender; } } public 公开属性 public指不受保护的、公开的属性。类的内部或外部及其子类均可访问或者修改该属性。 默认所有的属性都是public，使用public关键字定义公开属性即可，或者也可以不写： enum UserGender { male = 1, female = 2, unknown = 3 } class Person { // public可以不写，但是建议还是写上 public name: string; public age: number; public gender: UserGender; constructor(name: string, age: number, gender: UserGender) { this.name = name; this.age = age; this.gender = gender; } getInfo(): string { // ❶ 类的内部可以进行访问，也可以进行修改 return `name : ${this.name}\\nage : ${this.age}\\ngender : ${this.gender}` } setAge(age: number): void { this.age = age; } } let person = new Person(\"Jack\", 18, UserGender.male); // ❷ 类的外部也可以进行访问和修改 console.log(person.getInfo()); person.setAge(22); person.name = \"--Jack--\"; console.log(person.name); // ❸ 被继承的子类中也可以进行访问和修改 class Child extends Person { constructor(name: string, age: number, gender: UserGender) { super(name, age, gender) this.name = \"Mary\"; // 可以访问和修改 } } let child = new Child(\"Tom\", 12, UserGender.male); console.log(child.getInfo()); private 绝对私有 private指受保护的、私有的属性。仅能在当前类的内部访问或修改，外部的访问和修改是做不到的，但可通过类内部暴露的接口方法进行访问。 private属性经常与属性代理一起使用，使用private关键字定义私有属性即可： enum UserGender { male = 1, female = 2, unknown = 3 } class Person { // private必须写上 private name: string; private age: number; private gender: UserGender; constructor(name: string, age: number, gender: UserGender) { this.name = name; this.age = age; this.gender = gender; } getInfo(): string { // ❶ 类的内部可以进行访问，也可以进行修改 return `name : ${this.name}\\nage : ${this.age}\\ngender : ${this.gender}` } setAge(age: number): void { this.age = age; } } let person = new Person(\"Jack\", 18, UserGender.male); // ❷ 类的外部仅能通过类内部暴露的接口方法访问，直接访问是访问不到的 console.log(person.getInfo()); person.setAge(22); // person.name = \"--Jack--\"; // console.log(person.name); // ❸ 被继承的子类中不能进行访问和修改，但可以通过类内部暴露的接口方法进行访问和修改 class Child extends Person { constructor(name: string, age: number, gender: UserGender) { super(name, age, gender) // this.name = \"Mary\"; // 不可以访问和修改 抛出异常 } } let child = new Child(\"Tom\", 12, UserGender.male); console.log(child.getInfo()); child.setAge(10); protected 半私有的 protected是指受保护的，半私有的属性。仅能在类的内部访问和修改，外部的访问和修改是做不到的，但它允许在子类中进行访问和修改。 使用protected关键字定义半私有属性即可，注意半私有属性我们一般都会在它前面加上一个单下划线，表明这是一个半私有属性： enum UserGender { male = 1, female = 2, unknown = 3 } class Person { // protected必须写上 protected _name: string; protected _age: number; protected _gender: UserGender; constructor(name: string, age: number, gender: UserGender) { this._name = name; this._age = age; this._gender = gender; } getInfo(): string { // ❶ 类的内部可以进行访问，也可以进行修改 return `name : ${this._name}\\nage : ${this._age}\\ngender : ${this._gender}` } setAge(age: number): void { this._age = age; } } let person = new Person(\"Jack\", 18, UserGender.male); // ❷ 类的外部仅能通过类内部暴露的接口方法访问和修改，直接访问是访问不到的 console.log(person.getInfo()); person.setAge(22); // person._name = \"--Jack--\"; // console.log(person._name); // ❸ 被继承的子类中可以进行访问和修改 class Child extends Person { constructor(name: string, age: number, gender: UserGender) { super(name, age, gender) this._name = \"Mary\"; // 可以访问和修改 } } let child = new Child(\"Tom\", 12, UserGender.male); console.log(child.getInfo()); child.setAge(10); Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:48 "},"前端专栏/TypeScript/抽象基类.html":{"url":"前端专栏/TypeScript/抽象基类.html","title":"抽象基类","keywords":"","body":"抽象基类 抽象基类（abstract base class）是专门用来被其他类所继承的类，它智能被其他类所继承不能用来创建实例。 抽象基类的作用在于： 约束子类实现，子类必须实现抽象基类中的所有抽象方法才能被实例化，否则将不可被实例化 举个例子，羊（Sheep）和狼（Wolf）都属于哺乳类（Breastfeeding），那么它们都至少具有1个方法名为哺乳（feeding），如果没有该方法，则该类不能被实例化。 其实说白了，抽象基类的作用就是规范子类实现，所以： 抽象基类仅用于被继承，不必对其进行实例化 抽象基类内部方法不必实现 如何使用 我们可以使用abstract关键字定义抽象基类和抽象方法。 抽象方法没有方法实现，只有方法名，且它只能定义在抽象基类中，子类继承抽象基类时抽象方法必须要实现： abstract class Breastfeeding { // 定义抽象方法 abstract feeding(): void; } class Sheep extends Breastfeeding { // 子类必须实现抽象方法 feeding(): string { return \"sheep feeding\"; } } let ins = new Sheep(); console.log(ins.feeding()); Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:48 "},"前端专栏/TypeScript/定义接口.html":{"url":"前端专栏/TypeScript/定义接口.html","title":"定义接口","keywords":"","body":"认识接口 接口（interface）和抽象基类（abstract base class）是非常相似的。 抽象基类的作用是规范子类实现，而接口则是为了规范所有类的实现。 接口是针对所有类的实现的 接口规定了类的用途，举个例子，如果你这个类提供了支付方法和退款方法，那么就可以将其视为一个支付接口类，该类可用作支付功能，否则该类将不能用于支付功能 而抽象基类只是针对子类的实现的 抽象基类规定了子类的形状，你想继承我，就必须拥有我的一些特点，否则就不能算我的子类 接口使用 我们可以使用interface关键字定义一个接口。 定义接口时不需要实现具体的方法逻辑，而是只需要指定方法名即可，属性同理。 在实现接口时，可以使用implements来进行实现。 如下所示： // 定义接口 interface PayInterface { balance: number; // 余额 pay(target: string): void; // 支付 refund(target: string): void; // 退款 } // 实现接口 class OrangePay implements PayInterface { public balance: number; constructor(balance: number) { this.balance = balance; } pay(target: string): void { console.log(`Paying for the ${target}`); } refund(target: string): void { console.log(`Refund for the ${target}`); } } interface & type 接口和类型别名有些相似，接口也可以用来规定对象的属性组成，但是仅针对对象： enum UserGender { male = 1, female = 2, unknown = 3 } interface user { name: string; age: number; gender: UserGender; } let userMessage: user = { name: \"Jack\", age: 19, gender: UserGender.male } 它和类型别名的区别在于，类型别名一次只能定义一个，不能重名，而接口可以重名： enum UserGender { male = 1, female = 2, unknown = 3 } // user01已经定义了，不能在重复定义 type user02 = { name: string; age: number; gender: UserGender; hobby: Array; } // user02是接口，可以重复定义，它相当于将2个接口进行合并 interface user01 { name: string; age: number; gender: UserGender; } interface user01 { hobby: Array; } 个人推荐，对于类的实现使用接口、对于对象的实现使用类型别名。 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:48 "},"前端专栏/TypeScript/泛型介绍.html":{"url":"前端专栏/TypeScript/泛型介绍.html","title":"泛型介绍","keywords":"","body":"什么是泛型 在静态语言中，有一个非常重要的名词叫做泛型（Generic），泛型的意思就是指一个宽泛的类型。 比如我们的函数不确定要接收什么类型的值时，你可能想用any来进行参数接收，那么返回值也必定是any。 此时就会造成一个问题，使用者不明白这个返回的any到底是什么类型，any表示的范围太宽了，如下图所示，它的返回结果依旧还是any： 我们更想需要的是传入一个什么类型，就返回一个什么类型，但是返回的这个类型不是固定的，而是按照传入的参数类型变化而变化。 这个时候我们就可以使用泛型，泛型的定义如下所示，你需要为这个范围的类型取一个名字，如\\，那么返回值也必然是T： 泛型函数 定义泛型函数，你可以同时指定多个泛型，如下所示，当随机数为2时返回x，当随机数为1时返回y： function func(x: T, y: K): T | K { let n = Math.floor(Math.random() * 2) + 1; console.log(n); if (n == 2) { return x; } else { return y; } } 使用的时候，你可以不传入指定类型，而是让TypeScript编译器自动进行类型推导： let result = func(1, \"A\"); 更加推荐在使用时传入类型，这样在后期代码维护时更加的方便： let result = func(1, \"A\"); 泛型类 在类中也同样可以使用泛型，如下所示： class Demo{ public attribute: T; public property: K; constructor(attribute: T, property: K) { this.attribute = attribute; this.property = property; } } let ins1 = new Demo(100, []); let ins2 = new Demo(\"??\", {}); 泛型约束 除此之外，泛型也可以对具体类型进行严格的约束。 如下所示，泛型函数func collection必须传入一个具有length属性的对象： interface ContainerInterface { length: number; [key: string]: any } // 泛型T继承ContainerInterface接口，要求必须具有length属性 function Iterative(container: T): any[] { let ary = []; for (let i: number = 0; i ([\"A\", \"B\", \"C\"])); console.log(Iterative(document.querySelectorAll(\"main\"))); console.log(Iterative(document.getElementsByTagName(\"div\"))); 如果你传入了一个没有length属性的对象，它将引发错误： Iterative>(new Map([[\"k1\", \"v1\"], [\"k2\", \"v2\"]])) // 类型“Map”不满足约束“ContainerInterface”。 // 类型\"Map\"中缺少属性 \"length\"，但类型 \"ContainerInterface\" 中需要该属性 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:48 "},"前端专栏/Node.js/summary.html":{"url":"前端专栏/Node.js/summary.html","title":"Node.js","keywords":"","body":" 基础介绍 模块系统 包管理器 Ts+Node process 事件操作 定时器 路径处理 文件操作 Buffer Stream Web开发 Koa框架 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:48 "},"前端专栏/Node.js/基础介绍.html":{"url":"前端专栏/Node.js/基础介绍.html","title":"基础介绍","keywords":"","body":"基础介绍 语言介绍 Node.js是一个开源、跨平台的JavaScript运行环境，它使得JavaScript能够脱离浏览器自主运行，其本质是依赖了Chrome V8引擎而实现的。 此外，Node.js能够十分快速的编写出高效的WEB服务器，得益于事件驱动I/O模型，Node.js天然支持异步I/O。 Node.js学习简单、上手迅速，如果你掌握了JavaScript，并且想使用JavaScript语言搭建WEB服务器，那么Node.js是一个不错的选择。 官方文档 发展历史 Node.js于2009年5月发布初始版本，至今只有短短的12年，相比之下JavaScript已经存在了24年，而WEB则已经存在了31年。 以下是发展历史大纲： 2009：Node.js诞生 2010：Express诞生（Node.js中一款WEB框架）、Socket.io诞生 2011：npm发布1.0版本、hapi诞生（Node.js中一款WEB框架） 2012：Node.js开始大范围普及、KOA诞生（Node.js中一款WEB框架，通常将它视为Express的升级版，它支持了ES6语法中的async和await实现异步编程） 2013：第一个使用Node.js的大型博客平台Ghost上线 2014：Node.js的一个大分支，io.js诞生 2015：io.js重新合并会Node.js，同年Node.js 4发布（此前1、2、3版本均未发布）、Node.js基金会诞生 2016：yarn诞生（新的Node.js包管理工具、它意在解决npm所出现的问题），同年Node.js 6发布 2017：Node.js 8发布 2018：Node.js 10、11相继发布 2019：Node.js 12、13相继发布 2020：Node.js 14、15相继发布 2021：Node的版本先已更新到 Node.js 16 区别异同 由于Node.js独立于浏览器运行JavaScript代码，所以他没有浏览器所提供的document、window等对象。 Node.js作为后端使用的JavaScript，它必须支持链接数据库、文件读写操作等功能，这在前端是不被支持的。 Node.js始终与ECMAScrip保持一致，这意味着你可以在Node.js中书写ES6-7-8-9的代码。 但是Node.js中的模块使用CommonJs标准，这与在浏览器中使用的ES6模块标准不同，今后会有详细介绍。 除此之外，它与前端的JavaScript代码编写并无太大差异。 v8引擎 V8是Chrome为了支持JavaScript所开发的引擎名称，当使用Chrome浏览网页时，它将负责处理并执行JavaScript。 V8提供了执行JavaScript的运行时环境，DOM和其他WEB平台的API则由浏览器进行提供。 很酷的是，JavaScript引擎独立于托管它的浏览器。此关键的特性推动了Node.js的兴起。V8于2009年被选为为Node.js提供支持的引擎，并且随着Node.js的爆炸性发展，V8成为了现在为大量的服务器端代码（使用JavaScript编写）提供支持的引擎。 Node.js的生态系统非常庞大，得益于此，V8还为桌面应用程序（通过Electron等项目）提供支持。 其他浏览器也有自己的JavaScript引擎： Firefox具有SpiderMonkey Safari具有JavaScriptCore（又称为Nitro） Edge最初基于Chakra，但最近使用Chromium和V8引擎进行了重建。 还有很多其他的。 所有这些引擎都实现了ECMA ES-262 标准（又称为ECMAScript），这是JavaScript使用的标准。 编译or解释 JavaScript通常被认为是一门解释型的语言，但是现代的JavaScript引擎不再只是解释JavaScript，也会对其进行编译。 这从2009年开始就一直在发生，当时SpiderMonkey JavaScript编译器被添加到Firefox 3.5中，所有人都跟进了这个想法。 JavaScript是由V8在其内部编译的，使用了即时（JIT）编译以加快执行速度。 自2004年Google地图的引入以来，JavaScript已经从一门通常执行几十行代码的语言演变为能在浏览器中运行具有成千上万行代码的完整的应用程序。 现在，应用程序可以在浏览器中运行数小时，而不仅仅是一些表单验证规则或简单的脚本。 在这个新世界中，编译JavaScript非常有意义，因为尽管可能需要多花费一点时间来为JavaScript做准备，但是一旦完成，则它会比纯解释型的代码具有更高的性能。 快速安装 Node.js的安装十分迅速，你可以在官网进行下载。 官方网站 下载完安装包后基本无脑下一步即可，直至安装完成后使用以下代码测试Node.js是否成功安装： $ node -v 如果你和我一样使用MacOS、则可以使用Homebrew进行快速安装，只需在CLI中输入以下命令即可： $ brew install node nvm管理 安装nvm nvm可以更加方便的管理多个版本的Node.js，例如在多版本Node.js共存的情况下，就可使用nvm来快速的切换某一个Node.js。 以下将例举如何使用MacOS安装nvm，首先推荐使用Homebrew进行快速安装： $ brew install nvm 在下载完成后，根据提示，创建nvm文件夹： $ mkdir ~/.nvm 然后将以下内容添加到shell配置文件中，我这里使用的bash，所以添加到.bash_profile： # 导入nvm export NVM_DIR=\"$HOME/.nvm\" [ -s \"/usr/local/opt/nvm/nvm.sh\" ] && . \"/usr/local/opt/nvm/nvm.sh\" # This loads nvm [ -s \"/usr/local/opt/nvm/etc/bash_completion.d/nvm\" ] && . \"/usr/local/opt/nvm/etc/bash_completion.d/nvm\" # This loads nvm bash_completion 刷新配置文件： $ source ~/.bash_profile 使用以下命令测试nvm是否安装成功： $ nvm -v 由于nvm的镜像源在国内，所以下载的过程可能会很慢，推荐修改为国内源： # 修改nvm下载源为taobao镜像源 export NVM_NODEJS_ORG_MIRROR=http://npm.taobao.org/mirrors/node export NVM_IOJS_ORG_MIRROR=http://npm.taobao.org/mirrors/iojs 常用命令 以下是nvm的常用命令： nvm install [version]：下载对应版本的Node.js nvm use [version || name]：切换当前使用的Node.js nvm run [version] [jsfile]：用指定版本的Node.js运行js文件 nvm alias [newname] version：为指定版本的Node.js取一个别名 nvm install node：下载最新版本的Node.js（尝鲜版） nvm use node：切换至最新版本的Node.js（尝鲜版） nvm install --lts：下载最新版本的Node.js（稳定版） nvm use --lts：切换至最新版本的Node.js（稳定版） nvm ls：查看所有已安装的Node.js nvm ls-remote：查看所有可下载的Node.js版本 nvm -v：查看nvm版本 nvm uninstall [version || old oldname]：卸载指定版本的Node.js nvm current：查看当前所使用的Node.js nvm alias default version：设置默认的Node.js 使用示例 现在我们需要下载2个版本的Node.js，最新的稳定版（14.17.5）和10.24.1版本： $ nvm install --lts $ nvm install 10.24.1 下载完成后，查看已安装的Node.js，可以看到当前使用的是14.17.5版本： $ nvm ls v10.24.1 -> v14.17.5 ... 先为这2个版本的Node.js取一个别名： $ nvm alias new 14.17.5 new -> 14.17.5 (-> v14.17.5) $ nvm alias old 10.24.1 old -> 10.24.1 (-> v10.24.1) 切换当前使用的Node.js为10.24.1版本： $ nvm use old Now using node v10.24.1 (npm v6.14.12) 再次切换当前使用的Node.js为14.17.5版本： $ nvm use new Now using node v14.17.5 (npm v6.14.14) 基本使用 node命令 以下例举一些常见的node命令及参数释义： node -v：查看Node.js版本 node -e：直接执行一段JavaScript命令，它不会在前终端中显示命令结果 node -p：直接执行一段JavaScript命令，它将在当前终端中显示命令结果 node -c：检测代码语法，并不执行代码 示例演示： $ node -v v14.17.5 $ node -e \"console.log(1+2)\" 3 $ node -p \"3+2\" 5 其实node -e和node -p的功能都差不多，区别在于一个会打印结果，一个不会打印结果。 若node -e想打印结果，必须加上console.log()。 脚本调用式 书写一个JavaScript脚本，并使用node将其进行执行： $ node file.js 这是一种常用的方式，也是更加推荐使用的方式。 代码交互式 在CLI中输入node，进入REPL交互式环境中： $ node Welcome to Node.js v14.17.5. Type \".help\" for more information. > 它常用于进行一些简单的代码测试，如你想查看JavaScript中Number对象所能够调用的所有属性，可直接输入对象名称加点，然后使用tab键进行补齐： 通过输入global.并按下tab，可以检查可以访问的全局变量： 如果在某些代码之后输入 _，则会打印最后一次操作的结果。 此外，REPL环境下也提供了一系列可以直接.的属性： .help：获取帮助信息 .editor：启用编辑器模式，可以轻松的编写多行JavaScript代码，在此模式下按下crtl+D即可运行编写的代码 .break：当输入多行表达式时、输入.barek命令可终止进一步的输出，相当于按下crtl+C .clear：将REPL上下文重置为空对象，并清除当前正在输入的任何多行的表达式 .load：加载JavaScript文件，相对于当前工作目录 .save：将在 REPL 会话中输入的所有内容保存到文件（需指定文件名） 退出 REPL（相当于按下两次 ctrl-C） vscode模块 为了拥有更良好的编程体验，推荐在vscode上安装以下插件： Node.js Modules Intellisense 图标如下所示： Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:48 "},"前端专栏/Node.js/模块系统.html":{"url":"前端专栏/Node.js/模块系统.html","title":"模块系统","keywords":"","body":"CommonJS 基本介绍 JavaScript这门语言最早是单纯的为网页添加行为功能而问世的，所以在诞生之初并没有模块这一个概念。 到了ES6之后，JavaScript提供了module语法用于组织模块关系。 而在ES6之前，最主要的模块解决方案为CommonJS和AMD两种，由于Node.js的出现早于ES6，故其模块解决方案采用了CommonJs，它主要遵从以下3个原则： 一个文件被视为一个模块、文件内变量的作用域均在模块内 使用module.exports对象导出模块中的功能，对外暴露接口 使用require引入其他模块 在Node.js中，模块文件仅限于： js文件 JSON文件 编译过的C/C++ 扩展文件 除此之外的文件均不被认为是模块文件。 模块分类 在Node.js中模块的分类主要有3大类： 内置模块：Node.js自带的 自定义模块：自己编写的文件 第三方模块：npm命令下载的 Node.js对于内置模块或者第三方模块来说，在导入时并不需要加入任何路径，直接书写模块名即可。 而对于第三方模块而言，在导入时需要加入文件所在路径，除此之外，如果是JSON文件则还需要添加上.json的后缀，而JavaScript脚本文件则不用添加这种后缀。 基本使用 目录展示 以下是代码demo的目录展示： . ├── main.js # 导入模块的文件 ├── moduleJson.json # 自定义模块文件 └── moduleScript.js # 自定义模块文件 module.exports module.exports拥有3种导出模块的方式，如下所示。 1）一个一个的导出： // moduleScript.js let moduleName = __filename; function area(w, h) { return w * h; } module.exports.moduleName = moduleName; module.exports.area = area; 2）使用默认导出，一个模块中只能有一个默认导出： // moduleScript.js module.exports = function area(w, h) { return w * h; } 3）使用多个导出： // moduleScript.js let moduleName = __filename; function area(w, h) { return w * h; } module.exports = { moduleName, area }; 除此之外，你也可以省略module.exports的前缀module，直接使用exports进行导出，但是个人不建议这么做，因为它不支持多个导出的方式，只能支持一个一个导出或者默认导出，如下所示： // moduleScript.js let moduleName = __filename; function area(w, h) { return w * h; } exports.moduleName = moduleName; exports.area = area; 具体原因是因为exports本身指向了module.exports对象，如果将exports赋值了一个新的对象，那么它将和module.exports失去链接关系、而require()则只会导入module.exports对象中的属性。 require 使用require()来导入模块中被导出的功能，它其实是moudle.require()的简写形式，但使用简写形式并不会有任何问题。 1）导入整个模块，针对一个个的导出和多个导出，在使用其下功能时需要加上模块名字： // main.js const m1 = require(\"./moduleScript\"); console.log(m1.area(2, 2)); console.log(m1.moduleName); 2）导入默认导出的功能，直接使用接收的名字对功能进行调用即可，仅针对默认导出： // main.js const area = require(\"./moduleScript\"); console.log(area(2, 2)); 导入JSON 我们先在JSON文件中输入内容： // moduleJson.js { \"userName\": \"Jack\", \"userAge\": \"18\", \"userGender\": \"male\" } 然后在main.js中进行导入： // main.js const userMessage = require(\"./moduleJson.json\"); for (let [k, v] of Object.entries(userMessage)) { console.log(k, \":\", v); } // userName : Jack // userAge : 18 // userGender : male 可以发现，被导入的JSON文件变成了一个Object。 导入内置模块 以下示例将演示如何导入内置模块http，在导入内置模块或者第三方模块时，并不需要输入模块路径： const http = require('http'); const server = http.createServer((request, response) => { response.setHeader('Content-Type', 'application/json'); response.statusCode = 200; response.end(JSON.stringify(request.method === \"GET\" ? \"GET OK!!!\" : \"POST OK!!!\")); }) server.listen(5700, \"localhost\", 256, () => { console.log(\"server running success! http://localhost:3000\"); }); 模块搜索路径 Node.js中每一个文件都是一个模块，模块内的变量均属于局部变量，故不会出现全局变量污染的问题。 在执行模块代码前，Node.js会使用如下的一个函数封装器将模块进行封装： (function(exports, require, module, __filename, __dirname) { // 模块的代码实际上在这里 }); 参数释义： exports：加载其他模块的方法，指向了module.exports对象 require：导出模块功能的方法，执行了module.require对象 module：当前模块的实例 __filename：当前模块文件的绝对路径 __dirname：当前模块文件所在目录的绝对路径 在搜索一个模块时，如果出现多个导入模块同名的情况下，Node.js会优先导入内置或第三方模块。 这与模块的搜索路径有关，它会根据module.paths所提供的路径进行搜索，如下所示： > module.paths [ '/Users/yunya/Project/nodeProject/repl/node_modules', '/Users/yunya/Project/nodeProject/node_modules', '/Users/yunya/Project/node_modules', '/Users/yunya/node_modules', '/Users/node_modules', '/node_modules', '/Users/yunya/.node_modules', '/Users/yunya/.node_libraries', '/Users/yunya/.nvm/versions/node/v14.17.5/lib/node' ] 仔细观察搜索路径，会发现它会按照就近原则进行逐层上溯，直至根目录NODE_PATH中。 然后会额外搜索以下3个目录： $HOME/.node_modules $HOME/.node_libraries $PREFIX/lib/node 其中$HOME是用户的主目录，$PREFIX是 Node.js 里配置的node_prefix。 强烈建议将所有的依赖放在本地的node_modules目录，这样将会更快地加载，且更可靠。 ES6 Module Node.js现已支持ES6 Module语法进行模块管理，主要有2种方式。 1）通过第三方模块babel进行构建，在v12版本以前较为常用： { \"presets\": [ [\"@babel/preset-env\", { \"targets\": { \"node\": \"8.9.0\", \"esmodules\": true } }] ] } 2）直接使用ES6 Module语法，适用于v12版本之后。 需要开启 --experimental-modules 模块名修改为.mjs或者在package.json中设置\"type\": module，推荐使用后者 当设置完成后，Node.js会将所有的js文件当做ES Module进行处理，更多详情参考官方文档 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:48 "},"前端专栏/Node.js/包管理器.html":{"url":"前端专栏/Node.js/包管理器.html","title":"包管理器","keywords":"","body":"基础介绍 npm npm是Node.js中标准的软件包管理器，它类似于Python中的pip，能够更加方便的让我们进行下载和管理第三方模块。 除此之外，Node.js中也提供了Yarn软件包管理器，它作为npm的替代品更加的优秀。但在npm5.0更新之后，两者的差距并不大，开发者可自行选择。 cnpm 由于npm的镜像站是在国外，因此更加推荐安装cnpm来进行第三方模块下载，它采用国内淘宝的镜像源，淘宝镜像源每10分钟便会同步npm镜像源一次，因此速度更快。 你只需要在CIL中输入以下命令即可： $ npm i -g cnpm --registry=https://registry.npm.taobao.org 在下载第三方模块时，只需将npm替换为cnpm命令即可，如： $ cnpm install jquery 不过这里推荐，能用npm的还是尽量用npm，因为cnpm可能会出现某些令人意外的情况，尽管这种概率很小但依然存在。 常用命令 以下是npm的常用命令： 命令 描述 npm -v 查看npm版本 npm i npm -g 更新npm至最新版 npm install 模块名@版本号 本地安装一个模块，若不指定@版本号，则自动安装最新版，若加上-g则是全局安装 npm install 模块1 模块2 模块3 本地安装n个模块，若加上-g则是全局安装 npm uninstall 模块1 模块2 模块3 卸载本地n个模块，若加上-g则是全局卸载 npm uninstall 模块名 卸载本地一个模块，若加上-g则是全局卸载 npm update 模块名@版本号 更新本地一个模块，若不指定@版本号，则自动更新到最新版，若加上-g则是全局更新 npm ls 查询本地已安装的所有模块，若加上-g则是查询全局 npm ls 模块名 查询本地已安装的某个模块信息，若加上-g则是查询全局 npm search 模块名 从镜像站搜索某个模块 npm cache clear --force 清除npm的缓存 npm init 创建一个package.json文件，用于管理项目中多个模块 npm install --save 根据文件package.json下载所有适用于生产环境下的模块，等同于npm install npm install --save-dev 根据文件package.json下载所有适用于开发环境下的模块，等同于npm install -D 安装方式 当使用npm安装第三方模块时，会有2种安装方式： 全局安装 本地安装 默认情况下，当输入npm install命令后它将进行本地安装。 被下载的第三方模块会安装至当前目录树中的node_modules子目录下，如果该目录不存在，将自动进行创建。 除此之外，如果当前目录中存在package.json文件，它还会在package.json文件的dependencies属性中添加lodash条目。 使用-g标志可执行全局安装。 全局安装时，被下载的第三方模块会安装至全局位置中，可使用npm root -g来查看全局安装的位置。 在macOS或Linux上，此位置可能是 /usr/local/lib/node_modules。 在Windows上，可能是C:\\Users\\YOU\\AppData\\Roaming\\npm\\node_modules。 但是，如果使用nvm管理 Node.js 版本，则该位置会有所不同。 例如，使用nvm，则软件包的位置可能为/Users/joe/.nvm/versions/node/v8.9.0/lib/node_modules。 一句话总结，本地安装的第三方模块只有当前项目能使用，而全局安装的第三方模块则所有项目都能使用，如果不是特殊情况，如下载cnpm这种全局可用的模块时，一定要确保使用了本地安装。 package.json 文件作用描述 package.json是当前项目中所依赖第三方模块的清单，除此之外它还是整个项目的管理中心。 你可以在package.json中查看到当前项目下所使用的全部第三方模块、还可以自定义shell命令更加轻松的管理当前项目。 只需要在项目根目录中输入npm init命令，即可在当前目录中生成package.json文件，输入命令后一路回车即可（也可以输入npm init -y命令直接确认），以下是生成的文件内容： { \"name\": \"nodeproject\", \"version\": \"1.0.0\", \"description\": \"\", \"main\": \"main.js\", \"scripts\": { \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\" }, \"author\": \"\", \"license\": \"ISC\" } 文件释义： name：当前项目的名称 version：当前项目的版本 description：当前项目的描述 main：当前项目的入口文件 scripts：当前项目中自定义的npm脚本命令 author：当前项目的作者名称 license：当前项目的许可证 除此之外，它可能还拥有更多的内容： dependencies：生产环境下，该项目运行所依赖的所有模块 devDependencies：开发环境下，该项目运行所依赖的所有模块 engines：当前项目适用于在哪个版本的Node.js中进行运行 contributors：该项目的其他贡献者 keywords：关键字 bugs：链接到当前项目的问题跟踪器，最常用的是 GitHub 的 issues 页面 homepage：当前项目的主页 browserslist：当前项目所支持的浏览器列表，在使用Babel等构建工具时，它将产生作用 生产环境依赖 当直接使用以下命令时，第三方模块安装后将会把lodash信息添加至dependencies属性中： $ npm install jquery bootstrap axios 它相当于在执行命令时加上了--save的后缀： $ npm install jquery bootstrap axios --save 可以看到package.json的dependencies属性已经更新了： \"dependencies\": { \"axios\": \"^0.21.1\", \"bootstrap\": \"^5.1.0\", \"jquery\": \"^3.6.0\" } 当要下载一个项目中所有的用于生产环境的依赖模块时，你只需要在package.json同级目录下执行以下命令即可： $ npm install --save 开发环境依赖 当使用以下命令时，第三方模块安装后将会把lodash信息添加至devDependencies属性中： $ npm install jquery bootstrap axios --save-dev 或者你也可以使用-D的后缀： $ npm install jquery bootstrap axios --D 可以看到package.json的devDependencies属性已经更新了： \"devDependencies\": { \"axios\": \"^0.21.1\", \"bootstrap\": \"^5.1.0\", \"jquery\": \"^3.6.0\" } 当要下载一个项目中所有的用于开发环境的依赖模块时，你只需要在package.json同级目录下执行以下命令即可： $ npm install --save-dev 项目版本规范 任何npm能够下载的第三方模块，实际上都是一个独立的项目。 包括我们自定义的项目，在广义上来说它被称之为包更加合适，当你需要指定项目版本version时需要注意以下一些规则。 所有版本号均有3个数字组成 第一个数字是主版本号 第二个数字是次版本号 第三个数字是补丁版本 package.json中依赖模块版本中夹杂的符号用于在npm install下载时规定下载模块的版本区间，以下是常见符号释义： ^：只能在当前主版本区间中下载依赖模块，如^3.6.0，它不会下载到4.0.0的模块，但支持下载到3.0.0至3.99.9999之间的模块 ~：高低一个补丁号区间，如^3.6.1，它可能下载到^3.6.0或者^3.6.2，但不会下载到4.0.0 >：接受高于指定版本的任何版本 >=：接受等于或高于指定版本的任何版本 =：接受确切的版本 -：接受一定范围的版本。例如：2.1.0 - 2.6.2 ||：组合集合。例如 2.6 npm脚本命令 一般来说，npm脚本由用户提供。但是，npm对两个脚本提供了默认值。也就是说，这两个脚本不用定义，就可以直接使用。 \"start\": \"node server.js\"， \"install\": \"node-gyp rebuild\" 上面代码中，npm run start的默认值是node server.js，前提是项目根目录下有server.js这个脚本；npm run install的默认值是node-gyp rebuild，前提是项目根目录下有binding.gyp文件。 通过package.json中的scripts属性，我们也可以定制一些自定义的npm脚本命令。 如指定一个自定义的npm脚本命令serve： \"scripts\": { \"serve\" : \"node ./main.js\" }, 在CIL中输入npm run serve，它实际上将执行node ./main.js命令： $ npm run serve > nodeproject@1.0.0 serve /Users/yunya/Project/nodeProject > node ./main.js server running localhost:5700 使用npm run，查看所有自定义的脚本命令。 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:48 "},"前端专栏/Node.js/Ts+Node.html":{"url":"前端专栏/Node.js/Ts+Node.html","title":"Ts+Node","keywords":"","body":"基本介绍 TypeScript现在已经开始逐渐的取代JavaScript，因此在我们的后端上也推荐使用TypeScript进行代码编写。 它拥有严格的类型检查，让你的错误能够及时发现，最大限度的规范你的代码。 关于TypeScript的使用，可以查看之前关于TypeScript内容进行学习。 下载安装 下载安装TypeScript： $ npm install typescript 在项目根目录中运行以下命令，生成tsconfig.json： $ tsc --init 填入TypeScript的配置文件： { \"include\": [ \"./src/**/*\", // 仅编译src目录下的所有ts文件 ], \"exclude\": [ \"./src/test/**/*\", // 不编译src目录中test目录下所有的ts文件 ], \"compilerOptions\": { \"target\": \"ES6\", // 编译后生成的js版本为es6 \"module\": \"CommonJS\", // 编译后的模块使用规范为CommonJs \"lib\": [ // node环境中测试ts代码所需要使用的库 \"ES6\" ], \"outDir\": \"./dist\", // 编译后生成的js文件存放路径 \"allowJs\": true, // 二次编译js文件 \"checkJs\": true, // 验证js文件语法 \"removeComments\": false, // 编译后的js文件删除注释信息 \"noEmitOnError\": true, // 如果编译时出现错误，编译将终止 \"strict\": true, // 启用TypeScript的严格模式 \"alwaysStrict\": true, // 启用JavaScript的严格模式 \"noFallthroughCasesInSwitch\": true, // 检测switch语句块是否正确的使用了break \"noImplicitReturns\": true, // 检测函数是否具有隐式的返回值 \"noUnusedLocals\": true, // 检测是否具有未使用的局部变量 \"noUnusedParameters\": true, // 检测是否具有未使用的函数参数 \"allowUnreachableCode\": true, // 检测是否具有永远不会运行的代码 } } 相关依赖 node解释器并不认识TypeScript，我们可以下载一个ts-node，让我们能够更加方便的调试TypeScript代码。 $ npm install ts-node 其次，需要下载一个@types/node，让我们的Node.js在TypeScript中能够支持ES Module语法： $ npm install @types/node 还需要下载3个依赖包： $ npm install peer dependencies yourself 简单使用 项目目录如下： . ├── dist # 存放编译后的JavaScript代码 ├── node_modules │ └── ... ├── package-lock.json ├── package.json ├── src # ts源代码存放目录 │ └── server.ts └── tsconfig.json 此外你还需要对package.json做修改，主要是main和scripts属性： { ... \"main\": \"./dist/server.js\", \"scripts\": { \"serve\": \"node ./dist/server.js\" }, ... } 下面编写一个HTTP服务，注意，我们在利用TypeScript编写代码的时候也将采用ES Module标准，而不是使用CommonJS： import * as http from 'http'; const hostname: string = \"localhost\"; const port: number = 3000; const server: http.Server = http.createServer((request: http.IncomingMessage, response: http.ServerResponse): void => { response.setHeader('Content-Type', 'application/json'); response.statusCode = 200; response.end(JSON.stringify(request.method === \"GET\" ? \"GET OK!!!\" : \"POST OK!!!\")); }); server.listen(port, hostname, (): void => { console.log(`server running success! http://${hostname}:${port}`); }) 在代码编写完成后，使用ts-node命令进行代码测试： $ ts-node ./src/server.ts server running success! http://localhost:3000 代码测试无误后，使用tsc命令将ts文件编译为js文件，编译完成后的js文件将位于dist目录中： $ tsc 由于我们的npm脚本命令serve指向了node ./dist/server.js，故可以直接使用npm run serve来运行服务： $ npm run serve > nodeproject@1.0.0 serve /Users/yunya/Project/nodeProject > node ./dist/server.js server running success! http://localhost:3000 最后可以查看一下编译完成的JavaScript文件，它使用的是CommonJS标准，因为我们已经在tsconfig.json文件中对其进行了配置： \"use strict\"; Object.defineProperty(exports, \"__esModule\", { value: true }); const http = require(\"http\"); const hostname = \"localhost\"; const port = 3000; const server = http.createServer((request, response) => { response.setHeader('Content-Type', 'application/json'); response.statusCode = 200; response.end(JSON.stringify(request.method === \"GET\" ? \"GET OK!!!\" : \"POST OK!!!\")); }); server.listen(port, hostname, () => { console.log(`server running success! http://${hostname}:${port}`); }); Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:48 "},"前端专栏/Node.js/process.html":{"url":"前端专栏/Node.js/process.html","title":"process","keywords":"","body":"process process对象是一个全局变量，同时它也是EventEmitter对象的实例，提供了当前Node.js进程的信息和操作方法。 由于process对象是EventEmitter对象的实例，故可以对其进行事件监听。 常用属性 属性一览 以下是process对象中常用的属性： 属性 描述 title 返回进程名称，默认为node pid 返回进程pid号 platform 返回当前运行进程的操作系统名称 version 返回当前的Node.js版本号 env 返回当前shell中所有的环境变量 execPath 返回执行当前脚本的Node二进制文件的绝对路径 argv 返回从命令行接收到用户输入命令的数组，它包含了执行当前脚本的Node二进制文件的绝对路径以及当前被执行文件的绝对路径 execArgv 如果用户在命令行输入的命令携带了Node.js的内置参数，如--inspect时，那么--inspect将添加到该数组中 argv process.argv属性是一个比较常用的属性。 我们可以在命令行中输入一些参数，并且让JavaScript脚本进行接收。 如下所示： $ npm start localhost:5700 脚本文件： ts-node ./src/server.ts 127.0.0.1:5500 argv数组： [ '/Users/yunya/.nvm/versions/node/v14.17.5/bin/ts-node', '/Users/yunya/Project/nodeProject/src/server.ts', '127.0.0.1:5500' ] 它有什么作用呢？比如我们想由使用者来决定HTTP服务的port和hostname时，它就派上了用处： import * as http from 'http'; const argv: string[] = process.argv.slice(2); const hostname: string = argv.length ? argv[0].split(\":\")[0] : \"localhost\"; const port: number = argv.length ? Number(argv[0].split(\":\")[1]) : 3000; const server: http.Server = http.createServer((request: http.IncomingMessage, response: http.ServerResponse): void => { response.setHeader('Content-Type', 'application/json'); response.statusCode = 200; response.end(JSON.stringify(request.method === \"GET\" ? \"GET OK!!!\" : \"POST OK!!!\")); }); server.listen(port, hostname, (): void => { console.log(`server running success! http://${hostname}:${port}`); }) 常用方法 方法一览 以下是process对象中常用的方法： 方法 描述 chidr() 切换工作目录到指定目录 cwd() 返回当前工作目录 exit() 退出当前进程 memoryUsage() 返回Node.js进程的内存使用情况 进程事件 exit 当Node.js进程因以下原因之一即将退出时，则会触发exit事件： 显式调用process.exit()方法 Node.js事件循环不再需要执行任何其他工作 此时无法阻止退出事件循环，并且一旦所有exit事件的监听器都已完成运行时，Node.js进程将终止 process.on('exit', (code: number) => { console.log(`退出码: ${code}`); }); uncaughtException 当前进程抛出一个没有被捕捉的错误时，会触发uncaughtException事件： process.on('uncaughtException', function (err: NodeJs.ErrnoException) { console.error(err.stack); }); beforeExit 当Node.js清空其事件循环并且没有其他工作要安排时，会触发beforeExit事件。通常Node.js进程将在没有调度工作时退出，但是在beforeExit事件上注册的监听器可以进行异步调用使Node.js进程继续： process.on('beforeExit', (code: number) => { console.log('进程 beforeExit 事件的代码: ', code); }); process.on('exit', (code: number) => { console.log('进程 exit 事件的代码: ', code); }); console.log('此消息最新显示'); // 打印: // 此消息最新显示 // 进程 beforeExit 事件的代码: 0 // 进程 exit 事件的代码: 0 message 如果使用IPC通道fork Node.js进程，子进程收到父进程使用childprocess.send()发送的消息，就会触发message事件： process.on('message', (m: string) => { console.log('子进程收到消息', m); }); process.nextTick(callback) process.nextTick()方法将callback添加到下一个时间点的队列执行。 也就是说它会将一个任务提升为异步微任务。 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:48 "},"前端专栏/Node.js/事件操作.html":{"url":"前端专栏/Node.js/事件操作.html","title":"事件操作","keywords":"","body":"监听事件 监听对象 所有EventEmitter类的实例，均可对其进行事件监听。 on() Node.js中使用on()进行事件监听，如下所示，我们为EventEmitter实例对象ev绑定了一个custom自定义事件，并且每3s主动触发一次该事件： import * as events from \"events\"; const ev: events.EventEmitter = new events.EventEmitter(); ev.on(\"custom\", (): void => { console.log(\"custom event trigger\"); }) setInterval((): void => { ev.emit(\"custom\") }, 3000); once() once()见名知意，由它监听的事件只会触发一次： import * as events from \"events\"; const ev: events.EventEmitter = new events.EventEmitter(); ev.once(\"custom\", (): void => { console.log(\"custom event trigger\"); }) setInterval((): void => { ev.emit(\"custom\") }, 3000); prependListener() 注意，EventEmitter实例对象内部会维护一个已监听事件的数组，每次添加新的监听事件时都会将被监听事件追加该数组尾部。重复的监听同一事件并不会产生任何问题。 如果你想将新的监听事件插入到该数组的头部，可使用prependListener()进行事件监听： import * as events from \"events\"; const ev: events.EventEmitter = new events.EventEmitter(); ev.prependListener(\"custom\", (): void => { console.log(\"custom event trigger\"); }) setInterval((): void => { ev.emit(\"custom\") }, 3000); 触发事件 emit() EventEmitter实例对象可调用emit()方法主动的触发一个事件，并且还可以传入一些参数给事件处理程序： import * as events from \"events\"; const ev: events.EventEmitter = new events.EventEmitter(); ev.on(\"custom\", (...ary: any[]): void => { console.log(ary); console.log(\"custom event trigger\"); }) setInterval((): void => { ev.emit(\"custom\", 1, 2, 3, 4) }, 3000); 取消监听 off() 使用off()方法或者removeListener()方法来取消某个事件的监听。 每次至多只能取消一个，若要取消多个则必须调用多次该方法： import * as events from \"events\"; const ev: events.EventEmitter = new events.EventEmitter(); function callback(): void { console.log(\"custom event trigger\"); } ev.on(\"custom\", callback); ev.emit(\"custom\"); ev.off(\"custom\", callback); ev.emit(\"custom\"); 以上代码中，第二次的emit()并不会被执行，因为事件已被取消监听。 removeAllListeners() 使用removeAllListeners()方法来取消所有事件的监听，它也可以用来取消某一个事件的监听。 import * as events from \"events\"; const ev: events.EventEmitter = new events.EventEmitter(); function callback(): void { console.log(\"custom event trigger\"); } ev.on(\"custom\", callback); ev.emit(\"custom\"); // ev.removeAllListeners(\"custom\"); // 取消一个 ev.removeAllListeners(); // 取消全部 ev.emit(\"custom\"); Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:48 "},"前端专栏/Node.js/定时器.html":{"url":"前端专栏/Node.js/定时器.html","title":"定时器","keywords":"","body":"事件循环 Node.js JavaScript代码运行在单个线程上。 每次只处理一件事。 这个限制实际上非常有用，因为它大大简化了编程方式，而不必担心并发问题。 如果你之前不了解JavaScript事件循环，可参照之前JavaScript中Promise章节。 const bar = () => console.log('异步宏任务 bar'); const baz = () => console.log('同步任务 baz'); const foo = () => { console.log('同步任务 foo') setTimeout(bar, 0) new Promise((resolve, reject) => { console.log(\"同步任务 Promise executor\"); resolve(); } ).then(() => console.log(\"异步微任务 then\")); baz(); }; foo(); // 同步任务 foo // 同步任务 Promise executor // 同步任务 baz // 异步微任务 then // 异步宏任务 bar 定时器 Node.js中可用的定时器函数如下所示： setTimeout(callback, delay[, ...args]) setInterval(callback[, ...args]) setImmediate(callback[, ...args]) process.nextTick(callback[, ...args]) 前2个和WEB端是一致的，后2个有略微的差异。 setImmediate()用于将任务添加至宏任务队列，它晚于微任务执行 process.nextTick()用于将任务添加至微任务队列，它早于宏任务执行 在Node.js中，setImmediate()以及process.nextTick()是会被经常使用的，与之相比前2个setTimeout()以及setInterval()使得场景较少。 Node.js 不保证回调被触发的确切时间，也不保证它们的顺序，回调会在尽可能接近指定的时间被调用。setTimeout 当 delay 大于 2147483647 或小于 1 时，则 delay 将会被设置为 1， 非整数的 delay 会被截断为整数 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:48 "},"前端专栏/Node.js/路径处理.html":{"url":"前端专栏/Node.js/路径处理.html","title":"路径处理","keywords":"","body":"path模块 Node.js中关于路径的处理，统一采用内置模块path进行解决。 path模块对不同的操作系统会有不同的处理方案，如果在Windows操作系统上，path会使用Windows风格的路径，即（C:\\\\temp\\\\index.html），而在POSIX操作系统上会默认使用POSIX的路径风格，即(/temp/index.html)。路径风格和操作系统不一致会出现意外的结果。 PS：POSIX，Portable Operating System Interface，是UNIX系统的一个设计标准，很多类UNIX系统也在支持兼容这个标准，如Linux和Mac OS所基于的FreeBSD 指定系统 如果你想获取某一个平台下的路径，可通过以下方式运行方法： path.win32.方法名() path.posix.方法名() 示例如下： import * as path from 'path'; let winDirName: string = path.win32.dirname(\"C://temp//index.html\"); let posixDirName: string = path.posix.dirname(\"/temp/index.html\"); console.log(winDirName); console.log(posixDirName); // C://temp/ // /temp 如果直接使用path.方法名()则Node.js解析器会自动判断操作系统，从而返回该平台风格的路径内容。 常用属性 以下是path模块中所提供的常用属性： 属性 描述 sep 返回路径分隔符，Windows返回反斜杠、POSIX返回正斜杠 delimiter 获取操作系统路径界定符，Windows返回分号、POSIX返回冒号 示例演示： > path.sep '/' > path.delimiter ':' 常用方法 以下是path模块中所提供的常用方法： 方法 描述 dirname() 获取文件的父文件夹 basename() 获取文件名部分 extname() 获取文件扩展名部分 join() 拼接一个完整路径 resolve() 返回文件绝对路径 isAbsolute() 检测路径是否是绝对路径 normalize() 当出现.或者..时，它会自动计算文件实际路径 parse() 解析文件路径信息，返回一个文件路径信息对象 format() 根据文件路径信息对象拼接出文件路径信息，相当于parse()的反操作 示例演示： > const posixPath = \"/Users/yunya/Project/server.js\" undefined > path.dirname(posixPath) '/Users/yunya/Project' > path.basename(posixPath) 'server.js' > path.extname(posixPath) '.js' > path.join(\"/\", \"Users\", \"Jack\", \"Demo\") '/Users/Jack/Demo' > path.isAbsolute(posixPath) true > path.normalize(\"/Users/yunya/../jack/./Demo\") '/Users/jack/Demo' > let pathObject = path.parse(posixPath) undefined > pathObject { root: '/', dir: '/Users/yunya/Project', base: 'server.js', ext: '.js', name: 'server' } > path.format(pathObject) '/Users/yunya/Project/server.js' Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:48 "},"前端专栏/Node.js/文件操作.html":{"url":"前端专栏/Node.js/文件操作.html","title":"文件操作","keywords":"","body":"fs模块 fs模块提供了对文件、文件夹读写操作的同步、异步方法。 个人比较喜欢使用该模块下的同步方法，异步方法编写起来比较麻烦，而且大多数常见下作用不明显。 但是本章节还是着重介绍异步方法，因为同步方法相对来说比较简单。 操作风格 回调风格 Node.js中基本上所有的异步操作都是回调函数的风格，这就造成了ES6标准没出来之前令人闻风丧胆的回调地狱现象，如读取一个文件时，就需要指定1个回调函数，用于读取完成后做处理。 绝大多数异步操作的fs方法基本都具有2个参数，极少数方法除外： err：操作失败，err为错误信息 returnValue：操作成功，returnValue为操作成功后的内容，err为null 我们以读取文件为示例进行演示： import * as fs from 'fs'; fs.readFile(\"./src/testFile.txt\", \"utf-8\", (err: NodeJS.ErrnoException | null, data: string) => { if (err) { throw err; } console.log(data); }) fs promise API fs.promise API提供了一组和callback风格对应的方法，它让原本的方法返回Promise对象而不使用回调，避免出现callback嵌套的回调地狱问题。 API可通过require('fs').promises 或 require('fs/promises')访问，这个模块下没有同步方法，只有Promise封装好的异步方法。 注意！require('fs/promises')仅在v14后可用。 示例演示，这里采用第二种方式： import * as pfs from 'fs/promises'; pfs.readFile(\"./src/testFile.txt\", \"utf-8\") .then((data: string) => { console.log(data); }).catch((err: NodeJS.ErrnoException) => { console.log(err); }) 同步读取 除此之外，你也可进行同步操作，它在某些时候显得更加适用。 如你必须将文件读取完成后才能返回，fs模块下大部分的方法都提供了一个同步版本，只需要在方法名称后面加上Sync后缀即可，如fs.readFile需要变更为fs.readFileSync。 同步方法不需要指定回调，如下所示： import * as fs from 'fs'; try { const data: string = fs.readFileSync(\"./src/testFile.txt\", \"utf-8\"); console.log(data); } catch (e: unknown) { console.log(e); } stat 获取基本信息 fs.stat()方法用于异步的获取文件基本信息，如下所示： import * as fs from 'fs'; fs.stat(\"./src/testFile.txt\", (err: NodeJS.ErrnoException | null, currentFile: fs.Stats) => { if (err) { throw err; } console.log(currentFile); }) 除此之外你也可以使用fs.statSync()来同步的获取文件基本信息： import * as fs from 'fs'; try { let currentFile: fs.Stats = fs.statSync(\"./src/testFile.txt\"); console.log(currentFile); } catch (e: unknown) { console.log(e); } 基本信息如下： Stats { dev: 16777220, mode: 33188, nlink: 1, uid: 501, gid: 20, rdev: 0, blksize: 4096, ino: 15414257, size: 11, blocks: 8, atimeMs: 1630053255000, mtimeMs: 1630048964000, ctimeMs: 1630048964000, birthtimeMs: 1630048960000, atime: 2021-08-27T08:34:15.000Z, mtime: 2021-08-27T07:22:44.000Z, ctime: 2021-08-27T07:22:44.000Z, birthtime: 2021-08-27T07:22:40.000Z } isDirectory() 判断当前对象是否是一个目录： import * as fs from 'fs'; fs.stat(\"./src/testFile.txt\", (err: NodeJS.ErrnoException | null, currentFile: fs.Stats) => { if (err) { throw err; } console.log(currentFile.isDirectory()); // false }) isFile() 判断当前对象是否是一个普通文件： import * as fs from 'fs'; fs.stat(\"./src/testFile.txt\", (err: NodeJS.ErrnoException | null, currentFile: fs.Stats) => { if (err) { throw err; } console.log(currentFile.isFile()); // false }) isSymbolicLink() 判断当前对象是否是一个软链接： import * as fs from 'fs'; fs.stat(\"./src/testFile.txt\", (err: NodeJS.ErrnoException | null, currentFile: fs.Stats) => { if (err) { throw err; } console.log(currentFile.isSymbolicLink()); // false }) size 获取当前对象的字节数大小： import * as fs from 'fs'; fs.stat(\"./src/testFile.txt\", (err: NodeJS.ErrnoException | null, currentFile: fs.Stats) => { if (err) { throw err; } console.log(currentFile.size); // 11 }) 文件读取 fs.readFile() 使用fs.readFile()异步的读取文件。 path：需要读取的文件路径 encoding：文件字符编码格式，若不指定则返回Buffer格式数据 callback：回调函数 示例演示： import * as fs from 'fs'; fs.readFile(\"./src/testFile.txt\", \"utf-8\", (err: NodeJS.ErrnoException | null, data: string) => { if (err) { throw err; } console.log(data); }) fs.readFileSync() 使用fs.readFileSync()同步的读取文件： path：需要读取的文件路径 encoding：文件字符编码格式，若不指定则返回Buffer格式数据 示例演示： import * as fs from 'fs'; try { const data: string = fs.readFileSync(\"./src/testFile.txt\", \"utf-8\"); console.log(data); } catch (e: unknown) { console.log(e); } fs.createReadStream() 使用fs.createReadStream()流来读取大文件，它具有6个可用于监听的事件： open：文件已打开完成 ready：文件已准备完成 data：文件已正在读取 end：文件已读取完毕 close：文件已经关闭 error：读取发生异常 示例演示： import * as fs from 'fs'; const fd: fs.ReadStream = fs.createReadStream(\"./src/testFile.txt\"); let content: string = \"\"; fd.on(\"open\", () => { console.log(`已经打开`); }); fd.on(\"ready\", () => { console.log(`准备就绪`); }); fd.on(\"data\", (chunk: NodeJS.ReadStream) => { console.log(\"开始读取\"); content += chunk.toString(); }); fd.on(\"end\", () => { console.log(`读取完成`); console.log(content); }); fd.on(\"close\", () => { console.log(`已经关闭`); }); fd.on(\"error\", () => { console.log(`发生错误`); }); 文件写入 fs.writeFile() 使用fs.writeFile()异步的将内容写入文件中。 path：需要写入的文件路径 data：需要写入文件的内容 callback：回调函数，仅有一个err参数 注意，当文件已存在，它将清空文件源内容后再写入新内容，若文件不存在则自动创建并写入。 示例演示： import * as fs from 'fs'; const content = \"Hello Node.js\" fs.writeFile(\"./src/testFile.txt\", content, (err: NodeJS.ErrnoException | null) => { if (err) { throw err; } console.log(\"write to file success!\"); }) fs.writeFileSync() 使用fs.writeFile()同步的将内容写入文件中。 path：需要写入的文件路径 data：需要写入文件的内容 注意，当文件已存在，它将清空文件源内容后再写入新内容，若文件不存在则自动创建并写入。 示例演示： import * as fs from 'fs'; const content = \"Hello Node.js\" try { fs.writeFileSync(\"./src/testFile.txt\", content); console.log(\"write to file success!\"); } catch (e: unknown) { console.log(e); } fs.appendFile() 使用fs.appendFile()异步的将内容追写进文件中。 path：需要写入的文件路径 data：需要写入文件的内容 callback：回调函数，仅有一个err参数 注意，当文件已存在，它将在源文件已有内容的后面追写新的内容，若文件不存在则自动创建并写入。 示例演示： import * as fs from 'fs'; const content = \"Hello Node.js\" fs.appendFile(\"./src/testFile.txt\", content, (err: NodeJS.ErrnoException | null) => { if (err) { throw err; } console.log(\"write to file success!\"); }) fs.appendFileSync() 使用fs.appendFileSync()同步的将内容追写进文件中。 path：需要写入的文件路径 data：需要写入文件的内容 注意，当文件已存在，它将在源文件已有内容的后面追写新的内容，若文件不存在则自动创建并写入。 示例演示： import * as fs from 'fs'; const content = \"Hello Node.js\" try { fs.appendFileSync(\"./src/testFile.txt\", content); console.log(\"write to file success!\"); } catch (e: unknown) { console.log(e); } fs.createWriteStream() 使用fs.createWriteStream()流来写入大文件，它具有5个可用于监听的事件： open：文件已打开完成 ready：文件已准备完成 finish：文件已写入完毕 close：文件已经关闭 error：写入发生异常 通过write()方法，可指定写入内容并指定编码格式。 示例演示，我们可以自定义一个write作为可写事件，并在文件准备完成后手动触发该事件，当文件内容写入完成后你应当调用end()方法通知文件以写入完毕，它将自动执行finish回调函数： import * as fs from 'fs'; const fd: fs.WriteStream = fs.createWriteStream(\"./src/testFile.txt\"); let content: string = \"Hello Node.js\"; fd.on(\"open\", () => { console.log(`已经打开`); }); fd.on(\"ready\", () => { console.log(`准备就绪`); fd.emit(\"write\"); // 手动触发可写事件，注意可写事件是自定义的 }); fd.on(\"write\", () => { console.log(\"开始写入\"); fd.write(content, \"utf-8\"); fd.end(); // 宣告写入结束，自动触发finish事件 }); fd.on(\"finish\", () => { console.log(`写入完成`); }); fd.on(\"close\", () => { console.log(`已经关闭`); }); fd.on(\"error\", () => { console.log(`发生错误`); }); 文件夹操作 fs.Dir与fs.Dirent fs.Dir是可迭代的目录流，你可以将它认为是目录项。 fs.Dirent是遍历fs.Dir得到的子内容，可以是文件或者子目录。 以下是fs.Dir中可调用的属性或方法： path：获取目录的只读路径 read()：若不传入callback、则返回一个Promise，读取迭代器中下一个目录项，resolve后得到fs.Dirent或null close()：若不传入callback、则返回一个Promise，关闭目录的底层资源句柄 以下是fs.Dirent中可调用的属性或方法： name：返回文件名 isDirectory()：判断是否是一个目录 isFile()：判断是否是一个文件 isSymbolicLink()：判断是否是一个软链接 fs.opendir() fs.opender()方法用于打开一个目录，它将返回一个fs.Dir对象。 path：需要打开的目录路径 ?options：一个对象，用于传入字符编码和缓冲区大小 callback：回调函数 示例如下： import * as pfs from \"fs/promises\"; import * as fs from \"fs\"; async function dirMap(path: string): Promise { let dir: fs.Dir = await pfs.opendir(path); let dirent: fs.Dirent; for await (dirent of dir) { console.log(dirent.name); } } dirMap(\"./\"); 实现遍历目录下所有文件： import * as pfs from \"fs/promises\"; import * as fs from \"fs\"; import * as ph from \"path\"; async function dirMap(path: string): Promise { let dir: fs.Dir = await pfs.opendir(path); let dirent: fs.Dirent; console.log(path); for await (dirent of dir) { if (dirent.isDirectory()) { dirMap(ph.join(path, dirent.name)) } else { console.log(ph.join(path, dirent.name)); } } } dirMap(\"./src\"); fs.readdir() fs.readdir()方法用于返回目录下所有的内容。 path：需要打开的目录路径 ?options：一个对象，用于传入字符编码和缓冲区大小 callback：回调函数 示例演示： import * as pfs from \"fs/promises\"; async function dirMap(path: string): Promise { let dir: string[] = await pfs.readdir(path); console.log(dir); } dirMap(\"./src\"); // [ 'demo.ts', 'pf.py', 'server.ts', 'test', 'testFile.txt' ] fs.mkdir() fs.mkdir()方法用于创建目录。 path：需要创建的目录路径 ?options：一个对象，如果其中的recursive为true的话，则相当于mkdir -p，默认为false callback：回调函数 示例演示： import * as pfs from \"fs/promises\"; import * as fs from \"fs\"; let path: string = \"/tmp/1/2/3/4/5\"; try { // 相当于 mkdir -p /tmp/1/2/3/4/5 pfs.mkdir(path, { recursive: true }); } catch (e: unknown) { console.log(e); } finally { console.log(fs.existsSync(path)); } fs.redir() fs.mkdir()方法用于删除目录。 path：需要删除的目录路径 ?options：一个对象，如果其中的recursive为true的话，则递归的进行目录删除，即使目录不存在也不会抛出异常，默认为false callback：回调函数 示例演示： import * as pfs from \"fs/promises\"; import * as fs from \"fs\"; let path: string = \"/tmp/1\"; try { pfs.rmdir(path, { recursive: true }); } catch (e: unknown) { console.log(e); } finally { // 注意，由于rmdir是一个异步方法，而existsSync是个同步方法 // 所以判断目录是否存在会先执行而后删除，使用setImmediate()将existsSync()提升到宏任务队列中 // 保证判断不会出现在删除之前 setImmediate(() => { console.log(fs.existsSync(path)); }) } 其他常用 API fs.existsSync() fs.existsSync()用于同步的判断文件是否存在。 返回布尔值。 import * as fs from \"fs\"; console.log(fs.existsSync(\"/Users\")); 该方法存在异步版本。但是不推荐使用。 copyFileSync() copyFileSync()用于同步的拷贝文件。 import * as fs from \"fs\"; // fs.constants.COPYFILE_EXCL选项的意思是，如果文件已存在，将会抛出异常 fs.copyFileSync(\"源文件.txt\", \"目标文件.txt\", fs.constants.COPYFILE_EXCL); 该方法存在异步版本。 fs.renameSync() fs.renameSync()方法用于同步的为文件进行重命名。 import * as fs from \"fs\"; fs.renameSync(\"旧名字\", \"新名字\"); 该方法存在异步版本。 fs.unlinkSync() fs.unlinkSync()方法只能同步的删除文件或软链接，不能删除目录。 import * as fs from \"fs\"; fs.unlinkSync(\"文件路径\"); 该方法存在异步版本。 fs.chmodSync() fs.chmodSync()方法用于同步的修改文件读写执行权限。 import * as fs from \"fs\"; fs.chmodSync(\"文件路径\", 0o775); 该方法存在异步版本。 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:48 "},"前端专栏/Node.js/Buffer.html":{"url":"前端专栏/Node.js/Buffer.html","title":"Buffer","keywords":"","body":"基本介绍 我们都知道，如果数据想在网络中进行传播，那么必须传输二进制字节流。但遗憾的是JavaScript中并没有实现类似的直观数据类型。 所幸，Node.js中支持了Buffer格式、Buffer类似于Python中的bytes类型、Go中的byte类型，它能够作用于数据网络传输和文件系统操作等场景。 我们都知道1个Byte等于8个bit，而Buffer则等于256个Byte。 Buffer类的实例实际上是一个0-255之间的数组，它是一个由JavaScript和C++结合的模块，其对象内存不经过V8引擎分配，而是通过C++进行申请、JavaScript 分配。缓冲区的大小在创建时确定，不能调整。 因Buffer对象实在过于常用，故被直接内置到全局变量中，使用时候无需 require 引入。 创建Buffer Buffer.form(string , encoding) 返回一个包含给定字符串的Bufferr： let bf: Buffer = Buffer.from(\"hello world\", \"utf-8\"); console.log(bf); // Buffer目前支持以下几种编码格式 ascii utf8 utf16le base64 binary hex Buffer.form(array) 返回一个内容包含所提供的字节副本的Buffer，数组中每一项是一个表示八位字节的数字，所以值必须在0 ~ 255之间，否则会取模： let bf: Buffer = Buffer.from([256, 2444, 3]); console.log(bf); // 超过 255 会取模，相当于 number % 256 // Buffer.form(object) 取object的valueOf()或Symbol.toPrimitive()初始化Buffer： let bf: Buffer = Buffer.from({ valueOf() { return \"hello world\"; } }); // 自动调用对象的valueOf()方法 console.log(bf); // Buffer.form(buffer) 返回一个给定Buufer的副本Buffer： let firstBf: Buffer = Buffer.from(\"hello world\", \"utf-8\"); let lastBf : Buffer = Buffer.from(firstBf); console.log(lastBf); // 转换为字符串 字符串转Buffer需要使用Buffer.form()方法，而Buffer转字符串只需要调用其下的toString()方法即可： let bf: Buffer = Buffer.from(\"hello world\", \"utf-8\"); console.log(bf); let str = bf.toString(); console.log(str); // // hello world Buffer拼接 使用Buffer.concat()方法将多个Buffer进行拼接： let firstBf: Buffer = Buffer.from(\"hello\", \"utf-8\"); let lastBf: Buffer = Buffer.from(\"world\", \"utf-8\"); console.log(Buffer.concat([firstBf, lastBf])); 常用方法 isBuffer() 判断一个对象是否是Buffer类型： console.log(Buffer.isBuffer(\"1\")); // false isEncoding() 判断Buffer对象的默认编码格式： console.log(Buffer.isEncoding(\"utf-8\")); // true length 获取Buffer对象的长度： let bf: Buffer = Buffer.from(\"hello world\", \"utf-8\"); console.log(bf.length); // 11 indexOf 获取某字符在Buffer中的位置，如果不存在则返回-1： let bf: Buffer = Buffer.from(\"hello world\", \"utf-8\"); console.log(bf.indexOf(\"w\")); // 6 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:48 "},"前端专栏/Node.js/Stream.html":{"url":"前端专栏/Node.js/Stream.html","title":"Stream","keywords":"","body":"基础介绍 什么是流 流是一种高效的信息传输手段，实际上早在几十年前的Unix操作系统中就已经存在了这一概念。 如下命令： ls . | grep \"test\" 它有个最大的特点就能是对数据进行分段处理，第一个阶段该怎么做、第二个阶段该怎么做。 例如，在传统方式中，当告诉程序需要读取文件时，它会将文件从头到尾读入内存后再进行处理，而使用流的话则可以逐个分段的读取并处理数据，意味着不必一次读完所有数据后再进行处理。 一个通俗的例子，我们在线观看视频时，缓冲进度条总是随着当前观看进度不断的增加，它并不是一开始就立马请求完整个完整的视频后再进行播放，这就是一个非常典型的流式传输案例。 相较于使用其他的数据处理方法，流提供了2个主要优点： 内存效率：无需加载大量的数据到内存中即可进行处理 时间效率： 当获得数据之后即可立即开始处理数据，这样所需的时间更少，而不必等到整个数据有效负载可用才开始 Node.js 的 stream模块提供了构建所有流 API 的基础。 所有的流都是EventEmitter的实例。 流可以分为4种类型： Readable：可读流，不可写入数据 Writable：可写流，不可读取数据 Duplex：双工流，可读可写 Transform：类似于双工流、但其输出是其输入的转换的转换流 流的传输 流的数据传输必须依赖一个管道，例如，下面的示例将从可读流中读取数据，并通过管道将它交由HTTP客户端： import * as http from 'http'; import * as fs from 'fs'; const hostname: string = \"localhost\"; const port: number = 3000; const server: http.Server = http.createServer((request: http.IncomingMessage, response: http.ServerResponse): void => { console.log(request.url); response.setHeader('Content-Type', 'text/html; charset=utf-8'); response.statusCode = 200; const stream = fs.createReadStream(__dirname + \"/testFile.txt\"); stream.pipe(response); // 通过管道发送给response }); server.listen(port, hostname, (): void => { console.log(`server running success! http://${hostname}:${port}`); }) 这样做的好处就是如果要读取的文件太大，那么我们可以不必等待文件被完全读取后再进行返回，而是读取一部分返回一部分。 实际上pipe()方法可以进行链式操作，它将不断的对数据进行传输，如下所示： src.pipe(dest1).pipe(dest2) 此构造相对于： src.pipe(dest1) dest1.pipe(dest2) 可读流 基本创建 通过stream模块创建一个可读流，对其进行初始化的同时并实现_read()方法即可。 this.push()方法用于为当前的可读流中新增数据，如下所示我们创建了一个不断产生随机数的可读流。 this.push()的内容只能是字符串或者Buffer，不能是数字 this.push()方法有第二参数encoding，用于第一个参数是字符串时指定encoding 如下所示： import * as stream from \"stream\"; const readableStream: stream.Readable = new stream.Readable() readableStream._read = function (): void { // 模拟数据的产生，每1s产生一个数据 setTimeout(() => { this.push(String(Math.round(Math.random() * 20)) + \"\\n\"); }, 1000); } // 进行读取，将数据输出到stdout上 readableStream.pipe(process.stdout) 或者你也可以通过类继承的方式进行实现： import * as stream from \"stream\"; class ReadableStream extends stream.Readable { constructor() { super(); } _read(): void { setTimeout(() => { this.push(String(Math.round(Math.random() * 20)) + \"\\n\"); }, 1000); } } const readableStream = new ReadableStream(); readableStream.pipe(process.stdout); 停止读取 如何停止可读流呢？实际上只要this.push()一个null即可，如下所示只要随机数为20就停止读取： import * as stream from \"stream\"; class ReadableStream extends stream.Readable { constructor() { super(); } _read(): void { setTimeout(() => { let n: number = Math.round(Math.random() * 20); n != 20 ? this.push(String(n) + \"\\n\") : this.push(null); }, 1000); } } const readableStream = new ReadableStream(); readableStream.pipe(process.stdout); 工作模式 细心的朋友可能会发现，我们的_read()方法中关于随机数的生成使用了setTimeout()，而没有使用setInterval()，但是当readableStream.pipe()时依旧会源源不断的产生随机数，这是为什么呢？ 其实流分为2种工作模式： 流动模式：由pipe()方法进行触发 暂停模式：由read()方法进行触发（默认的） 可以这么理解，当我们调用read()方法时，相当于把水龙头拧开之后马上关掉，每次只会流出一股水。 而当调用pipe()方法时，它内部会源源不断的调用readableStream._read()方法，相当于直接把水龙头拧开，直至蓄水池中的水被全部放掉后才会关闭水龙头，也就是说只有可读流不再产生新的数据后，pipe()方法才算运行完成，否则便会一直运行。 相关事件 我们可以对可读流进行事件监听： data事件：当可读流已经产生了数据时，将自动触发该事件并启用流动模式读取产生的数据 end事件：数据已经读取完成 error事件：数据读取失败了 如下示例演示： import * as stream from \"stream\"; class ReadableStream extends stream.Readable { constructor() { super(); } _read(): void { setTimeout(() => { let n: number = Math.round(Math.random() * 20); n != 20 ? this.push(String(n) + \"\\n\") : this.push(null); }, 1000); } } const readableStream = new ReadableStream(); readableStream.on(\"data\", (chunk: Buffer) => { // chunk = 本次被读取的数据 console.log(chunk.toString()); }) readableStream.on(\"end\", () => { console.log(\"读取完毕\"); }) readableStream.on(\"error\", () => { console.log(\"读取失败\"); }) 此外还有一个readable事件，它代表可读流已经产生了新的数据。 常用于和read()方法搭配使用，用于启用暂停模式的读取数据： import * as stream from \"stream\"; class ReadableStream extends stream.Readable { constructor() { super(); } _read(): void { setTimeout(() => { let n: number = Math.round(Math.random() * 20); n != 20 ? this.push(String(n) + \"\\n\") : this.push(null); }, 1000); } } const readableStream = new ReadableStream(); readableStream.on(\"readable\", () => { console.log(\"有数据了\"); let chunk: Buffer = readableStream.read(); if(chunk !== null){ console.log(chunk.toString()); } }) 可写流 基本创建 通过stream模块创建一个可写流，对其进行初始化的同时并实现_write()方法即可。 在进行可写流初始化时，可指定options，它是一个对象，以下是常用的设置项： objectMode：Boolean类型，默认是 false， 设置成true后writable.write()方法除了写入string和buffer外，还可以写入任意 JavaScript对象。 highWaterMark：Number类型，每次最多写入的数据量， Buffer的时候默认值16kb decodeStrings：Boolean类型，是否把传入的数据转成Buffer，默认是true 若想使用可写流，则需要调用write()方法，它指向了内部的_write()，共接收3个参数： chunk：写入的数据，默认是Buffer类型 encoding：如果数据是字符串，可以设置编码，buffer或者object模式会忽略 done：回调函数 如下所示，我们往自己的可写流中写入数据，然后将数据再写入到process.stdout的可写流中： import * as stream from \"stream\"; class WriteableStream extends stream.Writable { constructor(options?: { [key: string]: any }) { super(options); } _write(chunk: string | Buffer, encoding?: Buffer | string, done?: (err?: NodeJS.ErrnoException) => void): void { try { // Ts避免错误 encoding; process.stdout.write(chunk.toString()); if (done !== undefined) { done(); } } catch (e) { if (done !== undefined) { done(e); } } } } const writeableStream = new WriteableStream({ objectMode: false, highWaterMark: 16, decodeStrings: true }); writeableStream.write(\"hello\"); // buffer // hello 停止写入 数据写入完成后，应当调用end()方法，表示数据已经写入完成了： writeableStream.write(\"hello\"); writeableStream.end(); 它将会触发一系列的事件完成操作。 相关事件 我们可以对可写流进行事件监听： finish事件：数据已经写入完成 error事件：数据写入失败了 如下示例演示： import * as stream from \"stream\"; class WriteableStream extends stream.Writable { constructor(options?: { [key: string]: any }) { super(options); } _write(chunk: string | Buffer, encoding?: Buffer | string, done?: (err?: NodeJS.ErrnoException) => void): void { try { // Ts避免错误 encoding; process.stdout.write(chunk.toString()); if (done !== undefined) { done(); } } catch (e) { if (done !== undefined) { done(e); } } } } const writeableStream = new WriteableStream({ objectMode: false, highWaterMark: 16, decodeStrings: true }); writeableStream.write(\"hello world\"); writeableStream.end(); writeableStream.on(\"finish\", () => { console.log(\"写入完成\"); }) writeableStream.on(\"error\", () => { console.log(\"写入失败\"); }) Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:48 "},"前端专栏/Node.js/Web开发.html":{"url":"前端专栏/Node.js/Web开发.html","title":"Web开发","keywords":"","body":"http模块 简单使用 Node.js中内置的http模块可用于搭建HTTP服务器。 如下所示： import * as http from \"http\"; const hostname: string = \"localhost\"; const port: number = 3000; const server = http.createServer((request: http.IncomingMessage, response: http.ServerResponse) => { response.setHeader('Content-Type', \"text/http charset=utf-8\"); response.statusCode = 200; if (request.method === \"GET\") { response.end(\"/GET OK!\"); } else { response.end(\"/POST OK!\"); } }); server.listen(port, hostname, 128, () => { console.log(`server running success! http://${hostname}:${port}`); }); 代码释义： http.createServer()：创建一个HTTP服务器，需要指定一个callback，它将在请求来临时自动调用，callback具有2个参数req和res分别代指请求对象和响应对象 listen()：用于启动服务并监听指定端口，必须传入port、host，可选传入backlog和callback，callback会在服务器成功启动后自动调用 请求相关 以下是关于请求对象req的常用API，req是一个可读流的对象： api 描述 req.headers 返回请求头对象 req.method 返回本次请求的方式（GET、POST、DELETE、PUT 等） req.url 返回本次请求的地址 req.httpVersion 返回本次请求的HTTP版本 响应相关 以下是关于请求对象响应对象res的常用API，res是一个可写流的对象： api 描述 res.statusCode 用于设置响应的HTTP状态码 res.setHeader(name, value) 用于设置响应头 res.writeHead(statusCode [, StatusMessage[, headers]]) 发送响应首部，包含状态码、状态信息、响应头 res.getHeaders() 获取已设置的响应头副本 res.getHeaderNames() 获取已设置的HTTP响应头名称的列表 res.getHeader(name) 获取已设置的响应头 res.removeHeader(name) 删除已设置的响应头 res.hasHeader(name) 如果响应已设置该消息头，则返回true res.write(chunk) 用于向响应体中写入字符串或者buffer res.end(chunk) 用于结束本次响应，若指定chunk则相当于同时调用了write()方法 返回文件 如下示例将演示如何返回一个普通的资源文件，如HTML、CSS、JS文件： import * as http from \"http\"; import * as path from \"path\"; import * as fs from \"fs\"; const hostname: string = \"localhost\"; const port: number = 3000; const baseDir: string = path.join(__dirname, \"..\"); const templatesDir: string = path.join(baseDir, \"templates\"); const server = http.createServer((request: http.IncomingMessage, response: http.ServerResponse) => { if (request.method === \"GET\") { response.writeHead(200, { \"Content-Type\": \"text/html; charset=utf-8\", }); const indexPath: string = path.join(templatesDir, \"index.html\"); fs.createReadStream(indexPath).pipe(response); } else { response.writeHead(405); response.end(\"Method Not Allowed\"); } }); server.listen(port, hostname, 128, () => { console.log(`server running success! http://${hostname}:${port}`); }); 返回视频 如下示例将演示如何返回视频文件： import * as http from \"http\"; import * as path from \"path\"; import * as fs from \"fs\"; const hostname: string = \"localhost\"; const port: number = 3000; const baseDir: string = path.join(__dirname, \"..\"); const templatesDir: string = path.join(baseDir, \"templates\"); const staticsDir: string = path.join(baseDir, \"static\"); function index(request: http.IncomingMessage, response: http.ServerResponse) { console.log(request.httpVersion); response.writeHead(200, { \"Content-Type\": \"text/html; charset=utf-8\", }); const indexPath: string = path.join(templatesDir, \"index.html\"); fs.createReadStream(indexPath).pipe(response); } function getVideo(request: http.IncomingMessage, response: http.ServerResponse) { // 前端代码： // 与本地的staticDir路径做拼接，获取static目录下的/video/apple.mp4 const videoPath = path.join(staticsDir, (request.url || \"\").split(\"/static/\")[1]); const stat: fs.Stats = fs.statSync(videoPath); const fileSize = stat.size; const range: string = request.headers.range || \"\"; if (range) { // 后续的请求视频，浏览器会自动携带range请求头，包含当前播放的部分 const parts = range.replace(/bytes=/, \"\").split(\"-\"); const start = parseInt(parts[0], 10); const end = parts[1] ? parseInt(parts[1], 10) : fileSize - 1; // 计算新返回的视频流长度 const chunkSize: number = (end - start) + 1; // 根据视频流长度进行截取 const file: fs.ReadStream = fs.createReadStream(videoPath, { start, end }); // 返回当前响应的视频流长度，并且请求状态要置为206 response.writeHead(206, { 'Content-Type': 'video/mp4', 'Content-Range': `bytes ${start}-${end}/${fileSize}`, 'Accept-Ranges': 'bytes', 'Content-Length': chunkSize }); file.pipe(response); } else { // 第一次请求视频，请求头只返回请求视频的总长度，和一些数据 response.writeHead(200, { 'Accept-Ranges': 'bytes', 'Content-Length': fileSize, }); fs.createReadStream(videoPath).pipe(response); } } const server = http.createServer((request: http.IncomingMessage, response: http.ServerResponse) => { if (request.method === \"GET\") { const reqUrl: string = request.url || \"\"; switch (true) { case reqUrl === \"/\": index(request, (response)); break case reqUrl.includes(\"video\"): getVideo(request, response); break default: response.writeHead(404); response.end(\"Not Found\"); } } else { response.writeHead(405); response.end(\"Method Not Allowed\"); } }); server.listen(port, hostname, 128, () => { console.log(`server running success! http://${hostname}:${port}`); }); url模块 GET请求参数 推荐使用内置模块url对GET请求参数做出解析，如下所示，我们需要将request.url转成一个url对象，然后获取其中的URLSearchParams对象： import * as http from \"http\"; import * as url from \"url\"; const hostname: string = \"localhost\"; const port: number = 3000; const server = http.createServer((request: http.IncomingMessage, response: http.ServerResponse) => { if (request.method === \"GET\") { const urlIns: url.URL = new url.URL(request.url || \"\", `http://${hostname}:${port}`); const getParams: url.URLSearchParams = urlIns.searchParams; console.log(getParams); response.writeHead(200, { \"Content-Type\": \"text/plain;\" }); response.end(\"ok\"); } else { response.writeHead(405); response.end(\"Method Not Allowed\"); } }); server.listen(port, hostname, 128, () => { console.log(`server running success! http://${hostname}:${port}`); }); 以下是urlIns对象的结构： # requestURL : http://localhost:3000/?getParams1=v1&getParams2=v2 URL { href: 'http://localhost:3000/?getParams1=v1&getParams2=v2', origin: 'http://localhost:3000', protocol: 'http:', username: '', password: '', host: 'localhost:3000', hostname: 'localhost', port: '3000', pathname: '/', search: '?getParams1=v1&getParams2=v2', searchParams: URLSearchParams { 'getParams1' => 'v1', 'getParams2' => 'v2' }, hash: '' } POST请求参数 注意！如果前端发送的是POST请求可能请求体的内容一次性接受不完，此时后端需要监听可读流request对象进行接收。 请求体接收完成之后直接调用url模块下的URLSearchParams方法得到一个参数对象： import * as http from \"http\"; import * as url from \"url\"; const hostname: string = \"localhost\"; const port: number = 3000; const server = http.createServer((request: http.IncomingMessage, response: http.ServerResponse) => { if (request.method === \"POST\") { let data: string = \"\"; request.on(\"data\", (chunk: Buffer) => { data += chunk.toString(); }) request.on(\"end\", () => { const postParams: url.URLSearchParams = new url.URLSearchParams(data); console.log(postParams); response.writeHead(200, { \"Content-Type\": \"text/plain;\" }); response.end(\"ok\"); }) } else { response.writeHead(405); response.end(\"Method Not Allowed\"); } }); server.listen(port, hostname, 128, () => { console.log(`server running success! http://${hostname}:${port}`); }); 以下是postParams对象的结构： # requestURL : http://localhost:3000/ # requestBody : postParams1=v1 postParams2=v2 URLSearchParams { 'postParams1' => 'v1', 'postParams2' => 'v2' } 合并两者请求 有的时候在发送POST请求时，可能也会在地址栏中带入一些GET请求的参数。 此时我们就需要获取POST+GET的所有参数，可以将2个URLSearchParams对象进行合并，如下所示： import * as http from \"http\"; import * as url from \"url\"; const hostname: string = \"localhost\"; const port: number = 3000; const server = http.createServer((request: http.IncomingMessage, response: http.ServerResponse) => { let data: string = \"\"; request.on(\"data\", (chunk: Buffer) => { data += chunk.toString(); }) request.on(\"end\", () => { const getParams: url.URLSearchParams = new url.URL(request.url || \"\", `http://${hostname}:${port}`).searchParams; const postParams: url.URLSearchParams = new url.URLSearchParams(data); const queryParams: { [key: string]: any } = {}; getParams.forEach((v: string, k: string) => { queryParams[k] = v; }) postParams.forEach((v: string, k: string) => { queryParams[k] = v; }) console.log(queryParams); response.writeHead(200, { \"Content-Type\": \"text/plain;\" }); response.end(\"ok\"); }) }); server.listen(port, hostname, 128, () => { console.log(`server running success! http://${hostname}:${port}`); }); 如下，发送一次POST请求，并在地址栏中携带参数： # requestURL : http://localhost:3000/?getParams1=v1&getParams2=v2 # requestBody : postParams1=v1 postParams2=v2 { getParams1: 'v1', getParams2: 'v2', postParams1: 'v1', postParams2: 'v2' } mime模块 基本使用 我们可以安装一个mime模块，用于动态的获取请求中的MIME类型，判断所请求的是静态资源还是动态资源。 也可以自动的书写响应头Content-Type： $ npm install mime --save $ npm install --save @types/mime // 适用于TypeScript导包 示例演示： import * as http from \"http\"; import * as url from \"url\"; import * as mime from \"mime\"; const hostname: string = \"localhost\"; const port: number = 3000; const server = http.createServer((request: http.IncomingMessage, response: http.ServerResponse) => { // 获取请求的MIME类型 let urlIns: url.URL = new url.URL(request.url || \"\", `http://${hostname}:${port}`); console.log(mime.getType(urlIns.pathname)); let mimeType: string = mime.getType(urlIns.pathname) || \"\"; response.writeHead(200, { \"Content-Type\": mimeType }); response.end(\"ok\"); }); server.listen(port, hostname, 128, () => { console.log(`server running success! http://${hostname}:${port}`); }); 常见mime类型 以下例举常见的mime类型： 类型/字类型 扩展名 text/plain *.txt 或 其他文本文件 text/html .html 或 .htm text/css *.css text/javascript *.js application/json *.json image/gif *.gif image/png *.png image/jpeg .jpg 或 .jpeg image/bmp *.bmp image/webp *.webp image/svg+xml *.svg(矢量图) image/x-icon *.ico audio/wav *.wav audio/webm *.webm audio/ogg *.ogg audio/mpeg *.mp3 video/webm *.webm video/ogg *.ogg video/mp4 *.mp4 application/octet-stream .*（ 二进制流，不知道下载文件类型） EJS模块 模板渲染 下载EJS模块，生成模板文件： $ npm install ejs --save $ npm install @types/ejs // 适用于TypeScript导包 官方文档：点我跳转 模板文件如下，注意模板文件用ejs进行结尾，在模板文件中你可以输入任何JavaScript代码： // index.ejs Document { %> 后端渲染的视图函数如下： import * as http from \"http\"; import * as path from \"path\"; import * as ejs from \"ejs\"; const hostname: string = \"localhost\"; const port: number = 3000; const baseDir: string = path.join(__dirname, \"..\"); const templatesDir: string = path.join(baseDir, \"templates\"); const server = http.createServer((request: http.IncomingMessage, response: http.ServerResponse) => { if (request.method === \"GET\") { response.writeHead(200, { \"Content-Type\": \"text/html; charset=utf-8\", }); const indexPath: string = path.join(templatesDir, \"index.ejs\"); ejs.renderFile(indexPath, { unOrderList: [\"热门新闻\", \"热门评论\", \"实时资讯\"] }, (err: Error | null, str: string) => { if (err) throw err; response.end(str); }) } else { response.writeHead(405); response.end(\"Method Not Allowed\"); } }); server.listen(port, hostname, 128, () => { console.log(`server running success! http://${hostname}:${port}`); }); 相关语法 脚本标签： # 它将作用在后端服务器上 输出标签： 导入模板： 自定义分隔符： // 单个模板文件，将 改为 ejs.render('', {user: 'Jack'}, {delimiter: '?'}); // 全局，将 改为 ejs.delimiter = '$'; ejs.render('', {user: 'Jack'}); mysql模块 基本使用 如果想操纵mysql数据库，需要依赖第三方模块mysql： $ npm install mysql --save $ npm install @types/mysql --save // 适用于TypeScript导包 然后我们需要链接数据库： import * as mysql from \"mysql\"; const connection: mysql.Connection = mysql.createConnection({ host: \"localhost\", user: \"root\", password: \"\", database: \"db1\" }) connection.connect(); console.log(\"connection success\"); connection.end(); console.log(\"close connection\"); 新增记录 示例如下，我们的数据库db1中有一张空的userInfo表，在此基础上做操作。 import * as mysql from \"mysql\"; const connection: mysql.Connection = mysql.createConnection({ host: \"localhost\", user: \"root\", password: \"\", database: \"db1\" }) connection.connect(); console.log(\"connection success\"); // 使用 ? 进行占位 const sql: string = \"INSERT INTO db1.userInfo (name, age, gender) VALUES (?, ?, ?);\"; // 与 ? 一一对应，防止SQL注入 const params = [\"Jack\", \"18\", \"male\"]; connection.query(sql, params, (err: mysql.MysqlError | null, result: any) => { if (err) { console.log(err.message); throw err; } console.log(`Affected line: ${result.affectedRows}`); if (result.affectedRows > 0) { console.log(`Insert success, id: ${result.insertId}`); } else { console.log(`Insert fail`); } }) connection.end(); console.log(\"close connection\"); 删除记录 删除记录示例： import * as mysql from \"mysql\"; const connection: mysql.Connection = mysql.createConnection({ host: \"localhost\", user: \"root\", password: \"\", database: \"db1\" }) connection.connect(); console.log(\"connection success\"); // 使用 ? 进行占位 const sql: string = \"DELETE FROM db1.userInfo WHERE id=?\"; // 与 ? 一一对应，防止SQL注入 const params = 1; connection.query(sql, params, (err: mysql.MysqlError | null, result: any) => { if (err) { console.log(err.message); throw err; } console.log(`Affected line: ${result.affectedRows}`); if (result.affectedRows > 0) { console.log(`delete success`); } else { console.log(`delete fail`); } }) connection.end(); console.log(\"close connection\"); 更新记录 更新记录示例，以下是原有的数据： mysql> select * from userInfo; +----+------+-----+--------+---------------------+ | id | name | age | gender | create_time | +----+------+-----+--------+---------------------+ | 1 | Jack | 18 | male | 2021-08-30 17:23:44 | | 2 | Mary | 21 | female | 2021-08-30 17:24:53 | | 3 | Tom | 17 | male | 2021-08-30 17:24:53 | +----+------+-----+--------+---------------------+ 进行更新： import * as mysql from \"mysql\"; const connection: mysql.Connection = mysql.createConnection({ host: \"localhost\", user: \"root\", password: \"\", database: \"db1\" }) connection.connect(); console.log(\"connection success\"); // 使用 ? 进行占位 const sql: string = `UPDATE db1.userInfo SET name = ?, age = ? WHERE id = ?; `; // 与 ? 一一对应，防止SQL注入 const params = [\"Ken\", 22, 1]; connection.query(sql, params, (err: mysql.MysqlError | null, result: any) => { if (err) { console.log(err.message); throw err; } console.log(`Affected line: ${result.affectedRows}`); if (result.affectedRows > 0) { console.log(`update success`); } else { console.log(`update fail`); } }) connection.end(); console.log(\"close connection\"); 查询记录 查询记录示例： import * as mysql from \"mysql\"; const connection: mysql.Connection = mysql.createConnection({ host: \"localhost\", user: \"root\", password: \"\", database: \"db1\" }) connection.connect(); console.log(\"connection success\"); // 使用 ? 进行占位 const sql: string = `SELECT * FROM db1.userInfo WHERE id > ? `; // 与 ? 一一对应，防止SQL注入 const params = 1; connection.query(sql, params, (err: mysql.MysqlError | null, result: any) => { if (err) { console.log(err.message); throw err; } console.log(`select success! a total of ${result.length} records`); for (let row of result) { console.log(row.id, row.name, row.age, row.gender); } }) connection.end(); console.log(\"close connection\"); 模块封装 项目前瞻 http模块最大的缺点是在路由系统以及静态文件管理系统上。 它只提供了最基本的HTTP服务器所需要的功能，并未对此进行更高层次的封装，所以在此我们可以对其进行更高程度的封装，着重以下3个方面： 路由系统：用户可自己定义路由匹配规则，并限制视图函数处理的请求方式 参数获取：用户可以直接从req.queryParams中获取GET请求以及POST请求所发送的所有参数 静态资源响应：自动响应所请求的静态资源，并且如果请求的是一个视频文件，那么它会自动使用流返回该视频文件 以下是整个项目的目录结构： . ├── dist # 编译代码目录 │ ├── ... ├── node_modules │ ├── ... ├── package-lock.json ├── package.json ├── src # 源代码目录 │ └── server.ts ├── common # 公用组件，自定义模块 │ ├── advancedHttp.ts ├── static # 静态文件目录 │ ├── css │ │ └── index.css │ ├── img │ │ └── avatar.jpg │ ├── js │ │ └── index.ts │ └── video │ └── apple.mp4 ├── templates # 模板文件目录 │ └── index.ejs └── tsconfig.json 其次我们需要修改一下tsconfig.json文件： { \"include\": [ \"./src/**/*\", // 编译src目录下的所有ts文件 \"./static/js/**/*\", // 编译static/js/目录下的所有ts文件 \"./common/**/*\" // 编译common目录下的所有ts文件 ], \"exclude\": [ \"./src/test/**/*\", // 不编译src目录中test目录下所有的ts文件 ], \"compilerOptions\": { \"target\": \"ES6\", // 编译后生成的js版本为es6 \"module\": \"CommonJS\", // 模块使用规范为es6 \"lib\": [ // node环境中测试ts代码所需要使用的库 \"ES6\" ], \"outDir\": \"./dist\", // 编译后生成的js文件存放路径 \"allowJs\": true, // 二次编译js文件 \"checkJs\": true, // 验证js文件语法 \"removeComments\": true, // 编译后的js文件删除注释信息 \"noEmitOnError\": true, // 如果编译时出现错误，编译将终止 \"strict\": true, // 启用TypeScript的严格模式 \"alwaysStrict\": true, // 启用JavaScript的严格模式 \"noFallthroughCasesInSwitch\": true, // 检测switch语句块是否正确的使用了break \"noImplicitReturns\": true, // 检测函数是否具有隐式的返回值 \"noUnusedLocals\": true, // 检测是否具有未使用的局部变量 \"noUnusedParameters\": true, // 检测是否具有未使用的函数参数 \"allowUnreachableCode\": true, // 检测是否具有永远不会运行的代码 \"allowSyntheticDefaultImports\": false, // 允许从没有设置默认导出的模块中默认导入，仅用于提示，不影响编译结果 \"esModuleInterop\": false // 允许编译生成文件时，在代码中注入工具类 } } 具体实现 我们将所有的代码都写在./common/advancedHttp.ts文件中，为了尽量的简单，仅定义一个类： import * as http from 'http'; import * as url from 'url'; import * as mime from 'mime'; import * as path from 'path'; import * as fs from 'fs'; interface ServerRequest extends http.IncomingMessage { queryParams: { [key: string]: any }, } interface ServerResponse extends http.ServerResponse { mimeType: string; } type ViewType = (req: ServerRequest, res: ServerResponse) => void; interface RouterStructure { method: string[]; rule: string; view: ViewType; } type RequestRouter = RouterStructure[]; class HttpServer { public hostname: string; public port: number; public backlog: number; public router: RequestRouter; public baseDir: string; public templatesDir: string; public staticsDir: string; public server: http.Server; public addr: string; public request: ServerRequest | null; public response: ServerResponse | null; public pathName: string; constructor(hostname: string, port: number, router: RequestRouter, baseDir: string = \".\", templatesDir: string = \"./templates\", staticsDir: string = \"./static\", backlog?: number) { this.hostname = hostname; this.port = port; this.router = router; this.backlog = backlog || 128; this.baseDir = baseDir; this.templatesDir = templatesDir; this.staticsDir = staticsDir; this.server = http.createServer(this.handleRequestParams.bind(this)); this.addr = `http://${this.hostname}:${this.port}`; this.request = null; this.response = null; this.pathName = \"\"; } // 参数处理 handleRequestParams(req: http.IncomingMessage, res: http.ServerResponse): void { let data: string = \"\"; req.on(\"data\", (chunk: Buffer) => { data += chunk.toString(); }) req.on(\"end\", () => { let urlIns: url.URL = new url.URL(req.url || \"\", this.addr); const postParams: url.URLSearchParams = new url.URLSearchParams(data); const getParams: url.URLSearchParams = urlIns.searchParams; const queryParams: { [key: string]: any } = {}; getParams.forEach((v: string, k: string) => { queryParams[k] = v; }) postParams.forEach((v: string, k: string) => { queryParams[k] = v; }) // 封装request对象和response对象 this.pathName = urlIns.pathname; this.request = Object.assign(req, { queryParams }); this.response = Object.assign(res, { mimeType: mime.getType(this.pathName) || \"\" }); this.handleRequestRouter(this.request, this.response) }) } // 路由解析 handleRequestRouter(req: ServerRequest, res: ServerResponse) { let tag: boolean = false; // 匹配静态资源 if (this.pathName.includes(\"static\")) { tag = this.handleStaticRequest(req, res); } // 匹配动态资源 else { tag = this.handleDynamicRequest(req, res); } // 没有匹配到 if (!tag) { res.writeHead(404); res.end(\"Not Fund\"); } } // 静态请求处理 handleStaticRequest(req: ServerRequest, res: ServerResponse): boolean { const requestPath: string = this.pathName.split(\"/static/\")[1]; // 注意！如果是js文件，那么它存放的目录是./dist下，因为ts文件会先进行编译，不能直接在网页中进行使用 const realPath = res.mimeType.includes(\"application/javascript\") ? path.join(this.baseDir, \"dist\", path.basename(this.staticsDir), requestPath) : path.join(this.staticsDir, requestPath); if (fs.existsSync(realPath)) { switch (true) { // 请求的是视频文件 case res.mimeType.includes(\"audio\"): case res.mimeType.includes(\"video\"): const stat: fs.Stats = fs.statSync(realPath); const fileSize = stat.size; const range: string = req.headers.range || \"\"; if (range) { // 后续的请求视频，浏览器会自动携带range请求头，包含当前播放的部分 const parts = range.replace(/bytes=/, \"\").split(\"-\"); const start = parseInt(parts[0], 10); const end = parts[1] ? parseInt(parts[1], 10) : fileSize - 1; // 计算新返回的视频流长度 const chunkSize: number = (end - start) + 1; // 根据视频流长度进行截取 const file: fs.ReadStream = fs.createReadStream(realPath, { start, end }); // 返回当前响应的视频流长度，并且请求状态要置为206 res.writeHead(206, { 'Content-Type': 'video/mp4', 'Content-Range': `bytes ${start}-${end}/${fileSize}`, 'Accept-Ranges': 'bytes', 'Content-Length': chunkSize }); file.pipe(res); } else { // 第一次请求视频，请求头只返回请求视频的总长度，和一些数据 res.writeHead(200, { 'Accept-Ranges': 'bytes', 'Content-Length': fileSize, }); fs.createReadStream(realPath).pipe(res); } break // 请求的是其他文件，CSS、img、js等 default: res.writeHead(200, { \"Content-type\": res.mimeType, }); fs.createReadStream(realPath).pipe(res); } return true; } // 没找到静态文件 return false; } // 动态请求处理 handleDynamicRequest(req: ServerRequest, res: ServerResponse): boolean { for (let match of this.router) { if (this.pathName === match.rule) { if (match.method.includes(req.method || \"\")) { match.view(req, res); } else { res.writeHead(406); res.end(\"Method Not Allowed\"); } return true; } } return false; } // 启动服务 start(callback: () => void) { this.server.listen(this.port, this.hostname, this.backlog, callback.bind(this)); } } export { ServerResponse, ServerRequest, ViewType, RouterStructure, RequestRouter, HttpServer } 使用案例： import * as path from 'path'; import * as ejs from \"ejs\"; import * as advHttp from \"../common/advancedHttp\"; const baseDir: string = path.join(__dirname, \"..\"); const templateDir: string = path.join(baseDir, \"templates\"); const staticDir: string = path.join(baseDir, \"static\"); const host: string = \"localhost\"; const port: number = 3000; function index(req: advHttp.ServerRequest, res: advHttp.ServerResponse) { console.log(req.queryParams); console.log(res.statusCode); res.writeHead(200, { 'Content-Type': 'text/html charset=utf-8' }); ejs.renderFile(path.join(templateDir, \"index.ejs\"), { unOrderList: [\"first\", \"second\", \"third\"] }, (err: Error | null, str: string) => { if (err) throw err; res.end(str); }) } const router: advHttp.RequestRouter = [ { method: [\"GET\", \"POST\"], rule: \"/\", view: index }, ] const server: advHttp.HttpServer = new advHttp.HttpServer(host, port, router, baseDir, templateDir, staticDir); server.start(() => { console.log(`server running success! http://${host}:${port}`); }) Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:48 "},"前端专栏/Node.js/Koa框架.html":{"url":"前端专栏/Node.js/Koa框架.html","title":"Koa框架","keywords":"","body":"Koa 基本介绍 Koa是Node.js中非常出名的一款WEB框架，其特点是短小精悍性能强。 它由Express原版人马打造，同时也是Egg框架的设计蓝图，可以说Koa框架的学习性价比是非常高的。 官方文档 项目搭建 我们先初始化一个项目： $ npm init TypeScript可以让项目更加容易维护，所以安装TypeScript是不可或缺的一部分： $ npm install typescript ts-node @types/node peer dependencies yourself --save 当安装完成后，需要在根目录中新建src目录以及server.ts文件： $ mkdir ./src $ touch ./src/server.ts 下一步是填入TypeScript的配置文件： $ tsc --init 配置文件内容如下： { \"include\": [ \"./src/**/*\", // 仅编译src目录下的所有ts文件 ], \"exclude\": [ \"./src/test/**/*\", // 不编译src目录中test目录下所有的ts文件 ], \"compilerOptions\": { \"target\": \"ES6\", // 编译后生成的js版本为es6 \"module\": \"CommonJS\", // 编译后的模块使用规范为CommonJs \"lib\": [ // node环境中测试ts代码所需要使用的库 \"ES6\" ], \"outDir\": \"./dist\", // 编译后生成的js文件存放路径 \"allowJs\": true, // 二次编译js文件 \"checkJs\": true, // 验证js文件语法 \"removeComments\": false, // 编译后的js文件删除注释信息 \"noEmitOnError\": true, // 如果编译时出现错误，编译将终止 \"strict\": true, // 启用TypeScript的严格模式 \"alwaysStrict\": true, // 启用JavaScript的严格模式 \"noFallthroughCasesInSwitch\": true, // 检测switch语句块是否正确的使用了break \"noImplicitReturns\": true, // 检测函数是否具有隐式的返回值 \"noUnusedLocals\": false, // 检测是否具有未使用的局部变量 \"noUnusedParameters\": false, // 检测是否具有未使用的函数参数 \"allowUnreachableCode\": true, // 检测是否具有永远不会运行的代码 } } 由于Koa是第三方框架，所以你应该先安装它： $ npm install koa --save $ npm install @types/koa --save 快速上手 使用Koa框架搭建一个HTTP服务器非常的简单，你只需要以下几行代码即可搞定。 import * as Koa from \"koa\" const server: Koa = new Koa() server.use(async (ctx: Koa.Context) => { ctx.response.body = \"HELLO KOA!\"; }) server.listen(3000, \"localhost\", 128, (): void => { console.log(\"server started at http://localhost:3000\"); }) 级联操作 每一个视图函数中，都具有2个参数ctx和next，而通过next你可以实现级联操作。 如下所示，它将按顺序打印1、2、3、4、5： import * as Koa from \"koa\" const server: Koa = new Koa() server.use(async (ctx: Koa.Context, next: Koa.Next) => { const start: number = Date.now() console.log(\"1\"); await next() console.log(\"5\"); ctx.response.body = \"HELLO KOA!\" }) server.use(async (ctx: Koa.Context, next: Koa.Next) => { console.log(\"2\"); await next(); console.log(\"4\"); }) server.use(async (ctx: Koa.Context, next: Koa.Next) => { console.log(\"3\"); console.log(\"hello middleware\"); }) server.listen(3000, \"localhost\", 128, (): void => { console.log(\"server started at http://localhost:3000\"); }) 路由系统 koa-router 默认的Koa框架路由系统不是很完善，对此你可以使用koa-router插件，官方所提供的文档非常齐全，你可以自行前往查看，包括嵌套路由、动态路由等知识在官方文档里面都有详细的示例，这里不再阐述。 首先需要进行下载： $ npm install koa-router --save $ npm install @types/koa-router --save 然后就可以进行使用了，注意现在Middleware View Function的编写不再是通过server.use()进行注册了而是通过router.requestMethod()进行注册，代码如下： import * as Koa from \"koa\" import * as Router from 'koa-router' const server: Koa = new Koa() const router: Router = new Router() // 1. 装载插件 server.use(router.routes()) // 2.书写视图，注意后面都是编程router.requestMethod() router.get(\"/api/get\", async (ctx: Koa.Context, next: Koa.Next) => { // 3.等待之前的插件处理完成后再运行Middleware View Function await next() ctx.response.body = \"HELLO KOA!\" }) server.listen(3000, \"localhost\", 128, (): void => { console.log(\"server started at http://localhost:3000\"); }) 请求方式 koa-router能够限制请求方式，如下所示，其中all()方法能支持所有的请求： router .get('/', (ctx, next) => { ctx.body = 'Hello World!'; }) .post('/users', (ctx, next) => { // ... }) .put('/users/:id', (ctx, next) => { // ... }) .del('/users/:id', (ctx, next) => { // ... }) .all('/users/:id', (ctx, next) => { // ... }); 请求相关 ctx.request ctx是一个上下文对象，你可以通过ctx.request获得本次HTTP服务的请求对象。 在请求对象中它提供了很多属性可供我们使用，以下只例举一些比较常见的： 属性 简写 描述 ctx.request.header ctx.header 可获取或者设置请求头对象 ctx.request.headers ctx.headers 同上 ctx.request.method ctx.method 可获取或者设置请求方式 ctx.request.href ctx.href 可获取完整的href ctx.request.origin ctx.origin 仅获取协议、主机、端口号 ctx.request.host ctx.host 仅获取主机、端口号 ctx.request.hostname ctx.hostname 仅获取主机 ctx.request.url ctx.url 仅获取url部分 ctx.request.path ctx.path 仅获取path部分 ctx.request.query ctx.query 仅获取query部分 ctx.request.ip ctx.ip 获取请求的ip 结果如下： ctx.request.href http://localhost:3000/api/get?name=Jack ctx.request.origin http://localhost:3000 ctx.request.host localhost:3000 ctx.request.hostname localhost ctx.request.url /api/get?name=Jack ctx.request.path /api/get ctx.request.query { name: 'Jack' } params 对于动态的URL params，可以使用ctx.params获取，注意！这是vue-router所提供的一个方法，它并不存在于ctx.request对象中： import * as Koa from \"koa\" import * as Router from 'koa-router' const server: Koa = new Koa() const router: Router = new Router() server.use(router.routes()) router.get(\"/api/get/:id?\", async (ctx: Koa.Context, next: Koa.Next) => { await next() // http://localhost:3000/api/get/8?k1=v1 console.log(ctx.params.id); // 8 ctx.response.body = \"HELLO KOA!\" }) server.listen(3000, \"localhost\", 128, (): void => { console.log(\"server started at http://localhost:3000\"); }) get请求参数 对于URL中的query请求参数来说，你可以直接通过ctx.request.query进行获取： import * as Koa from \"koa\" import * as Router from 'koa-router' const server: Koa = new Koa() const router: Router = new Router() server.use(router.routes()) router.get(\"/api/get/:id?\", async (ctx: Koa.Context, next: Koa.Next) => { await next() // http://localhost:3000/api/get/8?k1=v1 console.log(ctx.request.query); // { k1: 'v1' } ctx.response.body = \"HELLO KOA!\" }) server.listen(3000, \"localhost\", 128, (): void => { console.log(\"server started at http://localhost:3000\"); }) post请求参数 对于请求体中的data请求参数来说，我们可以通过第三方插件koa-body来让它的获取更加的方便。 因为默认的ctx.request对象中没有获取请求体的方法，但是使用koa-body插件后它会向ctx.request中封装一个body属性，调用它你将会获得data请求参数对象。 要想使用koa-body插件，需要对其进行安装： $ npm install koa-body --save $ npm install @types/koa__cors --save 示例如下： import * as Koa from \"koa\" import * as Router from 'koa-router' import * as koaBody from \"koa-body\" const server: Koa = new Koa() const router: Router = new Router() server.use(router.routes()) server.use(koaBody({ // 是否支持 multipart-formdata 的表单 multipart: true, })) router.post('/api/post', async (ctx, next) => { // 等待之前的插件处理完成后再运行Middleware View Function // 否则你必须将server.use()的插件应用语句放在 // Middleware View Function的下面 await next() console.log(ctx.request.body); ctx.response.body = \"HELLO KOA!\" }); server.listen(3000, \"localhost\", 128, (): void => { console.log(\"server started at http://localhost:3000\"); }) 上传文件 koa-body插件同样支持对文件自动上传，如下所示，我们在使用之前需要对其进行一些小小的配置，在获取文件后它将自动进行上传。 我们可通过ctx.request.files参数获取文件对象，与ctx.request.body一样，它也是koa-body所封装的方法： import * as fs from \"fs\" import * as path from \"path\" import * as Koa from \"koa\" import * as Router from 'koa-router' import * as koaBody from \"koa-body\" const server: Koa = new Koa() const router: Router = new Router() server.use(router.routes()) server.use(koaBody({ // 是否支持 multipart-formdata 的表单 multipart: true, formidable: { // 上传的目录 uploadDir: path.join(__dirname, 'upload'), // 保持文件的后缀 keepExtensions: true, // 最大支持上传8M的文件 maxFieldsSize: 8 * 1024 * 1024, // 文件上传前的设置 onFileBegin: (name: string, file: any): void => { const filePath: string = path.join(__dirname, \"upload\"); // 检查是否有upload目录 if (!fs.existsSync(filePath)) { fs.mkdirSync(filePath); console.log(\"mkdir success!\"); } } } })) router.post('/api/upload', async (ctx, next) => { // 等待之前的插件处理完成后再运行Middleware View Function // 否则你必须将server.use()的插件导入语句放在 // Middleware View Function的下面 await next() // 获取文件对象avatar const avatar: any | null = ctx.request.files[\"avatar\"] // 自动写入... // 将上传后的信息自动返回 ctx.response.set(\"Content-Type\", \"application/json\") ctx.response.body = JSON.stringify(avatar) }); server.listen(3000, \"localhost\", 128, (): void => { console.log(\"server started at http://localhost:3000\"); }) 文件对象中包含的属性如下： { \"size\": 文件大小, \"path\": \"上传路径\", \"name\": \"文件原本的名字\", \"type\": \"image/jpeg\", \"mtime\": \"文件最后修改时间\" } koa-body配置 以下是koa-body在进行使用时的一级配置项： 参数名 描述 类型 默认值 patchNode 将请求体打到原生 node.js 的ctx.req中 Boolean false patchKoa 将请求体打到 koa 的 ctx.request 中 Boolean true jsonLimit JSON 数据体的大小限制 String / Integer 1mb formLimit 限制表单请求体的大小 String / Integer 56kb textLimit 限制 text body 的大小 String / Integer 56kb encoding 表单的默认编码 String utf-8 multipart 是否支持 multipart-formdate 的表单 Boolean false urlencoded 是否支持 urlencoded 的表单 Boolean true text 是否解析 text/plain 的表单 Boolean true json 是否解析 json 请求体 Boolean true jsonStrict 是否使用 json 严格模式，true 会只处理数组和对象 Boolean true formidable 配置更多的关于 multipart 的选项 Object {} onError 错误处理 Function function(){} stict 严格模式,启用后不会解析 GET, HEAD, DELETE 请求 Boolean true 以下是koa-body在进行使用时的二级（formidable）配置项： 参数名 描述 类型 默认值 maxFields 限制字段的数量 Integer 1000 maxFieldsSize 限制字段的最大大小 Integer 2 1024 1024 uploadDir 文件上传的文件夹 String os.tmpDir() keepExtensions 保留原来的文件后缀 Boolean false hash 如果要计算文件的 hash，则可以选择 md5/sha1 String false multipart 是否支持多文件上传 Boolean true onFileBegin 文件上传前的一些设置操作 Function function(name,file){} ctx.req ctx.request是Koa框架所封装的请求对象，而ctx.req则是原生的http库的请求对象。 我们不建议对其进行使用，具体所包含的属性可以参照http库中的req对象。 响应相关 ctx.response ctx是一个上下文对象，你可以通过ctx.response获得本次HTTP服务的响应对象。 在响应对象中它也提供了很多属性或者方法可供我们使用，以下只例举一些比较常见的： 属性/方法 简写 描述 ctx.response.header 无 可获取或者设置响应头对象 ctx.response.headers 无 同上 response.get() ctx.get() 可获取某个响应头字段 response.has() ctx.has() 可检测某个响应头字段是否存在 response.set() ctx.set() 用来设置单个响应头字段与值，也可用一个对象来设置多个响应头字段与值 response.remove() ctx.remove() 可删除某个响应头字段 ctx.response.body ctx.body 可获取或者设置响应体，可设置string、Buffer、Stream、Object或者Array的JSON字符串以及null ctx.response.status ctx.status 可获取或者设置响应码 ctx.response.message ctx.message 可获取或者设置响应信息，它与响应码相关联 ctx.response.redirect ctx.redirect 可进行重定向跳转 ctx.response.type ctx.type 获取或者设置响应的mime-type类型 设置响应码 响应码一般来说不需要我们手动设置，它的默认值大多数情况下总是200或者204. 如果你想手动进行设置，可参照下面这个示例： router.get(\"/api/get\", async (ctx: Koa.Context, next: Koa.Next) => { ctx.response.status = 403; ctx.response.message = \"Reject service\"; }) 设置响应头 如果你没有使用TypeScript来规范你的项目代码，则可以直接对响应头做出结构改变的操作： router.get(\"/api/get\", async (ctx: Koa.Context, next: Koa.Next) => { ctx.response.headers = { \"Content-Type\": \"text/plain; charset=utf-8\" }; ctx.response.body = \"HELLO KOA!\"; }) 如果你使用了TypeScript来规范你的项目代码，则必须通过ctx.response.set()方法来设置响应头： // 设置一个 ctx.response.set(k, v) ctx.response.set(\"Content-Type\", \"text/plain; charset=utf-8\"); // 设置多个 ctx.response.set({k1 : v1, k2 : v2, ...}) ctx.response.set({ \"Content-Type\": \"text/plain; charset=utf-8\", \"Token\" : \"=fdss9d9k!-=f23\" }); 重定向 对于需要跳转的路由，可以使用ctx.response.redirect()方法来进行跳转： import * as Koa from \"koa\" import * as Router from 'koa-router' const server: Koa = new Koa() const router: Router = new Router() server.use(router.routes()) router.get(\"/\", async (ctx: Koa.Context, next: Koa.Next) => { ctx.redirect(\"/index\"); ctx.response.status = 302; }) router.get(\"/index\", async (ctx: Koa.Context, next: Koa.Next) => { ctx.response.body = \"HELLO KOA!\"; }) server.listen(3000, \"localhost\", 128, (): void => { console.log(\"server started at http://localhost:3000\"); }) CORS跨域 利用第三方插件@koa/cors解决跨域问题： $ npm install @koa/cors 它的使用非常简单，直接server.use()即可，当然你也可以对其进行详细配置，这里不再进行配置举例： import * as Koa from \"koa\" import * as cors from \"@koa/cors\" const server: Koa = new Koa() server.use(cors()) 静态资源 利用第三方插件koa-static实现静态资源的下发： $ npm install koa-static 在使用时，你必须配置当前项目下的静态资源文件目录，当用户访问这个目录中的文件时就会直接将资源进行返回了： import * as static from \"koa-static\" import * as path from \"path\" const server: Koa = new Koa() // 静态资源目录对于相对入口文件index.js的路径 const staticPath = './static' app.use(static( path.join( __dirname, staticPath) )) 例如，我们想要获取./static/avatar.jpg，只需要用GET请求下面的url即可： GET http://localhost:3000/avatar.jpg ctx.res ctx.response是Koa框架所封装的响应对象，而ctx.res则是原生的http库的响应对象。 我们不建议对其进行使用，具体所包含的属性可以参照http库中的res对象。 jsonwebtoken 基本介绍 Koa框架中提供了Cookie相关的操作，但是Cookie在目前的项目开发中使用的比较少，故这里不再进行例举，而是推荐使用第三方插件jsonwebtoken来生成JWT进行验证。 如果你不了解JWT，我之前也有写过相关的技术文章，你可以搜索并进行参考。 现在我假设你已经了解过了JWT相关的知识，让我开始第一步，安装jsonwebtoken这个插件吧。 $ npm install jsonwebtoken --save 安装后之后我们需要在src目录中新建一个JWT目录以及一个index.js文件，用来JWT存放相关的代码： $ mkdir ./src/jwt $ touch ./src/jwt/index.ts 封装使用 一般的手动签发token我们需要用到下面3种类型的数据： header：头部信息，可定义加密类型、加密方式 playload：荷载信息，可定义token过期时间、签发者、接受者以及私有声明信息，但不建议存放敏感信息 secret：密钥，该密钥只能由服务端所知晓 但是jsonwebtoken对其进行封装，直接使用config来配置即可，以下是签发和验证token的案例，默认它将采用HASH256算法进行JWT格式封装： import * as JWT from \"jsonwebtoken\" // 服务端的字符串，绝对保密 const secret = \"=937dce32&?f99\" function issueToken(userID: number, userName: string, expiration: number = 86400 * 14) { // 定义荷载信息，不要存放敏感的诸如用户密码之类的数据 const playLoad = { id: String(userID), name: userName, } // 定义配置文件，下面有一些选项也是属于荷载信息的一部分，如过期时间、签发时间、面向谁签发的 const config = { // 定义头部信息 header: {}, // 过期时间、按秒计算，也可以是字符串，如1day、1min等 expiresIn: expiration, // 在签发后多久之前这个token是无用的，如果是数字则是按秒计算 notBefore: `120ms`, // 面向谁签发的 audience: userName, // 发行者是谁 issuer: \"Node.js KOA\", // 该token的发布主题 subject: \"demo\", // 不使用时间戳 noTimestamp: true, } // 第一个对象中也可以添加额外的属性，它将作为荷载信息被格式化 return JWT.sign(playLoad, secret, config) } function verifyToken(token: string | string[]): { verify: boolean, playLoad: { id: string, name: string, nbf: number, exp: number, aud: string, iss: string, sub: string } | null } { // 如果没有抛出异常，则验证成功 try { return { playLoad: JWT.verify(token, secret), verify: true } } // 如果抛出了异常，则验证失败 catch { return { playLoad: null, verify: false } } } export { issueToken, verifyToken } 使用案例： // 手动传入用户ID以及用户姓名还有token过期时间 const token = issueToken(19, \"Jack\", 7); // 传入token验证是否成功 console.log(verifyToken(token)); 验证成功返回的结果： { playLoad: { id: '19', name: 'Jack', nbf: 1633537512, exp: 1633537519, aud: 'Jack', iss: 'Node.js KOA', sub: 'demo' }, verify: true } 实战演示 我们以一个简单的案例来进行说明，后端有2个api接口，分别是index和login。 若用户第一次访问主页，则必须先进行登录后才能访问主页，此后的20s内用户不用再重新登录： import * as Koa from \"koa\" import * as Router from 'koa-router' import * as koaBody from 'koa-body' import * as cors from \"@koa/cors\" import * as JWT from \"./jwt/index\" // 模拟数据库 const userDataBase: { id: number, username: string, password: string, age: number }[] = [ { id: 1, username: \"Jack\", password: \"123456\", age: 18 } ] const server: Koa = new Koa() const router: Router = new Router() server.use(cors()) server.use(koaBody({ // 是否支持 multipart-formdata 的表单 multipart: true, })) server.use(router.routes()) server.use(async (ctx: any, next: any) => { await next() // 由于所有返回的数据格式都是JSON，故这里直接进行生命 ctx.response.set(\"Content-Type\", \"application/json\"); }) router.get(\"/api/index\", async (ctx: Koa.Context, next: Koa.Next) => { await next() const token: string | string[] = ctx.request.get(\"JWT\"); // 如果能获取token就进行验证，判断是否是伪造请求 if (token) { const { verify, playLoad } = JWT.verifyToken(token) if (verify) { // 验证通过，直接返回playLoad给前端 ctx.response.body = JSON.stringify({ code: 200, message: playLoad }) } else { // 验证未通过，token无效或者已过期 ctx.response.body = JSON.stringify({ code: 403, message: \"Please do not forgery information\" }) } } // 获取不到token，你应该先进行登录 else { ctx.response.body = JSON.stringify({ code: 401, message: \"please log in first\" }) } }) router.post(\"/api/login\", async (ctx: Koa.Context, next: Koa.Next) => { await next() const name: string = ctx.request.body.name; const pwd: string = ctx.request.body.pwd; // 如果用户存在于数据库中，就签发token，并且设置在响应头中返回 for (const row of userDataBase) { if (row.username === name && row.password === pwd) { const token = JWT.issueToken(row.id, row.username, 20); // 设置响应头JWT ctx.response.set(\"JWT\", token); ctx.response.body = JSON.stringify({ code: 200, message: \"login successful\" }); return } } // 用户不存在 ctx.response.body = JSON.stringify({ code: 406, message: \"Login error, username or password is incorrect\" }) }) server.listen(3000, \"localhost\", 128, (): void => { console.log(\"server started at http://localhost:3000\"); }) 代码测试 下面我们使用postMan来测试一下这个功能过程。 首先是用户第一次到我们的网站尝试访问主页，此时会提示它应该先进行登录： 然后我们进行登录，下面是登录错误的情况，数据库没有这个用户： 下面是登录成功后的情况，它会返回给你一个JWT的响应字段： 我们需要复制这个JWT响应字段的value值，并且将它添加到访问index时的请求头里，注意请求头的字段也必须是JWT，因为我们的后端做了限制，那么接下来的20s内你对index的访问都将是正常的： 如果token过期或者被伪造，它将提示你不要伪造token，其实这里有心的朋友可以处理的更细节一点： 其他插件推荐 好了，关于Koa框架的基本使用目前就到此结束了。 下面推荐一些Koa框架中可能会被使用到的插件： koa-compress：用于压缩内容，以便更快的完成HTTP响应 koa-logger：提供日志输出 koa-view：提供视图模板渲染，适用于前后端混合开发 koa-jwt：也是一款提供JWT认证的插件，不同于jsonwebtoken，它的局限性比较清 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:48 "},"前端专栏/Vue3/summary.html":{"url":"前端专栏/Vue3/summary.html","title":"Vue3","keywords":"","body":" 基础知识 mustache 基本指令 v-bind操作属性样式 methods和computed v-on事件监听 v-for和v-if v-model双向绑定 watch数据侦听 数组响应 组件化开发 组件中通信 组件化插槽 生命周期函数 动画效果 自定义指令 Mixins teleport传送门 CompositionAPI Vue-CLI Vue-Router Vue-X axios 其他资源 一个案例 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:48 "},"前端专栏/Vue3/基础知识.html":{"url":"前端专栏/Vue3/基础知识.html","title":"基础知识","keywords":"","body":"基本介绍 Vue.js Vue是一款优秀的前端开源框架，也是现在WEB工程师必备的一项技能。 它是一个渐进式的框架，所谓渐进式是指你可以对你的项目代码进行分批次的重构，比如最开始你的项目中所有页面的代码全部是由jQuery构建的，如果想将其重构为Vue的话则可以对某一些页面进行重写，这并不会影响其他页面的正常使用。 目前，Vue3正式版已经推出了有一些时间了，那么本专栏就是基于Vue3开始的一个新系列，希望能对大家带来帮助，案例统一采用Vue3新语法进行演示，从Options API（选项式API）逐渐过渡到Composition API（组合式API），在此期间如遇见2个版本之间常见的差异，也会指出来。 安装方式 如果你构建的是一个工程化项目，推荐使用npm进行Vue的安装： # 最新稳定版 $ npm install vue 如果你正在学习Vue3，推荐使用非工程化的脚本引入式开始Vue的探究： 下面再放上一个Vue2的CDN引入： Vue特点 声明式编程 使用Vue开发和jQuery开发是两种截然不同的体验，Vue是声明式的编程语言，而jQuery是命令式的编程语言。 使用jQuery你可能会经常想，下一步我该怎么做，从细节到全局。 但是使用Vue则是会有一个很良好的全局观，是由全局到细节的。 这里不多说明，后续将会慢慢体会。 单页面开发 Vue是单页面开发，即页面用不刷新，用一个页面来展示不同的内容。 在Vue中有一个组件的概念。一个页面上有一个根组件，并且其中包含很多子组件，通过用户不同的操纵状态由Vue决定展示或隐藏哪些其内部的子组件。 这其实就是单页面开发的概念，如图所示，子组件是可以自由替换的，但是根组件是不变的，这样就能达到不刷新页面也能更新内容的方式，像这样的单页富应用程序也被称为SPA： 简单体验 初次上手 下面是使用Vue3打印hello world的一个案例，通过这个小案例你可以简单体会声明式编程与命令式编程两种截然不同的风格。 首先要创建一个Vue应用 使用mount()来挂载元素，mount()中支持通过CSS选择器来拿到原生的DOM元素，注意！它不支持挂载或者 将需要展示的数据定义在data中，data必须是一个函数，且返回一个对象 使用Vue的mustache语法对data中返回对象的数据进行渲染，将其展示到被挂载元素的模板上 示例如下： {{message}} \"use strict\"; const app = Vue.createApp({ data() { return { message: \"hello world\" } } }).mount(\"#app\"); 如果你使用的是Vue2版本，则运行上面的小案例可能会出现一些问题，Vue2中虽然标签全局导入了Vue对象，但它是一个构造函数，你必须通过new来实例化该对象，并且通过mount()方法的元素挂载要变为通过el的属性元素挂载： {{message}} \"use strict\"; const app = new Vue({ el: \"#app\", data() { return { message: \"hello world\" } } }); data data我们可以将其理解为数据仓库，它存储了页面中需要用到的所有数据。 大体可分为2类： 需要展示的数据 需要提交的数据 在Vue3中，data必须是一个函数，且返回一个对象： const app = Vue.createApp({ data() { return { message: \"hello world\" } } }).mount(\"#app\"); 但是在Vue2中，它可以直接定义成一个对象，这在Vue3中是不被支持的： const app = new Vue({ el: \"#app\", data: { message: \"hello world\" } }); 当然Vue2中也支持Vue3里对data的定义形式： const app = new Vue({ el: \"#app\", data(){ return { message: \"hello world\" } } }); 为什么Vue2和Vue3会有这2种差别呢？其实这里涉及到后面要学习的一个组件化开发的知识，Vue2中将data定义成一个对象的方式虽然是允许的，但是会出现一些问题，所以干脆Vue3中不支持这种定义方法了，算是一个小小的改动。 在后面组件化开发中会详细提到。 代理器 Vue中大量使用了对象代理Proxy，如下所示，message明明是data函数中返回的对象属性，但是我们却可以通过Vue应用app对其进行访问： 对象代理不光在此处得以体现，在其他地方也会见到。 如下示例，我们为按钮增加了一个事件，当点击按钮后，的文本数值会发生变化： 仔细观察下面的代码我们也可以看到，当事件触发后，在methods对象的事件回调方法中调用this，也会被代理到data函数中返回的对象： body { display: flex; justify-content: center; align-items: center; } p { text-align: center; } {{number}} + - \"use strict\"; const app = Vue.createApp({ data() { return { number: 0 } }, methods: { add(event) { this.number++; }, sub(event) { this.number--; } } }).mount(\"#app\"); MVVM MVVM是Model-View-ViewModel的缩写，它是一种软件设计思想。 View：视图层（UI界面） ViewModel：业务逻辑层（一切JavaScript代码均可视为存在于该层中） Model：数据层（存储数据及的数据的处理相关的地方） 当Vue通过对DOM元素进行事件监听后，则可以动态的从后端服务器获取数据，同时被监听的DOM元素当状态发生改变时，也将通过Vue把信息传递给后端服务器。 对于上述代码来说，我们可以进行如下的划分： View视图层：被挂载元素的模板，即#app中的内容均属于视图层 ViewModel模型层：整个标签中的内容，均可属于模型层 Model数据层：Vue应用中data返回的对象可属于数据层 开发工具 devtool 学习Vue时，推荐安装Vue.js devtools工具，能高效的让我们更加探究Vue的变化。 Vue3和Vue2都支持的版本，推荐安装。 点我跳转至Chrome商店 仅支持Vue2的版本。 点我跳转至Chrome商店 在下载安装完成后，我们需要重新打开Chrome，然后按下F12在控制台即可看到它的选项： vscode 如果你使用vscode进行开发，那么下面的这个插件是我强烈推荐的： Vetur – 支持语法高亮、智能感知、Emmet等功能 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:48 "},"前端专栏/Vue3/mustache.html":{"url":"前端专栏/Vue3/mustache.html","title":"mustache","keywords":"","body":"mustache 名称由来 mustache本意为胡子的意思，因其Vue中模板渲染语法格式长的比较像2片胡子，故便有了这样的名字： {{变量}} 当使用mustache语法对模板进行渲染操作时，Vue内部会查找数据层中是否具有该变量，如果有则将该变量的值替换到模板上。 它与后端语言中的模板渲染非常的相似，如果你有前后端混合式开发的经验，那么掌握它应该再轻松不过了。 初学者应当注意一点，只有在被挂载的元素下才可使用mustache语法，如果在被挂载元素之外使用mustache语法是不生效的。 内容渲染 如下所示，我们通过mustache渲染出一个基本的个人信息： name : {{information.name}} age : {{information.age}} gender : {{information.gender}} \"use strict\"; const app = Vue.createApp({ data() { return { information: { name: \"Jack\", age: 19, gender: \"male\" } } } }).mount(\"#app\"); 四则运算 在mustache语法中，可以进行四则运算，如下所示： {{x + y}} \"use strict\"; const app = Vue.createApp({ data() { return { x : 100, y : 200 } } }).mount(\"#app\"); 调用方法 mustache语法中也能够调用方法，总之{{}}中可以进行任何操作，他都会向当前Vue应用去请求获取这些属性或方法： {{show()}} \"use strict\"; const app = Vue.createApp({ methods: { show() { return \"Yes\"; } } }).mount(\"#app\"); 响应式渲染 当Vue中的属性发生更改时，会响应到页面中，此时Vue会重新渲染DOM，响应式的前端框架也是Vue的一大特色： 代码如下： {{ name }} \"use strict\"; const app = Vue.createApp({ data(){ return { name : \"Jack\" } } }).mount(\"#app\"); 版本差异 废弃的过滤器 在Vue2的版本中提供了过滤器的选项，旨在让模板的渲染具有更多的可能性。 但由于功能过于鸡肋，于是在Vue3版本中移除了。 全局过滤器 全局过滤器可以由所有的的Vue组件使用。它应当定义在Vue.filter()中，且是一个函数，使用mustache语法时加上|即可主动完成调用。 {{currentTime | timeFormat}} \"use strict\"; Vue.filter(\"timeFormat\", value => { // value就是 | 左边的值 return moment(value).format(\"YYYY-MM-DD HH:mm:ss\"); }) const app = new Vue({ el: \"#app\", data() { return { currentTime: new Date() } } }) 局部过滤器 局部过滤器仅能由当前的的Vue组件使用。它应当定义在Vue示例中，关键字为filters，且是一个对象，使用mustache语法时加上|即可主动调用filters下的方法。 {{currentTime | timeFormat}} \"use strict\"; const app = new Vue({ el: \"#app\", data() { return { currentTime: new Date() } }, filters: { timeFormat(value) { // value就是 | 左边的值 return moment(value).format(\"YYYY-MM-DD HH:mm:ss\"); } } }) 过滤器参数 过滤器函数中的第一个参数固定死为|左边的值。 当我们有多个参数时，可以进行如下的传递方式，下面的示例将计算七天后的时间是多久： {{currentTime | addTime(7,\"days\")}} \"use strict\"; const app = new Vue({ el: \"#app\", data() { return { currentTime: new Date() } }, filters: { addTime(value, ...arg) { // value就是 | 左边的值,arg是右边的两个值 return moment(value).add(...arg).format(\"YYYY-MM-DD HH:mm:ss\"); } } }) Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:48 "},"前端专栏/Vue3/基本指令.html":{"url":"前端专栏/Vue3/基本指令.html","title":"基本指令","keywords":"","body":"什么是指令 指令 (Directives)是指带有v-开头的元素属性，这些属性都是由Vue所提供的，具有特殊的含义及用途。 在Vue解析模板时，如果发现某个DOM元素上具有Vue指令，则会对其进行特殊处理。 v-once 当标签中添加v-once指令时，标签渲染的内容将是固定的，页面不会随着数据层数据的动态改变而进行响应式的改变。 代码示例： div:not([v-once]) span { font-style: normal; } div[v-once] span { font-style: italic; } {{number}} {{number}} \"use strict\"; const app = Vue.createApp({ data() { return { number: 100 } } }).mount(\"#app\"); v-text 使用v-text指令和mustache语法渲染内容并无太大差异，它们的渲染结果都是相同的，唯一区别在于一个是通过指令渲染内容，一个是通过mustache语法渲染内容： {{message}} 注意，无论是mustache语法还是v-text指令，如果被渲染的内容是一个HTML字符串，它们将不会进行解析操作，而是将 这样做的意义在于防范XSS攻击： 代码示例： {{content}} \"use strict\"; const app = Vue.createApp({ data() { return { content : \"hello world\" } } }).mount(\"#app\"); v-html 如果被渲染的内容是一个HTML字符串，我们想让它生效则可使用v-html指令进行渲染。 使用方式和v-text一致，但是渲染结果会有不同： 代码示例： \"use strict\"; const app = Vue.createApp({ data() { return { content : \"hello world\" } } }).mount(\"#app\"); v-show v-show指令的值为false时，相当于将该标签添加上display:none的样式： 代码示例： {{message}} \"use strict\"; const app = Vue.createApp({ data() { return { message: \"hello world\", status: true } } }).mount(\"#app\"); v-pre 当一个标签添加上该指令后，该标签的内容将不会被Vue进行渲染，即使你在该标签内部使用了mustache语法。 代码示例： {{message}} {{message}} \"use strict\"; const app = Vue.createApp({ data() { return { message: \"hello world\" } } }).mount(\"#app\"); v-cloak 在网络情况较差的环境下，可能会出现模板渲染不及时的问题。 使用v-cloak指令搭配css样式可挡住{{}}模板语法，使用户获得更好的体验。 注意，在工程化的Vue项目中，v-clock默认是手动开启的，并不需要我们额外的做单独的配置 这也侧面说明v-clock实际上在真正生产开发时使用的很少 代码示例，你可以通过取消#app的v-cloak指令来查看不同的效果： [v-cloak]{ display: none; } {{message}} \"use strict\"; setTimeout(() => { const app = Vue.createApp({ data() { return { message: \"hello world\" } } }).mount(\"#app\"); }, 3000); Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:48 "},"前端专栏/Vue3/v-bind操作属性样式.html":{"url":"前端专栏/Vue3/v-bind操作属性样式.html","title":"v-bind操作属性样式","keywords":"","body":"属性绑定 v-bind 通过v-bind指令可以单向的为模板元素的属性动态绑定一个属性值，在使用时应当注意以下2点： 被双引号包裹的属性值没有被任何其他引号包裹时，该值将会被认为是Vue应用中数据层的某一个数据，会在Vue应用中先查找该数据再进行赋值 被双引号包裹的属性值同时还被其他引号所包裹时，该属性值将会被认为是一个普通的字符串，会直接进行赋值 如下示例。 1）被双引号包裹的属性值没有被任何其他引号包裹时，将访问data方法中返回的对象里的desc属性： ??? --> ??? \"use strict\"; const app = Vue.createApp({ data() { return { desc: \"this is a div\" } } }).mount(\"#app\"); 2）被双引号包裹的属性值同时还被其他引号所包裹时，该属性值将被当做普通字符串处理： ??? --> ??? \"use strict\"; const app = Vue.createApp({ data() { return { desc: \"this is a div\" } } }).mount(\"#app\"); 简写形式 我们可以省略v-bind的前缀，直接采用:进行绑定，如下所示： ??? ??? 样式操作 :class对象操作 将:class的属性值定义为一个对象，若key的value为true，则将该key进行应用，反之则不进行应用。 除此之外，你也可以定义class属性，用于设置一些永远不会改变的样式。 语法格式如下： 内容 在下面的例子中，我们定义了.red、.italic、.opacity三个类，通过:class对象中不同key的状态切换，可以达到不同的样式效果： 代码示例： .red { color: red; } .italic { font-style: italic; } .opacity { opacity: 0.5; } hello world \"use strict\"; const app = Vue.createApp({ data() { return { redStatus: true, italicStatus: true, opacityStatus: true, } } }).mount(\"#app\"); :class数组操作 将:class的属性值定义为一个数组，数组中的元素将被当做类名进行应用。 使用场景一般较少，语法格式如下： 内容 我更喜欢将它这样进行使用： 代码示例： .red { color: red; } .italic { font-style: italic; } .opacity { opacity: 0.5; } hello world \"use strict\"; const app = Vue.createApp({ data() { return { styleClass: [\"red\", \"opacity\", \"italic\"] } } }).mount(\"#app\"); :style对象操作 将:style的属性值定义为一个对象，key为css的样式名，value为css的设置值。 除此之外，你也可以定义style属性，用于设置一些永远不会改变的样式。 注意它的格式是这样的，:style中的key必须为小驼峰式命名法，如果你对key进行了引号包裹，则可以使用-分割命名： 内容 示例演示： 代码示例： hello world \"use strict\"; const app = Vue.createApp({ data() { return { bgStyle:\"linear-gradient(90deg, #667eea 0%, #764ba2 100%)\" } } }).mount(\"#app\"); :style数组操作 除开可以使用对象语法绑定:style属性，也可以通过数组语法进行绑定。 数组中的元素必需是能够从Vue实例中获取到的数据。 示例演示： 代码示例： hello world \"use strict\"; const app = Vue.createApp({ data() { return { fontStyle: { \"font-size\": \"24px\", \"font-style\": \"italic\" }, ColorStyle: { \"color\": \"red\", \"background-color\": \"green\" }, } } }).mount(\"#app\"); Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:48 "},"前端专栏/Vue3/methods和computed.html":{"url":"前端专栏/Vue3/methods和computed.html","title":"methods和computed","keywords":"","body":"methods 基本使用 methods中定义的方法通常都是搭配事件监听做回调的，当然我们也可以主动的对其进行调用。在使用时需要注意以下2点： methods下所定义的方法必须加括号才能完成调用 methods对象内部的方法如果想调用同一Vue应用下的方法或者属性，可使用this进行调用，Vue内部会通过代理器进行查找 如下示例，我们将计算书籍的总价格： 代码示例： books total price: {{getTotalPrice()}} \"use strict\"; const app = Vue.createApp({ data() { return { bookList: [ { name: \"JavaScript\", price: 69 }, { name: \"HTML5\", price: 43 }, { name: \"CSS3\", price: 58 } ], } }, methods: { getTotalPrice() { return this.bookList.reduce((pre, cur, index, ary) => { return pre + cur.price; }, 0); } } }).mount(\"#app\"); computed 基本使用 总价格更像是一个属性，而并非是一个方法，所以针对需要有复杂计算的数据结果，我们可以在Vue应用中定义computed计算属性，再交由mustache进行渲染。 在使用时需要注意以下2点： computed下所定义的方法在mustache渲染时不需要加括号就能调用，因此它更像是一个方法 computed对象内部的方法如果想调用同一Vue应用下的方法或者属性，可使用this进行调用，Vue内部会通过代理器进行查找 如下示例，我们将计算书籍的总价格： 代码示例： books total price: {{totalPrice}} \"use strict\"; const app = Vue.createApp({ data() { return { bookList: [ { name: \"JavaScript\", price: 69 }, { name: \"HTML5\", price: 43 }, { name: \"CSS3\", price: 58 } ], } }, computed: { totalPrice(){ return this.bookList.reduce((pre, cur, index, ary)=>{ return pre + cur.price }, 0) } } }).mount(\"#app\"); 实现原理 computed的内部实现原理是定义了getter方法实现的，我们可以对它进行复现： \"use strict\"; let bookShop = { bookList: [ { book_name: \"JavaScript\", price: 99 }, { book_name: \"CSS3\", price: 80 }, { book_name: \"HTML5\", price: 72 }, ], get total() { return this.bookList.reduce((prev, cur, index, array) => { return prev + cur.price; }, 0) } }; console.log(bookShop.total); // 251 其实使用Proxy全局对象代理可能会更好一些，如下所示： \"use strict\"; const Vue = { data() { return { bookList: [ { name: \"JavaScript\", price: 69 }, { name: \"HTML5\", price: 43 }, { name: \"CSS3\", price: 58 } ], } }, computed: { totalPrice() { return this.bookList.reduce((pre, cur, index, ary) => { return pre + cur.price }, 0) } }, methods: { getTotalPrice() { return this.bookList.reduce((pre, cur, index, ary) => { return pre + cur.price }, 0) } } } const app = new Proxy(Vue, { // 包含属性和方法以及计算属性 dataObject: Object.assign(Vue.data(), Vue.methods, Vue.computed), get(obj, attribute) { // 如果访问的是属性和方法，则直接返回 if (attribute in obj.data() || attribute in obj.methods) { return this.dataObject[attribute] } // 如果是计算属性，则自动调用 else if (attribute in obj.computed) { return this.dataObject[attribute]() } }, set(_, attribute, value) { dataObject[attribute] = value; return true; } }); app.bookList[0].price = 100; console.log(app.bookList); console.log(app.totalPrice); console.log(app.getTotalPrice()); // [ // { name: 'JavaScript', price: 100 }, // { name: 'HTML5', price: 43 }, // { name: 'CSS3', price: 58 } // ] // 201 // 201 指定get/set computed中可以指定一个对象，该对象必须提供get和set方法。 get：当获取该computed时自动触发 set：当设置该computed时自动触发，value属性为设置的新值 示例如下，当获取number时实际上获取的是_n，当设置number时实际上是设置的_n： {{number}} \"use strict\"; const app = Vue.createApp({ data() { return { _n: 100 } }, computed: { number: { get() { return this._n }, set(value) { this._n = value } } } }).mount(\"#app\"); 两者异同 同-响应特性 如果修改了数据源，那么计算属性和方法都会重新进行页面渲染。 如下所示，书籍总价本来为170，当我们修改其中任意一本书的价格后，书籍总价格也将发生改变： 代码示例： computed price: {{totalPrice}} methods price: {{getTotalPrice()}} \"use strict\"; const app = Vue.createApp({ data() { return { bookList: [ { name: \"JavaScript\", price: 69 }, { name: \"HTML5\", price: 43 }, { name: \"CSS3\", price: 58 } ], } }, computed: { totalPrice() { return this.bookList.reduce((pre, cur, index, ary) => { return pre + cur.price }, 0) } }, methods: { getTotalPrice() { return this.bookList.reduce((pre, cur, index, ary) => { return pre + cur.price }, 0) } } }).mount(\"#app\"); 异-缓存特性 computed具有缓存特性，即多次调用只会调用一次，只有当数据源发生改变时才会自行调用一次。 而methods没有缓存特性，调用几次就执行几次，并且当数据源发生改变时也会自动调用之前的次数。 如下所示，下面模板中3次调用了computed，实际上它只执行了1次，而methods同样也是3次调用，但是执行了3次，当数据源发生改变后computed会多加1次，而methods会每一个都重新执行1次，总计为新增3次： 代码示例： computed total : {{total}} computed total : {{total}} computed total : {{total}} computed call count : {{ccc}} methods getTotal : {{getTotal()}} methods getTotal : {{getTotal()}} methods getTotal : {{getTotal()}} methods call count : {{mcc}} \"use strict\"; let computedCallCount = 0; let methodsCallCount = 0; const app = Vue.createApp({ data() { return { num1: 100, num2: 100, ccc: computedCallCount, mcc: methodsCallCount, } }, computed: { total() { computedCallCount++; this.ccc = computedCallCount; return this.num1 + this.num2; } }, methods: { getTotal() { methodsCallCount++; this.mcc = methodsCallCount; return this.num1 + this.num2; } } }).mount(\"#app\"); Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:48 "},"前端专栏/Vue3/v-on事件监听.html":{"url":"前端专栏/Vue3/v-on事件监听.html","title":"v-on事件监听","keywords":"","body":"事件监听 v-on 通过v-on可对DOM元素进行事件监听，当用户某一行为触发后将自动执行mthods中定义的方法。 语法格式如下，当无参数进行传递时，可省略括号的书写： 点我 下面是一个小案例： 代码示例： + &nbsp;{{number}}&nbsp; - \"use strict\"; const app = Vue.createApp({ data() { return { number: 0 } }, methods: { add() { this.number++; }, sub() { this.number--; } } }).mount(\"#app\"); 简写形式 我们可以省略v-on:的前缀，使用@来进行代替，如下所示： 点我 注意区分与v-bind的区别： 点我 ??? 事件对象 无参调用与事件对象 当没有参数进行传递时，回调函数默认接收一个形参即Event事件对象： click me \"use strict\"; const app = Vue.createApp({ methods: { callback(event) { console.log(event); } } }).mount(\"#app\"); $event与事件对象 当有参数进行传递时，我们必须手动传入事件对象，且事件对象必须定义为$event： click me \"use strict\"; const app = Vue.createApp({ methods: { callback(event, ...args) { console.log(event); console.log(args); } } }).mount(\"#app\"); 事件修饰符 .once 使用.once修饰符后，该事件只会监听一次。当执行完这一次动作后将取消监听： click me \"use strict\"; const app = Vue.createApp({ methods: { callback(event, str) { console.log(str); } } }).mount(\"#app\"); .prevent 使用.prevent修饰符来阻止默认事件的发生： go to google search \"use strict\"; const app = Vue.createApp({ methods: { callback(event, str) { console.log(str); } } }).mount(\"#app\"); .stop 使用.stop修饰符阻止事件冒泡： .father { width: 200px; height: 200px; background-color: #ddd; } .son { width: 100px; height: 100px; background-color: #ccc; } \"use strict\"; const app = Vue.createApp({ methods: { fatherCallback(event) { console.log(\"father callback\"); }, sonCallback(event) { console.log(\"son callback\"); } } }).mount(\"#app\"); .self 使用.self修饰符，也可以防止事件冒泡。只有点击到自己时才触发，不会通过冒泡触发： .father { width: 200px; height: 200px; background-color: #ddd; } .son { width: 100px; height: 100px; background-color: #ccc; } \"use strict\"; const app = Vue.createApp({ methods: { fatherCallback(event) { console.log(\"father callback\"); }, sonCallback(event) { console.log(\"son callback\"); } } }).mount(\"#app\"); .captrue 使用.capture，开启事件捕获。当子元素点击事件后，事件被派发到父元素时，会先执行完父元素监听事件的回调函数，再执行子元素监听事件的回调函数。 注意区分事件冒泡与事件捕获： 事件捕获：在子元素事件发生后先运行父元素的同事件回调函数、再运行子元素的事件回调函数 事件冒泡：在子元素事件发生后先运行子元素的事件回调函数、再运行父元素的同事件回调函数 代码示例： .father { width: 200px; height: 200px; background-color: #ddd; } .son { width: 100px; height: 100px; background-color: #ccc; } \"use strict\"; const app = Vue.createApp({ methods: { fatherCallback(event) { console.log(\"father callback\"); }, sonCallback(event) { console.log(\"son callback\"); } } }).mount(\"#app\"); 鼠标修饰符 鼠标操作也有常见的修饰符，如下所示： .left：按下左键 .right：按下右键 .middle：按下中间 案例释义： .area { width: 200px; height: 200px; display: inline-block; background-color: #ddd; margin-left: 1rem; text-align: center; line-height: 200px; } 1 2 3 4 \"use strict\"; const app = Vue.createApp({ methods: { callback(event) { console.log(\"mouse callback\"); } } }).mount(\"#app\"); 键盘修饰符 使用keyup和keydown来进行键盘事件的监听。 keyup：按键按下 keydown：按键松开 键盘操作也有常见的修饰符，如下所示： .enter：按下回车 .tab：按下制表符 .delete：按下删除或者退格 .esc：按下退出 .ctrl：按下CTRL按键 .alt：按下ALT按键 .shift：按下SHIFT按键 除此之外，你也可以使用其他的修饰符，由于键盘按键较多这里不再进行例举。 如下示例： \"use strict\"; const app = Vue.createApp({ methods: { callback(event) { console.log(\"keyboard callback\"); } } }).mount(\"#app\"); 修饰符连用 修饰符可以连用，但是连用时一定要注意它们的顺序。 如下所示： 点我 这个例子的意思非常明显，只执行一次，阻止默认事件。 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:48 "},"前端专栏/Vue3/v-for和v-if.html":{"url":"前端专栏/Vue3/v-for和v-if.html","title":"v-for和v-if","keywords":"","body":"流程控制 v-for 通过v-for可快速的进行循环，从而能够使开发人员更方便的构建HTML结构。 如下示例，我们通过v-for指令迅速的生成了一份学生名单： 代码示例： table, table * { border: 1px solid #aaa; border-collapse: collapse; width: 400px; text-align: center; } table caption { background-color: #ddd; font-weight: bold; font-size: 1.2rem; } table tbody tr:nth-of-type(odd) { background-color: #ddd; } table tbody tr td { cursor: pointer; } table tfoot tr td { text-align: right; padding-right: 1rem; } student message name age gender {{row.name}} {{row.age}} {{row.gender}} statistics time:1998-08-02 \"use strict\"; const app = Vue.createApp({ data() { return { studentMessage: [ { id: 1, name: \"Jack\", age: 18, gender: \"male\" }, { id: 2, name: \"Tom\", age: 21, gender: \"male\" }, { id: 3, name: \"Mary\", age: 17, gender: \"female\" }, { id: 4, name: \"Anna\", age: 18, gender: \"female\" } ] } } }).mount(\"#app\"); 遍历数组 对数组的遍历，可使用for/in来进行操作，如下所示： {{value}} - {{index}} 也可以进行for/of操作，效果同for/in相同： {{value}} - {{index}} 除此之外，你也可以先对数组创建出一个迭代器后再对其进行遍历操作，如kes()、values()、entries()等这些方法都是可行的： {{value}} - {{index}} 遍历对象 对对象的遍历，可使用for/in来进行操作，如下所示： {{value}} - {{key}} - {{index}} 也可以进行for/of操作，效果同for/in相同： {{value}} - {{key}} - {{index}} 除此之外，你也可以先对对象创建出一个迭代器后再对其进行遍历操作，如Object.kes()、Object.values()、Object.entries()等这些方法都是可行的： {{value}} - {{index}} key属性 在使用v-for指令时，你应当同时为元素指定一个key属性，并且该属性必须和被渲染的值具有一对一的关系，这样做可以提升后期的操作效率。 其实Vue并不会直接操纵DOM对象，在Vue与真实DOM之间存在着一层虚拟DOM，Vue的操作会先映射到虚拟DOM上，然后再由虚拟DOM映射到真实DOM上。 我们以操纵数组为例： {{value}} - {{index}} 如果你在使用v-for渲染数组时指定了key属性，它将会依照diff算法将生成的标签在虚拟DOM中直接进行插入，这是非常高效的，它不会引起后面元素的位置后移： 如果你未在使用v-for渲染数组时指定key属性，那么在插入新元素时将会引起后面元素的位置后移，在元素较多时会拉低操纵效率： 我们用一个简单的例子来进行举例，下面有4个radio单选框，我们先选中值为D的单选框，然后再D的前面插入一个值为C的单选框。 首先是未指定key属性的情况，可以发现这个时候出现了一个BUG，本来我们选中的是D，但是插入C后它选中的变成了C： 接下来我们指定key属性，就可以避免这个BUG了： 代码如下： add radio C {{value}} \"use strict\"; const app = Vue.createApp({ data() { return { ary: [\"A\", \"B\", \"D\", \"E\"] } }, methods: { addElement(event) { this.ary.splice(2, 0, \"C\") } } }).mount(\"#app\"); 因此，在使用v-for进行循环时我们一定要注意添加key属性，推荐使用id作为key的值，不推荐使用index，因为index总是能够发生变化，不够稳定。 分支循环 v-if v-if指令的条件如果为true，那么将渲染该标签及其内部的子标签，如果为false时则不会进行渲染。 它类似于v-show，但是实际上两者之前还有很大的差别，可以暂时先这么认为： {{condition}} {{condition}} \"use strict\"; const app = Vue.createApp({ data() { return { condition: true } } }).mount(\"#app\"); v-else v-else指令应该和v-if指令连用。效果与v-if相反。 这两组指令一个代表如果怎样就渲染，一个代表否则怎样就渲染。 {{condition}} {{condition}} \"use strict\"; const app = Vue.createApp({ data() { return { condition: true } } }).mount(\"#app\"); v-else-if v-else-if是额外的判断条件，当有v-if/v-else/v-else-if在时，只会执行其中的一条。 = 80\">成绩优秀 = 60\">成绩及格 = 40\">成绩一般 90\">成绩较差 \"use strict\"; const app = Vue.createApp({ data() { return { grades: 80 } } }).mount(\"#app\"); v-if和v-show v-if和v-show的关键区别如下： v-if在条件为false时，标签会进行销毁，条件为true时会重新进行创建，整个过程会重新渲染DOM v-show在条件为false时，标签不会进行销毁而是通过css进行隐藏，整个过程不会重新渲染DOM 综合来看，v-show的性能要高于v-if，但是当出现多个组件频繁互相切换的常见，还是推荐使用v-if，因为它的代码逻辑会更清晰。 版本差异 Vue2中的key 在Vue2中，我们的真实DOM在某些情况下的渲染结果与我们料想之中的渲染结果存在一些偏差。 如下所示，我们定义了2个框，用户可以自己选择进行手机登录还是邮箱登录。 但是当用户在一个框中输入值后再进行切换，就会出现窜值的情况（即不同的输入框切换会保留一样的值）： 造成这种结果的原因是由于虚拟DOM的渲染复用，虚拟DOM进行渲染时会尽量复用已存在的组件，而不是创建新的组件。 上述示例中看起来写了两个，其实是被复用了，所以导致窜值问题的出现，使用key属性可解决这个问题： 手机 邮箱 \"use strict\"; const app = new Vue({ el: \"#app\", data() { return { type: \"phone\", } }, }); 在Vue3中，v-if已经不需要再手动的添加key了，因为Vue内部会自动的为每个添加了v-if指令的标签生成一个key属性。但是v-for指令中的key依旧是必须的，不要将两者搞混淆了。 优先级更改 Vue中允许同时在一个元素上使用v-if和v-for指令。 Vue2：v-for的优先级高于v-if，它会先进行渲染，再决定要不要将渲染结果映射到真实DOM Vue3：v-if的优先级高于v-for，它会先查看条件是否满足，再决定要不要进行渲染 我们并不推荐在同一个元素上使用v-if和v-for，这并不是一个良好的编码习惯。 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:48 "},"前端专栏/Vue3/v-model双向绑定.html":{"url":"前端专栏/Vue3/v-model双向绑定.html","title":"v-model双向绑定","keywords":"","body":"双向绑定 v-model v-model指令常用于与from表单元素做绑定使用。 当表单内容发生改变时，数据层的数据也会发生改变 当数据层的数据发生改变时，表单内容也会发生改变 这种绑定关系是双向的，因此v-model也被称之为双向绑定： 代码示例： phone: \"use strict\"; const app = Vue.createApp({ data() { return { phoneNumber: \"\" } }, }).mount(\"#app\"); v-bind和v-model的区别 很多初学者可能疑惑v-bind和v-model的区别，这里特别指出一下： v-bind常用于与元素的属性做绑定，并且这个绑定关系是单向的，只有当数据层的数据发生改变时，元素的属性才会发生变更 v-model常用于与表单元素做绑定，并且这个绑定关系是双向的，无论哪一方的数据发生改变，都会影响另一方数据的改变 举个例子，我们在之前没有学习Vue时要通过AJAX提交表单数据时只有从元素身上获取value属性值后再进行提交，但是有了Vue的双向绑定之后这一切都变的非常简单，如下示例，我们只需要将需要提交的表单元素和数据层中的提交数据做绑定，然后就可以快速的进行提交了： name password login \"use strict\"; const app = Vue.createApp({ data() { return { username: \"\", password: \"\" } }, methods: { login(event) { const url = \"http://localhost:3000/\"; axios.post( url, { username: this.username, password: this.password } ).then(response => { switch (response.status) { case 200: console.log(response.data); break default: console.log(\"login fail!\"); } }) } } }).mount(\"#app\"); 后端代码，采用Node.js完成： const http = require('http'); const server = http.createServer((req, res) => { res.setHeader(\"Access-Control-Allow-Origin\", \"*\"); if (req.method === \"OPTIONS\") { res.setHeader(\"Access-Control-Allow-Headers\", \"*\"); } let data = \"\"; req.on(\"data\", chunk => { data += chunk.toString(); }) req.on(\"end\", () => { res.writeHead(200, { \"content-type\": \"text/plain\" }); console.log(data); res.end(\"login success!\"); }) }) server.listen(3000, \"localhost\"); 表单操作 input&textarea v-model指令直接用于以及上时，当他们的value发生改变后数据层被绑定的数据也会发生改变。 注意，v-model指令直接用于以及上时数据层的绑定对象可以是任意类型： username introduction \"use strict\"; const app = Vue.createApp({ data() { return { username: \"\", introduction: \"\", } } }).mount(\"#app\"); checkbox v-model绑定input:checkbox时，数据层的绑定对象必须是一个数组类型，因为checkbox是多选： basketball football volleyball \"use strict\"; const app = Vue.createApp({ data() { return { hobby: [] } } }).mount(\"#app\"); radio v-model绑定input:radio时，元素身上可以不用指定name属性，只要v-model相同，就会产生互斥效果，此外checked属性也不需要做指定，只要元素的value和数据层的数据一致，默认就会进行选中。 注意，v-model指令绑定在input:radio时数据层的绑定对象可以是任意类型： male female \"use strict\"; const app = Vue.createApp({ data() { return { gender: \"male\", } } }).mount(\"#app\"); select单选&复选 v-model绑定时，需要区分单选还是多选。 如果是单选，那么数据层的绑定对象可以是任意类型 如果是多选，那么数据层的绑定对象必须是数组类型 单选示例： beijing shanghai chongqing \"use strict\"; const app = Vue.createApp({ data() { return { address: 'beijing', } } }).mount(\"#app\"); 多选示例： beijing shanghai chongqing \"use strict\"; const app = Vue.createApp({ data() { return { choice: [] } } }).mount(\"#app\"); v-model修饰符 .lazy 使用该修饰符时，数据层的绑定对象不会进行实时刷新，而是等到表单元素失去焦点后才会更新： 代码示例： \"use strict\"; const app = Vue.createApp({ data() { return { content:\"\" } } }).mount(\"#app\"); .number 使用该修饰符时，当你输入的内容为纯数字时将会自动转为int类型后再存储到数据层的绑定对象身上。 如果不使用该修饰符，则数据层绑定对象存储的string类型的数据： 代码示例： \"use strict\"; const app = Vue.createApp({ data() { return { number: null, string: null } } }).mount(\"#app\"); .trim 使用该修饰符时，将会自动移除表单元素输入内容的两侧空白： 代码示例： \"use strict\"; const app = Vue.createApp({ data() { return { trimString: \"\", noTrimString: \"\" } } }).mount(\"#app\"); Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:48 "},"前端专栏/Vue3/watch数据侦听.html":{"url":"前端专栏/Vue3/watch数据侦听.html","title":"watch数据侦听","keywords":"","body":"基本使用 我们可以使用watch来监听数据层数据的变化。 watch应当是一个对象，且在内部定义了一些方法，这些方法必须与被监听的数据（可以是计算属性）名字相同，它具有2个参数，分别是newValue和oldValue。 watch中的方法只能被动调用，当被侦听的属性发生改变时，将会自动调用侦听器中的同名方法。 下面是一个简单的例子： 代码示例： + &nbsp;{{number}}&nbsp; - \"use strict\"; const app = Vue.createApp({ data() { return { number: 0 } }, watch: { number(newValue, oldValue) { console.log(`${oldValue} => ${newValue}`); } } }).mount(\"#app\"); 适用场景 watch中的方法是支持异步操作的，所以特别适用于在某些特定场景下进行网络请求。 如页面无刷新的进行前后端交互、表单数据项格式认证等。 测试案例 人员筛选 以下是demo.css的代码： body { margin: 0; padding: 0; box-sizing: border-box; } body main { width: 400px; display: flex; flex-flow: column nowrap; justify-content: center; align-items: center; padding: 2rem; } body main>div:nth-child(1) { width: 50%; display: flex; justify-content: space-around; margin-bottom: 0.5rem; } body main>div:nth-child(2) { width: 100%; } body main>div:nth-child(2) table { width: 100%; } body main>div:nth-child(2) table, body main>div:nth-child(2) table * { border: 1px solid #aaa; border-collapse: collapse; text-align: center; } body main>div:nth-child(2) table caption { background-color: #ddd; font-weight: bold; font-size: 1.2rem; } body main>div:nth-child(2) table tbody tr:nth-of-type(odd) { background-color: #ddd; } body main>div:nth-child(2) table tbody tr:nth-of-type(odd) td { cursor: pointer; } body main>div:nth-child(2) table tfoot tr td { text-align: right; padding-right: 1rem; } body main>div:nth-child(3) { width: 70%; display: flex; justify-content: center; margin-top: 0.5rem; } 以下是demo.html中的代码： id age 升序 降序 id name age gender {{row.id}} {{row.name}} {{row.age}} {{row.gender}} \"use strict\"; const app = Vue.createApp({ data() { return { orderRule: \"id\", keyword: \"\", studentMessage: [ { id: 1, name: \"Jack\", age: 18, gender: \"male\" }, { id: 2, name: \"Tom\", age: 19, gender: \"male\" }, { id: 3, name: \"Ken\", age: 21, gender: \"male\" }, { id: 4, name: \"Anna\", age: 17, gender: \"female\" }, { id: 5, name: \"Mary\", age: 22, gender: \"female\" } ] } }, methods: { order(event, type) { // studentMessage发生改变,studentArray重新计算 if (type === \"asc\") { this.studentMessage.sort((a, b) => { return a[this.orderRule] - b[this.orderRule] }) } else { this.studentMessage.sort((a, b) => { return b[this.orderRule] - a[this.orderRule] }) } }, }, computed: { studentArray() { if (!this.keyword) { return this.studentMessage; } return this.studentMessage.filter((row, index, ary) => { for (let v of Object.values(row)) { if (row.name.match(this.keyword)) { return row; } } }) } }, watch: { keyword(newValue, oldValue) { // 重新计算 this.studentArray; } } }).mount(\"#app\"); 最终呈现的效果如下： 登录验证 以下是demo.css的代码： body { margin: 0; padding: 0; box-sizing: border-box; position: relative; } body main { position: absolute; left: 50%; top: 50%; transform: translate(-50%, -50%); } body main form { display: flex; flex-flow: column nowrap; justify-content: center; align-items: center; padding: 0.8rem; width: 250px; border: 2px solid #ddd; position: relative; } body main form>div { margin-bottom: 0.8rem; } body main form>div:first-of-type { height: 1rem; } body main form>div:first-of-type span { font-size: 0.3rem; color: red; } body main form>div:last-of-type button:nth-of-type(1) { width: 6rem; margin-right: 0.5rem; } body main form>div:last-of-type button:nth-of-type(2), body main form>div:last-of-type button:nth-of-type(3) { width: 6rem; margin-left: 0.5rem; } 以下是demo.html中的代码： {{error}} 手机号: 验证码: 登录 发送验证码 已发送 ({{waitSecond}}) \"use strict\"; const app = Vue.createApp({ data() { return { phone: null, phoneCheck: false, verify: null, verifyCheck: false, timer: null, waitSecond: 5, error: null, testVerifyCode: null, } }, methods: { sendVerify($event) { // 请求后端，模拟验证码的到来 this.testVerifyCode = \"\"; for (let i = 0; i { if (this.waitSecond 最终呈现的效果如下： Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:48 "},"前端专栏/Vue3/数组响应.html":{"url":"前端专栏/Vue3/数组响应.html","title":"数组响应","keywords":"","body":"响应渲染 在Vue中，大部分的数据渲染都是响应式的，即Vue应用中数据发生改变页面中的显示效果也会发生改变。 代码示例： + &nbsp;{{number}}&nbsp; - \"use strict\"; const app = Vue.createApp({ data() { return { number: 0 } }, methods: { add() { this.number++; }, sub() { this.number--; } } }).mount(\"#app\"); 数组响应 在Vue2中，如果数据源是一个数组的话，它有一些操作并不是响应式的，如通过索引来操纵数组。 如下所示，当我点击按钮使用索引修改元素后，数组中的元素确实发生了改变，但是页面的渲染效果并未发生改变，所以Vue2中数组的索引操作是非响应式的： 代码如下： * { margin: 0; padding: 0; } main { display: flex; flex-flow: column nowrap; align-items: center; } ul { list-style: none; margin-bottom: 1rem; } {{index}} - {{value}} change array \"use strict\"; const app = new Vue({ el: \"#app\", data() { return { ary: [\"A\", \"B\", \"C\", \"D\"] } }, methods: { changeArray(event) { this.ary.forEach((value, index, ary) => { ary[index] = value.toLowerCase(); }) console.log(this.ary); } } }); 但是在Vue3中，关于数组的索引操作已经变更为了响应式，这是一个非常好的改进： \"use strict\"; const app = Vue.createApp({ data() { return { ary: [\"A\", \"B\", \"C\", \"D\"] } }, methods: { changeArray(event) { this.ary.forEach((value, index, ary) => { ary[index] = value.toLowerCase(); }) console.log(this.ary); } } }).mount(\"#app\"); 变异方法 下面这些方法都是经过Vue封装后的方法。使用方式与原生Js相同，但是他们是响应式的。 方法 描述 push() 追加末尾，将元素压入数组尾部 unshift 追加头部，将元素压入数组头部 pop() 弹出末尾，将数组中最后一个元素弹出 shift() 弹出头部，将数组中第一个元素弹出 splice() 可以添加、删除、替换数组中的元素 sort() 排序 reverse() 翻转 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:48 "},"前端专栏/Vue3/组件化开发.html":{"url":"前端专栏/Vue3/组件化开发.html","title":"组件化开发","keywords":"","body":"基础知识 基本概念 在开始的时候，已经大概的聊了聊Vue是单页面开发，用户总是在一个页面上进行操作，看到的不同内容也是由不同组件构成的。 通过用户的操作，Vue将会向用户展示某些组件，也会隐藏某些组件，可以说Vue中一切皆组件。 一个Vue的项目其实就是一个Vue的应用对象，即createApp()所创建出的实例。而用户看到的页面则是在这个Vue应用中注册的不同的组件。 组件其实说白了就是将一些复用性高的内容进行单独封装，如导航栏、搜索框、版权信息等等，我们可以在页面中的任何地方对其进行引用，避免了重复创建所带来的代码冗余。 组件是Vue的核心、但是本章节不会讨论Vue如何实现组件的显示、隐藏，而是聊一聊如何使用组件。 组件分类 组件之间允许嵌套，如下所示： 根据组件与组件的关系，大体可分为4种组件： 根组件：即createApp()所创建出的Vue实例，通常情况下一个项目中只会有一个根组件 父组件：相对于子组件而言，包裹在外部的组件被称之为父组件 子组件：相当于父组件而言，放置在内部的组件被称之为子组件 兄弟组件：相当于其他组件而言，处于同级且没有嵌套关系的组件被称之为兄弟组件 组件使用 基本声明 普通的组件和根组件一样，都具有诸如data()、methods、computed、watch等子对象。 除此之外，它还具有一个template的选项，该选项存放的是该组件的HTML结构。 如下所示，我们定义了一个header头部组件，为了后面方便演示，我们将会对该子组件的内容进行变更让它更精简，这个例子只是让你知道所有的组件都和根组件一样能拥有某些属性及方法： const cpnHeader = { template: \"{{content}}\", data() { return { content: \"this is header component\", style: { \"color\": \"rgba(0,0,0,1)\", \"border\": \"1px solid #ddd\", \"padding\": \".5rem\", \"background\": \"#eee\", \"cursor\": \"pointer\" } } }, methods: { callback(event) { const r = Math.floor(Math.random() * (255 + 1)); const g = Math.floor(Math.random() * (255 + 1)); const b = Math.floor(Math.random() * (255 + 1)); const a = Math.random().toFixed(1); this.style.backgroundColor = rgba(${r},${g},${b},${a}); } } } 全局注册 我们可以将该组件注册到全局中，这样任何组件都能够去调用它。 如下所示我们在根组件中多次使用了该全局组件： 代码示例： #app { border: 1px solid #ddd; padding: 1rem; } {{content}} \"use strict\"; // step01：创建根组件，注意此时先不要进行挂载 const app = Vue.createApp({ data() { return { content: \"root component\" } } }); // step02：创建子组件 const cpnHeader = { template: \"{{content}}\", data() { return { content: \"header component\", style: { border: \"1px solid #ddd\", padding: \".5rem\" } } } } // step03：在根组件上调用component()方法进行注册，该组件就会变更为全局组件 // 注意命名风格，可以是驼峰式，也可以是kebab-case风格，它决定了如何在HTML结构中使用该组件 app.component('cpnHeader', cpnHeader); // step04：必须先注册组件，然后再进行元素挂载 app.mount(\"#app\") 局部注册 我们可以再书写一个cpnNav组件，将它注册在cpnHeader中，注册时需要在cpnHeader里定义components对象进行注册。 局部组件只能够在其注册的父组件作用域中进行使用，不能由根组件进行调用： 代码示例： #app { border: 1px solid #ddd; padding: 1rem; } {{content}} \"use strict\"; // step01：创建根组件，注意此时先不要进行挂载 const app = Vue.createApp({ data() { return { content: \"root component\" } } }); // step02：创建局部子组件cpnNav const cpnNav = { template: \"{{content}}\", data() { return { content: \"nav component\", style: { border: \"1px solid #ddd\", padding: \".5rem\", fontSize: \".3rem\" } } } } // step03：创建全局父组件cpnHeader，注册并使用局部子组件cpnNav，注意cpnNav只能在cpnHeader中使用，因为我们只在cpnHeader中注册了它 const cpnHeader = { template: {{content}} , data() { return { content: \"header component\", style: { border: \"1px solid #ddd\", padding: \".5rem\" } } }, components: { cpnNav, // ES6新语法，相当于 cpnNav : cpnNav } } // step04.全局注册cpnHeader组件 app.component('cpnHeader', cpnHeader); // step05：必须先注册组件，然后再进行元素挂载 app.mount(\"#app\") 命名风格 细心的朋友可能会发现，我们在注册组件时均使用了驼峰式命名风格： app.component('cpnHeader', cpnHeader); 但是在使用时却变成了短横线分隔命名风格： 为什么要这样做呢？其实如果你是通过Vue CIL创建的项目，则没必要这么麻烦，可以在使用时也通过驼峰式命名风格应用组件，但是非工程化的项目中必须在使用时更改组件命名风格为短横线分隔式，这是因为HTML文档在渲染时会将驼峰全部变为小写，所以就找不到该组件了。 我们来做一个简单的例子，现在我们是非工程化的Vue项目，将第一次使用组件的风格变为驼峰式，其他不变： {{content}} 打开控制台后会发现，浏览器会自动的将驼峰全部变为小写，该组件就找不到了，因此也不能生效： 组件模板 抽离写法 如果定义组件时在template属性中写HTML代码，是不太友好的，你可以将模板抽离出来，有2种方式进行抽离： 使用script标签，并添加type=\"text/x-template\"以及id属性 使用template标签，并添加id属性 后期子组件定义时template属性可以直接通过元素id挂在该模板，如下所示： {{content}} \"use strict\"; const app = Vue.createApp({ data() { return {} } }); // 子组件挂载模板 const cpn = { template: \"#cpn-tpl\", data() { return { content: \"cpn\", } } } app.component('cpn', cpn); app.mount(\"#app\") 重复渲染 注意！模板进行抽离写法时必须采用浏览器所不识别的标签，否则会造成重复渲染问题，即渲染次数比组件调用次数多一次。 这是因为如果你的模板标签是浏览器所识别的，浏览器会预先对其进行一次渲染： 代码示例： {{content}} \"use strict\"; const app = Vue.createApp({ data() { return {} } }); // 子组件挂载模板 const cpn = { template: \"#cpn-tpl\", data() { return { content: \"cpn\", } } } app.component('cpn', cpn); app.mount(\"#app\") 其他组件 动态组件 有的时候我们需要根据用户的行为来动态的切换某个组件，此时可以利用:is属性。 如下所示，我们定义了2个header组件，一款是红色背景的，一款是黑色背景的，用户可自行选择样式： 代码示例： 切换 hot news home \"use strict\"; const blackHeaderCpn = { template: #header-cpn, data() { return { style: { background: \"#2b0c09\" } } } } const redHeaderCpn = { template: #header-cpn, data() { return { style: { background: \"#dd1e1d\" } } } } const app = Vue.createApp({ data() { return { // 指定需要显示的组件名字，这里的组件名字和注册时一致 choice: \"redHeaderCpn\" } }, methods: { modifyHeaderCpn(event) { this.choice = this.choice === \"redHeaderCpn\" ? \"blackHeaderCpn\" : \"redHeaderCpn\" console.log(this.choice); } }, components: { // 组件注册 redHeaderCpn, blackHeaderCpn, } }) app.mount(\"#app\") 异步组件 在大型应用中，我们可能需要将应用分割成小一些的代码块，并且只在需要的时候才从服务器加载一个模块。为了简化，Vue有一个defineAsyncComponent方法： const { createApp, defineAsyncComponent } = Vue const app = createApp({}) const AsyncComp = defineAsyncComponent( () => new Promise((resolve, reject) => { resolve({ template: 'I am async!' }) }) ) app.component('async-example', AsyncComp) 如你所见，此方法接受返回Promise的工厂函数。从服务器检索组件定义后，应调用Promise的resolve回调。你也可以调用reject(reason)，来表示加载失败。 你也可以在工厂函数中返回一个Promise，把webpack2和ES2015语法相结合后，我们就可以这样使用动态地导入： import { defineAsyncComponent } from 'vue' const AsyncComp = defineAsyncComponent(() => import('./components/AsyncComponent.vue') ) app.component('async-component', AsyncComp) 7 当在局部注册组件时，你也可以使用defineAsyncComponent import { createApp, defineAsyncComponent } from 'vue' createApp({ // ... components: { AsyncComponent: defineAsyncComponent(() => import('./components/AsyncComponent.vue') ) } }) 版本差异 模板根元素 在Vue2中，下必须具有1个根元素，否则将会抛出警告： header main footer 但是在Vue3中，可以不加这个根元素，但是推荐还是添加上，因为这样会避免一些可能出现的问题，如$emit自定义事件的根标签不能是文本节点： header main footer Vue2的警告如下： vue.js:634 [Vue warn]: Error compiling template: Component template should contain exactly one root element. If you are using v-if on multiple elements, use v-else-if to chain them instead. 1 | 2 | header 3 | main | ^^^^^^^^^^^^^^^^^ 4 | footer | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 5 | | ^^^^ found in ---> 全局组件 Vue2中的全局组件是通过Vue对象本身进行注册，而不再是Vue应用，即Vue实例本身： \"use strict\"; // 子组件挂载模板 const cpn = { template: \"#cpn-tpl\", data() { return { content: \"cpn\", } } } // 注册全局组件 Vue.component('cpn', cpn); const app = new Vue({ el: \"#app\", // 挂载根元素 data() { return {} } }); 下面是Vue3的全局组件注册： \"use strict\"; const app = Vue.createApp({ data() { return {} } }); // 子组件挂载模板 const cpn = { template: \"#cpn-tpl\", data() { return { content: \"cpn\", } } } // 注册全局组件 app.component('cpn', cpn); // 挂载根元素 app.mount(\"#app\") data差异 在开篇的时候我们说过，Vue2中的data可以是一个对象，也可以是一个函数且返回一个对象，但是Vue3中的data必须是一个函数且返回一个对象。 如下示例： {{message}} \"use strict\"; const app = new Vue({ el: \"#app\", data: { message: \"hello world\" } }); 为什么Vue3会更改这种设置呢？我们可以从下图中寻找答案，如果data直接是一个对象，那么多次应用组件的时候每个组件引用的实际上还是同一个data对象，如下图所示： 这会造成一个问题，任何一个组件对于数据的修改都会造成其他组件数据的变更，完全没有了丝毫数据隔离性。 相当于下面这个案例： 代码示例： + &nbsp;{{number}}&nbsp; - \"use strict\"; const dataStore = { number: 0 } const app = Vue.createApp({}); app.component(\"cpn\", { template: \"#cpn-tpl\", data() { return dataStore } }) app.mount(\"#app\") 因此Vue3将data设计成了一个函数，且必须返回一个对象，这样每次组件应用的时候都会调用一次data()函数，从而得到不同的数据对象，已完全隔离组件多次应用之间的数据影响，如下图所示： Vue3的这个设计对于Vue老用户老说没什么特别的影响，但针对Vue新用户确实是友好了许多，但是Vue2中的data设计缺陷还是一定了解的。 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:48 "},"前端专栏/Vue3/组件中通信.html":{"url":"前端专栏/Vue3/组件中通信.html","title":"组件中通信","keywords":"","body":"通信的意义 组件之间的通信是非常有必要的。 例如当Vue项目启动后，父组件从后端获取到了一些信息，那么它该如何将这些信息分发给不同的子组件呢？ 再比如当用户在某一个子组件上产生了新的数据，子组件该如何将数据交由父组件进行前后端交互呢？ 学习组件通信前，我们要明白一点，数据的流动必须是单向的，只能子传父、或者父传子，而兄弟组件之间的通信也需要依赖父组件进行，并且传递过程中子组件不能修改源数据，源数据只能由产生该数据的组件进行修改。 如下图所示： 组件通信的方案有很多种，我们本章节主要介绍原生Vue自带的通信方案。 父传子 props props 基本使用 父组件向子组件传递数据时，需要通过props进行传递。整个传递过程如下图所示： 代码示例： {{recvMessage}} \"use strict\"; const cpn = { // JavaScript层面全部采用驼峰式命名 // 由于HTML层面是recv-message，故这里书写成recvMessage props: [\"recvMessage\"], template: \"#cpn-tpl\" } const app = Vue.createApp({ data() { return { sendMessage: \"hello world\" } }, components: { cpn } }) app.mount(\"#app\") 传递图示： props 数据检查 我们可以让子组件props对父组件传递的数据进行验证，避免一些渲染错误。 可以验证的项目如下所示： 验证项目 描述 type 一个Array，允许的类型 required 一个Boolen，是否必须传递 default 一个Any，当父组件没有传递数据时，当采用default进行填充 validator 一个Function，用于自定义的验证设置 type可支持验证的类型有： String Number Boolean Array Object Date Function Symbol 你可以仅验证类型，如下所示： const cpn = { props: { recvMessage1: String, recvMessage2: Array, recvMessage3: Object }, template: \"#cpn-tpl\" } 或者可以进行更详细的验证，示例如下： {{recvMessage}} \"use strict\"; const cpn = { // JavaScript层面全部采用驼峰式命名 // 由于HTML层面是recv-message，故这里书写成recvMessage // 数据验证 // 01.props必须是一个Object props: { // 02.指定要验证的数据项， 必须是一个Object recvMessage: { // 允许传递的类型 type: [String, Array, Object, Function], // 是否必须传递 required: true, // 自定义验证函数，若返回false则验证失败 validator(v) { if (typeof v == 'string') { return v.match(\"hello\") } return true }, // 如果父组件没有传递数据时，采用的默认值 default() { return \"default\" }, } }, template: \"#cpn-tpl\" } const app = Vue.createApp({ data() { return { sendMessage: \"hello world\", } }, components: { cpn } }) app.mount(\"#app\") 继承属性 在子组件进行应用时，我们可以为子组件绑定一些属性，这些属性会被继承到子组件模板根标签上，这种策略也被称为no_props： ... --> hello world 最终生成的结果为： hello world 我们可以禁用这种继承机制，只需要在子组件中添加inheritAttrs:false即可： const cpn = { inheritAttrs:false, template: \"#cpn-tpl\" } 这样生成的结果为： hello world 通过$attrs可拿到使用组件时所绑定的所有属性，以此来为子组件中的元素动态绑定属性： hello world --> hello world hello attrs --> hello attrs ... --> {{this.$attrs}} \"use strict\"; const cpn = { inheritAttrs: true, template: \"#cpn-tpl\" } const app = Vue.createApp({ components: { cpn } }) app.mount(\"#app\") 大小写问题 HTML中的attribute名是大小写不敏感的，所以浏览器会把所有大写字符解释为小写字符。这意味着当你使用 DOM 中的模板时，camelCase (驼峰命名法) 的 prop名需要使用其等价的 kebab-case (短横线分隔命名) 命名： Vue.component('blog-post', { // 在 JavaScript 中是 camelCase 的 props: ['postTitle'], template: '{{ postTitle }}' }) 重申一次，如果你使用字符串模板，那么这个限制就不存在了。 子传父 $emit 自定义事件通信 当子组件的数据发生改变后，我们希望子组件将这个数据传递给父组件，继而让父组件发送网络请求进行前后端交互该怎么做？ 这个时候我们可以自定义一个事件让父组件进行监听，当子组件数据改变后便手动的触发该事件，然后将数据通过这个自定义事件传递给父组件即可，整个流程如下图所示： 代码示例，当用户的数据发生改变后，父组件便会接收到该数据。 + &nbsp;{{number}}&nbsp; - \"use strict\"; const cpn = { template: \"#cpn-tpl\", data() { return { number: 0 } }, watch: { number(newValue, oldValue) { // 当number发生改变后，发射这个事件 // JavaScript层面全部采用驼峰式命名 // 由于HTML层面是number-change，故这里书写成numberChange this.$emit(\"numberChange\", newValue, oldValue); } } } const app = Vue.createApp({ data() { return { sendMessage: \"hello world\", } }, methods: { // 自定义事件没有$event事件对象 callback(newValue, oldValue) { console.log(`${oldValue}=>${newValue}`); } }, components: { cpn } }) app.mount(\"#app\") 组件访问 父访子 $refs 我们希望父组件在某些时候能够调用子组件下的某些方法或者查看某些属性，此时可以使用$refs来进行，示例如下： show cpn1 name show cpn2 name {{name}} \"use strict\"; const cpn1 = { template: \"#cpn-tpl\", data() { return { name: \"cpn1\" } } } const cpn2 = { template: \"#cpn-tpl\", data() { return { name: \"cpn2\" } } } const app = Vue.createApp({ methods: { showCPN1(event) { // 通过ref别名来访问cpn1的name属性 console.log(this.$refs.firstCPN.name); }, showCPN2(event) { // 通过ref别名来访问cpn2的name属性 console.log(this.$refs.lastCPN.name); } }, components: { cpn1, cpn2 } }) app.mount(\"#app\") 子访父 $parent 我们希望子组件在某些时候能够调用父组件下的某些方法或者查看某些属性，此时可以使用$parent来进行，示例如下： show parent name \"use strict\"; const cpn = { template: \"#cpn-tpl\", methods:{ // 通过$parent来访问父组件 showParent(event){ console.log(this.$parent.name); } } } const app = Vue.createApp({ data() { return { name: \"parent cpn\" } }, components: { cpn, } }) app.mount(\"#app\") 访问根 $root 如果存在3级以上的嵌套，我们可以直接利用$root来拿到根组件，这样就能调用根组件下的某些方法或者属性了，示例如下，当然下面这个示例中只有2层嵌套： show root name \"use strict\"; const cpn = { template: \"#cpn-tpl\", // 通过$root来访问根组件 methods:{ showRoot(event){ console.log(this.$root.name); } } } const app = Vue.createApp({ data() { return { name: \"root cpn\" } }, components: { cpn, } }) app.mount(\"#app\") 单向数据流 独立修改 上面我们提到过数据的传递必须是单向的，且相互独立的组件不应该由自身去修改正在流动的数据。 如果某个组件想要修改流动的数据，则应当进行一次拷贝操作，必须保证这一修改操作不会影响到其他的组件对该数据的使用。 如下所示，我们有一个三层嵌套的组件： 根组件：下发数据 父组件：需要修改数据后再展示数据 子组件：需要修改数据后再展示数据 对此情形而言，我们必须在父组件和子组件上都进行一次拷贝，让父组件的数据修改不会影响到子组件的数据。 代码如下： root {{number}} son {{sonNumber}} father {{fatherNumber}} \"use strict\"; const son = { props: { number: { type: Number, required: true } }, template: \"#son-cpn-tpl\", data() { return { // 不能直接修改props中的数据，必须自定义 sonNumber: this.number + 200 } } } const father = { props: { number: { type: Number, required: true } }, template: \"#father-cpn-tpl\", data() { return { // 不能直接修改props中的数据，必须自定义 fatherNumber: this.number + 100 } }, components: { son } } const app = Vue.createApp({ data() { return { number: 0 } }, components: { father } }) app.mount(\"#app\") 同源修改 更多的场景下，我们的一份数据可能被多个组件使用，并且我们希望当一份组件中该数据发生变化后，其他组件中的这份数据也会发生变化。 这个时候我们必须在该数据的产生地上定义一系列操纵数据的方法，并且下发给子组件们。 也就是说，产生该数据的组件上你不仅要向下传递数据、并且还需要传递操纵数据的方法。 如下示例： {{ary.length}} {{v}} push random pop \"use strict\"; const cpn = { // 由于我们想在子组件上操纵父组件传递的数据 // 所以必须接收由父组件提供的操纵方法来进行数据操纵 // 否则直接操纵props的数据是不被允许的 props: { ary: Array, push: Function, pop: Function, }, template: \"#cpn-tpl\", } const app = Vue.createApp({ data() { return { ary: [1, 2, 3] } }, methods: { push(event) { this.ary.push(Math.floor(Math.random() * 20) + 1) }, pop(event) { this.ary.pop() } }, components: { cpn } }) app.mount(\"#app\") 版本差异 已废弃的$children 在Vue2中，我们可以在父组件上使用$children来访问所有的子组件，它将返回一个列表，包含当前父组件下注册的所有子组件。 但是Vue3中已经将它废弃了，废弃的原因是因为它严格依赖数组的索引才能精确定位某个子组件，因此非常鸡肋，还是建议使用$ref来访问子组件。 以下是Vue2中的示例： show children cpn {{name}} \"use strict\"; const cpn1 = { template: \"#cpn-tpl\", data() { return { name: \"cpn1\" } } } const cpn2 = { template: \"#cpn-tpl\", data() { return { name: \"cpn2\" } } } const app = new Vue({ el: \"#app\", methods: { showChildren(event) { console.log(this.$children); // (2) [VueComponent, VueComponent] } }, components: { cpn1, cpn2 } }) 已废弃的.sync 如果子组件的数据来自于父组件，当子组件中的数据发生改变时我们也想让父组件中的数据发生同样的改变。 则可以使用.sync修饰符（尽量少用，会破坏单一性，Vue3已废弃），如下所示： 代码示例： 父组件的值:{{num}} 子组件的值:{{sonNum}} \"use strict\"; var cpn = { props: [\"sonNum\",], template: \"#cpn-template\", data: function () { return { newValue: this.sonNum, } }, methods: { changeValue() { this.$emit(\"update:sonNum\", this.newValue) } } } const app = new Vue({ el: \"#app\", data: { num: 100, }, components: { // Vue实例内部进行注册 cpn, }, }) 流程图示： Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:48 "},"前端专栏/Vue3/组件化插槽.html":{"url":"前端专栏/Vue3/组件化插槽.html","title":"组件化插槽","keywords":"","body":"认识插槽 插槽是干什么用的？它其实是配合组件一起使用的，让一个组件能够更加的灵活多变，如下图所示，你可以将组件当作一块电脑主板，将Vue中的插槽当作电脑主板上的插槽，你可以随意的更换该主板上的零件。 我们举个例子，如YouTube上的左侧导航栏，我们可以将它视作一个组件，但是被重复引用了3次。 注意，示例中组件的每次使用其内容都不相同，这是如何做到的呢？实际上就是通过插槽来完成的。 基本使用 我们可以在组件模板中使用来定义一个插槽，当父组件模板中引用子组件时，可通过标签以及v-slot指令来向该插槽中插入内容。 如下所示，我们在2个地方使用了一个相同的组件，但是填入了不同的内容： 代码示例： \"use strict\"; const cpn = { template: \"#cpn\" } const app = Vue.createApp({ components: { // 组件注册 cpn } }) app.mount(\"#app\") 具名插槽 插槽可以定义多个，但要在定义时必须通过name属性为这些插槽取一个名字，这种插槽被称为具名插槽。 具名插槽在插入内容时，必须通过标签来进行插入，并且指定v-slot属性为插槽名称。 代码示例： header main footer \"use strict\"; const cpn = { template: \"#cpn\" } const app = Vue.createApp({ components: { // 组件注册 cpn } }) app.mount(\"#app\") 默认插槽 若一个插槽没有名字，那么Vue会指定给它一个默认的名字default，因此这种插槽也被称之为默认插槽。 默认插槽一个组件中至多只有一个，我们推荐在为默认插槽插入内容时，也指定好default的名称。 代码示例： default slot demo header main footer \"use strict\"; const cpn = { template: \"#cpn\" } const app = Vue.createApp({ components: { // 组件注册 cpn } }) app.mount(\"#app\") 编译作用域 编译作用域的意思是，在哪个组件的模板中使用数据时，就在哪个组件的数据层中区寻找，如下图所示： 我们在根组件模板的子组件身上绑定了v-show:condition指令，并且在子组件和根组件数据层都定义了condition，那么它到底是用根组件的condition还是用子组件的condition呢？ 答案是根组件的，因为根组件的模板就是根组件的渲染作用域，所有在此模板中对数据的使用都会寻找根组件数据层。 代码示例： cpn \"use strict\"; const cpn = { template: \"#cpn\", data() { return { condition: true } }, } const app = Vue.createApp({ data() { return { condition: false } }, components: { // 组件注册 cpn } }) app.mount(\"#app\") 作用域插槽 作用域插槽的作用是，通过子组件的内容来填充子组件中的插槽，这个应用场景比较少。 主要实现思路就是在子组件模板中将数据发送到根组件的作用域内再进行渲染，代码实现如下所示： {{row.id}}-{{row.name}}-{{row.age}}-{{row.gender}} \"use strict\"; const cpn = { template: \"#cpn\", data() { return { userList: [ { id: 1, name: \"Jack\", age: 18, gender: \"male\" }, { id: 2, name: \"Mary\", age: 16, gender: \"female\" }, { id: 3, name: \"Tom\", age: 18, gender: \"male\" } ] } }, } const app = Vue.createApp({ components: { // 组件注册 cpn } }) app.mount(\"#app\") 它的意义在于，同一份数据我们可以使用不同的样式进行多次渲染，如上述示例中是使用了列表渲染，当然也可以在我们再次使用该组件时进行表格渲染。 默认内容 我们可以在插槽中定义一个默认值，当外部没有向该插槽传递内容时，Vue将会使用默认值来填充该插槽。 代码示例： 自定义的头部 自定义的底部 默认的头部 默认的主体 默认的底部 \"use strict\"; const cpn = { template: \"#cpn\" } const app = Vue.createApp({ components: { // 组件注册 cpn } }) app.mount(\"#app\") v-slot缩写形式 v-slot:default可以简写为#default，如下所示： content 版本差异 整个Vue2和Vue3中关于插槽的改动非常大，我们一个一个来例举。 首先对于具名插槽而言，填入内容时不需要使用标签，直接填入内容即可，并且指定填入插槽的方式也有所不同。 1）Vue3的代码示例，指定插槽通过v-slot指令进行指定： demo slot fill content 2）Vue2的代码示例，指定插槽通过slot属性进行指定： demo slot fill content 其次是关于作用域插槽，它们在父组件接收子组件所传递的值时应用方法有所不同。 1）Vue3的代码示例，Vue3中父组件模板接收子组件中传递过来的信息时子组件必须使用v-bind进行发送，父组件必须使用v-slot属性进行接收： {{row.id}}-{{row.name}}-{{row.age}}-{{row.gender}} 2）Vue2的代码示例，Vue2中父组件模板接收子组件中传递过来的信息时子组件必须使用v-bind进行发送，父组件必须使用slot-scope（Vue2.5以下使用scope）属性进行接收： {{row.id}}-{{row.name}}-{{row.age}}-{{row.gender}} Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:48 "},"前端专栏/Vue3/生命周期函数.html":{"url":"前端专栏/Vue3/生命周期函数.html","title":"生命周期函数","keywords":"","body":"钩子函数是什么 钩子函数是指在某些时刻必定会运行的一些函数。 Vue组件在从创建至销毁的过程中，官方为我们预留了许多的钩子函数让我们能够在其中进行一些自定义操作。 如发送网络请求，处理业务逻辑等前置或后置性工作。 生命周期函数 以下例举一些常见的Vue3中组件生命周期钩子函数，这里以简写形式举例： beforeCreate：组件创建前 created：组件创建时（推荐在此时发送只请求一次的网络请求） beforeMount：组件挂载模板前 mounted：组件挂载模板时（推荐在此时发送会请求多次的网络请求） beforeUpdate：组件数据更新前 update：组件数据更新时 beforeUnmount：卸载组件前 unmounted：卸载组件时 renderTracked：每次浏览器刷新页面时 renderTriggered：每次Vue重新渲染页面时 详情参见官方文档。 点我跳转 代码示例如下： {{count}} \"use strict\"; const app = Vue.createApp({ data() { return { count: 0 } }, beforeCreate() { console.log(\"beforeCreate\"); }, created() { console.log(\"created\"); }, beforeMount() { console.log(\"beforeMount\"); }, mounted() { console.log(\"mounted\"); }, beforeUpdate() { console.log(\"beforeUpdate\"); }, updated() { console.log(\"updated\"); } }).mount(\"#app\") setInterval(() => { app.count++; console.log(app.count); }, 1000) 官方图示 官方图示如下所示： Vue2.x Vue2中的生命周期函数和Vue3中有一些不一样，但总体逻辑都差不多。 值得一提的是，Vue3中不建议开发人员手动对Vue生命周期进行管理，所以对于beforeUnmount()和unmounted()方法来说不太好验证，但对于Vue2来说则没有这种顾虑，我们可以手动的去卸载一个Vue组件。 Vue2的beforeDestroy相当于Vue3的beforeUnmount Vue2的destroyed相当于Vue3的unmounted 代码示例： {{count}} \"use strict\"; const app = new Vue({ el: \"#app\", data() { return { count: 0 } }, beforeCreate() { console.log(\"beforeCreate\"); }, created() { console.log(\"created\"); }, beforeMount() { console.log(\"beforeMount\"); }, mounted() { console.log(\"mounted\"); }, beforeUpdate() { console.log(\"beforeUpdate\"); }, updated() { console.log(\"updated\"); }, beforeDestroy(){ console.log(\"beforeDestroy\"); }, destroyed(){ console.log(\"destroyed\"); } }) setInterval(() => { app.count++; console.log(app.count); }, 1000) // 通过cpn.destroyed()可卸载组件，根组件无法卸载故不再进行演示 Vue2的生命周期函数图示： Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:48 "},"前端专栏/Vue3/动画效果.html":{"url":"前端专栏/Vue3/动画效果.html","title":"动画效果","keywords":"","body":"CSS动画 全元素动画 使用标签对需要执行切换动画的内容进行包裹。 然后定义下面这些内置类，所有的标签都会在元素切换时作用到这些动画效果： 时机 描述 v-enter-from 定义进入过渡的开始状态 v-enter-active 定义进入过渡生效时的状态 v-enter-to 定义进入过渡的结束状态 v-leave-from 定义离开过渡的开始状态 v-leave-active 定义离开过渡生效时的状态 v-leave-to 定义离开过渡的结束状态 我们定义一个过渡动画，下面例子中的2个都会生效： 代码示例： /* 动画进入前 */ .v-enter-from { transform: translate(3rem); opacity: 0; } /* 动画进入时 */ /* 动画退出时 */ .v-enter-active, .v-leave-active { transition: all 2s ease-out; opacity: .5; } /* 动画进入完 */ /* 动画退出前 */ .v-enter-to, .v-leave-from { opacity: 1; } /* 动画退出完 */ .v-leave-to { transform: translate(3rem); opacity: 0; } use HELLO Vue3 use 1 2 3 \"use strict\"; const app = Vue.createApp({ data() { return { spanCondition: false, ulCondition: false } } }).mount(\"#app\") 单元素动画 我们可以为标签定义一个name属性，然后将动画执行的时机类中的v切换成的name属性，即可为一个单一的元素做动画效果。 时机 描述 name-enter-from 定义进入过渡的开始状态 name-enter-active 定义进入过渡生效时的状态 name-enter-to 定义进入过渡的结束状态 name-leave-from 定义离开过渡的开始状态 name-leave-active 定义离开过渡生效时的状态 name-leave-to 定义离开过渡的结束状态 我们定义了两个帧动画，一个用于进场切换，一个用于出场切换，但它们仅对生效： 代码示例： @keyframes moveIn { from { transform: translate(3rem); opacity: 0; } to { transform: translate(0); opacity: 1; } } @keyframes moveOut { from { transform: translate(0); opacity: 1; } to { transform: translate(3rem); opacity: 0; } } /* 动画进入时 */ .span_move-enter-active { animation: moveIn 1.5s ease-in; } /* 动画退出时 */ .span_move-leave-active { animation: moveOut 1.5s ease-out; } use HELLO Vue3 use 1 2 3 \"use strict\"; const app = Vue.createApp({ data() { return { spanCondition: false, ulCondition: false } } }).mount(\"#app\") 帧/过渡动画 如果想同时使用帧动画和过渡动画，可在标签上利用下面2个属性进行配置： type属性：值可以是animation或者transition，如果帧动画和过渡动画的执行时长不一样，你可以指定采取谁的执行时长 duration属性：值是一个number或者Object，定义帧动画和过渡动画的总执行时长，它的优先级最高 下面这个例子中，我们为的切换定义了2组帧动画以及一组过渡动画，执行时长通过duration属性指定为3000毫秒： 代码示例，帧动画负责元素的移动，过渡动画负责透明度的变化： @keyframes moveIn { from { transform: translate(3rem); } to { transform: translate(0); } } @keyframes moveOut { from { transform: translate(0); } to { transform: translate(3rem); } } .v-enter-from { opacity: .2; } /* 过渡动画 */ .v-enter-from { opacity: 0; } .v-enter-active, .v-leave-active { transition: all 2s ease-out; opacity: .5; } .v-enter-to, .v-leave-from { opacity: 1; } .v-leave-to { opacity: 0; } /* 帧动画 */ .v-enter-active { animation: moveIn 10s ease-in; } .v-leave-active { animation: moveOut 10s ease-out; } use HELLO Vue3 \"use strict\"; const app = Vue.createApp({ data() { return { condition: false, } } }).mount(\"#app\") JavaScript动画 transition的钩子方法 我们可以在标签中定义一些属性，这些属性均指向其组件中的方法，依次来做JavaScript动画。 可定义的属性如下。 注意，在enter和leave钩子函数中必须使用done进行回调。 由于JavaScript动画应用比较少，故不再进行详细举例，官方示例： body { margin: 30px; } .box { width: 30px; height: 30px; background: teal; margin-top: 20px; } Toggle \"use strict\"; const app = Vue.createApp({ data() { return { show: false } }, methods: { beforeEnter(el) { gsap.set(el, { scaleX: 0.8, scaleY: 1.2 }) }, enter(el, done) { gsap.to(el, { duration: 1, scaleX: 1.5, scaleY: 0.7, opacity: 1, x: 150, ease: 'elastic.inOut(2.5, 1)', onComplete: done }) }, leave(el, done) { gsap.to(el, { duration: 0.7, scaleX: 1, scaleY: 1, x: 300, ease: 'elastic.inOut(2.5, 1)', }) gsap.to(el, { duration: 0.2, delay: 0.5, opacity: 0, onComplete: done }) } } }).mount(\"#app\") 元素切换的动画 当我们有多组元素需要进行切换显示时，可以为其添加一个切换动画，让切换过程看起来更美观。 在标签中可指定以下2个属性： mode属性：值可以是in-out或者是out-in，意味切换动画时先进先出亦或是先进后出 appear属性：无值，让页面开始时就执行动画 演示效果： 代码示例： .v-leave-active { transition: opacity .3s } .v-enter-from, .v-leave-to { opacity: 0 } .btn { background-color: #00ae80; width: 4rem; height: 2rem; line-height: 2rem; text-align: center; padding: .5rem; color: #fff; border-radius: 20px; cursor: pointer; } NO OFF \"use strict\"; const app = Vue.createApp({ data() { return { condition: true } } }).mount(\"#app\") 组件切换的动画 组件的切换过程也可以添加动画效果，如下所示： 代码示例： .v-leave-active { transition: opacity .3s } .v-enter-from, .v-leave-to { opacity: 0 } switch cpn \"use strict\"; const app = Vue.createApp({ data() { return { choiceCpn: \"cpn1\" } }, components: { cpn1: { template: `cpn1`, data() { return { style: { background: \"red\", padding: \".2rem\", display: \"inline-block\", color: \"#fff\" } } } }, cpn2: { template: `cpn2`, data() { return { style: { background: \"blue\", padding: \".2rem\", display: \"inline-block\", color: \"#fff\" } } } } }, methods: { switchCpn(event) { this.choiceCpn = this.choiceCpn === \"cpn1\" ? \"cpn2\" : \"cpn1\"; } } }).mount(\"#app\") 列表组动画 使用标签对需要切换动画的元素组进行包裹，元素组通常是指由v-for定义的一系列元素。 效果如下，我们定义了一个组，当点击add或者remove时，组的内容会发生变更，于此同时会搭配上一些动画效果。 注意，这里的动画是为组内的每一个元素项进行作用，而非整个组。 代码示例： .list-item { display: inline-block; margin-right: 10px; } .list-enter-active, .list-leave-active { transition: all 1s ease; } .list-enter-from, .list-leave-to { opacity: 0; transform: translateY(30px); } Add Remove {{ item }} \"use strict\"; const Demo = { data() { return { items: [1, 2, 3, 4, 5, 6, 7, 8, 9], nextNum: 10 } }, methods: { randomIndex() { return Math.floor(Math.random() * this.items.length) }, add() { this.items.splice(this.randomIndex(), 0, this.nextNum++) }, remove() { this.items.splice(this.randomIndex(), 1) } } } Vue.createApp(Demo).mount('#list-demo') 使用第三方库 在实际开发中，我们更多的是选用第三方动画库，如animate.css进行动画切换。 你只需要指定动画类即可，可指定的动画类有： 属性 描述 enter-active-class 开始的动画类 leave-active-class 结束的动画类 示例如下： 代码示例： 切换 const app = Vue.createApp({ data() { return { status: false } } }).mount(\"#app\") Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:48 "},"前端专栏/Vue3/自定义指令.html":{"url":"前端专栏/Vue3/自定义指令.html","title":"自定义指令","keywords":"","body":"全局指令 使用app.directive注册全局指令，全局指令在所有组件的模板作用域中都能使用。 如下所示我们定义了一个v-focus指令，当页面刷新后自动获取表单元素的焦点： \"use strict\"; const app = Vue.createApp({}); // 注册全局指令v-focus app.directive('focus', { // 绑定指令的钩子函数 mounted(el) { el.focus(); } }) app.mount(\"#app\") 局部指令 在组件内部定义directives对象，注册局部指令，局部指令只有在其注册组件的模板作用域中才能使用。 如下所示我们定义了一个v-focus指令，当页面刷新后自动获取表单元素的焦点： \"use strict\"; const app = Vue.createApp({ directives: { // 注册局部指令v-focus focus: { // 绑定指令的钩子函数 mounted(el) { el.focus() } } } }); app.mount(\"#app\") 指令钩子 一个指令定义对象可以提供如下几个钩子函数 (均为可选)，它们会在不同的时期让指令进行生效： created：指令创建时调用 beforeMount：指令绑定了但组件未被挂载时调用 mounted：指令绑定了且组件已被挂载时调用 beforeUpdate：需要更新组件内容时时调用 updated：组件内容已更新时调用 beforeUnmount：卸载组件前调用 unmounted：卸载组件时调用 钩子参数 在一个指令的钩子函数中，我们可以利用以下的一些参数来获取元素标签以及被绑定的值： el：获取元素标签 binding：获取绑定的值 比如： 它们获取的值是： el : binding.arg : \"left\" binding.value : 200 如果你的指令更加复杂，那么binding应该能满足你的需求，你可以在官方文档中找到关于binding的更多attribute。 完整代码示例： \"use strict\"; const app = Vue.createApp({ directives: { position: { // 绑定指令的钩子函数 mounted(el, binding) { console.log(el); console.log(binding); } } } }); app.mount(\"#app\") Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:48 "},"前端专栏/Vue3/Mixins.html":{"url":"前端专栏/Vue3/Mixins.html","title":"Mixins","keywords":"","body":"基本介绍 Mixins机制是Vue2中经常使用的一种手段，Vue3中也同样支持，但是使用的场景越来越少了。 它意在将多个组件中具有相同内容的地方进行提炼，如下所示，我们的cpn1和cpn2的data以及methods都是相同的，因此可以将这些共有的部分提炼成一个Mixin对象： 代码示例： \"use strict\"; const common = { data() { return { message: \"hello world\" } }, methods: { change(event) { this.message = this.message.toUpperCase() } } } const app = Vue.createApp({ components: { cpn1: { mixins: [common,], template: \"cpn1-{{message}}\" }, cpn2: { mixins: [common,], template: \"cpn2-{{message}}\" } } }).mount(\"#app\") 属性覆盖 如果组件中拥有和Mixin对象中的同名属性或方法，那么只会运行组件中的属性或方法。 代码示例： \"use strict\"; const common = { data() { return { message: \"hello mixin\" } } } const app = Vue.createApp({ components: { cpn1: { mixins: [common,], template: \"{{message}}\", data() { return { message: \"hello cpn1\" } } } } }).mount(\"#app\") 钩子函数 如果Mixin对象中定义了生命周期钩子函数，而组件中也定义了同名的生命周期钩子函数，那么会先运行Mixin对象的生命周期钩子函数，再运行组件自己的生命周期钩子函数。 代码示例： \"use strict\"; const common = { created(){ console.log(\"mixin created running\"); } } const app = Vue.createApp({ components: { cpn1: { mixins: [common,], template: \"cpn\", created(){ console.log(\"cpn created running\"); } } } }).mount(\"#app\") 普通属性 如果Mixin对象中定义了一个普通属性，那么在组件中想要使用这个普通属性时需要加上$options的前缀符进行访问，因为它不会将Mixin的普通属性放入到data中： \"use strict\"; const common = { message : \"hello mixin\" } const app = Vue.createApp({ components: { cpn1: { mixins: [common,], template: \"{{this.$options.message}}\", } } }).mount(\"#app\") 实际上$options会将所有的组件中的普通属性进行存入，如下所示： \"use strict\"; const common = { message : \"hello mixin\" } const app = Vue.createApp({ components: { cpn1: { mixins: [common,], template: \"{{this.$options.message}}\", cpnName : \"cpn1\", mounted(){ console.log(this.$options.cpnName); // cpn1 } } } }).mount(\"#app\") 如果Mixin对象和组件都定义了同名的普通属性，那么会优先选择组件中的同名属性。 我们可以通过配置项来更改这个优先级，用于决定组件到底使用哪一个普通属性，如下所示： \"use strict\"; const common = { message: \"hello mixin\" } const app = Vue.createApp({ components: { cpn1: { mixins: [common,], template: \"{{this.$options.message}}\", message: \"hello cpn\" } } }) // 这会作用到内部所有组件中 app.config.optionMergeStrategies.message = (mixinValue, cpnValue) => { // 先返回mixin的，如果没有再返回cpn的 return mixinValue || cpnValue; } app.mount(\"#app\") 全局注册 上面的Mixin对象的注册方式为局部注册，只能在cpn1中生效： const app = Vue.createApp({ components: { cpn1: { mixins: [common,], template: \"{{this.$options.message}}\", } } }) 我们可以将Mixin对象改为全局注册，这样所有的组件中都能访问Mixin对象中的属性以及方法了： \"use strict\"; const app = Vue.createApp({ components: { cpn1: { template: \"{{this.$options.message}}\", } } }) // 全局注册 app.mixin({ message: \"hello mixin\" }) app.mount(\"#app\") Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:48 "},"前端专栏/Vue3/teleport传送门.html":{"url":"前端专栏/Vue3/teleport传送门.html","title":"teleport传送门","keywords":"","body":"需求场景 在某些情况下，我们需要让一个组件的作用发生到另一个组件上，此时就需要teleport传送门进行实现。 举个例子，我们有3个组件： 登录框组件（子组件） 主内容组件（父组件） 遮罩层组件（全局组件） 我们希望在主内容组件上点击登录按钮时，会触发登录框组件以及遮罩层组件的显示，同时遮罩层组件将作用在主内容组件上。 整体逻辑如下图所示： 这个过程就是将遮罩层组件作用在主内容组件身上。 代码实现 通过teleport来实现这一个需求： 登录 欢迎登录 提交取消 \"use strict\"; const maskCpn = { template: \"#mask-tpl\" } const loginCpn = { template: \"#login-tpl\", methods: { // 监听退出事件按钮 close(event) { this.$emit(\"close\"); } } } const contentCpn = { template: \"#content-tpl\", data() { return { status: false } }, components: { loginCpn } } const app = Vue.createApp({ data() { return { maskStatus: false } }, components: { contentCpn } }) app.component(\"maskCpn\", maskCpn); app.mount(\"#app\"); CSS代码如下： * { margin: 0; padding: 0; box-sizing: border-box; } body #content { width: 400px; height: 400px; border: 1px solid #ddd; display: flex; flex-flow: column nowrap; position: relative; } body #content > header { display: flex; justify-content: flex-end; align-items: center; padding-right: 0.2rem; height: 10%; background-color: #aaa; } body #content > main { background: #bbb; height: 90%; } body #content > main #login { background: #fff; position: absolute; left: 50%; top: 50%; transform: translate(-50%, -50%); padding: 0.5rem; z-index: 1; } body #content > main #login div { margin: 0.2rem; } body #content > #mask { position: absolute; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0, 0, 0, 0.5); } Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:48 "},"前端专栏/Vue3/CompositionAPI.html":{"url":"前端专栏/Vue3/CompositionAPI.html","title":"CompositionAPI","keywords":"","body":"Composition API Composition API是Vue3中推荐的组件代码书写方式，相较于传统的Options API来说，它能让业务逻辑处理和后期代码维护变的更加简单。 首先我们来看Options API的优缺点，在Options API中，一个组件通常由data()、methods、watch、computed来组成，在这些选项里我们可以将数据和功能进行完美的划分。 但是这样会出现一个问题，随着代码量越来越大，我们对一个功能的追踪也变的越来越困难，因为该功能的不同部分总是分割在了不同的选项中，如我们要追踪关于数据A的所有代码时，需要从data()到methods再至watch中寻找所有数据A出现的地方，这十分的麻烦： 而Composition API从根本上解决了这种问题，它针对一个数据开展一条业务线，当你需要寻找与该数据相关的逻辑代码时，它总是一目了然的展现在你的面前，如下图所示，关于数据A的处理都被封装在了一个函数中，不管是data()、methods亦或是watch的逻辑代码都书写在这一个函数中，这对后期维护来讲非常的方便： setup 基本使用 在Composition API中有一个setup()，该函数能够去代替data()、methods、以及watch和computed，你可以将所有该组件能应用到的代码逻辑都写在这个里面，它具有2个参数，props以及context。 让我们通过Composition API书写一个最简单的例子，现在在setup()函数中你不光可以书写属性，还可以书写方法： {{message}} \"use strict\"; const app = Vue.createApp({ setup(props, context) { const message = \"hello composition api\" function callbackfn(event) { console.log(\"why do you point me?\"); } return { message, callbackfn } } }) app.mount(\"#app\") this的支持 Composition API和Options API两者可以同时使用，它们是不冲突的。 但是需要注意的是，setup()函数取代了Options API中beforeCreate以及created这2个生命周期钩子函数，在官方文档中你可以找到这一则说明： 这意味着，在setup()函数中你不能使用this访问到data中的数据项，但是可以在data()中通过$options拿到setup()返回的对象： {{dataMessage}} {{setupMessage}} \"use strict\"; const app = Vue.createApp({ setup(props, context) { const setupMessage = \"hello composition api\" // console.log(this.dataMessage); // Cannot read properties of undefined return { setupMessage } }, data() { const dataMessage = \"hello options api\" console.log(this.$options.setup()); // {setupMessage: 'hello composition api'} return { dataMessage } } }) app.mount(\"#app\") 响应式数据 非响应式支持 Options API中data()返回的数据均是响应式的： + &nbsp;{{number}}&nbsp; - \"use strict\"; const app = Vue.createApp({ data() { let number = 0 return { number } } }) app.mount(\"#app\") 而Composition API中setup()返回的数据并不是响应式的： + &nbsp;{{number}}&nbsp; - \"use strict\"; const app = Vue.createApp({ setup(props, context) { let number = 0 return { number } } }) app.mount(\"#app\") ref ref能够让值类型的数据在Composition API中具有响应式特征，使用前你需要引入它： const { ref } = Vue; let number = ref(0) 它本质上是将这个数据进行了proxy包装，格式如下： proxy({value:0}) 当我们需要在setup()函数内部修改该值时，必须使用该代理器的value属性进行修改，如： number.value++ 但是在模板中需要修改该值则可直接进行修改： number++ 示例如下： + + &nbsp;{{number}}&nbsp; - - \"use strict\"; const app = Vue.createApp({ setup(props, context) { const { ref } = Vue; let number = ref(0) const add = event => { number.value++; } const sub = event => { number.value--; } return { number, add, sub } } }) app.mount(\"#app\") reactive reactive能够让引用类型的数据在Composition API中具有响应式特征，使用前你需要引入它： const { reactive } = Vue; let ary = reactive([1, 2, 3, 4, 5]) 它本质上是将这个数据进行了proxy包装，格式如下： Proxy {0: 1, 1: 2, 2: 3, 3: 4, 4: 5} 如果是Object，则包装后的格式如下： Proxy {name: 'Jack', age: 18, gender: 'male'} 我们不管是在模板中，还是在setup()函数中，都可以直接对其进行操作。 示例如下： + + &nbsp;{{ary}}&nbsp; - - \"use strict\"; const app = Vue.createApp({ setup(props, context) { const { reactive } = Vue; let ary = reactive([1, 2, 3, 4, 5]) const push = event => { const lastValue = ary[ary.length - 1] ary.push(lastValue + 1) } const pop = event => { ary.pop() } return { ary, push, pop } } }) app.mount(\"#app\") toRefs 有时候我们并不需要return一个完整的对象，而是return一个对象中单独的某个值，这个时候我们必须通过toRefs对对象进行解构赋值，才能够获得响应对象： {{name}} {{age}} {{gender}} \"use strict\"; const app = Vue.createApp({ setup(props, context) { const { reactive, toRefs } = Vue; let message = reactive({ name: \"Jack\", age: 18, gender: \"male\" }) const { name, age, gender } = toRefs(message) return { name, age, gender } } }) app.mount(\"#app\") 它相当于使用ref对每个值进行包裹，所以说在setup()函数内部修改这些被解构出来的值时，需要使用proxy的value属性进行修改： setup(props, context) { const { reactive, ref } = Vue; let message = reactive({ name: \"Jack\", age: 18, gender: \"male\" }) return { name: ref(message.name), age: ref(message.age), gender: ref(message.gender) } } toRef 在我们对对象进行解构赋值时，有可能出现没有的值，这个时候我们得到的结果是undefined。 如果后续对该值进行修改，让其进行变更时也需要进行响应式支持的话，则必须使用toRef进行解构赋值，如下所示： {{name}} {{age}} {{gender}} {{score}} \"use strict\"; const app = Vue.createApp({ setup(props, context) { const { reactive, toRefs, toRef, ref } = Vue; let message = reactive({ name: \"Jack\", age: 18, gender: \"male\" }) let { name, age, gender } = toRefs(message) // 现在获取的对象是undefined，因为message中没有score属性 let score = toRef(message, \"score\") // 3s后将它修改为100，如果没有使用toRefs对其进行包裹，那么这种变更则不是响应式的 // 它相当于 let score = ref(message.score) || ref(undefined); setTimeout(() => { score.value = 100 }, 3000) return { name, age, gender, score } } }) app.mount(\"#app\") 本节陈述 这一小结主要针对Composition API对数据非响应式支持做出的介绍，Vue3中提供了很多种解决方案，最常用的就是上面举例的4种： ref：让值类型的数据能够支持响应式操作 reactive：让引用类型的数据能够支持响应式操作 toRefs：让解构赋值出的对象和源容器对象之间具备响应式操作 toRef：针对解构赋值没有的对象支持响应式操作 除开reactive，其他诸如ref、toRefs以及toRef的数据变更都需要使用proxy.value属性进行操作。 组件化开发 props参数 我们都知道，在setup()函数中不能使用this，因此在父子通信时父组件传递给子组件的信息需要子组件使用setup()的props参数进行接收，以下是使用方法： {{childRecvData}} \"use strict\"; const { ref, reactive, toRefs, toRef } = Vue const app = Vue.createApp({ setup(props, context) { const fatherData = ref(\"father data\") return { fatherData } } }) app.component(\"cpn\", { template: \"#cpn-tpl\", props: { childRecvData: { required: true, type: String } }, setup(props, context) { // 这里的props等同于上面的props const { childRecvData } = props return { childRecvData } } }) app.mount(\"#app\") context参数 context参数有3个属性可供调用： attrs：相当于no_props的属性继承 slots：能够获取组件中的插槽 emit：能够进行自定义事件 首先是context.attrs，如同no_props一样，它能获取组件使用时所元素身上所绑定的非动态属性： cpn \"use strict\"; const { ref, reactive, toRefs, toRef } = Vue const app = Vue.createApp({}) app.component(\"cpn\", { template: \"#cpn-tpl\", setup(props, context) { console.log(context.attrs[\"data-font-size\"]); // font-size:16px console.log(context.attrs[\"data-font-color\"]); // color:#fff return {} } }) app.mount(\"#app\") 其次是context.slots，它能获取组件中的槽位信息： default slot \"use strict\"; const { ref, reactive, toRefs, toRef, h } = Vue const app = Vue.createApp({}) app.component(\"cpn\", { template: \"#cpn-tpl\", setup(props, context) { // {__v_isVNode: true, __v_skip: true, type: 'span', props: null, key: null, …} console.log(context.slots.default()[0]); // 修改槽位中元素样式 return () => h(\"div\", { style: \"color:#aaa\" }, [context.slots.default()]) } }) app.mount(\"#app\") 最后是context.emit，它能发送自定义事件，可用于子组件向父组件传递信息，这个是最常用的属性： cpn \"use strict\"; const { ref, reactive, toRefs, toRef, h } = Vue const app = Vue.createApp({ setup(props, context) { function callbackfn(...params) { console.log(params); // ['child data'] } return { callbackfn } } }) app.component(\"cpn\", { template: \"#cpn-tpl\", setup(props, context) { const childData = \"child data\" context.emit(\"readEvent\", childData) return {} } }) app.mount(\"#app\") readonly 通过readonly让对象不可更改，这种不可更改是更深层次的限定，比如数组嵌套对象时，你既不能修改外部数组中的内容，也不能修改内部对象中的内容。 下面是readonly简单的使用例子，我们可将它用于组件通信当中，对于一些只能看不能修改的数据非常方便： {{message}} \"use strict\"; const { ref, reactive, toRefs, toRef, readonly } = Vue const app = Vue.createApp({ setup(props, context) { // 只能看，不能改 const message = readonly( reactive( [ { id: 1, name: \"Jack\", age: 19 }, { id: 1, name: \"Tom\", age: 18 }, { id: 1, name: \"Mary\", age: 21 } ] ) ) return { message } } }) app.mount(\"#app\") inject与provide 令人激动的消息，相信在之前学习组件通信时，你对props和emit的通信方式心存怨念，认为这样太麻烦了。 不错，有许许多多的人和你具有同样的想法，这不，在Vue3中迎来了更简单好用的组件通信方式，即inject()和provide()。 使用它们就像是使用消息发布订阅系统一样，你只需要在某一个组件上通过provide()发送出一则数据，那么该Vue应用下所有的组件都可以使用inject()来对该数据进行接收。 这意味着兄弟组件、爷孙组件等都可以直接的进行通信了，而不再是将数据一层一层的进行传递。 下面是一个简单的使用案例： {{message}} \"use strict\"; const { ref, reactive, toRefs, toRef, readonly, inject, provide } = Vue const app = Vue.createApp({ setup(props, context) { const message = readonly( reactive( [ { id: 1, name: \"Jack\", age: 19 }, { id: 1, name: \"Tom\", age: 18 }, { id: 1, name: \"Mary\", age: 21 } ] ) ) // 发布数据，指定key和value provide(\"message\", message) return {} } }) app.component(\"cpn\", { template: \"#cpn-tpl\", setup(props, context) { // 订阅数据，指定key和defaultValue，如果没有该数据则采用defaultValue const message = inject(\"message\", \"default value\") return { message } } }) app.mount(\"#app\") 计算属性 computed Composition API中的computed使用与Options API中computed的使用已经不同了。 你必须先导入它然后再到setup()中进行定义，示例如下，computed()参数可以是一个function： {{number1}} {{number2}} number1 + 1 number1 - 1 \"use strict\"; const { ref, reactive, computed } = Vue; const app = Vue.createApp({ setup(props, context) { let number1 = ref(100); let number2 = computed(() => { return number1.value * 2 }) return { number1, number2 } } }) app.mount(\"#app\") get和set Composition API中的computed()参数也可以是一个Object，该Object允许定义get和set方法，这意味着你可以对computed attribute进行重新赋值。 示例如下： + &nbsp;{{number}}&nbsp; - \"use strict\"; const { ref, reactive, computed } = Vue; const app = Vue.createApp({ setup(props, context) { let _n = ref(100); let number = computed({ get() { console.log(\"computed get()\"); return _n.value; }, set(newValue) { console.log((\"computed set()\")); _n.value = newValue; } }) return { number } } }) app.mount(\"#app\") 数据侦听 watch 同computed一样，如果你想在Composition API中使用watch进行数据监听，则必须先导入后使用。 以下是关于watch最基本的使用，当点击元素时，会触发watch侦听： count \"use strict\"; const { ref, reactive, watch } = Vue; const app = Vue.createApp({ setup(props, context) { let count = ref(0); // 要监听的属性，回调函数(新值，旧值) watch(count, (newValue, oldValue) => { console.log(`count ${oldValue} => ${newValue}`); }) return { count } } }) app.mount(\"#app\") Compostion API中的watch允许监听对象的某一个属性，这非常的便捷，如下所示我们只侦听ary中最后一位数据项的变化： \"use strict\"; const { ref, reactive, watch } = Vue; const app = Vue.createApp({ setup(props, context) { let ary = reactive( [\"A\", \"B\", \"C\", \"D\"] ); function callbackfn(index, event) { ary[index] = event.target.value } // 第一个参数必须是一个函数，返回你要侦听的对象属性 // 第二个参数是回调函数(新值，旧值) // 如下所示，只侦听ary的最后一个元素变更 watch(() => ary[ary.length - 1], (newValue, oldValue) => { console.log(`ary last element change : ${oldValue} => ${newValue}`); }) return { ary, callbackfn } } }) app.mount(\"#app\") Composition API中的watch现在可以更加方便的实现监听多个属性的变化了，相对于Options API中的watch这一点十分强大。 下面这个例子中不管是number1发生改变还是number2发生改变，都将触发watch的回调函数： {{number1}} {{number2}} \"use strict\"; const { ref, reactive, watch } = Vue; const app = Vue.createApp({ setup(props, context) { let number1 = ref(100); let number2 = ref(100); // watch(数组, 回调函数(数组, 数组)=>{}) watch([number1, number2], ( ( [number1NewValue, number1OldValue], [number2NewValue, number2OldValue] ) => { console.log(`number1 change ${number1NewValue} ${number1OldValue}`) console.log(`number2 change ${number2NewValue} ${number2OldValue}`) } )) return { number1, number2 } } }) app.mount(\"#app\") watch中允许传入第三个参数配置对象，如下示例: {{message}} \"use strict\"; const { ref, reactive, watch } = Vue; const app = Vue.createApp({ setup(props, context) { let message = reactive( [ { id: 1, name: \"Jack\", age: 19 }, { id: 1, name: \"Tom\", age: 18 }, { id: 1, name: \"Mary\", age: 21 } ] ) watch(message, ((newValue, oldValue) => { console.log(`message change ${oldValue} => ${newValue}`); } ), { // 及早侦听，默认为false，如果为true，它将会在页面一打开就触发callbackfn，而不是在数据发生变更时才触发callbackfn // 默认的watch为false，即惰性侦听，只有在在数据发生变更时才触发callbackfn immediate: true, // 深度侦听，默认为true， 即当多层对象嵌套时它会侦听所有对象内部的变化，而不仅仅是一层 deep: true }) return { message, } } }) app.mount(\"#app\") watchEffect Composition API中新增了watchEffect侦听。 它与watch侦听的区别在于： watchEffect是对当前setup()函数下所有数据的全局侦听，而watch只能侦听一个或者多个，需要我们手动进行配置 watchEffect的侦听回调函数是没有参数的，而watch侦听的回调函数是具有参数的 watchEffect的侦听是及早侦听，而watch的侦听默认是惰性侦听（可通过配置项配置为及早侦听） 如下示例，我们使用watchEffect侦听当前setup()函数中所有数据的变化： name age gender male female \"use strict\"; const { ref, reactive, watchEffect } = Vue; const app = Vue.createApp({ setup(props, context) { let name = ref(\"\"); let age = ref(0); let gender = ref(\"male\"); // 会监听name、age、gender。 // 只能拿到当前的值，不能拿到之前的值 watchEffect(() => { console.log(\"start watchEffect\"); console.log(name.value); console.log(age.value); console.log(gender.value); }) return { name, age, gender } } }) app.mount(\"#app\") 其他知识 钩子函数变更 在Options API中如果你需要定义生命周期钩子函数，则只需要新增对应的选项即可，如： \"use strict\"; const app = Vue.createApp({ beforeCreate(){ console.log(\"beforeCreate\"); }, created(){ console.log(\"created\"); } }) app.mount(\"#app\") 而在Composition API中，你必须先导入这些钩子函数，然后在setup()函数中对它们进行使用，注意导入时需要加上前缀on，如下所示： \"use strict\"; const { onBeforeMount, onMounted } = Vue; const app = Vue.createApp({ setup(props, context) { onBeforeMount(() => { console.log(\"beforeMount\"); }) onMounted(() => { console.log(\"mounted\"); }) } }) app.mount(\"#app\") 官方例举了它们详细的变更记录，如下表所示： Options API Composition API beforeCreate 没有了，被setup()函数取代了 created 没有了，被setup()函数取代了 beforeMount onBeforeMount mounted onMounted beforeUpdate onBeforeUpdate updated onUpdated beforeUnmount onBeforeUnmount unmounted onUnmounted errorCaptured onErrorCaptured renderTracked onRenderTracked renderTriggered onRenderTriggered activated onActivated deactivated onDeactivated 辅助性函数 setup()中可以定义任何数据或者对象，当你的业务非常复杂时，我们也可以定义多个辅助性函数来让代码结构更清晰，如下所示： {{aData.a}} {{bData.b}} \"use strict\"; const { ref, reactive, computed } = Vue; // 数据A相关逻辑 function logicA() { const _a = ref(\"a\"); const a = computed({ get() { return _a.value } }) const callbackfn = () => { console.log(\"hello a\"); } return { a, callbackfn } } // 数据B相关逻辑 function logicB() { const _b = ref(\"b\"); const b = computed({ get() { return _b.value } }) const callbackfn = () => { console.log(\"hello b\"); } return { b, callbackfn } } const app = Vue.createApp({ setup(props, context) { // 调用辅助性函数 const aData = reactive(logicA()); console.log(aData); const bData = reactive(logicB()); return { aData, bData } } }) app.mount(\"#app\") 获取真实DOM对象 在某些时候我们需要获取真实的一个DOM对象，该如何做呢？ 其实你可以为这个元素绑定一个ref属性，该ref属性指向setup()函数中的一个变量。 然后我们可以通过这个变量的value属性拿到真实的DOM对象，它同样也适用于为组件进行绑定。等同于Vue2中的this.$refs的用法。 整体流程如下所示： span div \"use strict\"; const { ref, reactive, onMounted } = Vue; const app = Vue.createApp({ setup(props, context) { // 2. 绑定的变量必须通过ref进行包裹 let spanNode = ref(null); let divNode = ref(null); // 3.接下来你就可以通过value属性拿到DOM元素或者组件本身 onMounted(() => { { console.log(spanNode.value); // span console.log(divNode.value); // div } }) // 你必须将它们返回出去 return { spanNode, divNode } } }) app.mount(\"#app\") Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:48 "},"前端专栏/Vue3/Vue-CLI.html":{"url":"前端专栏/Vue3/Vue-CLI.html","title":"Vue-CLI","keywords":"","body":"Vue-cli 安装cli Vue-cli是Vue官方发布的构建Vue项目的脚手架，通过Vue-cli我们可以快速的生成Vue项目以及构建开发环境。 一言以蔽之，使用Vue-cli能让你的Vue项目搭建更加轻松，测试更加方便。 首先先全局安装最新版的Vue-cli： $ npm install -g @vue/cli 安装完成后使用以下命令查看版本，注意Vue-cli版本号必须大于4.5才能运行Vue3项目： $ vue -V 如果你之前安装过Vue-cli，可通过以下命令进行升级： $ npm update -g @vue/cli 如果你习惯使用yarn而不是npm，则输入以下命令即可： $ yarn global add @vue/cli -- 安装 $ yarn global upgrade --latest @vue/cli -- 升级 创建项目 在Vue3版本后，对于项目的构建我们推荐使用Vite来进行，在Vue2时期，你可以通过直接通过Vue-cli来构建你的项目，Vite相比于直接通过Vue-cli创建项目来说更加的简单也更容易上手。 下面让我们构建自己的第一个Vue工程化项目，注意项目的命名风格必须是kebab-case风格： $ npm init @vitejs/app 在运行完上面的命令后，它会让你输入构建项目的框架framework，选择vue即可，另外会让你选择语言类型，如果不用TypeScript，则选用vue即可： ✔ Package name: … demo-project ✔ Select a framework: › vue ✔ Select a variant: › vue 下一步我们需要进入到刚刚创建的项目中： $ cd 运行以下命令安装package.json中所有的依赖： $ npm install 接下来你就可以启动这个Vue项目了，默认项目的端口是3000： $ npm run dev 如果你习惯使用yarn而不是npm，则输入以下命令即可： $ yarn create @vitejs/app $ cd $ yarn $ yarn dev 注意！如果你的Node版本是V7及以上，则需要在启动项目之前运行下面这一条命令来重新安装esbuild，否则项目将不能启动： $ node node_modules/esbuild/install.js 以下是启动后的界面，这个count是可以点击的，算是一个小demo吧： 目录解析 以下是整个Vue初始化项目的目录结构： ├── node_modules │ ├── ... ├── public │ └── favicon.ico ├── src │ ├── App.vue │ ├── assets │ │ └── logo.png │ ├── components │ │ └── HelloWorld.vue │ └── main.js ├── index.html ├── package-lock.json ├── package.json ├── README.md ├── .gitignore └── vite.config.js 当前根目录下子目录说明： node_modules：项目所需要的模块安装目录 public：存放公共的静态资源文件 src：源代码文件 *dist：当运行npm run build命令后会生成该目录，存放打包后的资源文件 当前根目录下的文件说明： index.html：由于Vue更多的是单页面开发，所以index.html也就是这个项目的单页面，你可以将它理解为根组件模板，可在此中引入css-reset等文件 package-lock.json：项目中固定版本的依赖包清单文件 package.json：项目中非固定版本的依赖包清单文件，npm脚本存储的文件 README.md：项目的详细信息描述文件 .gitgnore：git管理时忽略的目录或文件清单 vite.config.js：项目配置文件，在Vue2时期该文件名为vue.config.js src目录中的子目录与文件说明： assets：项目中组件的静态资源目录，可创建imgs、video等目录存放静态资源 components：项目中组件的存放目录，可在内创建更详细的子目录用于区分不同功能的组件 App.vue：根组件，即index.html中#div所挂载的组件 main.js：项目入口文件，用于将App.vue和index.html进行挂载联系 *router：存放路由文件的目录，通常情况下需要使用Vue-router插件后方可具备 *store：存放数据文件的目录，通常情况下需要使用VueX插件后方可具备 npm脚本 使用Vite构建Vue项目后，它默认的会添加3个npm脚本，我们可以在package.json中查看到： { \"scripts\": { \"dev\": \"vite\", // 启动开发服务器 \"build\": \"vite build\", // 为生产环境构建产物 \"serve\": \"vite preview\" // 本地预览生产构建产物 } } 运行npm脚本，你需要通过以下方式执行上面的3个命令： $ npm run 脚本名称 我们还可以指定额外的命令行选项，如 --port或 --https。运行npx vite --help获得完整的命令行选项列表。 启动流程 当我们执行了npm run dev后，它内部会做哪些事情呢？我们可以从index.html文件中入手，首先它的结构其实很简单，就是一个普普通通的HTML文件，只不过在标签内部加入了根组件模板元素div#app以及导入了main.js： 接下来我们可以看一下main.js，可以很清晰的看到它就是通过App.vue创建了一个Vue应用： import { createApp } from 'vue' import App from './App.vue' createApp(App).mount('#app') 而关于App.vue，仔细看以及标签的内容，它的标签内部其实采用了Vue3的语法，下面我们会对其进行详细介绍，至于中的内容你目前可以将它看成下面这一段代码： import HelloWorld from \"./components/HelloWorld.vue\"; export default { components: { HelloWorld, }, }; 这一段代码的意思是说，导出了一个默认的组件，并且该组件中注册了一个HelloWorld的子组件，而且还在模板中进行了使用，至于为什么App.vue中这个导出的组件没有定义template属性呢，实际上它内部已经定义好了，就是指向下面这个template。 然后我们需要看一下，HelloWorld组件，也是关注一下标签就好，你可能现在看不懂这个文件（你电脑上的），没关系，我们可以参照下面这个代码： export default { name : \"HelloWorld\", props : { msg : String }, data(){ return { count : 0 } } } 很简单，它通过props接收了一个msg，就是App.vue中传递的那个。 然后内部的data()中返回了一个count，这个count计数为0。其他就没什么了，至此我们的启动流程算是跑完了，以下是关于初始化项目中组件的划分： 一些细节 @符号 在Vue2的组件中当你需要通过import语句导入其他组件或资源时，可通过@符号代指src目录，如下示例： import HelloWorld from \"@/components/HelloWorld.vue\"; 但是在Vue3中需要我们自己来进行配置，打开vite.config.json文件，粘贴一下内容即可： import { resolve } from 'path' import { defineConfig } from 'vite' import vue from '@vitejs/plugin-vue' // https://vitejs.dev/config/ export default defineConfig({ plugins: [vue()], resolve: { alias: { \"@\": resolve(__dirname, \"src\") } } }) 如果你熟悉webpack，那么上面的操作对你来说肯定不会陌生，如果你不熟悉webpack也没关系，它其实就是为src目录取一个别名而已。 vue文件 vue文件你可以将它认为是一个独立的组件，通常情况下该文件的命名风格均采用大驼峰式命名法。 我们以App.vue来进行举例，每个vue文件都有3部分组成，且在中书写组件时不需要指定template属性，它内部会自动的进行挂载： // 组件内容 // 组件模板 // 组件样式 下面我们可以自己书写一个组件，并在App.vue中进行注册： # src/components/Test.vue export default { name: \"test\", data() { return { message: \"test component\", }; }, }; {{ message }} div { display: inline-block; background: #fff; padding: 1rem; } 然后再到App.vue中导入并注册： # src/components/App.vue import Test from \"@/components/Test.vue\" export default { components: { Test, }, }; #app { font-family: Avenir, Helvetica, Arial, sans-serif; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; text-align: center; color: #2c3e50; margin-top: 60px; } 注意在导入一个vue文件时必须要添加上后缀名： import Test from \"./components/Test.vue\"; 如果你不想添加后缀名，也可以通过vite.config.js来进行设置，总体配置和webpack差不多： import { resolve } from 'path' import { defineConfig } from 'vite' import vue from '@vitejs/plugin-vue' // https://vitejs.dev/config/ export default defineConfig({ plugins: [vue()], resolve: { alias: { \"@\": resolve(__dirname, \"src\") }, extensions: [\".vue\",] // 忽略后缀名，自动匹配 } }) 当配置完成后，在导入vue文件时就不需要加上后缀了： import Test from \"@/components/Test\"; style - scoped 通过观察可以发现，除了根组件App.vue外的其他组件中，标签会多一个属性scoped。 添加了该属性的的样式只会在当前组件中生效。 这意味着App.vue的全局生效的，你可以在此引入一些公共的样式资源，如reset-css： @import url(\"./assets/css/css-reset.css\"); script - setup Vue3的工程化项目中，几乎所有的标签都会有一个setup属性，这正是Composition API所带来的变化。 它的意思在于，在这个标签中你可以直接书写之前在setup()中的代码，且不用再进行return暴露接口的操作。 除此之外，它内部会自动进行export将该组件进行导出，如下所示： 我们以HelloWorld组件来进行举例，下面是它原本的代码，实际上就是Composition API的setup()简写： // 不用return {msg} ，内部会自动进行 // 也不用return export， 内部会自动进行 import { ref } from 'vue' defineProps({ msg: String }) const count = ref(0) 将它修改成完整的Composition API，效果一致，代码量增加： import { ref } from \"vue\"; export default { name: \"HelloWorld\", props: { msg: String, }, setup(props, context) { return { count: ref(0), }; }, }; 将它修改成Options API，效果一致，代码量增加： export default { name : \"HelloWorld\", props : { msg : String }, data(){ return { count : 0 } } } setup中的API 实际上是实验的功能，不排除后期会全部进行应用。 在中编写代码时，需要注意以下API的变更。 如果想注册组件，直接import即可，它会自动进行注册： import Cpn from \"@/components/Cpn.vue\" 使用defineProps替代props： const props = defineProps({ foo: String }) 使用defineEmits代替context.emit()： // 先注册 const emit = defineEmits(['change', 'delete']) // 再使用 emit(\"change\", \"Hello\") emit(\"delete\", 1) 其他更多API请参阅官方文档 项目上手 项目一览 我们以一个todolist来作为Vue-cli的熟悉项目，最终效果如下： 上面这个例子由1个大组件和3个小组件构成，分别是： main-cpn：整体组件 header-cpn：头部组件 left-cpn：左侧日程选择组件 right-cpn：右侧日程展示组件 我们需要在components目录中新建一个toListCpn的子目录，并且将这些组件放进去，再次提醒，vue文件的命名要以大驼峰式命名法进行： src/components/ └── toListCpn ├── Header.vue ├── Left.vue ├── Main.vue └── Right.vue 选项式API演示 首先需要从App.vue中引入Main.vue，并且定义一些全局样式： import Main from \"./components/toListCpn/Main.vue\"; export default { components: { Main, }, }; * { margin: 0; padding: 0; box-sizing: border-box; } #app { display: flex; justify-content: center; align-items: center; height: 100vh; } 其次是Main.vue的代码，我们定义了事件列表eventList与一系列修改事件列表的方法，因为该组件所产生的数据对象eventList会分发给其他组件，所以当其他组件需要修改事件列表时也必须依赖该组件所提供的方法： import Header from \"./Header.vue\"; import Left from \"./Left.vue\"; import Right from \"./Right.vue\"; export default { name: \"Main\", data() { return { eventList: [], }; }, methods: { registerEvent(time, event) { this.eventList.push({ time, event, finish: false }); }, unRegisterEvent(index) { this.eventList.splice(index, 1); }, changeEventStatus(index) { this.eventList[index].finish = !this.eventList[index].finish; }, }, components: { Header, Left, Right, }, }; main { border: 1px solid #ddd; background: #4ca64c; } main:before { clear: both; content: \"\"; display: block; } 接下来是Header.vue的代码，Header组件只需要获取eventList即可，因为它仅展示eventList中的已注册事件和已完成事件： {{ currentTime }} 已完成({{ getFinishEvent }})/今日事件({{ getTotalEvent }}) export default { name: \"Header\", props: { eventList: Array, }, computed: { getTotalEvent() { return this.eventList.length; }, getFinishEvent() { return this.eventList.reduce((pre, cur, idx, ary) => { return (pre += cur.finish ? 1 : 0); }, 0); }, currentTime() { const date = new Date(); let format = \"YYYY年MM月DD日\"; const config = { YYYY: date.getFullYear(), // 获取年份 MM: date.getMonth() + 1, // 获取月份，月份+1是因为Js中的月份是0-11 DD: date.getDate(), // 获取天数 HH: date.getHours(), // 获取小时 mm: date.getMinutes(), // 获取分 ss: date.getSeconds(), // 获取秒 }; for (const key in config) { format = format.replace(key, config[key]); } return format; }, }, }; #header { width: 400px; height: 80px; padding: 0.5rem; margin-bottom: 0.5rem solid #ddd; border-bottom: 1px solid #ddd; } #header div:first-of-type { font-size: 1.6rem; } #header div:last-of-type { font-size: 0.8rem; } 然后是Left.vue的代码，Left组件中只需要接收注册事件的方法即可： {{ time }} export default { name: \"Left\", props: { registerEvent: Function, }, data() { return { eventDescribe: \"\", eventTime: null, }; }, computed: { timeList() { let time = []; for (let i = 0; i #left { width: 200px; height: 200px; padding: 0.5rem; float: left; border-right: 1px solid #ddd; background: #4cd66a; } #left input { width: 100%; height: 18%; margin-bottom: 2%; outline: none; } #left ul { list-style: none; text-align: center; height: 80%; overflow-y: scroll; background: #fff3fe; } #left ul li:hover { background-color: #ddd; font-size: 1.4rem; cursor: pointer; } 最后是Right.vue的代码，Right组件中所做的工作比较多，需要注销事件、修改事件状态、删除事件，但是代码量很少，因为这些方法都在Main组件中定义好了，直接调用即可，如下所示： {{ row.time }} {{ row.event }} 删除 export default { name: \"Right\", props: { eventList: Array, unRegisterEvent: Function, changeEventStatus: Function, }, }; #right { width: 200px; height: 200px; padding: 0.5rem; float: left; overflow-y: scroll; background: #fff3fe; } #right > ul { height: 100%; margin-bottom: 2%; } #right > ul li:after { clear: both; content: \"\"; display: block; } #right > ul li:hover button { display: inline-block; } #right > ul li { border: 1px solid #aaa; padding: 0 0.5rem; height: 1.5rem; } #right > ul li > input[type=\"checkbox\"] { margin-right: 5%; } #right > ul li > time { width: 3rem; display: inline-block; margin-right: 5%; text-align: left; } #right > ul li > span { width: 70%; } #right > ul li > button { float: right; } #right > ul li > button { display: none; } 组合式API演示 我们基于上面选项式API来将所有的JavaScript代码改装成Vue3的组合式API。 首先是App.vue，它只需要直接导入Main组件即可，内部会自动将该组件注册成为App的子组件： import Main from \"./components/toListCpn/Main.vue\"; 其次是Main.vue，在它里面我们需要使用reactive将eventList修改为响应式的，且还需要使用provide将数据分发给子组件们： import { reactive } from \"vue\"; import { provide } from \"vue\"; import Header from \"./Header.vue\"; import Left from \"./Left.vue\"; import Right from \"./Right.vue\"; const eventList = reactive([]); const registerEvent = (time, event) => { eventList.push({ time, event, finish: false }); }; const unRegisterEvent = (index) => { eventList.splice(index, 1); }; const changeEventStatus = (index) => { eventList[index].finish = !eventList[index].finish; }; provide(\"eventList\", eventList); provide(\"registerEvent\", registerEvent); provide(\"unRegisterEvent\", unRegisterEvent); provide(\"changeEventStatus\", changeEventStatus); 下面是Header.vue的代码，Header组件只需要通过inject接收Main组件中provide过来的eventList即可： {{ currentTime }} 已完成({{ getFinishEvent }})/今日事件({{ getTotalEvent }}) import { inject } from \"vue\"; import { computed } from \"vue\"; let eventList = inject(\"eventList\"); let getTotalEvent = computed(() => { return eventList.length; }); let getFinishEvent = computed(() => { return eventList.reduce((pre, cur, idx, ary) => { return (pre += cur.finish ? 1 : 0); }, 0); }); let currentTime = computed(() => { const date = new Date(); let format = \"YYYY年MM月DD日\"; const config = { YYYY: date.getFullYear(), // 获取年份 MM: date.getMonth() + 1, // 获取月份，月份+1是因为Js中的月份是0-11 DD: date.getDate(), // 获取天数 HH: date.getHours(), // 获取小时 mm: date.getMinutes(), // 获取分 ss: date.getSeconds(), // 获取秒 }; for (const key in config) { format = format.replace(key, config[key]); } return format; }); 然后是Left.vue的代码，这里面需要借助inject、computed以及ref，注意在timeClickfn()的回调函数中eventDescribe等经过ref包裹的属性设置值时一定要通过proxy.value属性进行： import { inject } from \"vue\"; import { computed } from \"vue\"; import { ref } from \"vue\"; const registerEvent = inject(\"registerEvent\"); const eventDescribe = ref(\"\"); const eventTime = ref(null); const timeList = computed(() => { let time = []; for (let i = 0; i { if (!eventDescribe.value) { alert(\"您还未输入日程信息\"); return; } eventTime.value = time; registerEvent(eventTime.value, eventDescribe.value); eventDescribe.value = \"\"; }; 最后是Right.vue，它的改造最简单，只需要将props接收的属性通过inject接收即可： import { inject } from \"vue\"; const eventList = inject(\"eventList\"); const unRegisterEvent = inject(\"unRegisterEvent\"); const changeEventStatus = inject(\"changeEventStatus\"); Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:48 "},"前端专栏/Vue3/Vue-Router.html":{"url":"前端专栏/Vue3/Vue-Router.html","title":"Vue-Router","keywords":"","body":"Vue-Router 基本介绍 Vue-Router是Vue全家桶中至关重要的一个扩展化插件，使用它能够让我们的组件切换更加的方便，更加容易的开发前后端分离项目，目前Vue-Router版本已更新到4.x，我们就以4.x为例了解它的用法。 官方文档 后端路由 学习Vue-Router之前，我们有必要了解一下什么是后端路由。 在早期前后端混合开发时，前端具体所展示的内容是由后端负责的，也就是说用户在浏览器中的一次请求操作会直接传递到后端服务器上，后端服务器会根据这个请求内容返回给浏览器不同的页面，如下所示： 前端路由 现在的项目越来越大，前后端混合的开发模式并不适用于大型项目，于是出现了前后端分离的开发模式，即用户在页面上所有静态资源请求大部分都是面向前端服务器发起的，然后再由前端服务器动态请求后端服务器的API接口获得所需要展示的数据最终结合前端服务器中的静态资源反馈给浏览器： 前置知识 简单认识url 用户与Web服务器之间是经由浏览器通过url打交道的，因此在学习Vue-Router插件之前你应该掌握一些必要的url相关知识。 下面是url的组成部分，截图自Node.js官网中对url的描述： 值得注意的是，auth部分是对身份权限的认证，目前在绝大多数应用中已经极少看到了，因此这里不再进行介绍。 我们以下面这个url进行说明： https://localhost/book/1?page=2#caption_01 释义如下： https：代指请求协议，最常见的有http与https协议 localhost：为host主机部分，其实完整写法应该是localhost:80，但是浏览器会自动为我们填上一个80的端口号，所以上面没有显式的写出来 /book/1：这一段是path即请求的资源路径（服务器上不一定真实存在），通常情况下/book这一段是固定的。而/1这个只是一个书籍编号而已，它不是固定的，因此对于1来说他可以作为查询的params，即查询参数，这在RestAPI设计风格中极为常见 ?page=2：这一段是请求的具体参数，即query部分，指的是我们请求book1这本书从第2页开始 #caption_01：一个锚点的跳转，用于定位具体的内容，当打开这个url后它会直接跳转到第二章节，注意该部分绝大多数情况下都不会被路由系统所处理 单页面原理 Vue单页面开发的原理实际上就是利用标签的锚点切换来完成的，举个例子。 访问下面的这个url就是主页： http://loclhost/#/index 跳转时只需要修改锚点的定位即可，如从首页跳转到新闻页面： http://loclhost/#/news 下面我们基于此原理利用原生的HTML+CSS来实现一个单页面应用： 代码示例： * { margin: 0; padding: 0; box-sizing: border-box; list-style: none; } .components { display: none; } :target { display: block; } body header { background-color: #565656; height: 48px; } body header ul { height: 100%; display: flex; flex-flow: row wrap; align-items: center; padding: 1rem; } body header ul li:first-of-type, body header ul li:nth-of-type(2) { margin-right: 2rem; } body header ul li:last-of-type { margin-left: auto; } body header ul li a { color: #fff; text-decoration: none; } body main { display: flex; justify-content: center; align-items: center; margin-top: 68px; font-size: 5rem; } 主页 新闻 后台 HELLO INDEX HELLO NEWS HELLO BACKEND hash与history Vue-Router中对于组件的切换有2种模式，分别是hash模式和history模式。 当使用hash模式时，若你访问/index页面则浏览器地址栏中的url是这个样子的： http://loclhost/#/index 而使用history模式时，url看起来会正常许多： http://loclhost/index 使用hash模式的优缺点如下： 优点是#后面的信息永远不会被发送到Vue服务器的路由上，因此不会出现请求错误的情况 缺点是对SEO会有不好的影响，以及看起来不是那么美观 而使用history模式的优缺点如下： 优点是组件的切换看起来不再是锚点定位了，更加的美观了 缺点是如果用户在浏览器中直接访问某个嵌套的子组件时，会报404错误，并且我们还需要在服务器上加上一个回退路由，所以配置比较麻烦 hash模式是我们在开发时建议使用的，尽管history模式让url看起来美观了许多，但是你需要做一些额外的配置，过程比较繁琐，你可以参阅官方文档寻找这部分的资料。 hash和history其实都是window的2个子对象，使用location.hash可修改当前url中#后的部分，比如我们在浏览器的控制台中输入以下命令： location.hash = \"/index\" 你会发现浏览器的地址栏中url会变更为： http://localhost:5500/#/index 同理，history模式也提供了一些链接跳转的方法支持。 如，在浏览器的控制台中输入以下命令： history.pushState({}, \"\", \"/index\") 你会发现浏览器的地址栏中url会变更为： http://localhost:5500/index 如果你想了解更多，请参照之前JavaScript中的widnow对象章节。 历史记录栈 当浏览一个网页时，只要地址栏中的url发生改变都会被浏览器记录到一个“栈”中。 如下所示，我们先浏览了index.html、然后又浏览了news.html、最后浏览了backend.html： 当你点击back按钮或者调用router.back()以及history.back()方法后，它会向后回退一格，同时图中左侧的计数器也会发生变化： 同理，当你点击forward按钮或者调用router.forward()以及history.forward()方法后，它又会向前推进一格，回到图1的状态： 如果你通过router.go()或者history.go()方法，并且填入的参数是-2时，那么它会向后回退2格，变成下面这种状态： 而router.replace()的意思是，跳转至新的页面，并且清空整个栈，如下所示，它等同于history.replaceState()方法： 基本使用 初始化项目 使用Vite生成项目，跟随指引一步一步的进行初始化： $ npm init @vitejs/app 进入到项目根目录下，安装Vue-Router插件，输入以下命令后它将会安装Vue-Router 4.x的最新版本： $ npm install vue-router@4 在src下新建一个router目录，并在其中新建一个index.js文件，该文件将作为Vue-Router插件的入口文件存在： $ mkdir ./src/router $ touch ./src/router/index.js 删除.src/components/HelloWorld.vue： $ rm -rf ./src/components/HelloWorld.vue 清空.src/App.vue中的代码，并粘贴下面的代码： hello world 接下来你就可以启动这个Vue项目了，默认项目的端口是3000： $ npm run dev 快速的上手 我们需要先准备3个组件、分别是Index、Book、Hot，代码基本一致： Hello Index h1 { font-size: 8rem; } 要想使用Vue-Router插件，我们就必须在.src/router/index.js文件中对其进行引入： // 1. 导入使用hash模式、使用history模式、以及创建全局路由对象的方法 import { createWebHashHistory, createWebHistory, createRouter } from \"vue-router\"; // 2. 导入组件 import Index from \"../components/Index.vue\" import Book from \"../components/Book.vue\" import Hot from \"../components/Hot.vue\" // 3.配置路由映射表 const routes = [ { path: \"/index\", component: Index }, { path: \"/book\", component: Book }, { path: \"/hot\", component: Hot }, ] // 4.创建全局路由对象，并且使用hash模式初始化这个全局路由对象 const router = createRouter({ routes, history: createWebHashHistory() }) // 5.导出全局路由对象 export default router 然后需要到.src/main.js中为当前的Vue应用加载这个插件： import { createApp } from 'vue' import App from './App.vue' import router from \"./router/index\" const app = createApp(App); // 加载插件 app.use(router); app.mount('#app'); 最后修改一下App.vue的代码，我们要在App.vue中使用以及组件来做路由的入口和出口，注意以及组件都是Vue-Router所自带的组件，内部已完成全局注册，可以直接使用： 主页 书籍 热门 后，路由表中的组件会在此处显示 --> // 注册组件 import Index from \"./components/Index.vue\"; import Book from \"./components/Book.vue\"; import Hot from \"./components/Hot.vue\"; /* 全局样式设置 */ * { margin: 0; padding: 0; box-sizing: border-box; list-style: none; } header#header { height: 50px; padding: 1rem; background: #565656; display: flex; justify-content: flex-start; align-items: center; box-shadow: #aaa 0 5px 5px; } header#header a { text-decoration: none; margin-right: 2rem; color: #fff; } main#main { display: flex; flex-flow: column; justify-content: center; align-items: center; height: 80vh; } 实际上中的to属性也可以不用进行动态绑定，而是直接填入path，但是我们并不推荐这样使用： 主页 主页 name具名路由 对.src/index.js里routes中每一条rule对象，我们都可以为它们加上一个name属性： const routes = [ { path: \"/index\", name: \"index\", component: Index }, { path: \"/book\", name: \"book\", component: Book }, { path: \"/hot\", name: \"hot\", component: Hot }, ] 这样在为模板中的设置to属性时，可以动态的绑定一个对象并指定需要跳转的rule的name属性即可： 主页 书籍 热门 alias路由别名 对.src/index.js里routes中每一条rule对象，我们都可以为它们加上一个alias属性： const routes = [ { path: \"/index\", name: \"index\", alias: [\"/index.htm\", \"/index.html\"], component: Index } ] 配置好之后不管你访问下面那个url，它都会跳转至Index组件中： http://localhost:3000/index http://localhost:3000/index.htm http://localhost:3000/index.html redirect重定向 如果想在路由中定义重定向，则只需要配置redirect属性即可： const routes = [ { path: \"/\", redirect: { name: \"index\" } }, { path: \"/index\", name: \"index\", alias: [\"/index.htm\", \"/index.html\"], component: Index }, ] 这样当你访问 localhost:3000 时，它会自动跳转到Index中。 meta定义路由元信息 对.src/index.js里routes中每一条rule对象，我们都可以为它们加上一个meta属性： const routes = [ { path: \"/index\", name: \"index\", alias: [\"/index.htm\", \"/index.html\"], meta: { title: \"主页\", verify: false }, component: Index } ] 在后续开发时，我们能通过一些方式拿到这些内容，因此你可以将meta属性定义成这个route的附加信息： import { onMounted } from \"vue\"; import { useRoute } from \"vue-router\"; const route = useRoute(); onMounted(() => { console.log(route.meta.verify); console.log(route.meta.title); }); router-link的点按效果 默认的点击后没有任何样式，我们可以在App.vue中配置一个全局的style，它的作用在于所有的点击后都会应用这个样式类，如下所示： .router-link-active { text-shadow: #ddd 2px 5px 5px !important; } 最终结果： 你也可以为每个单独添加active-class属性，然后定义属性值的class style，它的优先值高于.router-link-active： // template 主页 // style .choice_index{ color : red !important; } 路由对象 Router介绍 useRouter()是Vue-Router中提供的一个构造方法，调用它可以得到一个全局的Router对象，即整个routes路由映射表。 如果想在模板中使用这个全局路由对象，你可以直接像下面这样操作： {{ $router }} 要想在脚本中使用这个全局路由对象你必须先对其进行导入： import { useRouter } from \"vue-router\"; 接下来需要进行实例化操作： const router = useRouter(); 而后你就可以使用这个全局路由对象了，全局路由对象中可以调用很多方法、如push()、back()等，如下表所示： 方法 描述 push() 等同于window.history.pushState()，打开一个新的url replace() 等同于window.history.replaceState()，打开一个新的url，并清空当前活动窗口的历史记录 back() 等同于window.history.back()，执行页面回退操作 forward() 等同于window.history.forward()，执行页面前进操作 go(±n) 等同于window.history.go()，执行页面回退或前进n个操作 Route介绍 useRoute()是Vue-Router中提供的一个构造方法，调用它可以得到一个当前活动的Route对象，即当前所匹配到的rule。 如果想在模板中使用这个活动路由对象，你可以直接像下面这样操作： {{ $route }} 要想在脚本中使用这个活动路由对象你必须先对其进行导入： import { useRoute } from \"vue-router\"; 接下来需要进行实例化操作： const route = useRoute(); 而后你就可以使用这个活动路由对象了，活动路由对象中可以调用很多属性、如path、name等，如下表所示： 属性 描述 path 获取当前活动路由的path name 获取当前活动路由的name params 获取当前活动路由的params query 获取当前活动路由的query meta 获取当前活动路由的meta hash 获取当前活动路由的hash redirectedFrom 获取当前活动路由的前一个跳转链接 在脚本中进行跳转 如果你想在进行路由跳转，可以调用router.push()或者router.replace()方法，如下所示： import { onMounted } from \"vue\"; import { useRouter } from \"vue-router\"; const router = useRouter(); onMounted(() => { router.push({ name: \"book\" }); }); 获取路由的元信息 如果你想在中获取当前路由的meta元信息，可以调用route.meta获得整个meta对象，如下所示： import { onMounted } from \"vue\"; import { useRoute } from \"vue-router\"; const route = useRoute(); onMounted(() => { console.log(route.meta); }); 路由视图 嵌套视图 组件是允许嵌套的，当然也同样支持嵌套，举个例子，我们的Index中有2个子组件分别是login和register，当点击这2个组件中任何一个时我们希望在Index中展示这2个组件，而不是单独进行跳转。 首先我们需要在routes中为rule配置children选项，如下所示，注意第2层rule的path必须加上前缀： const routes = [ { path: \"/index\", name: \"index\", alias: [\"/index.htm\", \"/index.html\"], meta: { title: \"主页\", verify: false }, component: Index, children: [ { path: \"/index/login\", name: \"login\", meta: { title: \"登录\" }, component: Login }, { path: \"/index/register\", name: \"register\", meta: { title: \"注册\" }, component: Register }, ] }, ] 其次是需要在Index组件中开放和，此外还需要在Index组件中对Login和Register组件进行注册： 注册 登录 import Register from \"./Register.vue\"; import Login from \"./Login.vue\"; import { onMounted } from \"vue\"; import { useRoute } from \"vue-router\"; const route = useRoute(); onMounted(() => { console.log(route.meta); }); #index-header { height: 2rem; border: 1px solid #ddd; display: flex; align-items: center; padding: 0.5rem; background: #6b6b6b; } #index-header a { color: #fff; text-decoration: none; } #index-header a:first-of-type { margin-right: 0.5rem; } #index-main { width: 200px; height: 100px; border: 1px solid #ddd; display: flex; justify-content: center; align-items: center; } 下面是Login和Register组件的代码，它们的结构基本一致： login 效果展示，首先最外部的App.vue中具有一个，它主要作用于主页、书籍以及热门的切换，而在Index.vue中也具有一个，它则只用于登录或者注册的切换，于是这个嵌套关系就出来了： 命名视图 嵌套视图是具有层级的，而命名视图没有层级，即可以在一个组件模板中多次使用，它是一种扁平化的设计。 如，头部导航栏，左侧菜单栏，右边内容块三个组件，都显示在一个页面上，就可以使用命名视图，换而言之，命名视图是由多个组件构成一个页面的。 核心代码如下，由于命名视图使用较少，这里不再进行具体演示： // template // .src/router/index.js const routes = [ { path: \"/index\", name: \"index\", alias: [\"/index.htm\", \"/index.html\"], meta: { title: \"主页\", verify: false }, // 由于这个页面是由3个组件构成的，所以这里要使用components而不是component components: { // 如果没有name属性，则用default default: header, menu: menu, show: show, } }, ] 参数相关 params 从restAPI设计规范来看，url的路径不可能全部由routes进行配置，因为params总是动态变化的。 如下所示： GET localhost:3000/#/book // 查询所有书籍 GET localhost:3000/#/book/1 // 查询编号为1的书籍 GET localhost:3000/#/book/2 // 查询编号为2的书籍 我们需要有一个动态的路由机制，在rule中匹配时的代码如下： { path: \"/book/:id?\", name: \"book\", alias: [\"/book.htm\", \"/book.html\"], component: Book } // id代表接收的这个params名称是id // ?代表这个params可以有也可以没有 而则需要向下面这样设置： {{book.name}} 当你需要在模板中取得这个params时，需要通过当前路由对象route获得： {{ $route.params.id }} 当你需要在脚本中取得这个params时，也需要通过当前路由对象route获得： import { useRoute } from \"vue-router\"; const route = useRoute(); route.params.id 我们以Book组件为例，默认它将使用AllBook组件展示所有图书，当你选中一本图书后它将使用BookDetails组件展示书籍详情： Book组件代码如下： import AllBook from \"./AllBook.vue\"; import BookDetails from \"./BookDetails.vue\"; import { provide } from \"vue\"; import { reactive } from \"vue\"; import { useRoute } from \"vue-router\"; const route = useRoute(); const bookAry = reactive([ { id: 1, name: \"红楼梦\", author: \"曹雪芹\", chapter: [ \"第一回 甄士隐梦幻识通灵 贾雨村风尘怀闺秀\", \"第二回 贾夫人仙逝扬州城 冷子兴演说荣国府\", \"第三回 开生面梦演红楼梦 立新场情传幻境情\", ], }, { id: 2, name: \"西游记\", author: \"吴承恩\", chapter: [ \"第一回 灵根育孕源流出 心性修持大道生\", \"第二回 悟彻菩提真妙理 断魔归本合元神\", \"第三回 四海千山皆拱伏 九幽十类尽除名\", ], }, { id: 3, name: \"三国演义\", author: \"罗贯中\", chapter: [ \"第一回 宴桃园豪杰三结义 斩黄巾英雄首立功\", \"第二回 张翼德怒鞭督邮 何国舅谋诛宦竖\", \"第三回 议温明董卓叱丁原 馈金珠李肃说吕布\", ], }, { id: 4, name: \"水浒传\", author: \"施耐庵\", chapter: [ \"第一回 张天师祈禳瘟疫 洪太尉误走妖魔\", \"第二回 王教头私走延安府 九纹龙大闹史家村\", \"第三回 史大郎夜走华阴县 鲁提辖拳打镇关西\", ], }, ]); provide(\"bookAry\", bookAry); AllBook组件代码如下： {{ book.name }} import { inject } from \"vue\"; const bookAry = inject(\"bookAry\"); BookDetails组件代码如下： {{ book.name }} {{ book.author }} {{ chapter }} import { inject } from \"vue\"; const bookAry = inject(\"bookAry\"); query 在发送具有条件筛选的请求、或者提交具有数据的请求时query是非常常用的。 如下这个例子： GET localhost:3000/#/book/1?chapter=2 // 查询编号为1的书籍的第二章 而对于则需要向下面这样设置： {{book.name}} 当你需要在模板中取得这个query时，需要通过当前路由对象route获得： {{ $route.query.chapter }} 当你需要在脚本中取得这个params时，也需要通过当前路由对象route获得： import { useRoute } from \"vue-router\"; const route = useRoute(); route.query.chapter 这里我们不再进行演示，因为它和params是非常相似的。 导航守卫 基本概念 每个组件切换都需要经历两个阶段，你可以将它理解为2个保安。 前置守卫：对切换前的行为进行检查，检查通过后必须调用next()方法才能继续进行切换 后置守卫：对切换后的工作进行善后，可以理解为路由切换组件时最后运行的一个钩子函数 一般来说前置守卫使用较多，后置守卫使用较少。 全局守卫 在router全局路由对象中设置的导航守卫为全局守卫，如下所示我们希望组件在切换时能够获取当前活动路由对象的meta元信息中的title属性，以设置document的title。 下面这段代码可以放在./src/router/index.js中： router.beforeEach((to, from, next) => { // from为当前活动路由对象 // to为即将活动的下一个路由对象 console.log(`from : ${from.path} => to : ${to.path}`); next(); }) router.afterEach((to, from)=>{ document.title = to.meta.title || \"Web Site\" }) 路由守卫 我们也可以对某个route单独的配置守卫，当然这很少使用到： const routes = [ { path: \"/\", redirect: { name: \"index\" } }, { path: \"/index\", name: \"index\", component: Index, beforeEnter: (to, from) => { // false拦截、true通过 return false }, } ] 组件守卫 我们也可以单独的为某一个组件添加以下守卫，当然这也很少使用到： import { onBeforeRouteLeave, onBeforeRouteUpdate } from 'vue-router' export default { setup() { onBeforeRouteLeave((to, from, next) => { next() }) onBeforeRouteUpdate((to, from, next) => { next() }) }, } keep-alive 组件缓存 的时候我们希望当组件发生切换后，再次back回来时之前被切换的组件仍然保留被切换之前的状态，当出现这种需求时就可以采用进行组件缓存。 如下示例，我们缓存了Register组件和Login组件，这样在用户输入过程中切换组件会保留组件的状态： 代码如下： 钩子函数 Vue3中提供了2个生命周期钩子函数： onActivated：被 keep-alive 缓存的组件激活时调用 onDeactivated：被 keep-alive 缓存的组件失活时调用 常用属性 以下是上可添加的一些属性： include : string | RegExp | Array 只有名称匹配的组件会被缓存。 exclude : string | RegExp | Array 任何名称匹配的组件都不会被缓存。 max : number | string 最多可以缓存多少组件实例。 示例演示: 其他知识 资源懒加载 在使用Vite进行项目打包后，所有的资源文件都会整合到一起，最终输出一个chunk。 这样做会带来一个问题，当你的项目过大时用户打开页面首次加载chunk会显得非常慢，因为它会将所有的组件、第三方库一次性加载出来。 这种情况下，我们就需要进行按需加载了，对于没有展示的组件或没有使用的第三方库暂时不进行加载，当进行路由跳转时才进行加载，如下所示： // 将 // import UserDetails from './views/UserDetails' // 替换成 const UserDetails = () => import('./views/UserDetails') const router = createRouter({ // ... routes: [{ path: '/users/:id', component: UserDetails }], }) 修改完成后再次打包，你会发现它将输出多个chunk。 组件切换动画 想要在你的路径组件上使用转场，并对导航进行动画处理，你需要使用 v-slot API： Transition 的所有功能 在这里同样适用。 上面的用法会对所有的路由使用相同的过渡。如果你想让每个路由的组件有不同的过渡，你可以将元信息和动态的name 结合在一起，放在上： const routes = [ { path: '/custom-transition', component: PanelLeft, meta: { transition: 'slide-left' }, }, { path: '/other-transition', component: PanelRight, meta: { transition: 'slide-right' }, }, ] 也可以根据目标路由和当前路由之间的关系，动态地确定使用的过渡。使用和刚才非常相似的片段： 我们可以添加一个 after navigation hook，根据路径的深度动态添加信息到meta字段。 router.afterEach((to, from) => { const toDepth = to.path.split('/').length const fromDepth = from.path.split('/').length to.meta.transitionName = toDepth 版本区别 Route和Router 在Options API中，如果想要在中获取Route或者Router需要使用this进行调用： export default { name : \"Index\", data(){ return {} }, mounted(){ console.log(this.$route); console.log(this.$router); } } 组件守卫 在Options API中，组件守卫多了一个钩子函数，尽管很少使用，但是还是要列出来，如下所示： const UserDetails = { template: `...`, beforeRouteEnter(to, from) { // 在渲染该组件的对应路由被验证前调用 // 不能获取组件实例 `this` ！ // 因为当守卫执行时，组件实例还没被创建！ }, beforeRouteUpdate(to, from) { // 在当前路由改变，但是该组件被复用时调用 // 举例来说，对于一个带有动态参数的路径 `/users/:id`，在 `/users/1` 和 `/users/2` 之间跳转的时候， // 由于会渲染同样的 `UserDetails` 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。 // 因为在这种情况发生的时候，组件已经挂载好了，导航守卫可以访问组件实例 `this` }, beforeRouteLeave(to, from) { // 在导航离开渲染该组件的对应路由时调用 // 与 `beforeRouteUpdate` 一样，它可以访问组件实例 `this` }, } keep-alive&transition 在Vue2中，keep-alive和transition调用很简单，如下所示： Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:48 "},"前端专栏/Vue3/Vue-X.html":{"url":"前端专栏/Vue3/Vue-X.html","title":"Vue-X","keywords":"","body":"Vue-X 基本介绍 Vue-X是Vue全家桶中非常重要的一环，它能够使我们更加方便的集中管理组件中的数据，在大型项目中Vue-X的使用频率非常之高，因此Vue-X的学习是必不可少的。 目前Vue-X版本已更新到4.x，我们就以4.x为例了解它的用法。 官方文档 优势对比 在之前我们通过props与$emit()亦或是provide()和inject()的方式进行组件通信时，所有的数据都是绑定在某个组件内部的，如果其他组件想要使用以及修改这些数据，则必须由数据源组件将数据与修改方法进行下发。 对于props与$emit()通信来说，它的数据传递过程会显得十分繁琐，必须由父组件通过props一层一层的将数据向下进行传递，或者通过$emit()将数据一层一层往上进行传递，如果组件层级过多，则会导致后期代码维护困难的问题出现。 而Vue-X则将公用数据与组件进行剥离，你可以将它理解为是一个数据仓库，组件树中所有的组件都能从这个数据仓库中获得想要的数据、同时组件树中任何一个组件对仓库中数据的修改均可以影响到其它的组件。 工作流程 每一个Vux-X你都可以将它理解为一个仓库，而在仓库中，有3个重要的概念： actions：行为 mutations：变化 state：状态 我们可以看一下这张图： 释义如下： vue components可以通过dispatch或者commit直接发生行为（actions）或者触发变化（mutations） actions只能是由vue components通过dipatch引起的，且它的作用只能是通过commit触发变化（mutations） state只能由mutations进行改变，并且改变后会及时的将数据进行响应并渲染在所有vue components中 devtools只能监听mutations 换而言之，仓库store中的数据状态（state）会发放给vue components，而当我们想要修改这些数据状态时则必须先通过dispatch发起行为（actions），然后行为会通过commit触发变化（mutations），由变化（mutations）来对仓库中数据的状态（state）进行改变。 或者你可以直接在vue components中通过commit触发变化（mutations），再由变化（mutations）来对仓库中数据的状态（state）进行改变。 不论如何，这是一个单向的工作流程，你不能直接在vue components中修改仓库store中的数据状态（state），因为devtools不会检测这一环节，如果这样做，则会造成数据不可预测的情况发生。 主要组成 以下是整个Vue-X中store的组成部分： state：一个对象，内部可以包含任意类型的数据，是真正存储数据的地方，而对数据的修改只能通过mutations中定义的方法进行 mutations：一个对象，内部能包含一系列的方法，这些方法必须是同步的，它主要的作用在于对state中的数据修改提供接口 actions：一个对象，内部能包含一系列的方法，这些方法可以是同步的或者是异步的，常用于与后端API进行交互，但这些方法不能直接修改state中的数据，必须间接的通过mutations修改state中的数据 getters：一个对象，内部能包含一系列的方法，这些方法必须是同步的，它类似于computed计算属性，当使用getters对象中的方法时不需要加括号即可完成调用 modules：一个对象，主要用于在业务复杂时对数据进行模块化分类 现在我们再来看看下面这张图，你就能完全明白它们的功能了： 基本使用 初始化项目 使用Vite生成项目，跟随指引一步一步的进行初始化： $ npm init @vitejs/app 进入到项目根目录下，安装Vue-X插件，输入以下命令后它将会安装Vue-X 4.x的最新版本： $ npm install vuex@next --save 在src下新建一个store目录，并在其中新建一个index.js文件，该文件将作为Vue-X插件的入口文件存在： $ mkdir ./src/store $ touch ./src/store/index.js 删除.src/components/HelloWorld.vue： $ rm -rf ./src/components/HelloWorld.vue 清空.src/App.vue中的代码，并粘贴下面的代码： hello world 接下来你就可以启动这个Vue项目了，默认项目的端口是3000： $ npm run dev 快速上手 要想使用Vue-X插件，我们就必须在.src/store/index.js文件中对其进行引入： // 1.导入创建仓库的方法 import { createStore } from \"vuex\" // 2.创建仓库并进行配置 const store = createStore({ strict: process.env.NODE_ENV !== \"production\", // 定义数据 state: { counter: 65, }, // 定义多样化展示数据的方法 getters: { char(state) { return String.fromCharCode(state.counter); } }, // 定义修改数据的方法 mutations: { MODIFY(state, playload) { state.counter = playload.number; } }, // 定义请求后端数据的方法 actions: { }, // 对数据进行模块化分类 modules: { } }) // 3.导出仓库 export default store 然后需要到.src/main.js中为当前的Vue应用加载这个插件： import { createApp } from 'vue' import App from './App.vue' import vueX from \"./store/index\" const app = createApp(App); // 加载插件 app.use(vueX); app.mount('#app'); 严格模式 根据第一章中的Vue-X工作流程我们可以得知，state的改变只能通过mutations进行，但是这个条件默认情况下并不是严格限制的，所以我们可以对此开启严格模式进行限制。 注意！因为严格模式在项目上线后会造成性能损失，所以这里采用了一个if条件作为判断，如果是开发模式则开启严格模式、如果是生产模式则关闭严格模式： import { createStore } from \"vuex\" // 开启严格模式 const store = createStore({ strict: process.env.NODE_ENV !== \"production\", state: { ... }, ... }) // 3.导出仓库 export default store 仓库对象 想在组件中使用Vue-X中的数据，我们必须先拿到这个仓库对象。 你可以在组件的模板中直接进行获取： {{ $store }} 要想在组件的脚本中使用这个仓库对象你必须先对其进行导入： import { useStore } from \"vuex\"; 接下来需要进行实例化操作： const store = new useStore(); 而后你就可以使用这个仓库对象了，在仓库对象中的任意数据、方法你都可以拿到。 如，拿到store.state下的counter： // template {{ $store.state.counter }} // script console.log(store.state.counter) state store.state根据图示可以发现，在组件内部它可以直接进行使用，但是当要修改store.state中的数据时必须通过store.mutations中定义的方法进行。 如，我们可以在直接在模板中拿到store.state.counter： {{ $store.state.counter }} 这个时候页面上将显示65，因为在store.state中我们定义的counter为65： state: { counter: 65, }, getters store.getters本质和store.state差不多，store.getters与store.state的关系就如同data与computed的关系，它内部所包含的方法必须是同步的。 我们在组件内部可以直接使用store.getters的方法，但是当要修改store.getters中方法所展示的数据时就必须先通过store.mutations修改store.state中的数据，而一旦store.state中的数据发生变化，那么store.getters中方法所展示的数据会也自动进行更新。 如，我们可以在直接在模板中拿到store.getters.char： {{ $store.state.counter }} -&gt; {{ $store.getters.char }} 这个时候页面上将显示65 -> A，因为store.getters.char方法我们定义的是返回该数字的Unicode字符表现形式： getters: { char(state) { return String.fromCharCode(state.counter); } }, 注意，store.getters中的方法均可定义一个名为state的形参，它指向了当前的store.state。 mutations store.mutations中定义的方法主要是作为修改store.state中所定义的数据而存在的，它内部所包含的方法必须是同步的。 它可以在组件中或者store.actions通过store.commit(type, playload)的方式传递新的数据进入仓库，以便于修改store.state中的数据。 store.commit(type, playload) // type为store.mutations中定义的方法名 // playload可以为store.mutations中定义的方法传递参数，通常情况下它应该是一个对象 如下所示： {{ $store.state.counter }} -&gt; {{ $store.getters.char }} change import { useStore } from \"vuex\"; const store = new useStore(); const generateRandomNumber = () => { const number = Math.floor(Math.random() * (90 - 65 + 1)) + 65; store.commit(\"modify\", { number }); }; 当我们点击按钮后，将触发组件的generateRandomNumber方法，该方法会生成一个65-90之间的随机数，而后会对store进行通知。 当store接到commit()通知后，会在store.mutations中寻找符合type的方法： mutations: { modify(state, playload) { state.counter = playload.number; } }, 注意，store.getters中的方法均可定义一个名为state的形参，它指向了当前的store.state。 而playload形参则接受store.commit()所提交的参数，通常情况下我们希望它传递的是一个对象。 actions store.actions中定义的方法主要是作为获取backend API中的数据而存在的，它内部所包含的方法可以是同步的，也可以是异步的。 它只能在组件中通过store.dispatch(type, playload, ?options)进行调用。 store.dispatch(type, playload, ?option) // type为store.dispatch中定义的方法名 // playload可以为store.dispatch中定义的方法传递参数，通常情况下它应该是一个对象 // options能够为store.dispatch中定义的方法提供一些选项，通常情况下它的使用较少，可以不必关注 注意，store.actions只能获取backend API中的数据，而不能直接修改store.state中定义的数据，我们必须通过store.commit()触发store.mutations下定义的方法，再由它来修改store.state中的数据。 我们用一个最简单的案例来进行说明，下面是一个后端接口，它可以返回一些数据： const Koa = require('koa') const router = require('koa-router')() const koaBody = require(\"koa-body\") const cors = require('@koa/cors') const server = new Koa() server.use(cors()) server.use(router.routes()) server.use(koaBody({ multipart: true })) server.use(async (ctx, next) => { await next(); ctx.response.set(\"Content-Type\", \"application/json\") }) router.post(\"/api/books\", async (ctx, next) => { await next(); const bookList = [ { id: 1, name: \"红楼梦\", price: 199 }, { id: 2, name: \"西游记\", price: 159 }, { id: 3, name: \"三国演义\", price: 149 }, { id: 4, name: \"水浒传\", price: 129 } ] ctx.response.body = JSON.stringify( { code: 200, message: bookList } ) }) server.listen(3001, \"localhost\", 128, () => { console.log(\"server started to http://localhost:3001\"); }) 我们可以在store.actions中定义一个getBooks的方法，它将会对后端/api/books发起请求，然后将bookList通过store.mutations下的addBooks方法添加到store.state中： // 1.导入创建仓库的方法 import { createStore } from \"vuex\" import axios from \"axios\" // 2.创建仓库并进行配置 const store = createStore({ strict: process.env.NODE_ENV !== \"production\", // 定义数据 state: { bookList: [], }, // 定义修改数据的方法 mutations: { addBooks(state, playload) { state.bookList = playload.bookList } }, // 定义请求后端数据的方法 actions: { getBooks(store, playload) { axios({ url: \"/api/books\", baseURL: \"http://localhost:3001\", method: \"POST\", responseType: \"json\" }).then((response) => { if (response.data.code === 200) { const bookList = response.data.message store.commit(\"addBooks\", { bookList }) } }) } }, }) // 3.导出仓库 export default store 在组件中，我们必须使用store.dispatch()方法才能对actions下的方法发起调用。 而对于网络的请求，一般情况下我们会将其放在onCreated()钩子函数（只获取一次的数据）或者onMounted()钩子函数（每次刷新页面都重新获取的数据）中： {{ book.name }} import { useStore } from \"vuex\"; import { onMounted } from \"vue\"; const store = new useStore(); onMounted(() => { store.dispatch(\"getBooks\", {}); }); modules 在之前我们总是将所有的数据存放在一个仓库中，这样管理起来比较杂乱： 其实每个不同类别的数据你都可以将它们做成一个独立的模块，你可以将它理解为一个小仓库，最后再汇总到大仓库中： 示例如下： // 1.导入创建仓库的方法 import { createStore } from \"vuex\" // 2.定义小仓库 const cart = { state: {}, getters: {}, mutations: {}, actions: {}, } // 3.定义大仓库 const store = createStore({ strict: process.env.NODE_ENV !== \"production\", modules: { cart } }) // 4.导出大仓库 export default store 当在使用小仓库下的方法时，你必须加上小仓库的名字： // 获取小仓库中的内容 {{ $store.state.小仓库名字.内容 }} // 调用小仓库的mutations下的方法 store.commit(\"小仓库名字/方法名\", playload) // 调用小仓库的actions下的方法 store.dispatch(\"小仓库名字/方法名\", playload) 实战演示 项目一览 现在我们可以用一个小的demo案例来加深对Vue-X的使用影响。 一个简单的购物车案例，当你在主页中选择商品后，它会将商品添加到购物车中并且计算支付总价。 我们需要2个组件： Index：展示商品信息、勾选商品 Shop：展示购物车信息与购物总价格 以下是项目的成品效果： 后端代码 后端还是采用Node.js + Koa框架进行搭建，一共只有1个API接口，返回一些商品信息： const Koa = require('koa') const router = require('koa-router')() const static = require(\"koa-static\") const path = require('path') const koaBody = require(\"koa-body\") const cors = require('@koa/cors') const server = new Koa() const protocol = \"http\" const hostname = \"localhost\" const port = 3001 const serverAddr = protocol.concat(\":\", \"//\", hostname, \":\", port); server.use(cors()) server.use(router.routes()) server.use(static( path.join(__dirname, \"./static\") )) console.log(path.join(__dirname, \"./static\")); server.use(koaBody({ multipart: true })) server.use(async (ctx, next) => { await next(); ctx.response.set(\"Content-Type\", \"application/json\") }) router.post(\"/api/goods\", async (ctx, next) => { await next(); const goodsList = [ { id: 1, name: \"北京烤鸭\", price: 98, img: serverAddr + \"/1.jpg\" }, { id: 2, name: \"窝窝头\", price: 24, img: serverAddr + \"/2.jpg\" }, { id: 3, name: \"烤山药\", price: 67, img: serverAddr + \"/3.jpg\" }, { id: 4, name: \"小米儿\", price: 18, img: serverAddr + \"/4.jpg\" } ] ctx.response.body = JSON.stringify( { code: 200, message: goodsList } ) }) server.listen(port, hostname, 128, () => { console.log(`server started to ${serverAddr}`); }) 插件代码 对于Vue-X的store目录下的index.js文件，我们可以进行更加详细的拆分。 如将state、getters、mutations、actions、mutations_type以及actions_type还有modules拆分成不同的文件： ./src/store ├── actions.js ├── actions_type.js ├── getters.js ├── index.js ├── modules.js ├── mutations.js ├── mutations_type.js └── state.js 以下各个文件中的代码，首先是./src/store/index.js： import { createStore } from \"vuex\" import state from \"./state\" import getters from \"./getters\" import mutations from \"./mutations\" import actions from \"./actions\" import modules from \"./modules\" export default createStore({ state, getters, mutations, actions, modules }) 下面是./src/store/state.js： export default { // 所有商品信息 /* [ {id : 1, name : \"phone\", price : 98, img : \"http://localhost:30001/x.jpg\"} ] */ goodsList: [], // 当前购物车信息 /* [ {id : 1, name : \"phone\", price : 98, img : \"http://localhost:30001/x.jpg\", number : 1} ] */ shopList: [] } 其次是./src/store/getters.js： export default { // 计算购物车总价 totalPrice(state) { return state.shopList.reduce((pre, goods) => { return pre + goods.price * goods.number }, 0) } } 然后是./src/store/mutations_type.js： export default { // 初始化所有商品数据 loadAllGoods: \"loadAllGoods\", // 向购物车新增一个商品 incrShopList: \"incrShopList\", // 移除购物车中的一个商品 decrShopList: \"decrShopList\", // 修改购物车中的商品数量 changeShopGoodsNumber: \"changeShopGoodsNumber\" } 下面是./src/store/mutations.js： import mutationsType from \"./mutations_type\" export default { // 初始化所有商品数据 [mutationsType.loadAllGoods](state, playload) { state.goodsList = playload.goodsList }, // 先购物车中新增一个商品 [mutationsType.incrShopList](state, playload) { for (const goods of state.shopList) { // 如果存在就数量+1 if (goods.name === playload.goods.name && goods.id === playload.goods.id) { goods.number += 1 return } } // 不存在、直接添加 state.shopList.push(playload.goods) }, // 移除购物车中的一个商品 [mutationsType.decrShopList](state, playload) { state.shopList.splice(playload.goodsIndex, 1) }, // 修改购物车中的商品数量 [mutationsType.changeShopGoodsNumber](state, playload) { // 这里始终是用的加法运算，假如你的购物车中有1个商品，那么 1 + -1 就等于 1 - 1 state.shopList[playload.goodsIndex].number += playload.number } } 以及./src/store/actions_type.js： export default { // 请求所有商品 getAllGoods: \"getAllGoods\" } 还有./src/store/actions.js： import actionsType from \"./actions_type\" import mutationsType from \"./mutations_type\" import axios from \"axios\" export default { // 发送请求，并且将请求后的商品信息添加至 [actionsType.getAllGoods](store, playload) { axios({ baseURL: \"http://localhost:3001\", url: \"api/goods\", method: \"POST\", responseType: \"json\" }).then((response) => { if (response.data.code === 200) { const goodsList = response.data.message; store.commit(mutationsType.loadAllGoods, { goodsList }) } }) } } 最后是modules.js： export default { } 组件代码 定义好Index.vue以及Shop.vue，并在App.vue中进行引入。 下面是./src/App.vue的代码： import Index from \"./components/Index.vue\"; import Shop from \"./components/Shop.vue\"; * { margin: 0; padding: 0; box-sizing: border-box; list-style: none; } #app-tpl { display: flex; flex-flow: column nowrap; padding: 2rem; } Index.vue的代码： {{ goods.name }} ￥{{ goods.price }} import { onMounted } from \"vue\"; import { useStore } from \"vuex\"; import actionsType from \"../store/actions_type\"; import mutationsType from \"../store/mutations_type\"; const store = new useStore(); onMounted(() => { store.dispatch(actionsType.getAllGoods, {}); }); const addShopGoods = (goods, event) => { store.commit(mutationsType.incrShopList, { goods: { ...goods, number: 1 } }); }; #index-tpl { width: 100vw; height: 50vh; display: flex; justify-content: center; align-items: center; } #index-tpl ul { display: flex; justify-content: center; align-items: center; } #index-tpl ul li { display: flex; flex-flow: column nowrap; justify-content: space-between; align-items: center; border: 1px solid #ddd; } #index-tpl ul li .goods_name, #index-tpl ul li .goods_price { background-color: red; width: 100%; text-align: center; color: #fff; font-size: 1.2rem; } #index-tpl ul li .goods_img:hover { cursor: pointer; } 还有Shop的代码： 名称 价格 数量 {{ goods.name }} ￥{{ goods.price * goods.number }} + {{ goods.number }} - 总结 : ￥{{ $store.getters.totalPrice }} import { useStore } from \"vuex\"; import mutationsType from \"../store/mutations_type\"; const store = useStore(); const addGoodsNumber = (goodsIndex, event) => { const number = +1; store.commit(mutationsType.changeShopGoodsNumber, { goodsIndex, number }); }; const subGoodsNumer = (goodsIndex, event) => { const number = -1; // 如果商品购物车中已添加的数量大于1，就不用移除该商品 if (store.state.shopList[goodsIndex].number > 1) { store.commit(mutationsType.changeShopGoodsNumber, { goodsIndex, number }); } // 否则就需要将该商品移除至购物车 else { store.commit(mutationsType.decrShopList, { goodsIndex }); } }; #shop-tpl { width: 100vw; height: 50vh; display: flex; justify-content: center; align-items: flex-start; } #shop-tpl table { border-collapse: collapse; width: 880px; } #shop-tpl table tr td, #shop-tpl table tr th { border: 1px solid #aaa; text-align: center; padding: 0.2rem; } #shop-tpl table thead tr { background: #dddd; } #shop-tpl table tbody tr td:last-of-type span { margin: 0 0.5rem; } #shop-tpl table tbody tr td:last-of-type button { width: 2rem; } #shop-tpl table tr:nth-child(even) { background: #dddd; } 版本区别 创建仓库 在Vue-X4.0之前，创建仓库并不是通过下面的方式创建： import { createStore } from \"vuex\" 而是通过VueX.store()进行创建： import Vue from 'vue' import Vuex from 'vuex' Vue.use(Vuex) const store = new Vuex.Store({ state: { count: 0 }, mutations: { increment (state) { state.count++ } } }) 获取仓库 在Options API中，如果想要在中获取store仓库对象，则需要使用this进行调用： this.$store.state.data; this.$store.commit('mutationsType', playload); this.$store.dispatch('actionsType', playload); Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:48 "},"前端专栏/Vue3/axios.html":{"url":"前端专栏/Vue3/axios.html","title":"axios","keywords":"","body":"axios 基本介绍 axios是一个基于Promise的网络请求库，它可以在Node.js与浏览器中运行。 在Node.js中运行axios，它将依赖于http库。 在浏览器中运行axios，它将依赖于XMLHttpResponse。 axios可以说是目前应用最广泛的一款网络请求库，它所提供的接口非常简洁易懂，其名称来源于ax（ajax）io（io）s（system）。 相较于jQuery.ajax()，它更加的智能，比如在上传JSON数据、或者上传文件时你甚至可以直接忽略contentType的设置而直接上传数据。 安装方式 在工程化项目中，推荐使用npm或者yarn进行安装： $ npm install axios $ yarn add axios 在非工程化项目中，你可以使用Boot CDN进行引入： 后端代码 为了方便后续前后端交互的代码测试，我们后端采用Node.js+Koa框架来完成。 IP：localhost PORT：3001 代码如下： const path = require('path'); const fs = require('fs'); // npm install koa --save const Koa = require('koa'); // npm install koa-router --save ： 用于为Koa框架添加路由功能 const router = require('koa-router')(); // npm install koa-body --save : 用于获取POST请求体参数，以及获取文件对象 const koaBody = require('koa-body'); // npm install @koa/cors --save : 用于解决前后端跨域问题 const cors = require('@koa/cors'); const server = new Koa(); server.use(cors()); server.use(koaBody( { // 是否支持 multipart-formdata 的表单 multipart: true, formidable: { // 上传的目录 uploadDir: path.join(__dirname, 'upload'), // 保持文件的后缀 keepExtensions: true, // 最大支持上传8M的文件 maxFieldsSize: 8 * 1024 * 1024, // 文件上传前的设置 onFileBegin: (name, file) => { const filePath = path.join(__dirname, \"upload\"); // 检查是否有upload目录 if (!fs.existsSync(filePath)) { fs.mkdirSync(filePath); console.log(\"mkdir success!\"); } } } } )) server.use(async (ctx, next) => { await next(); ctx.response.set(\"Content-Type\", \"application/json\"); ctx.response.statusCode = 200; }) router.get('/get', async (ctx, next) => { await next(); ctx.response.body = JSON.stringify(ctx.request.query); }); router.post('/post', async (ctx, next) => { await next(); ctx.response.body = JSON.stringify(ctx.request.body); }); router.post(\"/upload\", async (ctx, next) => { await next(); const file = ctx.request.files[\"img\"]; ctx.response.body = JSON.stringify(file); }) server.use(router.routes()); server.listen(3001, \"localhost\"); console.log('server started at http://localhost:3001'); 快速上手 全局配置 在axios中可以配置一些全局设置，如baseUrl或者timeout，如下所示： baseUrl：默认的request host，如当前缀设置为“http://localhost:3001”后，当你发送网络请求时它会自动添加上该前缀 timeout：请求超时时间，默认为0，即永不超时 示例如下，对于这些全局配置我们可以直接书写在一个配置文件当中： import axios from \"axios\"; axios.defaults.baseURL = \"http://localhost:3001\"; axios.defaults.timeout = 2000; GET 以下是发送GET请求的案例，若想携带参数你必须带上params： get import axios from \"axios\"; axios.defaults.baseURL = \"http://localhost:3001\"; axios.defaults.timeout = 2000; const callbackfn = (event) => { axios({ method: \"GET\", url: \"/get\", headers: {}, params: { getParams1: \"v1\", getParams2: \"v2\" }, responseType: \"json\", }) .then((response) => { console.log(response.data); }) .catch((error) => { throw error; }); }; * { margin: 9; padding: 9; } #app { height: 100vh; width: 100vw; display: flex; justify-content: center; align-items: center; } POST 以下是发送POST请求的案例，若想携带参数你必须带上data： post import axios from \"axios\"; axios.defaults.baseURL = \"http://localhost:3001\"; axios.defaults.timeout = 2000; const callbackfn = (event) => { axios({ method: \"POST\", url: \"/post\", headers: {}, data: { postParams1: \"v1\", postParams2: \"v2\" }, responseType: \"json\", }) .then((response) => { console.log(response.data); }) .catch((error) => { throw error; }); }; * { margin: 9; padding: 9; } #app { height: 100vh; width: 100vw; display: flex; justify-content: center; align-items: center; } 上传文件 上传文件必须是POST请求，我们可以利用formData对象来进行上传，如下所示： import axios from \"axios\"; axios.defaults.baseURL = \"http://localhost:3001\"; axios.defaults.timeout = 2000; const callbackfn = (event) => { // 1.封装formData const fd = new FormData(); const file = event.target.files[0]; fd.append(\"img\", file); // 2.发送请求 axios({ method: \"POST\", url: \"/upload\", headers: {}, data: fd, responseType: \"json\", }) .then((response) => { console.log(response.data); }) .catch((error) => { throw error; }); }; * { margin: 9; padding: 9; } #app { height: 100vh; width: 100vw; display: flex; justify-content: center; align-items: center; } 并发请求 如果想一次性发送多个请求，则可以使用all()方法，all()方法应当传入一个Array，并且这个Array中可以包含任意个axios请求，当： all import axios from \"axios\"; axios.defaults.baseURL = \"http://localhost:3001\"; axios.defaults.timeout = 2000; const callbackfn = (event) => { axios .all([ axios({method: \"GET\",url: \"/get\",params: { getParams1: \"v1\", getParams2: \"v2\" }}), axios({method: \"POST\",url: \"/post\", data: { postParams1: \"v1\", postParams2: \"v2\" }}), ]) .then((responseArray) => { responseArray.forEach((response) => { console.log(response.status); console.log(response.data); }); }) .catch((error) => { throw error; }); }; * { margin: 9; padding: 9; } #app { height: 100vh; width: 100vw; display: flex; justify-content: center; align-items: center; } 请求响应 请求配置 以下是请求相关的config，摘自axios官网： { // `url` 是用于请求的服务器 URL url: '/user', // `method` 是创建请求时使用的方法 method: 'get', // 默认值 // `baseURL` 将自动加在 `url` 前面，除非 `url` 是一个绝对 URL。 // 它可以通过设置一个 `baseURL` 便于为 axios 实例的方法传递相对 URL baseURL: 'https://some-domain.com/api/', // `transformRequest` 允许在向服务器发送前，修改请求数据 // 它只能用与 'PUT', 'POST' 和 'PATCH' 这几个请求方法 // 数组中最后一个函数必须返回一个字符串， 一个Buffer实例，ArrayBuffer，FormData，或 Stream // 你可以修改请求头。 transformRequest: [function (data, headers) { // 对发送的 data 进行任意转换处理 return data; }], // `transformResponse` 在传递给 then/catch 前，允许修改响应数据 transformResponse: [function (data) { // 对接收的 data 进行任意转换处理 return data; }], // 自定义请求头 headers: {'X-Requested-With': 'XMLHttpRequest'}, // `params` 是与请求一起发送的 URL 参数 // 必须是一个简单对象或 URLSearchParams 对象 params: { ID: 12345 }, // `paramsSerializer`是可选方法，主要用于序列化`params` // (e.g. https://www.npmjs.com/package/qs, http://api.jquery.com/jquery.param/) paramsSerializer: function (params) { return Qs.stringify(params, {arrayFormat: 'brackets'}) }, // `data` 是作为请求体被发送的数据 // 仅适用 'PUT', 'POST', 'DELETE 和 'PATCH' 请求方法 // 在没有设置 `transformRequest` 时，则必须是以下类型之一: // - string, plain object, ArrayBuffer, ArrayBufferView, URLSearchParams // - 浏览器专属: FormData, File, Blob // - Node 专属: Stream, Buffer data: { firstName: 'Fred' }, // 发送请求体数据的可选语法 // 请求方式 post // 只有 value 会被发送，key 则不会 data: 'Country=Brasil&City=Belo Horizonte', // `timeout` 指定请求超时的毫秒数。 // 如果请求时间超过 `timeout` 的值，则请求会被中断 timeout: 1000, // 默认值是 `0` (永不超时) // `withCredentials` 表示跨域请求时是否需要使用凭证 withCredentials: false, // default // `adapter` 允许自定义处理请求，这使测试更加容易。 // 返回一个 promise 并提供一个有效的响应 （参见 lib/adapters/README.md）。 adapter: function (config) { /* ... */ }, // `auth` HTTP Basic Auth auth: { username: 'janedoe', password: 's00pers3cret' }, // `responseType` 表示浏览器将要响应的数据类型 // 选项包括: 'arraybuffer', 'document', 'json', 'text', 'stream' // 浏览器专属：'blob' responseType: 'json', // 默认值 // `responseEncoding` 表示用于解码响应的编码 (Node.js 专属) // 注意：忽略 `responseType` 的值为 'stream'，或者是客户端请求 // Note: Ignored for `responseType` of 'stream' or client-side requests responseEncoding: 'utf8', // 默认值 // `xsrfCookieName` 是 xsrf token 的值，被用作 cookie 的名称 xsrfCookieName: 'XSRF-TOKEN', // 默认值 // `xsrfHeaderName` 是带有 xsrf token 值的http 请求头名称 xsrfHeaderName: 'X-XSRF-TOKEN', // 默认值 // `onUploadProgress` 允许为上传处理进度事件 // 浏览器专属 onUploadProgress: function (progressEvent) { // 处理原生进度事件 }, // `onDownloadProgress` 允许为下载处理进度事件 // 浏览器专属 onDownloadProgress: function (progressEvent) { // 处理原生进度事件 }, // `maxContentLength` 定义了node.js中允许的HTTP响应内容的最大字节数 maxContentLength: 2000, // `maxBodyLength`（仅Node）定义允许的http请求内容的最大字节数 maxBodyLength: 2000, // `validateStatus` 定义了对于给定的 HTTP状态码是 resolve 还是 reject promise。 // 如果 `validateStatus` 返回 `true` (或者设置为 `null` 或 `undefined`)， // 则promise 将会 resolved，否则是 rejected。 validateStatus: function (status) { return status >= 200 && status 响应结构 以下是响应对象response对象的相关结构，摘自axios官网： { // `data` 由服务器提供的响应 data: {}, // `status` 来自服务器响应的 HTTP 状态码 status: 200, // `statusText` 来自服务器响应的 HTTP 状态信息 statusText: 'OK', // `headers` 是服务器响应头 // 所有的 header 名称都是小写，而且可以使用方括号语法访问 // 例如: `response.headers['content-type']` headers: {}, // `config` 是 `axios` 请求的配置信息 config: {}, // `request` 是生成此响应的请求 // 在node.js中它是最后一个ClientRequest实例 (in redirects)， // 在浏览器中则是 XMLHttpRequest 实例 request: {} } 拦截器 axios中可添加请求或者响应拦截器来对请求或者响应做2次处理： // 添加请求拦截器 axios.interceptors.request.use(function (config) { // 在发送请求之前做些什么 return config; }, function (error) { // 对请求错误做些什么 return Promise.reject(error); }); // 添加响应拦截器 axios.interceptors.response.use(function (response) { // 2xx 范围内的状态码都会触发该函数。 // 对响应数据做点什么 return response; }, function (error) { // 超出 2xx 范围的状态码都会触发该函数。 // 对响应错误做点什么 return Promise.reject(error); }); Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:48 "},"前端专栏/Vue3/其他资源.html":{"url":"前端专栏/Vue3/其他资源.html","title":"其他资源","keywords":"","body":"typescript 如果想让你的Vue项目支持TypeScript，你可以在vite新建项目时选择ts： $ npm init @vitejs/app demo-project @vitejs/create-app is deprecated, use npm init vite instead ? Select a framework: › - Use arrow-keys. Return to submit. ❯ vanilla ? Select a framework: › - Use arrow-keys. Return to submit. vanilla ✔ Select a framework: › vue ✔ Select a variant: › vue-ts ts.config.js有一些配置需要我们手动的进行更改，下面是我常用的配置项： { \"compilerOptions\": { \"target\": \"esnext\", \"useDefineForClassFields\": true, \"module\": \"esnext\", \"moduleResolution\": \"node\", \"strict\": true, \"jsx\": \"preserve\", \"sourceMap\": true, \"resolveJsonModule\": true, \"esModuleInterop\": true, \"lib\": [\"esnext\", \"dom\"], \"alwaysStrict\": true, // 启用JavaScript的严格模式 \"noFallthroughCasesInSwitch\": true, // 检测switch语句块是否正确的使用了break \"noImplicitReturns\": true, // 检测函数是否具有隐式的返回值 \"noUnusedLocals\": false, // 检测是否具有未使用的局部变量 \"noUnusedParameters\": false, // 检测是否具有未使用的函数参数 \"allowUnreachableCode\": true, // 检测是否具有永远不会运行的代码 }, \"include\": [\"src/**/*.ts\", \"src/**/*.d.ts\", \"src/**/*.tsx\", \"src/**/*.vue\"] } 在编辑组件的代码时，添加上lang=”ts”属性即可： + {{ counter }} - import { ref, Ref } from \"vue\" let counter: Ref = ref(0); type callbackfn = (event: Event | undefined) => void const add: callbackfn = (e: Event | undefined): void => { counter.value++ } const sub: callbackfn = (e: Event | undefined): void => { counter.value-- } less 如果想让你的Vue项目支持Less，你可以在上添加属性less。 然后安装less即可： $ npm install less --save 其他的诸如scss同理，这里不再演示。 element-ui element-ui是Vue中最受欢迎的UI库，使用它能够更方便的让我们搭建出炫酷的内容。 element-ui的官方文档非常齐全，你可以进行参阅。 注意element-ui的文档有2个版本，分别针对Vue2和Vue3： Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:48 "},"前端专栏/Vue3/一个案例.html":{"url":"前端专栏/Vue3/一个案例.html","title":"一个案例","keywords":"","body":"准备工作 ts项目准备 我们准备用Vue3+TypeScript+less+element-ui构建一个非常简单的网站首页。 首先全局安装最新版的Vue-cli： $ npm install -g @vue/cli 再进行项目初始化，语言选择TypeScript： $ npm init @vitejs/app 我们现在可以进入这个目录中了： $ cd ./ $ npm install 编辑ts.config.js，在compilerOptions中新增以下配置项： \"compilerOptions\": { \"alwaysStrict\": true, // 启用JavaScript的严格模式 \"noFallthroughCasesInSwitch\": true, // 检测switch语句块是否正确的使用了break \"noImplicitReturns\": true, // 检测函数是否具有隐式的返回值 \"noUnusedLocals\": false, // 检测是否具有未使用的局部变量 \"noUnusedParameters\": false, // 检测是否具有未使用的函数参数 \"allowUnreachableCode\": true, // 检测是否具有永远不会运行的代码 } 在package.json中新增项目的browserslist： \"browserslist\": { \"development\": [ \"last 1 chrome version\", \"last 1 firefox version\", \"last 1 safari version\" ], \"production\": [ \">0.2%\", \"not dead\", \"not op_mini all\" ] } 在package.json中设置npm脚本： \"scripts\": { \"dev\": \"vite --mode development\", \"build:beta\": \"vite build --mode beta\", \"build:production\": \"vite build --mode production\", \"serve\": \"vite preview\" }, 添加less依赖 下载less即可： $ npm install less --save 安装vue-router 安装vue-router插件： $ npm install vue-router@4 --save 在src下新建一个router目录，并在其中新建一个index.ts文件，该文件将作为Vue-Router插件的入口文件存在： $ mkdir ./src/router $ touch ./src/router/index.ts 在./src/router/index.ts文件中添加以下代码： import { createWebHashHistory, createWebHistory, createRouter, } from \"vue-router\"; const routes: any[] = []; const router = createRouter({ routes, history: createWebHashHistory(), }); export default router; 在.src/main.ts中导入并加载该插件： import { createApp } from \"vue\"; import App from \"./App.vue\"; import router from \"./router/index\"; const app = createApp(App); app.use(router); app.mount(\"#app\"); 安装vue-x 安装vue-x插件： $ npm install vuex@next --save 创建store目录以及index.ts、state.ts、getters.ts、mutations.ts、mutations_type.ts、actions.ts、actions_type.ts、modules.ts。 $ mkdir ./src/store $ touch ./src/store/{index.ts,state.ts,getters.ts,mutations.ts,mutations_type.ts,actions.ts,actions_type.ts,modules.ts} ./src/store/Index.ts代码如下： import { createStore } from \"vuex\"; import state from \"./state\"; import getters from \"./getters\"; import mutations from \"./mutations\"; import actions from \"./actions\"; import modules from \"./modules\"; export default createStore({ state, getters, mutations, actions, modules, }); 此路径下其他的所有文件代码如下： export default {}; 在.src/main.ts中导入并加载该插件： import { createApp } from \"vue\"; import App from \"./App.vue\"; import router from \"./router/index\"; import store from \"./store/index\"; const app = createApp(App); app.use(router); app.use(store); app.mount(\"#app\"); 安装axios 使用npm安装axios： $ npm install axios --save 在.src目录下新建axios目录，并且新增index.ts文件： $ mkdir ./src/axios $ touch ./src/axios/index.ts ./src/axios/index.ts代码如下： import axios from \"axios\"; const baseURL: string = \"http://localhost:3001\"; const responseType: string = \"JSON\"; const timeout: number = 2000; axios.defaults = Object.assign(axios.defaults, { baseURL, responseType, timeout, }); 安装element-ui 下载element-ui-plus： $ npm install element-plus --save 在./src/main.ts中导入element-ui： import { createApp } from \"vue\"; import App from \"./App.vue\"; import router from \"./router/index\"; import store from \"./store/index\"; // 插件本身 import ElementPlus from \"element-plus\"; // 基础样式 import \"element-plus/dist/index.css\"; const app = createApp(App); app.use(router); app.use(store); app.use(ElementPlus); app.mount(\"#app\"); css-reset 在./src/assets中新建一个style目录和css-reset.css文件： $ mkdir ./src/assets/style $ touch ./src/assets/style/css-reset.css 粘贴进以下代码： /* http://meyerweb.com/eric/tools/css/reset/ v2.0 | 20110126 License: none (public domain) */ html, body, div, span, applet, object, iframe, h1, h2, h3, h4, h5, h6, p, blockquote, pre, a, abbr, acronym, address, big, cite, code, del, dfn, em, img, ins, kbd, q, s, samp, small, strike, strong, sub, sup, tt, var, b, u, i, center, dl, dt, dd, ol, ul, li, fieldset, form, label, legend, table, caption, tbody, tfoot, thead, tr, th, td, article, aside, canvas, details, embed, figure, figcaption, footer, header, hgroup, menu, nav, output, ruby, section, summary, time, mark, audio, video { margin: 0; padding: 0; border: 0; font-size: 100%; font: inherit; vertical-align: baseline; } /* HTML5 display-role reset for older browsers */ article, aside, details, figcaption, figure, footer, header, hgroup, menu, nav, section { display: block; } body { line-height: 1; } ol, ul { list-style: none; } blockquote, q { quotes: none; } blockquote:before, blockquote:after, q:before, q:after { content: ''; content: none; } table { border-collapse: collapse; border-spacing: 0; } 在./src/main.ts中进行引入： import \"./assets/style/css-reset.css\"; 项目清理 删除./src/components/HelloWorld组件、删除./src/assets/logo.png图片： $ mv ./src/components/HelloWorld.vue /tmp $ mv ./src/assets/logo.png /tmp 删除./src/App.vue中所有代码，并且填入以下内容： hello world 输入命令，npm run dev，查看项目启动是否正常。 代码书写 组件创建 首先我们的思路是做一个上下分栏的结构，其中Header部分是固定不变的，而Main部分会随着用户的点击根据Vue-Router的路由系统进行跳转。 一共需要5个组件： Index.vue：主页 Other.vue：其它页，其实这里已经不重要了，你可以有任意个其它页组件 LoginRegister.vue：登录和注册组件，它内部会嵌套登录和注册组件 Login.vue：登录组件 Register.vue：注册组件 以下是成品展示： 路由系统 路由系统的代码非常简单，只有主页和其他页的跳转： import { createWebHashHistory, createWebHistory, createRouter, } from \"vue-router\"; import Index from \"../components/Index.vue\"; import Other from \"../components/Other.vue\"; const routes: any[] = [ { path: \"/\", redirect: { name: \"index\" } }, { path: \"/index\", name: \"index\", alias: [\"/index.html\"], meta: { title: \"主页\" }, component: Index, }, { path: \"/other\", name: \"other\", alias: [\"/other.html\"], meta: { title: \"其他页\" }, component: Other, }, ]; const router = createRouter({ routes, history: createWebHashHistory(), }); router.afterEach((to, from) => { let title: any = to.meta.title; document.title = title; }); export default router; App.vue App.vue中主要就是做整体布局，包括和的放置，以及模态框的显示隐藏： 主页 登录 | 注册 import LoginRegister from \"./components/LoginRegister.vue\"; import { ref, Ref } from \"vue\"; export default { setup() { const dialogVisible: Ref = ref(false); return { dialogVisible, }; }, components: { LoginRegister, }, }; :root { font-family: \"Helvetica Neue\", Helvetica, \"PingFang SC\", \"Hiragino Sans GB\", \"Microsoft YaHei\", \"微软雅黑\", Arial, sans-serif; color: #303133; a { color: #303133; text-decoration: none; } } #app-tpl { #global-header { background: #aaa; color: #fff; box-shadow: 0 2px 4px rgba(0, 0, 0, 0.12), 0 0 6px rgba(0, 0, 0, 0.04); .el-row { height: 100%; .el-col:last-of-type { text-align: right; cursor: pointer; span:hover { color: #606266; } } } a { color: #fff; } } } Index.vue Index.vue中主要就是轮播图与吐司信息框的弹出，注意这里的轮播图资源理应是由后端进行返回的： 去其他页看看 import { ElMessage } from \"element-plus\"; import { useRouter } from \"vue-router\"; export default { setup() { const router = useRouter(); const callbackfn = (event: Event) => { ElMessage({ message: \"别点了，跳转不了\", type: \"warning\", }); }; const jump = (event: Event) => { router.push({ name: \"other\" }); }; return { callbackfn, jump, }; }, }; img { height: 400px; } .el-col { margin-bottom: 5rem; } Other.vue Other.vue是用作其他页显示的，这里只是一个模板： 其他页面 LoginRegister.vue LoginRegister.vue中主要是Login组件和Register组件的动态切换： 登录 注册 import { ref, Ref } from \"vue\"; import Login from \"./Login.vue\"; import Register from \"./Register.vue\"; export default { setup() { const component: Ref = ref(\"Login\"); return { component, }; }, components: { Login, Register, }, }; #login-reg-tpl { .el-row:first-of-type { margin-bottom: 1rem; } } Login.vue Login组件中包含了element-ui的表单和验证： 登录 import { reactive, ref } from \"vue\"; export default { setup() { // form表单验证字段 const ruleForm = reactive({ username: null, password: null, }); // form表单验证规则 const rules = reactive({ username: [ { required: true, message: \"必须填入用户名\", }, { min: 3, max: 8, message: \"格式错误，用户名必须大于3且小于8个字符\", }, ], password: [ { required: true, message: \"必须填入密码\" }, { min: 6, max: 16, message: \"格式错误，密码必须大于6且小于16个字符\" }, ], }); // 待验证的form表单 const from = ref(null); const submitForm = (event: Event) => { const cpn: any = from.value; if (cpn !== null) { cpn.validate((valid: boolean): boolean => { // 验证通过 if (valid) { console.log(\"success\"); return true; } // 验证失败 else { console.log(\"fail\"); return false; } }); } }; return { ruleForm, rules, submitForm, from, }; }, }; Register.vue Register组件中包含了element-ui的表单和自定义验证： {{ sendBtnValue }} 注册 import { ref, reactive } from \"vue\"; export default { setup() { let phoneCheckStatus = ref(false); let sendBtnValue = ref(\"发送验证码\"); let tag = 0; let waitSecond = 60; // form表单验证字段 const ruleForm = reactive({ phone: null, code: null, }); // 自定义验证规则 const checkPhoneIsNumber = ( rule: { [attr: string]: any }, value: string, callback: Function ) => { if (!Number.isInteger(Number(value))) { callback(new Error(rule.message)); } else { phoneCheckStatus.value = true; callback(); } }; // form表单验证规则 const rules = reactive({ phone: [ { required: true, message: \"必须填入手机号\" }, { len: 11, message: \"格式错误，手机号必须保证11位\" }, { validator: checkPhoneIsNumber, message: \"手机号必须是纯数字\" }, ], code: [ { required: true, message: \"必须填入验证码\" }, { len: 4, message: \"格式错误，验证码必须保证4位\" }, ], }); // 待验证的form表单 const from = ref(null); const submitForm = (event: Event) => { const cpn: any = from.value; if (cpn !== null) { cpn.validate((valid: boolean): boolean => { // 验证通过 if (valid) { console.log(\"success\"); return true; } // 验证失败 else { console.log(\"fail\"); return false; } }); } }; const sendVerifycode = (event: Event) => { if (tag) { return; } tag = setInterval(() => { if (waitSecond > 1) { waitSecond--; sendBtnValue.value = `请等待${waitSecond}秒`; } else { sendBtnValue.value = \"发送验证码\"; waitSecond = 60; clearTimeout(tag); tag = 0; } }, 1000); sendBtnValue.value = `请等待${waitSecond}秒`; }; return { from, ruleForm, rules, submitForm, sendBtnValue, sendVerifycode, phoneCheckStatus, }; }, }; Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:48 "},"前端专栏/Webpack5/summary.html":{"url":"前端专栏/Webpack5/summary.html","title":"Webpack5","keywords":"","body":" 基础介绍 常用配置 devServer 优化配置 配置整理 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:48 "},"前端专栏/Webpack5/基础介绍.html":{"url":"前端专栏/Webpack5/基础介绍.html","title":"基础介绍","keywords":"","body":"基本介绍 webpack是前端目前最热门的打包方式，它将所有资源文件当做模块进行处理，并且根据模块的依赖关系进行静态分析和打包处理以便生成对应的静态资源文件，减少页面请求次数。 为什么要使用webpack？可以从以下几点看出它的优势： 模块化：前端拥有各种各样的模块化规则，如ES Module、CommonJs、AMD，如果要将不同的模块化规则所书写的JavaScript文件整合到一起，无疑是一项繁琐的工作，webpack可以自动对其进行转换 预处理：less、scss等这些css预处理文件是不被浏览器所识别的，通过webpack打包过后，可以自动的将其转换为css文件以供浏览器使用，极大提升了开发效率 兼容性：不同的浏览器之间存在兼容性问题，通过webpack可以让你的ES6代码在较低版本的浏览器中进行运行 webpack实际上就是一个模块打包机，它所做的事情无外乎是分析项目、找到浏览器不能运行的扩展语言，将其进行打包和处理并生成新的浏览器能识别的文件。 webpack能做的事情非常多，并且学习难度不大，是非常值得学习的一门技术，本系列基于webpack5来进行探究。 相关概念 配置文件 webpack需要有一个配置文件，用来指定如何对项目进行打包。 例如，当打包时遇到非js、json等模块文件的导入时该怎么做？从哪个文件开始进行打包？打包后的文件放在哪个地方？等等。 它常位于项目根目录下，名为webpack.config.js。 以下是最基本的格式： const { resolve } = require('path'); // node.js模块，用于路径拼接 module.exports = { mode: \"打包模式\", entry: \"入口文件\", output: {}, // 输出设置 module: {}, // 碰见非模块资源该怎么做 plugins: [], // webpack插件相关 } 关于内部的使用，在接下来会进行详细介绍。 entry 在使用webpack对项目进行打包时，我们需要为项目指定一个入口文件（js脚本），webpack会从该入口文件开始寻找当前项目中所有的依赖文件，从而生成一个依赖图。 当遇到非JavaScript模块资源时，webpack会根据用户配置的loader将该资源转变为JavaScript可识别的模块，最终所有的依赖文件都将会被打包处理成bundels文件。 这意味着我们可以在JavaScript代码里导入任意的资源文件，只要有对应的loader将其与JavaScript进行转换即可： import \"./static/css/demo.less\" import \"./static/js/demo.js\" import \"./static/imgs/demo.png\" 常用属性 在webpack.config.js中配置entry属性的值时，可有3种定义方式。 1）值是string，只有一个入口文件，适用于单页面应用，只输出一个chunk（默认为main.js）： const { resolve } = require('path'); module.exports = { mode: \"development\", entry: \"./src/entry.js\", output: { filename: \"main.js\", path: resolve(__dirname, \"dist\") } } 2）值是array，可以有多个入口文件，适用于单页面应用，只输出一个chunk（默认为main.js），它表示的含义是数组最后一个文件是资源的入口文件，数组其余文件会预先构建到入口文件中： const { resolve } = require('path'); module.exports = { mode: \"development\", entry: [\"./src/login.js\", \"./src/index.js\", \"./src/entry.js\"], output: { filename: \"main.js\", path: resolve(__dirname, \"dist\") } } # 上面的代码等同于直接在entry.js中导入login.js和index.js，一般情况下用的很少： import \"./login.js\" import \"./index.js\" 3）值是object，可以有多个入口文件，适用于多页面应用，会输出多个chunk，chunk的名字为对象中key，注意，由于它会输出多个chunk，所以chunk的名字必须要自己定义为不一样的： const { resolve } = require('path'); module.exports = { mode: \"development\", entry: { pageOne: './src/app01/entry.js', pageTwo: './src/app02/entry.js', pageThree: './src/app03/entry.js', }, output: { filename: \"[name].js\", path: resolve(__dirname, \"dist\") } } 目录一览： . ├── dist │ ├── pageOne.js │ ├── pageThree.js │ └── pageTwo.js ├── src │ ├── app01 │ │ └── entry.js │ ├── app02 │ │ └── entry.js │ └── app03 │ └── entry.js └── webpack.config.js output output是出口的意思，用于指定webpack在哪里输出以及如何命名这些被打包后的bundels文件。 它的默认值为./dist，当然你也可对其进行配置。 常用配置 以下是output在webpack.config.js中常见的配置项。 const { resolve } = require('path'); module.exports = { ... output: { filename: \"[name].js\", // 输出后的文件名称 path: resolve(__dirname, \"dist\"), // 输出到那个目录下 publicPath: \"/\", // 输出后的http或者file协议访问路径，不建议设置 } } 注意，可使用的[]如下所示： [name] 源文件名 [hash] 根据源文件内容生成的hash值 [contentHash] 同上 [hash:] 只取多少位的hash [path] 源文件路径 [ext] 源文件扩展名 loader loader的主要功能是让webpack如何去处理那些非JavaScript文件（webpack自身只理解JavaScript）。 loader可以将所有类型的文件转换为webpack能够处理的有效模块，然后你就可以利用webpack的打包能力，对它们进行处理。 本质上，webpack loader将所有类型的文件，转换为应用程序的依赖图（和最终的bundle）可以直接引用的模块。 注意，由于有loader的存在，故我们能够在代码中import导入任何类型的模块（例如 .css 文件）。 这是webpack特有的功能，其他打包程序或任务执行器的可能并不支持。我们认为这种语言扩展是有很必要的，因为这可以使开发人员创建出更准确的依赖关系图。 注意，loader一般都是第三方的，所以我们需要对其进行npm安装，并且将其安装在生产环境下。 遍历规则 loader在webpack.config.js中配置还是有一些注意事项的。 首先它们必须全部定义在module中，然后用rules与test来匹配资源文件，最后添加loader来处理这些资源文件。 如下所示，我们针对不同的资源文件给出了不同的loader处理方案： const { resolve } = require('path'); module.exports = { ... module: { // rules：指定所有可能会被应用的loader rules: [ // test：识别出哪些文件会被转换 // use：将使用那些loader对该文件做转换 { test: /\\.js$/, use: [\"babel-loader\"] }, { test: /\\.css$/, use: [\"style-loader\", \"css-loader\"] }, { test: /\\.html$/, use: [\"html-loader\"] } ] } } 默认情况下，它会不断的去遍历整个rules列表，来处理资源文件，整个流程相当于如下语句，即整个rules列表中的loader都会被匹配一次： for (let rule of rules) { if (fileName.match(rule.test)) { // 调用loader处理资源文件 rule.use?.map(loader => { loader(fileName) }) || rule.loader(filename); } } 我们可以在rules中添加一个具有oneOf属性的对象，这样它在遍历时当一个loader生效后其他的loader将不再进行遍历，类似于else if语句： const { resolve } = require('path'); module.exports = { ... module: { rules: [ { oneOf: [ // 只匹配一个，匹配完成后立刻跳出 { test: /\\.js$/, use: [\"babel-loader\"] }, { test: /\\.css$/, use: [\"style-loader\", \"css-loader\"] }, { test: /\\.html$/, use: [\"html-loader\"] } ] } ] } } 若你想让一个文件被多个loader进行处理，可以使用如下的配置： const { resolve } = require('path'); let fileName = \"demo.css\" for (let rule of rules) { if (fileName.match(rule.test)) { // 调用loader处理资源文件 rule.use?.map(loader => { loader(fileName) }) || rule.loader(filename); } } module.exports = { ... module: { rules: [ // js文件会先执行这个loader { test: /\\.js$/, use: [\"xxx-loader\"], enforce: \"pre\", }, { oneOf: [ // 然后再执行这个loader { test: /\\.js$/, use: [\"babel-loader\"] }, // 跳出，不匹配下面的loader { test: /\\.css$/, use: [\"style-loader\", \"css-loader\"] }, { test: /\\.html$/, use: [\"html-loader\"] } ] } ] } } 书写方式 如果一个资源文件只需要用一个loader来进行处理，那么你可以直接在rules子对象中指定loader为一个string，并且在下面可以跟随options属性： const { resolve } = require('path'); module.exports = { ... module: { rules: [ { test: /\\.html$/, loader: 'html-loader', options:{ // 配置项 } }, ] } } 如果一个资源文件需要有多个loader来进行处理，那么你可以使用数组use来存放多个loader。 注意！use中loader的加载顺序是至下而上，自右而左的，所以下面示例中当css后缀名的文件被匹配时会先使用css-loader进行处理，然后再使用style-loader进行处理： const { resolve } = require('path'); module.exports = { ... module: { rules: [ { test: /\\.css$/, use: [ \"style-loader\", \"css-loader\" ] }, ] } } 如果use中的某些loader需要有一些详细的配置，你也可以将它指定为一个对象，如下所示： const { resolve } = require('path'); module.exports = { ... module: { rules: [ { test: /\\.css$/, use: [ \"style-loader\", { loader: \"css-loader\", options: { // 配置项 } } ] }, ] } } 常用配置 在一个具体的loader中，你也可以使用以下的配置项，来进行更加详细的定制，如eslint-loader会检查js文件的语法是否符合规范，但对于一些内置或第三方库来说我们并不需要对它们做重复的检查，因此可以将它们进行排除。 如下所示： const { resolve } = require('path'); module.exports = { ... module: { rules: [ { test: /\\.js$/, use: [\"eslint-loader\"], exclude: /node_modules/, // 不需要检测该目录下的语法 include: resolve(__dirname, \"src\"), // 仅检查该目录下的语法 enforce: \"pre\", // 优先于所有loader执行，此外你也可以设置post，即最后执行该loader } ] } } plugins 插件（plugins）可以用于执行范围更广的任务。 插件的范围包括，从打包优化和压缩，一直到重新定义环境中的变量。 插件接口功能极其强大，可以用来处理各种各样的任务。 想要使用一个插件，你只需要require()它，然后把它添加到plugins数组中。 多数插件可以通过选项(option)自定义。你也可以在一个配置文件中因为不同目的而多次使用同一个插件，这时需要通过使用new操作符来创建它的一个实例。 换而言之，loader是规定webpack如何处理非JavaScript模块的转换，它只针对一些特定类型，如.less、.css、.ts等。 而plugin是贯穿整个webpack打包生命周期的，依照插件的类型，它会在不同时期进行调用，丰富webpack打包过程，如压缩css、js等操作。 配置方式 每个plugin都是一个独立的类，因此你可以直接在plugins中对它进行实例化： const { resolve } = require('path'); const HtmlWebpackPlugin = require('html-webpack-plugin'); module.exports = { ... plugins: [ new HtmlWebpackPlugin(), ] } 注意，有些plugin是webpack内置的，你可以直接使用它们，而有些plugin则需要通过npm进行下载安装。 一般来说我们会根据plugin的功能不同将它们区别安装在开发环境或生产环境中。 mode 模式(Mode)指示webpack使用相应模式的配置。 它有2个选项： development：开发模式 production：生产模式 不同的模式选择，会触发webpack不同的优化机制。 选项 描述 特点 development 会将 DefinePlugin 中 process.env.NODE_ENV 的值设置 为 development。启用 NamedChunksPlugin 和 NamedModulesPlugin。 能让代码本地调试 运行的环境 production 会将 DefinePlugin 中 process.env.NODE_ENV 的值设置 为 production。启用 FlagDependencyUsagePlugin, FlagIncludedChunksPlugin, ModuleConcatenationPlugin, NoEmitOnErrorsPlugin, OccurrenceOrderPlugin, SideEffectsFlagPlugin 和 TerserPlugin。 能让代码优化上线 运行的环境 最常见的是production下会压缩打包后的JavaScript代码，而development下不会压缩打包后的JavaScript代码。 配置方式 我们只需要在webpack.config.js中配置mode即可，如下所示： module.exports = { mode: \"development\", ... } 其他概念 webpack依赖图 现如今的主流框架都是单页面开发，那么我们知道webpack在打包时必须有一个入口文件，在入口文件下可以导入各式各样的资源文件，只要你有对应的loader将其进行处理成浏览器可识别的资源都是可行的，如下代码： // entry.js import \"./static/js/index.js\" import \"./static/js/login.js\" import \"./static/js/register.js\" // 入口文件中引入了js文件，js文件是浏览器所认识的并不需要特别的loader进行转换，可以直接引用，但如果需要压缩代码或者提高兼容性，那么就需要loader进行处理了 // index.js import \"../css/index.less\" // index.js中引入了less文件，less文件是不被浏览器所认识的，所以需要有特别的loader对其进行转换，否则打包将产生错误 // index.less body { background-img: url(\"../imgs/background.jpeg\"); } // index.less中引入了图片资源，在打包时我们需要对其进行处理，将图片压缩或者变为base64数据流的格式以减少请求次数，因此也需要有特别的loader进行转换，否则将产生显示错误 那么上面三个简单的文件，就可以引出一份webpack依赖图，关于login.js或者register.js中的依赖我们并没有进行详细的说明，但整体逻辑都差不多： browserslist 在package.json中有一项配置名为browserslist，它规定了当前项目所支持的浏览器列表，在使用babel等构建工具时，它将产生作用。 也就是说，我们需要为项目做一些兼容性的支持时，就必须先定义它，然后再将它与loader结合使用，在打包时以提高css、js文件代码的兼容性，如何配置browserslist呢？ 其实他有2种模式，一种是生产模式，一种是开发模式（默认的）。 注意这2种模式和webpack的2种模式是不一样的，两者没有任何关系。 以下是定义它的规则： \"browserslist\": { \"development\": [ \"last 1 chrome version\", // 兼容最后一个chrome版本 \"last 1 firefox version\", // 兼容最后一个firefox版本 \"last 1 safari version\" // 兼容最后一个safari版本 ], \"production\": [ \">0.2%\", // 兼容市面上所有大于百分之2的浏览器 \"not dead\", // 不兼容已废弃的浏览器 \"not op_mini all\" // 不兼容所有版本的op_mini浏览器 ] } 如果，你想使用browserslist开发环境下的配置时，就需要在webpack.config.js中对其进行设置： const { resolve } = require('path'); process.env.NODE_ENV = \"development\" // 加载browserslist的development兼容性列表 module.exports = { mode: \"development\", entry: \"./src/entry.js\", output: { filename: \"main.js\", path: resolve(__dirname, \"dist\") }, module: { rules: [ { test: /\\.css$/, use: [ \"style-loader\", \"css-loader\", // 将依照browserslist处理兼容性 { loader: \"postcss-loader\", options: { postcssOptions: { plugins: [\"postcss-preset-env\"] } } } ] } ] } } reslove reslove是webpack.config.js中能够更加方便我们模块查找的一个配置项，我们知道在vue中，它将src目录设置成了@，因此在导入src目录下的文件时，我们可以直接使用下面的语法格式： import \"@/static/index.js\" 它是如何做到的呢？其实内部就是和webpack的reslove原理一致，如下所示： const { resolve } = require('path'); process.env.NODE_ENV = development; module.exports = { mode: \"development\", resolve: { alias: { \"@\": resolve(__dirname, \"src\"), } }, ... } 除此之外，reslove也可以用于设置文件扩展名的省略缩写，众所周知Node.js的模块只支持js文件和json文件，如果想导入一个其他类型的文件该怎么做？ 你只需要如下设置即可： const { resolve } = require('path'); process.env.NODE_ENV = development; module.exports = { mode: \"development\", resolve: { alias: { \"@\": resolve(__dirname, \"src\"), }, extensions: [\".js\", \".ts\", \".json\", \".less\", \".css\", \".scss\", \".vue\"] }, entry: \"./src/entry.js\", output: { filename: \"main.js\", path: resolve(__dirname, \"dist\") }, ... } 这样在导入时，我们可以不加后缀名，它会自动的匹配extensions列表中的后缀与文件名进行拼接，如下所示： import \"@/static/css/index\" // 自动匹配 index.js -> index.json -> index.less -> index.css -> index.scss -> index.vue webpack初体验 项目目录 以下是整个webpack处体验的项目目录，我们打算将js文件进行打包： . ├── dist ├── src │ ├── entry.js // 打包的入口文件 │ ├── index.html // 主页面 │ └── static // 静态资源目录 │ └── js │ └── index.js // index.js脚本文件 ├── package.json └── webpack.config.js 以下是index.html文件的内容： webpack初体验 HELLO WORLD 然后是index.js，主要工作就是点击hello world字样时改变字体颜色： document.querySelector(\"h1\").addEventListener(\"click\", event => { const r = Math.round(Math.random() * 256).toFixed(); const g = Math.round(Math.random() * 256).toFixed(); const b = Math.round(Math.random() * 256).toFixed(); event.target.setAttribute(\"onselectstart\", \"return false\"); event.target.style.cssText = `color : rgb(${r}, ${g}, ${b})`; }) webpack.json中也没什么好配置的，因为不需要处理兼容性的问题，只需要指定入口文件和输出文件即可： const { resolve } = require('path'); // node.js模块，用于路径拼接 module.exports = { mode: \"development\", entry: \"./src/entry.js\", output: { filename: \"main.js\", path: resolve(__dirname, \"dist\") }, devtool: false, // devtool为false时，不会压缩打包后的代码，推荐在学习过程中添加 } 最后别忘记在入口文件entry.js中导入index.js： import \"./static/js/index.js\" 安装webpack 然后是安装webpack，只需要使用npm命令即可，由于webpack是开发环境下使用的，所以我们要使用--save-dev的后缀将webpack安装在项目的开发环境中： $ npm install webpack webpack-cli --save-dev 这2个包的作用在于： webpack：提供打包服务 webpack-cli：提供命令行操纵方式 资源打包 现在我们就可以使用webpack对其进行打包了，只需要输入以下命令即可，它会自动在项目根目录中寻找webpack.config.js： $ npx webpack # npx命令用于在本地的node_modules中执行命令，并不会使用全局npm下安装的包命令。 打包后dist目录会生成一个main.js文件，那么我们可以利用live server打开index.html，查看打包的结果是否顺利。 资源检测 当被打包的资源文件内容发生变更时，我们希望webpack会自动对其进行打包。 可以使用以下命令对被打包的资源文件进行监听： $ npx webpack --watch 这样当我们改变index.js文件代码时，webpack会自动的重新打包。 指定配置 webpack.config.js文件通常来说会有2份，一份用于生产环境，一份用于开发环境。 我们可以在webpack打包命令后指定所需要选择的配置文件，如下所示： $ npx webpack --config ./webpack_config/webpack.dev.config.js $ npx webpack --config ./webpack_config/webpack.pro.config.js 更推荐在package.json中自定义npm脚本命令： \"scripts\": { \"dev-build\": \"npx webpack --config ./webpack_config/webpack.dev.config.js\", \"pro-build\": \"npx webpack --config ./webpack_config/webpack.pro.config.js\" }, 这样在打包时就非常方便了： $ npm run dev-build $ npm run pro-build Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:48 "},"前端专栏/Webpack5/常用配置.html":{"url":"前端专栏/Webpack5/常用配置.html","title":"常用配置","keywords":"","body":"基本插件 clean-webpack-plugin 我们每次打包后都需要手动删除dist目录下的打包资源，这样做会很麻烦。 为了方便后面的学习，因此推荐安装clean-webpack-plugin，它会在每次打包之前自动删除dist目录下的所有资源。 由于它是一个第三方插件，故我们需要使用npm进行下载： $ npm install clean-webpack-plugin --save-dev 在webpack.config.js中进行插件导入之后直接在plugins中使用即可： const { CleanWebpackPlugin } = require('clean-webpack-plugin') const { resolve } = require('path') module.exports = { mode: \"development\", devtool: false, entry: \"./src/entry.js\", output: { filename: \"main.js\", path: resolve(__dirname, \"dist\") }, plugins: [ new CleanWebpackPlugin(), ] } 你可以在dist目录下新建一个文件，然后执行webpack打包，打包完成后会发现你新建的文件已经被清理掉了。 html-webpack-plugin 在之前的webpack初体验中，我们需要在主页面index.html文件中手动引入打包后的main.js文件，这样做非常的麻烦。 因此推荐使用html-webpack-plugin插件，它会自动的在dist目录下生成一个html文件，你只需要在插件中配置该html文件所继承的模板是谁即可，当打包完成后，该插件所生成的html文件会自动引入被打包后的main.js资源，可以让我们将注意力更加专注的放在代码的编写上，而不是放在资源的引入上。 由于它是一个第三方插件，故我们需要使用npm进行下载： $ npm install html-webpack-plugin --save-dev 在webpack.config.js中进行插件导入之后直接在plugins中使用即可： const { CleanWebpackPlugin } = require('clean-webpack-plugin') const HtmlWebpackPlugin = require('html-webpack-plugin') const { resolve } = require('path'); module.exports = { mode: \"development\", devtool: false, entry: \"./src/entry.js\", output: { filename: \"main.js\", path: resolve(__dirname, \"dist\") }, plugins: [ new CleanWebpackPlugin(), new HtmlWebpackPlugin({ // 指定模板文件 template: \"./src/index.html\", minify:{ // 移除模板文件中的空格 collapseWhitespace: true, // 移除模板文件中的注释 removeComments: true, } }), ] } 此时，在index.html文件中就可以删除掉我们所手动引入的打包后的资源： html-webpack-plugin --> HELLO WORLD 注意，现在我们的dist目录下并没有index.html文件，当执行webpack打包后，html-webpack-plugin插件会自动创建一个html文件，注意对比两者之间的差距： html-webpack-plugin --> HELLO WORLD DefinePlugin 在index.html中我们可以书写一些EJS的语法，然后通过DefinePlugin插件对其进行渲染。 DefinePlugin是一个自带的插件，不用下载，直接使用即可，我们使用该插件定义了一个模板变量title，值是一个字符串： const { CleanWebpackPlugin } = require('clean-webpack-plugin') const HtmlWebpackPlugin = require('html-webpack-plugin') const { DefinePlugin } = require('webpack') const { resolve } = require('path'); module.exports = { mode: \"development\", devtool: false, entry: \"./src/entry.js\", output: { filename: \"main.js\", path: resolve(__dirname, \"dist\") }, plugins: [ new CleanWebpackPlugin(), new HtmlWebpackPlugin({ template: \"./src/index.html\", }), new DefinePlugin({ title: \"'Welcome home!'\" // 注意，这里如果你想使用字符串必须再包裹一层，否则将会在打包时出现语法错误 }) ] } index.html文件中使用EJS语法，引入该模板变量： DefinePlugin 进行打包后打开dist/index.html文件后会发现他会显示，Welcome home!的字样。 这里我们需要注意一个小问题，上面也提到过，使用该插件定义模板变量时如果模板变量的值是一个字符串，那么必须使用双层引号将它进行包裹，否则将产生语法问题，造成这个问题的原因主要是由于它内部原因所导致的，如下所示： new DefinePlugin({ title: \"Welcome home!\" # --> 等同于 const title = Welcome home 意外的标识符，Welcome未定义 }) new DefinePlugin({ title: \"'Welcome home!'\" # --> 等同于 const title = 'Welcome home' 成功 }) 处理CSS文件 前言概述 我们有这样的一个项目： ├── dist ├── node_modules ├── src │ ├── entry.js │ ├── index.html │ └── static │ ├── css │ │ └── index.css │ └── js │ └── index.js ├── package-lock.json ├── package.json └── webpack.config.js 入口文件entry.js中导入了index.js，而index.js中又导入了index.css，但是css文件是不被浏览器识别的文件，因此需要一个loader来对其进行解决。 # index.html CSS # entry.js import \"./static/js/index.js\" # index.js import \"../css/index.css\" document.querySelector(\"h1\").addEventListener(\"click\", event => { const r = Math.round(Math.random() * 256).toFixed(); const g = Math.round(Math.random() * 256).toFixed(); const b = Math.round(Math.random() * 256).toFixed(); event.target.setAttribute(\"onselectstart\", \"return false\"); event.target.style.cssText = `color : rgb(${r}, ${g}, ${b})`; }) # index.css body { height: 100vh; width: 100vw; display: flex; flex-flow: row nowrap; justify-content: center; align-items: center; } css-loader + style-loader 我们可以使用css-loader配合style-loader来让webpack处理css文件。 首先这2个loader都需要通过npm进行下载： $ npm install css-loader style-loader --save-dev 它们的作用在于： css-loader：将css文件内容加载出来 style-loader：创建标签，并且将css文件内容添加进来，最后将标签添加至html文件的标签中 以下是在配置文件中配置如何处理css文件的代码，在指派loader时需要注意loader定义的顺序，use中的加载顺序是自下而上，自右而左的： const { CleanWebpackPlugin } = require('clean-webpack-plugin') const HtmlWebpackPlugin = require('html-webpack-plugin') const { DefinePlugin } = require('webpack') const { resolve } = require('path'); module.exports = { mode: \"development\", devtool: false, entry: \"./src/entry.js\", output: { filename: \"main.js\", path: resolve(__dirname, \"dist\") }, module: { rules: [ { test: /\\.css$/, use: [ \"style-loader\", \"css-loader\", ] } ] }, plugins: [ ... ] } 然后你就可以执行打包命令了，如果加载正确的话标签应该位于页面的正中心。 此时你可以观察dist目录，发现他并没有生成单独的css文件，这是由于style-loader导致的。但是在main.js文件中，你可以找到css文件的引入代码。 postcss-loader 我们需要让我们的css代码兼容不同版本的浏览器，这个时候就需要借助postcss-loader以及在之前一章节中提到过的browserslist中的配置了。 首先postcss-loader只是一个能够提高兼容性的工具，如何提高代码兼容性还需要另外一个插件postcss-preset-env，我们来简单分析一下3者之间的关系： browserslist：老板，只告诉你要达到什么样的效果 postcss-preset-env：策划，告诉你这个效果应该怎么做才能达到老板的需求 postcss-loader：员工，真正干活的人，通过策划给定的方案进行执行 现在让我们下载postcss-loader以及postcss-preset-env插件： $ npm install postcss-loader postcss-preset-env --save-dev 安装完成之后就可以进行使用了，首先我们可以在package.json中指定browserslist： \"browserslist\": { \"development\": [ \">1%\", \"not dead\", \"not op_mini all\" ], \"production\": [ \">0.2%\", \"not dead\", \"not op_mini all\" ] }, 然后在webpack.config.js中进行配置，注意loader的定义顺序，postcss-loader应该位于css-loader之前进行执行： const { CleanWebpackPlugin } = require('clean-webpack-plugin') const HtmlWebpackPlugin = require('html-webpack-plugin') const { DefinePlugin } = require('webpack') const { resolve } = require('path'); process.env.NODE_ENV = \"development\" // 加载browserslist的development兼容性列表 module.exports = { mode: \"development\", devtool: false, entry: \"./src/entry.js\", output: { filename: \"main.js\", path: resolve(__dirname, \"dist\") }, module: { rules: [ { test: /\\.css$/, use: [ \"style-loader\", \"css-loader\", { loader: \"postcss-loader\", options: { postcssOptions: { plugins: [\"postcss-preset-env\"] } } } ] } ] }, plugins: [ ... ] } css回溯问题 如果我们再新建一个css文件，并且在index.css文件中对其引入，就会导致一个问题，新的css文件不能被postcss-loader进行兼容性处理。 # index.css @import url(\"./other.css\"); body { height: 100vh; width: 100vw; display: flex; flex-flow: row nowrap; justify-content: center; align-items: center; } # other.css h1 { transform: rotate(-3deg); } 当你webpack打包过后，你会发现在旧版本浏览器下的旋转的样式并没有加任何前缀处理兼容性，导致这个的原因其实非常简单： use列表中postcss-loader是第一个被执行的，它将处理index.css，但是index.css中有一个@import()语句，这是postcss-loader所处理不了的 当index.css被postcss-loader处理完成后，会将代码交由use列表中的下一个loader，即css-loader继续进行处理，我们的css-loader可以处理index.css文件中导入的other.css，但是注意！这个other.css在之前并没有被postcss-loader处理过！ 我们所需要做的就是让other.css再重头让postcss-loader处理一遍，该怎么做呢？其实你只需要指定该css文件被第几个loader重新处理即可，如postcss-loader目前在use列表中的执行排序为1，就将importLoaders属性指定为1即可： module: { rules: [ { test: /\\.css$/, use: [ \"style-loader\", { loader: \"css-loader\", options: { importLoaders: 1 // 交由第1个loader重新处理 } }, { loader: \"postcss-loader\", options: { postcssOptions: { plugins: [\"postcss-preset-env\"] } } } ] } ] }, 同理，如果postcss-loader在use列表中第二个执行位置，那么importLoaders就需要指定为2。 less-loader 如果想处理less文件，则只需要安装less-loader插件即可： $ npm install less-loader --save-dev 配置时，它需要在use列表中第一个执行位置，那么postcss-loader的执行位置就变成了2，同理，css-loader的importLoaders属性也需要改变为2： const { CleanWebpackPlugin } = require('clean-webpack-plugin') const HtmlWebpackPlugin = require('html-webpack-plugin') const { DefinePlugin } = require('webpack') const { resolve } = require('path'); process.env.NODE_ENV = \"development\" module.exports = { mode: \"development\", devtool: false, entry: \"./src/entry.js\", output: { filename: \"main.js\", path: resolve(__dirname, \"dist\") }, module: { rules: [ ... { test: /\\.less$/, use: [ \"style-loader\", { loader: \"css-loader\", options: { importLoaders: 2 } }, { loader: \"postcss-loader\", options: { postcssOptions: { plugins: [\"postcss-preset-env\"] } } }, \"less-loader\" ] } ] }, plugins: [ ... ] } 单独拆分CSS文件 style-loader会将css文件内容全部与main.js一起打包，如果我们想对其进行拆分，可使用MiniCssExtractPlugin中的loader来代替它。 首先需要进行安装： $ npm install mini-css-extract-plugin --save-dev 它是一款插件，所以要先对其进行引入： const MiniCssExtractPlugin = require('mini-css-extract-plugin') 然后是使用方式，直接看配置文件： const MiniCssExtractPlugin = require('mini-css-extract-plugin') const { resolve } = require('path'); process.env.NODE_ENV = \"development\" module.exports = { mode: \"development\", devtool: false, entry: \"./src/entry.js\", output: { filename: \"main.js\", path: resolve(__dirname, \"dist\") }, module: { rules: [ { test: /\\.css$/i, use: [ // 代替style-loader MiniCssExtractPlugin.loader, { loader: \"css-loader\", options: { // 解决css中的图片引入问题 esModule: false, // 设置兼容性，回溯层级为1 importLoaders: 1 } }, { loader: \"postcss-loader\", options: { postcssOptions: { plugins: [\"postcss-preset-env\"] } } } ] }, ] }, plugins: [ ... new MiniCssExtractPlugin({ // 指定需要输出的文件名，它会在dist/css文件中进行输出 filename: \"css/[name].css\" }) ] } 压缩CSS文件 在项目部署上线之前，我们一般都会对css文件进行压缩处理，将它压缩为一行。 使用插件css-minimizer-webpack-plugin来进行这项工作非常的方便，首先还是需要对其进行安装： $ npm install css-minimizer-webpack-plugin --save-dev 使用方式： const CssMinimizerPlugin = require(\"css-minimizer-webpack-plugin\"); const { resolve } = require('path'); process.env.NODE_ENV = \"development\" module.exports = { mode: \"development\", devtool: false, entry: \"./src/entry.js\", output: { filename: \"main.js\", path: resolve(__dirname, \"dist\") }, module: { rules: [ ... ] }, plugins: [ ... ], optimization: { minimizer: [ new CssMinimizerPlugin(), ], // 默认只有在生产环境下才会生效，通过该属性的添加让它在开发环境下也生效 minimize: true }, } 处理JS文件 babel-loader 同postcss-loader一样，babel-loader也是用于提高js兼容性而产生的。 它不仅可以让ES6的代码在较低版本的浏览器环境中运行，还能使ts、jsx等文件转换为js文件。 首先babel-loader只是一个能够提高兼容性的工具，如何提高代码兼容性还需要另外几个插件@babel/preset-env以及core-js，我们来简单分析一下4者之间的关系： browserslist：老板，只告诉你要达到什么样的效果 @babel/preset-env：主策划，指定主体方案，如何提高兼容性（能提高的兼容性有限） core-js：策划助理，负责为主策划的方案做填充，让主策划的方案兼容性更高 bebel-loader：员工，真正干活的人，通过策划给定的方案进行执行 首先我们需要安装这几个插件： $ npm install babel-loader core-js regenerator-runtime @babel/preset-env --save-dev # regenerator-runtime同core-js的作用一样，也是用于填充主策划方案而存在的策划助理 然后是配置项： { test: /\\.js$/, exclude: /node_modules/, loader: \"babel-loader\", options: { presets: [ [ \"@babel/preset-env\", { // 指定corejs的版本 corejs: 3, // 选择corejs的填充模式 // false : 不填充 // usage : 按需填充，使用到那个功能再兼容那个功能 // entry : 全部填充，不管有没有使用到那个功能都填充进去 // 注意，如果填充模式为entry，则需要在全局导入 import \"core-js/stable\" 以及 import \"regenerator-runtime/runtime\" useBuiltIns: \"usage\", } ] ] } } 处理TS文件 我们也可以通过babel-loader来处理ts文件，值得注意的是babel-loader不能检测ts语法是否合格。 因此在编译ts项目之前，我们需要使用tsc --noEmit命令来检查ts文件内容是否书写合法。需要使用一个第三方插件@babel/preset-typescript： $ npm install @babel/preset-typescript --save-dev 以下是babel-loader处理ts文件的配置： { test: /\\.ts$/, exclude: /node_modules/, loader: \"babel-loader\", options: { presets: [ [ \"@babel/preset-env\", { corejs: 3, useBuiltIns: \"usage\", } ], [\"@babel/preset-typescript\"], ] } } 在打包项目之前，请先输入tsc --noEmit确认没有ts语法错误后再进行打包： $ tsc --noEmit # 获取全局未安装typescript，请使用npx tsc --noEmit $ npx webpack 压缩JS文件 当你的webpack打包模式设置为production后，打包过后的js文件会自动压缩成一行，不需要再额外的单独进行设置。 其他资源处理 处理CSS中引入的图片资源 webpack5中新增了asset来处理图片资源，用于取代之前的file-loader和url-loader。 使用asset处理图片时，它具有2种模式： asset/resource：直接将图片拷贝到dist目录下，相当于之前的file-loader asset/inline：将图片转换为base64格式的数据流，内联在html的的src属性中 如何使用？如下图所示： const { CleanWebpackPlugin } = require('clean-webpack-plugin') const HtmlWebpackPlugin = require('html-webpack-plugin') const { DefinePlugin } = require('webpack') const MiniCssExtractPlugin = require('mini-css-extract-plugin') const CssMinimizerPlugin = require(\"css-minimizer-webpack-plugin\"); const { resolve } = require('path'); process.env.NODE_ENV = \"development\" // 加载browserslist的development兼容性列表 module.exports = { mode: \"development\", devtool: false, entry: \"./src/entry.js\", output: { filename: \"main.js\", path: resolve(__dirname, \"dist\") }, module: { rules: [ ... { test: /\\.(png|svg|gif|jpe?g)/, // 自动选择模式 type: \"asset\", // 配置asset/resource时图片的保存路径 generator: { filename: \"img/[name][hash:4][ext]\" }, // 当图片大小小于8kb时，将启用asset/inline模式 parser: { dataUrlCondition: { maxSize: 8 * 1024, } } } ] }, plugins: [ ... ], optimization: { ... }, } 需要注意一点，当需要处理css中的图片资源时，你必须指定css-loader的options属性中esModule为false，否则将产生令人意外的情况： { loader: \"css-loader\", options: { importLoaders: 1, esModule: false } }, 在index.less中引入nginx.jpeg： body div { width: 400px; height: 400px; background-image: url(\"../imgs/nginx.jpeg\"); } 打包后查看效果。 处理HTML中引入的图片资源 asset的设置只能用于处理在CSS中引入的图片资源，如果你在index.html中引入了一张图片，那么asset是处理不了的。如： # index.html 此时我们需要下载一个html-loader来对html文件内容作出解析，然后再交由asset进行处理。 首先安装该loader： $ npm install html-loader --save-dev 使用该loader： { test: /\\.html$/, loader: \"html-loader\", options: { esModule: false, } } 注意，该loader和DefinePlugin有所冲突，因此两者选其一即可，其实DefinePlugin插件实际生产中很少使用，几乎用不到，因此可以直接放弃它。 打包完成后，可以发现生成的index.html文件中src的路径指向已被改变： 处理字体文件及其他资源 如果想处理字体文件或者其他资源，通过asset也可以进行解决，这里不再进行演示： { test: /\\.(ttf|woff2?)$/, type: \"asset/resource\", generator: { filename: \"font/[name][hash:4][ext]\" } } copy_webpack_plugin copy_webpack_plugin插件用于对资源进行拷贝，被该插件选中的目录不会进行打包。 我们可以利用该插件来将一些不需要打包的文件放置在dist目录下，如favicon图标： $ npm install copy-webpack-plugin --save-dev 使用案例： const { CleanWebpackPlugin } = require('clean-webpack-plugin') const HtmlWebpackPlugin = require('html-webpack-plugin') const { DefinePlugin } = require('webpack') const MiniCssExtractPlugin = require('mini-css-extract-plugin') const CssMinimizerPlugin = require(\"css-minimizer-webpack-plugin\"); const CopyWebpackPlugin = require(\"copy-webpack-plugin\"); const { resolve } = require('path'); process.env.NODE_ENV = \"development\" // 加载browserslist的development兼容性列表 module.exports = { mode: \"development\", devtool: false, entry: \"./src/entry.js\", output: { filename: \"main.js\", path: resolve(__dirname, \"dist\") }, module: { ... }, plugins: [ ... new CopyWebpackPlugin({ patterns: [ { // 拷贝那个目录下的内容 from: resolve(__dirname, \"src\", \"resource\"), // 拷贝到那个目录下，可不写，如果不写则按照output中的path进行输出 to: resolve(__dirname, \"dist\", \"resource\"), globOptions: { // 忽略的文件 ignore: [\"**/reboots.text\",], } } ] }) ], optimization: { ... } } Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:48 "},"前端专栏/Webpack5/devServer.html":{"url":"前端专栏/Webpack5/devServer.html","title":"devServer","keywords":"","body":"基本介绍 在通过webpack开发时我们期望拥有一款更加高效的工具来提高我们的开发效率。 如果你使用vscode进行开发，那么可以通过webpack的--watch搭配live server来进行实时加载，但是这样做并不是最完美的解决方案，它依然存在以下几点问题： 每次源代码更新后所有的模块资源都会重新打包，即使你只修改了上百个模块中的其中一个 每次的编译打包操作都会引起磁盘的读写，因为打包后的资源文件会放置在磁盘上 为了解决这些问题，webpack中提供了一个server服务器，名为devServer，使用它来进行开发是我们最佳的选择。 它支持热更新、同时打包后的文件是放置在内存中，并不会写入磁盘，因此打包的速度非常快。 在进行代码编写时，devServer能够让我们更快的预览结果。 devServer配置 要想使用devServer，先要对其进行下载，devServer只在开发环境下使用，所以需要加上-dev的后缀： $ npm install webpack-dev-server --save-dev 要想启用devServer，推荐使用npm脚本进行操作，你只需要在package.json中的script中写入以下命令即可： \"scripts\": { \"dev-build\": \"npx webpack --config ./webpack_config/webpack.dev.config.js\", \"pro-build\": \"npx webpack --config ./webpack_config/webpack.pro.config.js\", \"dev-server\": \"npx webpack serve --config ./webpack.config.js\" }, 然后再命令行终端中敲入以下命令即可成功开启服务： $ npm run dev-server 它的端口号默认为8080，你可以对其进行访问。 相关配置 以下是devServer中的相关配置，我们要将其书写在webpack.config.js中： const { CleanWebpackPlugin } = require('clean-webpack-plugin') const HtmlWebpackPlugin = require('html-webpack-plugin') const { DefinePlugin } = require('webpack') const MiniCssExtractPlugin = require('mini-css-extract-plugin') const CssMinimizerPlugin = require(\"css-minimizer-webpack-plugin\"); const CopyWebpackPlugin = require(\"copy-webpack-plugin\"); const { resolve } = require('path'); process.env.NODE_ENV = \"development\" // 加载browserslist的development兼容性列表 module.exports = { mode: \"development\", devtool: false, entry: \"./src/entry.js\", output: { filename: \"main.js\", path: resolve(__dirname, \"dist\") }, // 在开发环境下，我们需要屏蔽掉browserslist的兼容性设置 // 只需要将target设置为web即可，否则热更新将失效 target: \"web\", devServer: { // 指定devServer的域名 host: 'localhost', // 指定devServer的端口号 port: 8080, // 是否开启热更新(一个模块更新后，并不重复打包其他的模块) hot: true, // 服务启动成功后是否自动打开浏览器 open: false, // 自动通过gzip压缩打包后的文件（在内存中），提升性能，推荐设置为true compress: true, // 在H5中（常见于单页面应用路由跳转里），当路由页面跳转后点击刷新页面时可能会发生404的情况，通过设置为true以进行解决 historyApiFallback: true, // 服务器代理 --> 解决开发环境跨域问题（推荐使用Chrome插件CORS进行解决，更方便省力） proxy: { // 一旦devServer(5000)服务器接受到 /api/xxx 的请求，就会把请求转发到另外一个服务器(3000) '/api': { target: 'http://localhost:3000', // 发送请求时，请求路径重写：将 /api/xxx --> /xxx （去掉/api） pathRewrite: { '^/api': '' } } } }, ... } HMR 如果想使用热更新的功能，我们除开需要在devServer中配置hot为true，还需要在入口文件entry.js中配置支持热更新的模块： import \"./static/js/index.js\" // 背后导入了index.css import \"./static/js/login.js\" // 背后导入了login.css if (module.hot) { module.hot.accept( // 支持热更新功能的模块 [ \"./static/js/index.js\", \"./static/js/login.js\", ], // 热更新后执行的回调函数 ()=>{ console.log(\"模块更新了\"); } ) } 上述这样配置的意思是： 当更新了login.js模块内容时，不会影响其他模块 当更新了index.js模块内容时，不会影响其他模块 一个项目中有多少个小组件，就配置多少个热更新即可。 我们来看一下它的效果，首先我在login.js中添加了一个输入框： console.log(\"login\"); document.body.append( document.createElement(\"input\") ) 然后当我更新index.js文件内容时，login.js输入框中输入的内容并不会被清除掉： 如果你想让Vue支持热更新，请参阅官方教程，点我跳转： Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:48 "},"前端专栏/Webpack5/优化配置.html":{"url":"前端专栏/Webpack5/优化配置.html","title":"优化配置","keywords":"","body":"代码映射 代码映射（source-map）是webpack中非常重要的一门技术，我们知道打包过后的代码和打包前的代码是不一样的，尤其是做了兼容性处理的时候。 如果运行打包后的代码产生了错误，我们需要依据source-map找到源代码中报错语句并对其进行修改，换而言之source-map技术就是在打包后的代码出现错误时，能够定位源代码中报错位置的一门技术。 在使用时，只需要设置devtool即可，它有以下一些设置项： source-map：会生成source-map文件，能够捕捉错误代码的报错信息，以及源代码中的错误位置 inline-source-map：生成内联的source-map文件，能够捕捉错误代码的报错信息，以及源代码中的错误位置 hidden-source-map：不会生成source-map文件，它只有错误代码的错误原因，只能提示到构建后代码的错误位置，没有源代码中的错误位置， eval-source-map：会为每一个文件都生成一个对应的source-map并放置在eval()函数中，能够捕捉错误代码的报错信息，以及源代码中的错误位置 nosources-source-map：会生成source-map文件，能够捕捉错误代码的报错信息，但不能提示源代码中的错误位置 cheap-source-map：会生成source-map文件，能够捕捉错误代码的报错信息，以及源代码中的错误位置，但只能精确到行，不包含loader的 sourcemap（譬如babel的sourcemap） cheap-module-source-map：会生成source-map文件，能够捕捉错误代码的报错信息，以及源代码中的错误位置，能够精确到行，同时loader的 sourcemap也被简化为只包含对应行的。 推荐设置，其实[inline-|hidden-|eval-][nosources-][cheap-[module-]]source-map可以任意组合： 开发环境：eval-source-map或者eval-cheap-module-source-map 生产环境：hidden-source-map或者nosources-source-map 使用示例： # index.js import \"../css/index.less\" throw new Error(\"this is error\") 配置文件： const { CleanWebpackPlugin } = require('clean-webpack-plugin') const HtmlWebpackPlugin = require('html-webpack-plugin') const { DefinePlugin } = require('webpack') const MiniCssExtractPlugin = require('mini-css-extract-plugin') const CssMinimizerPlugin = require(\"css-minimizer-webpack-plugin\"); const CopyWebpackPlugin = require(\"copy-webpack-plugin\"); const { resolve } = require('path'); process.env.NODE_ENV = \"development\" // 加载browserslist的development兼容性列表 module.exports = { mode: \"development\", devtool: \"source-map\", entry: \"./src/entry.js\", output: { filename: \"main.js\", path: resolve(__dirname, \"dist\") }, target: \"web\", devServer: { ... }, module: { rules: [ ... ] }, plugins: [ ... ], optimization: { ... } } 测试结果： # source-map # 会生成main.js.map # 能定位源代码中出错的位置 Uncaught Error: this is error at Module../src/static/js/index.js (index.js:3) # inline-source-map # 不会生成main.js.map # 能定位源代码中出错的位置 Uncaught Error: this is error at Object../src/static/js/index.js (index.js:3) # hidden-source-map # 会生成main.js.map # 不能定位源代码中出错的位置 Uncaught Error: this is error at Object../src/static/js/index.js (main.js:14) # eval-source-map # 不会生成main.js.map # 能定位源代码中出错的位置 Uncaught Error: this is error at eval (index.js?2127:3) at Object../src/static/js/index.js (main.js:30) # nosources-source-map # 会生成main.js.map # 能定位源代码中出错的位置，但不能进行查看 Uncaught Error: this is error at Object../src/static/js/index.js (index.js:3) # cheap-source-map # 会生成main.js.map # 能定位源代码中出错的位置，并且具有出错行的波浪线提示 Uncaught Error: this is error at Object../src/static/js/index.js (index.js:2) # cheap-module-source-map # 会生成main.js.map # 能定位源代码中出错的位置，并且具有出错行的波浪线提示 index.js:3 Uncaught Error: this is error at Object../src/static/js/index.js (index.js:3) 树摇 树摇（tree shaking）的意思即为把一颗书上的枯叶摇下来，对应到代码中即为删除无效代码。 开启树摇的前提有2个： 必须使用ES6 Module 必须开启Node.js的protected生产环境 只要满足这2个条件，webpack会自动开启树摇，但是开启树摇也有可能出现一些问题。 比如你的css、less文件等没有第一时间被使用时，可能被摇下来，除此之外babel-loader填充的资源也有可能被摇下来，针对这些现象我们可以在loader中配置sideEffects: true，告诉webpack不要树摇这些loader： process.env.NODE_ENV = \"protected\" module.exports = { mode: \"protected\", module: { rules: [ { test: /\\.css$/i, use: [\"style-loader\", \"css-loader\"], sideEffects: true } ] }, }; 多进程打包 当webpack需要处理的项目十分庞大时，我们可以开启多进程打包。 多进程打包是一把双刃剑，针对大项目的打包会有效提高打包效率，但是项目较小时打包的速度反而会更慢。 你需要先下载thread-loader： $ npm install thread-loader --save-dev 在打包过程中，babel是耗时最久的，所以我们可以为它加上该loader： { test: /\\.js$/, exclude: /node_modules/, use: [ { loader: \"thread-loader\", options: { // 开启4个进程,每个进程的启动大约是600毫秒 worker: 4, } }, { loader: \"babel-loader\", options: { presets: [ [ \"@babel/preset-env\", { corejs: 3, useBuiltIns: \"usage\", } ] ] } } ], } Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:48 "},"前端专栏/Webpack5/配置整理.html":{"url":"前端专栏/Webpack5/配置整理.html","title":"配置整理","keywords":"","body":"需要的包 项目中需要的包比较多，如下所示： $ npm install clean-webpack-plugin --save-dev $ npm install html-webpack-plugin --save-dev $ npm install css-loader style-loader --save-dev $ npm install postcss-loader postcss-preset-env --save-dev $ npm install less-loader --save-dev $ npm install mini-css-extract-plugin --save-dev $ npm install css-minimizer-webpack-plugin --save-dev $ npm install babel-loader core-js regenerator-runtime @babel/preset-env @babel/preset-typescript --save-dev $ npm install html-loader --save-dev $ npm install copy-webpack-plugin --save-dev $ npm install webpack-dev-server --save-dev $ npm install thread-loader --save-dev 开发环境配置 以下是开发环境下的推荐配置。 首先是package.json中的browserslist： \"browserslist\": { \"development\": [ \">1%\", \"not dead\", \"not op_mini all\" ], \"production\": [ \">0.2%\", \"not dead\", \"not op_mini all\" ] }, 然后配置npm脚本，我们就直接将配置文件放置在项目根目录下，方便路径的填写，如果你的项目中没有使用TypeScript，则删除tsc --noEmit即可： \"scripts\": { \"dev-build\": \"tsc --noEmit && npx webpack --config ./webpack.dev.config.js\", \"dev-server\": \"tsc --noEmit && npx webpack serve --config ./webpack.dev.config.js\" }, 然后是webpack.dev.config.js文件，在开发环境下我们并不需要做任何兼容性处理，所以配置项较少： const { CleanWebpackPlugin } = require('clean-webpack-plugin') const HtmlWebpackPlugin = require('html-webpack-plugin') const CopyWebpackPlugin = require(\"copy-webpack-plugin\") const { resolve } = require('path') // 配置Node.js的运行环境：打包时不进行树摇 process.env.NODE_ENV = 'development'; module.exports = { // 配置webpack的运行环境 mode: \"development\", // 配置代码映射方式，能够查看源代码错误 devtool: \"eval-source-map\", // 配置入口文件 entry: \"./src/entry.js\", // 由于不需要做兼容性处理，target改为web即可 target: \"web\", // 配置输出的文件名称 output: { filename: \"main.js\", path: resolve(__dirname, \"dist\") }, // 详细配置 module: { rules: [ { // 所有的规则只匹配一次就跳出，不进行重复匹配 oneOf: [ // 处理css { test: /\\.css$/i, use: [ \"style-loader\", { loader: \"css-loader\", options: { // 解决css中的图片引入问题 esModule: false } } ] }, // 处理less { test: /\\.less$/i, use: [ \"style-loader\", { loader: \"css-loader\", options: { // 解决css中的图片引入问题 esModule: false } }, \"less-loader\" ] }, // 处理ts { test: /\\.ts$/i, // 不处理node_modules下的ts文件 exclude: /node_modules/, // 使用babel-loader处理ts文件 loader: \"babel-loader\", options: { presets: [ [\"@babel/preset-typescript\"], ] } }, // 处理html图片 { test: /\\.html$/i, loader: \"html-loader\", // 关闭esModule options: { esModule: false, } }, // 处理css图片 { test: /\\.(png|svg|gif|jpe?g)/i, type: \"asset\", generator: { // 如果图片的大小大于8kb，将把图片拷贝到dist目录下的img目录中 filename: \"img/[name][hash:4][ext]\" }, parser: { dataUrlCondition: { // 如果图片的大小小于8kb，将转换为base64的数据流格式 maxSize: 8 * 1024, } } }, // 处理字体资源 { test: /\\.(ttf|woff2?)$/i, // 将字体资源拷贝至dist目录下的font目录中 type: \"asset/resource\", generator: { filename: \"font/[name][hash:4][ext]\" } }, // 处理其他资源依赖图中被引入的资源 { exclude: /\\.(css|less|js|ts|vue|jpe?g|png|gif|svg|ico|ttf|woff2?)$/i, // 将其他被引入的资源拷贝至dist目录下的other目录中 type: \"asset/resource\", generator: { filename: \"other/[name][hash:4][ext]\" } } ] } ] }, plugins: [ // 每次执行npx webpack时将会自动清除dist目录下的文件 new CleanWebpackPlugin(), // 避免我们手动的在index.html中引入打包后的资源文件 new HtmlWebpackPlugin({ // 指定模板文件 template: \"./src/index.html\", minify: { // 移除模板文件中的空格 collapseWhitespace: true, // 移除模板文件中的注释 removeComments: true, } }), // 拷贝一些未在资源图中引入的文件 new CopyWebpackPlugin({ patterns: [ { // 拷贝那个目录下的内容 from: resolve(__dirname, \"src\", \"resource\"), // 拷贝到那个目录下，可不写，如果不写则按照output中的path进行输出 to: resolve(__dirname, \"dist\", \"resource\"), globOptions: { // 忽略的文件 ignore: [\"**/reboots.text\",] } } ] }) ], // 设置路径别名，@代指src目录 resolve: { alias: { \"@\": resolve(__dirname, \"src\"), }, extensions: [\".js\", \".ts\", \".json\", \".less\", \".css\", \".scss\", \".vue\"] }, // 配置开发服务器 devServer: { // 开启热更新 hot: true, // 自动通过gzip压缩打包后的文件（在内存中），提升性能，推荐设置为true compress: true, // 在H5中（常见于单页面应用路由跳转里），当路由页面跳转后点击刷新页面时可能会发生404的情况，通过设置为true以进行解决 historyApiFallback: true }, } 生产环境配置 以下是生产环境下的推荐配置。 首先是package.json中的browserslist： \"browserslist\": { \"development\": [ \">1%\", \"not dead\", \"not op_mini all\" ], \"production\": [ \">0.2%\", \"not dead\", \"not op_mini all\" ] }, 然后配置npm脚本，我们就直接将配置文件放置在项目根目录下，方便路径的填写，如果你的项目中没有使用TypeScript，则删除tsc --noEmit即可： \"scripts\": { \"dev-build\": \"tsc --noEmit && npx webpack --config ./webpack.dev.config.js\", \"pro-build\": \"tsc --noEmit && npx webpack --config ./webpack.pro.config.js\", \"dev-server\": \"tsc --noEmit && npx webpack serve --config ./webpack.dev.config.js\" }, 然后是webpack.pro.config.js文件，在生产环境我们不需要devServer，但是需要做css以及js的兼容性处理，所以配置项较多，此外还有树摇等优化配置： const { CleanWebpackPlugin } = require('clean-webpack-plugin') const HtmlWebpackPlugin = require('html-webpack-plugin') const CopyWebpackPlugin = require(\"copy-webpack-plugin\") const MiniCssExtractPlugin = require('mini-css-extract-plugin') const CssMinimizerPlugin = require(\"css-minimizer-webpack-plugin\") const { resolve } = require('path') // 配置Node.js的运行环境：打包时会进行树摇 process.env.NODE_ENV = 'production'; module.exports = { // 配置webpack的运行环境 mode: \"production\", // 配置代码映射方式，不能够查看源代码错误 devtool: \"hidden-source-map\", // 配置入口文件 entry: \"./src/entry.js\", // 配置输出的文件名称 output: { filename: \"main.js\", path: resolve(__dirname, \"dist\") }, // 详细配置 module: { rules: [ { // 所有的规则只匹配一次就跳出，不进行重复匹配 oneOf: [ // 处理css { test: /\\.css$/i, // 不对css文件进行树摇 sideEffects: true, use: [ MiniCssExtractPlugin.loader, { loader: \"css-loader\", options: { // 解决css中的图片引入问题 esModule: false, // 设置兼容性，回溯层级为1 importLoaders: 1 } }, { loader: \"postcss-loader\", options: { postcssOptions: { plugins: [\"postcss-preset-env\"] } } } ] }, // 处理less { test: /\\.less$/i, // 不进行树摇 sideEffects: true, use: [ MiniCssExtractPlugin.loader, { loader: \"css-loader\", options: { // 解决css中的图片引入问题 esModule: false, // 设置兼容性，回溯层级为2 importLoaders: 2 } }, { loader: \"postcss-loader\", options: { postcssOptions: { plugins: [\"postcss-preset-env\"] } } }, \"less-loader\" ] }, // 处理js { test: /\\.js$/i, // 不对js文件进行树摇 sideEffects: true, // 不处理node_modules下的js文件 exclude: /node_modules/, // 使用babel-loader处理js文件 use: [ { // 多进程打包 loader: \"thread-loader\", options: { // 开启4个进程,每个进程的启动大约是600毫秒 worker: 4, } } , { loader: \"babel-loader\", options: { presets: [ [ \"@babel/preset-env\", { // 指定corejs的版本 corejs: 3, // 选择corejs的填充模式 // usage : 按需填充，使用到那个功能再兼容那个功能 useBuiltIns: \"usage\", } ] ] } } ] }, // 处理ts { test: /\\.ts$/i, // 不对ts文件进行树摇 sideEffects: true, // 不处理node_modules下的ts文件 exclude: /node_modules/, // 使用babel-loader处理ts文件 use: [ { // 多进程打包 loader: \"thread-loader\", options: { // 开启4个进程,每个进程的启动大约是600毫秒 worker: 4, } } , { loader: \"babel-loader\", options: { presets: [ [ \"@babel/preset-env\", { // 指定corejs的版本 corejs: 3, // 选择corejs的填充模式 // usage : 按需填充，使用到那个功能再兼容那个功能 useBuiltIns: \"usage\", } ], [\"@babel/preset-typescript\"] ] } } ] }, // 处理html图片 { test: /\\.html$/i, loader: \"html-loader\", // 关闭esModule options: { esModule: false, } }, // 处理css图片 { test: /\\.(png|svg|gif|jpe?g)/i, type: \"asset\", generator: { // 如果图片的大小大于8kb，将把图片拷贝到dist目录下的img目录中 filename: \"img/[name][hash:4][ext]\" }, parser: { dataUrlCondition: { // 如果图片的大小小于8kb，将转换为base64的数据流格式 maxSize: 8 * 1024, } } }, // 处理字体资源 { test: /\\.(ttf|woff2?)$/i, // 将字体资源拷贝至dist目录下的font目录中 type: \"asset/resource\", generator: { filename: \"font/[name][hash:4][ext]\" } }, // 处理其他资源依赖图中被引入的资源 { exclude: /\\.(css|less|js|ts|vue|jpe?g|png|gif|svg|ico|ttf|woff2?)$/i, // 将其他被引入的资源拷贝至dist目录下的other目录中 type: \"asset/resource\", generator: { filename: \"other/[name][hash:4][ext]\" } } ] } ] }, plugins: [ // 每次执行npx webpack时将会自动清除dist目录下的文件 new CleanWebpackPlugin(), // 避免我们手动的在index.html中引入打包后的资源文件 new HtmlWebpackPlugin({ // 指定模板文件 template: \"./src/index.html\", minify: { // 移除模板文件中的空格 collapseWhitespace: true, // 移除模板文件中的注释 removeComments: true, } }), // 拷贝一些未在资源图中引入的文件 new CopyWebpackPlugin({ patterns: [ { // 拷贝那个目录下的内容 from: resolve(__dirname, \"src\", \"resource\"), // 拷贝到那个目录下，可不写，如果不写则按照output中的path进行输出 to: resolve(__dirname, \"dist\", \"resource\"), globOptions: { // 忽略的文件 ignore: [\"**/reboots.text\",] } } ] }), // 单独拆分css文件 new MiniCssExtractPlugin({ // 指定需要输出的文件名，它会在dist/css文件中进行输出 filename: \"css/[name].css\" }) ], // 设置路径别名，@代指src目录 resolve: { alias: { \"@\": resolve(__dirname, \"src\"), }, extensions: [\".js\", \".ts\", \".json\", \".less\", \".css\", \".scss\", \".vue\"] }, optimization: { minimizer: [ // 压缩css代码 new CssMinimizerPlugin(), ] }, } 如何使用 项目目录一览： ├── dist │ ├── ... ├── node_modules │ ├── ... ├── src │ ├── entry.js │ ├── index.html │ ├── resource │ │ └── readme.md │ └── static │ ├── css │ │ └── index.less │ ├── imgs │ │ ├── avatar.jpg │ │ └── nginx.jpeg │ └── js │ ├── index.ts │ └── login.ts ├── tsconfig.json ├── package-lock.json ├── package.json ├── webpack.dev.config.js └── webpack.pro.config.js 在开发环境下使用时，只需要注意开启热更新模块功能即可： import \"@/static/js/index.ts\" import \"@/static/js/login.ts\" if (module.hot) { module.hot.accept( // 支持热更新功能的模块 [ \"./static/js/index.ts\", \"./static/js/login.ts\", ], // 热更新后执行的回调函数 () => { console.log(\"module update!\"); } ) } 此外，css文件中对于图片的引入，也支持@的方式，这是因为我们配置了webpack.config.json中的reslove： background-image : url(@/static/imgs/nginx.jpeg); 在开发环境下，使用以下命令打开webpack开发服务器： $ npm run dev-server 在生成环境下，使用以下命令进行打包： $ npm run pro-build Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:48 "},"数据库专栏/summary.html":{"url":"数据库专栏/summary.html","title":"数据库专栏","keywords":"","body":" MySQL MongoDB Redis Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:48 "},"数据库专栏/MySQL/summary.html":{"url":"数据库专栏/MySQL/summary.html","title":"MySQL","keywords":"","body":" 数据概述 基础学习 语法相关 配置相关 库相关操作 表相关操作 记录的操作 数值类型 时间类型 字符类型 枚举类型 集合类型 约束条件 单表查询 多表查询 视图相关 触发器 存储过程 函数相关 分支循环 元数据获取 存储引擎 InnoDB存储结构 索引相关 执行计划 事务相关 CSR浅析 事务隔离 锁的知识 运行日志 查询日志 二进制日志 备份恢复 mysqldump xtrabackup 主从复制 MHA架构 Atlas中间件 数据库设计 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:48 "},"数据库专栏/MySQL/数据概述.html":{"url":"数据库专栏/MySQL/数据概述.html","title":"数据概述","keywords":"","body":"数据 数据（DATA）是对事物的一种记录，这种记录可以是多种形式，如图片，数字，字符，声音。 如下我们有一组以表格形式组织的数据： ------------------------------------ | Jack | Male | 18 | Freelance | ------------------------------------ 粗略一看并不知道它的意思，所以我们需要有字段的标注： ------------------------------------ | NAME | GENDER | AGE | PROFESSION | ------------------------------------ | Jack | Male | 18 | Freelance | ------------------------------------ 这样的一组数据在一张数据表中被称之为记录，记录是由多个字段信息所构成的。 这样不管有多少条记录，我们都能够知道其真正的含义了。 姓名：杰克 性别：男 年龄：18 职业：自由职业 数据的组织形式多种多样，除开以上述表格的形式进行组织，也有其他的组织方式，如键值对： [ [姓名]：{ 年龄:18 性别：男 职业：自由职业 }, ] 数据库 数据库的英文称呼为DATA BASE，简称为DB。 早期的时候由于没有操作系统，数据都是放在一些外部存储设备中，如磁带，纸片等，一个程序对应一个数据集，由人工进行管理，效率十分低下。 后来渐渐的进入文件系统管理阶段，可以简单理解为将不同应用程序的数据放在不同的Excel数据表中，多个程序之间拥有的相同数据也不能放入同一张表而必须相互独立进行存放，这使得数据的冗余度极大，管理也不太方便，同时拥有一个最致命的问题就是不支持并发控制，别人打开的表格你只能看不能编辑。 到了现在已经进入了数据系统管理阶段，数据必须由DBMS进行管理，在共享性，并发性，扩展性，维护性上都有了非常好的支持。 数据库管理系统 DBMS是数据库管理系统的简称，全称为DataBase Management System，它可以极为方便的管理非常多的数据库，目前常见的数据库管理系统软件有MySQL、Oracle、SQLite、Access、SQLServer等等。 点我查看热门数据库排行榜 在数据库管理系统软件中，又分为两大派系，分别是关系型和非关系型。 1）关系型数据库管理系统软件（RDBMS）： 特点：有表结构，数据存储于硬盘之中，查询数据需要经过SQL层对语句的解析 代表软件：Sqllite，DB2，Oracle，Access，SQLServer，MySQL（SQL语句通用） 2）非关系型数据库管理系统软件（NoSQL）： 特点：使用key-value等方式进行存储，无表结构，数据存储于缓存之中，可存储任意类型的数据 代表软件：Redis、MongoDB、Memcache、Elasticsearch NewSQL 早期企业项目中单纯的使用RDBMS即可完成需求。 后来慢慢的需要RDBMS+NoSQL才行，因为业务规模和用户访问并发量都在不断的进行扩大。 但是到了现在，随着分布式微服务等概念的兴起，全新的解决方案NewSQL必是未来的大势所趋。 NewSQL是对各种新的可扩展/高性能数据库的简称，这类数据库不仅具有NoSQL对海量数据的存储管理能力，还保持了传统数据库支持ACID和SQL等特性。 常见数据库产品 以下是一些常见的数据产品。 1）RDBMS 关系型数据库管理系统软件： Oracle、MySQL、PG、MSSQL 2）NoSQL 非关系型数据库管理系统软件： MongoDB 、Redis 、Elasticsearch 3）NewSQL 新型的分布式解决方案： TiDB、Spanner、AliSQL(RDS+DRDS)、OB、PolarDB OLTP和OLAP概念 OLAP数据库通常称为数据仓库。它们用于存储供商业智能业务统计和分析历史记录。OLAP 数据库侧重于只读工作负载，其中包括用于批处理的即席查询。OLAP 数据库的查询用户数相对较少，通常情况下只有企业员工可以访问历史记录。 OLTP数据库用于高度并发的事务数据处理场景，该场景的特点是实时用户提交预定义的短时查询。事务处理的一个简单例子，就是普通用户在电子商务网站上搜索并购买商品。相对于 OLAP 用户，尽管 OLTP 用户访问的数据集规模很小，但是用户的数量要庞大很多，并且查询中可以包括读操作和写操作。OLTP 数据库主要考虑的是高可用性、并发性和性能。 一句话总结：OLAP更倾向于后台、内部人员使用，并发量少，而OLTP更倾向于前台、面向广大用户使用，并发量高。 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:48 "},"数据库专栏/MySQL/基础学习.html":{"url":"数据库专栏/MySQL/基础学习.html","title":"基础学习","keywords":"","body":"MySQL简介 MySQL是当下最流行的关系型数据库管理系统软件之一，它由MySQL AB公司进行开发，目前隶属于甲骨文（Oracle）公司旗下。 学习一款RDBMS是非常划算的，由于所有的RDBMS中的SQL语句都是通用的，所以在学习完MySQL之后再去学习其他的RDBMS时整个学习过程会轻松很多。 MySQL版本 MySQL版本丰富，当下主流版本是5.6、5.7、8.0，鉴于目前8.0的应用还不是那么广泛，所以我们以5.7为主展开后面的学习，具体版本号是5.7.34，也是目前8版本以下最新的一版。 以下是MySQL各个版本的发行日期与发行特征，版本编号中的GA代表稳定版本： Feature MySQL Series First release 3.11.1（1996） MySQL AB Query Cache, Unions, Full-text, InnoDB 4.0 （2003-03） Subqueries, R-trees 4.1 （2004-10） Stored Routies, Views, Cursors, Triggers, XA Transactions, I_S 5.0 （2005-10） Event scheduler, Patitioning, Plugin API, RBR, InnoDB Plugin, MySQL Cluster 5.1 （2008-11） SUN Dtrace support, Semisync-replication, P_S, Supplementary Unicode characters 5.5 GA版本5.5.8 （2010-12-03）Oracle Online-DDL, GTID, Parallel Replication, ICP, MRR ...etc... 5.6 GA版本5.6.10（2013-02-05） InnoDB Cluster、JSON、Boost.Geometry… 5.7 （2013-02） GA版本5.7.10 （2015-12-07） Invisible Index、JSON Partial Updates、NOWAIT、SKIP LOCKED、Window Function… 8.0.0 （2016-09-12） 下载安装 软件下载 打开Chorme浏览器，进入官网找到需要下载的版本，直接选择Linux通用版即可： 复制下载链接，而后使用wget命令进行下载： $ cd ~ $ wget https://downloads.mysql.com/archives/get/p/23/file/mysql-5.7.34-linux-glibc2.12-x86_64.tar.gz 配置目录 现在我们需要创建3个目录来存放mysqld.service服务所产生的不同数据： $ mkdir -p /db/mysql57/3306/{data,logs} 这个目录路径还是有一些需要说明的地方： mysql57：表示MySQL的版本信息 3306：表示MySQL的端口号 data：存放MySQL服务产生的数据文件 logs：存放MySQL服务产生的日志文件 Tar.gz安装 下载完成之后，执行以下命令进行解压操作： $ tar -xvf ./mysql-5.7.34-linux-glibc2.12-x86_64.tar.gz -C /db/mysql57/3306/ 将解压出来的目录进行重命名： $ mv /db/mysql57/3306/mysql-5.7.34-linux-glibc2.12-x86_64/ /db/mysql57/3306/mysql 环境变量 接下来需要设置环境变量，打开下面的文件： $ vim /etc/profile 写入的内容如下： export PATH=/db/mysql57/3306/mysql/bin:$PATH 记得刷新配置： $ source /etc/profile 输入以下命令，若显示版本信息则代表配置成功： $ mysql -V mysql Ver 14.14 Distrib 5.7.34, for linux-glibc2.12 (x86_64) using EditLine wrapper 用户授权 MySQL应当由单独的用户组与用户进行管理，一般情况下该用户组与用户名字都是mysql。 在创建之前，先查看系统上是否存在该用户，如果不存在再进行手动创建也不迟： $ id mysql $ groupadd mysql $ useradd -g mysql mysql 我们需要对该用户进行目录授权操作，命令如下： $ chown -R mysql:mysql /db/mysql57/ 配置文件 使用配置文件可以对mysqld.service服务启动后的初始化参数进行配置，首先我们需要输入以下命令打开配置文件： $ vim /etc/my.cnf 填入以下内容： [mysqld] user=mysql # mysql用户配置 server_id=3306 # 当前mysql服务的ID号，适用于多实例mysql服务 port=3306 # 当前mysql服务的端口号 basedir=/db/mysql57/3306/mysql # 当前mysql服务软件目录 datadir=/db/mysql57/3306/data # 当前mysql服务的数据存放目录 log_error=/db/mysql57/3306/logs/mysqld.log # 当前mysql服务中运行日志存放目录及日志名称 socket=/tmp/mysql.sock # socket连接时的文件，仅供本地登录时使用 character-set-server=utf8mb4 # 当前mysql服务所使用的字符集为utf8mb4 collation-server=utf8mb4_general_ci # 当前mysql服务所使用的校对规则为utf8mb4_general_ci default-storage-engine=INNODB # 当前mysql服务创建新表时将使用的默认存储引擎为InnoDB [mysql] default-character-set=utf8mb4 # 设置mysql客户端链接当前mysql服务时所使用的字符集为utf8mb4 socket=/tmp/mysql.sock # socket连接时的文件，仅供本地登录使用 prompt=\"> \" # 设置mysql客户端链接当前mysql服务器时在命令行交互界面所展示的提示符 [client] port=3306 # 设置mysql客户端连接当前mysql服务端时默认使用的端口 初始化 我们在开启MySQL服务之前，需要进行一次初始化工作，以便让MySQL生成一些内置的库、表。 初始化的命令有两条： —-initialize # 常规初始化 --initialize-insecure # 免密初始化 常规初始化相较于免密初始化来说会有一些其他额外的功能： 为root@localhost用户设置临时密码，可在MySQL运行日志中查看，它位于/db/mysql57/3306/logs/mysqld.log之中 对密码复杂度进行定制，规定其root的登录密码必须为12位，必须具有4种格式（必须拥有大写字符，小写字符，数字，特殊字符） 临时密码过期时间为180s 在这里，我们采用免密初始化即可： $ mysqld --initialize-insecure sys服务 现在只是初始化完成，但是还没有将mysqld加入systemctl系统服务管控中，也就无法开启服务。 所以现在我们需要对mysqld制作成系统服务，输入以下命令： $ cat >/etc/systemd/system/mysqld.service 接下来我们需要将mysqld.service服务进行启动，并且将它设置为开启自运行： $ systemctl start mysqld.service $ systemctl enable mysqld.service 尝试登录MySQL服务端： $ mysql -uroot >exit 初始密码 如果你使用免密初始化后想为root用户生成一个密码，可在终端中输入如下命令： $ mysqladmin -uroot password \"密码\" 同时，它也支持修改root密码，但是你必须位于这台MySQL服务器之上才能执行这条命令。 $ mysqladmin -uroo -p\"旧密码\" password \"新密码\"; 常见错误 例举一些常见的错误： 错误1： .. ERROR! The server quit without updating PID file (...). 这个错误可能是因为你的系统上已经有mysqld.service服务启动了，导致了端口占用，你需要kill掉旧的mysqld.service服务： $ ps aux | grep 3306 $ kill PID 错误2： Can 't connect to local MySQL server through socket /tmp/mysql.sock 这个错误可能是因为你的系统上用于root用户本地登录的sock文件被删除，一般来说重启mysqld.service服务即可： $ pkill mysql* $ systemctl start mysqld.service 除此之外，你也可以使用TCP/IP协议进行登录： $ mysql -uroot -p密码 --protocol tcp -h地址 -P端口号 其他的错误可能是由配置文件导致的，检查配置文件是否是/etc/my.cnf，不要把路径配置错了。 登录相关 登录方式 MySQL是一个C/S架构的软件，可以在本地通过socket文件进行登录，也可在远端使用TCP/IP协议进行登录。 整个MySQL由2部分组成，其一是Client端（mysql命令）、其二是Server端（mysqld命令），一般来说登录本地的Server端时我们都会采用mysql.sock文件进行，而登录远程的Server端时我们都会采用TCP/IP协议进行。 以下是2种登录方式的书写： # mysql.sock文件登录 $ mysql -u用户名 -p密码 -S /tmp/mysql.sock # TCP/IP协议登录 $ mysql -u用户名 -p密码 -h地址 -P端口号 登录参数 以下例举一些常用的登录参数项： -h：MySQL服务器的IP地址 -P：MySQL服务器的端口号，默认为3306 -u：登录MySQL服务器的用户名 -p：登录MySQL服务器的用户密码 -e：只执行一段命令、但是不进入MySQL交互界面 使用参数e的案例，导出某些查询的内容： $ mysql -uroot -e\"SHOW DATABASES\" > /tmp/data $ cat /tmp/data Database information_schema mysql performance_schema sys 使用参数 $ mysql -uroot 关于如何导出SQL语句，在后面的章节中会有一些详细的介绍。 用户权限 基础概念 在MySQL中，我们可以使用root用户创建出一些新的子用户并为它们分配一些权限。 如新的子用户可以被限定为只对某个库或者某张表具有某些权限，其中包括增权限、删权限、改权限、查权限。 打个比方，一个开发部门可能公用一个数据库，而各个开发小组的组长包括成员在内只能查看或编辑自身业务范围之内的记录，这种需求下就需要使用到用户管理与权限管理。 系统库表 用户与权限相关的信息都被存放在内置库mysql中，下面是基础的权限4表： 表名 描述 user 针对所有数据库，所有库下所有表，以及表下的所有字段 db 针对某一数据库，该数据库下的所有表，以及表下的所有字段 tables_priv 针对某一张表，以及该表下的所有字段 columns_priv 针对某一个字段 用户管理 用户管理需要使用root账号来进行，其根本就是在对mysql.user表做修改。 以下是创建用户的示例，注意用户创建完成后需要使用FLUSH PRIVILEGES命令将内存中的数据刷写到磁盘： # 创建名为Jack的用户、允许该用户从本机进行登录 > CREATE USER \"Jack\"@\"localhost\" IDENTIFIED BY \"123\"; # 创建名为Tom的用户、允许该用户从任意地址进行登录 > CREATE USER \"Tom\"@\"%\" IDENTIFIED BY \"123\"; # 创建名为Ken的用户、允许该用户从192.168.1.10进行登录 > CREATE USER \"Ken\"@\"192.168.1.10\" IDENTIFIED BY \"123\"; # 创建名为MARY的用户、允许该用户从从192.168.1.xxx的网段进行登录 > CREATE USER \"Mary\"@\"192.168.1.%\" IDENTIFIED BY \"123\"; # 将内存中的数据刷写到磁盘 > FLUSH PRIVILEGES; # 注意：%代表通配符，与RegExp中的.效果相同 以下是查询用户的示例： # 查询当前登录用户 > SELECT user(); # 查询所有用户 > SELECT user, host FROM mysql.user; 以下是修改用户的示例： # 修改用户允许登录的地址，将Jack修改为只允许本地登录 > UPDATE mysql.user SET host=\"%\" WHERE user=\"Jack\" AND host=\"localhost\"; # 修改任意用户的密码（仅MySQL5.7可用，8.0已废弃password()函数，故不可用） > UPDATE mysql.user SET authentication_string=password(\"456\") WHERE user=\"root\" AND host=\"localhost\"; # 修改普通用户的密码 > ALTER USER \"Jack\"@\"%\" IDENTIFIED BY \"456\"; # 修改root用户的密码 > ALTER USER \"root\"@\"localhost\" IDENTIFIED WITH mysql_native_password BY \"123\"; # 将内存中的数据刷写到磁盘 > FLUSH PRIVILEGES; 以下是删除某个用户的示例： # 推荐方式 > DROP USER \"Jack\"@\"%\"; # 直接对mysql.user表做操作 > DELETE FROM mysql.user WHERE user=\"Tom\" AND host=\"%\"; # 将内存中的数据刷写到磁盘 > FLUSH PRIVILEGES; 权限管理 权限管理需要使用root账号来进行，下面的所有命令其本质上都是对权限4表做操作。 以下是分配权限的示例： # 为Jack分配所有权限 > GRANT all ON *.* TO \"Jack\"@\"%\"; # 为Tom分配db1数据库下的所有数据表的所有权限 > GRANT all ON db1.* TO \"Tom\"@\"%\"; # 为Ken分配db1数据库下的所有数据表的查看权限 > GRANT select ON db1.* TO \"Ken\"@\"192.168.1.10\"; # 为Mary分配db1数据库下的student数据表的查看id、name、age字段与更新name字段的权限 > GRANT select(id,name,age), update(name) ON db1.student TO \"Mary\"@\"192.168.1.%\"; # 将内存中的数据刷写到磁盘 > FLUSH PRIVILEGES; 以下是查看用户权限的示例： > SHOW GRANTS FOR \"Jack\"@\"%\"\\G; > SHOW GRANTS FOR \"Tom\"@\"%\"\\G; > SHOW GRANTS FOR \"Ken\"@\"192.168.1.10\"\\G; > SHOW GRANTS FOR \"Mary\"@\"192.168.1.%\"\\G; 以下是释放用户权限的示例： # 释放掉Jack在所有库表中的删除记录权限 > REVOKE delete ON *.* FROM \"Jack\"@\"%\"; # 将内存中的数据刷写到磁盘 > FLUSH PRIVILEGES; 忘记密码 用户在登录MySQL服务端时，MySQL服务端内部将会通过user表对本次登录进行验证，如果你忘记了root密码则可通过以下方式手动绕过这个验证并且重置root密码。 1）关闭需要授权登录的MySQL服务端： $ systemctl stop mysqld.service 2）开启mysql_safe免授权登录的服务端，并且暂时的禁止远端登录： $ mysqld_safe --skip-grant-tables --skip-networking 3）打开新终端，使用root用户进行登录，并且清空旧的密码： $ mysql -uroot -S /tmp/mysql.sock > UPDATE mysql.user SET authentication_string=\"\" WHERE user=\"root\"; > FLUSH PRIVILEGES; > exit; 4）关闭免授权、关闭禁止远端访问的mysqld_safe服务进程： $ ps -ef | grep mysql $ kill -9 mysql_safe_PID 5）开启正常的mysqld.service服务，尝试登录 $ systemctl start mysqld.service $ mysql -uroot -S /tmp/mysql.sock 三层架构 架构图示 我们知道MySQL是通过SQL语句进行操作的，其实当一个Client端链接到Server端后并提交SQL命令的过程可分为三个环节。 如下图所示： 链接层 链接层的主要作用有以下3点： 提供链接协议，如socket与TCP/IP 验证用户名及密码的合法性，对登录用户匹配专门的授权表 派生出一个专用的链接线程，用于接收SQL命令并返回执行结果 SQL层 SQL层主要作用于调优方面的工作，也是DBA极其需要关注的一层，主要作用如下所示： 验证SQL语法与sql_mode 验证语义 验证权限 进入解析器进行语句解析，生成多个执行计划（解析树） 进入优化器（各种算法，基于执行代价），根据算法，找到代价最低的执行计划（代价：CPU IO MEM） 执行器按照优化器选择的执行计划，执行SQL语句，得出获取数据的方法 提供查询缓存（默认关闭，8.0被移除） 记录操作日志binlog（默认关闭，8.0默认开启） 存储层 存储层依靠存储引擎与磁盘打交道，与Linux上文件系统的概念相似，其功能是对磁盘上的数据进行存取。 根据SQL层所提供的取数据的方法，拿到数据，返回给SQL层将其结构化成表，再由链接层线程返回给用户。 在后续章节InnoDB存储引擎中，将会详细介绍这一过程。 存储结构 逻辑存储结构 MySQL逻辑存储结构是按照库表进行存储，并且每个表中还具有字段（列），字段属性，数据行（记录），表属性（元数据，如字符编码校对规则等）等信息。 物理存储结构 对于MySQL中的一个库来说，实际上就是一个目录。 如下所示，我创建一个db1的库： > CREATE DATABASE db1; 在数据根目录中就能看到这样的一个以库名命名的目录： $ ll /db/mysql57/3306/data | grep db1; drwxr-x---. 2 mysql mysql 58 10月 15 10:40 db1 对于MySQL中的一个表来说，就需要涉及到存储引擎，因为不同的存储引擎对表的物理存储结构也有所不同。 在MyISAM存储引擎中，表的物理结构如下： 使用tableName.frm文件存储表结构，如字段，字段属性等 使用tableName.MYD存储表的记录 使用tableName.MYI存储表的索引 在InnoDB存储引擎中，表的物理结构如下： 使用tableName.frm文件存储单张表的表结构，如字段，字段属性等 使用tableName.ibd存储单张表的表的记录以及索引信息等 使用ibdata1文件存储每一张表的元信息等属性，如字符编码、校对规则、统计信息等 开发工具 Nvaicat 推荐使用navicat来操纵你的数据库，它提供了一系列的可视化操作。 注意，如果你的数据库是部署在虚拟机或者云平台中，则需要关闭防火墙后方能使用navicat进行链接： $ systemctl stop firewalld $ systemctl disable firewalld 同时，你需要创建一个允许远端登录的用户，以便于nvaicat链接mysqld服务，我这里直接将root用户修改成了允许远端登录： > UPDATE mysql.user SET host=\"%\" WHERE user=\"root\" AND host=\"localhost\"; 打开navicat，在左上角选择链接后填入链接信息即可操纵MySQL数据库。 SQLTools 如果你使用vscode来进行开发，那么SQLTools将是个不错的选择。 首先你需要在插件商店搜索并安装它，其次就链接数据库即可： Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:48 "},"数据库专栏/MySQL/语法相关.html":{"url":"数据库专栏/MySQL/语法相关.html","title":"语法相关","keywords":"","body":"内置命令 掌握一些常用的内置命令，让你使用MySQL更加得心应手： 命令 快捷键 描述 help 获得帮助信息 \\G 将一行记录竖着显示，常用于字段较多的数据展示 source 导入sql文件、恢复备份时使用，等同于在交互界面外使用 \\c ctrl+c 终止当前命令 \\q ctrl+d 退出交互界面、等同于exit;或者quit;命令 source恢复文件案例： # 选定数据库 > USE db1; # 选定sql文件，进行恢复 > SOURCE /tmp/backup.sql 注释语句 使用--可对SQL命令进行注释： > -- this is a comment > SHOW DATABASES; 语法规范 MySQL中的命令实际上是不区分大小写的，但是为了后期方便阅读所以建议各位在输入命令时将特定的单词书写成大写，将可变的单词书写为小写。 如查询所有的用户，其中，SELECT以及FROM都是固定不变的单词，而user、host等都是查询的字段是可变的： > SELECT user,host FROM mysql.user; DDL DDL（Data Definition Language ）译为数据库定义语言，用于定义或修改数据库的结构，它不会对数据本身做出任何操作。 DDL不需要COMMIT操作，以下是一些常见的DDL语句： CREATE：用于创建数据库或其对象（如表、索引、函数、视图、存储过程和触发器）。 DROP：用于从数据库中删除对象。 ALTER：用于更改数据库的结构。 TRUNCATE：用于从表中删除所有记录，包括删除为记录分配的所有空间。 COMMENT：用于向数据字典添加注释。 RENAME：用于重命名数据库中存在的对象。 DML DML（Data Manipulation Language ）译为数据库操纵语言，主要提供对数据做出增删改的功能。 DML需要COMMIT操作，以下是一些常见的DML语句： INSERT：用于向表中插入数据 UPDATE：用于更新表中的现有数据 DELETE：用于从数据库表中删除记录 LOCK：用于数据表控制并发。 CALL：用于调用 PL/SQL 或 JAVA 子程序 EXPLAIN PLAN：描用于述数据的访问路径 DQL DQL（Data Query Language）译为数据库查询语言，提供给用户从数据库中查询出数据的能力。 DQL不需要COMMIT操作，以下是常见的DQL语句： SELECT：用于从数据库中检索数据 DCL DCL（Data Control Language）译为数据库控制语言，DCL是面向数据库管理人员使用的，它提供了用户授权，角色控制等功能。 DCL不需要COMMIT操作，以下是常见的DCL语句： GRANT：授予用户对数据库的访问权限 REVOKE：撤销使用GRANT命令赋予的用户访问权限 TCL TCL（Transaction Control Language）译为事务控制语言，它提供了一系列事务操纵语句，如： COMMIT：提交事务 ROLLBACK：回滚事务 SAVEPOINT：在事务中设置保存点 SET TRANSACTION：指定交易的特征 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:48 "},"数据库专栏/MySQL/配置相关.html":{"url":"数据库专栏/MySQL/配置相关.html","title":"配置相关","keywords":"","body":"字符集相关 字符集简介 在MySQL中，字符串分为2进制和非2进制两种类型。 2进制用于存储图片、声音等媒体文件 非2进制则用于存储文本数据 非2进制类型的字符串会受到字符集和校对规则的影响。 而字符集说白了其实就是字符编码。 查看字符集 在MySQL中拥有多种字符集，如果MySQL版本小于8则默认字符集是latin1，而MySQL8则变成了utf8mb4。 查看当前的MySQL版本支持的字符集可使用以下命令： > SHOW CHARSET; 查看当前的MySQL服务所使用的字符集可使用以下命令： > SHOW variables LIKE 'character%'; +--------------------------+----------------------------------------+ | Variable_name | Value | +--------------------------+----------------------------------------+ | character_set_client | utf8mb4 | | character_set_connection | utf8mb4 | | character_set_database | utf8mb4 | | character_set_filesystem | binary | | character_set_results | utf8mb4 | | character_set_server | utf8mb4 | | character_set_system | utf8 | | character_sets_dir | /db/mysql57/3306/mysql/share/charsets/ | +--------------------------+----------------------------------------+ 设置字符集 字段不设置字符集继承表的字符集，表不设置字符集继承数据库的字符集，所以一般我们在配置文件中为数据库指定字符集即可： [mysqld] character-set-server=utf8mb4 [client] default-character-set=utf8mb4 [mysql] default-character-set=utf8mb4 utf8与utf8mb4 MySQL中utf8和utf8mb4的区别： utf8：单个字符最大支持占3个字节，不支持emoji表情 utf8mb4：单个字符最大支持占4个字节，支持emoji表情，是utf8的超集 实际上无论是utf8还是utf8mb4，都不是真正意义上的utf8，因为真正的utf8最大支持6字节的宽字符。 校对规则 校对规则简介 每一套字符集都有多种校对规则，校对规则其实是字符之间对比、排序的一种标准。 以_ci结束的校对规则不区分大小写 以_cs结束的校对规则区分大小写 以_bin结束的校对规则会比对字符的二进制元信息，可以理解为区分大小写 当使用以_ci结束的校对规则时，A和a是相同的，这会影响到排序和比对。 查看校对规则 查看当前的MySQL版本支持的校对规则可使用以下命令： > SHOW COLLATION; 查看当前的MySQL服务所使用的校对规则可使用以下命令： > SHOW variables LIKE \"collation_%\"; +----------------------+--------------------+ | Variable_name | Value | +----------------------+--------------------+ | collation_connection | utf8mb4_general_ci | | collation_database | utf8mb4_general_ci | | collation_server | utf8mb4_general_ci | +----------------------+--------------------+ 设置校对规则 修改表的校对规则时，对表的原字段没有任何影响，它只会影响新增的字段。 下面2个校对规则是会被经常使用到的： utf8mb4_general_ci # 不区分大小写 utf8mb4_bin # 区分大小写 设置校对规则一般都是在配置文件中直接进行配置，如下所示： [mysqld] collation-server=utf8mb4_general_ci 配置项 配置级别 MySQL的配置有3种级别，如下所示： 会话（SESSION）级别的配置，配置完成后立即生效，关闭当前会话窗口失效 全局（GLOBAL）级别的配置，配置完后立即生效，当前mysqld.service服务重启后失效 文件（FILE）级别的配置，配置完成后需要重启当前mysqld.service服务才能生效，配置永不失效 SESSION SESSION级别配置示例、配置数据库的字符集： > SET CHARACTER_SET_DATABASE=utf8mb4; GLOBAL GLOBAL级别配置示例、配置数据库的字符集： > SET GLOBAL CHARACTER_SET_DATABASE=utf8mb4; 配置文件 MySQL配置文件一般存放在/etc目录中，其名为my.cnf或者my.ini。 它是由XML格式的内容所组成的，整个配置文件中有7个配置类别（常见的），我们可以在这7个类别下用键值对的方式进行详细配置，如下所示： # 服务端配置： [mysqld] [mysqld_safe] [server] # 客户端配置： [mysql] [client] [mysqladmin] [mysqldump] 一般有3个配置类别是会被经常使用的： mysqld：服务端的配置项 client：全局的客户端配置项，即不管是使用sock文件链接登录还是TCP/IP协议链接登录的客户端，都会使用这下面的配置项 mysql：单一的客户端配置项，即只有通过sock文件链接登录的客户端才使用这里面的配置项，当没有[client]时以该配置项为准 以下是一个配置文件的基本定义模板： [mysqld] user=mysql # mysql用户配置 server_id=3306 # 当前mysql服务的ID号，适用于多实例mysql服务 port=3306 # 当前mysql服务的端口号 basedir=/db/mysql57/3306/mysql # 当前mysql服务软件目录 datadir=/db/mysql57/3306/data # 当前mysql服务的数据存放目录 log_error=/db/mysql57/3306/logs/mysqld.log # 当前mysql服务中运行日志存放目录及日志名称 # slow_query_log=1 # 当前mysql服务查询日志已被打开 # long_query_time=0.1 # 设定慢语句记录时间 # slow_query_log_file=/db/mysql57/3306/logs/slow.log # 当前mysql服务的慢日志存放目录及日志名称 # log_queries_not_using_indexes # 没走索引的语句也记录 # log_bin=/db/mysql57/3306/logs/mysql_bin # 当前mysql服务共享表空间文件数量与扩容机制 # innodb_data_file_path=ibdata1:512M:ibdata2:512M:autoextend # 当第2个文件达到512m后，自动为其扩容64M # innodb_autoextend_increment=64 # 当前mysql服务开启自动COMMIT # AUTOCOMMIT = 1; # 当前mysql服务日志刷新策略，最高安全模式 # innodb_flush_log_at_trx_commit=1 # Innodb_flush_method=O_DIRECT # 当前mysql服务的事务隔离级别 # transaction-isolation=Read-Committed # 开启binlog，设定二进制日志存放目录及日志名称前缀 # binlog_format=row # mysql中二进制日志的格式化模式 [statement、row、mixed] # gtid-mode=on # 当前mysql服务的binlog记录GTID模式以被打开 # enforce-gtid-consistency=true # 当前mysql服务的GTID号必须是唯一的,即GTID幂等性约束已被打开 character-set-server=utf8mb4 # 当前mysql服务所使用的字符集为utf8mb4 collation-server=utf8mb4_general_ci # 当前mysql服务所使用的校对规则为utf8mb4_general_ci default-storage-engine=INNODB # 当前mysql服务创建新表时将使用的默认存储引擎为InnoDB socket=/tmp/mysql.sock # socket连接时的文件，仅供本地登录时使用 [mysql] port=3306 # 设置mysql客户端连接当前mysql服务端时默认使用的端口 default-character-set=utf8mb4 # 设置mysql客户端链接当前mysql服务时所使用的字符集为utf8mb4 socket=/tmp/mysql.sock # socket连接时的文件，仅供本地登录使用 prompt=\"> \" # 设置mysql客户端链接当前mysql服务器时在命令行交互界面所展示的提示符 [client] port=3306 # 设置mysql客户端连接当前mysql服务端时默认使用的端口 default-character-set=utf8mb4 # 设置mysql客户端链接当前mysql服务时所使用的字符集为utf8mb4 加载顺序 配置文件在不同位置可以拥有多个，使用以下命令来查看mysqld.service服务启动时加载的配置文件顺序： $ mysqld --help --verbose | grep \"my.cnf\" /etc/my.cnf /etc/mysql/my.cnf /usr/local/mysql/etc/my.cnf ~/.my.cnf 你可以对不同的启动服务指定不同的配置文件，如对mysqld_safe服务启动时，采用全新的配置文件进行配置： $ mysqld_safe --defaults-file=/tmp/mysql_safe.ini 配置查看 基础语法 通过以下2个基础语句，可查看当前已配置的某个或某些配置项： # 精确查看某一配置项 $ SELECT @@配置项名称; # 模糊的查看所有带有该词条的配置项，使用%来代表匹配所有字符，_匹配一个或多个 $ SHOW variables LIKE \"%配置项名称%\"; 示例演示，精确的查看某一条配置项： > SELECT @@COLLATION_CONNECTION; +------------------------+ | @@COLLATION_CONNECTION | +------------------------+ | utf8mb4_general_ci | +------------------------+ 1 row in set (0.00 sec) 示例演示，模糊的查看某一些配置项： > SHOW variables LIKE \"%COLLATION_%\"; +----------------------+--------------------+ | Variable_name | Value | +----------------------+--------------------+ | collation_connection | utf8mb4_general_ci | | collation_database | utf8mb4_general_ci | | collation_server | utf8mb4_general_ci | +----------------------+--------------------+ 3 rows in set (0.01 sec) SHOW系列 单独的使用SHOW语句，你可以查看下面这些配置项： SHOW语句 描述 show databases; 查看数据库名 show tables; 查看表名 show create database 库名; 查看建库语句 show create table 表名; 查看建表语句 show processlist; 查看所有用户连接情况 show charset; 查看支持的字符集 show collation; 查看所有支持的校对规则 show grants for \"用户\"@\"允许登录的地址\"; 查看用户的权限信息 show variables like \"%指定参数%\"; 查看当前使用的某个参数信息 show engines; 查看所有支持的存储引擎类型 show index from 表名; 查看表的索引信息 show engine innodb status\\G; 查看innoDB引擎详细状态信息 show binlog events in \"指定参数\"; 查看二进制日志的事件信息 show master status; 查看mysql当前使用二进制日志信息 show slave status\\G; 查看从库状态信息 show relaylog events in \"指定参数\"; 查看中继日志的事件信息 show status like \"指定参数\"; 查看数据库整体状态信息 SELECT系列 单独的使用SELECT语句，你可以查看下面这些配置项： SELECT语句 描述 select @@basedir; 查看软件服务相关文件存放目录（安装目录） select @@datadir; 查看数据相关文件存放目录 select @@port; 查看当前实例端口号 select @@innodb_flush_log_at_trx_commit; 查看事务提交刷新策略 select database(); 查看当前所在的数据库 select user(); 查看当前所登录的用户 select now(); 查看当前时间 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:48 "},"数据库专栏/MySQL/库相关操作.html":{"url":"数据库专栏/MySQL/库相关操作.html","title":"库相关操作","keywords":"","body":"系统内置库 MySQL在初始化命令完成之后会自动创建一些系统库，不同的系统库有不同的用途： information_schema：虚拟库，不占用磁盘空间，存储的是数据库启动后的一些参数，如用户表信息、列信息、权限信息、字符信息等 mysql：授权库，主要存储系统用户的权限信息 performance_schema：mysql5.5后开始新增的一个数据库，主要用于收集数据库服务器性能参数，记录处理查询请求时发生的各种事件、锁等现象 sys：mysql5.7后开始新增的一个数据库，主要存放存储过程、视图、函数等数据 test：mysql数据库系统自动创建的测试数据库（只有包含测试套件的版本才拥有此库） 由于我没有下载测试版本，所以只能看见4个库： > SHOW DATABASES; +--------------------+ | Database | +--------------------+ | information_schema | | mysql | | performance_schema | | sys | +--------------------+ 4 rows in set (0.00 sec) 创建数据库 语法介绍： CREATE DATABASE 数据库名 CHARSET 字符集 COLLATE 校对规则; 示例演示： > CREATE DATABASE db1 CHARSET utf8mb4 COLLATE utf8mb4_general_ci; Query OK, 1 row affected (0.00 sec) 以下是创建数据库的一些行为规范： 库名使用小写字符 库名不能以数字开头 库名不能是数据库内部的关键字 必须设置字符集，可省略校对规则的设置 进入数据库 使用以下命令即可进入某一个数据库之中： USE 数据库名; 示例演示： > USE db1; Database changed > SELECT DATABASE(); +------------+ | DATABASE() | +------------+ | db1 | +------------+ 1 row in set (0.00 sec) 查看数据库 查看数据库，3个基本命令： # 查看所有数据库 SHOW DATABASES; # 查看当前所在的数据库 SELECT DATABASE(); # 查看数据库创建信息 SHOW CREATE DATABASE 数据库名; 示例演示： > SHOW DATABASES; +--------------------+ | Database | +--------------------+ | information_schema | | db1 | | mysql | | performance_schema | | sys | +--------------------+ 5 rows in set (0.00 sec) > SELECT DATABASE(); +------------+ | DATABASE() | +------------+ | db1 | +------------+ 1 row in set (0.00 sec) > SHOW CREATE DATABASE db1; +----------+-----------------------------------------------------------------+ | Database | Create Database | +----------+-----------------------------------------------------------------+ | db1 | CREATE DATABASE `db1` /*!40100 DEFAULT CHARACTER SET utf8mb4 */ | +----------+-----------------------------------------------------------------+ 1 row in set (0.00 sec) 修改数据库 修改数据库一般只针对数据库字符集、数据库校对规则： # 修改某一数据库的字符集 ALTER DATABASE 数据库名 CHARSET 字符集; # 修改某一数据库的校对规则 ALTER DATABASE 数据库名 COLLATE 校对规则; 示例演示： > ALTER DATABASE db1 CHARSET utf8mb4; Query OK, 1 row affected (0.00 sec) > ALTER DATABASE db1 COLLATE utf8mb4_general_ci; Query OK, 1 row affected (0.00 sec) 删除数据库 删除数据库在生产中属于禁用操作，仅做了解即可： # 删除某个数据库，当不存在时抛出异常 DROP DATABASE 数据库名; # 删除某个数据库，当该数据库存在时生效，若不存在也不会抛出异常 DROP DATABASE IF EXISTS 数据库名; 示例演示： > DROP DATABASE IF EXISTS db2; Query OK, 0 rows affected, 1 warning (0.00 sec) > DROP DATABASE db2; ERROR 1008 (HY000): Can't drop database 'db2'; database doesn't exist Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:48 "},"数据库专栏/MySQL/表相关操作.html":{"url":"数据库专栏/MySQL/表相关操作.html","title":"表相关操作","keywords":"","body":"表的基本组成 每一张数据表可以粗略的理解为一个表格文件，而这张数据表又由3大部分组成： 表结构：字段、字段约束等信息 表记录：数据表中的每一行数据（不包含字段行） 元信息：字符编码、校对规则、存储引擎等信息 如下图所示： 表本身操作 创建数据表 语法介绍： CREATE TABLE 库名.表名( 字段名1 类型(宽度) 约束条件1, 约束条件2... COMMENT \"字段描述信息\", 字段名2 类型(宽度) 约束条件1, 约束条件2... COMMENT \"字段描述信息\" ) ENGINE 存储引擎 CHARSET 字符编码 COLLATE 校对规则; 示例演示： CREATE TABLE db1.students ( id INT PRIMARY KEY AUTO_INCREMENT COMMENT \"主键\", name CHAR(32) NOT NULL COMMENT \"姓名\", age TINYINT UNSIGNED NOT NULL DEFAULT 0 COMMENT \"年龄\", gender ENUM(\"male\", \"female\", \"unknow\") NOT NULL DEFAULT \"unknow\" COMMENT \"性别\", create_time DATETIME NOT NULL DEFAULT NOW() COMMENT \"创建时间\" ) ENGINE innodb CHARSET utf8mb4 COLLATE utf8mb4_general_ci; 以下是创建数据表的一些行为规范： 库名是可选项，如果不指定库名则你必须use到该库下 表名必须为小写字母，避免使用保留字符，不能使用数字开头，请使用和业务有关的表名 字段名是必须的，避免使用保留字符，且需要注意在同一张表中，字段名是不能重复的 字段类型是必须的，而字段的约束条件和类型宽度是可选的 主键字段是必须的，且尽量定义为与业务无关的数字列，最好是自增长的 enum类型不要保存数字，最好只保存字符串类型 尽量为每个字段设置 NOT NULL + DEFAULT 约束 ，对于数字类型请使用0进行填充，按照具体情况酌情应用 外键字段不设置NOT NULL，对于字符类的特殊字段如name等不设置DEFAULT，按照具体情况酌情应用 字段的描述信息是必须的，这有助于后期的维护工作 表中最后一个字段不要加逗号，新手可能会常常忽略这个问题 必须为表设置存储引擎与字符集，可以不设置校对规则，但是个人建议还是设置 查看数据表 查看数据表，3个基本命令： # 必须进入某个数据库后方可使用，查看该库下所有数据表 SHOW TABLES; # 查看表的创建信息，能够获取到表结构及元信息 SHOW CREATE TABLE 表名; # 查看表结构，仅能够获取到表结构 DESC 表名; 示例演示： > USE db1; Database changed > SHOW TABLES; +---------------+ | Tables_in_db1 | +---------------+ | students | +---------------+ 1 row in set (0.00 sec) > SHOW CREATE TABLE students\\G; *************************** 1. row *************************** Table: students Create Table: CREATE TABLE `students` ( `id` int(11) NOT NULL AUTO_INCREMENT COMMENT '主键', `name` char(32) NOT NULL COMMENT '姓名', `age` tinyint(3) unsigned NOT NULL DEFAULT '0' COMMENT '年龄', `gender` enum('male','female','unknow') NOT NULL DEFAULT 'unknow' COMMENT '性别', `create_time` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间', PRIMARY KEY (`id`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 1 row in set (0.00 sec) ERROR: No query specified > DESC students; +-------------+--------------------------------+------+-----+-------------------+----------------+ | Field | Type | Null | Key | Default | Extra | +-------------+--------------------------------+------+-----+-------------------+----------------+ | id | int(11) | NO | PRI | NULL | auto_increment | | name | char(32) | NO | | NULL | | | age | tinyint(3) unsigned | NO | | 0 | | | gender | enum('male','female','unknow') | NO | | unknow | | | create_time | datetime | NO | | CURRENT_TIMESTAMP | | +-------------+--------------------------------+------+-----+-------------------+----------------+ 5 rows in set (0.00 sec) 修改表名字 使用以下命令格式修改表名： ALTER TABLE 旧表名 RENAME 新表名; 示例演示： > ALTER TABLE students RENAME new_students; Query OK, 0 rows affected (0.01 sec) > SHOW TABLES; +---------------+ | Tables_in_db1 | +---------------+ | new_students | +---------------+ 1 row in set (0.00 sec) 清空数据表 使用以下命令可将表中所有记录清空，并且对部分结构进行重置，如自增字段会恢复至初始值： TRUNCATE 表名; 示例演示，注意观察自增ID、它将恢复从1开始排列： > INSERT INTO -> new_students(name, age, gender) -> VALUES -> (\"Jack\", 19, \"male\"), -> (\"Ken\", 22, \"male\"), -> (\"Mary\", 18, \"female\"); Query OK, 3 rows affected (0.01 sec) Records: 3 Duplicates: 0 Warnings: 0 > SELECT * FROM new_students; +----+------+-----+--------+---------------------+ | id | name | age | gender | create_time | +----+------+-----+--------+---------------------+ | 1 | Jack | 19 | male | 2021-10-17 02:40:58 | | 2 | Ken | 22 | male | 2021-10-17 02:40:58 | | 3 | Mary | 18 | female | 2021-10-17 02:40:58 | +----+------+-----+--------+---------------------+ 3 rows in set (0.00 sec) > TRUNCATE new_students; Query OK, 0 rows affected (0.01 sec) > INSERT INTO -> new_students(name, age, gender) -> VALUES -> (\"Anna\", 21, \"female\"); Query OK, 1 row affected (0.00 sec) > SELECT * FROM new_students; +----+------+-----+--------+---------------------+ | id | name | age | gender | create_time | +----+------+-----+--------+---------------------+ | 1 | Anna | 21 | female | 2021-10-17 02:42:07 | +----+------+-----+--------+---------------------+ 1 row in set (0.00 sec) 删除数据表 使用以下命令可删除某张数据表，但是删表是生产中的禁用操作，所以这里不再进行演示： DROP TABLE 表名; 或者： DROP TABLES 表1, 表2...; 表字段操作 新增字段 新增字段的3种语法格式： # 新增单个字段，排在最前面 ALTER TABLE 表名 ADD 新字段名 数据类型(宽度) 约束条件1, 约束条件2... COMMENT \"字段描述信息\" FIRST; # 新增单个字段，排在某个字段后面 ALTER TABLE 表名 ADD 新字段名 数据类型(宽度) 约束条件1, 约束条件2... COMMENT \"字段描述信息\" AFTER 旧字段名; # 新增多个字段，排在最后面 ALTER TABLE 表名 ADD 新字段名1 数据类型(宽度) 约束条件1, 约束条件2... COMMENT \"字段描述信息\", ADD 新字段名2 数据类型(宽度) 约束条件1, 约束条件2... COMMENT \"字段描述信息\"; 示例演示，先创建表： CREATE TABLE db1.test_table ( field2 CHAR(32) NOT NULL DEFAULT \"field2\" COMMENT \"字段2\", field3 CHAR(32) NOT NULL DEFAULT \"field3\" COMMENT \"字段3\" ) ENGINE innodb CHARSET utf8mb4 COLLATE utf8mb4_general_ci; 新增单个字段id，排在最前面： ALTER TABLE db1.test_table ADD id INT PRIMARY KEY AUTO_INCREMENT COMMENT \"主键\" FIRST; 新增单个字段field1，排在id字段后面： ALTER TABLE test_table ADD field1 CHAR(32) NOT NULL DEFAULT \"field1\" COMMENT \"字段1\" AFTER id; 新增多个字段field4、field5，排在最后面 ALTER TABLE test_table ADD field4 CHAR(32) NOT NULL DEFAULT \"field4\" COMMENT \"字段4\", ADD field5 CHAR(32) NOT NULL DEFAULT \"field5\" COMMENT \"字段5\"; 查看表结构： > DESC test_table; +--------+----------+------+-----+---------+----------------+ | Field | Type | Null | Key | Default | Extra | +--------+----------+------+-----+---------+----------------+ | id | int(11) | NO | PRI | NULL | auto_increment | | field1 | char(32) | NO | | field1 | | | field2 | char(32) | NO | | field2 | | | field3 | char(32) | NO | | field3 | | | field4 | char(32) | NO | | field4 | | | field5 | char(32) | NO | | field5 | | +--------+----------+------+-----+---------+----------------+ 6 rows in set (0.00 sec) 修改字段 修改字段的3种语法格式： # MODIFY仅能修改数据类型与完整性约束条件 ALTER TABLE 表名 MODIFY 被修改的字段名 数据类型(宽度) 约束条件1，约束条件2... COMMENT \"字段描述信息\"; # CHANGE更加强大，相比于MODIFY还支持修改字段名 ALTER TABLE 表名 CHANGE 旧字段名 新字段名 数据类型(宽度) 约束条件1，约束条件2... COMMENT \"字段描述信息\"; # 同时修改多个字段，可混用MODIFY和CHANGE ALTER TABLE 表名 MODIFY ..., CHANGE ...; 示例演示： ALTER TABLE test_table MODIFY field1 VARCHAR(64) NOT NULL DEFAULT \"field1\" COMMENT \"字段1\", MODIFY field2 VARCHAR(64) NOT NULL DEFAULT \"field2\" COMMENT \"字段2\", CHANGE field3 new_field3 VARCHAR(64) NOT NULL DEFAULT \"field3\" COMMENT \"字段3\"; 删除字段 使用以下命令格式删除表中的某一个字段： ALTER TABLE 表名 DROP 字段名; 如下所示，删除test_table的field5字段： > ALTER TABLE test_table DROP field5; 混用操作 新增字段、修改字段、删除字段其实可以混用，如下示例： ALTER TABLE test_table ADD new_filed CHAR(64) NOT NULL DEFAULT \"new field\" COMMENT \"新字段\", MODIFY field1 VARCHAR(128) NOT NULL DEFAULT \"field1\" COMMENT \"字段1\", DROP field4; 表元信息操作 修改存储引擎 使用以下命令格式修改表的存储引擎： ALTER TABLE 表名 ENGINE = 存储引擎; 修改字符集 使用以下命令格式修改表的字符集： ALTER TABLE 表名 CHARSET = 字符集; 修改校对规则 使用以下命令格式修改表的校对规则： ALTER TABLE 表名 COLLATE = 校对规则; 混用操作 修改存储引擎、字符集、校对规则其实可以混用，如下示例： ALTER TABLE test_table ENGINE = innodb, CHARSET = utf8mb4, COLLATE = utf8mb4_general_ci; 实际上ALTER TABLE系列的都可以混用，表结构、表元信息等都可以一次性进行修改，但是这样使用的常见很少，故不再举例。 复制旧表创建新表 结构复制创建 使用以下命令格式只复制表的结构而不复制表的记录，用于创建新的一张表： CREATE TABLE 新表名 LIKE 旧表名; 基础复制创建 使用以下命令格式可以复制基础表结构与所有记录，但不会复制主键、外键、索引，用于创建新的一张表： CREATE TABLE 新表名 SELECT * FROM 旧表名; 选择复制创建 使用以下命令格式可以对一张表的某些记录与字段进行选择性复制，但不会复制主键、外键、索引，用于创建新的一张表： CREATE TABLE 新表名 SELECT 字段1, 字段2 FROM 旧表名; Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:48 "},"数据库专栏/MySQL/记录的操作.html":{"url":"数据库专栏/MySQL/记录的操作.html","title":"记录的操作","keywords":"","body":"创建表格 创建userInfo表，学习记录相关操作： CREATE TABLE userInfo( id INT PRIMARY KEY AUTO_INCREMENT COMMENT \"主键\", name CHAR(32) NOT NULL COMMENT \"用户姓名\", gender ENUM(\"male\", \"female\", \"unknow\") NOT NULL DEFAULT \"unknow\" COMMENT \"用户性别\", age TINYINT(3) NOT NULL DEFAULT 0 COMMENT \"用户年龄\" ) ENGINE = innodb CHARSET = utf8mb4 COLLATE utf8mb4_general_ci; 插入记录 使用INSERT INTO命令插入记录，语法格式如下： # 不指定字段插入多条记录，注意字段个数必须和插入的值个数一一对应 INSERT INTO 表名 VALUES (值1, 值2, 值3, 值4), (值1, 值2, 值3, 值4); # 指定字段插入多条记录，注意指定的字段和插入的值个数必须一一对应 INSERT INTO 表名(字段1, 字段2, 字段3, 字段4 ...) VALUES (值1, 值2, 值3, 值4), (值1, 值2, 值3, 值4); # 先查询出结果，再进行插入 INSERT INTO 表名(字段1, 字段2, 字段3, 字段4 ...) SELECT 字段1, 字段2, 字段3, 字段4 FROM 被查询表名 WHERE 条件; 示例如下： INSERT INTO userInfo(name, gender, age) VALUES (\"Jack\", \"male\", 18), (\"Anna\", \"female\", 17); 更新记录 使用UPDATE SET命令更新记录，语法格式如下： # 注意最后更新的一个字段值不加逗号 UPDATE 表名 SET 字段1 = 值1, 字段2 = 值2 WHERE 条件; 示例演示： UPDATE userInfo SET name = \"Ken\", age = 16, gender = \"male\" WHERE id = 1; 删除记录 使用DELETE命令删除记录，语法格式如下，由于该项操作生产中基本不会使用，故不再进行演示： DELETE FROM 表名 WHERE 条件; 我们在生产环境中，一般不会真正的删除某一条数据。 而是新增一个字段，如delete_status，如果为0则代表未删除，如果为1则代表已删除，在下面的数值类型一章节中会详细介绍这个小技巧。 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:48 "},"数据库专栏/MySQL/数值类型.html":{"url":"数据库专栏/MySQL/数值类型.html","title":"数值类型","keywords":"","body":"整数类型 基本介绍 整数类型一般是指TINYINT、SMALLINT、MEDIUMINT、INT以及BIGINT类型。下表中是其存取范围与显示宽度等信息： 类型 存储大小 默认显示宽度（个） 范围（有符号） 范围（无符号） TINYINT(m) 1Byte m：4 -128 - 127 0 - 255 SMALLINT(m) 2Byte m：6 -32768 - 32767 0 - 65535 MEDIUMINT(m) 3Byte m：9 -8388608 - 8388607 0 - 16777215 INT | INTEGER(m) 4Byte m：11 -2147483648 - 2147483647 0 - 4294967295 BIGINT(m) 8Byte m：20 -9233372036854775808 - 9223372036854775807 0 - 18446744073709551615 m代表其显示宽度，只有在为字段设置ZEROFILL约束条件后才生效，并且这个限制不是必须的，你可以不进行显示宽度的指定。 可选约束 除了公用完整性约束外，数值类型还有两个可选约束，如下表所示： 约束条件 描述 UNSIGNED 无符号存储，该约束条件必须紧跟在类型声明后，如INT UNSIGNED ZEROFILL 显示宽度不够时使用0进行填充，该约束推荐跟在类型声明或无符号存储约束声明后 使用一切数值类型时，指定其宽度均是为其指定显示宽度，并非存入限制数据的宽度。 以下示例将演示为INT类型设置设置了显示宽度后，当宽度不够时将以指定字符进行填充。 # 创建temp表，显示宽度为5，有num字段，无符号整型，不可为空，默认值是0，显示宽度不够时使用0进行宽度填充 CREATE TABLE temp ( num INT(5) UNSIGNED ZEROFILL NOT NULL DEFAULT 0 COMMENT \"显示宽度测试字段\" ) ENGINE innodb CHARSET utf8mb4 COLLATE utf8mb4_general_ci; -- # 插入两条数据，一条显示宽度不够，一条显示宽度足够，查看显示情况 INSERT INTO temp(num) VALUES (1), (99999); -- # 查看显示情况 SELECT * FROM temp; +-------+ | num | +-------+ | 00001 | | 99999 | +-------+ 范围超出 当数值存入范围超出默认值时，将会按照最大值或最小值进行存入。 MySQL5.7.28版本中这样的操作将会抛出异常 但是在MySQL5.6.X版本中这样的操作是被允许的（非严格模式下） INSERT INTO temp(num) VALUES (-1), (4294967296); -- SELECT * FROM temp; +------------+ | temp | +------------+ | 0 | # -1存成了0 | 4294967295 | # 4294967296变为4294967295 +------------+ 布尔类型 MySQL中提供了BOOLEAN或者BOOL类型，它其实是TINYINT(1)的别名，在插入记录时你可以对BOOL字段插入true或者false，内部会自动将其转换为1和0。 CREATE TABLE boolDemo( id INT PRIMARY KEY AUTO_INCREMENT COMMENT \"主键\", name CHAR(64) NOT NULL COMMENT \"姓名\", delete_status BOOLEAN DEFAULT false COMMENT \"是否删除\" ) ENGINE innodb CHARSET utf8mb4 COLLATE utf8mb4_general_ci; 查看表结果： > DESC boolDemo; +---------------+------------+------+-----+---------+----------------+ | Field | Type | Null | Key | Default | Extra | +---------------+------------+------+-----+---------+----------------+ | id | int(11) | NO | PRI | NULL | auto_increment | | name | char(64) | NO | | NULL | | | delete_status | tinyint(1) | YES | | 0 | | +---------------+------------+------+-----+---------+----------------+ 插入数据： INSERT INTO boolDemo(name) VALUES (\"Jack\"), (\"Tom\"), (\"Mary\"); 修改数据： UPDATE boolDemo SET delete_status = true WHERE id IN (1, 3); 查看结果： > SELECT * FROM boolDemo; +----+------+---------------+ | id | name | delete_status | +----+------+---------------+ | 1 | Jack | 1 | | 2 | Tom | 0 | | 3 | Mary | 1 | +----+------+---------------+ 筛选结果： > SELECT * FROM boolDemo WHERE delete_status = false; +----+------+---------------+ | id | name | delete_status | +----+------+---------------+ | 2 | Tom | 0 | +----+------+---------------+ 浮点类型 基本介绍 浮点类型包括FLOAT、DOUBLE、DECIMAL，下表中是其存取范围与显示宽度等信息： 类型 存储大小 最大显示宽度（个） 范围（有符号） 范围（无符号） 精确度 FLOAT(m[,d]) 4Bytes m：255，d：30 (-3.402 823 466 E+38，-1.175 494 351 E-38) - 0 0 - (1.175 494 351 E-38，3.402 823 466 E+38) 点七位以内 DOUBLE(m[,d]) 8Bytes m：255，d：30 (-1.797 693 134 862 315 7 E+308，-2.225 073 858 507 201 4 E-308) - 0 0 - (2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308) 点十五位以内 DECIMAL(m[,d]) m+2（如果m m：65，d：30 取决于m,d（m范围（1-65），d范围（0-30）） 取决于m,d（m范围（1-65），d范围（0-30）） 绝对精准 m代表其整数部分显示个数，d代表其小数部分显示个数。 DECIMAL底层由字符串进行存储，故精度不会出现偏差，也被称为定点类型。 精度问题 根据不同的需求，应当使用不同的浮点类型进行存储，一般来说使用FLOAT足以，但是对于一些精度非常高的数据则应该使用DECIMAL类型进行存储。 以下示例将演示使用不同的浮点类型进行值存储时会发生精度问题： # 创建三张表，并指定显示宽度 > CREATE TABLE t1(num FLOAT(255,30)); > CREATE TABLE t2(num DOUBLE(255,30)); > CREATE TABLE t3(num DECIMAL(65,30)); # 插入三条记录，查看结果是否准确 > INSERT INTO t1(num) VALUES(1.11111111111111111); > INSERT INTO t2(num) VALUES(1.11111111111111111); > INSERT INTO t3(num) VALUES(1.11111111111111111); # 查看结果，FLOAT精确度在点后7位以内 > SELECT * FROM t1; +----------------------------------+ | num | +----------------------------------+ | 1.111111164093017600000000000000 | +----------------------------------+ # 查看结果，DOUBLE精确度在点后15位以内 > SELECT * FROM t2; +----------------------------------+ | num | +----------------------------------+ | 1.111111111111111200000000000000 | +----------------------------------+ # 查看结果，DECIMAL绝对精确 > SELECT * FROM t3; +----------------------------------+ | num | +----------------------------------+ | 1.111111111111111110000000000000 | +----------------------------------+ 位类型 位类型为BIT(m)，可存放多位二进制数，m范围从1~64，如果不写默认为1位。 需要注意的是对于位字段需要使用函数读取： 函数 描述 bin() 显示为二进制 hex() 显示为十六进制 示例如下： # 创建temp表，num字段为bit类型 > CREATE TABLE temp(num BIT); # 默认显示宽度为1 > DESC temp; +-------+--------+------+-----+---------+-------+ | Field | Type | Null | Key | Default | Extra | +-------+--------+------+-----+---------+-------+ | num | bit(1) | YES | | NULL | | +-------+--------+------+-----+---------+-------+ # 插入记录，1 > INSERT INTO temp(num) VALUES(1); # 直接查看是查看不到的 > SELECT * FROM temp; +------+ | num | +------+ | | +------+ # 需要转换为二进制或十六进制进行查看 > SELECT bin(num), hex(num) FROM temp; +----------+----------+ | bin(num) | hex(num) | +----------+----------+ | 1 | 1 | +----------+----------+ # 修改num字段的显示宽度为5 > ALTER TABLE temp MODIFY num BIT(5); # 插入记录，num为8 > INSERT INTO temp VALUES(8); # 显示为不同的进制 > SELECT bin(num),hex(num) FROM temp; +----------+----------+ | bin(num) | hex(num) | +----------+----------+ | 1 | 1 | | 1000 | 8 | +----------+----------+ Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:48 "},"数据库专栏/MySQL/时间类型.html":{"url":"数据库专栏/MySQL/时间类型.html","title":"时间类型","keywords":"","body":"基本介绍 类型一览 MySQL5.7中所有的时间类型都如下表所示： 日期时间类型 占用空间 日期格式 最小值 最大值 零值表示 描述 DATETIME 8 bytes YYYY-MM-DD HH:MM:SS 1000-01-01 00:00:00 9999-12-31 23:59:59 0000-00-00 00:00:00 获取年月日时分秒毫秒 TIMESTAMP 4 bytes YYYY-MM-DD HH:MM:SS 1970-01-01 08:00:01 2038-01-19 03:14:07 00000000000000 获取年月日时分秒毫秒 DATE 4 bytes YYYY-MM-DD 1000-01-01 9999-12-31 0000-00-00 获取年月日 TIME 3 bytes HH:MM:SS -838:59:59 838:59:59 00:00:00 获取时分秒 YEAR 1 bytes YYYY 1901 2155 0000 仅获取年份 MySQL在保存日期时格式都会统一使用ISO 8601标准格式，即YYYY-MM-DD HH:MM:SS。 并且，在提交记录时也必须提交ISO 8601的标准格式时间，否则将会存储失败。 DTT和TTP MySQL中最常用的全写时间格式有2种： DATETIME TIMESTAMP 在实际应用的很多场景中，MySQL的这两种日期类型都能够满足我们的需要，因为它们的最大精度支持都是秒级别的。 但是在某些特殊的情况下，则需要根据这2种类型不同的优劣势来进行选择，如下表所示： DATETIME TIMESTAMP 时间范围 1001年——9999年 1970年——2038年 时区依赖 存储时间与时区无关，显示值也与时区无关 存储时间与时区有关，显示值也与时区有关 存储空间 8字节 4字节 默认值 5.6.5之前是null，之后是CURRENT_TIMESTAMP()函数 当前时间，CURRENT_TIMESTAMP()函数，并且每次update操作时都会自动更新时间 自动生成&自动更新 对于时间类型的字段，如果我们想要在创建记录和更新记录时让其自动更新，可以用以下方式规定字段的默认值： CREATE TABLE userInfo ( id INT PRIMARY KEY AUTO_INCREMENT COMMENT \"主键\", name CHAR(64) NOT NULL COMMENT \"用户姓名\", balance DECIMAL(64, 2) UNSIGNED NOT NULL DEFAULT 0 COMMENT \"用户余额\", create_time DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT \"创建时间\", last_update_time DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT \"最后更新时间\" ) ENGINE innodb CHARSET utf8mb4 COLLATE utf8mb4_general_ci; # 你也可以将create_time和last_update_time中的类型DATETIME修改为TIMESTAMP，不过个人更喜欢DATETIME一些 示例演示，当插入记录或者更新记录时，这2个字段都会自动进行更新： # 插入数据 INSERT INTO userInfo(name, balance) VALUES (\"Jack\", 1000.00), (\"Anna\", 800.00); -- # 自动插入当前时间 SELECT * FROM userInfo; +----+------+---------+---------------------+---------------------+ | id | name | balance | create_time | last_update_time | +----+------+---------+---------------------+---------------------+ | 1 | Jack | 1000.00 | 2021-10-17 11:10:20 | 2021-10-17 11:10:20 | | 2 | Anna | 800.00 | 2021-10-17 11:10:20 | 2021-10-17 11:10:20 | +----+------+---------+---------------------+---------------------+ -- # 自动更新当前时间 UPDATE userInfo SET balance = 1200 WHERE name IN (\"Anna\", \"Jack\"); > SELECT * FROM temp; +----+------+---------+---------------------+---------------------+ | id | name | balance | create_time | last_update_time | +----+------+---------+---------------------+---------------------+ | 1 | Jack | 1200.00 | 2021-10-17 11:10:20 | 2021-10-17 11:12:31 | | 2 | Anna | 1200.00 | 2021-10-17 11:10:20 | 2021-10-17 11:12:31 | +----+------+---------+---------------------+---------------------+ 查询格式化 格式化参数 格式化参数及描述如下表所示： 格式 描述 %a 缩写星期名 %b 缩写月名 %c 月，数值 %D 带有英文前缀的月中的天 %d 月的天，数值(00-31) %e 月的天，数值(0-31) %f 微秒 %H 小时 (00-23) %h 小时 (01-12) %I 小时 (01-12) %i 分钟，数值(00-59) %j 年的天 (001-366) %k 小时 (0-23) %l 小时 (1-12) %M 月名 %m 月，数值(00-12) %p AM 或 PM %r 时间，12-小时（hh:mm:ss AM 或 PM） %S 秒(00-59) %s 秒(00-59) %T 时间, 24-小时 (hh:mm:ss) %U 周 (00-53) 星期日是一周的第一天 %u 周 (00-53) 星期一是一周的第一天 %V 周 (01-53) 星期日是一周的第一天，与 %X 使用 %v 周 (01-53) 星期一是一周的第一天，与 %x 使用 %W 星期名 %w 周的天 （0=星期日, 6=星期六） %X 年，其中的星期日是周的第一天，4 位，与 %V 使用 %x 年，其中的星期一是周的第一天，4 位，与 %v 使用 %Y 年，4 位 %y 年，2 位 格式化函数 两个用于查询时对时间格式进行格式化的函数。 函数 描述 DATE_FORMAT(字段，格式化内容) 对字段进行年月日时分秒的格式化 TIME_FORMAT(字段，格式化内容) 对字段进行时分秒的格式化 示例演示： > SELECT name, balance, date_format(create_time, \"%Y年%m月%d日 %H时%i分%s秒 注册\") FROM userInfo; +------+---------+--------------------------------------------------------------------+ | name | balance | date_format(create_time, \"%Y年%m月%d日 %H时%i分%s秒 注册\") | +------+---------+--------------------------------------------------------------------+ | Jack | 1200.00 | 2021年10月17日 11时10分20秒 注册 | | Anna | 1200.00 | 2021年10月17日 11时10分20秒 注册 | +------+---------+--------------------------------------------------------------------+ 时间获取 函数介绍 三个不需要传参的函数： 函数 描述 NOW() 当前时间，完整的年月日时分秒 CURRENT_DATE() 当前日期，年月日 CURRENT_TIME() 当前时间，时分秒 其他的需要传参的函数： 函数 描述 YEAR() 年（范围从1000 到 9999） MONTH() 月（范围从1到12） DAY() 日（范围从1开始） HOUR() 时（范围从0到23） MINUTE() 分（范围从0到59） SECOND() 秒（范围从0到59） TIME() 只获取时间，即时分秒。 WEEK() 一年中的第几周，从1开始计数 QUARTER() 一年中的季度，从1开始计数 DAYOFYEAR() 一年中的第几天（从1开始） DAYOFMONTH() 月份中天数（从1开始） DAYOFWEEK() 星期天（1）到星期六（7） WEEKDAY() 星期一（0）到星期天（6） TO_DAYS() 从元年到现在的天数（忽略时间部分） FROM_DAYS() 根据天数得到日期（忽略时间部分） TIME_TO_SEC() 时间转为秒数（忽略日期部分） SEC_TO_TIME() 根据秒数转为时间（忽略日期部分） UNIX_TIMESTAMP() 根据日期返回秒数（包括日期与时间） FROM_UNIXTIME() 根据秒数返回日期与时间（包括日期与时间） DATEDIFF() 两个日期相差的天数（忽略时间部分，前面日期减后面日期） TIMEDIFF() 计算两个时间的间隔（忽略日期部分） TIMESTAMPDIFF() 根据指定单位计算两个日期时间的间隔（包括日期与时间） LAST_DAY() 该月的最后一天 时间获取 示例操作，获取当前时间： > SELECT NOW(); +---------------------+ | NOW() | +---------------------+ | 2021-10-17 11:49:21 | +---------------------+ 示例演示，获取当前时间中的分钟数： > SELECT MINUTE(NOW()); +---------------+ | MINUTE(NOW()) | +---------------+ | 49 | +---------------+ 示例演示，获取今天是星期几： > SELECT DAYOFWEEK(NOW()); +------------------+ | DAYOFWEEK(NOW()) | +------------------+ | 1 | +------------------+ 时间转换 示例演示，当前时间转秒数与当前秒数转时间： > SELECT SEC_TO_TIME(TIME_TO_SEC(NOW())) AS \"当前秒数转时间\", TIME_TO_SEC(NOW()) AS ”当前时间转秒数“; +-----------------------+-----------------------------+ | 当前秒数转时间 | ”当前时间转秒数“ | +-----------------------+-----------------------------+ | 11:52:44 | 42764 | +-----------------------+-----------------------------+ 时间计算 函数介绍 时间计算相关的函数： 函数 描述 ADDTIME() 添加时间，负数为减少，只对时间类型有效 TIMESTAMP() 添加时间，负数为减少，只对时间类型有效 DATE_ADD() 根据单位添加时间，支持单位有YEAR/MONTH/DAY/HOUR/MINUTE/SECOND/HOUR_MINUTE/DAY_HOUR/DAY_MINUTE/DAY_SECOND/HOUR_MINUTE/HOUR_SECOND（负数时等于DATE_SUB) DATE_SUB() DATE_ADD的反函数 操作演示 示例演示，使用INTERVAL来添加时间： # 7小时前的日期 > SELECT ADDTIME(NOW(), \"-7:00:00\"); +----------------------------+ | ADDTIME(NOW(), \"-7:00:00\") | +----------------------------+ | 2021-02-16 17:44:50 | +----------------------------+ # 7天后的日期 > SELECT DATE_ADD(NOW(), INTERVAL 7 DAY); +---------------------------------+ | DATE_ADD(NOW(), INTERVAL 7 DAY) | +---------------------------------+ | 2021-02-24 00:45:33 | +---------------------------------+ # 7天前的日期 > SELECT DATE_SUB(NOW(), INTERVAL 7 DAY); +---------------------------------+ | DATE_SUB(NOW(), INTERVAL 7 DAY) | +---------------------------------+ | 2021-02-10 00:46:12 | +---------------------------------+ # 20小时10分钟后的日期 > SELECT DATE_ADD(NOW(),INTERVAL '20:10' HOUR_MINUTE); +----------------------------------------------+ | DATE_ADD(NOW(),INTERVAL '20:10' HOUR_MINUTE) | +----------------------------------------------+ | 2021-02-17 20:56:41 | +----------------------------------------------+ # 2天8小时后的日期 > SELECT DATE_ADD(NOW(),INTERVAL '2 8' DAY_HOUR); +-----------------------------------------+ | DATE_ADD(NOW(),INTERVAL '2 8' DAY_HOUR) | +-----------------------------------------+ | 2021-02-19 08:47:12 | +-----------------------------------------+ # 获取本月最后一天日期 > SELECT LAST_DAY(NOW()); +-----------------+ | LAST_DAY(NOW()) | +-----------------+ | 2021-02-28 | +-----------------+ # 获取本月第一天日期 > SELECT DATE_SUB(NOW(),INTERVAL DAYOFMONTH(NOW())-1 DAY); +--------------------------------------------------+ | DATE_SUB(NOW(),INTERVAL DAYOFMONTH(NOW())-1 DAY) | +--------------------------------------------------+ | 2021-02-01 00:48:17 | +--------------------------------------------------+ Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:48 "},"数据库专栏/MySQL/字符类型.html":{"url":"数据库专栏/MySQL/字符类型.html","title":"字符类型","keywords":"","body":"字符类型 基本介绍 MySQL中提供了多种字符串类型，我们可以依据它们不同的特性来选择合适的类型进行数据存储，大多数情况下CHAR和VARCHAR是最常用的。 类型 最大存储字符数 用途 CHAR 0 - 255字符 定长字符串 VARCHAR 0 - 65535字符 变长字符串 TINYBLOB 0 - 255字符 不超过 255 个字符的二进制字符串 TINYTEXT 0 - 255字符 短文本字符串 BLOB 0 - 65 535字符 二进制形式的长文本数据 TEXT 0 - 65 535字符 长文本数据 MEDIUMBLOB 0 - 16 777 215字符 二进制形式的中等长度文本数据 MEDIUMTEXT 0 - 16 777 215字符 中等长度文本数据 LONGBLOB 0 - 4 294 967 295字符 二进制形式的极大文本数据 LONGTEXT 0 - 4 294 967 295字符 极大文本数据 字符宽度 与数值类型不同，对于字符类型而言，其指定宽度均为存入宽度而非显示宽度，且以字符为单位，同时字符宽度的设定是必须的： CREATE TABLE db1.temp( id INT PRIMARY KEY AUTO_INCREMENT COMMENT \"主键\", ch CHAR(4) NOT NULL COMMENT \"定长字符串\", vc VARCHAR(4) NOT NULL COMMENT \"变长字符串\" ) ENGINE innodb CHARSET utf8mb4 COLLATE utf8mb4_general_ci; 定长变长 区别差异 CHAR类型为定长字符串，存入的字符长度不足其指定宽度时，将会使用空字符进行填充。 VARCHAR类型为变长字符串，存入的字符长度不足其指定宽度时，不会使用空字符进行填充。 如果CHAR和VARCHAR的字符宽度相同，且都建立了索引，那么VARCHAR类型INDEX的key_len会比CHAR类型INDEX的key_len多出2个Bytes，它标识了可变字符的开始位和结束位。 通常情况下来讲，CHAR类型存取速度要比VARCHAR高约50%，但是更加浪费磁盘空间 在InnoDB存储引擎中，不存在这种差异 建议在同一张数据表中统一使用VARCHAR或CHAR类型，这里更推荐使用CHAR类型 CHAR类型的详细概述： 特点概述： 定长，简单粗暴，浪费空间，存取速度快 字符个数： 0-255（一个中文是一个字符，是utf8编码的3个字节，utf8mb4编码的4个字节） 存储特点： 存储CHAR类型的值时，会往右填充空格来满足长度 存储举例： 指定长度为10，存>10个字符则报错，存VARCHAR类型的详细概述： 特点概述： 变长，精准，节省空间，存取速度慢 字符个数： 0-65535，如果大于16383会提示用其他类型，如BLOB和TEXT，因为VARCHAR并不适合存储长文本数据。 存储特点： VARCHAR类型存储数据的真实内容，不会用空格填充，如果'ab ',尾部的空格也会被存起来。 此外，由于MySQL单行最大限制为65535字节，所以VARCHAR类型会在真实数据前加1-2Bytes的前缀，该前缀用来表示真实数据的bytes字节数。 存储举例： 如果真实的数据255bytes则需要2Bytes的前缀（2Bytes=16bit 2**16最大表示的数字为65535） 即VARCHAR类型最多存储65535个字符。 检索： 如果数据的尾部有空格，那么VARCHAR会保存下来，在检索或者说查询时，也会正常显示包含空格在内的内容 差异对比 下面是CHAR和VARCHAR在PAD_CHAR_TO_FULL_LENGTH模式下对同一个值存储时的差异对比： 注意：PAD_CHAR_TO_FULL_LENGTH模式下如果存储的值大于存储长度的限制，那么它不会抛出异常，而是将值截取后进行存储 如下表所示： 插入值 CHAR(4)存入值 CHAR(4)占据空间 VARCHAR(4)存入值 VARCHAR(4)占据空间 '' ' ' 4 bytes ' ' 1 bytes 'ab' 'ab ' 4 bytes 'ab' 3 bytes 'abcd' 'abcd' 4 bytes 'abcd' 5 bytes 'abcdefgh' 'abcd' 4 bytes 'abcd' 5 bytes 由于VARCHAR是变长存储，所以需要一个头部标识来表示真实内容究竟占据多少字符，这个头部标识通常占据1-2个字节的存储空间。 存入abcd，VARCHAR(4)需要算上头部标识，即最小占用5字节。而CHAR(4)则仅占用4字节。 若想验证上述的结果，需要使用1个函数与执行计划explain来完成对比： LENGTH()：查看字符占用的字节长度 补充点：CHAR_LENGTH()可用于查看字符占用的字符长度 示例如下： # 修改模式：使其查看定长字符类型时不会将填充空格移除，且在存储大于存储长度的限制的值是不会抛出异常，而是截取存入 SET sql_mode = 'PAD_CHAR_TO_FULL_LENGTH'; -- # 创建数据表 CREATE TABLE temp( id INT PRIMARY KEY AUTO_INCREMENT COMMENT \"主键\", ch CHAR(4) NOT NULL COMMENT \"定长字符串\", vc VARCHAR(4) NOT NULL COMMENT \"变长字符串\" ) ENGINE innodb CHARSET utf8mb4 COLLATE utf8mb4_general_ci; -- # 插入数据 INSERT INTO temp(ch, vc) VALUES (\"\", \"\"), (\"ab\", \"ab\"), (\"abcd\", \"abcd\"), (\"abcdefg\", \"abcdefg\"); -- # 查看数据的字节长度对比情况 # 注意！对于VARCHAR类型来说，它并不会统计头部信息，所以我们需要在原本的基础上+1或者2个bytes单位，因为这里的数据是abcd，共占用4个Bytes，故+1即可 SELECT LENGTH(ch) AS \"占用字节数CHAR\", LENGTH(vc) + 1 AS \"占用字节数VARCHAR\" FROM temp; +---------------------+------------------------+ | 占用字节数CHAR | 占用字节数VARCHAR | +---------------------+------------------------+ | 4 | 1 | | 4 | 3 | | 4 | 5 | | 4 | 5 | +---------------------+------------------------+ 下面我们将演示使用执行计划获取VARCHAR类型INDEX的key_len长度，它应该会比CHAR类型INDEX的key_len长度多2个Bytes： # 添加索引 ALTER TABLE temp ADD INDEX cidx(ch); ALTER TABLE temp ADD INDEX vidx(vc); -- # 查看索引覆盖情况 # 使用执行计划可以看见ch索引长度key_len是16个字节。utf8mb4下4*4=16 EXPLAIN SELECT ch FROM temp; +----+-------------+-------+------------+-------+---------------+------+---------+------+------+----------+-------------+ | id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra | +----+-------------+-------+------------+-------+---------------+------+---------+------+------+----------+-------------+ | 1 | SIMPLE | temp | NULL | index | NULL | cidx | 16 | NULL | 4 | 100.00 | Using index | +----+-------------+-------+------------+-------+---------------+------+---------+------+------+----------+-------------+ # 使用执行计划可以看见vc的key_len是18个字节。这是因为除了utf8mb4下4*4=16之外，还需要加上开始和结束位置，占2字节 EXPLAIN SELECT vc FROM temp; +----+-------------+-------+------------+-------+---------------+------+---------+------+------+----------+-------------+ | id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra | +----+-------------+-------+------------+-------+---------------+------+---------+------+------+----------+-------------+ | 1 | SIMPLE | temp | NULL | index | NULL | vidx | 18 | NULL | 4 | 100.00 | Using index | +----+-------------+-------+------------+-------+---------------+------+---------+------+------+----------+-------------+ 常用函数 大小写转换 UPPER()函数功能是小写转大写。 LOWER()函数功能是大写转小写。 > SELECT UPPER(\"mysql\"), LOWER(\"MYSQL\"); +----------------+----------------+ | UPPER(\"mysql\") | LOWER(\"MYSQL\") | +----------------+----------------+ | MYSQL | mysql | +----------------+----------------+ 字符替换 REPLACE()函数可以将指定字符的子串替换为新的子串，如下示例将google替换成biying： > SELECT REPLACE(\"www.google.com\", \"google\", \"biying\"); +-----------------------------------------------+ | REPLACE(\"www.google.com\", \"google\", \"biying\") | +-----------------------------------------------+ | www.biying.com | +-----------------------------------------------+ 指定量取 LEFT()函数是从左往右取指定数量的字符。 RIGHT()函数是从右往左取指定数量的字符。 > SELECT LEFT(\"ABCDE\",3), RIGHT(\"ABCDE\",3); +-----------------+------------------+ | LEFT(\"ABCDE\",3) | RIGHT(\"ABCDE\",3) | +-----------------+------------------+ | ABC | CDE | +-----------------+------------------+ 中间字符 MID()函数从中间取字符。 参数2为指定起始位置，默认从1开始。 参数3为指定取出的字符数量，默认一直取完。 > SELECT MID(\"ABCDE\",2,2); +------------------+ | MID(\"ABCDE\",2,2) | +------------------+ | BC | +------------------+ 截取子串 SUBSTRING()函数从指定起始位置开始取出像右的指定字符。 参数2为指定起始位置，默认从1开始。 参数3为指定取出的字符数量，默认一直取完。 感觉它和MID()函数没啥大区别： M > SELECT SUBSTRING(\"ABCDE\",2,2); +------------------------+ | SUBSTRING(\"ABCDE\",2,2) | +------------------------+ | BC | +------------------------+ 字符长度 CHAR_LENGTH()函数可获取字符长度，如果想要获取CHAR类型的字符长度且包括空白填充字符时需要修改SQL模式： # 修改SQL模式 SET sql_mode = 'PAD_CHAR_TO_FULL_LENGTH'; 函数示例演示： > SELECT CHAR_LENGTH(\"ABCDE\"); +----------------------+ | CHAR_LENGTH(\"ABCDE\") | +----------------------+ | 5 | +----------------------+ 字节长度 LENGTH()函数可获取字节长度，如果想要获取CHAR类型的字节长度且包括空白填充字符时需要修改SQL模式： # 修改SQL模式 SET sql_mode = 'PAD_CHAR_TO_FULL_LENGTH'; 函数示例演示： > SELECT LENGTH(\"ABCDE\"); +-----------------+ | LENGTH(\"ABCDE\") | +-----------------+ | 5 | +-----------------+ 字符连接 CONCAT()和CONCAT_WS()函数可将多段字符进行连接。 CONCAT()：可将查询结果与任意字符串进行拼接 CONCAT_WS()：可指定连接符进行拼接，第1个参数是连接符 它们的作用不仅局限于此，还有更多的妙用，我们将在元信息获取一章节中进行介绍，下面是它们的基本使用案例： > SELECT CONCAT(\"A\", \"-\", \"B\", \"-\", \"C\"); +---------------------------------+ | CONCAT(\"A\", \"-\", \"B\", \"-\", \"C\") | +---------------------------------+ | A-B-C | +---------------------------------+ > SELECT CONCAT_WS(\"-\", \"A\", \"B\", \"C\"); +-------------------------------+ | CONCAT_WS(\"-\", \"A\", \"B\", \"C\") | +-------------------------------+ | A-B-C | +-------------------------------+ Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:48 "},"数据库专栏/MySQL/枚举类型.html":{"url":"数据库专栏/MySQL/枚举类型.html","title":"枚举类型","keywords":"","body":"ENUM 枚举类型可以从众多的选项成员中提取一个选项，类似于单选的概念，最大可指定65535个选项。 插入的值，必须位于ENUM选项成员中，如果不在将会抛出异常。 CREATE TABLE userInfo( id INT PRIMARY KEY AUTO_INCREMENT COMMENT \"主键\", name CHAR(32) NOT NULL COMMENT \"姓名\", age TINYINT(3) NOT NULL DEFAULT 0 COMMENT \"年龄\", gender ENUM(\"male\", \"female\", \"unknow\") NOT NULL DEFAULT \"unknow\" COMMENT \"性别\" ) ENGINE innodb CHARSET utf8mb4 COLLATE utf8mb4_general_ci; 以下是插入值的演示： INSERT INTO userInfo(name, age, gender) VALUES (\"Jack\", 18, \"male\"); 查看插入结果： > SELECT * FROM userInfo WHERE id = 1; +----+------+-----+--------+ | id | name | age | gender | +----+------+-----+--------+ | 1 | Jack | 18 | male | +----+------+-----+--------+ Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:48 "},"数据库专栏/MySQL/集合类型.html":{"url":"数据库专栏/MySQL/集合类型.html","title":"集合类型","keywords":"","body":"SET 集合类型可以从众多的选项成员中提取多个选项，类似于多选的概念，最大可指定64个选项。 插入的值，必须位于SET选项成员中，如果不在将会抛出异常。 ALTER TABLE userInfo ADD hobby SET(\"basketball\", \"football\", \"volleyball\", \"unknow\") NOT NULL DEFAULT \"unknow\" COMMENT \"爱好\"; 以下是插入值的示例： INSERT INTO userInfo(name, age, gender, hobby) VALUES (\"Anna\", 17, \"female\", \"basketball,football,volleyball\"); 查看插入结果： > SELECT * FROM userInfo WHERE id = 2; +----+------+-----+--------+--------------------------------+ | id | name | age | gender | hobby | +----+------+-----+--------+--------------------------------+ | 2 | Anna | 17 | female | basketball,football,volleyball | +----+------+-----+--------+--------------------------------+ Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:48 "},"数据库专栏/MySQL/约束条件.html":{"url":"数据库专栏/MySQL/约束条件.html","title":"约束条件","keywords":"","body":"约束条件 约束条件与数值类型的显示宽度一样均为可选参数，其作用在于保证数据的完整性与一致性。 常用完整性约束如下表所示： 约束条件 描述 DEFAULT 为该字段设置默认值 NOT NULL 标识该字段不能为空（非字符串有效） UNIQUE KEY 标识该字段的值是唯一的 PRIMARY KEY 标识该字段为该表的主键，可以唯一的标识记录 AUTO_INCREMENT 标识该字段的值自动增长（整数类型） FOREIGN KEY 标识该字段为该表的外键 还有2个针对数值类型的完整性约束条件： 约束条件 描述 UNSIGNED 设定数值类型存入方式为无符号，该约束条件必须紧跟在类型声明后，如INT UNSIGNED ZEROFILL 使用0对数值的显示宽度进行填充，该约束推荐跟在类型声明或无符号存储约束声明后 DEFAULT 默认值 用于为该字段设置一个默认值，若后续在为该表格插入记录时没有选定该字段，则自动插入默认值，若没有设置默认值，则插入NULL。 示例演示，为age字段和gender字段设置默认值： CREATE TABLE userInfo( id INT PRIMARY KEY AUTO_INCREMENT COMMENT \"主键\", name CHAR(32) NOT NULL COMMENT \"姓名\", age TINYINT(3) NOT NULL DEFAULT 0 COMMENT \"年龄\", gender ENUM(\"male\", \"female\", \"unknow\") NOT NULL DEFAULT \"unknow\" COMMENT \"性别\" ) ENGINE innodb CHARSET utf8mb4 COLLATE utf8mb4_general_ci; 在插入数据时，不指定age字段和gender字段，将自动插入默认值： INSERT INTO userInfo(name) VALUES (\"Jack\"), (\"Tom\"), (\"Mary\"); 查询结果： > SELECT * FROM userInfo LIMIT 3; +----+------+-----+--------+ | id | name | age | gender | +----+------+-----+--------+ | 1 | Jack | 0 | unknow | | 2 | Tom | 0 | unknow | | 3 | Mary | 0 | unknow | +----+------+-----+--------+ NOT NULL 必须插入 代表非字符类型的字段不能为空，必须为该字段插入值，它常常和DEFAULT约束条件一起使用。 当非字符类型的字段拥有约束NOT NULL且没有设定默认值时，若插入记录不指定该字段将会抛出1364的异常。 ERROR 1364 (HY000): Field '字段名' doesn't have a default value UNIQUE KEY 唯一限制 UNIQUE代表该字段的记录必须拥有唯一性，UNIQUE约束有2种分类： 单列唯一 联合唯一 单列唯一的小例子，姓名可能是重复的，但是身份证号必须是唯一的： JACK + 110000199806215154 √ JACK + 110000199708154326 √ 同名，但身份证号不重复 KEN + 110000199806215154 × 不同名，但身份证号重复 联合唯一的小例子，IP+PORT能够标识出全世界独一无二的一台计算机，世界上不会存在IP+PORT都相同的2台计算机： 182.223.79.120 + 443 √ 182.223.79.120 + 80 √ 182.223.79.120 + 443 × 已经出现了一次 182.223.79.120 + 80 × 已经出现了一次 182.223.79.121 + 443 √ 182.223.79.121 + 80 √ 182.223.79.121 + 443 × 已经出现了一次 182.223.79.121 + 80 × 已经出现了一次 单列唯一 单列唯一是指该字段下的值不能重复。 设置方式1，直接在字段后面添加UNIQUE的约束条件： CREATE TABLE userInfo( id INT PRIMARY KEY AUTO_INCREMENT COMMENT \"主键\", name CHAR(32) NOT NULL COMMENT \"姓名\", id_card CHAR(18) NOT NULL UNIQUE COMMENT \"身份证号\" ) ENGINE innodb CHARSET utf8mb4 COLLATE utf8mb4_general_ci; 设置方式2，UNIQUE KEY(字段名)： CREATE TABLE userInfo( id INT PRIMARY KEY AUTO_INCREMENT COMMENT \"主键\", name CHAR(32) NOT NULL COMMENT \"姓名\", id_card CHAR(18) NOT NULL COMMENT \"身份证号\", UNIQUE KEY(id_card) COMMENT \"唯一条件约束(id_card)\" ) ENGINE innodb CHARSET utf8mb4 COLLATE utf8mb4_general_ci; 上面这2个建表语句的效果是一样的，名字可以相同，身份证号必须不同，如果身份证号相同则抛出异常： INSERT INTO userInfo(name, id_card) VALUES (\"Jack\", \"110000199806215154\"), (\"Mary\", \"110000199806215154\"); ERROR 1062 (23000): Duplicate entry '110000199806215154' for key 'id_card' 联合唯一 联合唯一是指多个字段的值不能重复。 设置方式1，不指定联合唯一的键名，UNIQUE KEY(字段1, 字段2)： CREATE TABLE serve( id INT PRIMARY KEY AUTO_INCREMENT COMMENT \"主键\", ip CHAR(19) NOT NULL COMMENT \"ip地址\", port INT(5) NOT NULL COMMENT \"port端口号\", UNIQUE KEY(ip, port) COMMENT \"联合唯一约束(ip, port)\" ) ENGINE innodb CHARSET utf8mb4 COLLATE utf8mb4_general_ci; 设置方式2，需指定联合唯一的键名，UNIQUE KEY 键名(字段1, 字段2)： CREATE TABLE serve( id INT PRIMARY KEY AUTO_INCREMENT COMMENT \"主键\", ip CHAR(19) NOT NULL COMMENT \"ip地址\", port INT(5) NOT NULL COMMENT \"port端口号\", UNIQUE KEY joint_unique_ip_port(ip, port) COMMENT \"联合唯一约束(ip, port)\" ) ENGINE innodb CHARSET utf8mb4 COLLATE utf8mb4_general_ci; 上面这2个建表语句的效果是一样的，IP+PORT必须不同，如果相同则会抛出异常： INSERT INTO serve(ip, port) VALUES (\"localhost\", 80), (\"localhost\", 80); # ERROR 1062 (23000): Duplicate entry 'localhost-80' for key 'joint_unique_ip_port' PRIMARY KEY 主键特性 主键是InnoDB表中必要的、组织数据的依据，它能对查找速度进行质的提升，此外它还有非空且唯一的约束性限制。 一张表中至多只有一个主键（约束只能有一个，但可以作用到好几个字段）。 当没有明确指出PRIMAY KEY时，InnoDB存储引擎首先会查找是否具有非空且唯一约束条件的字段 如果有将则将其转变为主键 如果没有则会自动的创建一个6字节的隐藏主键用于组织数据，但是它不会加速记录的查找 查看任意一张表的表结构，都能看到其主键信息： > DESC serve; +-------+----------+------+-----+---------+----------------+ | Field | Type | Null | Key | Default | Extra | +-------+----------+------+-----+---------+----------------+ | id | int(11) | NO | PRI | NULL | auto_increment | | ip | char(19) | NO | MUL | NULL | | | port | int(5) | NO | | NULL | | +-------+----------+------+-----+---------+----------------+ 非空唯一 主键具有非空且唯一的约束，如果我们没有设置主键但是设置一个非空且唯一的字段时InnoDB存储引擎会自动将它转变为主键。 CREATE TABLE user ( id INT NOT NULL UNIQUE AUTO_INCREMENT COMMENT \"主键\", name CHAR(12) NOT NULL COMMENT \"用户姓名\" ) ENGINE innodb CHARSET utf8mb4 COLLATE utf8mb4_general_ci; 查看这张表的表结构，可以看见id字段自动转变为主键了： > DESC user; +-------+----------+------+-----+---------+----------------+ | Field | Type | Null | Key | Default | Extra | +-------+----------+------+-----+---------+----------------+ | id | int(11) | NO | PRI | NULL | auto_increment | | name | char(12) | NO | | NULL | | +-------+----------+------+-----+---------+----------------+ 单列主键 尽管可以用上面的方式设置主键，但这并不是一种常用的手段，我们有更加简便的方式来设置单列主键。 单列主键即为单独的一个字段设置主键。 在设置单列主键时，需要注意2点： 设置单列主键的字段不应该再参与业务逻辑处理，它的功能只应该有两个：1.标识，2.加速查找 如身份证号这种可能会被引用于业务处理的字段最好不要设置为主键 设置方式1，直接在字段后面添加PRIMARY KEY的约束条件： CREATE TABLE user ( id INT PRIMARY KEY AUTO_INCREMENT COMMENT \"主键\", name CHAR(12) NOT NULL COMMENT \"用户姓名\" ) ENGINE innodb CHARSET utf8mb4 COLLATE utf8mb4_general_ci; 设置方式2，PRIMARY KEY(字段名)： CREATE TABLE user ( id INT AUTO_INCREMENT COMMENT \"主键\", name CHAR(12) NOT NULL COMMENT \"用户姓名\", PRIMARY KEY(id) COMMENT \"主键约束(id)\" ) ENGINE innodb CHARSET utf8mb4 COLLATE utf8mb4_general_ci; 联合主键 联合主键即是将多个字段设置为主键（约束限制作用到多个字段上），与联合唯一效果类似。 设置方式1，不指定联合主键的键名，PRIMARY KEY(字段1, 字段2)： CREATE TABLE admin ( name CHAR(12) NOT NULL COMMENT \"管理员\", host CHAR(15) NOT NULL COMMENT \"允许登录的地址\", PRIMARY KEY(name, host) COMMENT \"联合主键(name,host)\" ) ENGINE innodb CHARSET utf8mb4 COLLATE utf8mb4_general_ci; 设置方式2，需指定联合主键的键名，PRIMARY KEY 键名(字段1, 字段2)： CREATE TABLE admin ( name CHAR(12) NOT NULL COMMENT \"管理员\", host CHAR(15) NOT NULL COMMENT \"允许登录的地址\", PRIMARY KEY complex_primary_key(name, host) COMMENT \"联合主键(name,host)\" ) ENGINE innodb CHARSET utf8mb4 COLLATE utf8mb4_general_ci; 相较于联合唯一来说，联合主键用的较少。 AUTO_INCREMENT 自动增长 AUTO_INCREMENT每个表至多只能有1个，该约束可以为数字列进行自动增长（从1开始），被该约束条件所约束的字段必须同时被KEY所约束，如： UNIQUER KEY PRIMARY KEY FOREIGN KEY 一般来说该约束都与单列主键PRIMARY KEY配合使用： CREATE TABLE temp ( id INT PRIMARY KEY AUTO_INCREMENT COMMENT \"主键\", data CHAR(15) NOT NULL COMMENT \"任意数据\" ) ENGINE innodb CHARSET utf8mb4 COLLATE utf8mb4_general_ci; 插入3条数据后查看id列，可以发现由于其增加了AUTO_INCREMENT的约束，所以该列会自动增长： INSERT INTO temp(data) VALUES (\"first\"), (\"second\"), (\"third\"); 查看结果： > SELECT * FROM temp LIMIT 3; +----+--------+ | id | data | +----+--------+ | 1 | first | | 2 | second | | 3 | third | +----+--------+ 记录删除 当某一条记录进行删除后，插入时将继续依照其所记录的增长值进行增长。 示例如下： # 删除记录 DELETE FROM temp WHERE id=3; -- # 查看当前ID SELECT * FROM temp； +----+--------+ | id | data | +----+--------+ | 1 | first | | 2 | second | +----+--------+ -- # 插入新的数据 INSERT INTO temp(data) VALUES (\"new\"); -- # 查看增长的值，可以发现它是从4开始的 SELECT * FROM temp; +----+--------+ | id | data | +----+--------+ | 1 | first | | 2 | second | | 4 | new | +----+--------+ 使用以下命令可查看到其目前记录的增长值： > SHOW CREATE TABLE temp\\G; *************************** 1. row *************************** Table: temp Create Table: CREATE TABLE `temp` ( `id` int(11) NOT NULL AUTO_INCREMENT COMMENT '主键', `data` char(15) NOT NULL COMMENT '任意数据', PRIMARY KEY (`id`) ) ENGINE=InnoDB AUTO_INCREMENT=5 DEFAULT CHARSET=utf8mb4 1 row in set (0.00 sec) 通过TRUNCATE命令可以清除掉记录的增长值： # 清除所有记录、重置自增长值为0 TRUNCATE temp; -- # 重新查看当前的自增长值，可以发现它不在了 SHOW CREATE TABLE temp\\G; *************************** 1. row *************************** Table: temp Create Table: CREATE TABLE `temp` ( `id` int(11) NOT NULL AUTO_INCREMENT COMMENT '主键', `data` char(15) NOT NULL COMMENT '任意数据', PRIMARY KEY (`id`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 偏移步长 默认的自增长（偏移量）是从1开始，而默认的步长为1即每次都加一个，我们也可以修改这个值。 命令与描述如下所示： # 针对单表的设定 ALTER TABLE 表名 AUTO_INCREMENT = 设定下次生成的值从几开始 # 本次会话有效，关闭终端后失效，针对所有表 SET SESSION AUTO_INCREMENT_OFFSET = 设定的起始值 SET SESSION AUTO_INCREMENT_INCREMENT = 设定的步长 # 全局设置，所有会话生效，重启服务失效 SET GLOBAL AUTO_INCREMENT_OFFSET = 设定的起始值 SET GLOBAL AUTO_INCREMENT_INCREMENT = 设定的步长 由于偏移步长的使用相对较少，故不再进行演示。 FOREIGN KEY 外键描述 目前为止我们所学习的都是单表操作，而外键（FOREIGN KEY）则是学习多表操作的第一步。 FOREIGN KEY能够将2张表关联在一起，合成一张大表 FOREIGN KEY是一个表中的一个字段或字段集合，它引用另一个表中的UNIQUE KEY或者PRIMARY KEY 注意，FOREIGN KEY本身仅是一个约束条件，与查询关系不大。 使用FOREIGN KEY不仅能有效避免表格关系混乱的情况发生，并且表格关联后可以更方便的利用级联操作确保多表数据的一致性。 FOREGIN KEY也有一定的弊端，使用FOREGIN KEY后表关系的耦合度会增加，于后期扩展不利。 若想使用FOREIGN KEY，则需要注意以下一些操作事项： 2张关联的表必须是InnoDB存储引擎 2张关联的表字符编码和排序规则应当相同 2张关联的表所联系字段必须拥有相同的数据类型、且长度应当相同 主表（被关联表）的被连接字段必须是唯一键UNIQUE KEY或者主键PRIMARY KEY，无论如何要保证主表的被连接字段拥有唯一性约束，推荐从表（关联表）外键字段连接到主表（被关联表）的PRIMARY KEY上，这样可以避免回表查询，提高查询效率 外键操作 如下，我们有这样的2张表，主表是classInfo，从表是studentsInfo： 可以在studentsInfo表中创建一个FOREIGN KEY字段fk_class_id，让其连接到classesInfo表中的PRIMARY KEY字段id。 创建表时可以一并建立外键关系，以下是语法格式： # 创建表时外键的方式，别名可以省略。如果省略则自动生成 FOREIGN KEY 外键别名(本表外键字段) REFERENCES 被关联表名称(被连接字段) ON DELETE 级联操作 ON UPDATE 级联操作 也可以在一个表创建后新增外键，语法格式如下： # 可指定外键别名，也可以不指定 ALTER TABLE 表名 ADD FOREIGN KEY 外键别名(本表外键字段) REFERENCES 其他表名称(被连接字段) ON DELETE 级联操作 ON UPDATE 级联操作; 根据上图的关系，我们可以用下面的方式进行在创建studentsInfo表时建立外键关系： FOREIGN KEY fk_class(\"fk_class_id\") REFERENCES classesInfo(id) ON DELETE CASCADE ON UPDATE CASCADE 其实不同的表关系在创建FOREIGN KEY时都有一些小差异，下面我们将举例几种最常见的表关系。 一对一 一对一关系例举： 一个学号只能对应一个学生，一个学生只能对应一个学号 一对一关系用2张表即可进行表达，注意从表（连接表）和主表（被连接表）的连接字段都必须具有唯一性约束，双向唯一就是一对一关系。 下面这张图中，studentsInfo表的fk字段可以连接studentsNumberInfo表的id字段或者number字段，但是为了查询时避免回表操作，所以让它连接到studentsNumberInfo表的PRIMARY KEY字段id是最明智的选择： 创建表关系示例： # 创建学号表 CREATE TABLE studentsNumberInfo( -- 被连接表的连接字段必须具有UNIQUE约束 id INT PRIMARY KEY AUTO_INCREMENT COMMENT '主键', number INT NOT NULL UNIQUE COMMENT \"学生编号\", admission DATE NOT NULL COMMENT \"入学时间\", graduation DATE NOT NULL COMMENT \"毕业时间\" ) ENGINE innodb CHARSET utf8mb4 COLLATE utf8mb4_general_ci; # 创建学生表 CREATE TABLE studentsInfo( id INT PRIMARY KEY AUTO_INCREMENT COMMENT '主键', name CHAR(64) NOT NULL COMMENT '学生姓名', gender ENUM(\"male\", \"female\") NOT NULL DEFAULT \"male\" COMMENT '学生性别', age TINYINT(3) UNSIGNED NOT NULL DEFAULT 18 COMMENT \"学生年龄\", -- 一对一关系必须为连接表的连接字段创建UNIQUE的约束，这样才能是一对一，否则是一对多 fk_student_id INT(4) NOT NULL UNIQUE COMMENT \"学生编号\", -- 创建外键关系 FOREIGN KEY stumsg_fk_stuid(fk_student_id) REFERENCES studentsNumberInfo(id) ON DELETE CASCADE ON UPDATE CASCADE ) ENGINE innodb CHARSET utf8mb4 COLLATE utf8mb4_general_ci; 尝试插入数据： # 向学号表插入记录 INSERT INTO studentsNumberInfo(number, admission, graduation) VALUES (160201, \"2016-09-01\", \"2021-06-15\"), (160101, \"2016-09-01\", \"2021-06-15\"), (160301, \"2016-09-01\", \"2021-06-15\"); # 向学生表插入记录 INSERT INTO studentsInfo(name, gender, age, fk_student_id) VALUES (\"Jack\", \"male\", 17, 1), (\"Tom\", \"male\", 18, 2), (\"Mary\", \"female\", 16, 3); 查询操作： SELECT si.name AS \"学生姓名\", sin.number AS \"学生学号\", si.gender AS \"学生性别\", si.age AS \"学生年龄\", sin.admission AS \"入学时间\", sin.graduation AS \"毕业时间\" FROM studentsInfo AS si INNER JOIN studentsNumberInfo AS sin ON(si.fk_student_id = sin.id); 查询结果： +--------------+--------------+--------------+--------------+--------------+--------------+ | 学生姓名 | 学生学号 | 学生性别 | 学生年龄 | 入学时间 | 毕业时间 | +--------------+--------------+--------------+--------------+--------------+--------------+ | Jack | 160201 | male | 17 | 2016-09-01 | 2021-06-15 | | Tom | 160101 | male | 18 | 2016-09-01 | 2021-06-15 | | Mary | 160301 | female | 16 | 2016-09-01 | 2021-06-15 | +--------------+--------------+--------------+--------------+--------------+--------------+ 一对多&多对一 一对多&多对一关系例举： 一个班级可以拥有多个学生，对班级来讲，班级和学生是一对多的关系 一个学生只能拥有一个班级，对学生来讲，学生和班级是多对一的关系 一对多&多对一关系用2张表即可表达，FOREIGN KEY可以建立在任意一方，通常情况下我们会选择记录多的一方，也就是学生表中建立，这在一些ORM框架中有利于后期的查询操作。 注意，从表（学生表）的连接字段一定不能有唯一性约束，而主表（班级表）的被连接字段必须拥有唯一性约束，这样才能建立一对多&多对一的关系。 下面这张图中，studentsInfo表的fk字段可以连接classesInfo表的任意字段，因为classesInfo表中的所有字段都有UNIQUE约束，但是为了查询时避免回表操作，所以让它连接到classesInfo表的PRIMARY KEY字段id是最明智的选择： 创建表关系示例： # 创建班级表 CREATE TABLE classesInfo( -- 被连接表的连接字段必须具有UNIQUE约束 id INT PRIMARY KEY AUTO_INCREMENT COMMENT \"主键\", number INT(4) NOT NULL UNIQUE COMMENT \"班级编号\", name CHAR(64) NOT NULL UNIQUE COMMENT \"班级名称\", lead CHAR(64) NOT NULL UNIQUE COMMENT \"班级负责人\" ) ENGINE innodb CHARSET utf8mb4 COLLATE utf8mb4_general_ci; # 创建学生表 CREATE TABLE studentsInfo( id INT PRIMARY KEY AUTO_INCREMENT COMMENT '主键', name CHAR(64) NOT NULL COMMENT '学生姓名', gender ENUM(\"male\", \"female\") NOT NULL DEFAULT \"male\" COMMENT '学生性别', age TINYINT(3) UNSIGNED NOT NULL DEFAULT 18 COMMENT \"学生年龄\", -- 相比于一对一，连接表的连接字段不用UNIQUE约束即为多对一关系 fk_class_id INT(4) NOT NULL COMMENT \"学生编号\", -- 创建外键关系 FOREIGN KEY student_fk_classes(fk_class_id) REFERENCES classesInfo(id) ON DELETE CASCADE ON UPDATE CASCADE ) ENGINE innodb CHARSET utf8mb4 COLLATE utf8mb4_general_ci; 尝试插入数据： # 向班级表插入记录 INSERT INTO classesInfo(number, name, lead) VALUES (1601, \"one year one class\", \"David\"), (1602, \"one year two class\", \"Jason\"), (1603, \"one year three class\", \"Lisa\"); # 向学生表插入记录 INSERT INTO studentsInfo(name, gender, age, fk_class_id) VALUES (\"Jack\", \"male\", 17, 2), (\"Tom\", \"male\", 18, 1), (\"Mary\", \"female\", 16, 3), (\"Anna\", \"female\", 17, 1), (\"Ken\", \"male\", 19, 3), (\"Bobb\", \"male\", 18, 2); 查询操作： SELECT cl.name AS \"班级名称\", cl.number AS \"班级编号\", cl.lead AS \"班级负责人\", GROUP_CONCAT(si.name) AS \"学生信息\" FROM classesInfo AS cl INNER JOIN studentsInfo AS si ON(cl.id = si.fk_class_id) GROUP BY cl.name, cl.number, cl.lead ORDER BY cl.number; 查询结果： +----------------------+--------------+-----------------+--------------+ | 班级名称 | 班级编号 | 班级负责人 | 学生信息 | +----------------------+--------------+-----------------+--------------+ | one year one class | 1601 | David | Tom,Anna | | one year two class | 1602 | Jason | Jack,Bobb | | one year three class | 1603 | Lisa | Mary,Ken | +----------------------+--------------+-----------------+--------------+ 多对多 多对多关系例举： 一个班级可以有多位教师，一位教师也可以在多个班级中任教 多对多关系必须用3张表才能表达，第3张表就是班级与教师的关系表，我们需要在这张中间表中建立2个FOREIGN KEY，并且需要将中间表对班级表classesInfo和教师表teachersInfo的FOREIGN KEY连接字段设置上一个联合唯一限制才能保证不会出现重复数据。 下面这张图中，classesAndTeachers表的fk字段可以连接到classesInfo表和teachersInfo表中的id字段和number字段，但是为了查询时避免回表操作，所以让它连接到2张表的PRIMARY KEY字段id是最明智的选择： 创建表关系示例，双向一对多，就是多对多： # 创建班级表 CREATE TABLE classesInfo( -- 被连接表的连接字段必须具有UNIQUE约束 id INT PRIMARY KEY AUTO_INCREMENT COMMENT \"主键\", number INT(4) NOT NULL UNIQUE COMMENT \"班级编号\", name CHAR(64) NOT NULL COMMENT \"班级名称\" ) ENGINE innodb CHARSET utf8mb4 COLLATE utf8mb4_general_ci; # 创建教师表 CREATE TABLE teachersInfo( -- 被连接表的连接字段必须具有UNIQUE约束 id INT PRIMARY KEY AUTO_INCREMENT COMMENT '主键', number INT(4) NOT NULL UNIQUE COMMENT \"教师编号\", name CHAR(64) NOT NULL COMMENT '教师姓名', gender ENUM(\"male\", \"female\") NOT NULL DEFAULT \"male\" COMMENT '教师性别', age TINYINT(3) UNSIGNED NOT NULL DEFAULT 18 COMMENT \"教师年龄\" ) ENGINE innodb CHARSET utf8mb4 COLLATE utf8mb4_general_ci; # 创建中间表 CREATE TABLE classesAndTeachersRelationship( id INT PRIMARY KEY AUTO_INCREMENT COMMENT \"主键\", -- 注意不要设置UNIQUE约束，否则就会变为一对一 fk_teacher_id INT(4) NOT NULL COMMENT \"教师记录\", fk_class_id INT(4) NOT NULL COMMENT \"班级记录\", -- 必须使用联合唯一约束，防止出现重复数据 UNIQUE KEY joint_teacher_and_class(fk_teacher_id, fk_class_id), -- 中间表的2个一对多，就是多对多 FOREIGN KEY fk_teacher(fk_teacher_id) REFERENCES teachersInfo(id), FOREIGN KEY fk_class(fk_class_id) REFERENCES classesInfo(id) ) ENGINE innodb CHARSET utf8mb4 COLLATE utf8mb4_general_ci; 尝试插入数据： # 插入班级表数据 INSERT INTO classesInfo(number, name) VALUES (1601, \"one year one class\"), (1602, \"one year two class\"), (1603, \"one year three class\"); # 插入教师表数据 INSERT INTO teachersInfo(number, name, gender, age) VALUES (3341, \"David\", \"male\", 32), (3342, \"Jason\", \"male\", 30), (3343, \"Lisa\", \"female\", 28); # 插入中间表数据 INSERT INTO classesAndTeachersRelationship(fk_class_id, fk_teacher_id) VALUES (1, 1), (2, 1), (3, 1), (1, 2), (3, 3); 查询操作： SELECT te.name AS \"教师姓名\", te.number AS \"教师编号\", te.gender AS \"教师性别\", te.age AS \"教师年龄\", GROUP_CONCAT(cl.name) AS \"任教班级\" FROM classesAndTeachersRelationship AS mid INNER JOIN classesInfo AS cl ON(mid.fk_class_id = cl.id) INNER JOIN teachersInfo AS te ON(mid.fk_teacher_id = te.id) GROUP BY te.number, te.name, te.age, te.gender; 查询结果： +--------------+--------------+--------------+--------------+------------------------------------------------------------+ | 教师姓名 | 教师编号 | 教师性别 | 教师年龄 | 任教班级 | +--------------+--------------+--------------+--------------+------------------------------------------------------------+ | David | 3341 | male | 32 | one year one class,one year two class,one year three class | | Jason | 3342 | male | 30 | one year one class | | Lisa | 3343 | female | 28 | one year three class | +--------------+--------------+--------------+--------------+------------------------------------------------------------+ 自关联 自关联是特殊的一种关系，即自己关联自己。 场景例举： 一个文章下可以有很多评论，这些评论又分为根评论和子评论，评论发起者也可以自己回复自己，那么这个时候就可以使用自关联建立关系。 创建自关联表格： CREATE TABLE comment( id INT PRIMARY KEY AUTO_INCREMENT COMMENT \"主键\", user CHAR(32) NOT NULL COMMENT \"评论者\", content CHAR(255) NOT NULL COMMENT \"评论内容\", content_time DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT \"评论时间\", -- 若为null、则是根评论、若不为null则是子评论，所以这里不要加NOT NULL的约束条件 -- 此外，也不要加UNIQUE的约束条件，因为一条评论可以拥有多个子评论 fk_comment INT COMMENT \"评论层级\", -- 删除根评论时，子评论也一并删除 FOREIGN KEY self_comment_id(fk_comment) REFERENCES comment(id) ON DELETE CASCADE ) ENGINE innodb CHARSET utf8mb4 COLLATE utf8mb4_general_ci; 尝试插入数据： # 插入根评论（一级） INSERT INTO comment(user, content, content_time) VALUES (\"Jack\", \"根评论\", \"2016-01-28 12:01:28\"); # 插入子评论（二级） INSERT INTO comment(user, content, content_time, fk_comment) VALUES (\"Ken\", \"回复Jack\", \"2019-12-28 17:52:43\", 1); # 插入子评论（三级） INSERT INTO comment(user, content, content_time, fk_comment) VALUES (\"Mary\", \"回复Ken\", \"2021-06-21 22:11:38\", 2); 查询操作： SELECT lt.user AS \"评论者\", lt.content AS \"评论内容\", lt.content_time AS \"评论时间\", rt.user AS \"回复者\", rt.content AS \"回复内容\", rt.content_time AS \"回复时间\" FROM comment AS lt LEFT JOIN comment AS rt ON (lt.id = rt.fk_comment) UNION SELECT lt.user AS \"评论者\", lt.content AS \"评论内容\", lt.content_time AS \"评论时间\", rt.user AS \"回复者\", rt.content AS \"回复内容\", rt.content_time AS \"回复时间\" FROM comment AS lt RIGHT JOIN comment AS rt ON (lt.id = rt.fk_comment); 查询结果，若评论者为NULL，则它的回复者为根评论，若回复者为NULL，则代表这是该楼评论中最后一条子评论： +-----------+--------------+---------------------+-----------+--------------+---------------------+ | 评论者 | 评论内容 | 评论时间 | 回复者 | 回复内容 | 回复时间 | +-----------+--------------+---------------------+-----------+--------------+---------------------+ | Jack | 根评论 | 2016-01-28 12:01:28 | Ken | 回复Jack | 2019-12-28 17:52:43 | | Ken | 回复Jack | 2019-12-28 17:52:43 | Mary | 回复Ken | 2021-06-21 22:11:38 | | Mary | 回复Ken | 2021-06-21 22:11:38 | NULL | NULL | NULL | | NULL | NULL | NULL | Jack | 根评论 | 2016-01-28 12:01:28 | +-----------+--------------+---------------------+-----------+--------------+---------------------+ ON UPDATE 级联更新，不光是对FOREIGN KEY的本表连接字段有用，对其他字段也同样适用，如DATETIME字段设置自动更新时间： 选项 说明 ON UPDATE CASCADE 更新父表记录时，比如更改父表的主键时，子表记录同时更新 ON UPDATE SET NULL 更新父表记录时，比如更改父表的主键时，子表记录设置为NULL ON UPDATE NO ACTION 更新父表记录时，子表不做任何处理，必须把子表处理完才可以更新主表 ON UPDATE RESTRICT 更新父表记录时，子表不做任何处理，必须把子表处理完才可以更新主表 ON DELETE 级联删除，常用处理方式如下表所示： 选项 说明 ON DELETE CASCADE 删除父表记录时，子表记录同时删除 ON DELETE SET NULL 删除父表记录时，子表记录设置为NULL（子表字段要允许NULL） ON DELETE NO ACTION 删除父表记录时，子表不做任何处理，必须把子表处理完才可以删除主表，否则会抛出异常 ON DELETE RESTRICT 删除父表记录时，子表不做任何处理，必须把子表处理完才可以删除主表，否则会抛出异常 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:48 "},"数据库专栏/MySQL/单表查询.html":{"url":"数据库专栏/MySQL/单表查询.html","title":"单表查询","keywords":"","body":"前戏工作 数据准备 单表查询相关数据准备： # 创建表格 CREATE TABLE userInfo( id INT PRIMARY KEY AUTO_INCREMENT COMMENT \"主键\", name CHAR(32) NOT NULL COMMENT \"用户姓名\", gender ENUM(\"male\", \"female\") NOT NULL DEFAULT \"male\" COMMENT \"用户性别\", age TINYINT(3) UNSIGNED NOT NULL DEFAULT 0 COMMENT \"用户年龄\", role ENUM(\"user\", \"admin\", \"boss\") NOT NULL DEFAULT \"user\" COMMENT \"用户角色\", fans_quantinty INT NOT NULL DEFAULT 0 COMMENT \"粉丝数量\", create_time DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT \"创建时间\", update_time DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT \"更新时间\", delete_status BOOLEAN NOT NULL DEFAULT false COMMENT \"是否注销\" ) ENGINE innodb CHARSET utf8mb4 COLLATE utf8mb4_general_ci; # 插入数据 INSERT INTO userInfo(name,gender,age,role,fans_quantinty,create_time,delete_status) VALUES (\"Julie\",\"male\",18,\"boss\",0,\"2002-01-28 19:18:22\",false), (\"Jack\",\"male\",21,\"admin\",2000,\"2006-03-05 08:30:00\",false), (\"David\",\"male\",18,\"admin\",3689,\"2004-02-21 14:30:00\",false), (\"Dairis\",\"female\",19,\"admin\",5232,\"2008-09-21 08:30:00\",false), (\"Kyle\",\"female\",21,\"user\",123021,\"2002-08-22 12:02:31\",true), (\"Alice\",\"female\",24,\"user\",293042,\"2010-03-07 23:02:21\",false), (\"Ken\",\"male\",23,\"user\",231,\"2020-11-13 09:06:32\",false), (\"Jason\",\"male\",22,\"user\",32132134,\"2002-02-01 12:32:45\",false), (\"Tom\",\"male\",28,\"user\",32,\"2021-01-01 02:30:21\",true), (\"Fiona\",\"female\",18,\"user\",321234,\"2012-05-28 19:21:32\",false); 查询语法 查询语法如下： SELECT DISTINCT(字段名1, 字段名2) FROM 库名.表名 WHERE 过滤条件 GROUP BY 分组字段名1, 分组字段名2, 分组字段名n, ... HAVING 筛选条件 ORDER BY 排序字段名1 ASC / DESC, 排序字段名2 ASC / DESC, 排序字段名3 ASC / DESC, ... LIMIT 限制条数; 注意，库名、WHERE、GROUP BY、HAVING、ORDER BY以及LIMIT都是可以省略的。 执行顺序 内部执行顺序如下： 通过FROM找到将要查询的表 WHERE规定查询的过滤条件，在表记录中逐行进行查询并过滤出符合查询规则的记录 将过滤到的记录信息按照字段进行GROUP BY分组，如果没有进行分组，则默认按照主键分为1组 将分组得到的结果进行HAVING筛选，此时可使用聚合函数。而WHERE时不可使用聚合函数 判断筛选后的记录数量是否满足LIMIT，如果满足则停止继续搜索，如果不满足则继续搜索直至满足LIMIT条件 执行SELECT准备打印 执行DISTINCT()函数对打印结果进行去重 执行ORDERY BY对结果进行排序，升序ASC，降序DESC 结合LIMIT进行SELECT打印 SELECT 功能概述 SELECT主要负责查询相关的工作。 除了查询记录表外，它也可以打印某些函数的执行结果，如下所示： SELECT DATABASE(); 全部查询 全部查询的语句格式如下，其中的*代表所有字段： SELECT * FROM 表名 示例演示： > SELECT * FROM userInfo; +----+--------+--------+-----+-------+----------------+---------------------+---------------------+---------------+ | id | name | gender | age | role | fans_quantinty | create_time | update_time | delete_status | +----+--------+--------+-----+-------+----------------+---------------------+---------------------+---------------+ | 1 | Julie | male | 18 | boss | 0 | 2002-01-28 19:18:22 | 2021-10-20 08:39:35 | 0 | | 2 | Jack | male | 21 | admin | 2000 | 2006-03-05 08:30:00 | 2021-10-20 08:39:35 | 0 | | 3 | David | male | 18 | admin | 3689 | 2004-02-21 14:30:00 | 2021-10-20 08:39:35 | 0 | | 4 | Dairis | female | 19 | admin | 5232 | 2008-09-21 08:30:00 | 2021-10-20 08:39:35 | 0 | | 5 | Kyle | female | 21 | user | 123021 | 2002-08-22 12:02:31 | 2021-10-20 08:39:35 | 1 | | 6 | Alice | female | 24 | user | 293042 | 2010-03-07 23:02:21 | 2021-10-20 08:39:35 | 0 | | 7 | Ken | male | 23 | user | 231 | 2020-11-13 09:06:32 | 2021-10-20 08:39:35 | 0 | | 8 | Jason | male | 22 | user | 32132134 | 2002-02-01 12:32:45 | 2021-10-20 08:39:35 | 0 | | 9 | Tom | male | 28 | user | 32 | 2021-01-01 02:30:21 | 2021-10-20 08:39:35 | 1 | | 10 | Fiona | female | 18 | user | 321234 | 2012-05-28 19:21:32 | 2021-10-20 08:39:35 | 0 | +----+--------+--------+-----+-------+----------------+---------------------+---------------------+---------------+ 字段查询 查询特定的字段名，可使用以下语法格式： SELECT 字段名1, 字段名2 FROM 表名; 示例演示，查询每个用户的粉丝数： > SELECT name, fans_quantinty FROM userInfo; +--------+----------------+ | name | fans_quantinty | +--------+----------------+ | Julie | 0 | | Jack | 2000 | | David | 3689 | | Dairis | 5232 | | Kyle | 123021 | | Alice | 293042 | | Ken | 231 | | Jason | 32132134 | | Tom | 32 | | Fiona | 321234 | +--------+----------------+ 别名使用 使用AS对字段进行别名定制，当查询结果的表格打印出来时您将看到表头的字段名被替换成了别名。 别名除开可以在SELECT语句中使用之外，多表查询时也经常会使用到，AS别名的使用格式如下： SELECT 字段名1 AS 别名1, 字段名2 AS 别名2 FROM 表名; 示例演示，查询每个用户的姓名，年龄，角色，注意观察结果表的表头： SELECT name AS \"用户姓名\", age AS \"用户年龄\", gender AS \"用户性别\", role AS \"用户角色\" FROM userInfo; +--------------+--------------+--------------+--------------+ | 用户姓名 | 用户年龄 | 用户性别 | 用户角色 | +--------------+--------------+--------------+--------------+ | Julie | 18 | male | boss | | Jack | 21 | male | admin | | David | 18 | male | admin | | Dairis | 19 | female | admin | | Kyle | 21 | female | user | | Alice | 24 | female | user | | Ken | 23 | male | user | | Jason | 22 | male | user | | Tom | 28 | male | user | | Fiona | 18 | female | user | +--------------+--------------+--------------+--------------+ DISTINCT() 使用DISTINCT()函数可对打印结果进行去重，重复的结果行会合并成一行。 如下示例将展示该表中拥有的所有用户角色名称： SELECT DISTINCT(role) AS \"用户角色\" FROM userInfo; +--------------+ | 用户角色 | +--------------+ | boss | | admin | | user | +--------------+ 四则运算 查询结果也可以进行四则运算，如下示例将演示该表中所有人的粉丝数+1000是多少： SELECT name AS \"用户姓名\", fans_quantinty + 1000 AS \"增加1000粉丝\" FROM userInfo; +--------------+------------------+ | 用户姓名 | 增加1000粉丝 | +--------------+------------------+ | Julie | 1000 | | Jack | 3000 | | David | 4689 | | Dairis | 6232 | | Kyle | 124021 | | Alice | 294042 | | Ken | 1231 | | Jason | 32133134 | | Tom | 1032 | | Fiona | 322234 | +--------------+------------------+ WHERE 功能概述 WHERE能够有效过滤出我们想要的任何数据，但是要注意语句优化的使用。 比如在比较运算中，尽量避免使用!=，少使用范围查询等操作。 以下是简单使用，过滤出id为1的记录： > SELECT * FROM userInfo WHERE id = 1; +----+-------+--------+-----+------+----------------+---------------------+---------------------+---------------+ | id | name | gender | age | role | fans_quantinty | create_time | update_time | delete_status | +----+-------+--------+-----+------+----------------+---------------------+---------------------+---------------+ | 1 | Julie | male | 18 | boss | 0 | 2002-01-28 19:18:22 | 2021-10-20 08:39:35 | 0 | +----+-------+--------+-----+------+----------------+---------------------+---------------------+---------------+ 比较运算 WHERE中支持的比较运算符如下所示： >：大于 >=：大于等于 !=：不等于 以下示例将展示过滤出粉丝大于10000的用户（该操作不建议使用，数据量过大时必定出现慢查询）： > SELECT name, fans_quantinty FROM userInfo WHERE fans_quantinty > 10000; +-------+----------------+ | name | fans_quantinty | +-------+----------------+ | Kyle | 123021 | | Alice | 293042 | | Jason | 32132134 | | Fiona | 321234 | +-------+----------------+ 逻辑运算 使用AND OR NOT可进行逻辑运算与多条件查询。 以下示例中将展示找到年龄大于18并且年龄小于20的用户（该操作不建议使用，数据量过大时必定出现慢查询）： > SELECT name, age FROM userInfo WHERE age > 18 AND age 注意，NOT也可以使用!来进行代替。 成员运算 IN IN可以在特定的值中进行获取，如IN(80, 90, 100)则代表只取80或者90或者100的这几条记录。 注意，能用 col IN (x, y) 查询的就不要用 col=x OR col=y 查询，因为OR查询的效率没有IN查询高 以下示例中将展示找到role为boss或admin的用户： > SELECT name FROM userInfo WHERE role IN (\"boss\", \"admin\"); +--------+ | name | +--------+ | Julie | | Jack | | David | | Dairis | +--------+ BETWEEN AND BETWEEN AND是取区间的意思。 与>=并且 注意，能用 col BETWEEN x AND x 查询的就不要用 col>=x AND col=x AND col 以下示例中将展示找到年龄大于等于20，且小于25的用户（该操作不建议使用，数据量过大时必定出现慢查询）： > SELECT name, age FROM userInfo WHERE age BETWEEN 20 AND 25; +-------+-----+ | name | age | +-------+-----+ | Jack | 21 | | Kyle | 21 | | Alice | 24 | | Ken | 23 | | Jason | 22 | +-------+-----+ 模糊查询 LIKE LIKE关键字后的表达式可以添加2个符号： _：代表任意一个字符，类似于正则中的.? %：代表任意多个字符，类似于正则中的.+? 一般来讲%的使用更加多一些，但是在使用%的时候一定要注意不要出现类似于%xx%这种前后都有百分号的语句，因为它不会走索引查询，所以性能极差。 以下示例将展示使用LIKE匹配出姓名以K开头的所有用户的名字（该操作不建议使用，数据量过大时必定出现慢查询）： > SELECT name FROM userInfo WHERE name LIKE \"K%\"; +------+ | name | +------+ | Kyle | | Ken | +------+ 正则查询 REGEXP 我们也可以在WHERE后跟上正则查询。 在使用时注意一点： mysql8版本以下不允许出现?的取消贪婪符号 以下示例将展示使用REGEXP匹配出姓名中带有K字符的所有用户的名字（该操作不建议使用，数据量过大时必定出现慢查询）： > SELECT name FROM userInfo WHERE name REGEXP \"K+\"; +------+ | name | +------+ | Jack | | Kyle | | Ken | +------+ GROUP BY 功能概述 分组行为发生在WHERE条件之后，我们可以将查询到的记录按照某个相同字段进行归类，一般分组都会配合聚合函数进行使用。 SELECT语句是排在GROUP BY条件之后的，因此聚合函数也能在SELECT语句中使用。 如果不使用GROUP BY语句进行分组，则默认会将所有记录分成一组！ 基本使用 以下示例将展示对role字段进行分组，并打印组中的组员名称： SELECT role, GROUP_CONCAT(name) FROM userInfo GROUP BY role; +-------+--------------------------------+ | role | GROUP_CONCAT(name) | +-------+--------------------------------+ | user | Kyle,Alice,Ken,Jason,Tom,Fiona | | admin | Jack,David,Dairis | | boss | Julie | +-------+--------------------------------+ 打印字段 我们需要注意，在MySQL5.7之后GROUP BY会受到分组模式的影响。 如果你想在SELECT后打印除分组条件字段外的其他字段时，必须采取一些必要的措施，否则将会抛出异常。 如下所示，GROUP BY之后的字段只有role，而要在SELECT后打印name字段的记录就会抛出异常： SELECT name, role FROM userInfo GROUP BY role; # ERROR 1055 (42000): Expression #1 of SELECT list is not in GROUP BY clause and contains nonaggregated column 'db1.userInfo.name' which is not functionally dependent on columns in GROUP BY clause; this is incompatible with sql_mode=only_full_group_by 解决方案1，修改分组模式，它只会显示组内第一个成员的信息，所以并不推荐： # 查看分组模式 SELECT @@GLOBAL.SQL_MODE; # 修改分组模式（当前会话有效） SET SESSION sql_mode='STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION'; # 开始查询 SELECT name, role FROM userInfo GROUP BY role; # 查询结果 +-------+-------+ | name | role | +-------+-------+ | Kyle | user | | Jack | admin | | Julie | boss | +-------+-------+ 解决方案2，使用ANY_VALUE()函数对其他字段进行包裹，它只会显示组内第一个成员的信息，所以并不推荐： # 开始查询 SELECT ANY_VALUE(name), role FROM userInfo GROUP BY role; # 查询结果 +-----------------+-------+ | ANY_VALUE(name) | role | +-----------------+-------+ | Kyle | user | | Jack | admin | | Julie | boss | +-----------------+-------+ 解决方案3，将需要SELECT打印的字段也添加到GROUP BY条件后，它会将每个成员信息都进行打印，结果会比较杂乱，故不推荐使用： # 开始查询 SELECT name, role FROM userInfo GROUP BY role, name; # 查询结果 +--------+-------+ | name | role | +--------+-------+ | Alice | user | | Fiona | user | | Jason | user | | Ken | user | | Kyle | user | | Tom | user | | Dairis | admin | | David | admin | | Jack | admin | | Julie | boss | +--------+-------+ 解决方案4，使用GROUP_CONCAT()函数对其他字段进行包裹，它会显示组内所有信息，推荐使用： # 开始查询 SELECT GROUP_CONCAT(name), role FROM userInfo GROUP BY role; # 查询结果 +--------------------------------+-------+ | GROUP_CONCAT(name) | role | +--------------------------------+-------+ | Kyle,Alice,Ken,Jason,Tom,Fiona | user | | Jack,David,Dairis | admin | | Julie | boss | +--------------------------------+-------+ 解决方案5，使用聚合函数对其他字段进行包裹，如求出每组的人数，这是最常用的，所以推荐使用： # 开始查询 SELECT role, count(id) FROM userInfo GROUP BY role; # 查询结果 +-------+-----------+ | role | count(id) | +-------+-----------+ | user | 6 | | admin | 3 | | boss | 1 | +-------+-----------+ 其实GROUP BY后的字段如果是主键或拥有NOT NULL UNIQUE约束时则可以在SELECT后列出其他字段而不必使用上述手段进行处理，如下所示，我们按id字段进行分组，就可以在SELECT后面列出其他非GROUP BY的字段： # 开始查询 SELECT name, role FROM userInfo GROUP BY id; # 查询结果 +--------+-------+ | name | role | +--------+-------+ | Julie | boss | | Jack | admin | | David | admin | | Dairis | admin | | Kyle | user | | Alice | user | | Ken | user | | Jason | user | | Tom | user | | Fiona | user | +--------+-------+ 聚合函数 聚合函数一般放在SELECT语句后和HAVING语句后使用。 注意：不使用分组，则默认为一组，所以也可以在SELECT语句后面使用聚合函数 聚合函数一般是同分组进行配套使用，以下是常用的聚合函数。 函数名 作用 COUNT() 对组内成员某一字段求个数 MAX() 对组内成员某一字段求最大值 MIN() 对组内成员某一字段求最小值 AVG() 对组内成员某一字段求平均值 SUM() 对组内成员某一字段求和 示例演示，不使用分组，默认为一组，我们可以求出所有人员的平均年纪： SELECT avg(age) FROM userInfo; +----------+ | avg(age) | +----------+ | 21.2000 | +----------+ 示例演示，按role进行分组，求出所有组的平均年纪： SELECT role, avg(age) FROM userInfo GROUP BY role; +-------+----------+ | role | avg(age) | +-------+----------+ | user | 22.6667 | | admin | 19.3333 | | boss | 18.0000 | +-------+----------+ 示例演示，按age进行分组，查看各个年龄段有多少人： SELECT age, count(id) FROM userInfo GROUP BY age; +-----+-----------+ | age | count(id) | +-----+-----------+ | 18 | 3 | | 19 | 1 | | 21 | 2 | | 22 | 1 | | 23 | 1 | | 24 | 1 | | 28 | 1 | +-----+-----------+ HAVING 聚合筛选 HAVING可以对分组后的数据进行筛选，和WHERE最大的区别就是它能够使用聚合函数进行记录筛选。 执行优先级从高到低：WHERE > LIMIT > GROUNP BY > HAVING，先分组，后HAVING过滤。 WHERE发生在分组GROUNP BY之前，因而WHERE中可以有任意字段，但是绝对不能使用聚合函数进行过滤 HAVING发生在分组GROUNP BY之后，因而HAVING中可以使用分组的字段，但无法直接获取到其他非分组字段，可以使用聚合函数进行筛选 如果不使用分组GROUNP BY而单纯使用HAVING并且同时使用聚合函数作为筛选的话，SELECT将会受到分组模式的影响，可查看上面章节进行解决 只拿到出role是ADMIN的用户，且归到一个组中： SELECT GROUP_CONCAT(name) FROM userInfo GROUP BY role HAVING role = \"ADMIN\"; +--------------------+ | GROUP_CONCAT(name) | +--------------------+ | Jack,David,Dairis | +--------------------+ ORDER BY 排序规则 默认排序是按照id进行排序，也就是主键。 它的比对规则是对比ASCII码来产生的。 排序可以有多重规则，当第一组规则不能比较出大小时，将会按照第二组规则进行比较。 ASC 升序排序，也是默认的排序规则，以下示例中将展示按照粉丝数量进行升序排序： SELECT name, fans_quantinty FROM userInfo ORDER BY fans_quantinty ASC; +--------+----------------+ | name | fans_quantinty | +--------+----------------+ | Julie | 0 | | Tom | 32 | | Ken | 231 | | Jack | 2000 | | David | 3689 | | Dairis | 5232 | | Kyle | 123021 | | Alice | 293042 | | Fiona | 321234 | | Jason | 32132134 | +--------+----------------+ DESC 降序排序，以下示例中将展示用户年龄进行降序排序，如年龄相同则按照粉丝数量进行比对： SELECT name, age, fans_quantinty FROM userInfo ORDER BY age DESC, fans_quantinty DESC; +--------+-----+----------------+ | name | age | fans_quantinty | +--------+-----+----------------+ | Tom | 28 | 32 | | Alice | 24 | 293042 | | Ken | 23 | 231 | | Jason | 22 | 32132134 | | Kyle | 21 | 123021 | | Jack | 21 | 2000 | | Dairis | 19 | 5232 | | Fiona | 18 | 321234 | | David | 18 | 3689 | | Julie | 18 | 0 | +--------+-----+----------------+ LIMIT 条数控制 LIMIT可以控制查询的条数，如果查询的条数满足LIMIT的条数，就不会继续扫描，所以适当的使用LIMIT能够提升查询效率。 以下示例中，将展示控制显示条目为1条，以此来获得表中年龄最小，粉丝最少的一个人： SELECT name, age, fans_quantinty FROM userInfo ORDER BY age DESC, fans_quantinty DESC LIMIT 1; +------+-----+----------------+ | name | age | fans_quantinty | +------+-----+----------------+ | Tom | 28 | 32 | +------+-----+----------------+ 结果截取 LIMIT的参数至多有2个，如下示例中我们将展示如何从表中第5条开始（不包含5）向后取3条数据。 它实际上会查询8条数据，前5条加上后3条： SELECT name, age, fans_quantinty FROM userInfo LIMIT 5, 3; +-------+-----+----------------+ | name | age | fans_quantinty | +-------+-----+----------------+ | Alice | 24 | 293042 | | Ken | 23 | 231 | | Jason | 22 | 32132134 | +-------+-----+----------------+ 性能分页 LIMIT如果有2个参数，实际上是可以做分页的。 如，我们每页有100行数据，当要获取第2页的数据时，你只需要： SELECT title FROM article LIMIT 100, 100; 但是这种性能是堪忧的，因为它总计会查200条数据。 最好的办法其实是根据id来获取数据，如下所示： SELECT title FROM article WHERE id > 100 LIMIT 100; 这样它只会查100条数据就获取到第二页的信息了，当分页过多时这种效率差会越来越明显。 如果分页功能过于复杂，你可以参照下面这篇文章： 别再用OFFSET和LIMIT分页了 一个BUG 如果你使用执行计划EXPLAIN来查看查询时加LIMIT和不加LIMIT的性能，所得到的的结果其实是不准确的，可以发现它们其实都是RANGE，包括ROWS也是一样的，事实真的如此吗？ 可以查看 mysql-expain-errors这篇文章，上面明确的有指出了这个BUG。 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:48 "},"数据库专栏/MySQL/多表查询.html":{"url":"数据库专栏/MySQL/多表查询.html","title":"多表查询","keywords":"","body":"前戏工作 数据准备 前期的多表查询我们使用2张表进行学习即可。 注意下面的2张表中并没有FOREIGN KEY对它们进行物理层面的约束，但是逻辑层面上这2张表是有关联的，因此在插入数据时必须小心，如果操纵不当可能会产生非法数据。 表结构如下所示： -- 创建部门表 CREATE TABLE department ( id INT PRIMARY KEY AUTO_INCREMENT COMMENT \"主键\", did INT UNIQUE NOT NULL COMMENT \"部门编号\", name CHAR(64) UNIQUE NOT NULL COMMENT \"部门名称\" ) ENGINE innodb CHARSET utf8mb4 COLLATE utf8mb4_general_ci; -- 创建员工表 CREATE TABLE staff ( id INT PRIMARY KEY AUTO_INCREMENT COMMENT \"主键\", sid INT UNIQUE NOT NULL COMMENT \"员工编号\", name CHAR(64) NOT NULL COMMENT \"员工姓名\", age TINYINT UNSIGNED NOT NULL DEFAULT 18 COMMENT \"员工年龄\", gender BOOLEAN NOT NULL DEFAULT 1 COMMENT \"员工性别\", salary DECIMAL(10, 2) NOT NULL DEFAULT 0 COMMENT \"员工薪资(月)\", department_id INT NOT NULL COMMENT \"所属部门\" ) ENGINE innodb CHARSET utf8mb4 COLLATE utf8mb4_general_ci; 表数据如下所示： INSERT INTO department(did, name) VALUES (100, \"Management\"), (200, \"Finance\"), (300, \"Technical\"), (400, \"Sales\"), (500, \"Logistics\"); INSERT INTO staff(sid, name, age, gender, salary, department_id) VALUES (1001, \"Jack\", 32, 1, 21000.00, 1), (1002, \"Tom\", 30, 1, 18300.00, 1), (1003, \"Ken\", 34, 1, 8000.00, 2), (1004, \"Anni\", 28, 0, 8000.00, 2), (1005, \"Benjamin\", 26, 1, 12000.00, 3), (1006, \"David\", 21, 1, 10000.00, 3), (1007, \"Mary\", 26, 0, 6800.00, 4), (1008, \"Jason\", 24, 1, 8000.00, 4), (9999, \"Tomson\", 38, 1, 99999.00, 0); -- 注意！Logistics（后勤部）没有任何员工 -- 而Tomson不属于任何部门，因为他是老板 查询语法 查询语法如下： SELECT DISTINCT(字段名1, 字段名2) FROM 库名.左表名 AS 表别名 连接类型 JOIN 库名.右表名 AS 表别名 ON(连接条件) WHERE 过滤条件 GROUP BY 分组字段名1, 分组字段名2, 分组字段名n, ... HAVING 筛选条件 ORDER BY 排序字段名1 ASC / DESC, 排序字段名2 ASC / DESC, 排序字段名3 ASC / DESC, ... LIMIT 限制条数; 注意，库名、JOIN、ON、WHERE、GROUP BY、HAVING、ORDER BY以及LIMIT都是可以省略的。 另外，多张表相连时应当确保用小表驱动大表，这样会使得查询效率提升N个档次。 执行顺序 在单表查询的基础上，多表查询多了一些查询的步骤，因此执行顺序也与单表查询有所不同。 通过FROM找到将要查询的左表，将左表进行记录，生成一张虚拟表 通过JOIN找到将要查询的右表，将右表进行记录，生成一张虚拟表 将2张虚拟表进行合并，生成一张笛卡尔积虚拟表 通过ON来过滤出笛卡尔积虚拟表中需要保留的字段 WHERE规定查询的过滤条件，在表记录中逐行进行查询并过滤出符合查询规则的记录 将过滤到的记录信息按照字段进行GROUP BY分组，如果没有进行分组，则默认按照主键分为1组 将分组得到的结果进行HAVING筛选，此时可使用聚合函数。而WHERE时不可使用聚合函数 判断筛选后的记录数量是否满足LIMIT，如果满足则停止继续搜索，如果不满足则继续搜索直至满足LIMIT条件 执行SELECT准备打印 执行DISTINCT()函数对打印结果进行去重 执行ORDERY BY对结果进行排序，升序ASC，降序DESC 结合LIMIT进行SELECT打印 连表前瞻 笛卡尔积表 将两张表同时进行查询时，会产生一张笛卡尔积表，该表存储于内存中。 笛卡尔积表是连表查询的基础，但是有很多无用的数据。 左表的每一行记录都会与右表中的每一行记录做一次连接 左表department有5条记录，右表staff有9条记录 生成的笛卡尔积表总共就有9*5条记录 示例如下，直接对2张表进行SELECT查询，不做任何处理，它将产生一张超大的表： > SELECT * FROM department, staff; +----+-----+------------+----+------+----------+-----+--------+----------+---------------+ | id | did | name | id | sid | name | age | gender | salary | department_id | +----+-----+------------+----+------+----------+-----+--------+----------+---------------+ | 1 | 100 | Management | 1 | 1001 | Jack | 32 | 1 | 21000.00 | 1 | | 2 | 200 | Finance | 1 | 1001 | Jack | 32 | 1 | 21000.00 | 1 | | 3 | 300 | Technical | 1 | 1001 | Jack | 32 | 1 | 21000.00 | 1 | | 4 | 400 | Sales | 1 | 1001 | Jack | 32 | 1 | 21000.00 | 1 | | 5 | 500 | Logistics | 1 | 1001 | Jack | 32 | 1 | 21000.00 | 1 | | 1 | 100 | Management | 2 | 1002 | Tom | 30 | 1 | 18300.00 | 1 | | 2 | 200 | Finance | 2 | 1002 | Tom | 30 | 1 | 18300.00 | 1 | | 3 | 300 | Technical | 2 | 1002 | Tom | 30 | 1 | 18300.00 | 1 | | 4 | 400 | Sales | 2 | 1002 | Tom | 30 | 1 | 18300.00 | 1 | | 5 | 500 | Logistics | 2 | 1002 | Tom | 30 | 1 | 18300.00 | 1 | | 1 | 100 | Management | 3 | 1003 | Ken | 34 | 1 | 8000.00 | 2 | | 2 | 200 | Finance | 3 | 1003 | Ken | 34 | 1 | 8000.00 | 2 | | 3 | 300 | Technical | 3 | 1003 | Ken | 34 | 1 | 8000.00 | 2 | | 4 | 400 | Sales | 3 | 1003 | Ken | 34 | 1 | 8000.00 | 2 | | 5 | 500 | Logistics | 3 | 1003 | Ken | 34 | 1 | 8000.00 | 2 | | 1 | 100 | Management | 4 | 1004 | Anni | 28 | 0 | 8000.00 | 2 | | 2 | 200 | Finance | 4 | 1004 | Anni | 28 | 0 | 8000.00 | 2 | | 3 | 300 | Technical | 4 | 1004 | Anni | 28 | 0 | 8000.00 | 2 | | 4 | 400 | Sales | 4 | 1004 | Anni | 28 | 0 | 8000.00 | 2 | | 5 | 500 | Logistics | 4 | 1004 | Anni | 28 | 0 | 8000.00 | 2 | | 1 | 100 | Management | 5 | 1005 | Benjamin | 26 | 1 | 12000.00 | 3 | | 2 | 200 | Finance | 5 | 1005 | Benjamin | 26 | 1 | 12000.00 | 3 | | 3 | 300 | Technical | 5 | 1005 | Benjamin | 26 | 1 | 12000.00 | 3 | | 4 | 400 | Sales | 5 | 1005 | Benjamin | 26 | 1 | 12000.00 | 3 | | 5 | 500 | Logistics | 5 | 1005 | Benjamin | 26 | 1 | 12000.00 | 3 | | 1 | 100 | Management | 6 | 1006 | David | 21 | 1 | 10000.00 | 3 | | 2 | 200 | Finance | 6 | 1006 | David | 21 | 1 | 10000.00 | 3 | | 3 | 300 | Technical | 6 | 1006 | David | 21 | 1 | 10000.00 | 3 | | 4 | 400 | Sales | 6 | 1006 | David | 21 | 1 | 10000.00 | 3 | | 5 | 500 | Logistics | 6 | 1006 | David | 21 | 1 | 10000.00 | 3 | | 1 | 100 | Management | 7 | 1007 | Mary | 26 | 0 | 6800.00 | 4 | | 2 | 200 | Finance | 7 | 1007 | Mary | 26 | 0 | 6800.00 | 4 | | 3 | 300 | Technical | 7 | 1007 | Mary | 26 | 0 | 6800.00 | 4 | | 4 | 400 | Sales | 7 | 1007 | Mary | 26 | 0 | 6800.00 | 4 | | 5 | 500 | Logistics | 7 | 1007 | Mary | 26 | 0 | 6800.00 | 4 | | 1 | 100 | Management | 8 | 1008 | Jason | 24 | 1 | 8000.00 | 4 | | 2 | 200 | Finance | 8 | 1008 | Jason | 24 | 1 | 8000.00 | 4 | | 3 | 300 | Technical | 8 | 1008 | Jason | 24 | 1 | 8000.00 | 4 | | 4 | 400 | Sales | 8 | 1008 | Jason | 24 | 1 | 8000.00 | 4 | | 5 | 500 | Logistics | 8 | 1008 | Jason | 24 | 1 | 8000.00 | 4 | | 1 | 100 | Management | 9 | 9999 | Tomson | 38 | 1 | 99999.00 | 0 | | 2 | 200 | Finance | 9 | 9999 | Tomson | 38 | 1 | 99999.00 | 0 | | 3 | 300 | Technical | 9 | 9999 | Tomson | 38 | 1 | 99999.00 | 0 | | 4 | 400 | Sales | 9 | 9999 | Tomson | 38 | 1 | 99999.00 | 0 | | 5 | 500 | Logistics | 9 | 9999 | Tomson | 38 | 1 | 99999.00 | 0 | +----+-----+------------+----+------+----------+-----+--------+----------+---------------+ WHERE连表 笛卡尔积表的数据非常全面，我们可以针对笛卡尔积表做出一些条件限制使其能够筛选过滤出我们想要的数据。 如下示例，在笛卡尔积表的基础上增加WHERE条件过滤，剔除无用的数据： SELECT * FROM department AS l, staff AS r WHERE l.id = r.department_id; +----+-----+------------+----+------+----------+-----+--------+----------+---------------+ | id | did | name | id | sid | name | age | gender | salary | department_id | +----+-----+------------+----+------+----------+-----+--------+----------+---------------+ | 1 | 100 | Management | 1 | 1001 | Jack | 32 | 1 | 21000.00 | 1 | | 1 | 100 | Management | 2 | 1002 | Tom | 30 | 1 | 18300.00 | 1 | | 2 | 200 | Finance | 3 | 1003 | Ken | 34 | 1 | 8000.00 | 2 | | 2 | 200 | Finance | 4 | 1004 | Anni | 28 | 0 | 8000.00 | 2 | | 3 | 300 | Technical | 5 | 1005 | Benjamin | 26 | 1 | 12000.00 | 3 | | 3 | 300 | Technical | 6 | 1006 | David | 21 | 1 | 10000.00 | 3 | | 4 | 400 | Sales | 7 | 1007 | Mary | 26 | 0 | 6800.00 | 4 | | 4 | 400 | Sales | 8 | 1008 | Jason | 24 | 1 | 8000.00 | 4 | +----+-----+------------+----+------+----------+-----+--------+----------+---------------+ WHERE缺点 使用WHERE的确可以做到连表查询并且能够剔除笛卡尔积表中无用的数据，但此种方式并不建议进行使用，因为它还存在一些小BUG，比如： department里的Logistics（后勤部）拿不出来 右表staff里的Tomson也拿不出来 另外，WHERE条件我们如果只对其进行笛卡尔积表的过滤那未免太过浪费，WHERE应该是对无重复数据记录的笛卡尔积表再次进行二次过滤所使用的。 换而言之，我们不应该使用WHERE过滤来做连表的过滤条件，而是使用WHERE做一些额外的过滤条件。 因此，MySQL为我们提供了专门用于连表的JOIN ON语句，其中JOIN用于指定连表方式、ON用于指定过滤笛卡尔积表的条件。 所以，忘记WHERE连表查询吧。 连接查询 INNER JOIN INNER JOIN即内连接查询，可简写为JOIN。 它的特点是只能拿到左表和右表中共有的部分，这与上面的WHERE连表查询拿到的数据是相同的。 SELECT * FROM department AS l INNER JOIN staff AS r ON (l.id = r.department_id); +----+-----+------------+----+------+----------+-----+--------+----------+---------------+ | id | did | name | id | sid | name | age | gender | salary | department_id | +----+-----+------------+----+------+----------+-----+--------+----------+---------------+ | 1 | 100 | Management | 1 | 1001 | Jack | 32 | 1 | 21000.00 | 1 | | 1 | 100 | Management | 2 | 1002 | Tom | 30 | 1 | 18300.00 | 1 | | 2 | 200 | Finance | 3 | 1003 | Ken | 34 | 1 | 8000.00 | 2 | | 2 | 200 | Finance | 4 | 1004 | Anni | 28 | 0 | 8000.00 | 2 | | 3 | 300 | Technical | 5 | 1005 | Benjamin | 26 | 1 | 12000.00 | 3 | | 3 | 300 | Technical | 6 | 1006 | David | 21 | 1 | 10000.00 | 3 | | 4 | 400 | Sales | 7 | 1007 | Mary | 26 | 0 | 6800.00 | 4 | | 4 | 400 | Sales | 8 | 1008 | Jason | 24 | 1 | 8000.00 | 4 | +----+-----+------------+----+------+----------+-----+--------+----------+---------------+ LEFT JOIN LEFT JOIN即左连接查询。 它的特点是除了能拿到左表和右表中共有的部分之外还可以拿到左表独有的部分。 如下所示，通过左连接查询，可以拿出左表department中的Logistics部门： SELECT * FROM department AS l LEFT JOIN staff AS r ON (l.id = r.department_id); +----+-----+------------+------+------+----------+------+--------+----------+---------------+ | id | did | name | id | sid | name | age | gender | salary | department_id | +----+-----+------------+------+------+----------+------+--------+----------+---------------+ | 1 | 100 | Management | 1 | 1001 | Jack | 32 | 1 | 21000.00 | 1 | | 1 | 100 | Management | 2 | 1002 | Tom | 30 | 1 | 18300.00 | 1 | | 2 | 200 | Finance | 3 | 1003 | Ken | 34 | 1 | 8000.00 | 2 | | 2 | 200 | Finance | 4 | 1004 | Anni | 28 | 0 | 8000.00 | 2 | | 3 | 300 | Technical | 5 | 1005 | Benjamin | 26 | 1 | 12000.00 | 3 | | 3 | 300 | Technical | 6 | 1006 | David | 21 | 1 | 10000.00 | 3 | | 4 | 400 | Sales | 7 | 1007 | Mary | 26 | 0 | 6800.00 | 4 | | 4 | 400 | Sales | 8 | 1008 | Jason | 24 | 1 | 8000.00 | 4 | | 5 | 500 | Logistics | NULL | NULL | NULL | NULL | NULL | NULL | NULL | +----+-----+------------+------+------+----------+------+--------+----------+---------------+ RIGHT JOIN RIGHT JOIN即右连接查询。 它的特点是除了能拿到左表和右表中共有的部分之外还可以拿到右表独有的部分。 如下所示，通过右连接查询，可以拿出右表staff中的Tomson信息： SELECT * FROM department AS l RIGHT JOIN staff AS r ON (l.id = r.department_id); +------+------+------------+----+------+----------+-----+--------+----------+---------------+ | id | did | name | id | sid | name | age | gender | salary | department_id | +------+------+------------+----+------+----------+-----+--------+----------+---------------+ | 1 | 100 | Management | 1 | 1001 | Jack | 32 | 1 | 21000.00 | 1 | | 1 | 100 | Management | 2 | 1002 | Tom | 30 | 1 | 18300.00 | 1 | | 2 | 200 | Finance | 3 | 1003 | Ken | 34 | 1 | 8000.00 | 2 | | 2 | 200 | Finance | 4 | 1004 | Anni | 28 | 0 | 8000.00 | 2 | | 3 | 300 | Technical | 5 | 1005 | Benjamin | 26 | 1 | 12000.00 | 3 | | 3 | 300 | Technical | 6 | 1006 | David | 21 | 1 | 10000.00 | 3 | | 4 | 400 | Sales | 7 | 1007 | Mary | 26 | 0 | 6800.00 | 4 | | 4 | 400 | Sales | 8 | 1008 | Jason | 24 | 1 | 8000.00 | 4 | | NULL | NULL | NULL | 9 | 9999 | Tomson | 38 | 1 | 99999.00 | 0 | +------+------+------------+----+------+----------+-----+--------+----------+---------------+ FULL OUTER JOIN FULL OUTER JOIN即全外连接查询。 它的特点是除了能拿到左表和右表中共有的部分之外还可以拿到左表以及右表中独有的部分。 通过全外连接查询，可以拿出左表department中的Logistics部门以及右表staff中的Tomson信息，但是很遗憾，MySQL并不支持这种用法： SELECT * FROM department AS l FULL OUT JOIN staff AS r ON (l.id = r.department_id); ERROR 1064 (42000): You have an error in your SQL syntax; 拼接查询 UNION & UNION ALL UNION与UNION ALL都是对查询出的两张表结果做拼接使用的。 他们的区别如下： UNION会过滤重复的结果 UNION ALL不会过滤重复的结果 使用这种拼接查询，一定要确保每个查询返回的列的数量与顺序要一样。 使用语法如下： SELECT * FROM tb1 UNION SELECT * FROM tb2 LIMIT 5; 模拟全外连接 尽管MySQL中不支持全外链接查询，但是我们可以使用LEFT JOIN与RIGHT JOIN配合拼接查询UNION来做出 FULL OUTER JOIN的效果，如下所示： SELECT * FROM department AS l LEFT JOIN staff AS r ON (l.id = r.department_id) UNION SELECT * FROM department AS l RIGHT JOIN staff AS r ON (l.id = r.department_id); +------+------+------------+------+------+----------+------+--------+----------+---------------+ | id | did | name | id | sid | name | age | gender | salary | department_id | +------+------+------------+------+------+----------+------+--------+----------+---------------+ | 1 | 100 | Management | 1 | 1001 | Jack | 32 | 1 | 21000.00 | 1 | | 1 | 100 | Management | 2 | 1002 | Tom | 30 | 1 | 18300.00 | 1 | | 2 | 200 | Finance | 3 | 1003 | Ken | 34 | 1 | 8000.00 | 2 | | 2 | 200 | Finance | 4 | 1004 | Anni | 28 | 0 | 8000.00 | 2 | | 3 | 300 | Technical | 5 | 1005 | Benjamin | 26 | 1 | 12000.00 | 3 | | 3 | 300 | Technical | 6 | 1006 | David | 21 | 1 | 10000.00 | 3 | | 4 | 400 | Sales | 7 | 1007 | Mary | 26 | 0 | 6800.00 | 4 | | 4 | 400 | Sales | 8 | 1008 | Jason | 24 | 1 | 8000.00 | 4 | | 5 | 500 | Logistics | NULL | NULL | NULL | NULL | NULL | NULL | NULL | | NULL | NULL | NULL | 9 | 9999 | Tomson | 38 | 1 | 99999.00 | 0 | +------+------+------------+------+------+----------+------+--------+----------+---------------+ 子查询 快速上手 子查询是将一个查询语句嵌套在另一个查询语句中。 因为每一次的查询结果都可以当作一个在内存中的临时表来进行看待，所以我们可以在这张临时表的基础上再次进行查询。 子查询中可以包含：IN、NOT IN、ANY、ALL、EXISTS和NOT EXISTS等关键字，还可以包含比较运算符：= 、!=、> 、 子查询示例，查询Technical部门的员工信息： SELECT * FROM staff WHERE department_id = ( SELECT id FROM department WHERE name = \"Technical\" ); +----+------+----------+-----+--------+----------+---------------+ | id | sid | name | age | gender | salary | department_id | +----+------+----------+-----+--------+----------+---------------+ | 5 | 1005 | Benjamin | 26 | 1 | 12000.00 | 3 | | 6 | 1006 | David | 21 | 1 | 10000.00 | 3 | +----+------+----------+-----+--------+----------+---------------+ 子查询示例，查询薪资最高的部门： SELECT * FROM department WHERE id = ( SELECT department_id FROM staff WHERE name != \"Tomson\" -- 排除Tomson老板 GROUP BY department_id ORDER BY sum(salary) DESC LIMIT 1 ); +----+-----+------------+ | id | did | name | +----+-----+------------+ | 1 | 100 | Management | +----+-----+------------+ 子查询示例，查询没人的部门： SELECT * FROM department WHERE id NOT IN ( SELECT DISTINCT(department_id) FROM staff ); +----+-----+-----------+ | id | did | name | +----+-----+-----------+ | 5 | 500 | Logistics | +----+-----+-----------+ 子查询示例，查询没加入部门的人，即老板： SELECT * FROM staff WHERE department_id NOT IN ( SELECT DISTINCT(id) FROM department ); +----+------+--------+-----+--------+----------+---------------+ | id | sid | name | age | gender | salary | department_id | +----+------+--------+-----+--------+----------+---------------+ | 9 | 9999 | Tomson | 38 | 1 | 99999.00 | 0 | +----+------+--------+-----+--------+----------+---------------+ EXISTS EXISTS在子查询中都是跟在外部查询的WHERE条件之后，用于关注此次子查询结果是否为真。 如果此次子查询结果为真，则执行外部查询，否则将不会执行。 以下有一个例子非常不错，总公司的领导视察工作，如果所有员工平均薪资大于一万，则看一眼工资大于一万的员工们都有谁，如果不大于一万就不看。 SELECT * FROM staff WHERE EXISTS ( -- 条件1，判断平均工资是否大于1w，不包含老板汤姆逊 SELECT avg(salary) FROM staff WHERE name != \"Tomson\" ) -- 条件2，只查看高于1w薪资的员工 AND salary > 10000 -- 条件3，不查看老板汤姆逊 AND name != \"Tomson\"; +----+------+----------+-----+--------+----------+---------------+ | id | sid | name | age | gender | salary | department_id | +----+------+----------+-----+--------+----------+---------------+ | 1 | 1001 | Jack | 32 | 1 | 21000.00 | 1 | | 2 | 1002 | Tom | 30 | 1 | 18300.00 | 1 | | 5 | 1005 | Benjamin | 26 | 1 | 12000.00 | 3 | +----+------+----------+-----+--------+----------+---------------+ 新手上路 新手如何优雅的书写子查询呢？你可以从2个方面入手。 我们举一个例子： 查询Technical部门的员工信息 方法1，适合老鸟： 首先确定，我们要查询的最终结果是员工信息，所以可以直接SELECT * FROM staff 其次条件是部门必须是Technical，故可以在上面的语句基础上增加WHERE条件、staff表中的链接字段是department_id，所以可以写成WHERE department_id = () 然后再来书写括号内的内容，直接查询department表即可，SELECT id FROM department WHERE name = \"Technical” 最终结果： SELECT * FROM staff WHERE department_id = (SELECT id FROM department WHERE name = \"Technical\"); 方法2，更常用： 首先确定，我们要从department开始查询，直接书写括号内的内容SELECT id FROM department WHERE name = \"Technical” 然后再写外部的内容，SELECT * FROM staff WHERE department_id = () 最终结果： SELECT * FROM staff WHERE department_id = (SELECT id FROM department WHERE name = \"Technical\"); 自连接 快速上手 自连接SELF JOIN是建立在子查询以及连接查询基础之上，即在上一次查询自己的记录中再连接并查询一次自己。 因为每次的查询都会在内存中建立一张临时表，所以我们可以JOIN这张临时表并且用AS为这张临时表取一个别名。 如下示例将展示查询每个部门中工资最少的员工信息。 SELECT r.name, l.min_salary, l.dname FROM ( SELECT min(staff.salary) AS min_salary, department.id AS did, department.name AS dname FROM department INNER JOIN staff ON staff.department_id = department.id GROUP BY department.id ) AS l INNER JOIN staff AS r ON l.did = r.department_id WHERE l.min_salary = r.salary; +-------+------------+------------+ | name | min_salary | dname | +-------+------------+------------+ | Tom | 18300.00 | Management | | Ken | 8000.00 | Finance | | Anni | 8000.00 | Finance | | David | 10000.00 | Technical | | Mary | 6800.00 | Sales | +-------+------------+------------+ 流程分析 第一步，写子查询，拿到每组中最少的薪资，并且为这张虚拟表取名为l，它会向外暴露3个字段、min_salary、department.id和department.name。 其中min_salary、department.id用于做条件约束，如下所示我们可以拿到每个部门中最低的薪资、部门的id和部门的名称： ( SELECT min(staff.salary) AS min_salary, department.id AS did, department.name AS dname FROM department INNER JOIN staff ON staff.department_id = department.id GROUP BY department.id ); +------------+-----+------------+ | min_salary | did | dname | +------------+-----+------------+ | 18300.00 | 1 | Management | | 8000.00 | 2 | Finance | | 10000.00 | 3 | Technical | | 6800.00 | 4 | Sales | +------------+-----+------------+ 第二步，使用INNER JOIN进行连接查询，将表l与表r相连，拿到共有的部分，通过薪资以及部门编号过滤出人员姓名： SELECT r.name, l.min_salary, l.dname FROM ( SELECT min(staff.salary) AS min_salary, department.id AS did, department.name AS dname FROM department INNER JOIN staff ON staff.department_id = department.id GROUP BY department.id ) AS l INNER JOIN staff AS r ON l.did = r.department_id WHERE l.min_salary = r.salary; +-------+------------+------------+ | name | min_salary | dname | +-------+------------+------------+ | Tom | 18300.00 | Management | | Ken | 8000.00 | Finance | | Anni | 8000.00 | Finance | | David | 10000.00 | Technical | | Mary | 6800.00 | Sales | +-------+------------+------------+ 多表练习 五表数据 在实际生产中，所连的表最多应该不超过5张，所以我们就以5表关系来练习多表查询。 五表关系： 建表语句： -- 创建学号表 CREATE TABLE studentsNumberInfo( -- 被连接表的连接字段必须具有UNIQUE约束 id INT PRIMARY KEY AUTO_INCREMENT COMMENT '主键', number INT NOT NULL UNIQUE COMMENT \"学生编号\", admission DATE NOT NULL COMMENT \"入学时间\", graduation DATE NOT NULL COMMENT \"毕业时间\" ) ENGINE innodb CHARSET utf8mb4 COLLATE utf8mb4_general_ci; -- 创建教师表 CREATE TABLE teachersInfo( -- 被连接表的连接字段必须具有UNIQUE约束 id INT PRIMARY KEY AUTO_INCREMENT COMMENT '主键', number INT(4) NOT NULL UNIQUE COMMENT \"教师编号\", name CHAR(64) NOT NULL COMMENT '教师姓名', gender ENUM(\"male\", \"female\") NOT NULL DEFAULT \"male\" COMMENT '教师性别', age TINYINT(3) UNSIGNED NOT NULL DEFAULT 18 COMMENT \"教师年龄\" ) ENGINE innodb CHARSET utf8mb4 COLLATE utf8mb4_general_ci; -- 创建班级表 CREATE TABLE classesInfo( -- 被连接表的连接字段必须具有UNIQUE约束 id INT PRIMARY KEY AUTO_INCREMENT COMMENT \"主键\", number INT(4) NOT NULL UNIQUE COMMENT \"班级编号\", name CHAR(64) NOT NULL UNIQUE COMMENT \"班级名称\", -- 一对一关系必须为连接表的连接字段创建UNIQUE的约束，这样才能是一对一，否则是一对多 fk_teacher_id INT(4) NOT NULL UNIQUE COMMENT \"班级负责人\", -- 创建外键关系 FOREIGN KEY class_fk_teacher(fk_teacher_id) REFERENCES teachersInfo(id) ON DELETE CASCADE ON UPDATE CASCADE ) ENGINE innodb CHARSET utf8mb4 COLLATE utf8mb4_general_ci; -- 创建中间表 CREATE TABLE classesAndTeachersRelationship( id INT PRIMARY KEY AUTO_INCREMENT COMMENT \"主键\", -- 注意不要设置UNIQUE约束，否则就会变为一对一 fk_teacher_id INT(4) NOT NULL COMMENT \"教师记录\", fk_class_id INT(4) NOT NULL COMMENT \"班级记录\", -- 必须使用联合唯一约束，防止出现重复数据 UNIQUE KEY joint_teacher_and_class(fk_teacher_id, fk_class_id), -- 中间表的2个一对多，就是多对多 FOREIGN KEY fk_teacher(fk_teacher_id) REFERENCES teachersInfo(id), FOREIGN KEY fk_class(fk_class_id) REFERENCES classesInfo(id) ) ENGINE innodb CHARSET utf8mb4 COLLATE utf8mb4_general_ci; -- 创建学生表 CREATE TABLE studentsInfo( id INT PRIMARY KEY AUTO_INCREMENT COMMENT '主键', name CHAR(64) NOT NULL COMMENT '学生姓名', gender ENUM(\"male\", \"female\") NOT NULL DEFAULT \"male\" COMMENT '学生性别', age TINYINT(3) UNSIGNED NOT NULL DEFAULT 18 COMMENT \"学生年龄\", -- 一对一关系必须为连接表的连接字段创建UNIQUE的约束，这样才能是一对一，否则是一对多 fk_student_id INT(4) NOT NULL UNIQUE COMMENT \"学生编号\", -- 相比于一对一，连接表的连接字段不用UNIQUE约束即为多对一关系 fk_class_id INT(4) NOT NULL COMMENT \"学生编号\", -- 创建外键关系 FOREIGN KEY stumsg_fk_stuid(fk_student_id) REFERENCES studentsNumberInfo(id) ON DELETE CASCADE ON UPDATE CASCADE, FOREIGN KEY student_fk_classes(fk_class_id) REFERENCES classesInfo(id) ON DELETE CASCADE ON UPDATE CASCADE ) ENGINE innodb CHARSET utf8mb4 COLLATE utf8mb4_general_ci; 插入数据： -- 插入学号表数据 INSERT INTO studentsNumberInfo(number, admission, graduation) VALUES (160201, \"2016-09-01\", \"2021-06-15\"), (160101, \"2016-09-01\", \"2021-06-15\"), (160301, \"2016-09-01\", \"2021-06-15\"), (160102, \"2016-09-01\", \"2021-06-15\"), (160302, \"2016-09-01\", \"2021-06-15\"), (160202, \"2016-09-01\", \"2021-06-15\"); -- 插入教师表数据 INSERT INTO teachersInfo(number, name, gender, age) VALUES (3341, \"David\", \"male\", 32), (3342, \"Jason\", \"male\", 30), (3343, \"Lisa\", \"female\", 28); -- 插入班级表数据 INSERT INTO classesInfo(number, name, fk_teacher_id) VALUES (1601, \"one year one class\", 1), (1602, \"one year two class\", 2), (1603, \"one year three class\", 3); -- 插入中间表数据 INSERT INTO classesAndTeachersRelationship(fk_class_id, fk_teacher_id) VALUES (1, 1), (2, 1), (3, 1), (1, 2), (3, 3); -- 插入学生表数据 INSERT INTO studentsInfo(name, gender, age, fk_student_id, fk_class_id) VALUES (\"Jack\", \"male\", 17, 1, 2), (\"Tom\", \"male\", 18, 2, 1), (\"Mary\", \"female\", 16, 3, 3), (\"Anna\", \"female\", 17, 4, 1), (\"Ken\", \"male\", 19, 5, 3), (\"Bobby\", \"male\", 18, 6, 2); 查询案例 1）查看每个班级共有多少学生： SELECT classesInfo.name, count(studentsInfo.id) FROM classesInfo INNER JOIN studentsInfo ON classesInfo.id = studentsInfo.fk_class_id GROUP BY studentsInfo.fk_class_id; +----------------------+------------------------+ | name | count(studentsInfo.id) | +----------------------+------------------------+ | one year one class | 2 | | one year two class | 2 | | one year three class | 2 | +----------------------+------------------------+ 2）查看每个学生的入学、毕业年份以及所在的班级名称： SELECT sn.number AS student_number, s.name AS student_name, c.name AS student_class, sn.admission AS student_admission, sn.graduation AS student_graduation FROM classesInfo AS c INNER JOIN studentsInfo AS s ON c.id = s.fk_class_id INNER JOIN studentsNumberInfo AS sn ON sn.id = s.fk_student_id ORDER BY sn.number ASC; +----------------+--------------+----------------------+-------------------+--------------------+ | student_number | student_name | student_class | student_admission | student_graduation | +----------------+--------------+----------------------+-------------------+--------------------+ | 160101 | Tom | one year one class | 2016-09-01 | 2021-06-15 | | 160102 | Anna | one year one class | 2016-09-01 | 2021-06-15 | | 160201 | Jack | one year two class | 2016-09-01 | 2021-06-15 | | 160202 | Bobby | one year two class | 2016-09-01 | 2021-06-15 | | 160301 | Mary | one year three class | 2016-09-01 | 2021-06-15 | | 160302 | Ken | one year three class | 2016-09-01 | 2021-06-15 | +----------------+--------------+----------------------+-------------------+--------------------+ 3）查看David所教授的学生中年龄最小的学生： SELECT t.name AS teacher_name, s.name AS student_name, s.age AS student_age, c.name AS student_class FROM classesInfo AS c INNER JOIN classesAndTeachersRelationship AS mid ON mid.fk_class_id = c.id INNER JOIN teachersInfo AS t ON mid.fk_teacher_id = t.id INNER JOIN studentsInfo AS s ON s.fk_class_id = c.id WHERE t.name = \"David\" ORDER BY s.age ASC, s.id ASC LIMIT 1; +--------------+--------------+-------------+----------------------+ | teacher_name | student_name | student_age | student_class | +--------------+--------------+-------------+----------------------+ | David | Mary | 16 | one year three class | +--------------+--------------+-------------+----------------------+ 4）查看每个班级的负责人是谁，以及任课老师都有谁： SELECT c.name AS class_name, t.name AS principal_name, any.have_teacher AS have_teachers FROM -- 查班主任 classesInfo AS c INNER JOIN teachersInfo AS t ON c.fk_teacher_id = t.id -- 查任课老师 INNER JOIN ( SELECT mid.fk_class_id AS class_id, GROUP_CONCAT(teacherRight.name) AS have_teacher FROM classesInfo AS classLeft INNER JOIN classesAndTeachersRelationship AS mid ON mid.fk_class_id = classLeft.id INNER JOIN teachersInfo AS teacherRight ON mid.fk_teacher_id = teacherRight.id GROUP BY mid.fk_class_id ) AS any ON c.id = any.class_id; +----------------------+----------------+---------------+ | class_name | principal_name | have_teachers | +----------------------+----------------+---------------+ | one year one class | David | David,Jason | | one year two class | Jason | David | | one year three class | Lisa | David,Lisa | +----------------------+----------------+---------------+ 5）查看全是男生的班级，以及该班级的班主任： -- 具体思路：拿出每个班级的总人数，拿出每个班级的男生人数 -- 如果班级的总人数=班级的男生人数，那我们就认为这个班级只有男生 SELECT c.number AS class_number, c.name AS class_name, l_s.total_number AS student_number, l_s.total_student AS student_name, t.name AS class_principal FROM classesInfo AS c -- 数据表，提供班级总人生、班级学生列表 INNER JOIN ( SELECT fk_class_id, count(id) AS total_number, GROUP_CONCAT(name) AS total_student FROM studentsInfo GROUP BY fk_class_id ) AS l_s ON l_s.fk_class_id = c.id -- 条件表，只提供班级男生人数 INNER JOIN ( SELECT fk_class_id, count(id) AS male_number FROM studentsInfo WHERE gender = \"male\" GROUP BY fk_class_id ) AS r_s ON l_s.fk_class_id = r_s.fk_class_id AND l_s.total_number = r_s.male_number -- 老师表，因为需要获取班主任 INNER JOIN teachersInfo AS t ON c.fk_teacher_id = t.id; +--------------+--------------------+----------------+--------------+-----------------+ | class_number | class_name | student_number | student_name | class_principal | +--------------+--------------------+----------------+--------------+-----------------+ | 1602 | one year two class | 2 | Jack,Bobby | Jason | +--------------+--------------------+----------------+--------------+-----------------+ Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:48 "},"数据库专栏/MySQL/视图相关.html":{"url":"数据库专栏/MySQL/视图相关.html","title":"视图相关","keywords":"","body":"准备数据 视图（View）常用于多表查询中，因此在开始之前我们需要准备一些数据。 注意下面的2张表中并没有FOREIGN KEY对它们进行物理层面的约束，但是逻辑层面上这2张表是有关联的，因此在插入数据时必须小心，如果操纵不当可能会产生非法数据。 表结构如下所示： -- 创建部门表 CREATE TABLE department ( id INT PRIMARY KEY AUTO_INCREMENT COMMENT \"主键\", did INT UNIQUE NOT NULL COMMENT \"部门编号\", name CHAR(64) UNIQUE NOT NULL COMMENT \"部门名称\" ) ENGINE innodb CHARSET utf8mb4 COLLATE utf8mb4_general_ci; -- 创建员工表 CREATE TABLE staff ( id INT PRIMARY KEY AUTO_INCREMENT COMMENT \"主键\", sid INT UNIQUE NOT NULL COMMENT \"员工编号\", name CHAR(64) NOT NULL COMMENT \"员工姓名\", age TINYINT UNSIGNED NOT NULL DEFAULT 18 COMMENT \"员工年龄\", gender BOOLEAN NOT NULL DEFAULT 1 COMMENT \"员工性别\", salary DECIMAL(10, 2) NOT NULL DEFAULT 0 COMMENT \"员工薪资(月)\", department_id INT NOT NULL COMMENT \"所属部门\" ) ENGINE innodb CHARSET utf8mb4 COLLATE utf8mb4_general_ci; 表数据如下所示： INSERT INTO department(did, name) VALUES (100, \"Management\"), (200, \"Finance\"), (300, \"Technical\"), (400, \"Sales\"), (500, \"Logistics\"); INSERT INTO staff(sid, name, age, gender, salary, department_id) VALUES (1001, \"Jack\", 32, 1, 21000.00, 1), (1002, \"Tom\", 30, 1, 18300.00, 1), (1003, \"Ken\", 34, 1, 8000.00, 2), (1004, \"Anni\", 28, 0, 8000.00, 2), (1005, \"Benjamin\", 26, 1, 12000.00, 3), (1006, \"David\", 21, 1, 10000.00, 3), (1007, \"Mary\", 26, 0, 6800.00, 4), (1008, \"Jason\", 24, 1, 8000.00, 4), (9999, \"Tomson\", 38, 1, 99999.00, 0); -- 注意！Logistics（后勤部）没有任何员工 -- 而Tomson不属于任何部门，因为他是老板 视图概念 视图其实就是持久化的保存多表查询的临时表结果，避免了每次查询相同数据时需要重复输入很多SQL语句的弊端。 如下所示，不使用视图我们每次查询以下数据时都会输入大量的SQL语句： SELECT r.id, r.sid, r.name, r.age, r.gender, r.salary, l.name, l.did FROM department AS l INNER JOIN staff AS r ON l.id = r.department_id; +----+------+----------+-----+--------+----------+------------+-----+ | id | sid | name | age | gender | salary | name | did | +----+------+----------+-----+--------+----------+------------+-----+ | 1 | 1001 | Jack | 32 | 1 | 21000.00 | Management | 100 | | 2 | 1002 | Tom | 30 | 1 | 18300.00 | Management | 100 | | 3 | 1003 | Ken | 34 | 1 | 8000.00 | Finance | 200 | | 4 | 1004 | Anni | 28 | 0 | 8000.00 | Finance | 200 | | 5 | 1005 | Benjamin | 26 | 1 | 12000.00 | Technical | 300 | | 6 | 1006 | David | 21 | 1 | 10000.00 | Technical | 300 | | 7 | 1007 | Mary | 26 | 0 | 6800.00 | Sales | 400 | | 8 | 1008 | Jason | 24 | 1 | 8000.00 | Sales | 400 | +----+------+----------+-----+--------+----------+------------+-----+ 创建视图 在开发过程中应当尽量少的去应用视图，因为视图极为依赖真实表数据，过度的使用视图会使程序耦合度极大的提升。 另外，在创建视图时不应该出现虚拟表中多列字段同名的情况，这会抛出异常1064。 以下是创建视图的基本语法格式： CREATE VIEW 视图表名称 AS SQL语句; 以下示例中将展示如何为上述结构的虚拟表创建出视图，由于staff的name和department的name相同，所以我们需要AS一个别名: CREATE VIEW dep_staff_view AS SELECT r.id AS staff_id, r.sid AS staff_sid, r.name AS staff_name, r.age AS staff_age, r.gender AS staff_gender, r.salary AS staff_salary, l.name AS department_name, l.did AS department_did FROM department AS l INNER JOIN staff AS r ON l.id = r.department_id; 视图其实会按照查询的语句创建一个只有表结构，但没有表数据的视图表。 每一次使用视图查询时都会重复执行定义视图时的SQL语句来从物理表中获得数据。 查看视图 使用以下命令查看视图创建情况： > SHOW CREATE VIEW dep_staff_view\\G; *************************** 1. row *************************** View: dep_staff_view Create View: CREATE ALGORITHM=UNDEFINED DEFINER=`root`@`%` SQL SECURITY DEFINER VIEW `dep_staff_view` AS select `r`.`id` AS `staff_id`,`r`.`sid` AS `staff_sid`,`r`.`name` AS `staff_name`,`r`.`age` AS `staff_age`,`r`.`gender` AS `staff_gender`,`r`.`salary` AS `staff_salary`,`l`.`name` AS `department_name`,`l`.`did` AS `department_did` from (`department` `l` join `staff` `r` on((`l`.`id` = `r`.`department_id`))) character_set_client: utf8mb4 collation_connection: utf8mb4_general_ci 1 row in set (0.00 sec) 使用视图 视图表的使用应该仅限于查询，不应该对视图表进行插入或更新操作，虽然视图表可以当作正常物理表一样进行使用。 示例演示，正确使用视图进行查询： > SELECT staff_sid, staff_name, staff_salary, department_name, department_did FROM dep_staff_view; +-----------+------------+--------------+-----------------+----------------+ | staff_sid | staff_name | staff_salary | department_name | department_did | +-----------+------------+--------------+-----------------+----------------+ | 1001 | Jack | 21000.00 | Management | 100 | | 1002 | Tom | 18300.00 | Management | 100 | | 1003 | Ken | 8000.00 | Finance | 200 | | 1004 | Anni | 8000.00 | Finance | 200 | | 1005 | Benjamin | 12000.00 | Technical | 300 | | 1006 | David | 10000.00 | Technical | 300 | | 1007 | Mary | 6800.00 | Sales | 400 | | 1008 | Jason | 8000.00 | Sales | 400 | +-----------+------------+--------------+-----------------+----------------+ 当物理表数据发生改变后，视图表中的数据也会发生改变： > -- 查看视图表中Jack的工资情况 > SELECT staff_sid, staff_name, staff_salary, department_name, department_did FROM dep_staff_view WHERE staff_sid = 1001; +-----------+------------+--------------+-----------------+----------------+ | staff_sid | staff_name | staff_salary | department_name | department_did | +-----------+------------+--------------+-----------------+----------------+ | 1001 | Jack | 21000.00 | Management | 100 | +-----------+------------+--------------+-----------------+----------------+ 1 row in set (0.00 sec) > -- 修改物理表中Jack的工资 > UPDATE -> staff -> SET -> salary = 19800 -> WHERE -> sid = 1001; Query OK, 1 row affected (0.00 sec) Rows matched: 1 Changed: 1 Warnings: 0 > -- 再次查看视图表中Jack的工资情况 > SELECT staff_sid, staff_name, staff_salary, department_name, department_did FROM dep_staff_view WHERE staff_sid = 1001; +-----------+------------+--------------+-----------------+----------------+ | staff_sid | staff_name | staff_salary | department_name | department_did | +-----------+------------+--------------+-----------------+----------------+ | 1001 | Jack | 19800.00 | Management | 100 | +-----------+------------+--------------+-----------------+----------------+ 视图引用 视图表引用的是物理表中的数据，虽然不建议对视图表本身进行增删改等操作，但是视图表可以将引用修改为另一张物理表。 语法格式如下： ALTER VIEW 视图表名称 AS SQL语句; 删除视图 对视图表的删除语法如下： DROP VIEW 视图表名称; Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:48 "},"数据库专栏/MySQL/触发器.html":{"url":"数据库专栏/MySQL/触发器.html","title":"触发器","keywords":"","body":"功能概述 触发器可以定制用户对某张数据表进行增删改操作前以及操作后的行为。 触发器无法主动执行，必须由用户对特定数据表进行增删改操作后被动触发。 触发器无法对查询前或查询后的行为做定制。 创建触发器 创建触发器的语法格式如下： -- DELIMITER是指自定义结束符，mysql中以分号结束，使用自定义结束符后则以自定义结束符为准 -- 自定义结束符的意义在于有可能定制触发器逻辑中的语句会使用分号，但是此时触发器并未创建完成 -- 每个触发器创建完成之后都有一个$，代表该语句以正式结束，触发器以创建 DELIMITER $ -- 插入前 CREATE TRIGGER 触发器名称 BEFORE INSERT ON 表名 FOR EACH ROW -- 每一行 BEGIN 定制行为 END$ -- 插入后 CREATE TRIGGER 触发器名称 AFTER INSERT ON 表名 FOR EACH ROW BEGIN 定制行为 END$ -- 更新前 CREATE TRIGGER 触发器名称 BEFORE UPDATE ON 表名 FOR EACH ROW BEGIN 定制行为 END$ -- 更新后 CREATE TRIGGER 触发器名称 AFTER UPDATE ON 表名 FOR EACH ROW BEGIN 定制行为 END$ -- 删除前 CREATE TRIGGER 触发器名称 BEFORE DELETE ON 表名 FOR EACH ROW BEGIN 定制行为 END$ -- 删除后 CREATE TRIGGER 触发器名称 AFTER DELETE ON 表名 FOR EACH ROW BEGIN 定制行为 END$ DELIMITER ; 使用触发器 以下示例将展示对userInfo表进行插入与删除记录时，会向userInfoLog表中插入一条操作记录： -- 用户表 CREATE TABLE userInfo( id INT PRIMARY KEY AUTO_INCREMENT COMMENT \"主键\", name CHAR(32) NOT NULL COMMENT \"用户名称\", age TINYINT(3) UNSIGNED NOT NULL COMMENT \"用户年龄\", gender BOOLEAN NOT NULL DEFAULT 1 COMMENT \"用户性别\", role ENUM(\"USER\", \"ADMIN\") NOT NULL DEFAULT \"USER\" COMMENT \"用户角色\", delete_status BOOLEAN NOT NULL DEFAULT false COMMENT \"是否删除\" ) ENGINE innodb CHARSET utf8mb4 COLLATE utf8mb4_general_ci; -- 日志表 CREATE TABLE userInfoLog( id INT PRIMARY KEY AUTO_INCREMENT COMMENT \"主键\", user_name CHAR(32) NOT NULL COMMENT \"用户名称\", log_message CHAR(128) NOT NULL COMMENT \"日志信息\", create_time DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT \"记录时间\" ) ENGINE innodb CHARSET utf8mb4 COLLATE utf8mb4_general_ci; -- 创建触发器 DELIMITER $ -- 创建触发器、插入之后 CREATE TRIGGER user_after_insert AFTER INSERT ON userInfo -- 每一行 FOR EACH ROW BEGIN -- 判断插入的角色 其中NEW代表即将插入的行 IF NEW.role = \"user\" THEN INSERT INTO userInfoLog(user_name, log_message) VALUES (NEW.name, \"Add an ordinary user\"); ELSE INSERT INTO userInfoLog(user_name, log_message) VALUES (NEW.name, \"Add an administrator\"); END IF; END $ -- 创建触发器，删除之后 CREATE TRIGGER user_after_delete AFTER DELETE ON userInfo -- 每一行 FOR EACH ROW BEGIN -- 判断删除的角色，其中OLD代表即将删除的行 IF OLD.role = \"user\" THEN INSERT INTO userInfoLog(user_name, log_message) VALUES (OLD.name, \"Delete an ordinary user\"); ELSE INSERT INTO userInfoLog(user_name, log_message) VALUES (OLD.name, \"Delete an administrator\"); END IF; END $ DELIMITER ; 接下来对userInfo表做删除和插入操作，查看userInfoLog表中的记录变化： INSERT INTO userInfo(name, age, gender ,role) VALUE (\"Jack\", 18, 1, \"admin\"), (\"Tom\", 19, 1, \"user\"); DELETE FROM userInfo WHERE id = 1; SELECT * FROM userInfoLog; 最终结果： +----+-----------+-------------------------+---------------------+ | id | user_name | log_message | create_time | +----+-----------+-------------------------+---------------------+ | 1 | Jack | Add an administrator | 2021-11-08 01:43:44 | | 2 | Tom | Add an ordinary user | 2021-11-08 01:43:44 | | 3 | Jack | Delete an administrator | 2021-11-08 01:43:54 | +----+-----------+-------------------------+---------------------+ 查看触发器 查看某个触发器的元信息： SELECT * FROM information_schema.triggers WHERE trigger_schema = \"库名\" AND trigger_name = \"触发器名称\"\\G; 查看某个库下的所有触发器： -- 方式1 SHOW TRIGGERS FROM 库名\\G; -- 方式2 SELECT * FROM information_schema.triggers WHERE trigger_schema = \"库名\"\\G; 查看某个表下的所有触发器： -- 方式1 SHOW TRIGGERS FROM 库名 WHERE `table` = \"表名\"\\G; -- 注意使用`进行包裹，因为table是MySQL中的关键字 -- 方式2 SELECT * FROM information_schema.triggers WHERE trigger_schema = \"库名\" AND event_object_table = \"表名\"\\G; 删除触发器 删除触发器的语法格式如下： DROP TRIGGER 触发器名称; 或者你也可以删除某张表中的所有触发器： DROP TRIGGER 表名.触发器名称; Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:48 "},"数据库专栏/MySQL/存储过程.html":{"url":"数据库专栏/MySQL/存储过程.html","title":"存储过程","keywords":"","body":"功能概述 存储过程中包含了一系列可执行的SQL语句，存储过程必须存在在MySQL中，通过对存储过程的调用可执行其内部的SQL语句。 以下是存储过程的应用以及优缺点： 存储过程用于替代应用程序开发过程中书写的SQL语句，以实现应用程序与SQL的解耦合 如果是基于网络传输，远程直接输入执行存储过程的名字即可，数据传输量较小 存储过程的缺点在于部门间沟通不便导致可扩展性降低 换而言之我们希望的是由DBA来编写所有的SQL语句，并将它们书写为存储过程让后端进行调用，但这只是理想状态，大多数公司中部门之间的沟通效率并不支持这种开发模式。 创建存储过程 基础语法示例 以下是创建存储过程的基础语法： -- DELIMITER是指自定义结束符，mysql中以分号结束，使用自定义结束符后则以自定义结束符为准 -- 自定义结束符的意义在于有可能定制存储过程逻辑中的语句会使用分号，但是此时存储过程并未创建完成 -- 每个存储过程创建完成之后都有一个$，代表该语句以正式结束，存储过程以创建 DELIMITER $ -- 创建无参存储过程 CREATE PROCEDURE 存储过程名称() BEGIN 定制行为 END $ -- 创建有参存储过程 CREATE PROCEDURE 存储过程名称(IN 形参名 形参类型, OUT 返回值名 返回值类型) BEGIN 定制行为 END $ DELIMITER ; 内部变量声明 在存储过程的BEGIN…END中允许进行变量声明，基本语法如下： DECLARE 变量名 类型(宽度) DEFAULT 默认值; 示例演示： -- 普通声明 DECLARE total_sale INT DEFAULT 0; -- 一次声明多个变量 DECLARE x, y INT DEFAULT 0; 后续需要赋值时，通过SET语句即可： DECLARE total_count INT DEFAULT 0; SET total_count = 10; 无参存储过程 以下是无参存储过程的使用和在MySQL中的调用方式。 如下示例： DELIMITER $ -- 创建无参存储过程 CREATE PROCEDURE select_userInfo() BEGIN SELECT * FROM db1.userInfo; END $ DELIMITER ; -- 调用存储过程 CALL select_userInfo(); 有参存储过程 以下是有参存储过程的使用和在MySQL中的调用方式。 in：指定形参名和类型 out：指定返回值名和类型 inout：既可以指定形参名和类型也可以指定返回值名和类型 如下示例： DELIMITER $ -- 创建有参存储过程 CREATE PROCEDURE select_userInfo_when_id(IN uid INT, OUT result INT) BEGIN SELECT * FROM db1.userInfo WHERE id = uid; -- 自动返回结果 SET result = 1; END $ DELIMITER ; -- 调用存储过程，注意此时必须声明返回值等待接收 SET @uid = 1; SET @result = 0; CALL select_userInfo_when_id(@uid, @result); SELECT @result; INTO的简单使用 下面有一个nation表，记录了每个国家的人口信息： CREATE TABLE nation( id INT PRIMARY KEY AUTO_INCREMENT COMMENT \"主键\", name CHAR(64) NOT NULL COMMENT \"国家名称\", population BIGINT UNSIGNED NOT NULL COMMENT \"国家人口\" ) ENGINE innodb CHARSET utf8mb4 COLLATE utf8mb4_general_ci; INSERT INTO nation(name, population) VALUES (\"China\", 15000), (\"India\", 14000), (\"America\", 30000), (\"Russia\", 10000); 创建一个存储过程，根据国家名字查看该国家的人口数量： DELIMITER $ CREATE PROCEDURE select_nation_population(IN nation_name CHAR(64), OUT result BIGINT) BEGIN -- INTO 是将查询结果放入result变量中 SELECT population INTO result FROM nation WHERE name = nation_name; END $ DELIMITER ; SET @result = 0; CALL select_nation_population(\"China\", @result); SELECT @result; +---------+ | @result | +---------+ | 15000 | +---------+ 查看存储过程 通过以下命令，可查看某个库下的所有存储过程： SELECT name FROM mysql.proc WHERE db = \"库名\"; 删除存储过程 通过以下命令，可删除某个库下的某一个存储过程： DROP PROCEDURE 存储过程名称; 关于异常处理 存储过程逻辑处理中可使用异常处理，但是MySQL的异常处理并不是太完善。 DELIMITER $ -- 创建存储过程 参数1，传入参数，int类型，参数2，返回值，int类型 CREATE PROCEDURE demo(IN n1 int, OUT res int) BEGIN -- 异常捕捉：SQLWARNING：01开头的异常码，NOT FOUND:02开头的异常码，SQLEXCEPTION：其他数字开头的异常码 DECLARE EXIT HANDLER FOR SQLWARNING, NOT FOUND, SQLEXCEPTION BEGIN -- 异常逻辑书写区域，如果发生异常返回值为0 SELECT \"错误了\"; SET res = 0; END; -- 书写正常逻辑，当出现异常时跑到上面执行异常的处理逻辑 SELECT \"正常了\"; -- 没有该表，触发异常 SELECT * FROM nohavetable; -- 设置返回值，如果未触发异常，返回值为1 SET res = 1; END $ DELIMITER ; SET @res = 0; CALL demo(1, @res); SELECT @res; Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:48 "},"数据库专栏/MySQL/函数相关.html":{"url":"数据库专栏/MySQL/函数相关.html","title":"函数相关","keywords":"","body":"内置函数 数学函数 常用的数学相关函数如下所示： ROUND(x, y) -- 返回参数x的四舍五入的有y位小数的值 RAND() -- 返回一个大于0小于1的随机数 聚合函数 常用的聚合函数如下所示： AVG(col) -- 返回指定列的平均值 COUNT(col) -- 返回指定列中非NULL值的个数 MIN(col) -- 返回指定列的最小值 MAX(col) -- 返回指定列的最大值 SUM(col) --返回指定列的所有值之和 GROUP_CONCAT(col) -- 返回由属于一组的列值连接组合而成的结果 字符串函数 常用的字符串函数如下所示： CHAR_LENGTH(str) -- 返回值为字符串str的长度，长度的单位为字符 CONCAT(str1, str2, ...) -- 字符串拼接 -- 如有任何一个参数为NULL ，则返回值为NULL CONCAT_WS(separator, str1, str2, ...) -- 字符串拼接（自定义连接符） -- CONCAT_WS()不会忽略任何空字符串。但是会忽略所有的NULL CONV(N, from_base, to_base) -- 进制转换，例如： -- SELECT CONV('a', 16, 2); 表示将a由16进制转换为2进制字符串表示 FORMAT(X, D) -- 将数字X的格式写为'#,###,###.##',以四舍五入的方式保留小数点后D位，并将结果以字符串的形式返回。若D为0, 则返回结果不带有小数点，或不含小数部分 -- 例如： -- SELECT FORMAT(12332.1,4); 结果为： '12,332.1000' INSERT(str, pos, len, newstr) -- 在str的指定位置插入字符串 -- pos：要替换位置其实位置 -- len：替换的长度 -- newstr：新字符串 -- 特别的： -- 如果pos超过原字符串长度，则返回原字符串 -- 如果len超过原字符串长度，则由新字符串完全替换 INSTR(str, substr) -- 返回字符串str中子字符串的第一个出现位置 LEFT(str, len) -- 返回字符串str从开始的len位置的子序列字符 LOWER(str) -- 变小写 UPPER(str) -- 变大写 REVERSE(str) -- 返回字符串str，顺序和字符顺序相反 SUBSTRING(str, pos) SUBSTRING(str FROM pos) SUBSTRING(str, pos, len) SUBSTRING(str FROM pos FOR len) -- 以上皆为字符串截取方案 -- 不带len参数，从pos位截取到最后 -- 待len参数，从pos位截取len个 -- 使用FROM的格式为标准SQL语法。也可能对pos使用一个负值。假若这样，则子字符串的位置起始于字符串结尾的pos字符，而不是字符串的开头位置。在以下格式的函数中可以对pos使用一个负值 SELECT SUBSTRING('Quadratically', 5); 'ratically' SELECT SUBSTRING('foobarbar' FROM 4); 'barbar' SELECT SUBSTRING('Quadratically', 5, 6); 'ratica' SELECT SUBSTRING('Sakila', -3); 'ila' SELECT SUBSTRING('Sakila', -5, 3); 'aki' SELECT SUBSTRING('Sakila' FROM -4 FOR 2); 'ki' 日期函数 常用的日期与时间函数如下所示： NOW() CURRENT_TIMESTAMP(); -- 返回当前的日期和时间 CURDATE() CURRENT_DATE() -- 返回当前的日期 CURTIME() CURRENT_TIME() -- 返回当前的时间 DAYOFWEEK(date) -- 返回date所代表的一星期中的第几天(1~7) DAYOFMONTH(date) -- 返回date是一个月的第几天(1~31) DAYOFYEAR(date) -- 返回date是一年的第几天(1~366) DAYNAME(date) -- 返回date的星期名，如：SELECT DAYNAME(CURRENT_DATE); FROM_UNIXTIME(ts, fmt) -- 根据指定的fmt格式，格式化UNIX时间戳ts HOUR(time) -- 返回time的小时值(0~23) MINUTE(time) -- 返回time的分钟值(0~59) MONTH(date) -- 返回date的月份值(1~12) MONTHNAME(date) -- 返回date的月份名，如：SELECT MONTHNAME(CURRENT_DATE); QUARTER(date) -- 返回date在一年中的季度(1~4)，如SELECT QUARTER(CURRENT_DATE); WEEK(date) -- 返回日期date为一年中第几周(0~53) YEAR(date) -- 返回日期date的年份(1000~9999) DATE_FORMAT(date, format) -- 根据format字符串格式化date值 -- 示例演示: SELECT DATE_FORMAT('2009-10-04 22:23:00', '%W %M %Y'); 'Sunday October 2009' SELECT DATE_FORMAT('2007-10-04 22:23:00', '%H:%i:%s'); '22:23:00' SELECT DATE_FORMAT('1900-10-04 22:23:00','%D %y %a %d %m %b %j'); '4th 00 Thu 04 10 Oct 277' SELECT DATE_FORMAT('1997-10-04 22:23:00','%H %k %I %r %T %S %w'); '22 22 10 10:23:00 PM 22:23:00 00 6' SELECT DATE_FORMAT('1999-01-01', '%X %V'); '1998 52' SELECT DATE_FORMAT('2006-06-00', '%d'); '00' 加密函数 常用的加密函数如下所示： MD5() -- 计算字符串str的MD5校验和 PASSWORD(str) -- 返回字符串str的加密版本，这个加密过程是不可逆转的，和UNIX密码加密过程使用不同的算法 自定义函数 函数与存储过程 自定义函数与存储过程最大的不同点： 函数中不可以写SQL语句，而存储过程中是可以写SQL语句的 函数仅仅是对一个功能的封装，而不是对SQL语句封装 如果想在BEGIN…END中写SQL语句，请使用存储过程 定义函数 定义函数的语法如下： DELIMITER $ -- 创建函数 (形参名， 类型) CREATE FUNCTION func(x INT, y INT) -- 设置返回值的类型 RETURNS int -- 函数体 BEGIN -- 定义返回值 DECLARE result INT; -- 设置返回结果 SET result = x + y; -- 返回返回结果 RETURN(result); END $ DELIMITER $ 示例演示： DELIMITER $ CREATE FUNCTION getAgeRange( age INT ) RETURNS CHAR(32) BEGIN DECLARE res CHAR(32) DEFAULT \"UNKNOW\"; IF age SELECT getAgeRange(30); +-----------------+ | getAgeRange(30) | +-----------------+ | middle | +-----------------+ 删除函数 删除自定义函数语法格式如下： DROP FUNCTION 自定义函数名称; Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:48 "},"数据库专栏/MySQL/分支循环.html":{"url":"数据库专栏/MySQL/分支循环.html","title":"分支循环","keywords":"","body":"分支结构 CASE CASE的分支结构如下所示： -- 若when的expression满足case的条件，则执行其下的代码块，若都匹配不上则运行ELSE代码块 CASE condition WHEN when_expression_1 THEN run_1 WHEN when_expression_2 THEN run_2 ELSE run_3 END -- 若when_expression成立则运行其下的代码块，若都不成立则运行ELSE代码块 CASE WHEN when_expression_1 THEN run_1 WHEN when_expression_2 THEN run_2 ELSE run_3 END IF 除了使用CASE的分支结构，也可以使用IF的分支结构，如下所示： -- 纯IF IF condtion THEN on_true_run; END IF; -- IF/ELSE IF condition THEN on_true_run; ELSE on_false_run; END IF; -- IF/ELSEIF/ELSE IF condition_1 THEN on_true_run; ELSEIF condition_2 THEN on_true_run; ... ELSE all_flase_run; END IF; 此外还有几个函数： IF(conditon, on_true, on_flase) -- 如果condition为true，则返回on_true，否则返回on_false IFNULL(result, default) -- 如果result不是null，则返回result，否则返回default NULLIF(1, 2) -- 如果1=2则返回null，否则返回1 两者差别 IF语句只能在BEGIN…END中使用，这意味着除触发器、存储过程、自定义函数外的任何场景下都不能使用它。 而CASE语句就没有这种限制，如下所示： > SELECT CASE WHEN 1 = 1 THEN \"Yes\" ELSE \"No\" END; +------------------------------------------+ | CASE WHEN 1 = 1 THEN \"Yes\" ELSE \"No\" END | +------------------------------------------+ | Yes | +------------------------------------------+ > SELECT IF 1 = 1 THEN \"Yes\" ELSE \"No\" ENDIF; ERROR 1064 (42000): You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near '1 = 1 THEN \"Yes\" ELSE \"No\" ENDIF' at line 1 流程控制 WHILE WHILE循环当条件为false时退出，当条件为true时执行，基本流程如下： 示例演示： DELIMITER $ CREATE PROCEDURE proc_while() BEGIN DECLARE count INT; SET count = 0; WHILE count REPEAT REPEAT循环会先执行一次循环体的代码，当循环体代码执行完成后判断条件如果为false则再次执行循环体代码，如果条件为true则退出循环。 示例演示： DELIMITER $ CREATE PROCEDURE proc_repeat() BEGIN DECLARE count INT; SET count = 0; REPEAT SELECT count; SET count = count + 1; -- UNTIL : 结束循环的条件, 不需要加分号 UNTIL count = 5 END REPEAT; END $ DELIMITER ; CALL proc_repeat(); LOOP LOOP循环中可以使用ITERATE和LEAVE语句，它们类似于其他语言中的break和continue。 示例演示： DELIMITER $ CREATE PROCEDURE proc_loop() BEGIN DECLARE count INT; SET count = 0; -- 标签名为LOOP_LABEL的循环体开始 LOOP_LABEL : loop SET count = count + 1; IF count = 5 THEN -- ITERATE : 类似于continue ITERATE LOOP_LABEL; END IF; IF count = 10 THEN -- LEAVE : 类似于break LEAVE LOOP_LABEL; END IF; SELECT count; -- 结束loop END loop; END $ DELIMITER ; CALL proc_loop(); Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:48 "},"数据库专栏/MySQL/元数据获取.html":{"url":"数据库专栏/MySQL/元数据获取.html","title":"元数据获取","keywords":"","body":"information_schema information_schema是一个自带的虚拟库，它不占用任何磁盘空间，主要存储一些数据库启动后的一些参数，如用户表信息、列信息、权限信息、字符信息等元信息数据。 information_schema库下的所有表都是视图表，所有的元信息都是存储在这些视图表中的，这也是该库不占据磁盘空间的主要原因。 如下所示，查看该库下所有的表，其实它们都是视图表： > USE information_schema; > SHOW TABLES; +---------------------------------------+ | Tables_in_information_schema | +---------------------------------------+ | CHARACTER_SETS | | COLLATIONS | | COLLATION_CHARACTER_SET_APPLICABILITY | | COLUMNS | | COLUMN_PRIVILEGES | | ENGINES | | EVENTS | | FILES | | GLOBAL_STATUS | | GLOBAL_VARIABLES | | KEY_COLUMN_USAGE | | OPTIMIZER_TRACE | | PARAMETERS | | PARTITIONS | | PLUGINS | | PROCESSLIST | | PROFILING | | REFERENTIAL_CONSTRAINTS | | ROUTINES | | SCHEMATA | | SCHEMA_PRIVILEGES | | SESSION_STATUS | | SESSION_VARIABLES | | STATISTICS | | TABLES | | TABLESPACES | | TABLE_CONSTRAINTS | | TABLE_PRIVILEGES | | TRIGGERS | | USER_PRIVILEGES | | VIEWS | | INNODB_LOCKS | | INNODB_TRX | | INNODB_SYS_DATAFILES | | INNODB_FT_CONFIG | | INNODB_SYS_VIRTUAL | | INNODB_CMP | | INNODB_FT_BEING_DELETED | | INNODB_CMP_RESET | | INNODB_CMP_PER_INDEX | | INNODB_CMPMEM_RESET | | INNODB_FT_DELETED | | INNODB_BUFFER_PAGE_LRU | | INNODB_LOCK_WAITS | | INNODB_TEMP_TABLE_INFO | | INNODB_SYS_INDEXES | | INNODB_SYS_TABLES | | INNODB_SYS_FIELDS | | INNODB_CMP_PER_INDEX_RESET | | INNODB_BUFFER_PAGE | | INNODB_FT_DEFAULT_STOPWORD | | INNODB_FT_INDEX_TABLE | | INNODB_FT_INDEX_CACHE | | INNODB_SYS_TABLESPACES | | INNODB_METRICS | | INNODB_SYS_FOREIGN_COLS | | INNODB_CMPMEM | | INNODB_BUFFER_POOL_STATS | | INNODB_SYS_COLUMNS | | INNODB_SYS_FOREIGN | | INNODB_SYS_TABLESTATS | +---------------------------------------+ 61 rows in set (0.00 sec) tables表 这是一个重要的视图表，存储该MySQL实例下所有表的元数据。 对该表的结构进行查看，可以看到如下信息： > DESC tables; +-----------------+---------------------+------+-----+---------+-------+ | Field | Type | Null | Key | Default | Extra | +-----------------+---------------------+------+-----+---------+-------+ | TABLE_CATALOG | varchar(512) | NO | | | | | TABLE_SCHEMA | varchar(64) | NO | | | | | TABLE_NAME | varchar(64) | NO | | | | | TABLE_TYPE | varchar(64) | NO | | | | | ENGINE | varchar(64) | YES | | NULL | | | VERSION | bigint(21) unsigned | YES | | NULL | | | ROW_FORMAT | varchar(10) | YES | | NULL | | | TABLE_ROWS | bigint(21) unsigned | YES | | NULL | | | AVG_ROW_LENGTH | bigint(21) unsigned | YES | | NULL | | | DATA_LENGTH | bigint(21) unsigned | YES | | NULL | | | MAX_DATA_LENGTH | bigint(21) unsigned | YES | | NULL | | | INDEX_LENGTH | bigint(21) unsigned | YES | | NULL | | | DATA_FREE | bigint(21) unsigned | YES | | NULL | | | AUTO_INCREMENT | bigint(21) unsigned | YES | | NULL | | | CREATE_TIME | datetime | YES | | NULL | | | UPDATE_TIME | datetime | YES | | NULL | | | CHECK_TIME | datetime | YES | | NULL | | | TABLE_COLLATION | varchar(32) | YES | | NULL | | | CHECKSUM | bigint(21) unsigned | YES | | NULL | | | CREATE_OPTIONS | varchar(255) | YES | | NULL | | | TABLE_COMMENT | varchar(2048) | NO | | | | +-----------------+---------------------+------+-----+---------+-------+ 21 rows in set (0.00 sec) 重要字段介绍： TABLE_SCHEMA：表所在库名 TABLE_NAME：表名 ENGINE：存储引擎 TABLE_ROWS：数据行 AVG_ROW_LENGTH：平均行长度 INDEX_LENGTH：索引行长度 对所有库表查询 显示所有的库与表的信息，内置库除外： SELECT table_schema, table_name FROM information_schema.tables WHERE table_schema NOT IN( \"information_schema\", \"performance_schema\", \"sys\", \"mysql\" ); 以库进行分组，查看该库下所有的表，内置库除外： SELECT table_schema, GROUP_CONCAT(table_name) FROM information_schema.tables WHERE table_schema NOT IN( \"information_schema\", \"performance_schema\", \"sys\", \"mysql\" ) GROUP BY table_schema; 查询所有的表的存储引擎，内置库除外： SELECT table_schema, table_name, engine FROM information_schema.tables WHERE table_schema NOT IN ( 'sys', 'mysql', 'information_schema', 'performance_schema' ); 数据量占用空间 一张表数据量占用空间大小的计算公式如下，默认结果为字节为单位： -- 平均行长度 * 行数 + 索引长度 = 占用空间(字节) AVG_ROW_LENGTH * TABLE_ROWS + INDEX_LENGTH -- 使用KB做为单位 (AVG_ROW_LENGTH * TABLE_ROWS + INDEX_LENGTH) / 1024 统计某个库下，某张表的数据量占用空间大小： SELECT table_name, (AVG_ROW_LENGTH * TABLE_ROWS + INDEX_LENGTH) / 1024 AS total_size_kb FROM information_schema.tables WHERE table_schema = \"mysql\" AND table_name = \"user\"; 统计某个库的数据量占用空间大小： SELECT table_schema, SUM( (AVG_ROW_LENGTH * TABLE_ROWS + INDEX_LENGTH) / 1024 ) AS total_size_kb FROM information_schema.tables WHERE table_schema = \"mysql\"; 统计所有库的数据量占用空间大小，按照升序排序： SELECT table_schema, SUM( (AVG_ROW_LENGTH * TABLE_ROWS + INDEX_LENGTH) / 1024 ) AS total_size_kb FROM information_schema.tables GROUP BY table_schema ORDER BY total_KB; CONCAT()语句拼接 使用information_schema结合CONCAT()语句生成mysqldump的备份命令： mysqldump -uroot -p123 库名 表名 >/mysql_data/bak/库名_表名.sql 方案如下： SELECT CONCAT( \"mysqldump -uroot -p123 \", table_schema, \" \", table_name, \" >/bak/\", table_schema, \"_\", table_name, \".sql\" ) AS dump_sql FROM information_schema.tables WHERE table_schema = \"库名\" AND table_name = \"表名\"; 使用information_schema结合CONCAT()语句生成删除某张表ibd文件的命令： ALTER TABLE 库名.表名 DISCARD TABLESPACE; 方案如下： -- 向文件输出，需要打开配置项：secure-file-priv用于进行受信任的安全路径的配置，配置文件中配置secure_file_priv = -- 即可，=后面不填内容，代表所有路径均受信任 SELECT CONCAT( \"ALTER TABLE \", table_schema, \".\", table_name, \" DISCARD TABLESPACE;\" ) INTO OUTFILE \"/tmp/edit.sql\" FROM information_schema.tables WHERE table_schema = \"库名\"; Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:48 "},"数据库专栏/MySQL/存储引擎.html":{"url":"数据库专栏/MySQL/存储引擎.html","title":"存储引擎","keywords":"","body":"功能概述 MySQL中一个库就是一个目录，而一个表则对应该目录下的多份文件。 存储引擎的作用就是与磁盘打交道，如何组织数据存储在磁盘上，如何从磁盘上读取出数据是其首要工作，存储引擎说白了其实就是相当于Linux中的文件系统。 在Oracle和SqlServer等数据库中仅支持一种存储引擎，但是MySQL则支持多种存储引擎，用户可以根据不同的需求为数据表选择不同的存储引擎，用户也可以根据自己的需要编写自己的存储引擎。 存储引擎一览 查看存储引擎 使用以下命令查看当前MySQL所支持的全部存储引擎： > SHOW ENGINES; +--------------------+---------+----------------------------------------------------------------+--------------+------+------------+ | Engine | Support | Comment | Transactions | XA | Savepoints | +--------------------+---------+----------------------------------------------------------------+--------------+------+------------+ | InnoDB | DEFAULT | Supports transactions, row-level locking, and foreign keys | YES | YES | YES | | MRG_MYISAM | YES | Collection of identical MyISAM tables | NO | NO | NO | | MEMORY | YES | Hash based, stored in memory, useful for temporary tables | NO | NO | NO | | BLACKHOLE | YES | /dev/null storage engine (anything you write to it disappears) | NO | NO | NO | | MyISAM | YES | MyISAM storage engine | NO | NO | NO | | CSV | YES | CSV storage engine | NO | NO | NO | | ARCHIVE | YES | Archive storage engine | NO | NO | NO | | PERFORMANCE_SCHEMA | YES | Performance Schema | NO | NO | NO | | FEDERATED | NO | Federated MySQL storage engine | NULL | NULL | NULL | +--------------------+---------+----------------------------------------------------------------+--------------+------+------------+ 9 rows in set (0.00 sec) InnoDB MySQL5.5.8版本后默认均采用InnoDB引擎。 特点如下所示： 功能 支持 功能 支持 功能 支持 存储限制 64TB 压缩数据 是 B树索引 是 MVCC多版本并发控制 是 加密数据 是 群集索引 是 外键 是 数据高速缓存 是 自适应散列索引 是 事务 是 索引高速缓存 是 地理空间索引 是 锁定粒度 行 查询高速缓存 是 全文搜索索引 是 复制 是 多个缓冲区池 是 地理空间数据类型 是 文件格式管理 是 更改缓冲 是 快速索引创建 是 更新数据字典 是 PERFORMANCE_SCHEMA 是 备份和恢复 是 群集数据库 是 自动故障恢复 是 InnoDB存储引擎是行锁设计、支持外键，并支持类似Oracle的非锁定读，即默认读取操作不会产生锁。 InnoDB存储引擎将数据放在一个逻辑的表空间中，这个表空间就像黑盒一样由InnoDB存储引擎自身来管理。 从MySQL4.1(包括 4.1)版本开始，可以将每个InnoDB存储引擎的表单独存放到一个独立的ibd文件中。 InnoDB通过使用多版本并发控制(MVCC)来获得高并发性，并且实现了SQL标准的4种隔离级别，默认为REPEATABLE级别，同时使用一种称为netx-key locking的策略来避免幻读(phantom)现象的产生。 除了这些，InnoDB存储引擎还提供了插入缓冲(insert buffer)、二次写(double write)、自适应哈希索引(adaptive hash index)、预读(read ahead) 等高性能和高可用的功能。 对于表中数据的存储，InnoDB存储引擎采用了聚集(clustered)的方式组织数据，每张表都是按主键的顺序进行存储的，如果没有显式地在表定义时指定主键，InnoDB存储引擎会为每一行生成一个6字节的行ID(ROWID)，并以此作为主键。 InnoDB存储引擎是MySQL数据库最为常用的一种引擎，Facebook、Google、Yahoo等 公司的成功应用已经证明了InnoDB存储引擎具备高可用、高性能以及高可扩展性。对其底层实现的掌握和理解也需要时间和技术的积累。 如果想深入了解 InnoDB存储引擎的工作原理、实现和应用可以参考《MySQL 技术内幕:InnoDB存储引擎》一书。 MyISAM MyISAM存储引擎是MySQL5.5.8之前默认的存储引擎。 不支持事务、行锁。但支持全文索引。 数据库系统与文件系统一个很大的不同在于对事务的支持，MyISAM存储引擎是不支持事务的。 MyISAM存储引擎的另一个与众不同的地方是，它的缓冲池只缓存(cache)索引文件，而不缓存数据文件，这与大多数的数据库都不相同。 Memory 正如其名，Memory存储引擎中的数据都存放在内存中。 数据库重启或发生崩溃，表中的数据都将消失。 它非常适合于存储OLTP数据库应用中临时数据的临时表，也可以作为OLAP数据库应用中数据仓库的维度表。 Memory存储引擎默认使用哈希索引，而不是通常熟悉的B+树索引。 其他的存储引擎 以下例举一些常见的其他存储引擎： BLACKHOLE 黑洞存储引擎，可以应用于主备复制中的分发主库 NTSE 网易公司开发的面向其内部使用的存储引擎 目前的版本不支持事务，但提供压缩、行级缓存等特性，不久的将来会实现面向内存的事务支持 infobright 第三方的存储引擎。 其特点是存储是按照列而非行的，因此非常适合OLAP的数据库应用 其官方网站是 http://www.infobright.org/，上面有不少成功的数据 仓库案例可供分析 NDB 2003年，MysqlAB公司从SonyEricsson公司收购了NDB存储引擎 NDB存储引擎是一个集群存储引擎，类似于Oracle的RAC集群，不过与Oracle RAC的share everythin结构不同的是，其结构是share nothing的集群架构，因此能提供更高级别的高可用性 NDB存储引擎的特点是数据全部放在内存中(从 5.1 版本开始，可以将非索引数据放在磁盘上)，因此主键查找(primary key lookups)的速度极快，并且能够在线添加 NDB数据存储节点(data node)以便线性地提高数据库性能 由此可见，NDB存储引擎是高可用、 高性能、高可扩展性的数据库集群系统，其面向的也是OLTP的数据库应用类型 RocksDB、MyRocks、TokuDB 这三个的都是第三方存储引擎，压缩和数据的插入性能较高，其他功能和InnoDB没差 存储引擎配置 检查存储引擎 使用SELECT语句来检查当前使用MySQL实例所使用的默认存储引擎： SELECT @@default_storage_engine; 使用SHOW语句来检查某个表锁使用的存储引擎信息： SHOW TABLE STATUS LIKE \"表名\"\\G; SHOW CREATE TABLE 表名\\G; 通过information_schema检查每个非内置库表的存储引擎信息： SELECT table_schema, table_name, engine FROM information_schema.tables WHERE table_schema NOT IN ( 'sys', 'mysql', 'information_schema', 'performance_schema' ); 修改存储引擎 修改当前会话级别的存储引擎，当前会话终端窗口关闭后失效： SET default_storage_engine = InnoDB; 修改当前全局级别的存储引擎，当前mysqld.service服务重启后失效： SET GLOBAL default_storage_engine = InnoDB; 在配置文件中对默认存储引擎进行修改，永久生效，需重启当前mysqld.service服务： [mysqld] default-storage-engine=INNODB 修改指定表的存储引擎： ALTER TABLE 表名 ENGINE = 存储引擎; 通过information_shema将某个非内置库的下所有的表存储引擎进行修改： SELECT CONCAT(\"ALTER TABLE 库名.\", TABLE_NAME, \" ENGINE tokudb;\") FROM information_schema.tables WHERE table_schema = '库名' INTO OUTFILE '/tmp/tokudb.sql'; -- 通过source命令进行导入tokudb.sql文件即可 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:48 "},"数据库专栏/MySQL/InnoDB存储结构.html":{"url":"数据库专栏/MySQL/InnoDB存储结构.html","title":"InnoDB存储结构","keywords":"","body":"物理存储结构 文件释义 在MySQL5.7版本的InnoDB引擎中，以下5个文件至关重要。 1）数据存放根目录下有3个文件 ibdata文件：共享表空间文件，存放的信息很多，诸如表的元信息、UNDO回滚日志（8.0版本以下）等都存放在这里面 ib_logfile文件：存放REDO重做日志、以及事务相关日志 ibtmp文件：临时表的存放位置，诸如JOIN UNION等操作产生的临时数据都会存放在这里面，用完就删除 如下所示： $ ls /db/mysql57/3306/data/ ibdata1 ibtmp1 ib_logfile1 2）每一张表有2个文件： .frm文件：存放表字段信息 .ibd文件：存放表记录以及索引信息 如下所示： $ ls /db/mysql57/3306/data/db1/ | grep \"user\" userInfo.ibd userInfo.frm 3）其他类型的一些文件： .TRG：文件将触发器映射到相应的表 .TRN：文件包含触发器定义 逻辑存储结构 表空间 MySQL5.5版本之后的InnoDB存储引擎开始使用表空间存储数据，即文件ibdata。 它最初规定将所有的数据都存放在此文件中，这样的存储方式被称为共享表空间存储，但是这样的管理方式比较混乱。 所以经过版本变迁，共享表空间文件ibdata中存储的数据也越来越少，如下所示： 5.5版本出现表空间管理模式、此时为共享表空间管理模式，所有数据均存放至此、包括数据行、索引、临时表、统计信息等 5.6版本以后，共享表空间只用来存储元信息、UNDO回滚日志、临时表，至此变更为独立表空间管理模式 5.7版本以后，表空间中的临时表被独立出来 8.0版本以后，表空间中的UNDO回滚日志被独立出来 MySQL5.6表空间存储数据一览 MySQL5.7表空间存储数据一览 MySQL8.0表空间存储数据一览 段区页的概念 表空间是由段区页组成，基本概念如下： 图的解释： 段(tablespace): 一个段就是一张表，构成如下： leaf node segment -- 数据段、B+树的叶子节点 non leaf node segment -- 索引段、B+树的非索引节点 rollback segment -- 回滚段 区(extent): 一个段由多个区构成，一个区由64个连续的页构成，即16*64=1024kb 尽管页的大小可以改变，但是不论页的大小怎么变化，区的大小总是为1M 页(page): 一个页也被称为一个block，一个页的大小默认为16kb InnoDB 1.0.x开始引入压缩页，即每个页的大小可以通过参数key_block_size设置为2kb、4kb、8kb。 如果这样做，那么每个区对应页的数量就应该变为为512、256、128个，因为区总是要保证1M的大小 InnoDB 1.2.x开始新增了参数innodb_page_size，通过该参数可以将默认页的大小设置为4kb、8kb。但是页中的数据并不是压缩的。 如果这样做，那么每个区中页的数量同样也会变化为256或者128个，因为区总是要保证1M的大小 行(row): 数据是按行进行存放的。每个页存放的记录也是硬性定义的，最多允许存放16KB/2-200行记录，即7992行记录 我们说过存储引擎类似于文件系统，文件系统的作用在于组织数据如何写入到磁盘与规定如何从磁盘上读取数据。 如果没有文件系统，产生1kb的数据时就立马写入磁盘，这无疑是愚蠢的设计，因为I/O次数过多，时间就会大幅度增加。 InnoDB存储引擎也是一样的，当用户进行操作时它并不会直接将用户的数据写入到磁盘，而是先将写入的数据按照16k的大小依次写入到page中，同理读取数据也是一样，page也是最小的读取单元。 相关设置项 共享表空间 查看默认的共享表空间文件ibdata1的大小： > SHOW VARIABLES LIKE \"innodb_data_file_path\"; > SELECT @@innodb_data_file_path; -- 也可使用这个命令 +-----------------------+------------------------+ | Variable_name | Value | +-----------------------+------------------------+ | innodb_data_file_path | ibdata1:12M:autoextend | +-----------------------+------------------------+ 1 row in set (0.00 sec) 其中12M是最大阈值，autoextend的意思是到达12M后自动进行扩容，通过以下命令可查看到扩容到多少M。 > SHOW VARIABLES LIKE \"%extend%\"; > SELECT @@innodb_autoextend_increment; -- 也可使用这个命令 +-----------------------------+-------+ | Variable_name | Value | +-----------------------------+-------+ | innodb_autoextend_increment | 64 | +-----------------------------+-------+ 1 row in set (0.00 sec) 默认的共享表空间只有1个ibdata1文件，我们可以为其设置多个，如下面这条语句的意思就会初始出2个表空间文件，且第2个表空间文件达到阈值后会自动进行扩容。 通常该配置会放在服务初始化之前应用： # 初始化2个ibdata文件用做共享表空间 innodb_data_file_path=ibdata1:512M;ibdata2:512M:autoextend # 当第2个文件达到512m后，自动为其扩容64M innodb_autoextend_increment=64 独立表空间 在MySQL5.6版本之后，所有数据均采用独立表空间的存储方式。 存储特点如下： 一个表一个.ibd文件、存储数据行和索引信息 一个表一个.frm文件、存储表基本的字段、约束等信息 ibtmp1中会存放一些临时表的信息 ib_logfileN中存储REDO重做日志 共享表空间ibdataN中还会存放该表元信息，如统计信息等 ibdataN中除了存储所有表的元信息外还会存放UNDO回滚日志（8.0版本之前） 结论：一张InnoDB表的所有数据 = .frm+.ibd+ibdataN中该表的元信息 查看独立表空间管理模式是否开启，1开启，0关闭： > SELECT @@innodb_file_per_table; +-------------------------+ | @@innodb_file_per_table | +-------------------------+ | 1 | +-------------------------+ 全局级别的关闭独立表空间管理模式，采用共享表空间管理模式，仅对当前mysqld.service服务运行时生效，重启后则失效（不推荐设置）： > SET GLOBAL innodb_file_per_table = 0; ibd数据迁移 数据库A下有一张数据表t1，其中有1000万行的数据，现在我想将它迁徙到数据库B下，该怎么做？ 1）拿到t1的建表语句，在数据库B下进行执行，此时在数据库B中的ibdata1会生成t1表的相关元数据信息、还会生成t1.frm表结构文件以及生成t1.ibd的记录与索引文件。 2）在数据库B中执行以下命令，将t1.ibd文件进行删除，切记不可手动rm删除该文件，因为共享表空间中还存在一些数据，手动rm是删不掉的： > ALTER TABLE t1 DICARD TABLESPACE; 3）将数据库A下的t1.ibd拷贝到数据库B下，修改权限并在数据库B中执行以下命令： > ALTER TABLE t1 IMPORT TABLESPACE; Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:48 "},"数据库专栏/MySQL/索引相关.html":{"url":"数据库专栏/MySQL/索引相关.html","title":"索引相关","keywords":"","body":"功能概述 一张数据表中具有百万级的数据时，如何精确且快速的拿出其中某一条或多条记录成为了人们思考的问题。 InnoDB存储引擎的出现让这个问题得到了很好的解决，InnoDB存储引擎是以索引来组织数据的，而索引在MySQL中也被称之为键，因此UNIQUE KEY，PRIMARY KEY约束字段也会作为索引字段而存在于数据表中。 当没有明确指出PRIMAY KEY时，InnoDB存储引擎首先会查找是否具有非空且唯一约束条件的字段。 如果有将则将其转变为主键，如果没有则会自动的创建一个6字节的隐藏主键用于组织数据，但是由于该主键是隐藏的所以对查询没有任何帮助。 其实索引就相当于一本大字典的目录，有了目录来找想要的内容就快很多，否则就只能进行一页一页的遍历查询，这样的查询效率无疑是十分低下的。 索引相关 索引算法 常见的索引算法如下： 索引算法 描述 B树 B-Tree索引，也有其升级版B+树，B*树 R树 一般不用 Hash 自适应哈希索引，不必过分关注，内部自己会进行使用 Full Text 全文索引，类似Elasticsearch GIS 地理位置索引，类似MangoDB 当前的MySQL中默认采用的是B树索引算法，B树算法分为普通的B-Tree（不读B减树，就是普通的B树）升级版的B+Tree以及B*Tree。 B-Tree算法 首先我们从B-Tree入手，B-Tree相较于AVL树来说突破了每个枝节点至多只有2个叶子节点的限制，且所有叶子节点都在同一级，是一颗满多叉树，它不存在层级高度差的问题。 结构示意： 首先上图中整棵树的高度为2层（也可认为是3层），分别为0层的根节点、1层的枝节点、2层的叶子节点 每一块蓝色区域，都是InooDB引擎中最小的存储单元，即16kb的页（page） 蓝色区域是数据存储区域，而黄色区域为指针区域 只有最下层的叶子节点中，才存放一整行可用的记录信息 仔细观察该结构，可以发现每一层蓝色区域都是下层指向page中最小的值 模拟查询数据项50的过程如下： 从磁盘中加载根节点page至内存，发生1次I/O 在内存中以二分法形式，确定数据项50大于28小于65，根据根节点指针P2指向枝节点中第2个page 根据指针从磁盘中加载枝节点第2个page至内存，发生第2次I/O 在内存中以二分法形式，确定数据项50大于35小于56，根据枝节点第二个page中的P2指针指向叶子节点中第5个page（从左往右数） 根据指针从磁盘中加载叶子节点第5个page，发生第3次I/O 在内存中以二分法形式，拿到数据项50，查找完成 可以发现，总共只需3次I/O即可拿到数据项50。 其实2层高度的B-Tree可以表示上百万的数据，如果上百万的数据查找只需要三次I/O，性能提升将是巨大的。 而没有使用索引进行查询时，则不会利用B-Tree查找算法对数据项进行获取，届时百万级数据将进行百万次I/O，数据查找速度会直线下降。 B+Tree算法 下面是B+Tree的结构图，相较于普通的B-Tree来说，它在叶子节点中加入了双向指针Q用来指向相邻的叶子节点，这对于范围查找速度的提升是巨大的。 比如，查找所有大于20的数据项时，如果没有叶子节点指针，则查找完20/26/27 这一页的page后，下一页page将从根节点开始重新进行查找。 当有了叶子节点指针后，只需要从叶子节点往后拿数据项即可。 B*Tree算法 下面是B*Tree的结构图，相较于B+Tree来说，它在枝节点中也加入了双向指针Q用来指向相邻的枝节点。 在某些特定的情况下，如我们的查找条件是大于20小于99并且不要28至65中间的数据项时就可以通过枝节点进行跳跃查找。 B*Tree是三种B树算法中效率最高的，也是MySQL目前正在使用的索引算法。 索引种类 聚集索引 一张表中必须有且只能有一个聚集索引。 聚集索引的B树最底层的叶子节点是一整行数据记录，所以聚集索引能够十分快速的拿到该行任意字段的数据。 MySQL会自动选择主键作为聚集索引列 MySQL在存储数据时，会按照聚集索引列值的顺序有序的存放数据行 聚集索引的B树会直接将原表数据页作为叶子节点，然后提取聚集索引列向上生成枝和根 如下图所示： 辅助索引 一张表中可以有多个辅助索引，也可以没有辅助索引。 辅助索引的B树最底层的叶子节点并不会存储一整行记录，而是只存储该单列索引的数据，并且还存储了聚集索引的值信息。 辅助索引的B树生成会先提取索引列的所有值进行排序 然后会将排好序的值，均匀的存放在叶子节点，进一步生成枝节点和根节点 在叶子节点中的值，都会对应到聚集索引即主键值中 如下图所示： 使用索引 索引类型 MySQL常见索引类型如下表所示： 索引名 描述 类别 PRIMARY KEY(field) 主键索引，加速查找，非空且唯一约束 聚集索引 INDEX(field) 普通索引，只加速查找，无约束条件 辅助索引 UNIQUE(field) 唯一索引，加速查找，唯一约束 辅助索引 INDEX(field1, field2) 联合普通索引 辅助索引 PRIMARY KEY(field1, field2) 联合主键索引 聚集索引 UNIQUE(field1, field2) 联合唯一索引 辅助索引 FULLTEXT(field) 全文索引 辅助索引 SPATIAL(field) 空间索引 辅助索引 索引命令 索引应当在建立表时就进行创建，如果表中已有大量数据，再创建索引则会花费大量的时间。 索引相关命令如下所示，关于如何创建联合索引，联合主键索引请参照之前的MySQL 约束条件一章： -- 创建表时一并创建索引 CREATE TABLE 库名.表名( 字段名1 类型(宽度) 约束条件1, 约束条件2... COMMENT \"字段描述信息\", 字段名2 类型(宽度) 约束条件1, 约束条件2... COMMENT \"字段描述信息\", 索引类型 索引名字(字段名(索引长度)) COMMENT \"索引描述信息\" ) ENGINE 存储引擎 CHARSET 字符编码 COLLATE 校对规则; -- 在已存在的表上创建索引，如果要创建INDEX普通索引，则不用指定索引类型 CREATE 索引类型 INDEX 索引名字 ON 表名(字段名(索引长度)) COMMENT \"索引描述信息\"; -- 在已存在的表上创建索引，如果要创建INDEX普通索引，则索引类型指定为INDEX即可 ALTER TABLE 表名 ADD 索引类型 索引名字(字段名(索引长度)) COMMENT \"索引描述信息\"; -- 查询索引 SHOW INDEX FROM 表名\\G; -- 删除索引 DROP INDEX 索引名 ON 表名; 示例演示： -- 创建表时就创建索引 CREATE TABLE userInfo( id INT PRIMARY KEY AUTO_INCREMENT COMMENT \"主键\", name CHAR(32) NOT NULL COMMENT \"用户名\", age TINYINT(3) UNSIGNED NOT NULL COMMENT \"年龄\", gender BOOLEAN NOT NULL DEFAULT 1 COMMENT \"性别\", INDEX idx_name(name) COMMENT \"普通索引\" ) ENGINE innodb CHARSET utf8mb4 COLLATE utf8mb4_general_ci; -- 查询索引 SHOW INDEX FROM userInfo\\G; -- 删除普通索引 DROP INDEX idx_name ON userInfo; -- 在已存在的表上创建索引，如果要创建INDEX普通索引，则不用指定索引类型 -- 这里创建唯一索引 CREATE UNIQUE INDEX unique_index ON userInfo(name) COMMENT \"唯一索引\"; -- 删除唯一索引 DROP INDEX unique_index ON userInfo; -- 在已存在的表上创建索引，如果要创建INDEX普通索引，则不用指定索引类型 -- 这里创建普通索引 CREATE INDEX idx ON userInfo(name) COMMENT \"普通索引\"; -- 删除普通索引 DROP INDEX idx ON userInfo; -- 在已存在的表上创建索引，如果要创建INDEX普通索引，则索引类型指定为INDEX即可 -- 这里创建唯一索引 ALTER TABLE userInfo ADD UNIQUE INDEX unique_index(name) COMMENT \"唯一索引\"; -- 删除唯一索引 DROP INDEX unique_index ON userInfo; -- 在已存在的表上创建索引，如果要创建INDEX普通索引，则索引类型指定为INDEX即可 -- 这里创建普通索引 ALTER TABLE userInfo ADD INDEX idx(name) COMMENT \"普通索引\"; -- 删除普通索引 DROP INDEX idx ON userInfo; 索引名词 索引结构 如果想更加深入的了解索引，则需要更详细的认识索引结构。 你可以直接将聚集索引和辅助索引想象成2张索引表： 对于聚集索引来说，它包含了索引字段（主键）以及该记录中其他字段的值 对于辅助索引来说，它仅仅包含当前索引字段（idx）的值与聚集索引的值（主键） 如下图所示： 回表查询 使用辅助索引作为查询条件进行查询时，如果SELECT需要的字段并未存在于辅助索引中，则会根据辅助索引中存储的主键值使用聚集索引再查询一次，这个过程叫做回表查询。 回表查询的效率虽然比直接查询聚集索引低，但是比不走索引查询效率高。 如下所示，以下查询语句会产生回表查询： SELECT age FROM userInfo WHERE name = \"Jack\"; -- 1.查询到Jack的辅助索引，由于辅助索引只存当前索引列与聚集索引字段的值所以拿不到age -- 2.通过辅助索引中的聚集索引字段值，进行聚集索引查询、聚集索引中包含一整行记录，所以能拿到age 覆盖索引 通过辅助索引进行查询时，如果SELECT需要的字段正好存在于辅助索引中，则不必再进行回表查询，这种就叫覆盖索引，如下所示： SELECT name FROM userInfo WHERE name = \"Jack\"; 如果(name, age)为联合索引，则下面这种查询也属于覆盖索引的范畴： SELECT name, age FROM userInfo WHERE name = \"Jack\"; 另外，如果查询条件是PRIMARY KEY，则必定是覆盖索引，因为会直接走聚集索引进行查询。 索引合并索引下推 使用多个辅助索引（单列，非联合）进行查询时，被称之为索引合并。 索引合并的查询速度小于联合索引，并且不会有最左前缀匹配的限制： SELECT name, age FROM userInfo WHERE name = \"Jack\" AND age = 18; 最左前缀匹配特性 这个主要是在联合索引中体现的，如下所示，(name, age)字段为联合索引，必须从左边查询才会走索引： SELECT * FROM userInfo WHERE name = \"Jack\" AND age > 18; -- 联合索引是name在前，age在后 -- 查询条件name在前，age在后，走索引 如果像下面这种情况，本质上是不会走索引的，但是MySQL内部会做一些优化，所以查询性能和上面相同： SELECT * FROM userInfo WHERE age > 18 AND name = \"Jack\"; -- 联合索引是name在前，age在后 -- 查询条件age在前，name在后，不走索引 -- 但是MySQL内部会做优化，将age排在后面，name排在前面 如果联合索引中都是使用=作为查询条件，则最左前缀匹配特性失效，它的查询性能最高： SELECT * FROM userInfo WHERE age = 18 AND name = \"Jack\"; 短索引 如果一个字段中，前缀或者后缀都相同的情况下，如： name CHAR(64) user01203023 user32329937 user92328823 user02388322 将整条记录完整的做索引显然很浪费空间，只从第四个字符开始向后做索引是最明智的选择，这种索引被称之为短索引。 创建或修改短索引，详见创建索引中的语法，这里不再例举，如果确实有这种需求请搜索前缀索引、短索引等关键字。 正确使用索引 下面的查询都会造成索引未命中的情况发生： 1）使用LIKE进行模糊查询，且%在前面时，将会造成索引未命中： SELECT * FROM userInfo WHERE name LIKE \"%Ja\"; 2）使用函数作为筛选条件查询时，将会造成索引未命中： SELECT * FROM userInfo WHERE REVERSE(name) = \"kcaJ\"; 3）使用OR进行查询时，如果有任意一方不是索引列，将会造成索引未命中： SELECT * FROM userInfo WHERE id = 1 OR name = \"Jack\"; -- id是聚集索引 -- name是普通索引 4）条件类型不一致，如name是字符串类型，而在查找时未加引号，则将会造成索引未命中： # 不走索引 SELECT * FROM userInfo WHERE name = 1234; # 走索引 SELECT * FROM userInfo WHERE name = \"1234\"; 5）使用!=时，将会造成索引未命中，主键除外： # 不走索引 SELECT * FROM userInfo WHERE name != \"Jack\"; # 走索引 SELECT * FROM userInfo WHERE id != 1; 6）使用ORDER BY进行排序时，选择的排序字段如果不是索引字段，将会造成索引未命中： # 不走索引，gender不是索引列 SELECT * FROM userInfo ORDER BY age DESC; # 走索引，id是主键聚集索引 SELECT * FROM userInfo ORDER BY id DESC; Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:48 "},"数据库专栏/MySQL/执行计划.html":{"url":"数据库专栏/MySQL/执行计划.html","title":"执行计划","keywords":"","body":"功能概念 执行计划是DBA常用的分析SQL语句的一种手段。 使用执行计划能够拿到优化器选择完成后，其认为代价最小的一种执行方式。 在语句执行之前，拿到执行计划可以预防因SQL语句编写不妥当带来的性能问题，同时也能够对慢查询语句进行评估和优化。 使用语法 使用执行计划有两种方式，语法格式如下所示： -- 以EXPLAIN开头 EXPLAIN SQL语句; -- 以DESC开头 DESC SQL语句; 示例演示： > EXPLAIN SELECT * FROM userInfo\\G; *************************** 1. row *************************** id: 1 select_type: SIMPLE table: userInfo partitions: NULL type: ALL possible_keys: NULL key: NULL key_len: NULL ref: NULL rows: 1 filtered: 100.00 Extra: NULL 1 row in set, 1 warning (0.00 sec) 重要字段值说明： 参数 描述 table 查询的表 type 查询类型 possible_keys 可能走的索引 key 走的索引名 key_len 应用索引的长度 rows 查询结果集的长度 Extra 额外的信息 type级别 type信息标注了该查询语句的性能级别，可能出现的值有6种。 如下所示，从左至右性能依次变好，生产环境中一般需要达到RANGE标准才行： ALL 用例子说明一切可能出现的情况，表结构如下，name和age均为辅助索引列，id为聚集索引列： CREATE TABLE userInfo( id INT PRIMARY KEY AUTO_INCREMENT COMMENT \"主键\", name CHAR(32) NOT NULL COMMENT \"用户名\", age TINYINT(3) UNSIGNED NOT NULL COMMENT \"年龄\", gender BOOLEAN NOT NULL DEFAULT 1 COMMENT \"性别\", INDEX idx_name(name) COMMENT \"普通索引\", INDEX idx_age(age) COMMENT \"普通索引\" ) ENGINE innodb CHARSET utf8mb4 COLLATE utf8mb4_general_ci; 1）ALL，全表扫描，不走索引，以下语句可能会导致该级别的出现： -- 查询时没有使用索引进行查询 EXPLAIN SELECT * FROM userInfo LIMIT 1; -- 查询时条件与类型不一致 EXPLAIN SELECT * FROM userInfo WHERE name = 1234; -- ORDER BY排序是未选用索引字段进行排序 EXPLAIN SELECT * FROM userInfo ORDER BY age DESC; -- 非聚集索引（PRIMARY KEY）中出现 -- != IN/NOT IN LIKE(%开头) OR 函数 EXPLAIN SELECT * FROM userInfo WHERE name != \"Jack\"; EXPLAIN SELECT * FROM userInfo WHERE name IN (\"Jack\", \"Tom\"); EXPLAIN SELECT * FROM userInfo WHERE name NOT IN (\"Jack\", \"Tom\"); EXPLAIN SELECT * FROM userInfo WHERE name LIKE \"%ck\"; EXPLAIN SELECT * FROM userInfo WHERE name = \"Jack\" OR age = 18; EXPLAIN SELECT * FROM userInfo WHERE REVERSE(name) = \"kcaJ\"; -- 在聚集索引中使用IN/NOT IN以及OR -- IN的可选项大于2时必定是ALL EXPLAIN SELECT * FROM userInfo WHERE id IN(1, 2, 3); -- NOT IN必定是ALL EXPLAIN SELECT * FROM userInfo WHERE id NOT IN(1, 2, 3); -- OR 的可选项大于2必定是ALL EXPLAIN SELECT * FROM userInfo WHERE id = 1 OR id = 2 OR id = 3; -- 特别的，对非聚集索引中的OR可进行优化调整，达到ref级别： EXPLAIN SELECT * FROM userInfo WHERE name = \"Jack\" UNION ALL SELECT * FROM userInfo WHERE name = \"Tom\"; 2）INDEX，全索引扫描，以下语句可能会导致该级别的出现： -- 查询整颗索引树 EXPLAIN SELECT id FROM userInfo; EXPLAIN SELECT name FROM userInfo; -- 联合索引中未能遵守最左前缀匹配特性，如联合索引是(name, age) EXPLAIN SELECT * FROM userInfo WHERE age = 18; 3）RANGE，索引范围扫描，以下语句可能会导致该级别的出现： -- 在辅助索引中使用 = LIKE(非%开头) BETWEEN AND EXPLAIN SELECT * FROM userInfo WHERE age 18; EXPLAIN SELECT * FROM userInfo WHERE age = 18; EXPLAIN SELECT * FROM userInfo WHERE age BETWEEN 1 AND 18; EXPLAIN SELECT * FROM userInfo WHERE name LIKE \"Jac%\"; -- 在聚集索引中使用 = != IN OR BETWEEN AND EXPLAIN SELECT * FROM userInfo WHERE id > 1; EXPLAIN SELECT * FROM userInfo WHERE id = 1; EXPLAIN SELECT * FROM userInfo WHERE id != 1; -- IN 和 OR 的可选项必须小于或等于2 EXPLAIN SELECT * FROM userInfo WHERE id IN(1, 2); EXPLAIN SELECT * FROM userInfo WHERE id = 1 OR id = 2; EXPLAIN SELECT * FROM userInfo WHERE id BETWEEN 1 AND 18; 4）REF，非唯一索引的等值查询，以下语句可能会导致该级别的出现： -- 在辅助索引（非唯一）中使用 = EXPLAIN SELECT * FROM userInfo WHERE name = \"Jack\"; 5）EQ_REF，多表连接查询时，ON的连接条件为唯一索引（UNIQUE KEY或者PRIMARY KEY），以下语句可能导致该级别的出现： -- userinfo.fk_leval字段也必须设置UNIQUE约束，即一对一表关系 EXPLAIN SELECT * FROM userInfo JOIN userLeval ON userInfo.fk_leval = userLeval.id; 6）CONST(system)，唯一索引的等值查询，以下语句可能导致该级别的出现： -- 使用唯一辅助索引或聚集索引(PRIMARY KEY)进行 = 查询 EXPLAIN SELECT * FROM userInfo WHERE id = 1; Key_len key_len是一个值得注意关注的点，对于联合索引来说它应该越长越好。 而对于单列索引来说它应该越短越好。 不同的数据类型会造成不同的key_len，比如CHAR和VARCHAR类型： ch = CHAR(4) vc = VARCHAR(4) # 使用执行计划可以看见ch索引长度key_len是16个字节。utf8mb4下4*4=16 M > DESC SELECT ch FROM temp WHERE ch=\"\"; +----+-------------+-------+------------+------+---------------+------+---------+-------+------+----------+-------------+ +----+-------------+-------+------------+------+---------------+------+---------+-------+------+----------+-------------+ | 1 | SIMPLE | temp | NULL | ref | cidx | cidx | 16 | const | 1 | 100.00 | Using index | +----+-------------+-------+------------+------+---------------+------+---------+-------+------+----------+-------------+ # 使用执行计划可以看见vc的key_len是18个字节。这是因为除了utf8mb4下4*4=16之外，还需要加上开始和结束位置，占2字节 M > DESC SELECT vc FROM temp WHERE vc=\"\"; +----+-------------+-------+------------+------+---------------+------+---------+-------+------+----------+-------------+ +----+-------------+-------+------------+------+---------------+------+---------+-------+------+----------+-------------+ | 1 | SIMPLE | temp | NULL | ref | vidx | vidx | 18 | const | 1 | 100.00 | Using index | +----+-------------+-------+------------+------+---------------+------+---------+-------+------+----------+-------------+ 所以这也是为什么推荐建表时使用CHAR类型而不是VARCHAR类型。 Extra Extra中可能出现的提示信息： Using filesort 当出现该提示信息后，说明在查询中有关排序的条件列没有合理的应用索引，检测语句中下列地方并加以改进： ORDER BY GROUP BY DISTINCT() UNION SQL语句编写建议 以下是一些在编写SQL时的建议： 创建表时尽量使用CHAR类型来代替VARCHAR类型 表的字段顺序固定长度优先 避免使用SELECT *进行查询，因为这会产生大量的回表操作 使用COUNT(id)来代替COUNT(*) 查询一条数据时，使用LIMIT 1来结尾，否则会查询整张表 避免大量的范围查询，如确实需要范围查询请指定LIMIT n 在经常使用多条件查询时，使用联合索引代替多个单列索引 合理的使用短索引，前缀索引 索引散列值少的不适合建立索引，如性别 对于特定的查询语句，使用UNION ALL来代替多个OR的查询语句 UNION ALL代替UNION，因为UNION会对查询结果做去重 使用连接查询来代替子查询 连表查询时一定要小表驱动大表 连表查询时注意条件类型需一致 在连表时ON连表的条件列必须是单列索引字段，最好连表双方的条件列都建立索引 使用id BETWEEN 1 AND 100代替诸如id > 1 AND id 使用id IN (1, 2)代替诸如id = 1 OR id = 2之类的查询，前者只查询一次，后者需要查询两次 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:48 "},"数据库专栏/MySQL/事务相关.html":{"url":"数据库专栏/MySQL/事务相关.html","title":"事务相关","keywords":"","body":"功能概述 事务是InnoDB存储引擎的一大亮点，开启事务后即可以对一组SQL语句进行一个原子化的操作，即如果这一组SQL语句中有一条发生错误，那么同组中的其他SQL就都不会被执行。 事务的核心特点ACID如下： Atomic原子性：所有语句作为一个单元必须全部成功执行或或全部取消，不能出现中间状态 Consistent一致性：如果数据库在事务开始时处于一致状态，则在执行该事务期间将仍然保留一致状态 Isolated（隔离性）：事务之间不相互影响 Durable（持久性）：事务成功完成后，所做的所有更改都会准确地记录在数据库中，所做的更改不会丢失 标准事务 开启标准事务可使用BEGIN或者START TRANSACTION来完成，并在其中写入标准事务语句。 标准事务语句是指会被COMMIT或者ROLLBACK操纵所影响的语句，只包含INSERT UPDATE DELETE。 当执行完成一次COMMIT或者ROLLBACK操作后标准事务会自动关闭。 标准事务的开启方法与基本格式如下： BEGIN | START TRANSACTION; 标准事务语句 COMMIT | ROLLBACK; 示例演示如下，当开启事务后作出的操作如果不进行COMMIT则操作全部失效： START TRANSACTION; INSERT INTO userInfo(name, age, gender) VALUES (\"Jack\", 18, 1), (\"Ken\", 21, 1), (\"Keisha\", 22, 0); SELECT * FROM userInfo; ROLLBACK; SELECT * FROM userInfo; 全局事务 如果想让所有标准事务语句都使用COMMIT手动进行提交，我们必须先关闭AUTOCOMMIT的功能以打开全局事务，这样以后所有的标准事务语句都需要使用COMMIT手动进行提交或者使用ROLLBACK手动进行回滚。 查看自动提交机制是否开启： > SHOW VARIABLES LIKE \"AUTOCOMMIT\"; +---------------+-------+ | Variable_name | Value | +---------------+-------+ | autocommit | ON | +---------------+-------+ 1 row in set (0.00 sec) 临时的在会话级别关闭自动提交机制，当前终端关闭后失效： -- 0关闭，1打开 SET AUTOCOMMIT = 0; 全局级别关闭自动提交机制，当前mysqld.service服务重启后失效： -- 0关闭，1打开 SET GLOBAL AUTOCOMMIT = 0; 永久生效，修改配置文件，需重启mysqld.service服务： [mysqld] autocommit=0; 示例演示，现在我们并不需要手动进行START TRANSACTION或者BEGIN的操作也能开启事务： SET AUTOCOMMIT = 0; INSERT INTO userInfo(name, age, gender) VALUES (\"Tom\", 20, 1); COMMIT; SELECT * FROM userInfo; 保存回滚 MySQL中的事务也支持保存还原点的操作。 它类似于GIT的回滚机制，当你在进行事务处理的过程中可以定义一个还原点，后续任意时刻都可以自动回滚到这个还原点的状态上。 基础语法如下： -- 定义保存点 SAVEPOINT 保存点名字; -- 回滚到保存点 ROLLBACK TO SAVEPOINT 保存点名字; 我们先将全局事务关闭，然后清空userInfo表： SET AUTOCOMMIT = 1; TRUNCATE userInfo; 先插入一条记录： START TRANSACTION; INSERT INTO userInfo(name, age, gender) VALUES (\"Jack\", 18, 1); 查看当前userInfo表的记录数量，此时应该为1条： > SELECT count(id) FROM userInfo; +-----------+ | count(id) | +-----------+ | 1 | +-----------+ 设置一个保存点，名称定为first： SAVEPOINT first; 然后再插入2条数据： INSERT INTO userInfo(name, age, gender) VALUES (\"Ken\", 21, 1), (\"Keisha\", 22, 0); 查看当前userInfo表的记录数量，此时应该为3条： > SELECT count(id) FROM userInfo; +-----------+ | count(id) | +-----------+ | 3 | +-----------+ 现在我们回滚到保存点first，并提交记录： ROLLBACK TO SAVEPOINT first; COMMIT; 再次查看userInfo表的记录数量，又变更为了1条： > SELECT count(id) FROM userInfo; +-----------+ | count(id) | +-----------+ | 1 | +-----------+ 隐式提交 以下语句的出现可能会触发隐式的COMMIT： -- 1.连续使用BEGIN或者START TRANSACTION会自动触发COMMIT BEGIN; -- 开启第一个事务 标准事务语句 BEGIN; -- 开启第二个事务，自动提交第一个事务 -- 2.使用非标准事务语句会自动触发COMMIT DDL语句： （ALTER、CREATE 和 DROP） DCL语句： （GRANT、REVOKE 和 SET PASSWORD） 锁定语句：（LOCK TABLES 和 UNLOCK TABLES） Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:48 "},"数据库专栏/MySQL/CSR浅析.html":{"url":"数据库专栏/MySQL/CSR浅析.html","title":"CSR浅析","keywords":"","body":"名词介绍 事务如何保证ACID？这个就要从InnoDB存储引擎在存储数据的底层逻辑上开始说起了，本章节将介绍以下3个重要的知识点： redo_log事务重做日志 undo_log事务回滚日志 CSR自动故障恢复机制 前两者能保证事务的A（原子）C（一致）I（隔离）性，而后者则能保证事务的D（持久）性和C（一致）性。 在开始之前我们需要了解以下的一些名词： CSR：MySQL自动故障恢复机制的简称，而InnoDB存储引擎能够支持该机制 磁盘数据页文件：它是存储记录以及索引的文件，即数据库目录下的tableName.ibd文件 data buffer pool：译为数据缓冲池，从磁盘中加载的记录以及索引信息均存放至此，它位于内存中 redo_log：事务重做日志，CSR中用于前滚操作所必须依赖的日志，同时事务提交COMMIT操作也需要依赖该日志，它位于data目录中，有2个文件，名称为ib_logfile0和ib_logfile1，默认50M大小，轮询使用 undo_log：事务回滚日志，CSR中用于回滚操作所必须依赖的日志，同时事务回滚ROLLBACK操作也需要依赖该日志，它在MySQL5.7版本里仍位于共享表空间ibdata文件中，8.0版本后被独立出来 redo log buffer：redo log的内存缓冲区，它位于内存中 undo log buffer：undo log的内存缓冲区，它位于内存中 LSN号：日志序列号，每次MySQL数据库启动时，都会比较磁盘数据页文件（tableName.ibd）的LSN号和redo log的LSN号，两个LSN号必须一致数据库才能正常启动，它位于tableName.ibd、data buffer pool、redo_log、redo log buffer中 WAL：持久化存储方案的一种，全称为Write Ahead Log，译为日志优先写，MySQL以该方案实现持久化，本质是日志优先于数据写入磁盘 脏页：脏页是位于内存中的，由于WAL机制的存在，当数据页在内存中发生修改但没写入到磁盘之前我们把data buffer pool中的数据页称之为脏页，其页中的数据页被称为脏数据 CKPT：检查点，全称为Checkpoint，实际上就是将脏页刷写到磁盘的动作 TXID：事务号，全称为Transaction ID，InnoDB引擎会为每一个事务生成一个事务号并伴随着整个事务的生命周期 事务原理 BEGIN 下面我们开启一个事务，并进行COMMIT操作： BEGIN; UPDATE userInfo SET age = 21 WHERE name = \"Jack\"; -- 注意！未进行COMMIT或者ROLLBACK操作 MySQL内部处理机制如下： 在使用BEGIN开启事务时，会先给userInfo.ibd文件中分配一个TXID号和LSN号，假设为tx01与lsn01 在UPDATE执行时，MySQL会找到需更新数据的数据页，并将其内容加载到data buffer pool中，由DBWR（double write）线程记录变更数据页的内容，并且记录好TXID和更新LSN号，此时将产生脏页与脏数据 使用LOGBWR（log double write）线程，将更新前的数据页变化内容与TXID号以及LSN号记录到undo log buffer中 使用LOGBWR（log double write）线程，将更新后的数据页变化内容与TXID号以及LSN号记录到redo log buffer中 现在，基于WAL原则为了应对用户进行ROLLBACK操作，LOGBWR（log double write）线程会将undo log buffer中的内容全部写入到undo_log即ibdata1（MySQL5.7版本undo_log仍然存在于共享表空间中）文件中 图示如下： COMMIT 现在我们基于上面BEGIN后发生的情况执行COMMIT操作，内部会做以下的3件事： 执行COMMIT操作，基于WAL原则，LOGBWR线程会先将redo log buffer中记录的日志信息写入redo_log文件中，在日志信息完全写入redo_log即ib_logfile文件后，会对该日志打上COMMIT的标志 触发CKPT，将内存数据页更新到磁盘中，并且更新磁盘数据页文件userInfo.ibd中原有的LSN号，让其与redo_log文件中的LSN号保持一致 清空内存undo log buffer、data buffer pool、redo log buffer以及磁盘上undo_log中的数据 图示如下： 可以看到整个事务提交的过程是先写日志，再落盘写数据。 其实redo log buffer将数据刷新到redo_log文件中的策略除开自己手动执行COMMIT外还有另一种情况。 在多任务时，其他线程COMMIT操作也可能会导致整个redo log buffer的刷新，刷新的redo_log文件中会对本线程提交的事务打上NOCOMMIT的标记。 其实这种现象取决于data buffer pool中存储的数据量占据data buffer pool总量的多少来决定，一般来说如果占据到70%左右就会触发该现象，我们可以对其进行手动设置，但一般来说保持默认值即可。 在CSR机制中我们会详细介绍这一个过程。 ROLLBACK 现在我们基于上面BEGIN后发生的情况执行ROLLBACK操作，内部会做以下的2件事： 执行ROLLBACK操作，LOGBWR线程会将undo log buffer中的数据重写回到data buffer pool中，并且会把内存脏页数据恢复到最开始的值，然后对LSN号进行回滚更正 清空内存undo log buffer、redo log buffer以及磁盘上undo_log中的数据 图示如下： CSR机制 日志作用 到目前为止，我们还没有发现undo_log和redo_log的任何作用，这是因为这2个日志只有在mysqld.service服务出现故障时才会应用到。 单纯前滚 如果在COMMIT操作过程前发生了宕机，此时内存中的数据会全部丢失，并且redo_log文件还没有来得及为本次操作打上COMMIT的标记，而仅仅记录了数据变化日志与TXID号以及LSN号情况下重启mysqld.service服务时将会产生如下情况： 重启mysqld.service服务，发现redo_log中记录的LSN号和userInfo.ibd文件中记录的LSN号不一致，将触发CSR自动故障恢复机制的第一个阶段，前滚操作开始 通过redo_log文件中的变更记录日志，在内存数据页中恢复更改的数据 发现redo_log文件中的事务标记是COMMIT，CKPT将内存中数据页更新到磁盘，同时更新userInfo.ibd文件中的LSN号，让其追平redo_log文件中记录的LSN号 前滚工作完成，mysqld.service服务正常启动 图示如下： 前滚后滚 如果在COMMIT操作过程前发生了宕机，此时内存中的数据会全部丢失，但是恰好宕机前一秒由于其他线程的COMMIT操作导致了整个redo log buffer的自动刷新，此时redo_log文件中已经写入了刚刚本线程操作事务的TXID号以及LSN号且标记此次操作是NOCOMMIT状态的情况下重启mysqld.service服务时将会产生如下情况： 重启mysqld.service服务，发现redo_log中记录的LSN号和userInfo.ibd文件中记录的LSN号不一致，将触发CSR自动故障恢复机制的第一个阶段，前滚操作开始 通过redo_log文件中的变更记录日志，在内存数据页中恢复更改的数据 发现redo_log文件中的事务标记是NOCOMMIT，将触发CSR自动故障恢复的第二个阶段，回滚操作开始 通过undo log文件中的信息记录，在内存数据页中对前滚数据进行更改 使用LOGBWR线程，将更新的数据页变化信息与TXID以及LSN号记录到redo log buffer中 此时LOGBWR线程会先将redo log buffer中记录的信息写入到redo_log文件中，在日志信息完全写入log file即ib_logfile文件后，会对该日志打上COMMIT标记 触发CKPT，将内存数据页更新到磁盘文件userInfo.ibd中 回滚工作完成，redo_log中记录的LSN号与userInfo.ibd中记录的LSN号一致，mysqld.service服务正常启动 图示如下： 相关配置 INNODB_FLUSH_METHOD 配置参数据INNODB_FLUSH_METHOD，该参数控制的是undo/redo log buffer 和data buffer pool将数据刷写磁盘的时候是否经过os buffer。 fsync：日志和数据缓冲区向磁盘写入数据时，必须先将数据写入os buffer后再刷新至磁盘中，此为默认设置 O_DIRECT：数据缓冲区向磁盘写入数据时，不必将数据先写入os buffer中，而是直接写入到磁盘 O_DSYNC：日志缓冲区向磁盘写入数据时，不必将数据先写入os buffer中，而是直接写入到磁盘 INNODB_FLUSH_LOG_AT_TRX_COMMIT 配置参数INNODB_FLUSH_LOG_AT_TRX_COMMIT，定义COMMIT时，日志文件从缓冲区到磁盘的刷新方式。 设置为1时：日志在每次事务提交时必须先写入os buffer后再刷新至磁盘中。 设置为0时：每秒写入一次日志到os buffer并将其刷新到磁盘。未刷新日志的事务可能会在崩溃中丢失。 设置为2时：在每次事务提交后写入日志到os buffer中，并每秒刷新一次到磁盘。未刷新日志的事务可能会在崩溃中丢失。 推荐设置 推荐将配置项写入至配置文件中，达到永久生效的目的。 最高安全模式： innodb_flush_log_at_trx_commit=1 innodb_flush_method=O_DIRECT 最高性能模式: innodb_flush_log_at_trx_commit=0 innodb_flush_method=fsync 相关阅读 参考文章： 详细分析MySQL事务日志(redo log和undo log) InnoDB和事务流程、Crash Recovery、ACID InnoDB关键特性之double write Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:48 "},"数据库专栏/MySQL/事务隔离.html":{"url":"数据库专栏/MySQL/事务隔离.html","title":"事务隔离","keywords":"","body":"事务隔离 多并发问题 当数据库面对高并发场景时，多个事务之间可能会互相影响，下面3种是可能产生的情况： 脏读：事务A还没提交的数据被事务B读取到了，那么这些数据其实都是data buffer pool中的脏数据，多个事务之间没有隔离性 不可重复读：事务A不断的修改记录并提交，事务B不断的查看记录会发现每次查询结果都不一致，对于事务B来说未能保持数据的一致性 幻读：事务A删除某些记录时事务B又插入了一条新记录，事务A删除完成后查看记录发现还剩下一条没有被成功删除，就跟产生幻觉一样 不可重复读的描述和幻读很容易混淆，不可重复读侧重于记录的修改，幻读侧重于记录的新增或删除。 解决不可重复读的问题只需锁住满足条件的行即可，而解决幻读则需要锁表。 隔离级别 MySQL提供了多种事务隔离等级，默认为RR级别，如下表所示： 隔离级别 中文释义 脏读 不可重复读 幻读 说明 read uncommitted 读未提交 是 是 是 最低的事务隔离级别，一个事务还没提交时，它做的变更就能被别的事务看到 read committed 读已提交 否 是 是 保证一个事物提交后才能被另外一个事务读取，另外一个事务不能读取该事物未提交的数据 repeatable read 可重复读 否 否 是 多次读取同一范围的数据会返回第一次查询的快照，即使其他事务对该数据做了更新修改，事务在执行期间看到的数据前后必须是一致的 serializable 串行化 否 否 否 事务 100% 隔离，可避免脏读、不可重复读、幻读的发生。花费最高代价但最可靠的事务隔离级别 相关命令 查看当前事务隔离级别的命令如下： SELECT @@GLOBAL.TRANSACTION_ISOLATION, @@TRANSACTION_ISOLATION; 设置隔离级别的命令如下： -- SESSION设置 SET SESSION TRANSACTION ISOLATION LEVEL 隔离级别; -- 全局设置 SET GLOBAL TRANSACTION ISOLATION LEVEL 隔离级别; -- 文件设置 [mysqld] transaction-isolation=Read-Committed 操作演示 数据准备 演示事务隔离级别，需要准备的数据如下： CREATE TABLE userInfo( id INT PRIMARY KEY AUTO_INCREMENT COMMENT \"主键\", name CHAR(32) NOT NULL COMMENT \"姓名\", age TINYINT(3) UNSIGNED NOT NULL COMMENT \"年龄\", gender BOOLEAN NOT NULL DEFAULT 1 COMMENT \"性别\", balance DECIMAL(10, 2) NOT NULL COMMENT \"余额\", delete_status BOOLEAN NOT NULL DEFAULT 0 COMMENT \"删除状态\" ) ENGINE innodb CHARSET utf8mb4 COLLATE utf8mb4_general_ci; INSERT INTO userInfo(name, age, gender, balance) VALUES (\"Jack\", 18, 1, 13200.00), (\"Tom\", 19, 1, 12800.00), (\"Mary\", 17, 0, 9800.00), (\"Anna\", 17, 0, 9600.00); 为了模拟并发场景，下面的演示都需要开启两个终端进行测试。 RU-读未提交 RU级别一般不会进行应用，因为它的事务隔离性太低了，并且在开发和生产环境中脏读现象都是不允许出现的。 一个简单的例子，我们开启2个终端，并分别执行以下命令： -- SESSION 1 BEGIN; -- 开启一组事务 UPDATE userInfo SET balance = 0, delete_status = 0; -- SESSION 2 SET SESSION TRANSACTION ISOLATION LEVEL read uncommitted; BEGIN; -- 开启另一组事务 SELECT * FROM userInfo; 可以发现SESSION 1的UPDATE操作并未进行COMMIT，但是SESSION 2仍然可以读取到这些脏数据。 +----+------+-----+--------+---------+---------------+ | id | name | age | gender | balance | delete_status | +----+------+-----+--------+---------+---------------+ | 1 | Jack | 18 | 1 | 0.00 | 0 | | 2 | Tom | 19 | 1 | 0.00 | 0 | | 3 | Mary | 17 | 0 | 0.00 | 0 | | 4 | Anna | 17 | 0 | 0.00 | 0 | +----+------+-----+--------+---------+---------------+ RC-读已提交 RC级别面对金融业务、互联网高并发业务使用的较多，尤其是电商项目，它最大的特点就是拒绝了脏读，并且支持不可重复读，Ps：不可重复读，每次读到的数据都不一样。 下面我们将利用SESSION 1来统计所有用户余额的总量，但是在统计过程中会利用SESSION 2不断的变更Jack的余额并且COMMIT，此时SESSION 2将影响SESSION 1的统计结果： -- SESSION 1 SET SESSION TRANSACTION ISOLATION LEVEL read committed; BEGIN; -- 开启一组事务 SELECT SUM(balance) FROM userInfo; -- 结果：45400.00 -- SESSION 2 BEGIN; -- 开启另一组事务 UPDATE userInfo SET balance = 0 WHERE id = 1; COMMIT; -- SESSION 1 SELECT SUM(balance) FROM userInfo; -- 结果：32200.00 -- SESSION 2 BEGIN; -- 开启另一组事务 UPDATE userInfo SET balance = 999999 WHERE id = 1; COMMIT; -- SESSION 1 SELECT SUM(balance) FROM userInfo; -- 结果：1032199.00 其实RC的隔离级别更符合人的思维方式，但是该级别的隔离确实会导致事务A的变更影响事务B的结果，通常来说这种影响更是我们所希望看到的，举个例子，如果目前商品库存是100件，那么用户A购买了一件商品我们希望其他用户看到的商品库存会变更为99件，无疑RC级别更贴近这个事实。 RR-可重复读 RR级别是MySQL默认的事务隔离级别，它杜绝了脏读和不可重复读，使我们的结果看起来总是一致的不会变来变去，其实就是提高了事务隔离性。 我们上面说其实RC才更贴合身边的实际情况与人的思维方式，那么为什么MySQL会将RR做成默认级别呢？这个就涉及到一些历史原因，感兴趣的朋友可以查阅一下相关资料，毕竟Oracle和SqlServer都是将RC作为默认隔离级别。 言归正传，RR级别是支持可重复读的，那么会产生什么样的现象呢？如下所示，SESSION 1还是统计所有用户的总余额，而SESSSION 2依旧不断的变更Jack的余额并且COMMIT，此时SESSION 2将不会影响SESSION 1的统计结果，它的底层原理实际上是保存了一个一致性快照，具体可Google Search MVCC，这里不再进行例举： -- 恢复最开始Jack的余额 BEGIN; UPDATE userInfo SET balance = 13200 WHERE id = 1; COMMIT; -- SESSION 1 SET SESSION TRANSACTION ISOLATION LEVEL repeatable read; BEGIN; -- 开启一组事务 SELECT SUM(balance) FROM userInfo; -- 结果：45400.00 -- SESSION 2 BEGIN; -- 开启另一组事务 UPDATE userInfo SET balance = 0 WHERE id = 1; COMMIT; -- SESSION 1 SELECT SUM(balance) FROM userInfo; -- 结果：45400.00 -- SESSION 2 BEGIN; -- 开启另一组事务 UPDATE userInfo SET balance = 999999 WHERE id = 1; COMMIT; -- SESSION 1 SELECT SUM(balance) FROM userInfo; -- 结果：45400.00 SR-串行化 串读可以有效杜绝掉幻读现象，但是并发性支持就不好了，所以一般都不会使用它。 幻读现象 上面我们演示了脏读、不可重复、可重复读读现象，但是还没有演示幻读现象。 举一个例子，目前我们将删除所有性别是女的用户，当SESSION 1在删除的过程中SESSION 2又插入了一条性别是女的用户记录，那么SESSION 1在执行完操作后再看整个记录表会发现怎么还有一条记录没有删干净呢？看起来就跟产生幻觉一样： -- SESSION 1 SET SESSION TRANSACTION ISOLATION LEVEL repeatable read; -- 查看当前用户表 SELECT * FROM userInfo; +----+------+-----+--------+-----------+---------------+ | id | name | age | gender | balance | delete_status | +----+------+-----+--------+-----------+---------------+ | 1 | Jack | 18 | 1 | 999999.00 | 0 | | 2 | Tom | 19 | 1 | 12800.00 | 0 | | 3 | Mary | 17 | 0 | 9800.00 | 0 | | 4 | Anna | 17 | 0 | 9600.00 | 0 | +----+------+-----+--------+-----------+---------------+ -- 开启一组事务 BEGIN; UPDATE userInfo SET delete_status = 1 WHERE gender = 0; -- SESSION 2 -- 开启另一组事务，并新添加一个用户 BEGIN; INSERT INTO userInfo(name, age, gender, balance) VALUES (\"Anni\", 21, 0, 8888.00); COMMIT; -- SESSION 1 -- 突然发现多了一个安妮没有删除，产生幻觉了吗？ SELECT * FROM userInfo; +----+------+-----+--------+-----------+---------------+ | id | name | age | gender | balance | delete_status | +----+------+-----+--------+-----------+---------------+ | 1 | Jack | 18 | 1 | 999999.00 | 0 | | 2 | Tom | 19 | 1 | 12800.00 | 0 | | 3 | Mary | 17 | 0 | 9800.00 | 1 | | 4 | Anna | 17 | 0 | 9600.00 | 1 | | 5 | Anni | 21 | 0 | 8888.00 | 0 | +----+------+-----+--------+-----------+---------------+ 相信现在你应该能理解那句不可重复读侧重于修改记录，而幻读侧重于新增和删除记录了吧？ Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:48 "},"数据库专栏/MySQL/锁的知识.html":{"url":"数据库专栏/MySQL/锁的知识.html","title":"锁的知识","keywords":"","body":"功能概述 MySQL支持多线程操作，这就会造成数据安全问题，比如用户A在修改某一条记录时，用户B也刚好在修改这一条记录就会造成数据不一致的问题。 为了杜绝类似的情况发生，MySQL提供了多种锁机制来确保数据的一致性与隔离性，即一个用户在修改某一条记录时，其他用户只能排队等待上一个用户修改完成。 数据准备 学习MySQL锁相关知识前，我们可以准备如下一些数据： -- 库存表 CREATE TABLE in_stock( id INT PRIMARY KEY AUTO_INCREMENT COMMENT \"主键\", name CHAR(32) NOT NULL COMMENT \"商品名称\", price DECIMAL(10, 2) NOT NULL COMMENT \"商品价格\", quantity INT UNSIGNED NOT NULL COMMENT \"库存数量\", version INT UNSIGNED NOT NULL DEFAULT 0 COMMENT \"版本号\", INDEX idx(name) COMMENT \"普通索引(name)\" ) ENGINE innodb CHARSET utf8mb4 COLLATE utf8mb4_general_ci; -- 插入数据 INSERT INTO in_stock(name, price, quantity) VALUES (\"Phone\", 8999, 99), (\"TV\", 12999, 99), (\"Computer\", 18999, 99); 行锁表锁 基本概念 行锁与表锁现象可以根据不同的筛选情况出现： 筛选条件是索引列时，会触发行锁现象（可以锁一行，也可以锁多行，锁多行被称为区间锁） 筛选条件是非索引列时，会触发表锁现象 当用户进行COMMIT或者ROLLBACK操作时，将自动进行解锁操作。 行锁可以锁住某一行或多行的记录，这些记录不允许同时被其他用户进行修改，但可以被其他用户查询。 表锁可以锁住一张表中的所有记录，这些记录不允许同时被其他用户进行修改，但可以被其他用户查询。 由于InnoDB存储引擎支持行锁，因此它拥有更高的并发处理能力，而MyISAM只支持表锁，不支持行锁，所以InnoDB存储引擎确实要比MyISAM存储引擎优秀。 行锁现象 为了模拟并发场景，我们需要开启2个终端进行测试。 如下所示，SESSION 1开启事务，对库存表进行修改，筛选条件是索引列，此时将引发行锁现象锁住该记录。 SESSION 2不可对该记录进行事务语句操作，但是可以对该表中的其他行的记录进行事务语句操作。 -- SESSION 1 BEGIN; -- 筛选条件是索引列，触发行锁 UPDATE in_stock SET quantity = in_stock.quantity - 1 WHERE name = \"Phone\"; -- SESSION 2 BEGIN; -- 其他行操作、成功 UPDATE in_stock SET quantity = in_stock.quantity - 1 WHERE name = \"TV\"; -- 本行操作，行锁卡住 UPDATE in_stock SET quantity = in_stock.quantity - 1 WHERE name = \"Phone\"; -- SESSION 1 -- SESSION 1释放行锁，此时SESSION 2将继续执行 ROLLBACK; -- SESSION 2 -- 恢复初始数据 ROLLBACK; 表锁现象 为了模拟并发场景，我们需要开启2个终端进行测试。 如下所示，SESSION 1开启事务，对库存表进行修改，筛选条件是非索引列，此时将引发表锁现象锁住整张表。 SESSION 2不可对该表进行事务语句操作，唯有等到SESSION 1执行COMMIT或者ROLLBACK操作释放锁后SESSION 2才能继续执行操作。 -- SESSION 1 BEGIN; -- 筛选条件是非索引列，触发表锁 UPDATE in_stock SET quantity = in_stock.quantity - 1 WHERE price = 8999; -- SESSION 2 BEGIN; -- 其他行操作、表锁卡住 UPDATE in_stock SET quantity = in_stock.quantity - 1 WHERE name = \"TV\"; -- SESSION 1 -- SESSION 1释放表锁，此时SESSION 2将继续执行 ROLLBACK; -- SESSION 2 -- 恢复初始数据 ROLLBACK; 悲观乐观 基本概念 悲观锁顾名思义对所有的数据都是持悲观态度，认为该数据在对其进行操作时一定会和其他人产生冲突，所以我们在每次操作数据前都会手动对其进行加锁。 乐观锁顾名思义对所有的数据都是持乐观态度，认为该数据在对其进行操作时一定不会和其他人产生冲突，它更像是一种思路上的解决方案，而不是通过MySQL内部提供的某种功能或语句来解决的。 同行表锁一样，悲观锁与乐观锁在用户进行COMMIT或者ROLLBACK操作时，会自动进行解锁。 悲观锁 为了模拟并发场景，我们需要开启2个终端进行测试。 添加悲观锁可以利用FOR UPDATE语句进行，在使用时一定要注意： 如果WHERE条件后跟的是聚集索引，那么悲观锁就会锁行或者锁区间 如果WHERE条件后跟的是非聚集索引，那么悲观锁就会锁表 如下所示，SESSION 1开启了事务，使用FOR UPDATE语句锁住了所有id大于1的商品，此时只有SESSION 1才能对id大于1的商品进行更改，当然id等于1的商品SESSION 1也能更改。 SESSION 2开启了事务，尝试修改id大于1的商品中任何字段都会失败。 -- SESSION 1 BEGIN; -- 触发悲观锁, 锁住id大于1的商品, WHERE后面是聚集索引，将引发锁行 SELECT * FROM in_stock WHERE id > 1 FOR UPDATE; -- SESSION 2 BEGIN; -- 尝试修改未被悲观锁锁住的id为1的商品库存, 成功 UPDATE in_stock SET quantity = in_stock.quantity - 1 WHERE id = 1; -- 尝试修改被悲观锁锁住的id为2的商品库存, 失败 UPDATE in_stock SET quantity = in_stock.quantity - 1 WHERE id = 2; -- 尝试插入一条新的记录，失败，因为新插入的记录id为4 INSERT INTO in_stock(name, price, quantity) VALUES(\"PS5\", 2999, 99); -- SESSION 1 -- SESSION 1释放悲观锁，此时SESSION 2将继续执行 ROLLBACK; -- SESSION 2 -- 恢复初始数据 ROLLBACK; 此外还需要注意一点，如果SESSION 1锁住了id为1的商品，但是修改了id为2的商品，那么SESSION 1同样会将id为2的商品进行锁定，此时SESSION 2无法修改id为1和2的这两件商品： -- SESSION 1 BEGIN; -- 触发悲观锁, 锁住id等于1的商品, WHERE后面是聚集索引，将引发锁行 SELECT * FROM in_stock WHERE id = 1 FOR UPDATE; -- 修改id为1的商品库存，成功 UPDATE in_stock SET quantity = in_stock.quantity - 1 WHERE id = 1; -- 修改id为2的商品库存，成功，现在也会锁住这一条记录 UPDATE in_stock SET quantity = in_stock.quantity - 1 WHERE id = 2; -- SESSION 2 BEGIN; -- 尝试修改被悲观锁新锁住的id为2的商品库存, 失败 UPDATE in_stock SET quantity = in_stock.quantity - 1 WHERE id = 2; -- 尝试修改未被悲观锁锁住的id为3的商品库存, 成功 UPDATE in_stock SET quantity = in_stock.quantity - 1 WHERE id = 3; -- SESSION 1 -- SESSION 1释放悲观锁，此时SESSION 2将继续执行 ROLLBACK; -- SESSION 2 -- 恢复初始数据 ROLLBACK; 乐观锁 为了模拟并发场景，需要开启两个终端进行测试。 乐观锁在每次去拿数据的时候认为别人不会修改，所以不会对数据进行上锁，但是在提交更新的时候会判断在此期间数据是否被更改，如果被更改则提交失败。 它和悲观锁的区别在于： 悲观锁：不让别人动这个数据 乐观锁：别人可以动这个数据，但我要知道，别人动了我就不动了 乐观锁并不是由MySQL提供的，而是一种解决思路，如我们可以添加一些version版本号信息来判定该数据是否被其他人修改过，其他人要改动这行数据时也必须要改动version版本号，这是一种必须要遵守的约定。 如下所示，SESSION 1开启了事务，尝试对Phone的库存做出调整，我们知道目前Phone的version是0，所以更改完成后要对version加1。 恰在此时，SESSION 2也开启了事务，并且它也打算对Phone库存做出调整，此时SESSION 2认为Phone的version也是0，但是SESSION 1在调整完成Phone的库存后，version版本已经更新到了1，所以SESSION 2的这次提交会失败。 -- 注意！这个示例并不适用于在MySQL中进行重现 -- 因为MySQL中已经有了行锁/表锁，所以下面代码在执行时会产生锁表，这会导致SESSION 2的提交总是失败，切记乐观锁的思维方式即可 -- SESSION 1 BEGIN; UPDATE in_stock SET quantity = in_stock.quantity - 1, version = in_stock.version + 1 WHERE version = 0 AND name = \"Phone\"; -- 触发行表锁 -- SESSION 2 BEGIN; UPDATE in_stock SET quantity = in_stock.quantity - 1, version = in_stock.version + 1 WHERE version = 0 AND name = \"Phone\"; -- 触发行表锁 -- SESSION 1 -- 成功！version版本号更新为1 COMMIT; -- SESSION 2 -- 失败！version版本号为0的匹配不上 COMMIT; 读锁写锁 基本概念 针对一些不支持事务的存储引擎，可以使用读锁与写锁的方式来控制业务。 为表设置读锁后，当前会话和其他会话都不可以修改数据，但可以读取表数据。 为表设置了写锁后，只有当前会话可以修改，查询表，其他会话都将无法操作该表，包括查询。 因此读锁也被称之为共享锁，简称S，而写锁也被称之为排它锁，简称X。 读锁 基本语法格式如下： -- 设置读锁 LOCK TABLE 表名 READ; 业务逻辑 UNLOCK TABLES; -- 解除读锁 示例演示，SESSION 1为库存表设置读锁后，SESSION 2可以读取库存表的数据，但无法修改： -- SESSION 1 -- 加读锁 LOCK TABLE in_stock READ; -- 可读 SELECT * FROM in_stock; -- 不可写，抛出异常 UPDATE in_stock SET quantity = in_stock.quantity - 1 WHERE name = \"Phone\"; -- SESSION 2 -- 可读 SELECT * FROM in_stock; -- 不可写，阻塞，等待读锁释放 UPDATE in_stock SET quantity = in_stock.quantity - 1 WHERE name = \"Phone\"; -- SESSION 1 -- 释放读锁， SESSION 2可写 UNLOCK TABLES; 写锁 基本语法格式如下： -- 设置写锁 LOCK TABLE 表名 WRITE; 业务逻辑 UNLOCK TABLES; -- 解除写锁 示例演示，SESSION 1为库存表设置写锁后，SESSION 2不可以对库存表做任何操作，包括查询： -- SESSION 1 -- 加写锁 LOCK TABLE in_stock WRITE; -- 可读 SELECT * FROM in_stock; -- 可写 UPDATE in_stock SET quantity = in_stock.quantity - 1 WHERE name = \"Phone\"; -- SESSION 2 -- 不可读，阻塞，等待写锁释放 SELECT * FROM in_stock; -- 不可写，阻塞，等待写锁释放 UPDATE in_stock SET quantity = in_stock.quantity - 1 WHERE name = \"Phone\"; -- SESSION 1 -- 释写读锁， SESSION 2可读写 UNLOCK TABLES; Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:48 "},"数据库专栏/MySQL/运行日志.html":{"url":"数据库专栏/MySQL/运行日志.html","title":"运行日志","keywords":"","body":"运行日志 MySQL运行日志会记录MySQL服务过程中出现的所有级别的日志信息，它默认存放的路径位于MySQL数据目录下面，名称以hostname开头，.err结尾。 我们可以在配置文件中自己指定进行指定，重启mysqld.service服务后生效： [mysqld] log_error=/db/mysql57/3306/logs/mysqld.log 可以使用以下命令查看运行日志的存放路径，以及运行日志名称： SELECT @@LOG_ERROR; 尝试查看日志内容： $ vim /db/mysql57/3306/logs/mysqld.log -- 使用/ERROR搜索内容项，按n或者N来查看下一项或上一项 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:48 "},"数据库专栏/MySQL/查询日志.html":{"url":"数据库专栏/MySQL/查询日志.html","title":"查询日志","keywords":"","body":"查询日志 查询日志可以统计一些MySQL服务运行中性能较差的SQL语句，便于后期做语句优化。 首先需要在配置文件/etc/my.cnf中开启查询日志，重启mysqld.service服务后生效： [mysqld] slow_query_log=1 # 当前mysql服务查询日志已被打开 long_query_time=0.1 # 设定慢语句记录时间 slow_query_log_file=/db/mysql57/3306/logs/slow.log # 当前mysql服务的慢日志存放目录及日志名称 log_queries_not_using_indexes # 没走索引的语句也记录 在终端中使用mysqldumplow工具查看慢语句： -- -s代表排序，c代表排序规则是次数，-t代表是查看条目，10是条目数 -- 第一排序规则：最常用的语句 -- 第二排序规则：时间最久的语句 $ mysqldumpslow -s c -t 10 /db/mysql57/3306/logs/slow.log Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:48 "},"数据库专栏/MySQL/二进制日志.html":{"url":"数据库专栏/MySQL/二进制日志.html","title":"二进制日志","keywords":"","body":"基础知识 binlog 在MySQL中，二进制日志binlog的作用非常强大，它可以提供数据的备份恢复功能，且是主从搭建高可用服务的基础条件。 MySQL5.7中binlog默认处于关闭状态，我们需要在配置项中进行打开，如下所示，在/etc/my.cnf中新增以下配置项： [mysqld] log_bin=/db/mysql57/3306/logs/mysql_bin # 当前mysql服务的二进制日志存放目录以及日志名称 binlog_format=row # mysql中二进制日志的格式化模式 配置项新增完成后需要重启mysqld.service服务： $ systemctl restart mysqld.service 记录模式 binlog的记录模式有3种，如下所示： statement：SQL语句模式，可读性好，占用空间大，数据可能不准确 row：行模式，可读性差，占用空间小，但记录精准，是十分推荐的记录模式 mixed：混合模式，statement和row的结合体，混合模式，不推荐使用 关于记录模式的配置首选row模式，但是在MySQL5.6中默认记录模式是statement模式，所以我们最好还是在/etc/my.cnf中手动修改一下binlog_format的参数。 记录单元 binlog的最小记录单元为event，每一行语句都代表了一个事件，且每个事件都有开始和结束的标识位。 如下所示： -- 自动提交事务的模式下（autocommit=1），一条语句就是一个event > UPDATE userInfo SET age = age + 1 WHERE name = \"Jack\"; --> event01 20 - 145 -- 非自动提交事务的模式下（autocommit=0），一个commit就是一个envent > BEGIN; --> event01 100 - 120 > UPDATE userInfo SET age = age + 1 WHERE name = \"Jack\"; --> event02 120 - 342 > COMMIT; --> event03 342 - 560 相关命令 下面是一些常用的配置查看相关命令： -- 查看全局的二进制日志文件记录功能是否打开 > SELECT @@LOG_BIN; -- 查看二进制日志文件的存放路径以及二进制日志文件的前缀名 > SELECT @@LOG_BIN_BASENAME; -- 查看当前MySQL实例的服务ID号 > SELECT @@SERVER_ID; -- 查看二进制日志文件的记录格式 > SELECT @@BINLOG_FORMAT; -- 查看二进制日志文件的磁盘刷新策略，如果为1，二进制日志文件的记录将被立马刷写到磁盘 > SELECT @@SYNC_BINLOG; 日志分析 event命令分析日志 event可用于在MySQL交互环境下管理binlog文件及分析binlog内容，以下是常用命令： -- 查看目前所所拥有的所有二进制日志文件： > SHOW BINARY LOGS; -- 查看目前正在使用的二进制日志文件 > SHOW MASTER STATUS; -- 查看某个二进制日志文件记录的内容 > SHOW BINLOG EVENTS IN \"二进制日志文件名\"; -- 立马新增一个二进制日志文件 > FLUSH LOGS; 使用event进行日志分析的案例： -- 1. 登录至MySQL $ mysql -uroot -p -- 2. 查看当前正在使用的binlog文件 > SHOW MASTER STATUS; +------------------+----------+--------------+------------------+-------------------+ | File | Position | Binlog_Do_DB | Binlog_Ignore_DB | Executed_Gtid_Set | +------------------+----------+--------------+------------------+-------------------+ | mysql_bin.000001 | 154 | | | | +------------------+----------+--------------+------------------+-------------------+ -- file：当前MySQL正在使用的二进制日志文件名 -- Position：最后一个事件的结束位置号 -- Binlog_Do_DB：binlog日志白名单，只针对某个库进行记录 -- Binlog_Ignore_DB：binlog日志黑名单，只针对某个库不进行记录 -- Executed_Gtid_Set：GTID的记录情况，只有开了GTID模式后才会出现 -- 3. 使用event命令查看该二进制日志文件记录的内容 > SHOW BINLOG EVENTS IN \"mysql_bin.000001\"; +------------------+-----+----------------+-----------+-------------+---------------------------------------+ | Log_name | Pos | Event_type | Server_id | End_log_pos | Info | +------------------+-----+----------------+-----------+-------------+---------------------------------------+ | mysql_bin.000001 | 4 | Format_desc | 3306 | 123 | Server ver: 5.7.34-log, Binlog ver: 4 | | mysql_bin.000001 | 123 | Previous_gtids | 3306 | 154 | | +------------------+-----+----------------+-----------+-------------+---------------------------------------+ -- Log_name：binlog文件名 -- Pos：事件的开始位置号 -- Event_type：事件类型 -- Format_desc：格式描述，每一个日志文件的第一个事件，对用户没有意义，MySQL识别binlog的必要信息 -- Server_id：mysql服务号标识 -- End_log_pos：事件的结束位置号 -- Info：事件内容 现在我们来创建一个库和表，再用标准事务为该表插入数据，查看二进制日志文件记录内容的变化： > CREATE DATABASE db CHARSET utf8mb4; > use db; > CREATE TABLE tb(id INT) ENGINE innodb CHARSET utf8 COLLATE utf8_unicode_ci; > BEGIN; > INSERT INTO tb(id) VALUES (1), (2), (3); > COMMIT; 可以看到mysql_bin.000001中的event变化了： > SHOW BINLOG EVENTS IN \"mysql_bin.000001\"; +------------------+-----+----------------+-----------+-------------+--------------------------------------------------------------------------------------+ | Log_name | Pos | Event_type | Server_id | End_log_pos | Info | +------------------+-----+----------------+-----------+-------------+--------------------------------------------------------------------------------------+ | mysql_bin.000001 | 4 | Format_desc | 3306 | 123 | Server ver: 5.7.34-log, Binlog ver: 4 | | mysql_bin.000001 | 123 | Previous_gtids | 3306 | 154 | | | mysql_bin.000001 | 154 | Anonymous_Gtid | 3306 | 219 | SET @@SESSION.GTID_NEXT= 'ANONYMOUS' | | mysql_bin.000001 | 219 | Query | 3306 | 323 | CREATE DATABASE db CHARSET utf8mb4 | | mysql_bin.000001 | 323 | Anonymous_Gtid | 3306 | 388 | SET @@SESSION.GTID_NEXT= 'ANONYMOUS' | | mysql_bin.000001 | 388 | Query | 3306 | 532 | use `db`; CREATE TABLE tb(id INT) ENGINE innodb CHARSET utf8 COLLATE utf8_unicode_ci | | mysql_bin.000001 | 532 | Anonymous_Gtid | 3306 | 597 | SET @@SESSION.GTID_NEXT= 'ANONYMOUS' | | mysql_bin.000001 | 597 | Query | 3306 | 667 | BEGIN | | mysql_bin.000001 | 667 | Table_map | 3306 | 710 | table_id: 108 (db.tb) | | mysql_bin.000001 | 710 | Write_rows | 3306 | 760 | table_id: 108 flags: STMT_END_F | | mysql_bin.000001 | 760 | Xid | 3306 | 791 | COMMIT /* xid=30 */ | +------------------+-----+----------------+-----------+-------------+--------------------------------------------------------------------------------------+ 现在来对其进行分析： 219 - 323：创建db库 338 - 532：进入db库并创建tb表 597 - 791：向tb表中插入记录 mysqlbinlog工具 mysqlbinlog是MySQL自带的一个终端工具，可用于在非MySQL交互环境下分析binlog内容，它能对row模式记录的event事件进行一定程度的解密，下面是一些基本命令： -- 使用mysqlbinlog工具查看binlog $ mysqlbinlog --no-defaults /db/mysql57/3306/logs/mysql_bin.000001 -- 如果binlog的记录模式为row，可使用以下命令对其进行解密 $ mysqlbinlog --no-defaults --base64-output=decode-rows -v /db/mysql57/3306/logs/mysql_bin.000001 -- 只查看某个库下的binlog日志记录 $ mysqlbinlog --no-defaults -d db /db/mysql57/3306/logs/mysql_bin.000001 -- 指定部分日期区间查看 $ mysqlbinlog --no-defaults --start-datetime='2019-05-06 17:00:00' --stop-datetime='2019-05-06 17:01:00' /db/mysql57/3306/logs/mysql_bin.000001 -- no-defaults的作用：在my.cnf中添加了default-character-set=utf8mb4选项，那么mysqlbinlog在查看binlog时就会跑错，此时加上该参数可避免报错 使用mysqlbinlog工具进行日志分析的案例： $ mysqlbinlog --no-defaults --base64-output=decode-rows -d db /db/mysql57/3306/logs/mysql_bin.000001 预期得到的结果： 219 - 323：创建db库 338 - 532：进入db库并创建tb表 597 - 791：向tb表中插入记录 内容如下，仅截取分析部分： # at 219 #211126 3:44:07 server id 3306 end_log_pos 323 CRC32 0xbab39da3 Query thread_id=5 exec_time=0 error_code=0 SET TIMESTAMP=1637869447/*!*/; SET @@session.pseudo_thread_id=5/*!*/; SET @@session.foreign_key_checks=1, @@session.sql_auto_is_null=0, @@session.unique_checks=1, @@session.autocommit=1/*!*/; SET @@session.sql_mode=1436549152/*!*/; SET @@session.auto_increment_increment=1, @@session.auto_increment_offset=1/*!*/; /*!\\C utf8mb4 *//*!*/; SET @@session.character_set_client=45,@@session.collation_connection=45,@@session.collation_server=45/*!*/; SET @@session.lc_time_names=0/*!*/; SET @@session.collation_database=DEFAULT/*!*/; CREATE DATABASE db CHARSET utf8mb4 /*!*/; # at 323 # at 388 #211126 3:46:06 server id 3306 end_log_pos 532 CRC32 0x17abb3bc Query thread_id=5 exec_time=0 error_code=0 use `db`/*!*/; SET TIMESTAMP=1637869566/*!*/; CREATE TABLE tb(id INT) ENGINE innodb CHARSET utf8 COLLATE utf8_unicode_ci /*!*/; # at 532 # at 597 #211126 3:46:44 server id 3306 end_log_pos 667 CRC32 0xd3079646 Query thread_id=5 exec_time=0 error_code=0 SET TIMESTAMP=1637869604/*!*/; BEGIN /*!*/; # at 667 #211126 3:46:44 server id 3306 end_log_pos 710 CRC32 0xa58d1e1e Table_map: `db`.`tb` mapped to number 108 # at 710 #211126 3:46:44 server id 3306 end_log_pos 760 CRC32 0x5b38c26e Write_rows: table id 108 flags: STMT_END_F # at 760 #211126 3:46:45 server id 3306 end_log_pos 791 CRC32 0x08faebdf Xid = 30 COMMIT/*!*/; 数据恢复 日志截取 分析完binlog后，我们可以通过mysqlbinlog工具对特定范围内的binlog记录进行截取并将其存储为备份文件，后续恢复时可直接导入该文件进行数据恢复。 截取命令如下所示： mysqlbinlog --no-defaults --start-position=开始的事件号 --stop-position=结束的事件号 binlog路径 > 输出的文件.sql 故障演练 下面我们来做一个简单的故障演练，生产库不小心误删除了db库，我们将使用binlog来对其进行恢复： -- 1.登录生产库 $ mysql -uroot -p -- 2.模拟误删除操作 > DROP DATABASE db; -- 3.查看目前正在使用的binlog文件 > SHOW MASTER STATUS; -- 4.退出交互环境 > exit; -- 5.使用mysqlbinlog工具分析binlog记录，得到的结果为 219 - 791 $ mysqlbinlog --no-defaults --base64-output=decode-rows -v /db/mysql57/3306/logs/mysql_bin.000001 -- 6.使用mysqlbinlog的截取命令，生成backup文件 $ mysqlbinlog --no-defaults --start-position=219 --stop-position=791 /db/mysql57/3306/logs/mysql_bin.000001 > /tmp/backup.sql -- 7.将backup文件发送给测试库 $ scp -r /tmp/backup.sql root@192.168.0.130:/tmp -- 8.登录测试库进行恢复数据，查看是否恢复正确 $ mysql -uroot -p -- 9.临时关闭binlog记录 > SET sql_log_bin=0; -- 10.恢复数据 > SOURCE /tmp/backup.sql -- 11.打开binlog记录 > SET sql_log_bin=1; -- 12.查看数据，确保数据完全被恢复 > SELECT * FROM db.tb; -- 13.进入生产库，恢复数据 略 日志清理 自动清理 使用以下命令，可查看到是否开启自动清理二进制日志文件与清理的周期： > SELECT @@EXPIRE_LOGS_DAYS; +--------------------+ | @@EXPIRE_LOGS_DAYS | +--------------------+ | 0 | +--------------------+ 配置自动清理日志的周期： [mysqld] expire_logs_days=15; # 二进制日志文件保留15天后自动清理，也就是拥有15天的全备 手动清理 手动清理二进制日志文件的三种方式： -- 清除3天前的日志 > PURGE BINARY LOGS BEFORE now() - INTERVAL 3 day; -- 对某些日志文件进行清除，有10个删除前9个 > PURGE BINARY LOGS TO 'mysql_bin.000010'; -- 清除所有日志文件，新的文件计数从1开始，主从环境下禁止该操作！从库必崩 > RESET MASTER; 日志轮询 日志除开可以手动的执行FLUSH LOGS的命令外，当日志达到1GB时也会自动进行轮询，你可以在配置文件中进行配置： [mysqld] max_binlog_size=1073741824 # binlog日志轮询的大小，这里保持默认值 GTID介绍 工作模式 GTID是MySQL5.6新加入的特性，且在5.7中进行了增强，旨在让我们用更加简单的方式管理binlog。 现在的主流binlog管理方案都是GTID+ROW模式进行的，主要是方便备份和恢复。 GTID模式和event模式完全不同，对于event模式来说它的记录单元是事件，一组标准事务语句可能包含多个事件。 而对于GTID模式来说，它的记录单元是一次COMMIT，也可理解为一组标准事务语句仅能产生一次变更。 同时GTID模式拥有一个非常重要的概念GTID号，每次的COMMIT都会产生一个不同的GTID号，如下所示： -- 首先每个MySQL服务都有一个UUID号 -- 它默认存在于数据目录下的auto.cnf文件中 $ cat /db/mysql57/3306/data/auto.cnf [auto] server-uuid=4e4c5a8d-4e05-11ec-a21b-000c290fdc76 -- 每次提交一个事务，提交事务次数都会发生改变，默认是从1开始 4e4c5a8d-4e05-11ec-a21b-000c290fdc76:1 产生事务并提交 4e4c5a8d-4e05-11ec-a21b-000c290fdc76:2 产生事务并提交 4e4c5a8d-4e05-11ec-a21b-000c290fdc76:3 -- server_UUID号+:+transaction_id = GTID号 如果在做数据恢复的时候，某个GTID号已存在，则不会恢复这一条语句，这种策略被称为GTID幂等性。 配置使用 要想使用GTID模式，我们必须在配置文件中将其进行打开： [mysqld] gtid-mode=on # 当前mysql服务的binlog记录GTID模式以被打开 35 enforce-gtid-consistency=true # 当前mysql服务GTID幂等性约束已被打开 配置完成后记得重启mysql.service服务： $ systemctl restart mysqld.service 查看GTID 现在我们来创建一个新的数据库，主要查看GTID号的变化： -- 查看GTID模式下的初始状态 > SHOW MASTER STATUS; +------------------+----------+--------------+------------------+-------------------+ | File | Position | Binlog_Do_DB | Binlog_Ignore_DB | Executed_Gtid_Set | +------------------+----------+--------------+------------------+-------------------+ | mysql_bin.000001 | 154 | | | | +------------------+----------+--------------+------------------+-------------------+ -- 创建库后再次查看GTID模式下的状态 > CREATE DATABASE db CHARSET utf8mb4; > use db; > SHOW MASTER STATUS; +------------------+----------+--------------+------------------+----------------------------------------+ | File | Position | Binlog_Do_DB | Binlog_Ignore_DB | Executed_Gtid_Set | +------------------+----------+--------------+------------------+----------------------------------------+ | mysql_bin.000001 | 323 | | | 4e4c5a8d-4e05-11ec-a21b-000c290fdc76:1 | +------------------+----------+--------------+------------------+----------------------------------------+ -- 创建表后再次查看GTID模式下的状态 > CREATE TABLE tb(id INT) ENGINE innodb CHARSET utf8 COLLATE utf8_unicode_ci; > SHOW MASTER STATUS; +------------------+----------+--------------+------------------+------------------------------------------+ | File | Position | Binlog_Do_DB | Binlog_Ignore_DB | Executed_Gtid_Set | +------------------+----------+--------------+------------------+------------------------------------------+ | mysql_bin.000001 | 532 | | | 4e4c5a8d-4e05-11ec-a21b-000c290fdc76:1-2 | +------------------+----------+--------------+------------------+------------------------------------------+ -- 开启标准事务，插入1条数据并提交 > BEGIN; > INSERT INTO tb(id) VALUES (1); > COMMIT; > SHOW MASTER STATUS; +------------------+----------+--------------+------------------+------------------------------------------+ | File | Position | Binlog_Do_DB | Binlog_Ignore_DB | Executed_Gtid_Set | +------------------+----------+--------------+------------------+------------------------------------------+ | mysql_bin.000001 | 781 | | | 4e4c5a8d-4e05-11ec-a21b-000c290fdc76:1-3 | +------------------+----------+--------------+------------------+------------------------------------------+ -- 开启标准事务，插入1条数据并提交 > BEGIN; > INSERT INTO tb(id) VALUES (2); > COMMIT; > SHOW MASTER STATUS; +------------------+----------+--------------+------------------+------------------------------------------+ | File | Position | Binlog_Do_DB | Binlog_Ignore_DB | Executed_Gtid_Set | +------------------+----------+--------------+------------------+------------------------------------------+ | mysql_bin.000001 | 1030 | | | 4e4c5a8d-4e05-11ec-a21b-000c290fdc76:1-4 | +------------------+----------+--------------+------------------+------------------------------------------+ -- 开启标准事务，删除1条数据并提交 > BEGIN; > DELETE FROM tb WHERE id = 1; > COMMIT; > SHOW MASTER STATUS; +------------------+----------+--------------+------------------+------------------------------------------+ | File | Position | Binlog_Do_DB | Binlog_Ignore_DB | Executed_Gtid_Set | +------------------+----------+--------------+------------------+------------------------------------------+ | mysql_bin.000001 | 1279 | | | 4e4c5a8d-4e05-11ec-a21b-000c290fdc76:1-5 | +------------------+----------+--------------+------------------+------------------------------------------+ 日志截取 上面我们插入了记录1、2并且删除了记录1，现在我们要恢复记录1的插入该怎么做呢？ 首先还是要分析日志，需要注意当前用的是mysql_bin.000001号日志： $ mysqlbinlog --no-defaults --base64-output=decode-rows -v /db/mysql57/3306/logs/mysql_bin.000001 得到的结果： ----- 插入 ----- # 上面最近的一个GTID号是： SET @@SESSION.GTID_NEXT= '4e4c5a8d-4e05-11ec-a21b-000c290fdc76:3'/*!*/; # at 710 #211126 6:18:07 server id 3306 end_log_pos 750 CRC32 0x04161e17 Write_rows: table id 108 flags: STMT_END_F ### INSERT INTO `db`.`tb` ### SET ### @1=1 # at 750 #211126 6:18:11 server id 3306 end_log_pos 781 CRC32 0x6a65e676 Xid = 16 COMMIT/*!*/; ----- 删除 ----- # 上面最近的一个GTID号是： SET @@SESSION.GTID_NEXT= '4e4c5a8d-4e05-11ec-a21b-000c290fdc76:5'/*!*/; # at 1208 #211126 6:19:04 server id 3306 end_log_pos 1248 CRC32 0x79734300 Delete_rows: table id 108 flags: STMT_END_F ### DELETE FROM `db`.`tb` ### WHERE ### @1=1 # at 1248 #211126 6:19:11 server id 3306 end_log_pos 1279 CRC32 0xaf7c88b4 Xid = 24 COMMIT/*!*/; 一些常用的截取命令如下： -- include-gtids的作用：我要2-5 $ mysqlbinlog --no-defaults --skip-gtids --include-gtids='UUID号:2-5' binlog文件路径 > 输出的文件.sql -- exclude-gtids的作用：我要1-4，但是不要3 $ mysqlbinlog --no-defaults --skip-gtids --include-gtids='UUID号:1-4' --exclude-gtids='UUID号:3' binlog文件路径 > 输出的文件.sql -- 选择性的截取，我只要2和3，其他的不要 $ mysqlbinlog --no-defaults --skip-gtids --include-gtids='UUID号:2','UUID号:3' binlog文件路径 > 输出的文件.sql -- 排除性的截取，我要1-4，但是不要2和3 $ mysqlbinlog --no-defaults --skip-gtids --include-gtids='UUID号:1-4' --exclude-gtids='UUID号:2','UUID号:3' binlog文件路径 > 输出的文件.sql -- skip-gtids参数的作用：导出数据时不导出GTID相关的数据，这样就会跳过幂等性检查，如果导出时不加该参数则恢复时会失败 我们仅要第3条： $ mysqlbinlog --no-defaults --skip-gtids --include-gtids='4e4c5a8d-4e05-11ec-a21b-000c290fdc76:3' /db/mysql57/3306/logs/mysql_bin.000001 > /tmp/backup.sql 恢复操作 下面我就不在测试库进行确认了，因为按照一般的流程对截取出的记录做恢复时要先在测试库中做操作，确保恢复的没有问题才能在生产库中做操作。 -- 1.经测试库测试 略 -- 2.登录生产库 $ mysql -uroot -p -- 3.临时关闭binlog记录 > SET sql_log_bin=0; -- 4.恢复数据 > SOURCE /tmp/backup.sql -- 5.打开binlog记录 > SET sql_log_bin=1; -- 6.查看数据，确保数据完全被恢复 > SELECT * FROM db.tb; Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:48 "},"数据库专栏/MySQL/备份恢复.html":{"url":"数据库专栏/MySQL/备份恢复.html","title":"备份恢复","keywords":"","body":"备份策略 备份策略大体可分为全量备份与增量备份两种形式。 至少要保证在一个周期内进行全量备份。 备份检查 备份检查项分为两种。 第一项：检查备份是否正常、是否存在不合理的语句也被备份了的情况。 第二项：检查备份空间是否够用，一般来说我们会将备份信息单独存放在另一块磁盘中。 备份种类 备份种类从根上来讲可分为两类、物理备份以及逻辑部分。 从备份时对正常生产的影响来说，又分为热备份、温备份、冷备份三种。 它们的区别如下： 热备份：对数据库正常业务影响较小，不会产生锁表行为的发生，并且在备份过程中新加入的数据也会进行备份，对于InnoDB存储引擎的表来说能够做到一致性恢复 温备份：在备份时会进行锁表操作，对于MyISAM存储引擎的表来说，将只能查询而不能修改，会影响到写入操作 冷备份：必须关停数据库业务，在数据没有任何变更的情况下进行备份 通常情况下我们都会选择热备份。 备份迁徙 备份迁徙可分为同架构迁徙和异架构迁徙。 如MySQL迁徙到MySQL属于同架构迁徙，而MongoDB迁徙到MySQL属于异架构迁徙。 备份演练 恢复演练是指在业务正常的情况中，在非生产库中进行手动误删除数据且恢复数据的操作。 用于应对任何可能对生产产生威胁的情况，如数据库宕机、磁盘损坏等。 恢复流程 当生产库中的数据发生异常时，采用以下流程进行数据恢复操作： 将生产库中最近的全备文件和相关的二进制日志文件拷贝到测试库中 在测试库中对全备文件以及二进制日志文件进行解析，尝试恢复所有正常数据与操作 测试库中数据恢复完成之后，将整个测试库中恢复出的数据进行全备 将测试库中生成的全备文件拷贝至生产库中，进行数据恢复 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:48 "},"数据库专栏/MySQL/mysqldump.html":{"url":"数据库专栏/MySQL/mysqldump.html","title":"mysqldump","keywords":"","body":"功能概述 mysqldump简称MBP，是一款MySQL自带的逻辑备份与数据恢复工具，不需要额外的安装下载。 mysqldump备份出的文件内容均为SQL语句，因此可读性非常高，此外mysqldump对备份文件的压缩率也非常高，这能极大的节省磁盘空间。 尽管mysqldump十分优秀，但是它仍然有一些难以掩饰的缺点。 比如，mysqldump十分依赖存储引擎，它的备份过程是先从磁盘中把数据读取出来然后依赖存储引擎将其转变为SQL语句，比较消耗资源且对于数据量级很大的备份操作来说效率较低。 并且mysqldump并不支持真正意义上的热备份，而是只支持快照备份，因此对数据变更频率较高的库进行备份时，mysqldump可能会存在部分数据丢失的情况，需要配合binlog才能完全恢复数据。 此外，mysqldump并不支持增量备份，仅支持全备份。 备份相关 基础命令 以下两种命令格式，可用于链接本地或远程的MySQL服务器，是备份的基础命令。 -- 本地备份的基础链接命令 $ mysqldump -uroot -p -S /tmp/mysql.sock -- 远程备份的基础链接命令 $ mysqldump -uroot -p -h地址 -P端口 全库全表 参数-A用于进行所有库下所有表的全备操作，如下操作演示： $ mysqldump -uroot -p -A > /tmp/full.sql 如果出现以下警告信息，一定要谨慎： Warning: A partial dump from a server that has GTIDs will by default include the GTIDs of all transactions, even those that changed suppressed parts of the database. If you don't want to restore GTIDs, pass --set-gtid-purged=OFF. To make a complete dump, pass --all-databases --triggers --routines --events. 警告：默认情况下，来自具有 GTID 的服务器的部分转储将包括所有事务的 GTID，即使是那些更改了数据库中被抑制部分的事务。 如果您不想恢复 GTID，请传递 --set-gtid-purged=OFF。 要进行完整的转储，请传递 --all-databases --triggers --routines --events。 它会然你加一些参数，此时一定要注意--set-gtid-purged=OFF这个参数，对于普通备份来讲可以加上该参数，如果是构建主从环境时则千万不要加，因为它会在备份的SQL文件中额外的加入一些信息，有了这些信息主从就搭建不了。 指定某库 参数-B用于进行指定某些库下所有表的全备操作，如下操作演示： $ mysqldump -uroot -p -B 库名1 库名2 > /tmp/full.sql 这种备份操作一般来说会比较少做，因为在生产环境中我们会将所有的MySQL内置库也一同会进行备份。 指定某表 备份单个表或者多个表时，可使用以下的示例进行操作： -- 备份库1下的表1和表2 $ mysqldump -uroot -p 库名1 表名1 表名2 > /tmp/full.sql -- 备份库1下的所有表，由于没有加参数-B，所以生成的SQL语句中没有use 库1的操作，需要手动进行use $ mysqldump -uroot -p 库名1 > /tmp/full.sql 推荐参数 -R代表存储过程，-E代表事件，--triggers代表触发器，一般做备份操作的时候都把这三个参数加上即可。 $ mysqldump -uroot -p -A -R -E --triggers > /tmp/full.sql --master-data=2这个参数配置项如果加入，则会以注释的形式，保存备份开始时间点的binlog的状态信息，是一个必加参数。 $ mysqldump -uroot -p -A -R -E --triggers --master-data=2 > /tmp/full.sql # 功能1： # 在备份时，会自动记录，二进制日志文件名和位置号，如下所示： # CHANGE MASTER TO MASTER_LOG_FILE='mysql_bin.000002', MASTER_LOG_POS=154; # 它告诉你的信息是，目前所备份截止的数据是在mysql_bin.000002中的154事件处 # 在数据恢复时，我们恢复了这个全备文件，还有一些全备周期后的数据需要从binlog中进行截取恢复，那么就打开binlog文件mysql_bin.000002 # 截取154号事件及其后面的事件进行恢复即可。 # 功能2： # 自动对备份时的表进行锁定操作，如果配合--single-transaction参数，则只对非InnoDB引擎的表进行锁表 # 而--single-transaction参数是进行快照备份的前提参数，所谓快照备份是指在备份时新加入的数据并不会记录，这也是mysqldump的一个特点，不支持真正的热备份 # 所以需要像上面说的那样，mysqldump需要配合binlog来进行数据恢复，才能保持恢复后数据的完整性 --single-transaction也是一个必加参数，用于支持InnoDB引擎开启快照备份： $ mysqldump -uroot -p -A -R -E --triggers --master-data=2 --single-transaction > /tmp/full.sql --max-allowed-packet是一个可选性参数，一般来说我们也会将它加上，在远程备份时，我们需要将远程Server端的数据备份到本地，这个时候就会涉及到数据包大小的问题，使用该参数指定本地可收到的远程Server端传输的最大数据量。 $ mysqldump -uroot -p -A -R -E --triggers --master-data=2 --single-transaction --max-allowed-packet=512M > /tmp/full.sql -F代表在备份开始时，刷新一个或多个二进制日志文件，究竟是几个取决于备份库的数量，不推荐添加该参数，可能会一次性刷出很多二进制日志文件。 --set-gtid-purged=auto参数是一个可有可无的选项参数，默认值是auto其实就是on开启的意思，当开启时，会在全备文件中生成一个GTID号，由于GTID号具有幂等性，在做主从配置时，从库导入主库数据时发现该GTID号存在就不会将数据进行导入，如果该参数被设置为off，则全备文件中就不会生成GTID号，从库导入主库数据时即使该数据已经被导入了一次由于没有GTID号进行限制便会进行二次导入，这样主从搭建就会出现问题。 所以说该参数直接忘记它就好，因为它默认就是开启的，这正是我们所需要的状态。 故障演练 情况介绍 我的远端服务器上有1个db1的数据库出现了问题崩掉了，我需要对它进行恢复。 备份策略：每周2晚上23：00开始使用mysqldump进行全备，包括但不限于db1的所有库表信息，包括系统库。 故障时间：在周3凌晨的3：00时，数据库发生异常。 当前时间：现在是周3上午8：00，在这期间肯定有新数据的变更记录。 二进制日志：使用了二进制日志，并且记录模式是GTID+ROW 解决思路：使用mysqldump将全备进行恢复，至于周2晚23：00至周3上午8：00中的数据，可使用binlog进行恢复，恢复思路是找到周3凌晨3：00误操作的事件不对其进行截取，截取所有正常操作的事件。 准备数据 登录远程服务器，进入线上数据库开始准备数据： $ ssh 192.168.0.120 $ mysql -uroot -p 模拟周2晚23：00之前的数据： CREATE DATABASE db1 CHARSET utf8mb4; USE db1; CREATE TABLE userInfo( id INT PRIMARY KEY AUTO_INCREMENT COMMENT \"主键\", name CHAR(64) NOT NULL COMMENT \"姓名\", age TINYINT NOT NULL COMMENT \"年龄\" ) ENGINE innodb CHARSET utf8mb4 COLLATE utf8mb4_general_ci; BEGIN; INSERT INTO userInfo(name, age) VALUES (\"Jack\", 18), (\"Mary\", 18), (\"Tom\", 18); COMMIT; EXIT; 模拟周2晚23：00时的全备份： $ mysqldump -uroot -p -A -R -E --triggers --master-data=2 --single-transaction --max-allowed-packet=512M > /tmp/full.sql 模拟其他时间段的数据以及误操作： -- 模拟23:00全备完成后至发生误操作之前新插入的数据 USE db1; BEGIN; INSERT INTO userInfo(name, age) VALUES (\"Anni\", 21); COMMIT; -- 模拟3:00发生的误操作 BEGIN; DELETE FROM userInfo WHERE id > 1; COMMIT; -- 模拟3:00到8:00之后的数据 BEGIN; INSERT INTO userInfo(name, age) VALUES (\"Booby\", 19); COMMIT; 最终剩余的数据如下： SELECT * FROM db1.userInfo; +----+-------+-----+ | id | name | age | +----+-------+-----+ | 1 | Jack | 18 | | 5 | Booby | 19 | +----+-------+-----+ 数据截取 首先第一步，我们现在手里有全备文件，打开全备文件查看最后的全备时正在使用的二进制日志文件以及截止的事件点，全备文件中已经备份到了GTID3的地方： SET @@GLOBAL.GTID_PURGED='4e4c5a8d-4e05-11ec-a21b-000c290fdc76:1-3'; -- CHANGE MASTER TO MASTER_LOG_FILE='mysql_bin.000001', MASTER_LOG_POS=978; 然后是第二步，我们需要查看目前二进制日志文件已经记录到的文件编号与事件点，注意这里binlog已经记录到了GTID6的地方： > SHOW MASTER STATUS; +------------------+----------+--------------+------------------+------------------------------------------+ | File | Position | Binlog_Do_DB | Binlog_Ignore_DB | Executed_Gtid_Set | +------------------+----------+--------------+------------------+------------------------------------------+ | mysql_bin.000001 | 1806 | | | 4e4c5a8d-4e05-11ec-a21b-000c290fdc76:1-6 | +------------------+----------+--------------+------------------+------------------------------------------+ 第三步，分析二进制日志文件、找出误操作的事件点，如果有多个二进制文件则逐个进行分析： $ mysqlbinlog --no-defaults --base64-output=decode-rows -vvv /db/mysql57/3306/logs/mysql_bin.000001 GTID5号处为误操作，截取关键内容如下： # 上面最近的一个GTID号是： SET @@SESSION.GTID_NEXT= '4e4c5a8d-4e05-11ec-a21b-000c290fdc76:5'/*!*/; # at 1436 #211126 7:29:34 server id 3306 end_log_pos 1506 CRC32 0x903fb9e8 Delete_rows: table id 190 flags: STMT_END_F ### DELETE FROM db1.userInfo ### WHERE ### @1=2 /* INT meta=0 nullable=0 is_null=0 */ ### @2='Mary' /* STRING(256) meta=60928 nullable=0 is_null=0 */ ### @3=18 /* TINYINT meta=0 nullable=0 is_null=0 */ ### DELETE FROM db1.userInfo ### WHERE ### @1=3 /* INT meta=0 nullable=0 is_null=0 */ ### @2='Tom' /* STRING(256) meta=60928 nullable=0 is_null=0 */ ### @3=18 /* TINYINT meta=0 nullable=0 is_null=0 */ ### DELETE FROM db1.userInfo ### WHERE ### @1=4 /* INT meta=0 nullable=0 is_null=0 */ ### @2='Anni' /* STRING(256) meta=60928 nullable=0 is_null=0 */ ### @3=21 /* TINYINT meta=0 nullable=0 is_null=0 */ # at 1506 也就是说，我们在截取线上库的二进制日志时，不截取GTID为5的即可。 现在对二进制日志文件中的数据进行截取： -- 全备文件中截取到GTID3的地方 -- 所以我们接下来就要截取binlog文件里GTID4-6的地方 -- 但是不要5这个误操作 $ mysqlbinlog --no-defaults --skip-gtids --include-gtids='4e4c5a8d-4e05-11ec-a21b-000c290fdc76:4-6' --exclude-gtids='4e4c5a8d-4e05-11ec-a21b-000c290fdc76:5' /db/mysql57/3306/logs/mysql_bin.000001 > /tmp/bin.sql 恢复数据 现在，我们需要将线上服务器的全备文件以及截取到的binlog文件发送至本地，尝试进行恢复，如果恢复效果良好则再放到线上库中正式恢复。 第一步，下载生产库中的全备文件以及binlog文件生成的备份文件： $ scp root@192.168.0.120:/tmp/full.sql /tmp $ scp root@192.168.0.120:/tmp/bin.sql /tmp 第二步，在本地服务器上进行测试，尝试恢复，此时一定要确保本地服务器的数据库是干净且没有任何数据的： $ mysql -uroot -p > SET SQL_LOG_BIN = 0; > SOURCE /tmp/full.sql > SOURCE /tmp/bin.sql > SET SQL_LOG_BIN = 1; 第三步，恢复完成后查看相关数据： > SELECT * FROM db1.userInfo; +----+-------+-----+ | id | name | age | +----+-------+-----+ | 1 | Jack | 18 | | 2 | Mary | 18 | | 3 | Tom | 18 | | 4 | Anni | 21 | | 5 | Booby | 19 | +----+-------+-----+ 第四步，本地库的数据恢复成功，我们将本地库的所有数据进行导出，上传到远程服务器进行恢复。 -- 注意！rm -rf在生产库是禁止操作！ $ rm -rf /tmp/bin.sql $ rm -rf /tmp/full.sql $ mysqldump -uroot -p -A -R -E --triggers --master-data=2 --single-transaction --max-allowed-packet=512M > /tmp/full.sql 第五步，将本地库的全备份文件上传到线上库： $ scp /tmp/full.sql root@192.168.0.120:/tmp/full.sql 第六步，线上库导入本地库上传的全备文件，进行数据恢复： $ mysql -uroot -p > SET SQL_LOG_BIN = 0; > SOURCE /tmp/full.sql > SET SQL_LOG_BIN = 1; > SELECT * FROM db1.userInfo; +----+-------+-----+ | id | name | age | +----+-------+-----+ | 1 | Jack | 18 | | 2 | Mary | 18 | | 3 | Tom | 18 | | 4 | Anni | 21 | | 5 | Booby | 19 | +----+-------+-----+ 由于GTID号的幂等性约束，所以已存在的数据不会进行重复导入，至此数据恢复成功！ 单表恢复 如果误删除的只有一张表，且大小只有10M，而整个全备文件有500G，该如何进行恢复？ 我们知道mysqldump的备份文件是SQL语句，所以只需要查找出被误删除的表与相关记录，并且导入成单独的SQL文件即可。 -- 1.获得表结构 $ sed -e'/./{H;$!d;}' -e 'x;/CREATE TABLE `表名`/!d;q' /tmp/full.sql > /tmp/table.sql -- 2.获得INSERT INTO 语句，用于数据的恢复 $ grep -i 'INSERT INTO `表名`' /tmp/full.sql >> /tmp/table.sql & -- 3.登录数据库，进入库中，导入createbale > USE 库名; > SOURCE /tmp/table.sql; Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:48 "},"数据库专栏/MySQL/xtrabackup.html":{"url":"数据库专栏/MySQL/xtrabackup.html","title":"xtrabackup","keywords":"","body":"功能概述 xtrabackup简称XBK，是一款第三方的物理备份与恢复工具。 相比于mysqldump来说，xtrabackup的备份与管理更加的简单，并且支持真正意义上的热备份以及增量备份，它的备份方式类似于直接对物理文件进行拷贝操作，运维人员不需要管理逻辑结构，所以备份与恢复的性能较高。 xtrabackup并不是完美无缺的，首先它需要第三方的下载与安装，其次是它不能够对备份文件进行压缩操作，所以会占用更多的磁盘空间，此外xtrabackup由于是物理备份，故备份文件的可读性也比较差。 软件安装 下面我们在Centos服务器上安装该软件： -- 1.下载依赖包并安装 $ yum -y install perl perl-devel libaio libaio-devel perl-Time-HiRes perl-DBD-MySQL libev -- 2.下载软件并安装，这里选择7版本即可 $ wget https://www.percona.com/downloads/XtraBackup/Percona-XtraBackup-2.4.12/binary/redhat/7/x86_64/percona-xtrabackup-24-2.4.12-1.el7.x86_64.rpm $ yum install -y ./percona-xtrabackup-24-2.4.12-1.el7.x86_64.rpm xtrabackup有2个版本，分别是innobackupex与xtrabackup，innobackup更加强大，在执行上述命令时会一并对其进行安装，所以我们接下来只需要使用以下命令查看innobackupex是否安装成功即可： $ innobackupex --help 特点解析 备份特点 xtrabackup的备份是基于物理结构的备份，他会先去备份出ibdata文件、tablename.frm文件、tablename.ibd文件以及undo_log日志文件。 由于MySQL5.7中的redo_log信息存放在共享表空间ibdata文件里，所以在MySQL5.7环境下使用xtrabackup备份时并不会像MySQL8.0中一样还要去备份redo_log文件。 在备份过程中，有以下几点注意事项： 对于非InnoDB的表来说，会进行短暂锁表的操作，在锁表期间拷贝上述物理文件 对于InnoDB的表来说，会立即触发CKPT，将内存数据页刷写至磁盘中，并且会记录一个LSN号，然后在拷贝上述物理文件 对于InnoDB的表来说，在备份期间产生的新数据也会一并进行保存，实际上就是对redo_log文件实时的进行刷新，并记录redo_log文件中最新的LSN号码，这也就是常说的热备份 恢复特点 xtrabackup在恢复数据时，会模拟CSR的两次滚动过程（先前滚、再回滚）以便追平LSN号，具体CSR滚动过程的详情请参见之前关于CSR的文章。 全备与恢复 备份相关 全备的基础命令格式如下： $ innobackupex --user=root --password=密码 --no-timestamp --socket=/tmp/mysql.sock /tmp/full -- --no-timestamp：该选项可以表示不要创建一个时间戳目录来存储备份，指定到自己想要的备份文件夹 全备完成后，将产生以下一些重要文件： xtrabackup_binlog_info xtrabackup_checkpoints xtrabackup_info xtrabackup_logfile 其中有2个文件尤为重要： 1. xtrabackup_binlog_info -- 使用cat命令查看该文件后，会得到一些信息，如下所示： mysql_bin.000001 1806 4e4c5a8d-4e05-11ec-a21b-000c290fdc76:1-6 -- 它的意思是目前所备份截止的数据是在mysql_bin.000001中的1806事件处，也是GTID6的事件处 -- 在数据恢复时，我们恢复了这个全备文件，还有一些全备周期后的数据需要从binlog中进行截取恢复，那么就打开binlog文件mysql_bin.000001，截取GTID6事件及其后面的事件进行恢复即可。 2. xtrabackup_checkpoints -- 使用cat命令查看该文件后，会得到一些信息，如下所示： backup_type = full-backuped -- 代表这是全量备份 from_lsn = 0 -- 上次所到达的LSN号(对于全备就是从0开始，对于增量有别的显示方法) to_lsn = 4409199 -- 备份开始时间(CKPT)点数据页的LSN last_lsn = 4409208 -- 备份结束后，redo日志最终的LSN compact = 0 recover_binlog_info = 0 -- 注意！在MySQL5.7的版本中，进行全量备份时 last_lsn减9 = to_lsn 时是正确的，这是因为MySQL5.7中InnoDB存储引擎内部会占用9个LSN号 -- 所以每次全备完成之后，应当检查这两个号码是否一致 -- 而对于增量备份来说，应当检查增量备份文件中的from_lsn与全备文件中的to_lsn的号码是否一致 --（1）备份时刻，立即将已经commit过的，内存中的数据页刷新到磁盘(CKPT)并开始备份数据，数据文件的LSN会停留在to_lsn位置。 --（2）备份时刻有可能会有其他的数据写入，已备走的数据文件就不会再发生变化了。 --（3）在备份过程中，备份软件会一直监控着redo与undo，如果一旦有变化会将日志也一并备走，并记录LSN到last_lsn。 -- 从to_lsn到last_lsn就是指备份过程中产生的数据变化，在MySQL5.6版本中这两个号码如果一致则代表进行备份过程时没有任何新的数据变化 -- 而在MySQL5.7版本中last_lsn-9应该等于to_lsn，这也代表进行备份过程时没有任何新的数据变化 恢复相关 在恢复全备之前，要先对文件进行整理，进行CSR日志滚动，追平LSN号： $ innobackupex --apply-log /tmp/full -- --apply-log参数：一般情况下，在备份完成后，数据尚且不能用于恢复操作，因为备份的数据中可能会包含尚未提交的事务或已经提交但尚未同步至数据文件中的事务，因此，此时数据文件仍处于不一致状态。 -- 而--apply-log的作用是通过回滚未提交的事务及同步已经提交的事务至数据文件使数据文件与事务处于一致性状态 -- 也就是说该参数会进行CSR两次滚动机制，用于追平LSN号 然后直接将文件进行拷贝即可，别忘了修改权限： $ \\cp -rf /tmp/full/* /db/mysql57/3306/data/ $ chown -R mysql:mysql /db/mysql57/3306/data/ 故障演练 首先我们线上库中有一些数据： > SELECT * FROM db1.userInfo; +----+-------+-----+ | id | name | age | +----+-------+-----+ | 1 | Jack | 18 | | 2 | Mary | 18 | | 3 | Tom | 18 | | 4 | Anni | 21 | | 5 | Booby | 19 | +----+-------+-----+ 所以直接对其进行全备即可： $ innobackupex --user=root --password=123 --no-timestamp --socket=/tmp/mysql.sock /tmp/full 备份完成后，检查xtrabackup_binlog_info文件，获取当前全备截止的GTID号： $ cat /tmp/full/xtrabackup_binlog_info mysql_bin.000001 1806 4e4c5a8d-4e05-11ec-a21b-000c290fdc76:1-6 然后继续模拟新的数据： $ mysql -uroot -p > USE db1; > BEGIN; > INSERT INTO userInfo(name, age) VALUES (\"Jason\", 21),(\"Jarry\", 19); > COMMIT; 模拟误操作，由于权限管理不当，公司的实习生删除了整个MySQL的数据目录： $ rm -rf /db/mysql57/3306/data/ 故障发生后，我们要了解故障是怎么发生的，有没有逻辑误操作什么的，这里没有逻辑误操作，只有物理层面的误操作，所以恢复起来会很方便，不用分析binlog日志，直接找到最后一个GTID号即可，但是目前不知道用的是那个binlog，所以就直接查看最后的一个binlog： $ mysqlbinlog --no-defaults --base64-output=decode-rows -v /db/mysql57/3306/logs/mysql_bin.000001 | grep SET SET @@SESSION.GTID_NEXT= '4e4c5a8d-4e05-11ec-a21b-000c290fdc76:7'/*!*/; 下面是恢复思路，首先xtrabackup备份到了GTID6的位置，而binlog记录到了GTID7的位置，所以我们要使用全备文件恢复到GTID6的位置，再截取binlog恢复到GTID7的位置。 截取binlog日志，只要GTID7的记录： $ mysqlbinlog --no-defaults --skip-gtids --include-gtids='4e4c5a8d-4e05-11ec-a21b-000c290fdc76:7' /db/mysql57/3306/logs/mysql_bin.000001 > /tmp/bin.sql 还是按照管理，先到测试库中进行恢复演练，确保测试库是干净的，且配置文件和线上库是一致的： -- 测试库下载生产库上的全备文件以及二进制截取文件 $ scp -r root@192.168.0.120:/tmp/full /tmp $ scp -r root@192.168.0.120:/tmp/bin.sql /tmp 然后测试库先恢复xtrabackup的全备文件： $ innobackupex --apply-log /tmp/full $ \\cp -rf /tmp/full/* /db/mysql57/3306/data/ $ chown -R mysql:mysql /db/mysql57/3306/data/ 再恢复截取的二进制日志文件： $ systemctl restart mysqld.service $ mysql -uroot -p > SET SQL_LOG_BIN = 0; > SOURCE /tmp/bin.sql; > SET SQL_LOG_BIN = 1; 查看测试库数据是否恢复成功： > SELECT * FROM db1.userInfo; +----+-------+-----+ | id | name | age | +----+-------+-----+ | 1 | Jack | 18 | | 2 | Mary | 18 | | 3 | Tom | 18 | | 4 | Anni | 21 | | 5 | Booby | 19 | | 6 | Jason | 21 | | 7 | Jarry | 19 | +----+-------+-----+ 至此数据恢复成功，将测试库的数据使用xtrabackup进行全备后发送到线上库进行恢复： -- 测试库 $ rm -rf /tmp/full $ innobackupex --user=root --password=123 --no-timestamp --socket=/tmp/mysql.sock /tmp/full -- 线上库 $ mv /tmp/full /tmp/old_full $ scp -r root@192.168.0.130:/tmp/full /tmp $ innobackupex --apply-log /tmp/full $ mkdir /db/mysql57/3306/data $ \\cp -rf /tmp/full/* /db/mysql57/3306/data/ $ chown -R mysql:mysql /db/mysql57/3306/data/ $ systemctl restart mysqld.service $ mysql -uroot -p $ SELECT * FROM db1.userInfo; +----+-------+-----+ | id | name | age | +----+-------+-----+ | 1 | Jack | 18 | | 2 | Mary | 18 | | 3 | Tom | 18 | | 4 | Anni | 21 | | 5 | Booby | 19 | | 6 | Jason | 21 | | 7 | Jarry | 19 | +----+-------+-----+ 增量与恢复 备份相关 增量备份必须依赖于全量备份。 每个增量备份在备份后都会生成一个新的文件夹，并且具有全备中所有的相关文件。 增量备份命令如下： $ innobackupex --user=root --password=密码 --no-timestamp --incremental --incremental-basedir=/tmp/full --socket=/tmp/mysql.sock /tmp/incr1 -- --incremental ：添加该参数以表明此次是增量备份 -- --incremental-basedir：此次增量备份所依赖的备份文件 在备份完成后，我们需要检查本次增量备份后的from_lsn是否等于被基于备份文件的to_lsn： $ cat /tmp/full/xtrabackup_checkpoints backup_type = full-prepared from_lsn = 0 to_lsn = 4412147 -- 这里 last_lsn = 4412156 compact = 0 recover_binlog_info = 0 $ cat /tmp/incr1/xtrabackup_checkpoints backup_type = incremental -- 代表这是一个增量备份 from_lsn = 4412147 -- 这里 to_lsn = 4412738 last_lsn = 4412747 compact = 0 recover_binlog_info = 0 上面已经增量备份了incr1，还需要增量备份incr2，就需要将incr2的增量备份基于incr1来做： $ innobackupex --user=root --password=123 --no-timestamp --incremental --incremental-basedir=/tmp/incr1 --socket=/tmp/mysql.sock /tmp/incr2 恢复相关 进行增量备份恢复时，全备文件必须先进行整理，并且必须添加参数--redo-only： $ innobackupex --apply-log --redo-only /tmp/full -- --redo-only代表在进行整理文件模拟CSR过程的过程中，只加载redo_log文件中的信息 其次，需要将增量备份的文件合并到全量备份文件中并进行整理，先来整理incr1，只要不是最后一个合并的增量备份文件，就需要加参数--redo-only： $ innobackupex --apply-log --redo-only --incremental-dir=/tmp/inc1/ tmp/full 接着我们需要对incr2也进行合并，值得注意的是由于本次是最后一个增量备份的合并操作，所以不必加参数--redo-only： $ innobackupex --apply-log --incremental-dir=/tmp/incr2/ tmp/full 然后要对合并后的全量备份文件再次进行整理，此时不添加参数--redo-only： $ innobackupex --apply-log /tmp/full 故障演练 每周日进行全量备份，其他都进行增量备份。 异常是在周三上午发生的，全盘死机了，服务完全崩溃。 现在需要恢复周日全备+周一增量+周二增量，以及根据周二增量记录的备份位置截取到增量备份完成后至周三异常发生前的二进制日志记录。 模拟开始，清除全部数据： > DROP DATABASE db1; > RESET MASTER; -- 主从环境禁用该操作，从库必崩 > EXIT; $ rm -rf /tmp/{bin.sql,full,old_full,incr1,incr2} 模拟将要被全备份的记录信息： CREATE DATABASE full CHARSET utf8mb4; USE full; BEGIN; CREATE TABLE full_table(id INT); INSERT INTO full_table VALUES(1),(2),(3); COMMIT; 进行周日的全备份： $ innobackupex --user=root --password=123 --no-timestamp --socket=/tmp/mysql.sock /tmp/full 检测/tmp/full/xtrabackup_checkpoints文件中last_lsn减9是否等于to_lsn： $ cat /tmp/full/xtrabackup_checkpoints backup_type = full-backuped from_lsn = 0 to_lsn = 4429630 last_lsn = 4429639 compact = 0 recover_binlog_info = 0 模拟周一新增的数据变化： CREATE DATABASE incr1 CHARSET utf8mb4; USE incr1; BEGIN; CREATE TABLE incr1_table(id INT); INSERT INTO incr1_table VALUES(1),(2),(3); COMMIT; 进行周一的增量备份： $ innobackupex --user=root --password=123 --no-timestamp --incremental --incremental-basedir=/tmp/full --socket=/tmp/mysql.sock /tmp/incr1 检测/tmp/incr1/xtrabackup_checkpoints文件中from_lsn是否等于/tmp/full/xtrabackup_checkpoints文件中last_lsn的to_lsn： $ cat /tmp/full/xtrabackup_checkpoints backup_type = full-backuped from_lsn = 0 to_lsn = 4429630 -- 这里 last_lsn = 4429639 compact = 0 recover_binlog_info = 0 $ cat /tmp/incr1/xtrabackup_checkpoints backup_type = incremental from_lsn = 4429630 -- 这里 to_lsn = 4435783 last_lsn = 4435792 compact = 0 recover_binlog_info = 0 模拟周二的数据变化： CREATE DATABASE incr2 CHARSET utf8mb4; USE incr2; BEGIN; CREATE TABLE incr2_table(id INT); INSERT INTO incr2_table VALUES(1),(2),(3); COMMIT; 进行周二的增量备份： $ innobackupex --user=root --password=123 --no-timestamp --incremental --incremental-basedir=/tmp/incr1 --socket=/tmp/mysql.sock /tmp/incr2 检测/tmp/incr2/xtrabackup_checkpoints文件中from_lsn是否等于/tmp/incr1/xtrabackup_checkpoints文件中last_lsn的to_lsn： $ cat /tmp/incr1/xtrabackup_checkpoints backup_type = incremental from_lsn = 4429630 to_lsn = 4435783 -- 这里 last_lsn = 4435792 compact = 0 recover_binlog_info = 0 $ cat /tmp/incr2/xtrabackup_checkpoints backup_type = incremental from_lsn = 4435783 -- 这里 to_lsn = 4441836 last_lsn = 4441845 compact = 0 recover_binlog_info = 0 模拟周三的数据变化： CREATE DATABASE incr3 CHARSET utf8mb4; USE incr3; BEGIN; CREATE TABLE incr3_table(id INT); INSERT INTO incr3_table VALUES(1),(2),(3); COMMIT; 模拟异常发生： $ rm -rf /db/mysql57/3306/data/ 现在我们准备开始恢复，先将所有的增量合并到全备中： -- 1.第一次整理全备文件，并且后面要合并，就加参数 --redo-only $ innobackupex --apply-log --redo-only /tmp/full -- 2.不是最后一次合并增量文件，就加参数 --redo-only $ innobackupex --apply-log --redo-only --incremental-dir=/tmp/incr1 /tmp/full -- 3.是最后一次合并增量文件，不加参数 --redo-only $ innobackupex --apply-log --incremental-dir=/tmp/incr2 /tmp/full -- 4.最后一次整理全备文件，并且后面不需要合并，不加参数 --redo-only $ innobackupex --apply-log /tmp/full 然后记录最后一次的二进制日志记录，这里是记录到GTID9的位置： $ cat /tmp/incr2/xtrabackup_binlog_info mysql_bin.000001 2020 7dd9670a-4e70-11ec-8147-000c290fdc76:1-9 查看当前二进制日志文件已经记录到的位置，由于还是物理错误，不是逻辑错误，所以不用分析binlog文件： $ mysqlbinlog --no-defaults --base64-output=decode-rows -v /db/mysql57/3306/logs/mysql_bin.000001 | grep SET SET @@SESSION.GTID_NEXT= '7dd9670a-4e70-11ec-8147-000c290fdc76:12'/*!*/; 截取binlog，拿到GTID10-12这3条记录： $ mysqlbinlog --no-defaults --skip-gtids --include-gtids='7dd9670a-4e70-11ec-8147-000c290fdc76:10-12' /db/mysql57/3306/logs/mysql_bin.000001 > /tmp/bin.sql 还是按照管理，先到测试库中进行恢复演练，确保测试库是干净的，且配置文件和线上库是一致的： -- 测试库下载生产库上经过合并整理的全备文件以及二进制截取文件 $ scp -r root@192.168.0.120:/tmp/full /tmp $ scp -r root@192.168.0.120:/tmp/bin.sql /tmp 然后测试库先恢复xtrabackup的全备文件，上面已经经过了整理了，所以这里不再需要进行整理： $ \\cp -rf /tmp/full/* /db/mysql57/3306/data/ $ chown -R mysql:mysql /db/mysql57/3306/data/ 再恢复截取的二进制日志文件： $ systemctl restart mysqld.service $ mysql -uroot -p > SET SQL_LOG_BIN = 0; > SOURCE /tmp/bin.sql; > SET SQL_LOG_BIN = 1; 查看测试库数据是否恢复成功： > SELECT * FROM full.full_table; > SELECT * FROM incr1.incr1_table; > SELECT * FROM incr2.incr2_table; > SELECT * FROM incr3.incr3_table; 至此数据恢复成功，将测试库的数据使用xtrabackup进行全备后发送到线上库进行恢复： -- 测试库 $ rm -rf /tmp/full $ innobackupex --user=root --password=123 --no-timestamp --socket=/tmp/mysql.sock /tmp/full -- 线上库 $ mv /tmp/full /tmp/old_full $ scp -r root@192.168.0.130:/tmp/full /tmp $ innobackupex --apply-log /tmp/full $ mkdir /db/mysql57/3306/data $ \\cp -rf /tmp/full/* /db/mysql57/3306/data/ $ chown -R mysql:mysql /db/mysql57/3306/data/ $ systemctl restart mysqld.service $ mysql -uroot -p > SELECT * FROM full.full_table; > SELECT * FROM incr1.incr1_table; > SELECT * FROM incr2.incr2_table; > SELECT * FROM incr3.incr3_table; 单表恢复 如果误删除的只有一张表，且大小只有10M，而整个全备文件有500G，该如何进行恢复？ 这得配合之前InnoDB存储结构中提到的一种ibd文件拷贝的物理恢复策略，搭配进行使用： 必须拿到创建表的SQL语句，然后再进行恢复。 -- 1.拿到误删除表的建表语句并进行创建 略 -- 2.执行以下命令，删除自带的空的这个表名.ibd文件 > ALTER TABLE 表名 DICARD TABLESPACE; -- 3.将全备文件中的表ibd文件进行拷贝 > cp /tmp/full/库名/表名.ibd /db/mysql57/3306/data/库名/ -- 4.进行权限的修改 > chown -R mysql:mysql /db/mysql57/3306/data/库名/表名.ibd -- 5.导入拷贝过来的ibd文件 > ALTER TABLE t1 IMPORT TABLESPACE; Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:48 "},"数据库专栏/MySQL/主从复制.html":{"url":"数据库专栏/MySQL/主从复制.html","title":"主从复制","keywords":"","body":"主从介绍 主从复制是高可用架构的基础技术，在介绍主从复制之前我们需要了解一些全年无故障率的高可用标准： 99.9%可用时：一年内大概有525.6分钟处于停机状态，该级别属于比较优秀的企业全年无故障率 99.99%可用时：一年内大概有52.56分钟处于停机状态，该级别属于相当优秀的企业全年无故障率 99.999%可用时：一年内大概有5.256分钟处于停机状态，该级别属于金融类企业的全年无故障率 如何减少故障停机时间？这里有一个基础的方案就是采用2个MySQL服务，他们中数据相同，有一个发生故障后立马切换至另一个服务，进行服务保障，但是同一时刻只有一个MySQL在对外进行服务。 像这种同一时间只有一个MySQL实例处于服务状态的架构被称之为单活架构，在主库发生故障时切换至从库这样的操作是会花费一些时间的。 既然有单活架构，那么也有多活架构，如下就是一些比较常见的多活架构： NDB Cluster Oracle RAC Sysbase cluster InnoDB Cluster（MGR） PXC MGC 多活架构草图概述： 通过上面两张图发现，我们始终要保障多个MySQL服务之间的数据同步，因此主从的数据一致性是其关键技术点。 主从简介 以下是一些关于主从的简介： 主从复制其实是根据二进制日志进行复制的 主库的修改操作会记录二进制日志 从库会请求新的二进制日志，并将其进行回放操作（恢复），最终达到主从数据同步 主从复制的核心功能在于从库能够对主库进行辅助备份，处理主库的物理损坏、逻辑损坏，做到及时止损 主从复制是扩展新型高可用、高性能、分布式架构的前提 如何进行主从搭建？这里有一些搭建主从复制的前提条件： 两台或以上的MySQL实例，且server_id，server_uuid均不同 主库必须开启二进制日志，从库也推荐开启二进制日志，方便主库故障时进行主从身份转换 主库创建专用的用户，将来会由从库指定该用户为自己进行复制二进制日志记录的操作 从库必须保证和主库的数据是一致的 人为告诉从库一些必要信息，如主库的ip+port、负责复制主库记录给从库的专属用户、负责复制主库记录用户的用户密码、以及该用户从主库那个日志文件的那个事件号后开始复制 从库应该开启专门的复制线程IO_T和SQL_T 地址规划 以下是地址规划，我们准备3台干净的服务器，其实主从关系最少2台就可以进行搭建，但是为了后期MHA等架构的搭建所以这里选择3台服务器： 作用 IP地址 服务端口 操作系统 MySQL版本 配置 Master 192.168.0.120 3306 Centos7.3 基础设施服务器 5.7.34 2核CPU 2G内存 20G硬盘 SLAVE 192.168.0.130 3306 Centos7.3 基础设施服务器 5.7.34 2核CPU 2G内存 20G硬盘 SLAVE 192.168.0.140 3306 Centos7.3 基础设施服务器 5.7.34 2核CPU 2G内存 20G硬盘 有关于event主从的搭建这里不再进行例举，因为目前企业中很少有在用event主从的了。 总体来说GTID主从对比event主从有以下优势： 好搭建：得益于GTID幂等性约束，我们不必关心主库目前已存在的binlog记录是否会和从库目前以存在的数据产生冲突 速度快：由于GTID幂等性约束，所以主从复制的数据是并行传输的，不用担心数据会发生错误 易管理：用GTID来管理binlog日志或者relay日志都比event来管理更加方便，在出现主从异常时数据的恢复会更简单 综上所述，我们决定所有节点均采用MySQL5.7.34版本并搭建GTID主从复制。 主从搭建 基础配置 3份配置保持一致，如下所示： mysqld] user=mysql # 保证server_id不同 Master是120、Slave1是130、Slave2是140 server_id=120 port=3306 basedir=/db/mysql57/3306/mysql datadir=/db/mysql57/3306/data character-set-server=utf8mb4 collation-server=utf8mb4_general_ci default-storage-engine=INNODB socket=/tmp/mysql.sock innodb_data_file_path=ibdata1:512M;ibdata2:512M:autoextend innodb_autoextend_increment=64 autocommit=1 innodb_flush_log_at_trx_commit=1 innodb_flush_method=O_DIRECT transaction-isolation=Read-Committed log_error=/db/mysql57/3306/logs/mysqld.log slow_query_log_file=/db/mysql57/3306/logs/slow.log slow_query_log=1 long_query_time=0.1 log_queries_not_using_indexes # 保证以下5个项目 log_bin=/db/mysql57/3306/logs/mysql_bin binlog_format=row gtid-mode=on enforce-gtid-consistency=true # 释义：slave更新是否记入binlog日志，方便数据恢复后从库进行全备，切换主从身份，这里打开即可 log-slave-updates=1 [mysql] port=3306 default-character-set=utf8mb4 socket=/tmp/mysql.sock prompt=\"MASTER> \" [client] port=3306 default-character-set=utf8mb4 模拟数据 在GTID主从环境未开始搭建之前，先给主库MASTER录入一些数据： CREATE DATABASE db1 CHARSET utf8mb4; USE db1; CREATE TABLE userInfo( id INT PRIMARY KEY AUTO_INCREMENT COMMENT \"主键\", name CHAR(64) NOT NULL COMMENT \"姓名\", INDEX idx_name(name) COMMENT \"普通索引\" ) ENGINE innodb CHARSET utf8mb4 COLLATE utf8mb4_general_ci; INSERT INTO userInfo(name) VALUES (\"Jack\"), (\"Tom\"), (\"Mary\"); 备份恢复 然后我们需要对主库已有的信息进行一次全备份，由于我们是GTID主从，且使用了mysqldump进行全备，得益于GTID幂等性约束所以并不需要关注全备文件中关于SET @@GLOBAL.GTID_PURGED值的设定。 $ mysqldump -uroot -p -A -R -E --triggers --master-data=2 --single-transaction --max-allowed-packet=512M > /tmp/full.sql 将主库的备份文件下发到所有的从库上： $ scp -r /tmp/full.sql root@192.168.0.130:/tmp/ $ scp -r /tmp/full.sql root@192.168.0.140:/tmp/ 登录2个从库，对full.sql进行恢复，确保主库和从库的当前数据是一致的： > SOURCE /tmp/full.sql > select * from db1.userInfo; 主库操作 接下来就要正式准备主从搭建了，我们需要在主库上创建一个用于复制binlog的用户： $ mysql -uroot -p -S /tmp/mysql.sock -e \"grant replication slave on *.* to repl@'%' identified by '123'\"; -- 注意，如果是线上环境，请设置repl用户的允许登录地址 -- repl用户的权限是仅用于复制操作 注意从库这里并不需要创建该用户，因为主从一旦搭建成功从库就会复制主库的所有信息，那么该用户也会一同在从库上自动进行建立。 为什么从库也要有该用户呢？其实说白了还是主库发生故障后利于主从身份转换罢了。 从库操作 从库现在需要与主库进行链接，当主库发生任何操作后从库也一并执行操作，究其根本就是从库监听主库二进制日志的变化，当主库的二进制日志发生变化时从库也做出相应的变化： > CHANGE MASTER TO MASTER_HOST='192.168.0.120', MASTER_USER='repl', MASTER_PASSWORD='123', MASTER_PORT=3306, MASTER_CONNECT_RETRY=10, MASTER_AUTO_POSITION=1; -- MASTER_HOST：主库的地址 -- MASTER_PORT：主库端口号 -- MASTER_USER：主库中用于复制的用户 -- MASTER_PASSWORD：主库中用于复制的用户密码 -- MASTER_CONNECT_RETRY：主库链接失败后从库重试链接的次数 -- MASTER_AUTO_POSITION：是否自动寻找MASTER中的GTID号位置，详情参见外面的描述 关于MASTER_AUTO_POSITION选项的详细说明： 首先我们是使用的mysqldump对主库进行全备，并在从库上进行了恢复。 那么全备的sql文件中就会存在已截取的GTID事务号。 MASTER_AUTO_POSITION=1实际上是让从库从主库GTID事务号1后开始截取，如果是mysqldump进行逻辑备份恢复则会自动将该参数调整为全备SQL文件中的GTID事务号+1。 那么如果是XBK物理备份怎么填写该参数呢？你需要xtrabackup_binlog_info文件中，读取出已截取的GTID事务号，填写时+1即可（只截取最后的那个数字！不是整个uuid+int的字符串）。 总结！mysqldump逻辑备份恢复，该参数填1，内部会自动进行校正。 XBK物理备份恢复，检查xtrabackup_binlog_info文件，该参数在GTID事务号基础上+1 下面直接开始复制，在2个从库上执行： > START SLAVE; -- 该命令会直接复制MASTER的binlog日志到从库 在从库上执行以下命令，检查主从复制的状态： > SHOW SLAVE STATUS\\G; -- 检查下面2项： -- Slave_IO_Running: Yes -- Slave_SQL_Running: Yes 主从验证 下面我们来对主从架构进行验证，登录主库向userInfo表中插入数据，查看从库是否会自动完成同步： $ mysql -uroot -p > USE db1; > INSERT INTO userInfo(name) VALUES (\"Anna\"), (\"Jason\"); 登录从库，执行以下命令： $ mysql -uroot -p > SELECT * FROM db1.userInfo; +----+-------+ | id | name | +----+-------+ | 4 | Anna | | 1 | Jack | | 5 | Jason | | 3 | Mary | | 2 | Tom | +----+-------+ 至此，GTID主从已经完全搭建完毕了。 主从原理 相关资源 在主从复制中，主库会用到的文件和资源如下： binlog：二进制日志文件 BINLOG_DUMP_THREAD: DUMP_T线程，负责与从库进行链接，通知从库IO_T线程主库的binlog更新情况，让从库进行复制 在主从复制中，从库会用到的文件和资源如下： master.info：保存主库信息的文件 reay-log.info：保存中继日志信息文件 relaylog：中继日志文件，保存主库中binlog二进制日志文件的记录，用于回放操作 -- 以上3个文件均保存在数据目录下 SLAVE_IO_THREAD：IO_T线程，用于复制主库的binlog二进制日志文件记录 SLAVE_SQL_THREAD：SQL_T线程，用于读取从库的relay-log中继日志信息文件并回放从库的relaylog中继日志文件记录 内部原理 以下是主从复制的内部原理： 从库执行CHANGE MASTER TO命令时，会将主库链接信息存入到master.info文件中，如主库的地址、端口号、复制用户、重试次数等信息 从库执行START SLAVE命令时，会立即开启IO_T、SQL_T这2个线程 从库IO_T线程会先从master.info文件中读取主库链接信息，然后尝试与主库的DUMP_T线程进行链接 主库DUMP_T线程根据从库IO_T线程请求过来的信息，截取binlog记录并将binlog记录通过DUMP_T线程返回给从库的IO_T线程 从库IO_T线程此时会将获取到的binlog记录存储至TCP/IP缓存中，并且返回ACK信息给主库的DUMP_T线程，这是一个正常的TCP处理流程，此外IO_T线程还会更新master.info文件中部分信息，比如当前截取的二进制日志文件名以及已截取的binlog日志GTID事务号 从库IO_T线程会将TCP/IP缓存中存储的主库binlog记录，转存至relaylog.00000x中继日志文件中 从库SQL_T线程会根据relay-log.info中继日志信息文件，读取到上次已经回放（恢复）过的relaylog.00000x中继日志文件中的位置信息 从库SQL_T线程根据relay-log.info中继日志信息文件中读取到的位置信息，开始继续向后读取relaylog.00000x中继志文件中记载的主库binlog记录，并进行回放（恢复）操作 此外，从库会自动根据日期对relaylog.00000x中继志文件进行清理，当主库中binlog日志有任何变化时，主库都会通过DUMP_T线程通知从库的IO_T线程，让从库主动更新数据。 整体流程如下图所示： 主从监控 监控命令 在主从环境中，我们要经常登录从库，检查主从是否稳定。 命令如下： > SHOW SLAVE STATUS\\G; 监控信息 以下是从库的状态信息： Slave_IO_Running: Yes Slave_SQL_Running: Yes Last_IO_Errno: 0 Last_IO_Error: Last_SQL_Errno: 0 Last_SQL_Error: -- Slave_IO_Running: 从库与主库的链接状态，IO_T线程的运行状态 -- Slave_SQL_Running: 从库与主库的链接状态，SQL_T线程的运行状态 -- ...ERROR: 最近的一次报错 以下是主库相关的信息： Master_Host: 192.168.0.120 Master_User: repl Master_Port: 3306 Connect_Retry: 10 Master_Log_File: mysql_bin.000008 Read_Master_Log_Pos: 1541 -- Master_Host: 主库地址 -- Master_User: 库负责向从库复制binlog记录的用户 -- Master_Port: 主库端口号 -- Connect_Retry: 主库宕机后从库尝试链接的重试次数 -- Master_Log_File: 主库当前正在使用的binlog文件 -- Read_Master_Log_Pos: 从库已读取主库的binlog记录位置，与主库SHOW MASTER STATUS做对比，如果一致说明主从性能很好 -- 这些信息都存在在从库的master.info文件中，而master.info文件存储在从库的数据目录中：/db/mysql57/3306/data/master.info 以下是GTID主从复制有关的状态信息： Retrieved_Gtid_Set: e288aa3d-4f67-11ec-b2b2-000c296ef14b:4-5 Executed_Gtid_Set: e288aa3d-4f67-11ec-b2b2-000c296ef14b:1-5 Auto_Position: 1 -- Retrieved_Gtid_Set: 以获取到的主库binlog中GTID事务号，这里只从4获取的，因为4前面的都是从全备文件中恢复出来的 -- Executed_Gtid_Set: 当前从库已回放的binlog中GTID事务号，这里已经恢复了GTID1到GTID5的所有数据 -- Auto_Position: 是否开启自动位置确认，1代表开启，0代表取消 以下是从库与relay_log相关的信息： Relay_Log_File: slave2-relay-bin.000002 Relay_Log_Pos: 975 Relay_Master_Log_File: mysql_bin.000008 Exec_Master_Log_Pos: 1541 -- Relay_Log_File: 从库正在使用的中继志文件名 -- Relay_Log_Pos: 从库当前读取中继日志的信息 -- Relay_Master_Log_File: 从库以回放到主库的binlog文件 -- Exec_Master_Log_Pos: 从库以回放到主库的那一条binlog，最好与Read_Master_Log_Pos保持一致 -- 这些信息都存在在从库的relay-log.info中继日志信息文件中，relay-log.info文件存储在从库的数据目录中：/db/mysql57/3306/data/relay-log.info 以下是过滤的主库binlog相关信息： Replicate_Do_DB: Replicate_Ignore_DB: Replicate_Do_Table: Replicate_Ignore_Table: Replicate_Wild_Do_Table: Replicate_Wild_Ignore_Table: -- Replicate_Do_DB: 过滤库白名单，当前从库的SQL_T线程仅回放该名单库的binlog记录 -- Replicate_Ignore_DB: 过滤库黑名单，当前从库的SQL_T线程不回放该名单库的binlog记录 -- Replicate_Do_Table: 过滤表白名单 -- Replicate_Ignore_Table: 过滤表黑名单 -- Replicate_Wild_Do_Table: 模糊的表名白名单，如以t开头.. -- Replicate_Wild_Ignore_Table: 模糊的表名黑名单，如以t开头.. 以下是主从的非人为延时状态，如果该值过大则说明性能有一定的问题： Seconds_Behind_Master: 0 -- 大概估算主从复制时的同步时间差 以下是主从的人为延迟状态信息： SQL_Delay: 0 SQL_Remaining_Delay: NULL -- SQL_Delay：人为设定的延迟从库设定秒数 -- SQL_Remaining_Delay：当前还剩多长时间回放下一个中继日志文件relaylog记录 延时从库 延时配置 延时从库是人为定制的一种策略，从库作为主库的备份方案存在。 当主库发生异常时，在延迟时间内登录从库阻止即将到来的异常操作执行。 举个例子，主库DROP DATABASE操作成功后，如果从库不做延时策略，则立马也会执行该操作，所以我们需要设定延时从库。 在从库的基础配置完成后，再填入以下配置项，一般设置3-6小时，单位为秒数： > STOP SLAVE; > CHANGE MASTER TO MASTER_DELAY = 10800; -- 3小时 > START SLAVE; > SHOW SLAVE STATUS\\G; 或者你也可以在直接搭建主从时填入以下配置： > CHANGE MASTER TO MASTER_HOST='192.168.0.120', MASTER_USER='repl', MASTER_PASSWORD='123', MASTER_PORT=3306, MASTER_CONNECT_RETRY=10, MASTER_AUTO_POSITION=1, MASTER_DELAY=10800; > START SLAVE; > SHOW SLAVE STATUS\\G; 延时检查 执行以下命令查看配置项，可进行延迟检查： > SHOW SLAVE STATUS\\G; SQL_Delay: 10800 SQL_Remaining_Delay: NULL -- SQL_Delay: 人为设定的延迟从库设定秒数 -- SQL_Remaining_Delay: 当前还剩多长时间回放下一个中继日志文件relaylog记录 恢复演练 当主库发生误操作后，从库如果开了延迟，则可以在延迟时间内登录从库进行以下操作。 我们将2个从库都设置成了3小时延时，现在在主库上模拟一次误操作： > DROP DATABASE db1; 误操作之后主库还产生了很多正常操作，我们也应当进行模拟： > CREATE DATABASE db2; > CREATE DATABASE db3; 1）误操作已经发生，所以现在立马登录2个从库，停止SQL_T线程的回放工作，因为误操作现在已经同步到了从库上，但是还没有回放执行： > STOP SLAVE sql_thread; 2）接下来需要打开监控命令，查看从库目前使用的中继日志信息： > SHOW SLAVE STATUS\\G; Relay_Log_File: slave2-relay-bin.000002 Retrieved_Gtid_Set: e288aa3d-4f67-11ec-b2b2-000c296ef14b:5-7 Executed_Gtid_Set: e288aa3d-4f67-11ec-b2b2-000c296ef14b:1-4 -- Relay_Log_File: 查看当前正在使用的中继日志 -- Retrieved_Gtid_Set: 以获取到的主库binlog中GTID事务号 -- Executed_Gtid_Set: 当前从库已回放的binlog中GTID事务号 3）然后需要使用event工具或者mysqlbinlog工具查看从库中的中继日志记录，找到误操作的事件号并进行保存，这里我们使用event工具进行查看： > SHOW RELAYLOG EVENTS IN \"slave2-relay-bin.000002\"; -- 注意！查看中继志与查看二进制日志不同 -- 中继日志只看左边的信息，event开始点和结束点都在左边的Pos中 -- 右边的End_log_pos是binlog的记录，不用管也不用看 -- 由于我们是GTID模式的主从复制，所以直接看info信息即可 -- 可以看见GTID5号处就是误操作 +-------------------------+-----+----------------+-----------+-------------+-------------------------------------------------------------------+ | Log_name | Pos | Event_type | Server_id | End_log_pos | Info | +-------------------------+-----+----------------+-----------+-------------+-------------------------------------------------------------------+ | slave2-relay-bin.000002 | 4 | Format_desc | 140 | 123 | Server ver: 5.7.34-log, Binlog ver: 4 | | slave2-relay-bin.000002 | 123 | Previous_gtids | 140 | 154 | | | slave2-relay-bin.000002 | 154 | Rotate | 120 | 0 | mysql_bin.000001;pos=4 | | slave2-relay-bin.000002 | 201 | Format_desc | 120 | 123 | Server ver: 5.7.34-log, Binlog ver: 4 | | slave2-relay-bin.000002 | 320 | Rotate | 0 | 367 | mysql_bin.000001;pos=154 | | slave2-relay-bin.000002 | 367 | Rotate | 0 | 414 | mysql_bin.000001;pos=1258 | | slave2-relay-bin.000002 | 414 | Gtid | 120 | 1323 | SET @@SESSION.GTID_NEXT= 'e288aa3d-4f67-11ec-b2b2-000c296ef14b:5' | | slave2-relay-bin.000002 | 479 | Query | 120 | 1412 | DROP DATABASE db1 | | slave2-relay-bin.000002 | 568 | Gtid | 120 | 1477 | SET @@SESSION.GTID_NEXT= 'e288aa3d-4f67-11ec-b2b2-000c296ef14b:6' | | slave2-relay-bin.000002 | 633 | Query | 120 | 1568 | CREATE DATABASE db2 | | slave2-relay-bin.000002 | 724 | Gtid | 120 | 1633 | SET @@SESSION.GTID_NEXT= 'e288aa3d-4f67-11ec-b2b2-000c296ef14b:7' | | slave2-relay-bin.000002 | 789 | Query | 120 | 1724 | CREATE DATABASE db3 | +-------------------------+-----+----------------+-----------+-------------+-------------------------------------------------------------------+ 4）使用mysqlbinlog工具对中继日志进行截取，生成SQL文件。 当前我们的从库已经回放了GTID1-4的binlog日志，并且经过分析得出GTID5是误操作，所以只截取GTID6-7即可： -- 我5-7，但是不要5 $ mysqlbinlog --no-defaults --skip-gtids --include-gtids='e288aa3d-4f67-11ec-b2b2-000c296ef14b:5-7' --exclude-gtids='e288aa3d-4f67-11ec-b2b2-000c296ef14b:5' /db/mysql57/3306/data/slave1-relay-bin.000002 > /tmp/relay.sql 5）任选一个从库进行恢复，我这里选择SLAVE1： $ mysql -uroot -p > SOURCE /tmp/relay.sql 6）停止SLAVE1和SLAVE2的复制行为，并且解除从库身份： > STOP SLAVE; > RESET SLAVE ALL; 7）全备SLAVE1的数据，并将full.sql备份文件下放到SLAVE2和已经故障的MASTER上： $ mysqldump -uroot -p -A -R -E --triggers --master-data=2 --single-transaction --max-allowed-packet=512M > /tmp/full.sql $ scp -r /tmp/full.sql root@192.168.0.120:/tmp/ $ scp -r /tmp/full.sql root@192.168.0.140:/tmp/ 8）SLAVE2和已经故障的MASTER上进行数据导入： $ mysql -uroot -p -- 2台服务器都执行 > RESET MASTER; > SOURCE /tmp/full.sql 9）现在我们3台机器上所有的数据都保持一致了，将原本的SLAVE1作为MASTER重新启动吧，在2个从库（原MASTER，SLAVE2）上重新执行以下命令即可： > CHANGE MASTER TO MASTER_HOST='192.168.0.130', MASTER_USER='repl', MASTER_PASSWORD='123', MASTER_PORT=3306, MASTER_CONNECT_RETRY=10, MASTER_AUTO_POSITION=1, MASTER_DELAY=10800; > START SLAVE; > SHOW SLAVE STATUS\\G; 此外，如果你还想将原本的MASTER作为主库启动，也可以手动清除掉SLAVE1的MASTER信息。 下面我们仅做演示操作，因为具体的故障恢复到上面一步已经结束了，下面的操作是为了恢复原本地址规划时的主从地位： -- 原MASTER和SLAVE2执行 > STOP SLAVE; > RESET SLAVE ALL; -- 所有机器都执行 > RESET MASTER; -- SLAVE1和SLAVE2执行 > CHANGE MASTER TO MASTER_HOST='192.168.0.120', MASTER_USER='repl', MASTER_PASSWORD='123', MASTER_PORT=3306, MASTER_CONNECT_RETRY=10, MASTER_AUTO_POSITION=1, MASTER_DELAY=10800; > START SLAVE; > SHOW SLAVE STATUS\\G; 过滤复制 基本概念 在一些高可用架构中，我们常常会对一些数据量级比较大的数据库单独构建从库。 如下图所示： 这样的好处就是对于主库来说的压力会大大减少。 实现方案 实现方案有2种，第一种是在主库上对binlog进行记录时只记录某个库，当然这种实现方案很少会被应用到： MASTER> SHOW MASTER STATUS; +------------------+----------+--------------+------------------+-------------------+ | File | Position | Binlog_Do_DB | Binlog_Ignore_DB | Executed_Gtid_Set | +------------------+----------+--------------+------------------+-------------------+ | mysql_bin.000002 | 154 | | | | +------------------+----------+--------------+------------------+-------------------+ -- Binlog_Do_DB：binlog日志白名单，只针对某个库进行记录 -- Binlog_Ignore_DB：binlog日志黑名单，只针对某个库不进行记录 第二种方案是在从库上进行配置，当SQL_T线程执行回放操作时，仅针对某个库的binlog记录进行回放，只需要在从库的my.cnf中配置如下选项即可： [mysqld] replicate_db_db=db01 replicate_ignore_db=db02 监控主从状态时，在从库上只需关心以下命令即可： > SHOW SLAVE STATUS\\G; -- Replicate_Do_DB: 过滤库白名单，当前从库的SQL_T线程仅回放该名单库的binlog记录 -- Replicate_Ignore_DB: 过滤库黑名单，当前从库的SQL_T线程不回放该名单库的binlog记录 -- Replicate_Do_Table: 过滤表白名单 -- Replicate_Ignore_Table: 过滤表黑名单 -- Replicate_Wild_Do_Table: 模糊的表名白名单，如以t开头.. -- Replicate_Wild_Ignore_Table: 模糊的表名黑名单，如以t开头.. 另外如果要开启从库只允许读取，则可输入以下命令，缺点是这种设置不能限制root用户，我们一般都不会进行这样的设置，而是采用其他的读写分离方案： > SET GLOBAL read_only=0; 半同步复制 基本概念 如果不启动半同步复制，那么主库并不会关心从库对relaylog日志的回放情况。 如果启动半同步复制，则主库会开启一个ACK_RECEIVER线程，当从库回放了relay_log.00000x文件后，会向主库主动发送一次ACK确认请求，告诉主库这次的binlog记录以同步，此时主库才会继续利用DUMP_T线程向从库IO_T线程发送新信息告诉从库我有新的binlog记录了你来进行复制吧。 整体流程如下图所示，这样做的好处就是确保数据的一致性，坏处是性能下降比较严重，仅做了解即可： 实现方案 要实现半同步复制的方案，按照以下流程操作。 1）主库加载插件： > INSTALL PLUGIN rpl_semi_sync_master SONAME 'semisync_master.so'; 2）从库加载插件： > INSTALL PLUGIN rpl_semi_sync_slave SONAME 'semisync_slave.so'; 3）主从库检查插件是否加载成功： > SHOW plugins; 4）主库启动半同步复制，开启ACK_RECEIVER线程： > SET GLOBAL rpl_semi_sync_master_enabled = 1; 5）从库启动半同步复制，控制SQL_T线程读取完relay_log后交由IO_T线程发送ACK请求： > SET GLOBAL rpl_semi_sync_slave_enabled = 1; 6）重启从库上的IO_T线程： > STOP SLAVE io_thread; > START SLAVE io_thread; 常见问题 链接问题 从库链接主库链接不上，可以从以下两个方面入手解决： 检查主库的用户名、密码是否设置正确，是否存在允许登录地址设置有误，比如允许从所有地址登录符号为%而你填了个* 检查主库的链接线程是否过多？在主库中输入SHOW PROCESSLIST;进行查看 检查主库是否打开了禁止域名解析的设置--skip-name-resolve，或者是否打开了禁止远程登录的设置--skip-networking 检查从库的请求链接的主库是否输入有误，如主库负责复制binlog的用户密码是否输入错误等 如果是从库的链接信息填写错误，则可以重新进行填写： -- 停止复制行为 > STOP SLAVE; -- 重置复制信息 > RESET SLAVE ALL; -- 重新设置链接信息 > CHANGE MASTER TO ...; -- 重新开始从库复制行为 > START SLAVE; 如果是主库方面的原因，比如链接线程太多导致的，那么我们可以加大主库的链接线程数： > SET GLOBAL MAX_CONNECTIONS=300; 复制问题 如果主库进行了RESET MASTER;命令，从库的SLAVE信息和主库的binlog信息就对不上了。 如果很不幸的发生了这种问题，只能重新搭建主从。 使用主从复制时，铭记一点，主库的日志清理在主从关系依然存在的情况下只能使用定期清理。 数据问题 主从的数据必须一致，换句话说最好的办法就是禁止从库写入，在后面我们会介绍更好用的读写分离方案，但是下面这条命令可以实现从库只许读，还是不建议在这里进行设置，仅做了解即可： > SET GLOBAL read_only=0; 另外如果中继日志信息文件或者中继日志文件被人为删除，那么就只能重新搭建主从了，因为从库的SQL_T线程工作会被完全打乱。 线程问题 IO_T和SQL_T可能会停止工作，这个时候你就需要重新启用它们。 先在从库上查看复制状态： > SHOW SLAVE STATUS\\G; Slave_IO_Running: No Slave_SQL_Running: No 如果为No，则重新启用线程： > START SLAVE io_thread; > START SLAVE sql_thread; 延时问题 如果你没有做延时方面的操作，但是就是出现了主从延时，则可以从以下几个原因入手： 1）主库的binlog刷写策略有误： -- 检查并将其设置为1 > SELECT @@sync_binlog; 2）主库可能存在大量的写入操作，导致binlog_dump线程忙不过来，一般只有event主从才会遇见这种问题，因为GTID主从的binlog_dump线程是并行传输： -- 主库的数据可以同时被多个线程操控进行并行处理 -- 但是event主从中，主库DUMP线程只有一个，为了保证binlog传输时顺序不会乱所以是串行传输 -- 搭建GTID的主从，可以将DUMP线程变更为并行传输 3）从库中SQL_T线程只有一个，但是主库可能传输太多的记录SQL_T线程忙不过来： -- 搭建GTID的主从，就可以开启多个SQL_T线程 -- 大事务拆成小事务，加快SQL_T线程的回放过程 判断到底是主库还是从库的问题导致延迟，一般GTID主从不用太关注下面的这些原因： -- 第一步，使用监控命令，查看延迟时间：Seconds_Behind_Master > SHOW SLAVE STATUS\\G; -- 第二步，查看主库的MASTER的Position是否与从库的Read_Master_Log_Pos信息是否一致 -- 如果一致，则没有延迟问题 -- 如果主库大，从库小，接着往下看 > SHOW MASTER STATUS; > SHOW SLAVE STATUS\\G; -- 查看从库的Exec_Master_Log_Pos与从库的Read_Master_Log_Pos是否一致 -- 如果一致，则没有延迟问题 -- 如果Read_Master_Log_Pos大，则从库SQL_T线程有问题，查看是否有锁相关的语句或者大事务 > SHOW MASTER STATUS; Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:48 "},"数据库专栏/MySQL/MHA架构.html":{"url":"数据库专栏/MySQL/MHA架构.html","title":"MHA架构","keywords":"","body":"MHA介绍 功能概述 MHA（Master High Availability）是由日本人yoshinorim开发的一款成熟且开源的MySQL高可用程序，它实现了MySQL主从环境下MASTER宕机后能够自动进行单次故障转移的功能，其本身由perl语言编写，安装方便使用简单。 GitHub：点我跳转 使用MHA能够让我们更大程度的解放双手，用更少的指令完成更多的事，MHA主要能够做以下几件事： 自动的在MASTER宕机后选举新的SLAVE作为MASTER，保证服务不被中断 自动的在MASTER宕机后将所有未被选举为新MASTER的SLAVE重新指向新的MASTER并启动复制 自动的在MASTER宕机后向数据库管理人员发送报警邮件 自动的进行VIP漂移服务，确保服务运行不会暂停 MHA搭建条件最少是1主2从，且必须是独立的服务器，不能单机多实例进行搭建。 架构图示 MHA架构图如下所示，理想服务器数量是5台，我们也可以使用3台进行搭建，这篇文章会使用最理想的情况即5台服务器进行搭建： 相关说明 MHA实际上就是一个软件集合，它的软件分为2部分： Manager软件 Node软件 上图中每一个色块都是一个Node，包括Manager本身也是一个Node。 Node软件必须安装在所有的MHA节点上，而Manager软件则只需安装在管理节点上。 不同的软件由不同的工具包组成，如下所示： -- Master masterha_manager - 用于启动MHA masterha_check_ssh - 用于检查MHA的SSH配置情况 masterha_check_repl - 用于检查MHA的主从复制情况 masterha_master_monitor - 用于检查Master节点是否宕机 masterha_check_status - 用于检查当前MHA的运行状态 masterha_master_switch - 用于自动故障恢复 masterha_conf_host - 用于添加或者删除Manager中配置的server信息 -- Node save_binary_logs - 保存并复制Master的binlog apply_diff_relay_logs - 识别差异的中继日志事件并将其差异的event事件应用于其他的Slave中 purge_relay_logs - 自动清除中继日志，且不会阻塞SQL_T线程 对于MASTER、SLAVE1、SLAVE2的作用这里不再描述，主要描述一下VIP以及Manager和binlog_server的作用： -- VIP 对外服务的虚拟IP，当Master宕机之后故障转移过程中选举了新的Master时虚拟IP也会漂移到新Master上，确保服务不会中断 -- Manager 用于管理所有的Node，它会自动的监听MySQL主从复制的状态，当主库发生宕机后会开启一系列的故障转移工作 -- binlog_server 这是一个单独存放拷贝主库binlog的服务器，不会参与任何业务处理，并且不会与主库的binlog产生任何延迟，具体思路是当主库的事务准备提交前，会将binlog记录发送给该服务器，只有当二进制日志存储服务器将该条记录成功存储后，主库上这一事务方可被提交，由此可见，这种技术是在牺牲性能的前提下保证了数据的一致性，一般来说我们都会进行开启，在主机宕机且SSH不可被链接状态下，从库的数据恢复依然可以从二进制日志存储服务器中获取数据 工作流程 以下是MHA的工作流程，Manager节点通过masterha_manager脚本启动MHA后会先进行检查工作： Manager节点通过masterha_check_ssh脚本检查各节点的互信配置 Manager节点通过masterha_check_repl脚本检查主从之间的复制情况 检查工作均完成且确认无误后，Manager节点会进行监控工作： Manager节点通过masterha_master_monitor对主库不断的进行心跳检测，主库3次无响应后会认为其以宕机 当主库宕机后，会开始故障转移工作，首先会对SLAVE进行选主，有以下3种算法： 读取Manager配置文件，判断是否有强制选主的Slave 自动判断目前已有从库的日志量，将最接近主库日志量的从库选为新的主库 根据配置文件中先后顺序进行选主 当选主完成后，Manager节点会再次通过SSH链接已宕机主库，有以下2种情况发生： 已宕机主库的SSH能够链接，表明MySQL服务是由逻辑因素所导致的宕机，此时Manager会通过save_binary_logs脚本，计算各个从库（包括新主库）与已宕机主库之间binlog差异，将已宕机主库的binlog位置找出来并进行截取、分发到各个从库上进行数据对齐，确保数据一致性 已宕机主库的SSH不能链接，表明MySQL服务是由物理因素所导致的宕机，此时Manager会通过apply_diff_relay_logs脚本，计算各个从库relay-log的差异，将差异较大的从库与新主库进行relay-log对齐，确保数据一致性 当所有库的数据一致性被确保之后，所有从库都将会与新主库建立主从关系，同时旧的已宕机主库信息将会从Manager项目配置文件中移除，至此整个MHA软件服务结束，Manager不会再对Node进行管理，接下来需要管理员手动对已宕机主库进行排查恢复，并且手动搭建旧主库与新主库之间的主从关系然后重新启动整个MHA服务。 前期准备工作 地址规划 MHA架构仅支持单数的Node（不包含Manager和binlog_server），所以我们可以按照最低标准进行地址规划，如下所示： 作用 IP地址 服务端口 操作系统 MySQL版本 配置 Master 192.168.0.120 3306 Centos7.3 基础设施服务器 5.7.34 2核CPU 2G内存 20G硬盘 SLAVE 192.168.0.130 3306 Centos7.3 基础设施服务器 5.7.34 2核CPU 2G内存 20G硬盘 SLAVE 192.168.0.140 3306 Centos7.3 基础设施服务器 5.7.34 2核CPU 2G内存 20G硬盘 此外，Manager和binlog_server也需要2台服务器，地址规划如下所示： 作用 IP地址 服务端口 操作系统 MySQL版本 配置 Manager 192.168.0.200 3306 Centos7.3 基础设施服务器 无 1核CPU 1G内存 10G硬盘 binlog_server 192.168.0.210 3306 Centos7.3 基础设施服务器 5.7.34 1核CPU 1G内存 10G硬盘 如果你只有3台服务器，可以将Manager安装在Slave2上，不要binlog_server。 机器配置 我们准备5台虚拟机： 每一台机器都按照下面进行配置： -- 1.修改hostname $ hostnamectl set-hostname [server_role] -- 2.修改ip地址和UUID $ vim /etc/sysconfig/network-scripts/ifcfg-ens33 $ systemctl restart network 关闭防火墙这个不用多说了，必做的操作。 安装MySQL 接下来是在MASTER、SLAVE1、SLAVE2、binlog_server上安装MySQL。 1）下载MySQL5.7.34： $ cd ~ $ wget https://downloads.mysql.com/archives/get/p/23/file/mysql-5.7.34-linux-glibc2.12-x86_64.tar.gz 2）创建必要目录与解压MySQL： $ mkdir -p /db/mysql57/3306/{data,logs} $ tar -xvf ./mysql-5.7.34-linux-glibc2.12-x86_64.tar.gz -C /db/mysql57/3306/ $ mv /db/mysql57/3306/mysql-5.7.34-linux-glibc2.12-x86_64/ /db/mysql57/3306/mysql 3）添加环境变量： $ vim /etc/profile export PATH=/db/mysql57/3306/mysql/bin:$PATH $ source /etc/profile 4）创建MySQL管理用户： $ groupadd mysql $ useradd -g mysql mysql $ chown -R mysql:mysql /db/mysql57/ 5）验证是否安装成功： $ mysql -V 6）这一步很关键，填写配置文件： $ vim /etc/my.cnf [mysqld] user=mysql # 确保server_id都不相同 server_id=120 port=3306 basedir=/db/mysql57/3306/mysql datadir=/db/mysql57/3306/data # 如果加上这2句，在有binlog_server服务器的情况下，MHA高可用将失败，所以 # character-set-server=utf8mb4 # collation-server=utf8mb4_general_ci default-storage-engine=INNODB socket=/tmp/mysql.sock innodb_data_file_path=ibdata1:512M;ibdata2:512M:autoextend innodb_autoextend_increment=64 autocommit=1 innodb_flush_log_at_trx_commit=1 innodb_flush_method=O_DIRECT transaction-isolation=Read-Committed log_error=/db/mysql57/3306/logs/mysqld.log slow_query_log_file=/db/mysql57/3306/logs/slow.log slow_query_log=1 long_query_time=0.1 log_queries_not_using_indexes # 确保以下5项都是打开的 log_bin=/db/mysql57/3306/logs/mysql_bin binlog_format=row gtid-mode=on enforce-gtid-consistency=true log-slave-updates=1 [mysql] port=3306 # default-character-set=utf8mb4 socket=/tmp/mysql.sock prompt=\"> \" [client] port=3306 # default-character-set=utf8mb4 7）填写完成后进行初始化工作： $ mysqld --initialize-insecure 8）开启sys服务： $ cat >/etc/systemd/system/mysqld.service 9）尝试登录，再次验证server_id是否都不相同： $ mysql -uroot -e \"SELECT @@server_id;\" 主从搭建 主从搭建还是使用GTID主从而不是event主从，搭建流程如下： 1）在MASTER上执行以下操作，创建复制用户： $ mysql -uroot -S /tmp/mysql.sock -e \"grant replication slave on *.* to repl@'%' identified by '123'\"; -- 注意，如果是线上环境，请设置repl用户的允许登录地址 -- repl用户的权限是仅用于复制操作 2）在SLAVE1和SLAVE2上执行以下操作，这里我们不构建延时从库： > CHANGE MASTER TO MASTER_HOST='192.168.0.120', MASTER_USER='repl', MASTER_PASSWORD='123', MASTER_PORT=3306, MASTER_CONNECT_RETRY=10, MASTER_AUTO_POSITION=1; > START SLAVE; 3）在SLAVE1和SLAVE2上执行以下操作，检查复制状态，确保IO_T和SQL_T都是Yes： > SHOW SLAVE STATUS\\G; Slave_IO_Running: Yes Slave_SQL_Running: Yes 主从验证 这里我们对主从进行一次验证，为了后续的VIP功能测试，所以创建一个用户。 在MASTER上执行： > mysql -uroot > CREATE USER \"tom\"@\"%\" IDENTIFIED BY \"123\"; > GRANT all ON *.* TO \"tom\"@\"%\"; > FLUSH PRIVILEGES; 在SLAVE1和SLAVE2上查看用户是否创建成功： > SELECT user, host FROM mysql.user WHERE user = \"tom\" AND host = \"%\"; 至此，GTID主从搭建已经全部完成了。 MHA准备工作 互信配置 接下来开始做SSH互信配置，保证每个Node彼此之间能够互相链接，且在链接时不会有任何弹出提示要求输入密码的信息出现。 所有服务器上都执行以下操作： $ ssh-keygen -t dsa -P '' -f ~/.ssh/id_dsa >/dev/null 2>&1 -- 输入yes和root密码 $ ssh-copy-id -i /root/.ssh/id_dsa.pub root@192.168.0.120 $ ssh-copy-id -i /root/.ssh/id_dsa.pub root@192.168.0.130 $ ssh-copy-id -i /root/.ssh/id_dsa.pub root@192.168.0.140 $ ssh-copy-id -i /root/.ssh/id_dsa.pub root@192.168.0.200 $ ssh-copy-id -i /root/.ssh/id_dsa.pub root@192.168.0.210 互信配置完成后进行一次检查，所有服务器都执行，确保没有遗漏任何一台服务器： $ ssh root@192.168.0.120 pwd; ssh root@192.168.0.130 pwd; ssh root@192.168.0.140 pwd; ssh root@192.168.0.200 pwd; ssh root@192.168.0.210 pwd 软链接配置 MHA在启动后，不会加载环境变量profile，而是直接从/usr/bin下读取需要的应用，所以我们需要在MASTER、SLAVE1、SLAVE2、binlog_server上做2条软链接： $ ln -s /db/mysql57/3306/mysql/bin/mysqlbinlog /usr/bin/mysqlbinlog $ ln -s /db/mysql57/3306/mysql/bin/mysql /usr/bin/mysql 创建用户 在Master主库上创建MHA的管理用户，这个管理用户会自动的被复制到从库上： $ mysql -uroot -e \"GRANT ALL PRIVILEGES ON *.* TO mha@'192.168.0.%' IDENTIFIED BY 'mha'\"; 软件下载 MHA相关的软件资源你可以在Github上获取，共有4个需要下载的资源： 实际上我们只会用到3个资源： MHA Manager 0.56 rpm RHEL6：Manager的软件包 MHA Node 0.56 rpm RHEL6：Node的软件包 MHA Node 0.56 traball：Manager相关脚本，如虚拟IP、邮件提醒等功能脚本 这里MHA Node 0.56 traball中的脚本不能直接使用，要经过一些列配置，比较麻烦。 所以我将它们都统一打包到了腾讯云COS上，可以直接复制以下命令在服务器上进行操作，注意！每一台服务器都执行： $ cd ~ -- Manager的软件包 $ wget https://code-1302522496.cos.ap-nanjing.myqcloud.com/MHA/mha4mysql-manager-0.56-0.el6.noarch.rpm -- Node的软件包 $ wget https://code-1302522496.cos.ap-nanjing.myqcloud.com/MHA/mha4mysql-node-0.56-0.el6.noarch.rpm 下面这3条命令仅在Manager服务器上执行： -- VIP自动切换脚本 $ wget https://code-1302522496.cos.ap-nanjing.myqcloud.com/MHA_SCRIPTS/master_ip_failover -- VIP手动切换脚本 $ wget https://code-1302522496.cos.ap-nanjing.myqcloud.com/MHA_SCRIPTS/master_online_change -- 邮件报警脚本 $ wget https://code-1302522496.cos.ap-nanjing.myqcloud.com/MHA_SCRIPTS/send_report 目录配置 下面我们在Manager服务器上创建3个目录，用于存放mha相关的资源： $ mkdir -p /mha/{logs,scripts,conf} 将VIP脚本与邮件报警脚本转存到/mha/scripts目录下： $ mv ~/{master_ip_failover,master_online_change,send_report} /mha/scripts MHA基础搭建 软件安装 注意顺序！因为Manager服务器也是一个MHA的Node，所以必须先安装Node软件包。 1）所有的服务器上安装Node软件包依赖： $ yum install perl-DBD-MySQL -y $ rpm -ivh ./mha4mysql-node-0.56-0.el6.noarch.rpm 2）在Manager服务器上安装Manager软件包： -- 必须先进行换源，否则会出现下载不到依赖包的情况 $ wget -O /etc/yum.repos.d/epel.repo http://mirrors.aliyun.com/repo/epel-7.repo -- 安装软件包 $ yum install -y perl-Config-Tiny epel-release perl-Log-Dispatch perl-Parallel-ForkManager perl-Time-HiRes $ rpm -ivh ./mha4mysql-manager-0.56-0.el6.noarch.rpm 项目配置 我们上面已经创建了/mha/conf目录，接下来就需要在Manager服务器上创建mha的项目配置文件了。 一个mha可以管理多套主从，只需要创建不同的项目配置文件即可，我这里的这个主从项目就命名为app1： $ vim /mha/conf/app1.cnf [server default] # 链接其他服务器ssh的用户,主要用于心跳检测、IP漂移 ssh_user=root # 当前Manager的工作目录 manager_workdir=/mha/logs/app1 # 当前Manager的日志目录 manager_log=/mha/logs/manager # 执行MHA管控的用户，必须在主库上已经创建 user=mha password=mha # 主库中binlog的存放目录 master_binlog_dir=/db/mysql57/3306/logs # 主库为从库复制binlog的用户 repl_user=repl repl_password=123 # Manager对Master的心跳检测频率 ping_interval=3 # 相关脚本文件路径、自动切换VIP的脚本、手动切换VIP的脚本、发送邮件报警的脚本 # 注意！如果添加了mycat或者atlas等中间件，就可以不用添加VIP脚本master_ip_failover和master_online_change # 因为我们根本不会链接主库 master_ip_failover_script=/mha/scripts/master_ip_failover master_ip_online_change_script=/mha/scripts/master_online_change report_script=/mha/scripts/send_report [server1] hostname=192.168.0.120 port=3306 [server2] # 强制选主的从库 candidate_master=1 # 该从库进行选主时，relaylogs的复制情况不再起到决定因素 check_repl_delay=0 hostname=192.168.0.130 port=3306 [server3] hostname=192.168.0.140 port=3306 [binlog1] # 永不参与主库竞选 no_master=1 hostname=192.168.0.210 # binlog_server中存放复制Master的binlog的路径 master_binlog_dir=/data/mysql/binlog 注意，我们这里并没有显示的指明谁是主库，但是没有关系，MHA能够自动的鉴别主库是谁。 脚本配置 上面我们指定了3个脚本，MHA将在MASTER宕机之后自动启用它们。 但是这3个脚本还有一些配置项需要我们进行修改。 首先是邮件报警脚本，在设置该脚本前我们需要设置一下邮箱，打开SMTP服务。 以QQ邮箱为示例，点击设置： 点击邮箱设置，账户： 往下翻，找到POP3/SMTP服务选择并开启： 开启POP3/SMTP服务后生成授权码，将授权码保存下来。 然后对send_report脚本进行修改： $ vim /mha/scripts/send_report my $smtp='smtp service type'; my $mail_from='who will send this email'; my $mail_user='smtp login user'; my $mail_pass='smtp authorization code'; # my $mail_to=['to1@qq.com','to2@qq.com']; my $mail_to='who will receive this email'; -- 修改为 my $smtp='smtp.qq.com'; my $mail_from='我的QQ邮箱@qq.com'; my $mail_user='我的QQ邮箱@qq.com'; my $mail_pass='我的授权码肯定不给你看呀'; #my $mail_to=['to1@qq.com','to2@qq.com']; my $mail_to='对方的QQ邮箱@qq.com'; # 可以是其他的邮箱 下面还有2个脚本，它们分别是 master_ip_failover：MHA自动切换主库后进行VIP漂移的脚本 master_online_change：管理员手动切换主库后进行VIP漂移的脚本 在开始设置之前，先使用ifconfig记录一下你所使用的网卡名称，我这里是ens33（注意！这里必须主从复制中所有的服务器都具有这一块网卡才行）： $ ifconfig ens33: flags=4163 mtu 1500 先打开master_ip_failover脚本进行编辑： $ vim /mha/scripts/master_ip_failover my $vip = 'virtual IP address/virtual IP network segment'; my $key = '1'; my $ssh_start_vip = \"/sbin/ifconfig network_card:$key $vip\"; my $ssh_stop_vip = \"/sbin/ifconfig network_card:$key down\"; -- 修改为 my $vip = '192.168.0.250/24'; # 一定确保这个地址没有人用 my $key = '1'; # 一定确保网卡名:1没有人用 my $ssh_start_vip = \"/sbin/ifconfig ens33:$key $vip\"; # 网卡 my $ssh_stop_vip = \"/sbin/ifconfig ens33:$key down\"; # 网卡 然后打开master_online_change脚本进行编辑： $ vim /mha/scripts/master_online_change vip=`echo 'virtual IP address/virtual IP network segment'` key=`echo '1'` stop_vip=`echo \"ssh root@$orig_master_host /usr/sbin/ifconfig network_card:$key down\"` start_vip=`echo \"ssh root@$new_master_host /usr/sbin/ifconfig network_card:$key $vip\"` -- 修改为 vip=`echo '192.168.0.250/24'` # 和master_ip_failover的$vip一致 key=`echo '1'` # 和master_ip_failover的$key一致 stop_vip=`echo \"ssh root@$orig_master_host /usr/sbin/ifconfig ens33:$key down\"` # 网卡 start_vip=`echo \"ssh root@$new_master_host /usr/sbin/ifconfig ens33:$key $vip\"` # 网卡 下载doc2unix软件对3个脚本进行一次format，这是为了防止有中文信息的存在导致的错误： $ yum install -y dos2unix $ dos2unix /mha/scripts/{master_online_change,master_ip_failover,send_report} 然后一定要为这3个脚本添加执行权限： $ chmod +x /mha/scripts/{master_online_change,master_ip_failover,send_report} 最后，我们需要到主库上，执行下面这条命令： $ ifconfig ens33:1 192.168.0.250/24 #1 #2 #3 -- 将#1设置成你刚刚通过ifconfig命令获得的网卡地址 -- 将#2设置成master_ip_failover脚本中$key的值 -- 将#3设置成master_ip_failover脚本中$vip的值 -- 注意！确保ens33:1没有被使用！ 使用ifcofnig命令可以查看虚拟IP已经被添加上了，后期MASTER出现故障时他自动的进行转移到新MASTER上： $ ifconfig ens33:1: flags=4163 mtu 1500 inet 192.168.0.250 netmask 255.255.255.0 broadcast 192.168.0.255 ether 00:0c:29:6e:f1:4b txqueuelen 1000 (Ethernet) binlog_server配置 上面我们在app1的项目配置文件中添加了binlog_server： [binlog1] # 永不参与主库竞选 no_master=1 hostname=192.168.0.210 # binlog_server中存放复制Master的binlog的路径 master_binlog_dir=/data/mysql/binlog 所以现在我们需要到binlog_server上执行一些操作，首先是创建master_binlog_dir的目录： $ mkdir -p /data/mysql/binlog $ chown -R mysql.mysql /data/* 然后需要进入SLAVE1或者SLAVE2上，执行以下命令查看一下当前MASTER正在使用的binlog文件： > SHOW SLAVE STATUS\\G; Master_Log_File: mysql_bin.000005 回到binlog_server中，必须进入刚刚创建的master_binlog_dir目录，开始拉取主库的binlog日志： $ cd /data/mysql/binlog $ mysqlbinlog -R --host=192.168.0.120 --port=3306 --user=mha --password=mha --raw --stop-never mysql_bin.000005 & 状态检查 好了，现在一切就绪，我们可以让MHA验证主从状态了。 在Manager服务端上对1主2从的服务器进行SSH互信检查： $ masterha_check_ssh --conf=/mha/conf/app1.cnf -- 出现：All SSH connection tests passed successfully 则互相配置成功 在Manager服务器上进行主从状态检查： $ masterha_check_repl --conf=/mha/conf/app1.cnf -- 出现：MySQL Replication Health is OK 则主从状态良好 确认状态都没问题后，进行下一步操作。 MHA命令 MHA命令后面跟上项目配置文件即可，如下所示。 开启MHA监控： $ nohup masterha_manager --conf=/mha/conf/app1.cnf --remove_dead_master_conf --ignore_last_failover /mha/logs/manager.log 2>&1 & --conf：指定配置文件 --remove_dead_master_conf：剔除已经死亡的节点 --ignore_last_failover：MHA默认不能短时间(8小时)多次切换主从，添加此参数可跳过时间检查 检查MHA是否正常运行中： $ masterha_check_status --conf=/mha/conf/app1.cnf -- 当出现is running(0:PING_OK)则MHA正在运行 停止当前MHA的监控工作： $ masterha_stop --conf=/mha/conf/app1.cnf alias命令 上面不管是启动、检测、关闭MHA的命令都十分繁琐，我们可以alias一个别名方便后续使用。 在Manager服务器上，执行以下操作： $ vim /etc/profile alias mha_app1_start=\"nohup masterha_manager --conf=/mha/conf/app1.cnf --remove_dead_master_conf --ignore_last_failover /mha/logs/manager.log 2>&1 &\" alias mha_app1_status=\"masterha_check_status --conf=/mha/conf/app1.cnf\" alias mha_app1_stop=\"masterha_stop --conf=/mha/conf/app1.cnf\" $ source /etc/profile 故障演练 发生故障 现在我们要开始故障模拟了，首先在Manager上使用以下命令查看它的日志变化： $ tail -f /mha/logs/manager 然后到MASTER服务器上，执行以下命令关闭mysqld服务： $ systemctl stop mysqld.service 回到Manager服务器上，观察日志变化，当出现了以下字样则代表故障转移成功！已经有新的主库产生，若没下面的字样则故障转移一定是失败的： Master failover to 192.168.0.130(192.168.0.130:3306) completed successfully. 检查MHA是否运行，会看到它完成了工作，目前已经处于停止状态了： $ mha_app1_status app1 is stopped(2:NOT_RUNNING). [1]+ 完成 nohup masterha_manager --conf=/mha/conf/app1.cnf --remove_dead_master_conf --ignore_last_failover /mha/logs/manager.log 2>&1 登录QQ邮箱，查看邮件是否成功发送，如果成功发送则代表send_report脚本是运行成功的： 我们再到SLAVE1上查看VIP有没有转移过来： $ ifconfig ens33:1: flags=4163 mtu 1500 inet 192.168.0.250 netmask 255.255.255.0 broadcast 192.168.0.255 ether 00:0c:29:f3:f0:1f txqueuelen 1000 (Ethernet) 可以看到VIP已经成功转移，这意味着通过192.168.0.250:3306，我们依然可以访问MySQL服务，这代表master_ip_failover脚本是运行成功的。 在binlog_server上运行一下命令即可进行验证： $ mysql -utom -p123 -h192.168.0.250 -P3306 -e\"SELECT @@server_id;\" 故障恢复 现在，我们应该将已宕机的192.168.0.120库重新启动，加入到集群中： $ systemctl start mysqld.service $ mysql -uroot > CHANGE MASTER TO MASTER_HOST='192.168.0.130', -- 注意！现在130是主库了 MASTER_USER='repl', MASTER_PASSWORD='123', MASTER_PORT=3306, MASTER_CONNECT_RETRY=10, MASTER_AUTO_POSITION=1; > START SLAVE; 检查复制状态，确保IO_T和SQL_T都是Yes，并且记录Master_Log_File： > SHOW SLAVE STATUS\\G; Slave_IO_Running: Yes Slave_SQL_Running: Yes Master_Log_File: mysql_bin.000005 随着MHA服务的完成，binlogserver也完成了它的工作停止了继续复制master_binlog的行为，我们需要到binlog_server服务器上，删除旧MASTER上拉取的binlog日志，重新拉取新的binlog日志，当然你也可以选择不删除，这都无伤大雅： $ mv /data/mysql/binlog/* /tmp/ $ mysqlbinlog -R --host=192.168.0.130 --port=3306 --user=mha --password=mha --raw --stop-never mysql_bin.000005 & -- 拉取的日志名填写上面记录的Master_Log_File MHA服务完成后，会将旧主库从配置文件中删除，所以我们需要将旧主库重新加入到配置文件中，在Manager上执行以下操作，添加旧主库到项目配置文件中： $ vim /mha/conf/app1.cnf [server1] candidate_master=1 check_repl_delay=0 hostname=192.168.0.120 port=3306 做完上面的工作后，我们又可以运行MHA服务啦！只需要在Manager节点上执行以下操作即可： $ mha_app1_start $ mha_app1_status app1 (pid:2192) is running(0:PING_OK), master:192.168.0.130 手动切换 如果我们想手动的切换主库，必须要停止MHA服务： $ mha_app1_stop 然后在Manager上运行以下命令： $ masterha_master_switch --conf=/mha/conf/app1.cnf --master_state=alive --new_master_host=192.168.0.120 --orig_master_is_new_slave --running_updates_limit=10000 --interactive=0 -- Switching master to 192.168.0.120(192.168.0.120:3306) completed successfully. 代表切换成功 下一步还是到SLAVE上查看主库目前正在使用的日志： $ show slave status\\G; Master_Log_File: mysql_bin.000006 还是老步骤，到binlog_server上重新拉取这个日志： $ mv /data/mysql/binlog/* /tmp/ $ mysqlbinlog -R --host=192.168.0.120 --port=3306 --user=mha --password=mha --raw --stop-never mysql_bin.000006 & -- 拉取的日志名填写上面记录的Master_Log_File 检查VIP是否成功漂移到了192.168.0.120上，如果成功则代表master_online_change脚本运行完成，在新的MASTER上执行以下命令即可： $ ifconfig ens33:1: flags=4163 mtu 1500 这次是我们手动切换的主从身份，所以192.168.0.130会自动变为从库，不用重新CHANGE MASTER TO，所以接下来只需在Manager服务器上执行以下重新开启MHA监控即可： $ mha_app1_start $ mha_app1_status app1 (pid:2309) is running(0:PING_OK), master:192.168.0.120 至此，MHA的基础使用宣布告一段落，感谢阅读。 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:48 "},"数据库专栏/MySQL/Atlas中间件.html":{"url":"数据库专栏/MySQL/Atlas中间件.html","title":"Atlas中间件","keywords":"","body":"Atlas功能 Atlas中间件是由奇虎360公司基于MySQL官方中间件Mysql-Proxy二次开发进行实现，它能够对数据库进行读写分离、分库分表配置，配合MHA架构进行高可用环境搭建有较好的效果。 GITHUB地址：点我跳转 在此文中，会着重介绍MHA配合Atlas进行读写分离的配置，关于分库分表我们有更好的选择，不在此处进行举例。 如果你的数据库数据量级不是特别大，MHA高可用+Atlas读写分离应该能够应付绝大多数场景，并且它的配置比MHA+MyCat简单许多。 我们先来观察单纯的MHA架构有什么缺点： MHA是单活架构，最低1主2从构成，读写都在主库上进行，从库只有在主库宕机后才会发生作用，硬件利用率较小 单纯的使用MHA架构会使主库的压力比较大，承载高频率读写操作的耗时时间很长 所以我们需要使用Atlas中间件，来进行基于MHA高可用的读写分离构建，使硬件利用率提升，主库压力减轻。 以下是架构草图： Atlas搭建 地址介绍 我们基于上一章节MHA架构中的地址规划继续进行使用： Master: 192.168.0.120 -- 将Atlas中间件安在这台服务器上 Slave1: 192.168.0.120 Slave1: 192.168.0.130 Manager: 192.168.0.200 binlog_server: 192.168.0.210 为了节省虚拟机资源，所以可以将Atlas安装到MHA的Manager服务器上。 软件安装 在软件安装前，需要注意以下3点： Atlas只能运行在64位系统上 Centos5.x安装e15版本，Centos6.x及以上安装e16版本 MySQL版本应大于5.1，官方推荐使用5.6 去Github上下载软件： -- 1.官方Github上下载 https://github.com/Qihoo360/Atlas/wiki/Atlas%E7%9A%84%E5%AE%89%E8%A3%85 -- 2.或者直接使用下面的命令，我将安装包上传到了腾讯云COS，不用担心版本，官方一年没更了 $ wget https://code-1302522496.cos.ap-nanjing.myqcloud.com/Atlas-2.2.1.el6.x86_64.rpm $ rpm -ivh ./Atlas-2.2.1.el6.x86_64.rpm 另外我们这台服务器还没有安装MySQL，所以需要手动安装一下，参考之前的MHA架构一章。 注意Atlas服务器安装完MySQL后应当停止mysqld.service服务，因为我们只需要使用到MySQL的client端。 $ systemctl stop mysqld.service $ systemctl disable mysqld.service 相关配置 在安装成功后，进入以下目录： $ cd /usr/local/mysql-proxy/conf 这个目录中默认有个test.cnf，里面详细记载了Atlas的配置，先不用管它，直接重命名备份： $ mv ./test.cnf ./test.cnf.bak 接下来我们要自己写一个配置文件，但在此之前要将Master节点上配置的MHA管理用户以及主从复制用户使用Atlas中提供的功能进行加密并记录加密后得到的值，因为在Atlas配置项中，用户的密码需要密文填入，总体来说这里可以将所有Master上允许远程登录的业务用户都操作一次： $ /usr/local/mysql-proxy/bin/encrypt mha -- 我们mha管理用户的密码是mha，所以这里直接填写密码 O2jBXONX098= $ /usr/local/mysql-proxy/bin/encrypt 123 -- 我们主从复制用户的密码是123，所以这里直接填写密码 3yb5jEku5h4= 开始书写Atlas配置文件了： $ vim ./test.cnf [mysql-proxy] # Atlasd的工作IP和端口 proxy-address = 0.0.0.0:33060 # Atlasd的管理IP和端口 admin-address = 0.0.0.0:2345 # 默认字符集 charset=utf8 # 允许登录管理接口的用户名 admin-username = user # 管理接口的密码 admin-password = pwd # 主库的IP和端口号，可设置多个，使用逗号分隔 proxy-backend-addresses = 192.168.0.120:3306 # 从库的IP和端口号，可设置多个，使用逗号分隔 proxy-read-only-backend-addresses = 192.168.0.130:3306,192.168.0.140:3306 # 允许登录工作接口的用户名与其对应的加密后的密码 pwds = repl:3yb5jEku5h4=,mha:O2jBXONX098= # 是否已守护线程运行 daemon = true # 开启监控进程和工作进程 keepalive = true # 工作线程数 event-threads = 8 # 日志记录级别 log-level = message # 日志存放路径 log-path = /usr/local/mysql-proxy/log # SQL日志开关 sql-log=ON 其他配置项可参照test.cnf.back文件进行查找。 相关命令 配置完成后我们就可以使用Atlas的命令了，启动命令如下： $ /usr/local/mysql-proxy/bin/mysql-proxyd test start 查看Atlas是否正常运行： $ netstat -lntup | grep mysql-proxy $ /usr/local/mysql-proxy/bin/mysql-proxy test status 重启命令如下： $ /usr/local/mysql-proxy/bin/mysql-proxyd test restart 停止命令如下： $ /usr/local/mysql-proxy/bin/mysql-proxyd test stop Atlas测试 两种模式 Atlas有2种模式，一种是对外服务的33060接口，一种是对内服务的2345接口。 所有业务有关的操作，都在33060接口上进行，它将自动进行读写分离 所有监控有关的操作，都在2345接口上进行，它将自动使用Atlas监控整个服务 当我们添加了Atlas中间件后，后续所有请求都朝Atlas中间件发送而不是再朝真实的MySQL服务器发送。 工作接口 使用工作模式进入测试读写分离是否正常运行。 测试读操作，只要没有被BEGIN...COMMIT所包裹的语句，Atlas中间件都将视为读操作： $ mysql -umha -pmha -h192.168.0.200 -P33060 -e \" SELECT @@server_id;\" +-------------+ | @@server_id | +-------------+ | 140 | +-------------+ -- 注意！以后所有application都将链接Atlas的33060端口进行业务操作 测试写操作，即使是一个查询语句，但被BEGIN...COMMIT包裹，Atlas中间件也会认为它是写操作： $ mysql -umha -pmha -h192.168.0.200 -P33060 -e \"BEGIN; SELECT @@server_id; ROLLBACK;\" +-------------+ | @@server_id | +-------------+ | 120 | +-------------+ -- 注意！以后所有application都将链接Atlas的33060端口进行业务操作 管理接口 使用管理接口查看服务相关信息。 $ mysql -uuser -ppwd -h192.168.0.200 -P2345 -- 注意！这里针对管理接口我们设置的用户名是user、密码是pwd，参见配置文件 打印帮助信息，来查看你目前能够在管理接口下使用的所有语句： > SELECT * FROM help; +----------------------------+---------------------------------------------------------+ | command | description | +----------------------------+---------------------------------------------------------+ | SELECT * FROM help | shows this help | | SELECT * FROM backends | lists the backends and their state | | SET OFFLINE $backend_id | offline backend server, $backend_id is backend_ndx's id | | SET ONLINE $backend_id | online backend server, ... | | ADD MASTER $backend | example: \"add master 127.0.0.1:3306\", ... | | ADD SLAVE $backend | example: \"add slave 127.0.0.1:3306\", ... | | REMOVE BACKEND $backend_id | example: \"remove backend 1\", ... | | SELECT * FROM clients | lists the clients | | ADD CLIENT $client | example: \"add client 192.168.1.2\", ... | | REMOVE CLIENT $client | example: \"remove client 192.168.1.2\", ... | | SELECT * FROM pwds | lists the pwds | | ADD PWD $pwd | example: \"add pwd user:raw_password\", ... | | ADD ENPWD $pwd | example: \"add enpwd user:encrypted_password\", ... | | REMOVE PWD $pwd | example: \"remove pwd user\", ... | | SAVE CONFIG | save the backends to config file | | SELECT VERSION | display the version of Atlas | +----------------------------+---------------------------------------------------------+ 如，查询后端的所有节点信息： > SELECT * FROM backends; +-------------+--------------------+-------+------+ | backend_ndx | address | state | type | +-------------+--------------------+-------+------+ | 1 | 192.168.0.120:3306 | up | rw | | 2 | 192.168.0.130:3306 | up | ro | | 3 | 192.168.0.140:3306 | up | ro | +-------------+--------------------+-------+------+ 对于节点你可以自由的进行规划，如下所示： -- 动态删除某一个节点 > REMOVE BACKEND 3; -- 动态添加某一个节点 > ADD SLAVE 192.168.0.140:3306; 不需要重启而而想保存在管理接口中应用的配置，你需要输入以下语句： > SAVE CONFIG; 添加用户 使用Atlas中间件后，如果要添加一个允许远程登录的用户，我们可以向下面这样进行操作。 1）在主库中创建用户： $ mysql -uroot -p -e\"GRANT SELECT, UPDATE, INSERT ON *.* TO ken@'%' IDENTIFIED BY '123456';\" 2）登录atlas管理端口，添加用户： $ mysql -uuser -ppwd -h192.168.0.200 -P2345 > ADD pwd ken:123456; > SELECT * FROM pwds; +----------+--------------+ | username | password | +----------+--------------+ | repl | 3yb5jEku5h4= | | mha | O2jBXONX098= | | ken | /iZxz+0GRoA= | +----------+--------------+ > SAVE CONFIG; 宕机处理 当MHA中主库宕机故障转移产生了新库时，我们需要先执行MHA的修复流程。 MHA修复完毕后，需要在Atlas中执行以下操作： -- 1.登录管理接口 $ mysql -uuser -ppwd -h192.168.0.200 -P2345 -- 2.找到新主库索引编号 > SELECT * FROM backends; -- 3.删除旧主库 > REMOVE BACKEND stop_master_index; -- 4.添加新主库 > ADD MASTER 192.168.0.XXX:3306; -- 5.将旧主库设置为从库 > ADD SLAVE 192.168.0.XXX:3306; Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:48 "},"数据库专栏/MySQL/数据库设计.html":{"url":"数据库专栏/MySQL/数据库设计.html","title":"数据库设计","keywords":"","body":"模型构建 概念模型 概念模型简称CDM，通过描述业务系统要管理的对象，来构建大体的设计思路。 由需求分析师通过与客户的沟通，得到一个较浅层次的概念模型。 如，用户想要一个学生信息库，此时就有了一个最基本的概念雏形。 原来是想要一个学生信息库，中心点则应该以学生为主。 这也是对数据实体化最根本的一种模型建立。 逻辑模型 逻辑模型简称LDM，基于概念模型，列举出所有的实体、实体属性以及关系。 这是一种基于业务本身的描述，和数据库真正实施无关，由需求分析师和架构师一同完成。 如，学生信息库，应当有哪些属性？如学号、姓名、年龄、课程，除此之外还要研究与其他表的关系，如学生表与老师表是什么关系？学生表与课程表有哪些关系等等。 物理模型 物理模型简称PDM，基于逻辑模型开始在数据库上进行构建实施。 结合数据库的物理结构，设计具体的表结构，字段列表以及主外键约束等。 由技术实现细节，与具体的数据库类型相关，如RDBMS，NoSQL等数据库类型就有不同的实施方案。 开发人员根据数据库特点结合业务实际的逻辑模型进行实施搭建。 比如RDBMS一般都具有3大设计范式，它意在减少数据冗余，清晰逻辑结构，而这不适用于NoSQL。 设计范式 原子约束 1NF是字段属性不可再分解，只要满足了这个条件就满足了第一范式。 如下示例，其实下面这个结构乍一看没问题，但address其实是可以细分的，所以这张表不符合第一范式： 如果将address拆分出国家和城市，那么后续根据国家或者城市分类人员时将会更方便： 唯一约束 2NF是记录必须具有实体唯一性，不存在部分依赖关系。 如下所示，学生表中的成绩信息实际上只依赖学生编号，不依赖学生姓名、性别、年龄等信息，存在部分依赖关系而不是全部依赖，后续连表查询时容易造成该表数据量太大降低查询效率的问题： 可以单独将它和学生编号拆成一张新表，完成全部依赖，减少连表的数据量： 冗余约束 3NF规定数据必须减少冗余性，这样可以节省磁盘空间，减少查询I/O次数提高效率。 如下所示，每个学生都拥有班级姓名字段、班级负责人字段，这样就会带来极大的冗余性，会产生许多重复的数据： 最好的办法是拆出一个班级表进行一对多关系建立： 反范式设计 完全符合三大设计范式的数据库从逻辑层面上来讲是很完美的，但是他的性能不一定是最高的。 因此我们也应当适当的进行反范式设计，比如对于学生的成绩表来说总成绩total_score字段并不是必须的，因为它可以通过其他课程的成绩累加获得，但是这样的累加计算如果在查询时才进行是会拖慢查询效率的，所以最好的办法就是加上total_score字段，让其在插入数据时自动计算，而不是在查询时再计算。 典型的空间换时间： -- 低性能的 CREATE TABLE student_score( id PRIMARY KEY AUTO_INCREMENT, html TINYINT UNSIGED NOT NULL, css TINYINT UNSIGED NOT NULL, javascript TINYINT UNSIGED NOT NULL ) ENGINE innodb CHARSET utf8mb4 COLLATE utf8mb4_general_ci; -- 高性能的 CREATE TABLE student_score( id INT PRIMARY KEY AUTO_INCREMENT, html TINYINT UNSIGNED NOT NULL, css TINYINT UNSIGNED NOT NULL, javascript TINYINT UNSIGNED NOT NULL, total_score MEDIUMINT(3) NOT NULL ) ENGINE innodb CHARSET utf8mb4 COLLATE utf8mb4_general_ci; -- 在application链接时，先计算总价然后插入 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:48 "},"数据库专栏/MongoDB/summary.html":{"url":"数据库专栏/MongoDB/summary.html","title":"MongoDB","keywords":"","body":" 基础学习 简单概念 库与集合 文档操作 文档查询 聚合查询 索引相关 用户权限 配置文件 设计模式 复制集群 事务相关 变更流 分片集群 备份恢复 数据迁移 开发指南 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:48 "},"数据库专栏/MongoDB/基础学习.html":{"url":"数据库专栏/MongoDB/基础学习.html","title":"基础学习","keywords":"","body":"MongoDB 简介 基础概念 MongoDB 被誉为是最像 SQL 的 NoSQL，也是非关系数据库中最火热的产品，甚至 MySQL 中都能见到 MongoDB 的很多设计理念。 MongoDB 的官方文档非常全面，可供开发者进行查阅：MongoDB 中文文档 下面是一些 MongoDB 与 SQL 之间概念的一些差异： SQL 术语 / 概念 MongoDB 术语 / 概念 解释 / 说明 database database 数据库 table collection 数据库表 / 集合 row document 数据记录行 / 文档 column field 数据字段 / 域 index index 索引 table joins 表连接，MongoDB 不支持 primary key primary key 主键，MongoDB 自动将 _id 字段设置为主键 值得一提的是，MongoDB 中支持事务，这是其他很多 NoSQL 都不支持的。 版本介绍 MongoDB 第一版在 2009 年面世，由 DoubleClick 公司（2013 年时已更名 MongoDB）开发，一经推出就引起了轩然大波，因为它结束了关系型数据库产品对行业的统治，MongoDB 目前版本种类较少，主流版本为 4.x，那么在接下来我们也将使用目前较新的 4.4 版本进行学习（系统为 Centos7.3）。 下面是 MongoDB 的版本形式，摘自官网： MongoDB 的版本的形式 X.Y.Z，其中 X.Y 指的是一个版本系列或开发系列，而 Z 指修订 / 补丁号 如果 Y 是偶数，则 X.Y 指发布系列；例如， 4.0 发行系列和 4.2 发行系列。发布系列稳定且适合生产 如果 Y 是奇数，则 X.Y 指一个开发系列；例如， 4.1 开发系列和 4.3 开发系列。开发系列仅用于测试而不是生产 例如，在 MongoDB 版本 4.0.12 中，4.0 指的是发行系列，而 .12 指的是修订版。 与 SQL 区别 MongoDB 中数据基本单元名为文档，一个文档相当于 SQL 中的一条记录行。 而 MongoDB 中的集合可以认为是 SQL 中的表。 MongoDB 中自带了一个由 JavaScript 编写的 shell，能够管理 MongoDB 实例和操作数据 对于文档来说，每一个文档都有一个特殊的_id 键，非空且唯一，与 SQL 中的主键相同 在 MongoDB 中，更加注重数据的整体存放，而不同于 SQL 中分表的概念，如下是对多表关系进行存储时 MongoDB 与 MySQL 的一些差异。 # MySQL 多表关系存储： --------------------------------------- | id | name | age | gender | grades | --------------------------------------- | 1 | Jack | 18 | male | 1 | --------------------------------------- ----------------------------- | id | Js | Py | Go | ----------------------------- | 1 | 88 | 96 | 78 | ----------------------------- # MongoDB 多表关系存储： { \"_id\" : ObjectId(\"uuid\") \"id\" : \"1\", \"name\" : \"Jack\", \"age\" : \"18\", \"gender\" : \"male\", \"grades\" : { \"Js\" : \"88\", \"Py\" : \"96\", \"Go\" : \"78\", } } MongoDB 安装 系统准备 本次我们采用的系统是 Centos7.3，在安装 MongoDB 之前需要在系统上执行一些操作。 1）关闭防火墙： $ systemctl stop firewalld $ systemctl disable firewalld 2）关闭 SElinux： $ setenforce 0 $ vim /etc/selinux/config SELINUX=disabled $ source /etc/selinux/config 3）关闭大页内存机制，以提高 MongoDB 的性能： $ vim /etc/rc.local # 最后添加 if test -f /sys/kernel/mm/transparent_hugepage/enabled; then echo never > /sys/kernel/mm/transparent_hugepage/enabled fi if test -f /sys/kernel/mm/transparent_hugepage/defrag; then echo never > /sys/kernel/mm/transparent_hugepage/defrag fi echo never > /sys/kernel/mm/transparent_hugepage/enabled echo never > /sys/kernel/mm/transparent_hugepage/defrag $ source /etc/rc.local 目录配置 接下来需要创建 3 个目录来存放 MongoDB 服务的不同数据，由于我们准备使用 4.4 的 MongoDB，所以这里目录命名为 mongodb44： $ mkdir -p /db/mongodb44/27017/{conf,logs,data} 软件下载 点我跳转 至下载页，选择社区版服务器后进行下载，在这里我们选择免编译版本的 tgz 包： copy link 后使用 wget 命令进行下载： $ cd ~ $ wget https://fastdl.mongodb.org/linux/mongodb-linux-x86_64-rhel70-4.4.10.tgz 软件安装 在下载完成后，执行解压命令，解压至当前路径下，并将 bin 目录拷贝走： $ tar -xvf ./mongodb-linux-x86_64-rhel70-4.4.10.tgz $ cp -a ./mongodb-linux-x86_64-rhel70-4.4.10/bin/ /db/mongodb44/27017/ $ mv ./mongodb-linux-x86_64-rhel70-4.4.10.tgz /tmp 用户授权 创建管理和使用 MongoDB 的用户： $ groupadd mongod $ useradd -g mongod mongod 对目录进行授权： $ chown -R mongod:mongod /db/mongodb44/ 配置文件 MongoDB 的配置文件会比较复杂，使用以下配置文件进行简单的配置： $ vim /db/mongodb44/27017/conf/mongod.conf systemLog: destination: file path: \"/db/mongodb44/27017/logs/mongod.log\" logAppend: true storage: dbPath: \"/db/mongodb44/27017/data\" journal: enabled: true processManagement: fork: true net: bindIp: 0.0.0.0 port: 27017 setParameter: enableLocalhostAuthBypass: false 环境变量 将 MongoDB 存放至环境变量中： $ vim /etc/profile export PATH=/db/mongodb44/27017/bin:$PATH $ source /etc/profile 尝试启动 MongoDB 服务： $ mongod -f /db/mongodb44/27017/conf/mongod.conf # 也可以使用--config 来指定配置文件 登录 MongoDB： $ mongo > exit 关闭 MongoDB 服务： $ mongod -f /db/mongodb44/27017/conf/mongod.conf --shutdown sys 服务 使用 sys 服务管理 MongoDB，执行如下操作： $ cat > /etc/systemd/system/mongod.service 重新进行一次授权操作： $ chown -R mongod:mongod /db/mongodb44/ 设置和关闭 MongoDB 服务开机启动（可选）： $ systemctl enable mongod.service $ systemctl disable mongod.service 下面就可以通过 sys 服务来启动和管理 MongoDB 服务了： $ systemctl start mongod.service $ systemctl stop mongod.service $ systemctl restart mongod.service $ systemctl status mongod.service 相关工具 MongoDB Compass MongoDB-Compass 是一款 MongoDB 官方开发的工具，它能够让你更好的使用和学习 MongoDB。 点我跳转 下载完成后，打开链接即可： 然后你就可以看见整个 MongoDB 实例中的所有数据库与集合，甚至还可以在 MongoDB-Compass 中使用 shell： MongoDB for VSCode vscode 是当前最火热的代码编辑器，所以 MongoDB 也针对 vscode 开发了一款插件。 点我跳转 具体使用方法可参照文档说明，这里不再进行例举。 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:48 "},"数据库专栏/MongoDB/简单概念.html":{"url":"数据库专栏/MongoDB/简单概念.html","title":"简单概念","keywords":"","body":"进入 MongoDB 启动服务 MongoDB 服务的原生启动脚本是 bin 目录下的 mongod 文件： /db/mongodb44/27017/bin/mongod 在启动服务时我们可以为它指定一个配置文件： $ mongod --config /db/mongodb44/27017/conf/mongod.conf 其他更多的启动参数可以在帮助文档中获得信息： $ mongob --help 更推荐使用 systemctl 管理 MongoDB 服务： $ systemctl start mongod.service shell MongoDB 是一款 C/S 架构软件，所以在 MongoDB 的 bin 目录下有一个自带的 MongoDB Client shell： /db/mongodb44/27017/bin/mongo 使用 mongo 启动 shell，进入 MongoDB 交互环境： $ mongo MongoDB shell 其本身是一个 JavaScript 解释器，这意味你可以在这里面运行任何 JavaScript 程序与使用任何 JavaScript 标准库，如下所示： > Math.sin(Math.PI / 2) 1 > new Date(\"2016/1/1\") ISODate(\"2016-01-01T08:00:00Z\") > function func(n){ ... if(n 10\"; ... } > func(11) n > 10 MongoDB shell 的真正威力在于它是一个 MongoDB 的 Client 端，当开启 MongoDB shell 后，它会自动链接到 MongoDB 服务器的 test 数据库下，我们可以在 MongoDB shell 中使用其所提供的 MongoDB 命令，如显示当前所在库： > db test 获取帮助 在 MongoDB shell 中，你可以通过 help 命令来查看帮助文档，这将打印所有的 MongoDB 可用命令： > help db.help() help on db methods db.mycoll.help() help on collection methods sh.help() sharding helpers ... 在库层面下获取帮助，可以使用 db.help() 命令： > db.help() DB methods: db.adminCommand(nameOrDocument) - switches to 'admin' db, and runs command [just calls db.runCommand(...)] db.aggregate([pipeline], {options}) - performs a collectionless aggregation on this database; returns a cursor ... 在集合层面下获取帮助，可以使用 db.coll.help() 命令（其实可以使用任何一个名字，如 db.any.help()）: > db.any.help() DBCollection help db.any.find().help() - show DBCursor help db.any.bulkWrite( operations, ) - bulk execute write operations, optional parameters are: w, wtimeout, j ... 获取集群层面下的帮助，可以使用 rs.help()，获取分片层面下的帮助，可以使用 sh.help() 命令，其实这些都可以通过 help 命令查看到。 再举 3 个非常常用的命令，如下所示： - cls ： 清屏 - exit ： 退出 shell - version ： 查看版本 另外，如果你忘记一个命令的全拼时，可以按下 tab 键进行自动补全，如果对一个函数不加括号直接进行使用，可以查看到它的源码，如： > db.version function() { return this.serverBuildInfo().version; } 库的概念 库的介绍 一个 MongoDB 实例可以承载多个数据库，每个库都有独立的控制权限，在磁盘上每个库都会存放到不同的文件中。 如果想在同一个 MongoDB 实例上存放多个应用或者用户数据，就需要使用不同的库。 命名规则 MongoDB 的库名应当是由 utf8 字符所构成的字符串，满足以下一些限制条件，即可成功创建出一个库： 库名不能是空字符 库名不得含有 (空格)、.(点)、$(美元符)、/(正斜杠)、(反斜杠) 和\\0(空字符) 库名应当全部小写 库名最多 64 字节（utf8，一中文最多 3 字节，一英文一个字节） 内置库 MongoDB 有 3 个内置库，在创建新库时注意不要与他们重名： admin：从权限角度来看，这是一个 root 数据库，如果将一个用户添加至该数据库中，该用户可视为管理员 local：这个库的数据永远不会被复制，可以用来存储仅限于本地单台服务器的任意集合，主从复制不会被作用于该库之上 config：这个库在 Mongo 用于分片设置时才会使用，用于保存分片的相关信息 集合概念 集合介绍 集合类似于 RDBMS 数据库中的表，在一个 MongoDB 库中可以有多个集合。 不同于 RDBMS 数据库中的表，MongoDB 中的集合是没有任何限制的，这种状态被称之为无模式（无字段、无约束），例如下面 2 个文档（类似于记录的概念）都可以存放到同一个集合中： {\"name\" : \"Jack\"} {\"foo\" : 5} 我们可以看见，上面 2 个文档不光 key 不同，甚至就连 type 也不同，一个是 string、一个是 int。 既然集合中可以放置任意文档，那么还有必要使用多个集合吗？ 答案是非常有必要的，使用多集合的理由如下： 方便管理、方便查询 如果集合的数据格式不统一，查询速度会大大增加 将集合进行合理归类，大幅度减少磁盘寻道时间 创建索引时，文档会有附加的结构，将同种类型文档放入一个集合中，可以让索引更有效 命名规则 MongoDB 的集合名称应当是由 utf8 字符所构成的字符串，满足以下一些限制条件，即可成功创建出一个集合： 集合名不能是空字符串 集合名不能含有\\0 字符，这个字符会用来表明集合名字的结尾 集合名不能以 system. 开头，这是系统集合保留的前缀，如 system.users 这个集合保存数据库用户信息 集合名不能含有保留字符 $ 命名空间 将数据库名字放在集合前，会组成集合的完全限定名，称之为命名空间。 如，在 cms 数据库中使用 blog.posts 集合，该集合的命名空间为 cms.blog.posts。 命名空间长度不得超过 121 字节，实际使用中应当少于 100 字节。 文档概念 文档介绍 文档是 MongoDB 的核心概念，多个键及其关联的值有序地进行放置在一起就是一个文档。 每种编程语言对文档的表示方法都不一样，如在 JavaScript 中，它被表示为对象，而在 Python 中则被表示为字典，在 Golang 中被表示为 map，但是按照宏观角度来说，我们可以简单的将文档理解为 JSON（不尽然，MongoDB 文档比 JSON 要强大一些）： {\"name\" : \"Jack\", \"age\" : 18} 键与值 文档在定义时，有一些注意事项，如下所示： 1）我们在构建一个文档时，应当考虑前一个文档的键排列顺序，并且最好将它做到有序，如下这两个文档的键排列就是无序的： {\"name\" : \"Jack\", \"age\" : 18} {\"age\" : 18, \"name\" : \"Jack\"} 2）文档中的值，不仅仅可以是字符串，也可以是其他数据类型（甚至是一个嵌入的新文档）： { \"name\" : \"Jack\", \"hobby\" : [ \"games\", \"music\" ], \"grades\" : { \"MongoDB\" : 80, \"MySQL\" : 73, \"ElastSearch\" : 62 } } 键的命名 MongoDB 的文档名称应当是由 utf8 字符所构成的字符串，满足以下一些限制条件，即可成功创建出一页文档： 键名不能含有\\0 字符，这个字符会用来表明键名的结尾 . 和 $ 具有特别的含义，只有在特定环境中才可允许使用，不要轻易使用它们 以下划线 _ 开头的键是被保留的，虽然这是一个不太严格的要求 MongoDB 中不单区分类型，还区分大小写，如下，这两个文档是不同的： {\"name\" : \"Jack\"} {\"Name\" : \"Jack\"} 还有一个非常重要的事项需要注意，MongoDB 中文档不能含有重复的键，如下所示，这个文档是非法的： {\"name\" : \"Jack\", \"name\" : \"Tom\"} PRIMARY KEY MongoDB 对于每一个文档，都有一个名为_id 的主键。 如果你没有在插入文档时指定该主键，则会自动生成一个 12 字节的 objectId 对象，MongoDB 中关于主键的性质与 MySQL 中相同，都是非空且唯一的。 为何 MongoDB 中主键不用自动增长的数字，而是采用 objectId() 进行生成呢？ 这是由于 MongoDB 的适用场景与 MySQL 有些许不同，MongoDB 更适合做分布式数据库系统，这意味着主键必须不光在一台机器上唯一，而且要在多台机器上唯一，这样来看的话，使用自增长的_id 则在同步时显得更加费时又费力。 objectId 的组成有以下几个部分： 释义如下： 前 4 字节为 Unix 纪元开始的时间戳，单位为秒 接下来的 3 字节为所在主机唯一标识符，由机器主机名散列值生成，可以确保不同主机生成的 objectId 不同 进程标识符（2 字节）用来确保同一机器上多个进程产生的 objectId 是唯一的 计数器标识符（后 3 字节）是一个自增的计数器，用来确保相同进程同一秒中生成的 objectId 也不一样，同一秒钟最多允许每个进程产生 256**3=16777216 个不同的 objectId 时间戳在前有一个好处，在下一个文档 _id 生成时会按照顺序进行排列插入，将其作为索引能提高查询效率。 除此之外，时间戳还隐含了该文档的创建时间，绝大多数驱动都会公开一个方法从 objectId 中获取这一信息。 时间戳与后 5 个字节（机器、进程号）组合起来，能提供秒级别的唯一性，而再加上后 3 个字节（计数器）就可以提供毫秒级别的唯一性了。 数据类型 类型一览 对于 MongoDB 这种数据库来说，其文档如果仅仅是 JSON 类型还是不够强大，因为 JSON 仅仅只能表明 null，布尔，数字，字符串，数组和对象几种类型。 或许对于普通的应用程序来说或许它的表现力已经足够，但 JSON 没有日期类型这会使处理本来简单的日期问题变得十分繁琐。 此外 JSON 只有一种数字类型而没办法区分浮点数和整数，更不能区分 32 位数字和 64 位数字，这对一款数据库来说功能上其实显得有点捉襟见肘，所以 MongoDB 的文档采用了 BSON 类型来存储数据。 我们可以将 BSON 理解为 JSON 的超集，JSON 和 BSON 在设计上确实是近亲。BSON 被设计为 JSON 数据的二进制表示，具有适用于更广泛应用的特定扩展，并针对数据存储和检索进行了优化。 JSON BSON 存储 UTF-8 字符串 二进制 数据支持 字符串、布尔值、数字、数组 字符串、布尔值、数字（整数、浮点数、长整数、Decimal128...）、数组、日期、原始二进制 可读性 人和机器 仅机器 下面是 BSON 文档所能表示的数据类型： 32-bit integer：32 位 int 64-bit integer：64 位 int double：双精度浮点型 binary data：二进制数据 string：字符串类型 array：数组类型 object：对象类型 objectId：object_id 主键 boolean：布尔类型 date：日期类型 null：空类型 regex：正则类型 JavaScript：简单的 JavaScript 代码（不能带作用于） timestamp：时间戳类型 Decimal128：字符数值类型 min：可能的最小值 max：可能的最大值 日期 在 shell 中调用日期时，应当调用 new Date() 而不是调用 Date()。 直接调用 Date() 和调用 new Date() 其实是有一些差别的，Date() 是 MongoDB 提供的，而 new Date() 是 JavaScript 提供的： > Date() Wed Mar 10 2021 12:49:19 GMT+0800 (CST) > new Date() ISODate(\"2021-03-10T04:49:26.675Z\") 如果不是调用 new Date() 而是调用 Date()，则可能导致与字符串匹配出现问题，具体可参照 MongoDB 权威指南。 数组 MongoDB 中的数组同 JavaScript 中一样，允许任意类型。 如一个嵌套的二维数组，一个文档，一个字符串，一个数字…. MongoDB 对于数组可以进行深入理解，你可以在数组中进行增删改查等操作，当然也能够去建立索引。 内嵌文档 MongoDB 中的整个文档可以作为另一个集合下文档中键的值。 同数组一样，MongoDB 也能对内嵌文档进行深入理解，你可以在内嵌文档中进行增删改查等操作，当然也能够去建立索引。 需要注意的是，过分的滥用内嵌文档，可能会导致一些意外的情况发生，如查询性能降低等。 比如，我在很多个文档中都内嵌了 class 文档： { \"name\" : \"Jack\", \"gender\" : \"male\", \"class\" : { \"id\" : 1 \"name\" : \" 三年级一班 \", } } 现在，这个 class 内嵌文档对于三年级一班来说要将 id 改为 101，则意味着我们需要修改的内嵌文档数据量与外层文档的数量有着直接的关系，而在关系型数据库中，这两个表通常都是拆分开的，你只需要修改 class 中三年级一班的 id 即可，显然在 MongoDB 中如果要进行内嵌文档的使用，还是要经过深思熟虑的。 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:48 "},"数据库专栏/MongoDB/库与集合.html":{"url":"数据库专栏/MongoDB/库与集合.html","title":"库与集合","keywords":"","body":"库的命令 查看库 以下是查看库相关的命令： 命令 简写 描述 show databases show dbs 查看所有库（库中必须有集合才能被看到） db.getName() db 查看当前所在库 db.stats() ... 查看当前库状态 db.getMongo() ... 查看当前所在库链接地址 使用 show databases 来获取当前 MongoDB 中所有的数据库，这一条命令可以简写为 show dbs，如下所示： > show dbs admin 0.000GB config 0.000GB local 0.000GB 使用 db.getName()，可获取目前所在的数据库名称，这一条命令可简写为 db，在 MongoDB 中，登录时默认会进入一个名为 test 的数据库，该库下没有任何文档。 如下所示： > db test 使用 db.stats()，可获取当前所在数据库的一些状态，如下所示： > db.stats() { \"db\" : \"test\", \"collections\" : 3, \"views\" : 0, \"objects\" : 7, \"avgObjSize\" : 142.57142857142858, \"dataSize\" : 998, \"storageSize\" : 94208, \"numExtents\" : 0, \"indexes\" : 3, \"indexSize\" : 61440, \"scaleFactor\" : 1, \"fsUsedSize\" : 4921679872, \"fsTotalSize\" : 8575254528, \"ok\" : 1 } 使用 db.getMongo()，可查看当前所在库的链接地址，如下所示： > db.getMongo() connection to 127.0.0.1:27017 创建库 下面是创建库相关的命令： 命令 描述 use 库名 进入或创建某个数据库 MongoDB 中创建和进入某个数据库的命令都是 use，但情况有 2 种： 已经有这个数据库，use 就是进入该数据库 没有这个数据库，use 就是进入并创建该数据库 情况 1 命令演示如下： > use admin switched to db admin > db admin 情况 2 命令演示如下： > use db1 switched to db db1 > db db1 > show dbs admin 0.000GB config 0.000GB local 0.000GB 上面的这个示例中，我们仅创建并进入了 db1 库，但是由于 db1 库下没有集合，所以 show dbs 显示不出该库，这是正常现象。 删除库 下面是删除库相关的命令： 命令 描述 db.dropDatabase() 必须 use 进将要被删除的库后才能执行该方法，删除数据库 MongoDB 中删除库有两种情况： 当前所在库中没有集合，切换至别的数据库当前库自动删除 当前所在库中已有集合，使用 db.dropDatabase() 方法来删除该库与其下所有的集合 目前我们在 db1 这个空库中，尝试进入 admin 库后再看 db1 库是否被删除： > use db1 switched to db db1 > db db1 > use admin switched to db admin > show dbs admin 0.000GB config 0.000GB local 0.000GB 现在我们重新创建并进入 db1 库，并朝其中创建一个文档后再进入 admin 库，然后查看 db1 库是否被删除： > use db1 switched to db db1 > db.createCollection(\"coll\") { \"ok\" : 1 } > use admin switched to db admin > show dbs admin 0.000GB config 0.000GB db1 0.000GB local 0.000GB 当 db1 库有文档后，切换不会删除该库，此时若你执意要删除，可以通过 db.dropDatabase() 对其进行删除删除： > use db1 switched to db db1 > db.dropDatabase() { \"dropped\" : \"db1\", \"ok\" : 1 } > db db1 > show dbs admin 0.000GB config 0.000GB local 0.000GB 需要注意，db.dropDatabase() 方法必须在你进入该库之后方可执行，不能使用传参的方式进行删除，如：db.dropDatabase(“db1”)，这种方式是错误的。 集合命令 查看集合 下面是查看集合相关的命令： 命令 描述 show collections 查看当前库下所有集合 show tables 同上 db.getCollectionNames() 同上 这个没什么好说的，进入某个库后查看该库下的所有集合： > use config switched to db config > show tables system.sessions > db.getCollectionNames() [ \"system.sessions\" ] 唯一值得一提的是对于 db.getCollectionNames() 这个方法来说，无论你是否填入参数，它返回的还是当前库下的集合。 如下所示，在 config 库中调用该方法看到的始终是 config 库下的集合： > db config > db.getCollectionNames() [ \"system.sessions\" ] > db.getCollectionNames(\"admin\") [ \"system.sessions\" ] > db.getCollectionNames(\"db1\") [ \"system.sessions\" ] 创建集合 下面是创建集合相关的命令： 命令 描述 db.createCollection(“集合名”) 在当前库下创建一个集合，若已有该集合，则也会提示创建成功 MongoDB 中创建集合可以有两种方式： 直接对一个文档进行插入操作，可顺带的隐式创建集合 使用 db.createCollection() 方法来创建一个集合 方式 1，想象我有一个集合（实际没有），直接对其插入文档： > use db1 switched to db db1 > db.coll.insert({name : \"Jack\"}) WriteResult({ \"nInserted\" : 1 }) > show tables coll 方式 2，使用 db.createCollection() 方法创建集合： > db.createCollection(\"collection\") { \"ok\" : 1 } > show tables coll collection 删除集合 下面是删除集合相关的命令： 命令 描述 db.集合名.drop() 删除当前库下的某一个集合 这个命令没啥好说的，直接上示例： > db.collection.drop() true > show tables coll 重命名 下面是集合重命名相关的命令： 命令 描述 db.集合名.renameCollection(“新名”) 为该库下的某个集合重命名 这个命令没啥好说的，直接上示例： > db.coll.renameCollection(\"newColl\") { \"ok\" : 1 } > show tables newColl Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:48 "},"数据库专栏/MongoDB/文档操作.html":{"url":"数据库专栏/MongoDB/文档操作.html","title":"文档操作","keywords":"","body":"插入文档 基础方法 下面是向集合插入文档的基础命令： 命令 描述 db.集合名.insert(doc) 向集合中插入一个文档，若主键存在，则抛出异常 插入的基础方法为 insert()，支持最大一次性插入 4MB（新版好像是 16MB 了）的文档，该操作会给文档增加一个名为 _id 的键（未手动指定的情况下），其类型为 objectId 对象。 示例演示如下： > db.collection.insert({\"name\" : \"jack\"}) WriteResult({ \"nInserted\" : 1 }) 为了方便查看结果，再介绍一个查看命令，如下所示： > db.collection.find().pretty() { \"_id\" : ObjectId(\"60486be289d49aa11b240ad8\"), \"name\" : \"jack\" } 扩展方法 在 MongoDB3.2 之后，对插入文档提供了两个新方法： 命令 描述 db.集合名.insertOne(doc) 向集合中插入一个新文档，返回 _id db.集合名.insertMany([doc, doc]) 向集合中插入一个或多个文档，返回 _ids 参数说明如下： document：要写入的文档 writeConcern：写入策略，默认为 1，即立即写入磁盘，如果为 0 则是不要求 ordered：仅针对批量写入，是否按照指定顺序写入，默认为 true 示例演示如下： > db.collection.insertOne({\"name\" : \"Tom\"}) { \"acknowledged\" : true, \"insertedId\" : ObjectId(\"60486ea089d49aa11b240ad9\") } > db.collection.insertMany([{\"name\" : \"Ken\"}, {\"name\" : \"Mary\"}]) { \"acknowledged\" : true, \"insertedIds\" : [ ObjectId(\"60486f0789d49aa11b240ada\"), ObjectId(\"60486f0789d49aa11b240adb\") ] } 批量优势 如果要插入多个文档，使用批量插入会更快一些。 这是由于批量插入只传递一个由文档构成的数组给数据库，一次批量插入仅发送一次 TCP 请求。 这可以有效避免许多零碎的请求所带来的开销，无需处理大量的消息头，能够减少插入时间。 当使用单次插入进行循环时，每一次的 TCP 请求都会有一个 TCP 头部信息，而批量插入由于只发送一次 TCP 请求，所以服务端解析 TCP 信息的次数与时间就会大幅度的减少。 作用原理 当执行插入操作时，使用的驱动程序会将数据转换为 BSON 形式，然后将其传送给数据库。 数据库解析 BSON，检验是否有_id 键且文档大小不超过 4MB（新版扩容了）。 当解析完成后，不会做其他额外的操作而是将文档直接存储在数据库中。 这样的操作有好有坏，最明显的副作用就是允许插入无效的数据，而从好处看，它能让数据更加安全，远离注入式攻击。 如果在使用主流语言的驱动传输数据进行解析前，可对被传送数据做一些有效的检查，如文档是否超长，是否包含非 utf8 字符，或者使用了位置类型，要是对使用的驱动不熟悉，则可以在启动数据库服务器时使用--objectcheck 选项，这样服务器就会在文档插入之前检查结构的有效性（当然要牺牲些许性能）。 MongoDB 在做插入数据时，并不会执行任何代码，所以对于这块没有注入攻击的可能性，传统的注入式攻击对 MongoDB 来说是无效的。 附：想查看一个文档的大小，可以在 shell 中使用以下函数（以字节为单位）： > Object.bsonsize({\"name\" : \"Jack\"}) 20 删除文档 基础方法 下面是对集合删除文档的基础命令： 命令 描述 db.集合名.remove(query) 删除集合中符合条件的文档 参数说明如下： query：删除文档的条件 justOne：（可选）如果设置为 true 或者 1，则只删除一个文档，否则删除所有匹配到的文档，参数默认为 false writeConcern：（可选）抛出异常的级别 其实这个命令在于早期的 MongoDB 中是非常常用的，但是现在，官方更推荐使用下面的扩展方法。 故在此不对该方法进行演示。 不论是这个基础方法还是下面所介绍的扩展方法，对数据的删除操作都是永久性的，即不能撤销，也不能恢复。 扩展方法 在新版 MongoDB 中，更推荐使用下面两个扩展方法来进行删除文档的操作： 命令 描述 db.集合名.deleteOne(query) 删除集合中的第一个符合条件的文档 db.集合名.deleteMany(query) 删除集合中所有的符合条件的文档 对于 deleteOne() 方法来说，相当于 remove() 方法中的 justOne 参数设置为 true 对于 deleteMany() 方法来说，相当于 remove() 方法中的 justOne 参数设置为 false 示例演示如下，首先，我们先在 collection 中插入 3 个一样的文档（实际上 objectId 不一样）： > db.collection.drop() true > db.collection.insertMany([{\"name\" : \"Jack\"}, {\"name\" : \"Jack\"}, {\"name\" : \"Jack\"}]) { \"acknowledged\" : true, \"insertedIds\" : [ ObjectId(\"60487a1089d49aa11b240adc\"), ObjectId(\"60487a1089d49aa11b240add\"), ObjectId(\"60487a1089d49aa11b240ade\") ] } 使用 deleteOne() 方法来删除主键后缀值为 abc 的文档： > db.collection.deleteOne({\"name\" : \"Jack\"}) { \"acknowledged\" : true, \"deletedCount\" : 1 } > db.collection.find().pretty() { \"_id\" : ObjectId(\"60487a1089d49aa11b240add\"), \"name\" : \"Jack\" } { \"_id\" : ObjectId(\"60487a1089d49aa11b240ade\"), \"name\" : \"Jack\" } 使用 deleteMany() 方法来删除剩余的两个文档： > db.collection.deleteMany({\"name\" : \"Jack\"}) { \"acknowledged\" : true, \"deletedCount\" : 2 } > db.collection.find().pretty() 删除速度 如果只删除一个集合下的所有的文档，可能花费的时间比较长。 而直接删除一个集合，所花费的时间就会非常的短。 同时，仅删除文档，该集合可能还存在一些索引信息，而直接删除一个集合，所有关于该集合以及其下文档的信息都会被删除，包括索引。 更新文档 基础方法 下面是对集合更新文档的基础命令： 命令 描述 db.集合名.update(query, update) 对一个集合中筛选的第一个文档做替换（加了修改器 $set 是更新） db.集合名.save(doc) 集合中有该文档则更新，没有则创建，需要使用主键进行筛选 比较常用的还是 update()，关于它的参数说明如下： query：更新的查询条件 update：选定替换或更新的对象和添加的修改器 upsert：（可选）如果为 true，则与 save() 方法效果相同，默认为 false multi：（可选）如果为 true，则替换所有符合条件的文档，默认为 false writeConcern：（可选）抛出异常的级别 下面对 update() 方法做示例演示，插入 3 个一样的文档，使用 update() 方法对主键值后缀为 856 的文档进行替换： > db.collection.drop() true > db.collection.insertMany([{\"name\" : \"Jack\"}, {\"name\" : \"Jack\"}, {\"name\" : \"Jack\"}]) { \"acknowledged\" : true, \"insertedIds\" : [ ObjectId(\"604887e70b6bcfe9e15b9856\"), ObjectId(\"604887e70b6bcfe9e15b9857\"), ObjectId(\"604887e70b6bcfe9e15b9858\") ] } > db.collection.update({\"name\" : \"Jack\"}, {\"age\" : \"18\"}) WriteResult({ \"nMatched\" : 1, \"nUpserted\" : 0, \"nModified\" : 1 }) > db.collection.find().pretty() { \"_id\" : ObjectId(\"604887e70b6bcfe9e15b9856\"), \"age\" : \"18\" } // 直接替换了整个文档 { \"_id\" : ObjectId(\"604887e70b6bcfe9e15b9857\"), \"name\" : \"Jack\" } { \"_id\" : ObjectId(\"604887e70b6bcfe9e15b9858\"), \"name\" : \"Jack\" } 扩展方法 在新版 MongoDB 中，更推荐使用下面两个扩展方法来进行更新文档的操作： 命令 描述 db.集合名.updateOne(query, update) 对一个集合中筛选的第一个旧文档做更新，需要修改器 $set db.集合名.updateMany(query, update) 对一个结合中筛选的所有符合条件文档做更新，需要添加修改器 $set 对于 updateMany() 方法来说，相当于 update() 方法中的 multi 参数设置为 true。 而对于 updateOne() 方法来说，则与上面的 updateMany() 刚好相反。 示例演示如下，首先，我们先在 collection 中插入 3 个一样的文档（实际上 objectId 不一样）： > db.collection.drop() true > db.collection.insertMany([{\"name\" : \"Jack\"}, {\"name\" : \"Jack\"}, {\"name\" : \"Jack\"}]) { \"acknowledged\" : true, \"insertedIds\" : [ ObjectId(\"604889630b6bcfe9e15b9859\"), ObjectId(\"604889630b6bcfe9e15b985a\"), ObjectId(\"604889630b6bcfe9e15b985b\") ] } 使用 updateOne() 方法更新，仅更新第一条主键值后缀为 859 的文档： > db.collection.updateOne({\"name\" : \"Jack\"}, {$set:{\"name\" : \"NewJack\"}}) // 加了 $set 是更新 { \"acknowledged\" : true, \"matchedCount\" : 1, \"modifiedCount\" : 1 } > db.collection.find().pretty() { \"_id\" : ObjectId(\"604889630b6bcfe9e15b9859\"), \"name\" : \"NewJack\" } { \"_id\" : ObjectId(\"604889630b6bcfe9e15b985a\"), \"name\" : \"Jack\" } { \"_id\" : ObjectId(\"604889630b6bcfe9e15b985b\"), \"name\" : \"Jack\" } 现在，使用 updateMany() 方法来更新剩余的两个文档： > db.collection.updateMany({\"name\" : \"Jack\"}, {$set:{\"name\" : \"NewJack\"}}) // 加了 $set 是更新 { \"acknowledged\" : true, \"matchedCount\" : 2, \"modifiedCount\" : 2 } > db.collection.find().pretty() { \"_id\" : ObjectId(\"604889630b6bcfe9e15b9859\"), \"name\" : \"NewJack\" } { \"_id\" : ObjectId(\"604889630b6bcfe9e15b985a\"), \"name\" : \"NewJack\" } { \"_id\" : ObjectId(\"604889630b6bcfe9e15b985b\"), \"name\" : \"NewJack\" } 有关于 $ 修改器，会在下面介绍到。这里使用的 $set 代表仅更新文档中的某个键的值，而非替换整个文档。 $set & $unset 使用 $set 修改器来指定更新某一个键的值，而不是替换全文档，如果这个键不存在，则会进行创建。 使用 $unset 修改器来指定删除某一组键值对。 这两个修改器的语法格式如下： 修改器 语法格式 $set {$set : { k : v }} $unset {$unset : { k : 1 }} 示例如下，先是使用 $set 修改器修改 age 的值，然后使用 $unset 删除 age 这个键值对： > db.collection.drop() true > db.collection.insertOne({\"name\" : \"Jack\", \"age\" : 18}) { \"acknowledged\" : true, \"insertedId\" : ObjectId(\"60488d600b6bcfe9e15b985c\") } > db.collection.updateOne({\"_id\" : ObjectId(\"60488d600b6bcfe9e15b985c\")}, {$set : {\"age\" : 20}}) { \"acknowledged\" : true, \"matchedCount\" : 1, \"modifiedCount\" : 1 } > db.collection.find().pretty() { \"_id\" : ObjectId(\"60488d600b6bcfe9e15b985c\"), \"name\" : \"Jack\", \"age\" : 20 } > db.collection.updateOne({\"_id\" : ObjectId(\"60488d600b6bcfe9e15b985c\")}, {$unset : {\"age\" : 1}}) { \"acknowledged\" : true, \"matchedCount\" : 1, \"modifiedCount\" : 1 } > db.collection.find().pretty() { \"_id\" : ObjectId(\"60488d600b6bcfe9e15b985c\"), \"name\" : \"Jack\" } $inc 使用 $inc 修改器来对某一键的值进行自加或自减，如果这个键不存在，则会进行创建。 需要注意的是 $inc 仅能针对整数、长整数、双精度浮点数的 value 做更新。 修改器的语法格式如下： 修改器 语法格式 $inc {$inc : {k : +int || -int}} 示例如下，先将分数增加 10，再减 20： > db.collection.drop() true > db.collection.insertOne({\"name\" : \"Jack\", \"grades\": 90}) { \"acknowledged\" : true, \"insertedId\" : ObjectId(\"60488fab0b6bcfe9e15b985d\") } > db.collection.updateOne({\"_id\" : ObjectId(\"60488fab0b6bcfe9e15b985d\")}, {$inc : {\"grades\" : +10}}) { \"acknowledged\" : true, \"matchedCount\" : 1, \"modifiedCount\" : 1 } > db.collection.find().pretty() { \"_id\" : ObjectId(\"60488fab0b6bcfe9e15b985d\"), \"name\" : \"Jack\", \"grades\" : 100 } > db.collection.updateOne({\"_id\" : ObjectId(\"60488fab0b6bcfe9e15b985d\")}, {$inc : {\"grades\" : -20}}) { \"acknowledged\" : true, \"matchedCount\" : 1, \"modifiedCount\" : 1 } > db.collection.find().pretty() { \"_id\" : ObjectId(\"60488fab0b6bcfe9e15b985d\"), \"name\" : \"Jack\", \"grades\" : 80 } 普通修改器 普通修改器仅针对 key 为普通的 value（非内嵌文档，数组）所使用，以下是常用的普通修改器的大全： 修改器 语法格式 描述 $set {$set : { k : v}} 指定更新某一个键的值，而不是替换全文档，如果这个键不存在，则会进行创建 $unset {$unset : { k : 1}} 指定删除某一个键值对 $inc {$inc : {k : +int || -int}} 对某一键的值进行自加或自减，如果这个键不存在，则会进行创建 $mul {$mul : {k : int}} 对某一键的值进行乘法操作 $rename {$rename : {okn : nkn}} 对某一键进行重命名操作，okn->old key name，nkn-> new key name $min {$min : {k : v}} 如果原 key 中的 value 大于指定的 value 则更新 $max {$max : {k : v}} 如果原 key 中的 value 小于指定的 value 则更新 $currentDate {$currentDate : {k : v}} 指定更新某一 key 的 value 为当前时间 想要了解更多的普通修改器，请参照官方文档。 示例如下： # 插入一个文档 > db.item.insert({\"_id\" : 1, \"num\" : 10, time : \"2020-01-02 12:00:00\"}) WriteResult({ \"nInserted\" : 1 }) # $inc，对 num 字段自加 1 > db.item.update({\"_id\" : 1}, {$inc : {\"num\" : +1}}) { \"_id\" : 1, \"num\" : 11, \"time\" : \"2020-01-02 12:00:00\" } # $mul, 对 num 字段乘以 2 > db.item.update({\"_id\" : 1}, {$mul : {\"num\" : 2}}) { \"_id\" : 1, \"num\" : 22, \"time\" : \"2020-01-02 12:00:00\" } # $set, 只更新 num 字段， 如果不指定 $set, 则整个文档都会替换为{\"num\":1} > db.item.update({\"_id\" : 1}, {$set : {\"num\" : 1}}) { \"_id\" : 1, \"num\" : 1, \"time\" : \"2020-01-02 12:00:00\" } # $unset，删除 num 字段 > db.item.update({\"_id\" : 1}, {$unset : {\"num\" : 1}}) { \"_id\" : 1, \"time\" : \"2020-01-02 12:00:00\" } # $set，添加 num 字段 > db.item.update({\"_id\" : 1}, {$set : {\"num\" : 1}}) { \"_id\" : 1, \"time\" : \"2020-01-02 12:00:00\", \"num\" : 1 } # $min，更新 num 字段，如果原字段值大于 0 则更新为 0，否则不操作 > db.item.update({\"_id\" : 1}, {$min : {\"num\" : 0}}) { \"_id\" : 1, \"time\" : \"2020-01-02 12:00:00\", \"num\" : 0 } # $max，更新 num 字段，如果原字段值小于 100 则更新为 100，否则不操作 > db.item.update({\"_id\" : 1}, {$max : {\"num\" : 100}}) { \"_id\" : 1, \"time\" : \"2020-01-02 12:00:00\", \"num\" : 100 } # $currentDate, 更新 time 字段为当前时间，时间戳形式 ,$type 为时间戳类型 > db.item.update({\"_id\" : 1}, {$currentDate : {\"time\" : {$type : \"timestamp\"}}}); { \"_id\" : 1, \"time\" : Timestamp(1615335076, 1), \"num\" : 100 } 数组修改器 数组修改器仅针对 key 为 array 的 value 所使用，以下是常用的数组修改器的大全： 修改器 语法格式 描述 $addToset {$addToset : {k : v}} 更新的 key 必须是数组类型，朝数组中添加元素，添加至最后 $push {$push : {k : v}} 若文档中数组不存在，则创建并插入元素，若存在则更新添加元素 $position {$position : int} 更新的 key 必须是数组类型，配合 $push 与 $each 使用，向指定位置的后面插入元素 $each {$each : [v1, v2]} 更新的 key 必须是数组类型，配合 $push 或 $addToSet 使用达到批量插入更新的作用 $pop {$pop:{k : 1 || -1}} 更新的 key 必须是数组类型，从数组移除 key 的第 1 个元素（-1），或者最后一个元素（1） $pull {$pullALL : {k : [v1 , v2]}} 更新的 key 必须是数组类型，删除数组中指定的所有元素 如果想了解更多命令，请参照官方文档。 示例如下： # 插入一个数组 > db.array.insert({\"_id\" : 1, v : [1, 2, 3, 4, 5]}); WriteResult({ \"nInsertead\" : 1 }) # $addToSet，向 v 中更新一个元素 6 > db.array.updateOne({\"_id\" : 1}, {$addToSet : {v : 6}}); { \"_id\" : 1, \"v\" : [ 1, 2, 3, 4, 5, 6 ] } # $push，向 v 中更新一个元素 7（已存在） > db.array.updateOne({\"_id\" : 1}, {$push : {v : 7}}); { \"_id\" : 1, \"v\" : [ 1, 2, 3, 4, 5, 6, 7 ] } # $each 与 $position，向 v 中指定位置插入 3 个元素 > db.array.updateOne({\"_id\" : 1}, {$push : {v : {$each : [8, 9, 10], $position : 3}}}); { \"_id\" : 1, \"v\" : [ 1, 2, 3, 8, 9, 10, 4, 5, 6, 7 ] } # $pullAll, 删除 v 中的指定元素 > db.array.updateOne({\"_id\" : 1}, {$pullAll : {v : [1, 2, 3]}}); { \"_id\" : 1, \"v\" : [ 8, 9, 10, 4, 5, 6, 7 ] } 内嵌文档 深度访问 使用 . 来访问内嵌文档，并对成绩进行修改： > db.collection.drop() true > db.collection.insertOne({\"name\" : \"Jack\", \"grades\" : {\"Js\" : 80, \"Py\" : 60}}) { \"acknowledged\" : true, \"insertedId\" : ObjectId(\"604896e70b6bcfe9e15b985e\") } > db.collection.updateOne({\"_id\" : ObjectId(\"604896e70b6bcfe9e15b985e\")}, {$set : {\"grades.Js\" : 100}}) { \"acknowledged\" : true, \"matchedCount\" : 1, \"modifiedCount\" : 1 } > db.collection.updateOne({\"_id\" : ObjectId(\"604896e70b6bcfe9e15b985e\")}, {$set : {\"grades.Py\" : 100}}) { \"acknowledged\" : true, \"matchedCount\" : 1, \"modifiedCount\" : 1 } > db.collection.find().pretty() { \"_id\" : ObjectId(\"604896e70b6bcfe9e15b985e\"), \"name\" : \"Jack\", \"grades\" : { \"Js\" : 100, \"Py\" : 100 } } 性能相关 本章节所探讨的 3 个操作（插入、删除、更新）都是瞬间完成的，不需要等待数据库响应。 当然这并不是异步操作，可以想象成客户端动作发出后就不管了，客户端永远不会受到服务端类似于 “好的，知道了” 或者 “有问题，能重新传送一遍吗” 这样的响应。 这种特点的优点很明显，速度快。但是对数据的安全性保障级别不足，如服务器崩溃了，网线被老鼠咬断了，数据中心被洪水淹没了。 在没有服务器的情况下，客户端还是会发送写操作到服务器的，完全不用理会服务器是否正常工作。 对于有些应用这是可以接受的，如果涉及到金融系统，则需要慎之又慎。 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:48 "},"数据库专栏/MongoDB/文档查询.html":{"url":"数据库专栏/MongoDB/文档查询.html","title":"文档查询","keywords":"","body":"数据准备 在学习文档查询前，先录入以下数据： > db.collection.drop() > db.collection.insertMany( [ { _id: 1, name: \"Jack\", gender: \"male\", age: 18, grades: { Js: 88, Py: 92, Go: 78 }, class: { name: \"三年级一班\", numPeople: 30, } }, { _id: 2, name: \"Tom\", gender: \"male\", age: 19, grades: { Js: 72, Py: 81, Go: 56, }, class: { name: \"三年级一班\", numPeople: 30, } }, { _id: 3, name: \"Ken\", gender: \"male\", age: 20, grades: { Js: 61, Py: 72, Go: 96, }, class: { name: \"三年级一班\", numPeople: 30, } }, { _id: 4, name: \"Keisha\", gender: \"female\", age: 17, grades: { Js: 31, Py: 42, Go: 26, }, class: { name: \"三年级二班\", numPeople: 21, } }, { _id: 5, name: \"Kelly\", gender: \"female\", age: 18, grades: { Js: 71, Py: 64, Go: 19, }, class: { name: \"三年级二班\", numPeople: 21, } } ] ) 基础查询 查询与格式化 下面是对集合查询文档的基础命令： 命令 描述 db.集合名.find(query) 查询符合条件的所有文档，如不指定查询条件则返回全部文档 db.集合名.findOne(query) 查询符合条件的所有文档，如不指定查询条件则返回一条文档 pretty() 对查询结果进行标准的 JSON 格式化显示 使用 find() 方法可以查出一个集合下所有的文档，或者指定条件查询特定的文档： > db.collection.find() > db.collection.find({\"name\" : \"Jack\"}) 使用 .pretty() 方法可以对查询结果进行标准的 JSON 格式化： > db.collection.find().pretty() 查询指定键 如果想查询指定的键，只获取某一字段与值，则可以对 find() 函数的第二参数进行填写，第二参数默认为{}，我们需要加上指定查询的键，并将其 value 写为 1。 示例如下： > db.collection.find({\"name\" : \"Jack\"}, {\"grades\" : 1}) { \"_id\" : 1, \"grades\" : { \"Js\" : 88, \"Py\" : 92, \"Go\" : 78 } } 如果想隐藏掉_id 字段，则可以通过第二参数中_id 对应 0 来隐藏： > db.collection.find({\"name\" : \"Jack\"}, {\"grades\" : 1, \"_id\" : 0}) { \"grades\" : { \"Js\" : 88, \"Py\" : 92, \"Go\" : 78 } } 大小与个数 下面是查询集合中文档个数与集合大小的命令： 命令 描述 db.集合名.count() 返回集合中文档个数 db.集合名.totalSize() 统计集合下所有文档的大小，规则为集合索引信息 + 数据压缩存储后的大小 示例演示如下： > db.collection.count() 5 > db.collection.totalSize() 40960 查询子文档 层级关系可以用 . 点符号来进行查询，如下示例，我想查询 Jack 同学的 Js 成绩： > db.collection.find({\"name\" : \"Jack\"}, {\"grades.Js\" : 1, \"_id\" : 0}) { \"grades\" : { \"Js\" : 88 } } 显示结果 limit() 方法可跟在查询之后，用于显示指定的条目： > db.collection.find().pretty().limit(2) skip() 方法可跟在 limit() 方法之后，用于指定显示第几条索引的数据，从 0 开始计数： > db.collection.find().pretty().limit(2).skip(1) # 显示第二条数据 sort() 方法可跟在查询或者显示结果的方法之后，指定特定字段对显示结果进行排序，1 为升序，-1 为降序： > db.collection.find({},{\"age\" : 1, \"_id\" : 0}).sort({\"age\" : 1}) 修改器查询 等值查询 MongoDB 中在 find() 或者 findOne() 里可指定的等值查询语法如下： 条件语法 描述 { k : v } 等值查询 { k : { $eq : v } } 同上，等值查询 示例，查询年龄是 18 的文档，拿名字以及年龄： > db.collection.find({\"age\" : 18}, {\"_id\" : 0, \"name\": 1, \"age\" : 1}) { \"name\" : \"Jack\", \"age\" : 18 } { \"name\" : \"Kelly\", \"age\" : 18 } > db.collection.find({\"age\" : {$eq : 18}}, {\"_id\" : 0, \"name\": 1, \"age\" : 1}) { \"name\" : \"Jack\", \"age\" : 18 } { \"name\" : \"Kelly\", \"age\" : 18 } 比较查询 MongoDB 中在 find() 或者 findOne() 里可指定的比较查询语法如下： 条件语法 描述 { k : { $lt : v } } 小于查询 { k : { $lte : v } } 小于或等于 { k : { $gt : v } } 大于查询 { k : { $gte : v } } 大于或等于 { k : { $ne : v } } 不等于 示例，查询年龄大于 19 岁的文档，拿名字以及年龄： > db.collection.find({\"age\" : {$gt : 19}}, {\"_id\" : 0, \"name\": 1, \"age\" : 1}) { \"name\" : \"Ken\", \"age\" : 20 } 示例，查询 Js 成绩小于 80 的文档，拿名字以及 Js 成绩： > db.collection.find({\"grades.Js\" : {$lt : 80}}, {\"_id\" : 0, \"name\": 1, \"grades.Js\" : 1}) { \"name\" : \"Tom\", \"grades\" : { \"Js\" : 72 } } { \"name\" : \"Ken\", \"grades\" : { \"Js\" : 61 } } { \"name\" : \"Keisha\", \"grades\" : { \"Js\" : 31 } } { \"name\" : \"Kelly\", \"grades\" : { \"Js\" : 71 } } 包含查询 MongoDB 中在 find() 或者 findOne() 里可指定的包含查询语法如下： 条件语法 描述 { k : { $in : [ v1, v2, … ] } } 包含查询，如果数组中 v 只有 1 个，则为等值查询 { k : { $nin : [ v1, v2, … ] } } 不包含查询 示例，查询年龄在 18,19,20 岁的文档，拿名字以及年龄： > db.collection.find({\"age\" : {$in : [18, 19, 20]}}, {\"_id\" : 0, \"name\": 1, \"age\" : 1}) { \"name\" : \"Jack\", \"age\" : 18 } { \"name\" : \"Tom\", \"age\" : 19 } { \"name\" : \"Ken\", \"age\" : 20 } { \"name\" : \"Kelly\", \"age\" : 18 } 逻辑查询 MongoDB 中在 find() 或者 findOne() 里可指定的逻辑查询语法如下： 条件语法 描述 { k : v, k: v } AND 条件 { $and : [ {条件 1 : v }, {条件 2 : v } ] } 同上，AND 条件 { $or : [ {条件 1 : v }, {条件 2 : v } ] } OR 条件 { k : { $not : {条件 : v } } } NOT 条件，仅支持对单个 k 的条件 { $nor : [ {条件 1 : v }, {条件 2 : v } ] } NOT 条件，可支持对多个 k 的条件 示例 $and，查询 Js 成绩大于 80，并且年龄小于 22 的文档，拿名字以及 Js 成绩： > db.collection.find({\"grades.Js\" : {$gt : 80}, \"age\" : {$lt : 22}}, {\"_id\" : 0, \"name\" : 1, \"grades.Js\" : 1}) { \"name\" : \"Jack\", \"grades\" : { \"Js\" : 88 } } > db.collection.find( { $and:[ {\"grades.Js\" : {$gt : 80}}, {\"age\" : {$lt : 22}} ] }, { \"_id\" : 0, \"name\" : 1, \"grades.Js\" : 1 } ) { \"name\" : \"Jack\", \"grades\" : { \"Js\" : 88 } } 示例 $or，查询年龄是 17 岁或者 Js 成绩大于 80 的文档，拿名字，年龄以及 Js 成绩： > db.collection.find( { $or:[ {\"grades.Js\" : {$gt : 80}}, {\"age\" : {$eq : 17}} ] }, { \"_id\" : 0, \"name\" : 1, \"age\" : 1, \"grades.Js\" : 1 } ) { \"name\" : \"Jack\", \"age\" : 18, \"grades\" : { \"Js\" : 88 } } { \"name\" : \"Keisha\", \"age\" : 17, \"grades\" : { \"Js\" : 31 } } 示例 $not，查询性别不是 male 的文档，拿名字和性别： > db.collection.find( { \"gender\" : {$not : {$eq : \"male\"}} }, { \"_id\" : 0, \"name\" : 1, \"gender\" : 1, } ) { \"name\" : \"Keisha\", \"gender\" : \"female\" } { \"name\" : \"Kelly\", \"gender\" : \"female\" } 示例 $nor，查询性别不是 male，名字不是 kelly 的文档： > db.collection.find( { $nor : [ {\"gender\" : \"male\"}, {\"name\" : \"Kelly\"} ] }, { \"_id\" : 0, \"name\" : 1, \"age\" : 1, } ) { \"name\" : \"Keisha\", \"age\" : 17 } 存在与类型 MongoDB 中在 find() 或者 findOne() 里可指定的存在与类型查询语法如下： 语法格式 描述 { k : null } 查询 v 为 null 的 k，或者没有这个 k 的文档 { k : { $exists : bool }} 查询存在或不存在该 k 的文档 { k : { $type: “type” }} 查询该 k 的 v 为指定类型的文档 示例，null，查询不存在 school 键的文档，仅展示一个： > db.collection.findOne({\"school\" : null}) > db.collection.findOne({\"school\" : {$exists : false}}) 示例，查询 name 为 string 类型的文档，仅展示一个： > db.collection.findOne({\"name\" : {$type : \"string\"}}) 在查询类型时，你也可以使用数字编号进行代替： > db.collection.findOne({\"name\" : {$type : 2}}) $type 的数字编号如下表所示： 类型 数字 备注 Double 1 String 2 Object 3 Array 4 Binary data 5 Undefined 6 已废弃。 Object id 7 Boolean 8 Date 9 Null 10 Regular Expression 11 JavaScript 13 Symbol 14 JavaScript (with scope) 15 32-bit integer 16 Timestamp 17 64-bit integer 18 Min key 255 Query with -1. Max key 127 取余与正则 MongoDB 中在 find() 或者 findOne() 里可指定的取余与正则查询语法如下： 语法格式 描述 { k : { $mod : [ 除数 , 余数 ] } } 查询 k 的 v 是取余结果值的文档 { k :{ $regex : /表达式/ } } 查询 k 的 v 是被正则表达式所匹配的文档 示例，查询 age 的值是除 2 余 0 的文档： > db.c1.find({\"age\":{$mod:[2,0]}}); # 18，20 年龄的都会查出来 示例，查询 key 的值被正则表达式所匹配的文档： > db.c1.find({\"name\":{$regex:/^J.{2}k$/}}); 数组的条件 MongoDB 中在 find() 或者 findOne() 里可指定的数组的条件查询语法与获取语法如下： 语法格式 描述 { k : { $all : [ v1, v2, … ] } } 匹配所有 k 为数组类型，且 k 的元素均在查询条件中的文档 { k : { $elemMatch : { k : v } } 匹配所有 k 为数组类型，且 k 的元素均在查询条件范围中的文档，需要配合其他修改器 { k : { $size : int } } 匹配所有 k 为数组类型，且 k 的长度与查询条件设定长度一致的文档 { k : { $slice : [ start, stop ] || int } } 匹配所有 k 为数组类型的文档，返回数组中的元素，可进行切片或取一个的操作，位置在指定第二参数（元素获取语法） 先创建一个集合： > db.array.drop() > db.array.insertMany([{\"k\" : [1, 2, 3, 4, 5]}, {\"k\" : [1, 2, 3, 4, 5, 6]}]) 示例，$all，匹配规则，必须包含 1，2，3，4，5，多一个不行，少一个也不行： > db.array.find({\"k\" : {$all : [1, 2, 3, 4, 5]}}) 示例，$elemMatch，匹配规则，包含 1，2，3 即可： > db.array.find({\"k\" : {$elemMatch : {$in:[1, 2, 3]}}}) 示例，$size，返回长度为 5 的数组： > db.array.find({\"k\" : {$size : 5}}) 示例，$slice，从第一个开始，向后取 3 个： > db.array.find({\"k\" : {$type : \"array\"}}, {\"k\" : {$slice : [1, 3]}}) { \"_id\" : ObjectId(\"6048e85d6be9382bc8346b60\"), \"k\" : [ 2, 3, 4 ] } { \"_id\" : ObjectId(\"6048e85d6be9382bc8346b61\"), \"k\" : [ 2, 3, 4 ] } 此外我们也可以利用.进行深度访问，如，查询所有数组位置为0的成绩大于25的学生： db.userInfo.find({\"grades.0.score\": {$gt: 25}}, {\"name\": 1, \"_id\": 0}) $where 查询 最强大的一种查询，能够查询到任意的你想查询的信息，但是查询时不会走索引，所以尽量少用。 它其实是书写一个 JavaScript 函数进行查询，如下所示，查询所有成绩大于 200 分的文档： db.collection.find({ $where: function (){ if (this.grades.Js + this.grades.Go + this.grades.Py > 200){ return true } return false } }) # return false，不返回文档 # return true，返回文档 # 每次的 this 都是新的文档 $where 本身会将 BSON 文档转换为 JavaScript 可识别的对象，所以查询时会非常慢。 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:48 "},"数据库专栏/MongoDB/聚合查询.html":{"url":"数据库专栏/MongoDB/聚合查询.html","title":"聚合查询","keywords":"","body":"数据准备 在学习聚合查询前，先录入以下数据： > db.collection.drop() > db.collection.insertMany( [ { _id: 1, name: \"Jack\", gender: \"male\", age: 18, grades: { Js: 88, Py: 92, Go: 78 }, class: { name: \"三年级一班\", numPeople: 30, } }, { _id: 2, name: \"Tom\", gender: \"male\", age: 19, grades: { Js: 72, Py: 81, Go: 56, }, class: { name: \"三年级一班\", numPeople: 30, } }, { _id: 3, name: \"Ken\", gender: \"male\", age: 20, grades: { Js: 61, Py: 72, Go: 96, }, class: { name: \"三年级一班\", numPeople: 30, } }, { _id: 4, name: \"Keisha\", gender: \"female\", age: 17, grades: { Js: 31, Py: 42, Go: 26, }, class: { name: \"三年级二班\", numPeople: 21, } }, { _id: 5, name: \"Kelly\", gender: \"female\", age: 18, grades: { Js: 71, Py: 64, Go: 19, }, class: { name: \"三年级二班\", numPeople: 21, } } ] ) 基础函数 count() 对集合直接调用 count() 函数，可获取记录条数。 > db.collection.count() 5 也可以进行条件筛选，如找出 Js 成绩大于 80 的文档个数： > db.collection.count({\"grades.Js\" : {$gt : 80}}) 1 distinct() 对集合直接调用 distinct() 函数，并传入 key，用于获取该 key 的不同 value。 如下所示，获取所有文档的 name： > db.collection.distinct(\"name\") [ \"Jack\", \"Keisha\", \"Kelly\", \"Ken\", \"Tom\" ] aggregate() 其实以前的版本会使用 group() 函数做聚合查询，但是新版本已经不那么用了。 现在使用 aggregate() 函数完成聚合查询，参数必定是一个数组。 首先基础格式如下： db.集合名.aggregate( [ { $group : { _id : \"$分组key, $分组key\", // 按那个 key 进行分组，按 null 就是不分组，必须在 key 前面加上 $ 别名 : {$聚合运算 : \"$运算列\"} }, }, { $步骤 : { 上个管道的别名 : {$条件 : 值}, 别名: {$条件 : \"$上个管道的别名\"} // 如果是上个管道的别名要应用在 {} 中，则必须加上 $ 的前缀，且以双引号括起来 // 所以这里会出现两种情况 } } ] ) 管道与步骤 整个聚合运算由多个管道（Pipeline）组成，而每个运算层次被称为步骤（Stage）。 可以这么理解，在 aggregate() 函数的 [] 中，每个 {} 会被认为是一个管道，每个{}中顶层以 $ 开始的键被称为步骤。 如图所示，正确理解管道和步骤： 在管道的表达式 {} 中使用原管道或文档字段，必须添加 $ 的前缀，且以双引号括起来 而在管道的步骤 key 中引用原管道字段则不需要加 $ 的前缀 下面的示例中引用 TotalGrades 字段没有在 {} 中，则不需要加 $ 前缀： 而下面的这个示例中，由于上个管道的字段引用在 {} 中，则需要加 $ 前缀与双引号： 每个管道： 接受一系列文档（原始数据）； 由步骤对这些文档进行一系列运算； 结果文档输出给下一个步骤，由下一个步骤的管道继续运算； 如图所示： 步骤修改器 以下是常见的步骤修改器： 步骤修改器 作用 SQL 等价运算符 $match 条件匹配，放在 $group 前是 where，放在 $group 后是 having WHERE $project 控制 select 的结果，相当于 as AS $sort 条件排序 ORDER BY $group 条件分组 GROUP BY $skip 跳过文档的数量，相当于 limit 的第二个值 SKIP $limit 限制结果的数量，相当于 limit 的第一个值 LIMIT $lookup 多表关联查询 JOIN $unwind 展开数组 N/A $graphLookup 图搜索 N/A $facet/$bucket 分面搜索 N/A 管道修改器 以下是常见的管道修改器： 以下是在管道步骤中常用的运算符： $MATCH $PROJECT $GROUP $eq $map / $reduce / $filter $sum / $avg $in / $nin $range $push / $addToSet $and / $or / $not / $nor $multiply / $divide / $substract / $add $first / $last / $max/$min $exists / $type $year / $month / $dayOfMonth / $hour / $minute / $second $mod / $regex $all / $elemMatch / $size $geoWithin / $intersect 步骤修改器 $match $match 放在 $group 之前是 where，而放在 $group 之后是 having。 示例，查询平均年龄小于 18 岁的班级： db.collection.aggregate( [ { $group : { _id : \"$class.name\", avgAge : {$avg : \"$age\"} }, }, { $match : { avgAge : {$lt : 18} } } ] ) { \"_id\" : \"三年级二班\", \"avgAge\" : 17.5 } $project $project 能对显示结果做任意拼接。 示例，展示每个每个班级的总分，并在此基础上加上 100： db.collection.aggregate( [ { $group : { _id : \"$class.name\", TotalGrades : {$sum : {$add : [\"$grades.Js\", \"$grades.Go\", \"$grades.Py\"]}} }, }, { $project : { Grades : {$add : [\"$TotalGrades\", 100]} } } ] ) { \"_id\" : \"三年级二班\", \"Grades\" : 353 } { \"_id\" : \"三年级一班\", \"Grades\" : 796 } # 引用上个管道的 TotalGrades, 在 {} 中引用，需要加 $ 前缀，且以双引号括起来 管道修改器 $group -> $sum 示例，计算两个班级的总年龄： db.collection.aggregate( [ { $group : { _id : \"$class.name\", TotalAge : {$sum : \"$age\"} }, }, ] ) { _id: '三年级二班', TotalAge: 35 } { _id: '三年级一班', TotalAge: 57 } 示例，计算出两个班级的总成绩： db.collection.aggregate( [ { $group : { _id : \"$class.name\", TotalGrades : {$sum : {$add : [\"$grades.Js\", \"$grades.Go\", \"$grades.Py\"]}} }, }, ] ) { _id: '三年级二班', TotalGrades: 253 } { _id: '三年级一班', TotalGrades: 696 } $group -> $avg 示例，计算两个班级的平均 Js 成绩： db.collection.aggregate( [ { $group : { _id : \"$class.name\", avgJs : {$avg : \"$grades.Js\"} }, }, ] ) { \"_id\" : \"三年级二班\", \"avgJs\" : 51 } { \"_id\" : \"三年级一班\", \"avgJs\" : 73.66666666666667 } 示例，计算两个班级的平均年龄： db.collection.aggregate( [ { $group : { _id : \"$class.name\", avgAge : {$avg : \"$age\"} }, }, ] ) { \"_id\" : \"三年级二班\", \"avgAge\" : 17.5 } { \"_id\" : \"三年级一班\", \"avgAge\" : 19 } $group -> $max 示例，拿到两个班级中的最大年龄： db.collection.aggregate( [ { $group : { _id : \"$class.name\", maxAge : {$max : \"$age\"}, }, } ] ) { \"_id\" : \"三年级一班\", \"maxAge\" : 20 } { \"_id\" : \"三年级二班\", \"maxAge\" : 18 } Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:48 "},"数据库专栏/MongoDB/索引相关.html":{"url":"数据库专栏/MongoDB/索引相关.html","title":"索引相关","keywords":"","body":"基础知识 索引作用 MongoDB 的索引与传统的关系型数据库索引的概念基本一致。 除了能够加速查找外，还能针对字段做约束。 在 MongoDB 中，索引的查找算法也是采用 B-Tree 算法，具体可参照 MySQL 系列文章中的索引介绍。 以下是 MongoDB 官方所提供的索引图示，可以看见它会对下方杂乱无章的文档进行一次排序： 索引语法 我们在 MongoDB 中建立索引时，需要指定索引字段的排序方式，1 为升序，-1 为降序，并且索引建立完成后，会生成一个默认的索引名字（当然也可以自己指定）。 以下是创建、查看、删除、修改索引的语法： # 创建索引 db.集合名.createIndex({索引字段 : 排序}) # 查看所有索引 db.集合名.getIndexes() # 查看当前集合索引大小 db.集合名.totalIndexSize() # 删除集合中所有的索引，不包含默认索引 db.集合名.dropIndexes() # 删除集合中指定的所有 db.集合名.dropIndex(\" 索引名称 \") 索引排序 在创建索引时，指定排序规则有利于后期的查询。 如，以下表格中是未创建索引时的存储方式： 位置信息 文档 pos1 {“name” : “jack”, “age” : 19 } pos2 {“name” : “rose”, “age” : 20 } pos3 {“name” : “jack”, “age” : 18 } pos4 {“name” : “tony”, “age” : 21} pos5 {“name” : “adam”, “age” : 18} 如果要查询 age 等于 18 岁的人，则需要进行全集合扫描。 如果对其做了升序排序，则存储方式就变为了下表中的样子： age 位置信息 18 pos3 18 pos5 19 pos1 20 pos2 21 pos4 索引查看 当创建完一个索引后，可以使用 getIndexs() 来查看当前集合中所存在的所有索引，如下所示： > db.collection.drop() > db.createCollection(\"collection\") { \"ok\" : 1 } > db.collection.getIndexes() [ { \"v\" : 2, # 索引版本 \"key\" : { # 索引key \"_id\" : 1 # 排序规则 }, \"name\" : \"_id_\", # 索引名称 \"ns\" : \"test.collection\" # 所属集合 } ] 概念名词 默认索引 MongoDB 在集合创建时默认会建立一个基于_id 的唯一索引作为文档的主键。 该 index 无法被删除，名为 id\\ 索引。 聚集索引 聚集索引一个集合只能有一个，它包含了整个文档的信息。 MongoDB 中的聚集索引就是默认索引_id。 辅助索引 除了聚集索引以外，人为创建的索引都是辅助索引。 查询一个文档时，辅助索引仅包含自身 key 的 value，如果要从辅助索引 key 中拿取其他 key 的 value，则需要通过回表查询。 其他说明 MongoDB 中索引概念应当和 MySQL 中索引差不多。 我还是推荐你查看之前 MySQL 索引的文章，对一些概念性的名词有所了解。 索引种类 单键索引 为某一个键创建单键索引 Single Field，如下我们将为 name 字段建立单键索引： > db.collection.createIndex({name : 1}) 查看索引： > db.collection.getIndexes() { \"v\" : 2, \"key\" : { \"name\" : 1 }, \"name\" : \"name_1\", \"ns\" : \"test.collection\" } 复合索引 复合索引 Compound Index 是指一个索引包含多个字段，使用复合索引时要根据定义字段的顺序与排序规则进行使用，如果使用不当则可能会影响查询效率。 > db.collection.createIndex({\"name\" : 1, \"age\" : 1}) 查看索引： > db.collection.getIndexes() { \"v\" : 2, \"key\" : { \"name\" : 1, \"age\" : 1 }, \"name\" : \"name_1_age_1\", \"ns\" : \"test.collection\" } 多键索引 多键索引 Multikey Index 是指为内嵌的文档、或者数组建立索引，如下所示，建立多 key 索引后可以方便查询具有相同爱好的文档： > db.collection.createIndex({\"hobby\" : 1}) 查看索引: > db.collection.getIndexes() { \"v\" : 2, \"key\" : { \"hobby\" : 1 }, \"name\" : \"hobby_1\", \"ns\" : \"test.collection\" } 同理，我们也可以为内嵌文档来建立内嵌索引，如下所示，建立多 key 索引后方便以 Js 成绩为筛选条件来查看对应的文档： > db.collection.createIndex({\"grades.Js\" : 1}) 查看索引： > db.collection.getIndexes() { \"v\" : 2, \"key\" : { \"grades.Js\" : 1 }, \"name\" : \"grades.Js_1\", \"ns\" : \"test.collection\" } 哈希索引 哈希索引 Hashed Indexes 可以将字段的值进行哈希计算后作为索引，常用于定值查找，而不适用于范围查找。 如将手机号作为哈希索引来说是非常明智的一个选择，需要注意的是使用哈希索引不需要进行排序： > db.collection.createIndex({\"phone\" : \"hashed\"}) 查看索引： > db.collection.getIndexes() { \"v\" : 2, \"key\" : { \"phone\" : \"hashed\" }, \"name\" : \"phone_hashed\", \"ns\" : \"test.collection\" } 文本索引 MongoDB 文本索引可以将一篇文章中的任意词汇，句子用作查询条件。 但是一般来讲这种全局搜索类的业务我们不会用 MongoDB 来做，而是使用另一款 NoSQL 产品 Elasticsearch。 所以文本索引仅做了解即可，可以参阅官方文档：点我跳转 地理空间索引 MongoDB 地理空间索引一般用于地图类应用的开发中，所以相对来说使用场景也较少。 更多的 Web 开发者会选择第三方 API 进行调用，而不是自己实现，因此对于普通开发人员仅做了解即可。 可以参阅官方文档：点我跳转 索引约束 background 在创建索引时，默认会锁集合（锁表），加上该属性则不会锁集合，但是会降低建立索引的速度。 > db.collection.createIndex({\"name\" : 1}, {\"background\" : true}) name 在建立索引时，如果没有手动指定索引名字，则会自动生成一个名字，使用该属性可手动指定索引名： > db.collection.createIndex({\"name\" : 1}, {\"name\" : \"index_name\"}) unique indexs 为索引建立唯一性约束： > db.collection.createIndex({\"name\" : 1}, {\"unique\" : true}) 也可以进行复合索引的唯一约束： > db.collection.createIndex({\"name\" : 1 , \"age\" : 1}, {\"unique\" : true}) sparse indexs 稀疏索引的条件，举个例子，有的文档有 addr 字段，而有的文档没有 addr 字段，这个时候就可以用上稀疏索引。 如果为 addr 创建普通索引的话，即便没有 addr 字段的文档也会对其设置一个 {“addr\" : null} 的字段。 而稀疏索引就不会这么做，只针对有 addr 字段的文档建立索引，而没有 addr 字段的文档则不建立索引，更不会去添加字段。 > db.collection.createIndex({\"addr\" : 1}, {\"sparse\" : 1}) TTL indexs 过期索引的条件，若一个文档在一段时间后要求删除，则可以添加一个时间字段。 当时间到达后，该文档则会被 MongoDB 删除。 > db.items.insertMany({\"createTime\" : new Date()}) > db.items.createIndex({\"createTime\" : 1, {expireAfterSeconds : 120}}) # 以秒为单位，120s 后对该文档进行删除 # 过期时间 = 字段时间 + expireAfterSeconds 设定时间 正确使用索引 最左前缀匹配 最左前缀匹配仅适用于复合索引上。 如索引建立规则是： {“name” : 1, “age” : 1, “addr” : 1} 则在使用索引时，必须遵循最左前缀匹配规则，如下匹配都是能成功走索引的： > db.collection.find({\"name\" : \"Jack\", \"age\" : 18, \"addr\" : \"Bj\"}) 如果没有遵循顺序，如下这种查询是不走索引的： > db.collection.find({\"name\" : \"Jack\", \"addr\" : \"Bj\"}) > db.collection.find({\"age\" : 18, \"addr\" : \"Bj\"}) 注意，MongoDB 与 MySQL 不同，MySQL 中如果用了多个等值查询，则不用遵循最左前缀匹配的规则 而对于 MongoDB 来说，即使是多个等值查询，也依然不会走索引。 筛选与排序 有的时候，查询条件的筛选字段是做了索引的，如 name 这个筛选字段我们给他做了索引。 但是进行 sort() 排序时，排序字段是 createTime 字段，这个时候还是会降低运行效率。 正确的做法是，为 createTime 字段也加上索引。 低性能修改器 $where 与 $exists 以及 null 都是性能极低的修改器，完全不能使用索引。 $ne 和 $not 以及 $nor 还有 $nin 等，虽然能使用索引，但是会进行全索引扫描，性能也很低。 执行计划 语句分析 explain() 是一个语句调优中经常使用到的函数，它可以对增伤改查等任意对文档的语句做出性能评估，拿到优化器选择后的最优策略进行分析（并不会执行语句本身）。 使用 explain() 函数来查看语句的执行计划，下面是没使用了普通索引的一次扫描： > db.collection.find({\"name\" : \"Jack\"}).explain() { # 缺省模式， \"queryPlanner\" : { \"plannerVersion\" : 1, # 查询计划版本 \"namespace\" : \"test.collection\", # 被查询对象 \"indexFilterSet\" : false, # 是否使用到了索引来过滤 \"parsedQuery\" : { # 查询条件 \"name\" : { \"$eq\" : \"Jack\" } }, \"queryHash\" : \"01AEE5EC\", \"planCacheKey\" : \"4C5AEA2C\", \"winningPlan\" : { # 最佳的执行计划 \"stage\" : \"FETCH\", # 第一阶段：FETCH 根据索引检索文档（COLLSCAN 是全集合扫描文档） \"inputStage\" : { \"stage\" : \"IXSCAN\", # 第二阶段：IXSCAN 索引扫描 \"keyPattern\" : { \"name\" : 1 }, \"indexName\" : \"name_1\", \"isMultiKey\" : false, \"multiKeyPaths\" : { \"name\" : [ ] }, \"isUnique\" : false, \"isSparse\" : false, \"isPartial\" : false, \"indexVersion\" : 2, \"direction\" : \"forward\", \"indexBounds\" : { \"name\" : [ \"[\\\"Jack\\\", \\\"Jack\\\"]\" ] } } }, \"rejectedPlans\" : [ ] }, \"serverInfo\" : { \"host\" : \"centos\", \"port\" : 27017, \"version\" : \"4.2.12\", \"gitVersion\" : \"5593fd8e33b60c75802edab304e23998fa0ce8a5\" }, \"ok\" : 1 } 由于篇幅原因，这里不再做过多赘述，我找到一篇很不错的文章，如果你对执行计划感兴趣，可以 点我跳转 慢日志 开启 Profiling 功能 有两种方式可以控制 Profiling 的开关和级别，第一种是直接在启动参数里直接进行设置。 启动 MongoDB 时加上--profile= 级别即可。 也可以在客户端调用 db.setProfilingLevel(级别) 命令来实时配置。可以通过 db.getProfilingLevel() 命令来获取当前的 Profile 级别。 > db.setProfilingLevel(2); {\"was\" : 0 , \"ok\" : 1} > db.getProfilingLevel() 上面斜体的级别可以取 0，1，2 三个值，他们表示的意义如下： 0 – 不开启 1 – 记录慢命令 (默认为>100ms) 2 – 记录所有命令 Profile 记录在级别 1 时会记录慢命令，那么这个慢的定义是什么 ? 上面我们说到其默认为 100ms，当然有默认就有设置，其设置方法和级别一样有两种，一种是通过添加–slowms 启动参数配置。第二种是调用 db.setProfilingLevel 时加上第二个参数： db.setProfilingLevel( level , slowms ) db.setProfilingLevel( 1 , 10 ); 查询 Profiling 记录 与 MySQL 的慢查询日志不同，Mongo Profile 记录是直接存在系统 db 里的，记录位置 system.profile，所以，我们只要查询这个 Collection 的记录就可以获取到我们的 Profile 记录了。 > db.system.profile.find() {\"ts\" : \"Thu Jan 29 2009 15:19:32 GMT-0500 (EST)\" , \"info\" : \"query test.$cmd ntoreturn:1 reslen:66 nscanned:0 query: { profile: 2 } nreturned:1 bytes:50\" , \"millis\" : 0} db.system.profile.find( { info: /test.foo/ } ) {\"ts\" : \"Thu Jan 29 2009 15:19:40 GMT-0500 (EST)\" , \"info\" : \"insert test.foo\" , \"millis\" : 0} {\"ts\" : \"Thu Jan 29 2009 15:19:42 GMT-0500 (EST)\" , \"info\" : \"insert test.foo\" , \"millis\" : 0} {\"ts\" : \"Thu Jan 29 2009 15:19:45 GMT-0500 (EST)\" , \"info\" : \"query test.foo ntoreturn:0 reslen:102 nscanned:2 query: {} nreturned:2 bytes:86\" , \"millis\" : 0} {\"ts\" : \"Thu Jan 29 2009 15:21:17 GMT-0500 (EST)\" , \"info\" : \"query test.foo ntoreturn:0 reslen:36 nscanned:2 query: { $not: { x: 2 } } nreturned:0 bytes:20\" , \"millis\" : 0} {\"ts\" : \"Thu Jan 29 2009 15:21:27 GMT-0500 (EST)\" , \"info\" : \"query test.foo ntoreturn:0 exception bytes:53\" , \"millis\" : 88} 列出执行时间长于某一限度 (5ms) 的 Profile 记录： > db.system.profile.find( { millis : { $gt : 5 } } ) {\"ts\" : \"Thu Jan 29 2009 15:21:27 GMT-0500 (EST)\" , \"info\" : \"query test.foo ntoreturn:0 exception bytes:53\" , \"millis\" : 88} 查看最新的 Profile 记录： > db.system.profile.find().sort({$natural:-1}) Mongo Shell 还提供了一个比较简洁的命令 show profile，可列出最近 5 条执行时间超过 1ms 的 Profile 记录。 Profile 信息内容详解 ts-该命令在何时执行。 millis Time-该命令执行耗时，以毫秒记 . info-本命令的详细信息 . query-表明这是一个 query 查询操作 . ntoreturn-本次查询客户端要求返回的记录数 . 比如 , findOne() 命令执行时 ntoreturn 为 1. 有 limit(n) 条件时 ntoreturn 为 n. query-具体的查询条件 (如 x>3). nscanned-本次查询扫描的记录数 . reslen-返回结果集的大小 . nreturned-本次查询实际返回的结果集 . update-表明这是一个 update 更新操作 . fastmod-Indicates a fast modify operation. See Updates. These operations are normally quite fast. fastmodinsert – indicates a fast modify operation that performed an upsert. upsert-表明 update 的 upsert 参数为 true. 此参数的功能是如果 update 的记录不存在，则用 update 的条件 insert 一条记录 . moved-表明本次 update 是否移动了硬盘上的数据，如果新记录比原记录短，通常不会移动当前记录，如果新记录比原记录长，那么可能会移动记录到其它位置，这时候会导致相关索引的更新 . 磁盘操作更多，加上索引更新，会使得这样的操作比较慢 . insert-这是一个 insert 插入操作 . getmore-这是一个 getmore 操作，getmore 通常发生在结果集比较大的查询时，第一个 query 返回了部分结果，后续的结果是通过 getmore 来获取的。 Profiler 的效率 Profiling 功能肯定是会影响效率的，但是不太严重，原因是他使用的是 system.profile 来记录，而 system.profile 是一个 capped collection 这种 collection 在操作上有一些限制和特点，但是效率更高。 常见的语句优化 如果 nscanned(扫描的记录数) 远大于 nreturned(返回结果的记录数) 的话，那么我们就要考虑通过加索引来优化记录定位了。 reslen 如果过大，那么说明我们返回的结果集太大了，这时请查看 find 函数的第二个参数是否只写上了你需要的属性名。(类似 于 MySQL 中不要总是 select *) 对于创建索引的建议是：如果很少读，那么尽量不要添加索引，因为索引越多，写操作会越慢。如果读量很大，那么创建索引还是比较划算的。 如果写查询量或者 update 量过大的话，多加索引是会有好处的。 参考文档链接 关于慢日志这一小节，原文在此，点我跳转 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:48 "},"数据库专栏/MongoDB/用户权限.html":{"url":"数据库专栏/MongoDB/用户权限.html","title":"用户权限","keywords":"","body":"权限管理 MongoDB 默认是没有开启权限认证的，这意味着你不需要用户与密码就能随意链接我们的 MongoDB 服务。 如下图所示，我在 MAC 上链接了部署在 Centos 上的 MongoDB 服务，并未输入任何用户名与密码： 这是极度不安全的，意味着黑客可以在你的 MongoDB 中做任何事。 我们该怎么做？ 创建一个用户，并与某个数据库建立联系（生成认证库），此时该用户登录 MongDB 后将不再进入 test 库，而是进入自己的认证库 配置文件中指定，在登录时，必须输入认证库才能登录 一般来说，管理员用户的认证库是内置库 admin，普通用户的认证库是在后期业务中需要使用的库。 从 MongoDB3.6 开始，默认不允许远程登录，除非你在配置文件中指定了 bindIp 参数。 操作流程 新建管理用户 现在我们准备创建一个管理员，管理员的认证库为 admin： > use admin > db.createUser({ \"user\" : \"root\", \"pwd\" : \"123\", \"roles\" : [ { \"role\" : \"root\", \"db\" : \"admin\" } ] }) 基本语法说明： # user : 用户名 # pwd : 密码 # roles->role : 角色名，常用可选角色有root,readWrite,read # roles->db : 认证库，也就是该角色可以管理的库，admin库下的用户可以管理所有库 新建普通用户 接下来创建普通用户，你需要 use 到该用户日后要使用的库中。 这里以 db1 库举例： > use db1 > db.createUser({ \"user\" : \"user01\", \"pwd\" : \"user01\", \"roles\" : [ {\"role\" : \"readWrite\", \"db\" : \"db1\"} ] }) 如果你想让该用户管理和使用多个库，可在 db 中指定一个数组，并在数组中输入要管理和使用的库名。 查看所有用户 在 shell 中，进入 admin 库，查看所有用户： > use admin > db.system.users.find().pretty() { \"_id\" : \"admin.root\", \"userId\" : UUID(\"ac915072-5d31-4518-a55d-9cfae4b295c4\"), \"user\" : \"root\", \"db\" : \"admin\", \"credentials\" : { \"SCRAM-SHA-1\" : { \"iterationCount\" : 10000, \"salt\" : \"ezwo+/HcnquWlJQ3YhMK1g==\", \"storedKey\" : \"kYjX0rlHcwATxPYjdhshrRcNnqA=\", \"serverKey\" : \"aEWtC5lKcT1J3L/YNIlq63PUZq4=\" }, \"SCRAM-SHA-256\" : { \"iterationCount\" : 15000, \"salt\" : \"2dR8j82N/RjTN3z2aqrHU0Ro6NelsYJNStmgUw==\", \"storedKey\" : \"OsNdvZ7H4bkq+7eKZqzE83I1XQSmK2fi+8Sac6c/cls=\", \"serverKey\" : \"wERj9eex/CDykesnO7AF9xK27/LE/khXYm6CR6T+2wY=\" } }, \"roles\" : [ { \"role\" : \"root\", \"db\" : \"admin\" } ] } { \"_id\" : \"db1.user01\", \"userId\" : UUID(\"02c14c88-2821-4fbb-9011-21c75db9998a\"), \"user\" : \"user01\", \"db\" : \"db1\", \"credentials\" : { \"SCRAM-SHA-1\" : { \"iterationCount\" : 10000, \"salt\" : \"AfAFE0UiC6y2cQQ2CTVosw==\", \"storedKey\" : \"veo61KYTN8x2rVw7SVDpBo5BauQ=\", \"serverKey\" : \"F4lTqEPrwT1ZZ/3DCDzqpiHimjQ=\" }, \"SCRAM-SHA-256\" : { \"iterationCount\" : 15000, \"salt\" : \"EA7tjUSg0vgSpBbiYiO2fkSOa8+CJ5hPUby8fg==\", \"storedKey\" : \"4KwK2A7fHD1senpmi6r3m+B2KBAn+WzqZLcpZ5+RT8Y=\", \"serverKey\" : \"WijvE3vwCqvU7ys2jZUYr2oW+GU6gBYs5JslUiKIT8k=\" } }, \"roles\" : [ { \"role\" : \"readWrite\", \"db\" : \"db1\" } ] } 开启用户授权 接下来我们需要进入到这两个角色各自的库中，对其进行授权操作： > use admin > db.auth('root','123') > use db1 > db.auth('user01','user01') 开启登录验证 在配置文件中，首先加入如下配置项： security: authorization: enabled 然后重启 MongoDB 服务: $ systemctl restart mongod 如何进行登录 现在，如果要在本地 shell 中进行登录的话，你可以向下面这样登录，如果没有加后面的授权库，登陆上去很多操作是不被允许的： $ mongo -uroot -p123 127.0.0.1/admin $ mongo -uuser01 -puser01 127.0.0.1/db1 如果我们用 user01 这个普通用户进行登录后，使用 db 命令查看所在的库名就是 db1 库，并且使用 show dbs 库也只能查看到 db1 库： > db db1 > show dbs db1 如果是远程登录，可用以下的形式： mongodb://用户名:密码@地址:端口号/?authSource=验证库 mongodb://root:123@192.168.0.120:27017/?authSource=admin 用户管理 修改用户 如果要对一个用户进行修改，必须登录管理员用户且在该用户的认证库中使用如下命令： $ mongo -uroot -p123 127.0.0.1/admin > use db1 > db.updateUser('user01', { pwd:'user123', roles:[ { role:'read', db:'db1' } ] } ) 别忘记进行一次授权： > use db1 > db.auth('user01','user123') 删除用户 如果要删除一个用户，需要管理员用户进入被删除用户的验证库中执行以下命令： $ mongo -uroot -p123 127.0.0.1/admin > use db1 > db.dropUser(\"user01\") 可选角色 数据库用户角色： read: 只读数据权限 readWrite: 学些数据权限 数据库管理角色： dbAdmin: 在当前 db 中执行管理操作的权限 dbOwner: 在当前 db 中执行任意操作 userADmin: 在当前 db 中管理 user 的权限 备份和还原角色： backup restore 跨库角色： readAnyDatabase: 在所有数据库上都有读取数据的权限 readWriteAnyDatabase: 在所有数据库上都有读写数据的权限 userAdminAnyDatabase: 在所有数据库上都有管理 user 的权限 dbAdminAnyDatabase: 管理所有数据库的权限 集群管理： clusterAdmin: 管理机器的最高权限 clusterManager: 管理和监控集群的权限 clusterMonitor: 监控集群的权限 hostManager: 管理 Server 超级权限： root: 超级用户 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:48 "},"数据库专栏/MongoDB/配置文件.html":{"url":"数据库专栏/MongoDB/配置文件.html","title":"配置文件","keywords":"","body":"YAML MongoDB 中配置文件采用 YAML 进行书写（3.x 以上），这是一种通用的数据串行化格式。 不同于 MySQL 中 XML 的配置文件格式，YAML 格式阅读起来更加方便。 基本语法规则： 大小写敏感 使用缩进表示层级关系 缩进时不允许使用 Tab 键，只允许使用空格。 缩进的空格数目不重要，只要相同层级的元素左侧对齐即可 使用 #标识注释 此外，还可以使用 #号标识注释。 示例演示： systemLog: destination: file path: \"/usr/local/mongodb/logs/mongod.log\" logAppend: true storage: dbPath: \"/usr/local/mongodb/data\" journal: enabled: true processManagement: fork: true net: bindIp: 0.0.0.0 port: 27017 setParameter: enableLocalhostAuthBypass: false 如果你想了解更多关于 YAML 的信息，点我跳转。 配置简述 配置项 在 MongoDB 中，顶层拥有不同级别的配置项目，具体描述如下所示： 顶层配置 描述 systemLog 系统日志相关 storage 数据存储相关 processManagement 进程控制相关 net 网络配置相关 security 安全验证相关 replication 复制集相关 sharding 分片集群相关 operationProfiling 性能分析相关 setParameter 自定义变量相关 auditLog 审计日志相关 示例演示 下面是一份关于 MongoDB 配置的说明： # 系统日志 systemLog: destination: file # 日志输出目的地，file或syslog path: # 日志位置 logAppend: true # 日志记录时以追加模式记录，服务重启时不产生新的log文件 # 数据存储 storage: engine: # 存储引擎，3.x以上默认为wiredTiger，4.x开始已被弃用 dbPath: # 数据存储目录 journal: # 回滚日志 enabled: true directoryPerDB: true # 默认是false，不适用于内存引擎 mmapv1: # mmapv1存储引擎 preallocDataFiles: # 是否启用数据文件预分配？默认为false nsSize: # 命名空间的大小，默认为16M smallFiles: # 减少数据文件初始大小，用大量库存较小的文件，默认false quota: enforced: # 启动或禁用数据库可用于数字数据文件最大限制，默认false maxFilesPerDB: # 数据库中数据文件数量限制，默认为8，配合enforced参数使用 wiredTiger: # wiredTiger存储引擎 engineConfig: cacheSizeGB: 2 # 最大缓存数据大小 journalCompressor: # WiredTiger日志数据压缩类型，默认snappy directoryForIndexes: true # 索引集合storage.dbPath存储在单独的子目录中，默认false collectionConfig: blockCompressor: # 收集数据的默认压缩类型，默认snappy indexConfig: prefixCompression: # 禁用索引数据的前缀压缩，默认true inMemory: # inMemory存储引擎 engineConfig: inMemorySizeGB: # 最大缓存大小，默认物理内存的50% # 进程控制 processManagement: fork: true # 后台守护进程 pidFilePath: # pid文件的位置，一般不用配置，可以去掉这行，自动生成到data中 # 网络配置 net: bindIp: localhost,192.168.1.1 # 监听地址,绑定内网IP port: # 端口号,默认不配置端口号，是27017 maxIncomingConnections:5000 # 链接池中的初始最大链接数 # 安全验证 security: keyFile: # 秘钥存放路径，MongoDB的分配集群或复制集中身份验证共享秘钥 clusterAuthMode: keyFile # 集群认证方式，使用秘钥文件进行验证 authorization: enabled # 是否打开用户名密码验证 javascriptEnabled: # 禁用服务端Js执行 enableEncryption: # 启用WT存储引擎的加密，必须设置为true传递加密密钥和配置 encryptionCipherMode: # 加密的模式,仅适用于企业版 # 复制集 replication: oplogSizeMB: # 复制操作日志的大小 replSetName: \"\" # 复制集名称，同一复制集下所有hostname必须一致 secondaryIndexPrefetch: \"all\" # 分片集群 sharding: clusterRole: archiveMovedChunks: 详细说明 系统日志 以下是系统日志相关的配置及参数： systemLog: verbosity: # 日志级别，默认0,1-5均会包含debug信息 quiet: # 安静，true时将会减少日志的输出量 traceAllExceptions: # 打印异常详细信息 syslogFacility: # 启用syslog指定用于登录时信息到syslog Facility水平，前提是 path: # 日志路径 logAppend: # 追加日志还是新建日志 logRotate: rename|reopen # 日志轮询。默认值rename；reopen前提为 logAppend: true destination: # 日志输出目的地，可为file或syslog，不指定会输出到标准输出 timeStampFormat: # 日志时间戳格式，有 ctime,Iso869-utc,iso8691-local component: # 为不同的组件指定各自的日志信息级别 accessControl: verbosity: command: verbosity: 存储引擎 以下是存储引擎相关的配置及参数： storage: dbPath: # 数据存储目录 indexBuildRetry: # 构建索引时mongod意外关闭，启动是否重建索引，默认true repairPath: # 在repair期间临时数据目录 journal: enabled: # journal日志是否持久存储，通常用于数据故障恢复，建议开启 commitIntervalMs: # mongod日志刷新值，范围1-500毫秒，默认100，不建议修改 directoryPerDB: # 是否将不同的数据存储在不同的目录中，需为dbPath子目录 syncPeriodSecs: # fsync操作将数据flush到磁盘的时间间隔，默认为60秒，不建议修改 engine: # 存储引擎类型,3.2前默认mmapv1，3.2后默认WiredTiger wiredTiger: # 存储引擎配置 engineConfig: cacheSizeGB: # 最大缓存大小 journalCompressor: # 日志压缩算法，可选值有 none，snappy(默认)，zlib directoryForIndexes: # 是否将索引和集合数据分别存储在dbPath单独的目录中 collectionConfig: blockCompressor: # collection数据压缩算法，可选none, snappy，zlib indexConfig: prefixCompression: # 是否对索引数据使用前缀压缩。可有效减少索引数据的内存使用量。 进程相关 以下是进程相关的配置及参数： processManagement: fork: # 是否以守护进程运行，默认false pidFilePath: # 将mongod进程ID写入指定文件，默认不会创建 网络相关 以下是网络相关的配置及参数： net: prot: # 监听端口，默认27017 bindIp: # 绑定IP，如果此值是“0.0.0.0”则绑定所有接口 maxIncomingConnections: # 进程允许的最大连接数，上限是系统阈值(ulimit) wireObjectCheck: # 当客户端写入数据时，是否检查数据的有效性(BSON),有效的数据才执行 ipv6: # 是否支持多实例之间使用ipv6 http: # http配置 enabled: JSONEnabled: RESTInterfaceEnabled: ssl: # https配置 sslOnNormalPorts: mode: PEMKeyFile: PEMKeyPassword: clusterFile: clusterPassword: CAFile: CRLFile: allowConnectionsWithoutCertificates: allowInvalidCertificates: allowInvalidHostnames: disabledProtocols: FIPSMode: 验证相关 以下是验证相关的配置及参数： security: keyFile: # 秘钥存放路径，MongoDB的分配集群或复制集中身份验证共享秘钥 clusterAuthMode: keyFile # 集群认证方式，使用秘钥文件进行验证 authorization: enabled # 是否打开用户名密码验证 javascriptEnabled: # 禁用服务端Js执行 enableEncryption: # 启用WT存储引擎的加密，必须设置为true传递加密密钥和配置 encryptionCipherMode: # 加密的模式,仅适用于企业版 性能相关 以下是性能（慢查询）相关的配置及参数： operationProfiling: slowOpThresholdMs: # “慢查询”的时间阈值，单位毫秒(默认100ms) mode: # 数据库profiler级别，可选值“off|slowOp|all” 副本相关 以下是副本集相关的配置及参数： replication: oplogSizeMB: # replication操作日志的最大尺寸，如果太小则全量同步 replSetName: # 副本集名称，副本集中所有的mongod实例都必须有相同的名字 secondaryIndexPrefetch: # 副本集的secondary, 从oplog中应用变更操作前,会先把索引加载到内存 enalbeMajorityReadConcern: #允许readConcern的级别为“majority” 分片相关 以下是分片相关的配置及参数： sharding: clusterRole: # 在sharding集群中的角色。configsvr(27019)|shardsvr(27018) archiveMovedChunks: # 当chunks迁移后，是否归档并保存这些chunks在dbPath/movechunk目录下 审计相关 以下是审计相关的配置及参数： auditLog: destination: # 指定审计记录的输出方式，有syslog|console|file format: # 输出格式，有JSON 和 BSON path: # 如果输入为文件，那么指定文件完整路径及文件名 filter: # 过滤器，可限制审计系统记录的操作类型 变量相关 以下是自定义变量相关的配置及参数： setParameter: : : Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:48 "},"数据库专栏/MongoDB/设计模式.html":{"url":"数据库专栏/MongoDB/设计模式.html","title":"设计模式","keywords":"","body":"文档模型 JSON文档 MongoDB 的集合是一种无模式的状态，即没有字段，没有约束。 因此对于 MongoDB 的数据存储模型搭建过程来讲变的十分简单，需要什么字段就直接丢进去即可。 但是后期对于 MongoDB 集合的管理却变的较为复杂，相较于传统的关系型数据库，初次接触 MongoDB 的同学可能对这种结构的管理显得十分的懊恼。 例如，公司采用的文档结构可能刚开始没有 email 字段，并且该服务已经运行一阵，有了成百上千万条数据。 但是到了某一天领导发现需要加入 email 字段可能更好一点，此时存在的问题就是已经存储的集合文档中没有 email 字段，但后面新加入的文档就有了 email 字段，管理十分复杂。 在这里我不想再复述 JSON 的好处，它对于开发人员来讲十分的友好，但是对于运维人员来讲可能存在管理复杂的情况，所以学习如何设计、管理、优化 MongoDB 文档就十分的有必要了。 BSON存储 JSON 文档是一个抽象的概念，本身是在 JavaScript 中以对象的方式存在。 但是我们后面发现许多的后台应用都需要与前端打交道，渐渐的 JSON 成为了一种标准，但是 JSON 也有很多缺点，这里不再赘述，在数据类型一章节中已有详细介绍。 那么 BSON 到底是什么，BSON 是一种轻量的二进制格式，JSON 则是人们肉眼可识别的UTF8字符串格式。 BSON 对于 JSON 来讲有以下几点突破： 效率，BSON 设计能更好表示数据，占用更少的空间，大多数时候，BSON 要比 JSON 更加高效（传输、存储大数据） 可遍历性，BSON 牺牲了空间效率，但是更容易遍历，如在字符串前面加入该字符串的长度，而不是在结尾处使用一个终结符，这对 MongoDB 的内嵌文档十分有用 性能，BSON 的编码解码速度很快，由 C 的风格表现形式来表示某一类型，在大多数编程语言中都非常快 设计基础 设计误区 在关系型数据库中搭建数据模型的三要素为实体、属性、关系。 并且对于关系型数据库的数据模型三层深度来讲，具有概念模型、逻辑模型、物理模型等逐步细化的过程。 但是对于 MongoDB 来讲，集合的无状态性常常会让人陷入 3 个误区： 不需要模型设计，业务上有什么新的字段就直接丢进去 用一个超级大的文档来组织所有数据 MongoDB 不支持关联或者事务（4.x 版本以完美支持事务了），所以某些关键性的应用场景不应该使用 MongoDB 以上三点观念，均是错误的。 设计理念 JSON 文档设计不需要遵从第三范式，从而允许冗余的发生。 因此，概念建模和逻辑建模之后，一般直接可以用于实际生产（不需要物理建模），这也是无模式的一种特点。 如下，在 JSON 文档数据模型中，我们并不需要细分需要多少张表、需要哪些字段，而是直接添加即可： { \"name\" : \"Jack\", \"gender\" : \"male\", \"phones\" : [ {\"type\" : \"work\", \"number\" : 653897}, {\"type\" : \"home\", \"number\" : 793812} ], \"hobby\":[\"game\", \"music\"], \"addr\":[ {\"type\" : \"work\", \"province\" : \"JiangSu\", \"city\" : \"NanJing\"}, {\"type\" : \"home\", \"province\" : \"ZheJiang\", \"city\" : \"HangZhou\"} ] } 这是我随意想出来的一种数据格式，如果是关系型数据库则需要大量的时间来进行表的划分，字段的约束等。 对于关系型数据库来讲，物理建模可能会花费较大的时间，并且在逻辑建模时也要充分的给予考虑，整体设计较为复杂。比如，对模型的关系来讲，关系型数据库会采用关联、主外键约束等，而对 MongoDB 来讲，则只需要内嵌数组或者引用字段即可。 MongoDB 文档的设计原则必须遵循，性能和开发易用性，关于易于管理这个点来说相较于关系型数据库并没有那么方便，但是也要做好相应的设计。 设计实践 基础模型 MongoDB 中整个模型建立可分为 4 个步骤： 根据业务需求推导出概念模型与逻辑模型 列出实体关系 决定内嵌方式，开始进行物理建模 完成基础模型构建 首先，我们以一个简单的需求来开始，要建立一个学生信息库，此时仅仅在概念模型上，我们有了一个思维，原来要建立一个学生信息库，那肯定是以学生为中心。 其次，我们需要对该需求进行细分，建立逻辑模型，比如学生是否应该有学号？班级？课程？教师？成绩？部门？以及它们的关系是什么，如： 学号与学生是一对一 成绩与学生是一对一 班级与学生是一对多 部门与学生是多对多 课程与学生是多对多 教师与学生是多对多 建立物理模型之前，首先要有 3 个大方向： 对于一对一关系来讲，使用内嵌文档或直接在顶层书写，不涉及数据冗余 对于一对多关系来讲，使用数组嵌文档，不涉及数据冗余 对于多对多关系来讲，使用数组嵌文档，使用冗余表达多对多关系 需要注意的是，如果内嵌过多，文档大小超过 16MB 的话是会写入不进去的，这个容易让人忽视的点应该也在考虑范围中。 有了大的方向，开始建立物理模型： { # 基础信息 \"studentName\" : \"Jack\", \"studentAge\" : 18, \"studentGender\" : \"male\", # 一对一：一个学生只能拥有一个学号以及成绩单 \"studentId\": 33023, \"grades\": { \"English\" : 98, \"Mathematics\" : 88, \"Language\" : 92 }, # 一对多：对学生来讲，和班级的关系一般是学生仅有一个班级，而一个班级可以有多个学生 # 此时我们在学生方面使用内嵌文档即可，因为学生对班级是1。如果一个一对多关系学生是多的一方，则考虑使用 # 数组+内嵌文档 \"class\" : { \"name\" : \"Grade Three Class One\", \"principal\" : \"teachLiu\" }, # 多对多：采用数组+内嵌文档的形式实现 \"department\" : [ {\"name\" : \"dep01\"}, {\"name\" : \"dep02\"}, ], \"course\" : [ {\"type\" : \"English\", \"teacher\" : \"teachWang\"}, {\"type\" : \"mathematics\", \"teacher\" : \"teachLi\"}, {\"type\" : \"Language\", \"teacher\" : \"teachZhang\"}, ] } # 在上述示例中并未建立与教师的任何直接关系 # 而是通过班级负责人、课程教师等信息与老师建立间接关系 模型引用 模型的改动要依照实际情况来决定。 对于上述模型来讲，一个文档中存储的数据量级较少，因此改动可能较少。 而对于其他业务的模型，如一个内嵌文档可能达到上百万级别的数据且变更比较频繁时，可以考虑将该内嵌文档使用单独的集合进行存放，使用模型引用的方式进行查询。 如，最开始的时候文档模型是这样的，这是一个网购公司对一年中订单的成交记录： { \"years\" : \"xxxx年\", \"totalSales\" : 9392939, \"netProfit\" : 6302938, \"orders\" : [ {\"orderId\" : \"xxxx-xxxx-xxxx-xxxx\", \"date\" : \"xxx\", \"price\": 100}, {\"orderId\" : \"xxxx-xxxx-xxxx-xxxx\", \"date\" : \"xxx\", \"price\": 100}, {\"orderId\" : \"xxxx-xxxx-xxxx-xxxx\", \"date\" : \"xxx\", \"price\": 100}, ] } 一个文档中存放一年的记录，显然设计十分的不合理，如果订单量过多，则可能导致文档大小超过 16MB 的限制。 在这里给出的模型改动建议是将 orders 这个内嵌字段中数据作为一个新的集合存放，一个新的集合代表一年的订单记录，一个集合中最多有 12 个文档代表每月的订单记录。 # 订单年份表 -------------------------------------------------------------------------------- { \"years\" : \"2008年\", \"totalSales\" : 9392939, \"netProfit\" : 6302938, \"orders_ids\" : [1, 2, 3, 4, 5, 6] # 月份 } -------------------------------------------------------------------------------- { \"years\" : \"2009年\", \"totalSales\" : 6345339, \"netProfit\" : 3242938, \"orders_ids\" : [1, 2, 3] } -------------------------------------------------------------------------------- # 新集合 某年订单月份表 -------------------------------------------------------------------------------- { order_id : 1, # 1月份 orders : [ {\"orderId\" : \"xxxx-xxxx-xxxx-xxxx\", \"date\" : \"xxx\", \"price\": 100}, {\"orderId\" : \"xxxx-xxxx-xxxx-xxxx\", \"date\" : \"xxx\", \"price\": 100}, ] } -------------------------------------------------------------------------------- { order_id : 2, # 2月份 orders : [ {\"orderId\" : \"xxxx-xxxx-xxxx-xxxx\", \"date\" : \"xxx\", \"price\": 100}, {\"orderId\" : \"xxxx-xxxx-xxxx-xxxx\", \"date\" : \"xxx\", \"price\": 100}, ] } -------------------------------------------------------------------------------- 在查询时，我们可以使用聚合进行查询，利用 $lookup 进行多表关联查询： db.年份表.aggregate({ { $match : { years : {$eq : \"xxxx年\"} }, $lookup : { from : \"某年订单月份表\", localField : \"orders_ids\", foreignField : \"order_id\", as : \"别名（用作内嵌文档显示）\", } } }) 示例演示： db.yearOrders.aggregate([ { '$match': { 'years': { '$eq': '2008年' } } }, { '$lookup': { 'from': 'year2008Orders', 'localField': 'orders_ids', 'foreignField': 'order_id', 'as': 'order' } } ]) 查出的结果： [ { _id: ObjectId(\"6050297b78923004692c9966\"), years: \"2008年\", totalSales: 9392939, netProfit: 6302938, orders_ids: [1, 2, 3, 4, 5, 6], order: [ { _id: ObjectId(\"6050299778923004692c9967\"), order_id: 1, orders: [ { orderId: \"xxxx-xxxx-xxxx-xxxx\", date: \"xxx\", price: 100 }, { orderId: \"xxxx-xxxx-xxxx-xxxx\", date: \"xxx\", price: 100 }, ], }, { _id: ObjectId(\"6050299e78923004692c9968\"), order_id: 2, orders: [ { orderId: \"xxxx-xxxx-xxxx-xxxx\", date: \"xxx\", price: 100 }, { orderId: \"xxxx-xxxx-xxxx-xxxx\", date: \"xxx\", price: 100 }, ], }, ], }, ]; 设计模式 分桶设计 在某些特定的场景中，如数据点采集频繁，数据量多的业务设计文档时可采用分桶设计。 如下所示，这是一个监控，每分钟录入一条文档，文档格式如下： { \"name\" : \"xxxx监控\", \"startTime\" : \"xxxx年xx月xx日xx时xx分xx秒\", \"status\" : { \"a1\" : \"xxx\", # 不同的监控项 \"b1\" : \"xxx\", \"c1\" : \"xxx\", } } 这样每分钟都会录入一些重复信息，如 name，startTime 等，这使得对索引的建立等都会占据很大的空间。 使用分桶设计，每个小时生成一个新的文档进行录入，期间不断在已有文档上插入数据： { \"name\" : \"xxxx监控\", \"startTime\" : \"xxxx年xx月xx日xx时\" \"status\" : [ {\"a1\" : \"xxx\", \"b1\" : \"xxx\", \"c1\" : \"xxx\", \"startTime\" : \"xx分xx秒\"}, # 代表一分钟的信息 {\"a1\" : \"xxx\", \"b1\" : \"xxx\", \"c1\" : \"xxx\", \"startTime\" : \"xx分xx秒\"}, {\"a1\" : \"xxx\", \"b1\" : \"xxx\", \"c1\" : \"xxx\", \"startTime\" : \"xx分xx秒\"}, ... ] } 列转行 列转行的设计通常应用在大文档，具有很多字段，且这些字段很多都要建立索引时使用。 我们以上面学生表的情况举例，为什么课程要这样设计： \"course\" : [ {\"type\" : \"English\", \"teacher\" : \"teachWang\"}, {\"type\" : \"mathematics\", \"teacher\" : \"teachLi\"}, {\"type\" : \"Language\", \"teacher\" : \"teachZhang\"}, ] 而不设计成这个样子呢？ \"course\" : { \"English\" : \"teachWang\", \"mathematics\" : \"teachLi\", \"Language\" : \"teachZhang\", } 这是因为第一种方案更加利于索引的管理，如果采用第二种方案建立索引时则需要向下面这样建立: db.students.createIndex({\"course.English\" : 1}) db.students.createIndex({\"course.mathematics\" : 1}) db.students.createIndex({\"course.Language\" : 1}) 如果后面有新的课程，则需要重复进行建立，而使用第一种方案你只需要这样建立索引即可： db.students.createIndex({\"course.type\" : 1}) 版本号 可能该开始的时候你的业务中没有 email 字段。 过了很久之后第二版时又上线了 email 字段。 如何进行管理呢？添加一个版本号字段即可，如下所示： { \"name\" : \"Jack\", \"age\" : 18, \"gender\" : \"Male\", \"phone\" : 382734, } { \"name\" : \"Jack\", \"age\" : 18, \"gender\" : \"Male\", \"phone\" : 382734, \"email\" : \"xxxx@gmail.com\", \"schema_version\" : \"2.0\" } 近似计算 对于某些不需要准确性结果的统计操作，可以采用近似计算的方式进行解决。 如，网站点击频率，如果每一个用户点击一次都进行一次写入操作的话，无疑数据库压力会很大。 使用近似计算解决这个问题，生成随机数 0-9，则有十分之一的概率随机数是 0，如果随机数是 0 直接将点击量 + 10 即可： 预聚合 如果要统计某个商品今天卖出去了多少，这个星期卖出去了多少等类似的场景，可以通过预聚合字段来解决频繁写入的问题： { \"_id\" : 1, \"柴\" : 9239, \"米\" : 8328, \"油\" : 232, \"盐\" : 3282 } 更新时： db.collection.update( {_id : 1}, { $inc : { \"柴\" : +1, \"米\" : +1, \"油\" : +1, \"盐\" : +1 } } ) Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:48 "},"数据库专栏/MongoDB/复制集群.html":{"url":"数据库专栏/MongoDB/复制集群.html","title":"复制集群","keywords":"","body":"功能概述 MongoDB的复制集rs是MongoDB自带的一种高可用策略，其本身是一种单活架构，搭建条件最少为1主2从，可由单机多实例构成。 值得一提的是，rs自带读写分离机制，但是需要我们手动指定。 以下是rs最小架构的草图： 基础知识 故障恢复 当rs成功运行时，会在具有投票权的节点之间互相发送心跳检测。 当某一个节点5次心跳检测没有回应后，rs会认为该节点已经失联，如果失联的是primary，那么secondary节点之间会发起新的选举，重新选出新的primary节点。如果失联的是secondary，则不会产生新的选举。 选举过程基于RAFT一致性算法实现，选举成功的必要条件是大多数投票节点都处于存活状态。 一个rs中最多有50个节点，但是具有投票权的节点至多只能有7个。 投票机制 为什么MongoDB复制集必须要1主2从呢？其实也不一定，但是有一个前提即确保节点数必须为单数。 在primary库宕机后，rs会通过新的投票机制来选举出新的primary库，如果复制集的节点数是双数，则可能会出现出平票的情况。 在某些场景中，我们可能只需要1主1从外加投票节点的一种机制（这种情况比较少见，更常见的是1主1从1延迟从），则可以通过某些参数进行配置。 注意：投票节点永不参与竞选，也不会存储任何业务数据，仅负责投票 如果想成为新的primary节点，则该secondary节点至少要有下面几点要求： 能够与大多数节点建立链接 具有较新的oplog，与已宕机的主节点oplog差异最小 根据配置项的优先级来进行选举（如果有的话） 复制过程 当一个修改操作，无论是插入、删除、或者更新，到达primary节点后，与MySQL中日志优先写的策略一样，这些变更记录会存储在一个oplog的文件中（类似于MySQL的binlog）。 secondary节点通过在primary节点上打开tailable游标，不断获取新进入主节点的oplog，并在自己的数据上进行回放操作，以此保证跟主节点的数据一致性。 大体思路和MySQL差不多，可以查看之前MySQL的主从搭建文章。 节点配置 常见的节点配置有以下几种： 节点投票权：是否具有投票权 选主优先级：是否能优先成为新主，优先级为0的节点无法参与竞选 隐藏节点(hidden)：只复制数据，但对应用不可见，隐藏节点可以具有投票权，但优先级必须为0 延迟节点(delay)：复制主库N秒之前的数据，保持时间差防止误操作，一般来说延迟节点也会设置为隐藏节点 投票节点(arbiter)：仅投票，不存储业务数据，不提供任何服务，不参与选主 搭建过程 地址规划 为了能够更好的贴近实际业务场景，所以我们选择3台虚拟机来搭建rs服务。 以下是配置详情： 作用 IP地址 服务端口 操作系统 MongoDB版本 配置 Primary 192.168.0.120 27017 Centos7.3 基础设施服务器 4.4 2核CPU 2G内存 20G硬盘 Secondary 192.168.0.130 27017 Centos7.3 基础设施服务器 4.4 2核CPU 2G内存 20G硬盘 Secondary 192.168.0.140 27017 Centos7.3 基础设施服务器 4.4 2核CPU 2G内存 20G硬盘 前期准备 1）创建必要目录： $ mkdir -p /db/mongodb44/27017/{conf,logs,data} 2）安装MongoDB： $ tar -xvf ./mongodb-linux-x86_64-rhel70-4.4.10.tgz $ cp -a ./mongodb-linux-x86_64-rhel70-4.4.10/bin/ /db/mongodb44/27017/ $ mv ./mongodb-linux-x86_64-rhel70-4.4.10.tgz /tmp 3）创建管理用户： $ groupadd mongod $ useradd -g mongod mongod 4）书写配置文件： $ vim /db/mongodb44/27017/conf/mongod.conf systemLog: destination: file path: \"/db/mongodb44/27017/logs/mongod.log\" logAppend: true storage: dbPath: \"/db/mongodb44/27017/data\" journal: enabled: true directoryPerDB: true processManagement: fork: true net: bindIp: 0.0.0.0 port: 27017 setParameter: enableLocalhostAuthBypass: false replication: oplogSizeMB: 2048 replSetName: rs0 # 复制集名称，记录下来 # 如果开启了权限认证，那么就需要在下面打开 # security: # authorization: enabled 5）添加环境变量： $ vim /etc/profile export PATH=/db/mongodb44/27017/bin:$PATH $ source /etc/profile 6）制作sys服务： $ cat > /etc/systemd/system/mongod.service 7）用户目录授权： $ chown -R mongod:mongod /db/mongodb44/ 8）启动MongoDB服务： $ systemctl enable mongod.service $ systemctl start mongod.service 集群搭建 登录primary主库，开始进行进群搭建： $ mongo 创建集群配置文件： > config = { \"_id\" : \"rs0\", members : [ {\"_id\" : 0, \"host\" : \"192.168.0.120:27017\"}, {\"_id\" : 1, \"host\" : \"192.168.0.130:27017\"}, {\"_id\" : 2, \"host\" : \"192.168.0.140:27017\"}, ] } # 第一个就是primary 初始化集群： > rs.initate(config) 接下来会的标志位会从SECONDARY转变为PRIMARY： rs0:SECONDARY> rs0:PRIMARY> 登录secondary1和secondary2的从库，查看标志位是否改变： $ mongo --host 192.168.0.130 --port 27017 rs0:SECONDARY> $ mongo --host 192.168.0.140 --port 27017 rs0:SECONDARY> 如果发生改变，在secondary1和secondary2中输入以下命令，启动复制： rs0:SECONDARY> rs.secondaryOk() # 旧版命令：rs.slaveOk() 接下来进行一次测试，在primary上创建一个集合，查看secondary1和secondary2是否会成功复制： rs0:PRIMARY> use db1 switched to db db1 rs0:PRIMARY> db.coll.insert({\"name\" : \"Jack\"}) 复制成功，集群搭建已经完成了： rs0:SECONDARY> show dbs admin 0.000GB config 0.000GB db1 0.000GB local 0.000GB 集群管理 节点管理 查看复制集状态的三个基本命令，需要登录主库中操作： 命令 描述 rs.status() 查看整体复制集状态 rs.isMaster() 查看所有的节点信息，方便查找主节点 rs.conf() 查看复制集的配置信息 在主库中你可以添加和删除任意节点，命令如下所示： 命令 描述 rs.add(“ip:port”) 新增从节点 rs.remove(“ip:port”) 删除从节点 rs.addArb(“ip:port”) 新增仲裁节点（投票节点） 如果要对配置文件中进行修改，如设置延迟节点等，可使用如下的方式操作： # 复制配置到全局变量中 cfg = rs.conf() # 选取节点，修改配置信息，下标从0开始，2就是第3个节点 # 选主优先级 cfg.members[2].priorty = 0 # 隐藏节点 cfg.members[2].hidden = true # 设定延迟节点 cfg.members[2].slaveDelay= 60*60*4 # 4小时 # 应用配置项 rs.reconfig(cfg) 如果要监控主从延时状态，请在延时从库下执行以下命令： rs.printSlaveReplicationInfo() 读写分离 关于读写分离、应用层接入等事宜，请查看下篇文章。 MongoDB事务相关 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:48 "},"数据库专栏/MongoDB/事务相关.html":{"url":"数据库专栏/MongoDB/事务相关.html","title":"事务相关","keywords":"","body":"前言概述 MongoDB在4.0版本之后已经完美支持事务了。 因此MongoDB可以用作核心业务的数据库，这是其他NoSQL产品望尘莫及的，也是MongoDB的一大特性。 在前面的文章中，我们介绍了MongoDB复制集的搭建，在本章节中我们将着重介绍MongoDB如何保证复制集中各个节点数据一致性，并且对读写分离进行介绍。 那么，Lets’ go!! readPreference 参数释义 这个参数名很有趣，读的偏好，其实说白了就是读写分离中应用需要从哪个节点库读数据的指定方式。 它的可选值如下： primary ：从主节点读，并且只从主节点读 primaryPreferred ：优先选择主节点读，当主节点不可用时则选择从节点 secondary ：只选择从节点 secondaryPreferred ：优先选择从节点读，当从节点不可用时则选择主节点 nearest ： 选择最近的节点，无论主从 场景选择 用户下单后立马要跳转到订单详情页，此时选择主节点读或者优先从主节点读，因为此时从节点可能还未复制到订单信息。 用户查询自己下过的订单，可以选择在从节点上读或者优先从从节点上读，查询历史订单对时效性通常没有太高的要求。 生成报表，选择从节点读取，生成报表的操作对时效性要求不高，但是对资源需求大，可在从节点单独处理，避免对线上用户造成影响。 将用户上传的图片分发到全世界，让各地用户都能就近读取，此时选择最近读。 标签读取 标签读取常用于在一个集群中不同的节点具有不同功能的情况下使用。 如下图所示，有5个节点的复制集，3个节点是属于OLTP，服务前台线上应用，2个节点属于OLAP，专门做数据分析或者处理，此时就可以为这个集群中的2组节点打上不同的标签： 在读取不同数据时，通过标签读取指定组内的数据。 writeConcern 参数释义 写关注，这个参数名字用的很好，在MongoDB中，当主库发生变更操作时，writeConcern参数决定该变更操作作用到多少节点上才算成功。 它的可选值如下所示： 0 ： 主库发起变更操作，不关心是否成功被从库复制，此变更操作视为完成 1 ： 主库发起变更操作，该操作必须被指定节点数成功复制后才算该操作完成 majority : 主库发起变更操作，该操作必须被大多数节点成功复制后才算该操作完成 all : 主库发起变更操作，该操作必须被所有节点成功复制后才算该操作完成 默认的值 writeConcern的默认值是0，如果在3个节点上都不做任何设置的情况下，主库迎来一次变更操作，那么它不会关心这个操作是否能被从库成功复制，如图所示： 虚线部位是指，有可能从库复制了，有可能还没来得及复制。 majority 当wirteConcern的值设置为majority后，该操作必须被大多数节点成功复制后才算该操作完成，如图所示： all 当wirteConcern的值设置为all后，该操作必须被所有节点成功复制后才算该操作完成，如图所示： journal writeConcern参数决定变更操作到达多少节点才算成功。 而journal参数则定义如何才算成功，如下所示： true : 写操作必须落到journal文件中才算成功 false : 写操作到达内存即算作成功 说实话，这个journal日志好像是与MySQL中的redolog很像，下面是官方定义说明： WiredTiger使用检查点提供磁盘上数据的一致视图，并允许MongoDB从上一个检查点恢复 但是，如果MongoDB在检查点之间意外退出，则需要日志记录以恢复在最后一个检查点之后发生的信息 这玩意儿是WiredTiger所提供的预写日志，并不是常说的工作日志 如果该参数为true，则如下图所示： readConcern 参数释义 读关注，在readPreference指定了读取节点后，readConcern决定读取这个节点上的那些数据，与关系型数据库的隔离级别相似，具体如下： available ： 读取所有可用的数据 local ： 读取所有可用，且属于当前分片的数据 majority ： 读取在大多数节点上提交完成的数据（类似于可重复读的界别，也是MySQL默认级别） linearizable ：串行化读取 snapshot ： 读取最近快照中的数据 available与local 在复制集中，available与local是没有区别的，两者区别主要体现在分片集上。 如果一个chunk x正在从shard1向shard2迁移，整个迁移过程中chunk x中的部分数据会在shard1和shard2中同时存在，但源分片shard1仍然是chunk x的负责方，这意味着： 所有对chunk x的读写操作仍然进入shard1 config中记录的信息chunk x仍然属于shard1 如果此时读取shard2，则会体现出available与local的区别： local ：只取应该由shard2负责的数据，则不包含chunk x available ： shard2上有什么就读什么，包括chunk x 图示如下所示： 在两个参数的注意事项： 虽然看上去总是应该选择local，但毕竟对结果集进行过滤会造成额外消耗，在一些无关紧要的场景下（例如统计），也可以考虑available MongoDB版本小于或等于3.6不支持对从节点使用{ readConcern : “local” } 从主节点读取数据时默认readConcern是local，在从节点读取数据时默认readConcern是available majority 从一个节点中读取数据时，该参数表示只读取在大多数节点上提交完成的数据。 通过MVCC机制在所有节点上维护了一个版本快照，在指定该参数读取时只有被大多数节点确认过的数据才会加入这个版本快照。 快照持续到没有人使用时才会被删除。 总之majority是一个非常不错的选择项，它和local的区别如下： 主库读的时候，local可以直接查询到写入的数据 主库读的时候，majority则只能查询到已经被多数节点确认过的数据 并且使用majority可以有效避免脏读。 linearizable 串行化读取，效率较慢，不做介绍。 snapshort 只有在多文档事务中生效。 如果设置为该级别，将不会出现幻读，不会出现脏读，不会出现不可重复读。 因为所有的读都使用同一个快照，直到事务提交时该快照才会被释放。 三者使用 writeConcern 一般来讲，对于writeConcern参数我们设置为majority即可，这是性能与安全的最中和的选择。 一定不要将writeConcern设置为等于总节点数，因为一旦有一个节点故障，所有写操作都将失败。 writeConcern参数虽然会增加些操作的延迟时间，但并不会显著增加集群压力，因此无论是否等待，变更操作都最终会将作用到所有节点上，设置writeConcern参数只是为了让变更操作等待复制后再返回而已。换而言之，该参数缩减了非延迟从库与主库之间的oplog的差距，它与半同步复制有相似之处。 通过MongoDB的链接串参数指定写入的wirteConcern策略： mongodb://主库地址:端口,从库地址:端口,从库地址:端口/?authSource=验证库&replicaSet=复制集名称&w=majority&wtimeoutMS=5000 # wtimeoutMS写入的超时时间，单位是毫秒 在shell中指定每次写入操作的writeConcern策略： db.collection.insert({ \"k\" : \"v\" }, {\"writeConcern\" : {\"w\" : \"majority\", \"j\" : true}}) # 可在update，insert中指定 # j就是journal readPreference 通过MongoDB的链接串参数指定读取的readPreference策略： mongodb://主库地址:端口,从库地址:端口,从库地址:端口/?authSource=验证库&replicaSet=复制集名称&readPreference=secondary 在shell中指定每次读取操作的readPreference策略： db.collection.find().readPref(\"secondary\") 在使用时，要注意以下事项： 指定readPreference时也要注意高可用问题，例如将readPreference指定为primary，则在故障转移期间导致没有节点可读，如果业务允许，尽量选择primaryPreferred。 使用tag时也会遇到同样的问题，如果只有一个节点拥有一个特定的tag，则再这个节点失效时将导致无节点可读，如线上节点的tag应该保持多组，具有同样的tag readConcern 通过MongoDB的链接串参数指定读取的readConcern策略： mongodb://主库地址:端口,从库地址:端口,从库地址:端口/?authSource=验证库&replicaSet=复制集名称&readConcernLevel=majority 在shell中指定每次读取操作的readConcern策略： db.collection.find().readConcern(\"level\" : 'majority' ) ACID多文档事务 使用说明 以下是多文档事务的使用说明： var session = db.getMongo().startSession() session.startTransaction({readConcern: { level: 'majority' },writeConcern: { w: 'majority' }}) var coll = session.getDatabase('test').getCollection('user'); coll.update({name: 'Jack'}, {$set: {age: 18}}) // 成功提交事务 session.commitTransaction(); // 失败事务回滚 session.abortTransaction(); Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:48 "},"数据库专栏/MongoDB/变更流.html":{"url":"数据库专栏/MongoDB/变更流.html","title":"变更流","keywords":"","body":"功能概述 Change Stream（3.6新增）与MySQL中的触发器概念很像，但是又有一些区别，且实现原理完全不同： Change Stream 触发器 触发方式 异步 同步（事务保证） 触发位置 应用回调事件 数据库触发器 触发次数 每个订阅事件的客户端 1次 故障恢复 从上次断点重新触发 事务回滚 对于触发器来讲，触发器是包含在事务期间的，触发器中进行回滚该事务也会进行回滚，是属于同步操作。 而对于变更流来讲，它的事件是属于异步的，这是两者较大的一个区别。 实现原理 变更流基于oplog实现，它会在oplog上开启一个tailable cursor(尾部游标)来追踪所有复制集上的变更操作，最终调用应用中定义的回调函数。 被追踪的变更时间主要包括： insert/update/delete collection.drop rename dropDatabase invalidate：以上操作会导致invalidate被处罚，并关闭change stream 使用条件 变更流只推送已经在大多数节点上提交的变更操作，即{ readConcern : {“level” : “majority”}}，如果该readConcern的配置项不是majority，则该集群无法使用变更流。 除此之外，对于不是{ writeConcern : {“w” : “majority”}}的变更操作，也不会触发变更流。 使用方式 对一个集合进行启动监听订阅，当某些操作发生后执行管道中对应的处理逻辑，如下所示： > pipeline = [ {'$match': {'fullDocument.username': 'alice'}}, {'$addFields': {'newField': 'this is an added field!'}} ] > db.collection.watch(pipeline) 在上述示例中，过滤出所有名字为alice的文档，并且在变更操作发生后对其新增字段。 配置变更流时，可提供的管道步骤如下所示： $addFields $match $project $replaceRoot $replaceWith - 从MongoDB 4.2开始可用 $redact $set - 从MongoDB 4.2开始可用 $unset - 从MongoDB 4.2开始可用 如果你想了解更多关于变更流的使用，请参阅官方中文文档 使用场景 变更流的使用场景较为广泛，下面的常见非常适用于使用变更流： 跨集群的变更复制：源集群中订阅变更流，如果有变更操作则立即写入目标集群 微服务联动，当一个微服务变更数据库时，其他微服务得到通知并作出相应的变更 其他需要系统联动的场景 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:48 "},"数据库专栏/MongoDB/分片集群.html":{"url":"数据库专栏/MongoDB/分片集群.html","title":"分片集群","keywords":"","body":"架构探究 架构图 MongoDB分片集群与MySQL中的水平分表类似。 以下是一个较为完美的分片集群部署策略图： 集群组成 名词解释： mongos ：路由节点，提供集群单一入口，转发application的请求至所有分片节点上，上图中3个mongos是保证了高可用性，mongos之间不用做复制集 config ：配置节点，存储分片的配置策略，如分片开始位置，分片结束位置等，是整个分片集群的配置信息存储位置，上图3个config是为了保证高可用性 shard ：分片节点，以复制集为单位，对于分片节点来说，横向扩展最大可支持1024个，每个分片节点上的数据不允许重复，所有分片在一起才能完整的进行工作 分片集群由多个分片节点+配置节点+路由节点构成，特点如下： 分片集群对application是透明的，没有任何特殊处理 分片集群对于数据来说会有自动均衡策略 如果要对分片集群进行扩容，可在线上直接进行扩容而无需下线 MongoDB当前提供3种分片策略 分片相关 分片策略 MongoDB目前提供3种分片策略，如下所示： 基于范围，范围查询性能良好，侧重于读的性能，但是可能造成数据分布不均匀 基于Hash，数据分布均匀，侧重于写的性能，但是范围查询效率低 基于zones / tag，适用于大范围的全球性业务 基于范围分片的图示： 基于Hash分片的图示： 基于Zones的分片： 分片计算 如何计算当前业务需要多少个分片？下面是计算法则： 使用存储数据总量 / 单个服务器可挂载的容量 如：8TB / 2TB = 4 使用工作集的大小 / 单个服务器的内容容量*0.6（不可能全部占满） 如：400GB / (256G * 0.6) = 3 使用最高并发总数 / 单个服务器平均并发量*0.7（一个复制集群是有损耗的） 如：3000 / (9000 * 0.7) = 6 最终的分片数量采取3个结果中的最大值: max(4, 3, 6) = 6 对于分片的数据来说，每个分片节点的数据量都不应该超过3TB 对于分片的索引来说，必须保证常用的索引字段能够存放至内存中（查看文档索引，结合物理内存大小做计算） 分片名词 一些分片中常见的概念性名词，概念由小到大： 片键 shard key ：文档中的一个字段，由于MongoDB的分片类似于水平分表，所以我们必须指定拆分的字段列 文档 doc ：包含shard key的一行数据（对应到关系型数据库中，一个文档就是一行记录） 块 Chunk ： 一个块包含多个文档，每个块的大小为64MB 分片 Shard ： 一个分片节点中包含多个块，没有大小限制，但应该尽量保证单个分片的数据量在3TB下 集群 Cluster ： 一个分片集群中包含多个分片节点，通常情况下一个分片集群也必须是一个复制集群（保证高可用） 在选择片键时，要遵循以下几点原则，为了方便描述我均采用关系型数据库的概念来举例： 取值应该基数大：如果对一个表来说，水平拆分时如果按照gender字段进行拆分，那么即使拆分成多个表，单表的数据量级依旧很大，最好的选择是根据id进行拆分 取值应该分布均匀：如果对一个学生表来进行水平拆分，片键选择是年龄，年龄的基数虽然可以达到1-100，但是要注意业务场景，学生表的主要数据年龄为12-16岁（中学），这依然会造成单表的数据量级大的问题，所以按照年龄来进行拆分并不合适 片键应该利于分散写：集中读：如果片键选择不合理，对于写来说则可能造成写入的数据的Chunk块先到第一个分片节点中，发现位置不对再向第二个分片节点进行迁移的情况，造成性能损耗，多做了无用功。而对于读来说则可能会导致扫描所有分片节点的操作，不能准确定位，造成查询效率低的问题 用以下几种情况来举例MongoDB中片键的选择案例，这里与关系型数据库有较大的差异，建议不要做横向对比。 情况1，按照_id进行范围分片： 从基数的角度来看，使用_id进行分片，因为_\\id不会重复，所以是合理的 从写的角度看，由于_id总是递增的，新插入的数据总会到达最后的一个分片节点，是合理的 从读的角度看，用于MongoDB的_id与MySQL的id不同，因此没有人会用_id作为查询条件，这可能导致会扫描所有分片节点，读的性能极低，是不合理的 情况2，按照phone进行hash分片： 从基数的角度来看，phone永远不会重复，是合理的 从写的角度来看，使用hash分片，能够准确的将数据插入到对应的分片节点中，是合理的 从读的角度来看，使用phone作为查询条件虽然可以很快的拿出单个用户的数据，但是对于范围查询来讲效率会偏慢，这是不合理的 情况3，按照用户的id（不是_id）和phone进行分片： 从基数的角度来看，phone与用户id不会重复，是合理的 从写的角度来看，和上面一样，是合理的 从读的角度来看，无论是使用用户id或者phone进行读取，都能较快的拿出数据，是合理的 搭建过程 具体的搭建过程这里不再演示了，不过我找到一篇不错的MongoDB的分片集搭建文章，另外在搭建前保证每个服务器hostname不同应当是必要的。 点我跳转 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:48 "},"数据库专栏/MongoDB/备份恢复.html":{"url":"数据库专栏/MongoDB/备份恢复.html","title":"备份恢复","keywords":"","body":"mongodump 功能概述 mongodump能够在Mongodb运行时进行备份，它的工作原理是对运行的Mongodb做查询，然后将所有查到的文档写入磁盘。 但是存在的问题是使用mongodump产生的备份不一定是数据库的实时快照，如果我们在备份时对数据库进行了写入操作，则备份出来的文件可能不完全和Mongodb实时数据相等，必须配合oplog才能达到热备份的效果。 另外在备份时可能会对其它客户端性能产生不利的影响。 命令行中执行： $ mongodump --help 参数说明： 参数 描述 -h 指明数据库宿主机的IP -u 指明数据库的用户名 -p 指明数据库的密码 -d 指明数据库的名字 -c 指明collection的名字 -o 指明到要导出的文件名 -q 指明导出数据的过滤条件 -j 并行备份多个集合，默认4个 --port 端口号 --uri 使用链接字符串进行链接 --authenticationDatabase 验证库 --oplog 备份的同时备份oplog --gzip 压缩备份 注意，执行备份操作的用户应该是管理员用户。 全库备份 需要注意的是在进行全备时，必须关闭节点才能复制，否则复制的文件无效。 所以推荐在从节点上做备份。 也可以选择db.fsyncLock()进行节点锁定，在备份完成后不要忘记db.fsyncUnlock()进行解锁（不推荐）。 命令如下： $ mongodump -uroot -p密码 --port 27018 --authenticationDatabase admin -o /mongodb/backup/ --oplog 单库备份 命令如下： $ mongodump -uroot -p密码 --port 27018 --authenticationDatabase admin -d 库名 -o /mongodb/backup/ --oplog 单表备份 备份某个库下的某个集合： $ mongodump -uroot -p密码 --port 27018 --authenticationDatabase admin -d 库名 -c 集合名 -o /mongodb/backup/ --oplog 压缩备份 命令如下，以全库示例： $ mongodump -uroot -p密码 --port 27018 --authenticationDatabase admin -o /mongodb/backup --gzip --oplog 备份目录 在备份完成后会获得以下的目录： |- backup |---- admin |-------- system.version |-------- system.version |---- oplog.bson # oplog |---- 库名 |-------- 集合名.bson # 备份的数据文件 |-------- 集合名.metadata.json # 集合元数据 mongorestore 功能概述 用于恢复由mongodump备份的文件。 命令行中执行： $ mongorestore --help 参数说明： 参数 描述 -h 指明数据库宿主机的IP -u 指明数据库的用户名 -p 指明数据库的密码 -d 指明数据库的名字 -c 指明collection的名字 -j 并行恢复多个集合，默认4个 --port 端口号 --uri 使用链接字符串进行链接 --authenticationDatabase 验证库 --drop 在恢复时先执行删除命令（慎用） --gzip 恢复压缩备份 --oplogFile 指定需要恢复的oplog文件位置 --oplogLimit 恢复记录至某一时间点 --oplogReplay 恢复时也随着恢复oplog 恢复全库 命令如下： $ mongorestore -uroot -p密码 --port 27018 --authenticationDatabase admin --oplogReplay /mongodb/backup/ 恢复单库 命令如下： $ mongorestore -uroot -p密码 --port 27018 --authenticationDatabase admin -d 库名 --oplogReplay /mongodb/backup/库名 恢复单表 命令如下： $ mongorestore -uroot -p密码 --port 27018 --authenticationDatabase admin -d 库名 -c 表名 --oplogReplay /mongodb/backup/库名/表名.bson 恢复压缩 命令如下，恢复全库压缩： $ mongorestore -uroot -p密码 --port 27018 --authenticationDatabase admin --oplogReplay /mongodb/backup --gzip oplog 基本介绍 oplog仅用于复制集中，是一个定容集合，位于local库的db.oplog.rs中，其大小默认为磁盘空间的5%。 其中记录的是整个MongoDB实例一段时间内数据库的所有变更（插入/更新/删除）操作，当空间用完时新记录自动覆盖最老的记录。 由于oplog是一个定容集合，里面的内容会进行迭代更新，那么一组oplog的最大存活时长被称为窗口期。 想要查看当前的oplog时间窗口预计存活时间，可以使用以下命令： rs0:PRIMARY> use local rs0:PRIMARY> rs.printReplicationInfo() configured oplog size: 2048MB # 集合大小 log length start to end: 944secs (0.26hrs) # 预计窗口覆盖时间 oplog first event time: Fri Mar 19 2021 23:14:47 GMT-0700 (PDT) # 第一个时间点 oplog last event time: Fri Mar 19 2021 23:30:31 GMT-0700 (PDT) # 最后一个时间点 now: Fri Mar 19 2021 23:30:37 GMT-0700 (PDT) # 最新的时间点（跟随当前时间不短变化） 查看oplog相关信息： rs0:PRIMARY> db.oplog.rs.find().pretty() 信息如下，仅截取一条： { \"ts\" : Timestamp(1616220887, 1), \"h\" : NumberLong(0), \"v\" : 2, \"op\" : \"n\", \"ns\" : \"\", \"wall\" : ISODate(\"2021-03-20T06:14:47.449Z\"), \"o\" : { \"msg\" : \"initiating set\" } } 恢复某一时间点 背景：每天0点全备，oplog恢复窗口为48小时 某天，上午10点world.city业务表被误删除 恢复思路： 停应用挂维护页 找测试库 恢复昨晚全备 截取全备之后到world.city误删除时间点的oplog，并恢复到测试库 将误删除表导出，恢复到生产库 先全备数据库，首先模拟原始数据，在主库上插入： mongo --port 27017 use world for(var i = 1 ;i 全备，从从库上备份（非延迟）： rm -rf /mongodb/backup/* mongodump --port 27018 --oplog -o /mongodb/backup 再次模拟数据，主库插入： db.ci1.insert({id:1}) db.ci2.insert({id:2}) 上午10点，误删除world库下的ci表，主库删除： db.ci.drop() 备份现有的中oplog.rs表，从从库备份： mongodump --port 27018 -d local -c oplog.rs -o /mongodb/backup 截取oplog并恢复到drop()之前的位置，先登录原数据库： mongo --port 27017 use local db.oplog.rs.find({op:\"c\"}).pretty(); { \"ts\" : Timestamp(1553659908, 1), # oplog误删除时间点位置 \"t\" : NumberLong(2), \"h\" : NumberLong(\"-7439981700218302504\"), \"v\" : 2, \"op\" : \"c\", \"ns\" : \"wo.$cmd\", \"ui\" : UUID(\"db70fa45-edde-4945-ade3-747224745725\"), \"wall\" : ISODate(\"2019-03-27T04:11:48.890Z\"), \"o\" : { # 找操作 \"drop\" : \"ci\" } } 恢复备份+oplog cd /mongodb/backup/local/ cp oplog.rs.bson ../oplog.bson rm -rf /mongodb/backup/local/ # 先在本地测试库进行恢复 mongorestore --port 28017 --oplogReplay --oplogLimit \"1553659908:1\" --drop /mongodb/backup/ 如果恢复成功，导出测试库的全备，再恢复到线上主库。 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:48 "},"数据库专栏/MongoDB/数据迁移.html":{"url":"数据库专栏/MongoDB/数据迁移.html","title":"数据迁移","keywords":"","body":"mongoexport 将数据导出成JSON或者CSV格式，用于MongoDB中的数据向别的数据库产品进行迁移。 命令行中执行： $ mongoexport --help 参数说明： 参数 描述 -h 指明数据库宿主机的IP -u 指明数据库的用户名 -p 指明数据库的密码 -d 指明数据库的名字 -c 指明collection的名字 -f 指明要导出那些列 -o 指明到要导出的文件名 -q 指明导出数据的过滤条件 --port 端口号 --uri 使用链接字符串进行链接 --authenticationDatabase 验证库 示例，单表备份成JSON格式，从从库备份，需要管理员用户： $ mongoexport -uroot -p密码 --port 27018 --authenticationDatabase admin -d 库名 -c 表名 -o /mongodb/表名.json 示例，单表中某些字段备份成CSV格式，需要加--type=csv参数： $ mongoexport -uroot -p密码 --port 27017 --authenticationDatabase admin -d 库名 -c 表名 --type=csv -f 列1，列2，列3 -o /mongodb/表名.csv mongoimport 将格式为JSON或者CSV格式的数据文件进行导入，用于别的数据库产品中的数据向MongoDB进行迁移。 命令行中执行： $ mongoimport --help 参数说明： 参数 描述 -h 指明数据库宿主机的IP -u 指明数据库的用户名 -p 指明数据库的密码 -d 指明数据库的名字 -c 指明collection的名字 -f 指明要导入那些列 -j 并行导入，默认为1，使用 --numInsertionWorkers设置并行导入的数量 --port 端口号 --uri 使用链接字符串进行链接 --authenticationDatabase 验证库 --headerline 不导入第一行（列名） --file 要恢复的备份文件 示例，恢复JSON格式表到某一库中（推荐先恢复到测试库查看效果）： $ mongoimport -uroot -p密码 --port 28017 --authenticationDatabase admin -d 库名 -c 表名 /mongodb/备份文件.json 示例，恢复CSV格式表到某一库中，其中--headerline为第一行是列名，不需要导入：： $ mongoimport -uroot -p密码 --port 28017 --authenticationDatabase admin -d 库名 -c 表名 --type=csv --headerline --file /mongodb/备份文件.csv 示例，恢复CSV格式表中的记录到某一已有的集合中，没有第一行的列名字，自己指定： $ mongoimport -uroot -p密码 --port 28017 --authenticationDatabase admin -d 库名 -c 表名 --type=csv -f 列1,列2,列3 --file /mongodb/备份文件.csv 异构迁移 单表迁徙 从MySQL迁移到MongoDB。 将MySQL中的world数据库下的city表进行导出，并且导入到MongoDB。 第一步，设置MySQL输出文件的安全路径： $ vim /etc/my.cnf secure-file-priv= # =空为所有路径都是安全路径 重启数据库生效： $ systemctl restart mysqld.service 第二步，导出MySQL中world库下的city表： M > SELECT * FROM world.city INTO OUTFILE \"/tmp/city.csv\" FIELDS TERMINATED BY \",”； 第三步，处理备份文件，首先查看city表的表结构： M > DESC world.city +-------------+----------+------+-----+--------+-----------------+ | ID | int(11) | NO | PRI | NULL | auto_increment | | Name | char(35) | NO | | | | | CountryCode | char(3) | NO | MUL | | | | District | char(20) | NO | | | | +-------------+----------+------+-----+--------+-----------------+ 使用vim添加第一行的列名信息： $ vim /tmp/city.csv ID,Name,CountryCode,District 第四步，在MongoDB中导入备份文件： $ mongoimport -uroot -p密码 --port 28017 --authenticationDatabase admin -d world -c city --type=csv -f ID,Name,CountryCode,District --file /tmp/city1.csv 进入该库查看内容： > use world > db.city.find({CountryCode:\"CHN\"}); 其他知识 假如world下共有100张表，全部迁移到MongoDB中： M > select table_name ,group_concat(column_name) from columns where table_schema='world' group by table_name; M > select * from world.city into outfile '/tmp/world_city.csv' fields terminated by ','; M > select concat(\"select * from \",table_schema,\".\",table_name ,\" into outfile '/tmp/\",table_schema,\"_\",table_name,\".csv' fields terminated by ',';\") from information_schema.tables where table_schema ='world'; 在MySQL向文件输出时，可指定的语句如下： select * from test_info into outfile '/tmp/test.csv' fields terminated by ','　　　 # 字段间以,号分隔 optionally enclosed by '\"'　　 # 字段用\"号括起 escaped by '\"' 　　　　　　 # 字段中使用的转义符为\" lines terminated by '\\r\\n';　　# 行以\\r\\n结束 在MySQL中导入CSV文件时，可指定的语句如下： load data infile '/tmp/test.csv' into table test_info fields terminated by ',' optionally enclosed by '\"' escaped by '\"' lines terminated by '\\r\\n'; Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:48 "},"数据库专栏/MongoDB/开发指南.html":{"url":"数据库专栏/MongoDB/开发指南.html","title":"开发指南","keywords":"","body":"常用工具 以下是MongoDB中常用的工具： 软件模块 描述 mongod MongoDB数据库软件 mongo MongoDB命令行工具，管理MongoDB数据库 mongos MongoDB路由进程，分片环境下使用 mongodump / mongorestore 命令行数据库备份与恢复工具 mongoexport / mongoimport 命令行CSV/JSON导入与导出，用于异构平台迁徙 MongoDB Compass MongoDB的GUI管理工具 Ops Manager（企业版） MongoDB的集群管理软件 BI Connector（企业版） SQL解释器 / BI套件 MongoDB Charts（企业版） MongoDB可视化软件 Atlas（付费及免费） MongoDB云托管服务，赠送免费永久的基础复制集群 链接方式 链接选项 各个主流编程语言中都有MongoDB的官方驱动，可用于与MongoDB服务进行链接。 在进行链接时，会生成一个链接对象MongoClient，在代码中使用MongoClient时一定要保证它是单例的，并且整个生命周期中都能从它获取其他操作对象。 你可以通过链接字符串进行链接，链接字符串中可以配置大部分的链接选项，建议将常见选项在此进行配置。 参数 描述 maxPoolSize 链接池大小，默认为100 Max Wait Time 最大等待时间(毫秒) Write Concern 写入策略，建议设置majority Read Concern 读取策略，建议设置majority，按场景选择 Read Preference 读取节点，按场景选择 auth Source 验证库 复制集链接 使用复制集进行链接时，需要指定所有节点，在发生故障转移后自动切换： mongodb://用户名:密码@主库地址:端口,从库地址:端口,从库地址:端口/?authSource=验证库&replicaSet=复制集名称&w=majority&wtimeoutMS=5000&readConcernLevel=majority&readPreference=secondary 需要注意的是，如果你的复制集中的节点没有使用ip而是使用hostname进行配置，则链接时也要指定hostname，下面我的复制集中是使用了ip进行的节点配置，所以向下面这样链接即可： mongodb://192.168.0.120:27017,192.168.0.130:27017,192.168.0.140:27017/?replicaSet=rs0&w=majority&wTimeoutMS=5000&readConcernLevel=majority&readPreference=secondary 下面是我用MongoDB Compass链接rs后的截图： 分片集链接 如果是要链接一个分片集，则只需要链接mongos即可： mongodb://mongos1,mongos2,mongos3.../database?[options] mongodb+srv 在配置集群时使用域名可以为集群变更时提供一层额外的保护。 例如，需要将整体集群迁移到新网段，则在应用程序的计算机上直接修改hosts文件即可。 MongoDB在3.6版本后提供了mongodb+srv://的协议，该协议允许通过域名解析得到所有mongs或节点的地址，而不是写在链接字符串中： mongodb+srv://server.example.com/ 了解更多 如果你想了解更多关于链接MongoDB的方式，可查阅官方文档： 点我跳转 查询相关 注意事项 使用查询时，注意以下三点： 每个查询尽量有对应的索引 尽量使用覆盖索引 使用投影来减少返回到客户端的文档内容，如聚合操作中的$project，普通查询中的find()第二参数 分页处理 处理分页时，不要使用find()函数直接查询出所有数据然后再根据limit()和skip()进行分页，而是应该采用查询唯一条件+唯一排序条件，最好是聚集索引，如下所示： db.collection.find().sort({_id : 1}).limit(20) # 不好 db.collection.find({_id : {$lte : }}).sort({_id : 1}) # 好 db.collection.find({_id : {$lte : }}).sort({_id : 1}) # 好 ... 写入相关 注意事项 使用写入操作时，注意以下三点： 在update()语句中只包括需要更新的字段，加$set修改器，而不是替换全文档 尽可能使用批量插入来提升写入性能，如insertMany() 使用TTL索引来管理自动过期的文档，如日志类型文档 文档结构 防止使用太长的字段名（浪费空间） 防止使用太深的嵌套（阅读与操作都复杂） 不要使用中文，标点符号以及非拉丁字母作为字段名 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:48 "},"数据库专栏/Redis/summary.html":{"url":"数据库专栏/Redis/summary.html","title":"Redis","keywords":"","body":" 基础学习 通用命令 数据类型 持久化存储 事务相关 主从复制 哨兵模式 分片集群 trib.rb工具 清理策略 缓存相关 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:48 "},"数据库专栏/Redis/基础学习.html":{"url":"数据库专栏/Redis/基础学习.html","title":"基础学习","keywords":"","body":"基础介绍 Redis简介 Redis是一个伟大的开源项目，它是一个基于键值对的NoSQL数据库。 与很多键值对数据库不同，Redis拥有丰富的数据结构，如string、hash、list、set、zset等，相比之下同为键值对存储形式的Memcached存储系统仅支持字符串类型。 Redis会将所有的数据全部存放在内存中，所以它的读写速度是非常惊人的，通常情况下它的读写速度会是MySQL的千万倍。 不仅如此，Redis还可以将内存中的数据利用快照和日志形式保存到硬盘上实现持久化存储，这也是Memcached所不支持的。 此外，Redis还提供了TTL（键过期）、发布订阅、事务、流水线等功能，可以说Redis是目前NoSQL中的No.1。 Redis特性 1）速度快： Redis所有的数据都存放在内存中 Redis使用C语言实现 Redis使用单线程架构（v6.0之前） 2）丰富的数据结构： string 字符串 string 列表 string 集合 zset 有序集合 hash 哈希类型 3）丰富的业务功能： 提供了键过期功能,可以实现缓存 提供了发布订阅功能，可以实现消息系统 提供了pipeline功能，客户端可以将一批命令一次性传到Redis，减少了网络开销 4）简单稳定： Redis在3.0版本之后，仅有5万行代码 使用单线程模型法，使得Redis服务端处理模型变得简单 不依赖操作系统的中的类库 5）客户语言多，拥有各大主流语言的官方驱动： Java PHP Python C、C++ Node.Js Go 6）支持数据持久化： 快照方案：RDB 日志方案：AOF 7）支持主从复制、自带高可用架构： 哨兵 集群 Redis线程 Redis在v6.0版本前一直是单线程架构，那么为何单线程的Redis速度会这么快呢？主要得益于以下几点原因： Redis是内存数据库，如果不开启RDB或者AOF，那么它是不会直接和磁盘打交道的，所以数据读写的速度会很快 Redis处理网络请求采用的是I/O多路复用技术，我们知道epoll作为当下比较流行的异步（争论不休）实现方案，其网络请求处理速度是其他的I/O模型所不能比拟的，所以单线程足够应付绝大多数使用场景 没有线程上下文的切换，资源消耗很小，这也是Redis之前考虑单线程运作方式的主要原因 但是随着互联网的日益发展，Redis的单线程架构在如今显得越来越吃力了，所以在v6.0版本之后，Redis引进了多线程方案，但是它的多线程方案是很有讲究的： Redis的多线程只会作用于处理网络请求以及删除事件上，这使得Redis的多线程不会太麻烦，我们不用考虑锁的使用 网络请求的write以及read事件会占用大量的CPU时间，如果把网络读写事件交由多线程进行处理，那么对性能会有很大的提升 如果一个键值对过大，那么在单线程模式下删除它时势必会阻塞其他业务的正常处理，而利用多线程技术，让另一个线程异步的处理删除操作，那么其他的业务就不会被影响到 总体来说，Redis力求简单、高效，即便是加入了多线程系统，Redis本身的主要业务操作逻辑还是没有改变。 Redis功能 基于Redis键过期（TTL）的特性，可以提供缓存服务： 缓存session会话 缓存用户信息、找不到再去MySQL中查、将查询结果获取然后写到Redis中 基于Redis列表与有序集合，可以做排行榜： 热度排名排行榜 发布时间排行榜 基于Redis字符串的incr与decr，可以做计数器： 帖子浏览数 视频播放数 商品浏览数 基于Redis集合，可以做社交网络相关的功能： 共同好友、共同喜好 基于共同喜好进行内容推送 Redis版本 Redis使用标准版本标记进行版本控制，偶数的版本号表示稳定的版本，奇数的版本号用来表示非标准版本。 目前已更新至6.2版本，所以我们使用最新版即可。 安装部署 编译安装 首先下载Redis，它只有2.4M，非常小： $ cd ~ $ wget https://download.redis.io/releases/redis-6.2.6.tar.gz 接下来配置目录，考虑多后期哨兵集群的搭建，所以我们这样配置目录： $ mkdir -p /db/redis/6379/{conf,logs,pid} $ tree /db/redis /db/redis/ # redis服务相关文件目录 └── 6379 # 6379端口数据文件相关目录 ├── conf # 6379端口配置文件存放目录 ├── logs # 6379端口日志文件存放目录 └── pid # 6379端口pid文件存放目录 然后将Redis进行解压： $ tar -xvf redis-6.2.6.tar.gz -C /db/redis/ 进入到Redis主目录下，执行编译安装： $ cd /db/redis/redis-6.2.6/ $ make # 在src目录下生成各种服务命令 $ make install # 添加服务命令软链接至环境变量 检查make生成的服务命令： $ ls /db/redis/redis-6.2.6/src/ 检查make install 生成的软链接： $ ls /usr/local/bin | grep redis 常见问题 如出现提示，极大原因是gcc环境未被安装： CC adlist.o 解决方案，安装gcc： $ yum install -y gcc 清空上次编译失败残留文件： $ make distclean 再次进行编译安装： $ make $ make install 配置文件 书写配置文件： $ vim /db/redis/6379/conf/redis.cnf 填写以下信息，注意配置文件中注释一定要在配置项上方，而不能在后方： # 以守护进程模式启动 daemonize yes # 绑定的主机地址，一般设为本地即可，如设置为0.0.0.0则允许所有地址登录 bind 192.168.0.120 # 监听端口 port 6379 # pid文件和log文件的保存地址 pidfile /db/redis/6379/pid/redis_6379.pid logfile /db/redis/6379/logs/redis_6379.log # 设置数据库的数量，默认数据库为0 databases 16 # 指定本地持久化文件的文件名，默认是dump.rdb dbfilename redis_6379.rdb # 本地数据库的目录 dir /db/redis/6379/ 启停服务 指定配置文件进行启动： $ redis-server /db/redis/6379/conf/redis.cnf 登录Redis提供的shell，redis默认有16个库，如下操作会自动进入db0中： $ redis-cli -h 192.168.0.120 -p 6379 192.168.0.120:6379> EXIT 关闭服务，在redis-cli命令后跟上shutdown： $ redis-cli -h 192.168.0.120 -p 6379 shutdown $ ps -ef | grep redis 或者你也可以在shell中使用shutdown命令： 192.168.0.120:6379> SHUTDOWN 配置大全 自带配置 有的时候我们可能想要查询一些Redis配置，我们可以翻阅Redis自带的配置文件。 但是这个配置文件需要我们自动生成： 1）生成配置文件： $ cd /db/redis/redis-6.2.6/utils/ $ ./install_server.sh 2）如果你是centos7系统，它会告诉你你似乎使用systemd在进行管理，所以你需要修改一些配置： $ vim ./install_server.sh 注释掉下面的内容： #bail if this system is managed by systemd # 都注释掉 _pid_1_exe=\"$(readlink -f /proc/1/exe)\" if [ \"${_pid_1_exe##*/}\" = systemd ] then echo \"This systems seems to use systemd.\" echo \"Please take a look at the provided example service unit files in this directory, and adapt and install them. Sorry!\" exit 1 fi 3）再次运行： $ ./install_server.sh 欢迎使用redis服务安装程序 该脚本将帮助您轻松设置正在运行的Redis服务器 请为此实例选择redis端口：[6379] 选择默认值：6379 请选择redis配置文件名[/etc/redis/6379.conf] 选定的默认值-/etc/redis/6379.conf 请选择redis日志文件名[/var/log/redis_6379.log] 选定的默认值-/var/log/redis_6379.log 请选择此实例的数据目录[/var/lib/redis/6379] 选定的默认值-/var/lib/redis/ 6379 请选择redis可执行文件路径[/usr/local/bin/redis-server] 选定的配置： 端口：6379 配置文件：/etc/redis/6379.conf 日志文件：/var/log/redis_6379.log 数据目录：/var/lib/redis/6379 可执行文件：/usr/local/bin/redis-server 可执行文件Cli：/usr/local/bin/redis-cli 这个可以吗？然后按ENTER继续，或按Ctrl-C放弃。 复制/tmp/6379.conf => /etc/init.d/redis_6379 正在安装服务... 已成功添加到chkconfig中！ 已成功添加到运行级别345！ 正在启动Redis服务器... 安装成功！ 4）它会默认给你启动一个bind ip为127.0.0.1的Redis服务，把他关闭掉： $ ps -ef | grep redis root 5974 1 0 01:15 ? 00:00:00 redis-server 192.168.0.120:6379 root 6074 1 0 01:19 ? 00:00:00 /usr/local/bin/redis-server 127.0.0.1:6379 root 6088 1356 0 01:20 pts/0 00:00:00 grep --color=auto redis $ redis-cli -h 127.0.0.1 -p 6379 shutdown 5）查看它生成的自带配置文件： $ vim /etc/redis/6379.conf 密码设置 默认情况下，我们可以在任意位置链接Redis服务。 与MongoDB与MySQL的安全策略不同，Redis的安全策略没有角色和权限之分。 你只需要在配置文件中，为Redis设置一个登录密码，这样在进行服务链接请求时，将会被要求输入此密码。 使用以下命令，查看当前是否Redis服务是否已经设置了密码验证： $ redis-cli -h 192.168.0.120 -p 6379 192.168.0.120:6379> config get requirepass 1) \"requirepass\" 2) \"\" 2为空，代表未设置密码。 所以我们可以进入Redis配置文件中对其进行设置： $ vim /db/redis/6379/conf/redis.cnf # 安全密码认证 requirepass 123 重启Redis服务，现在登录后执行任何操作都会要求你输入认证密码： # 停止服务 $ redis-cli -h 192.168.0.120 -p 6379 shutdown # 启动服务 $ redis-server /db/redis/6379/conf/redis.cnf # 尝试登录 $ redis-cli -h 192.168.0.120 -p 6379 # 执行查询操作 192.168.0.120:6379> config get requirepass (error) NOAUTH Authentication required. # 输入验证密码 192.168.0.120:6379> AUTH 123 OK # 再次执行查询操作 192.168.0.120:6379> config get requirepass 1) \"requirepass\" 2) \"123\" 你也可以在链接服务时指定参数-a并输入密码，如下所示： $ redis-cli -h 192.168.0.120 -p 6379 -a 123 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:48 "},"数据库专栏/Redis/通用命令.html":{"url":"数据库专栏/Redis/通用命令.html","title":"通用命令","keywords":"","body":"获取帮助 首先我们先登录Redis-CLI： $ redis-cli -h 192.168.0.120 -a 123 获取帮助的形式分为2种： HELP 命令 HELP @群组 比如，获取GET命令的相关帮助，可以看到它的群组是属于stirng的： 192.168.0.120:6379> HELP get GET key # 命令格式 summary: Get the value of a key # 功能概述 since: 1.0.0 # 出现版本 group: string # 所属群组 然后获取string群组命令： 192.168.0.120:6379> HELP @string APPEND key value summary: Append a value to a key since: 2.0.0 ... key操作 基本操作 设置一组键值对： SET key value 获取一组键值对： GET key 删除一组键值对： DEL key 移动当前db中的key到另一个db中，默认我们登录的db为db0： MOVE key db 判断一个key是否存在： EXISTS key 获取一个key的类型： TYPE key 获取键总数： DBSIZE # dbsize 命令在计算键总数时不会遍历所有键，而是直接获取Redis中内置的键总数变量 获取所有key，危险操作！ KEYS * # 实际生产中应当禁止大范围查询，如keys \\*，这样的操作会使内存压力陡增！造成Redis服务崩溃！ 增量式迭代获取key，对于内存占用大的数据非常有用 SCAN cursor [MATCH pattern] [COUNT count] [TYPE type] - cursor：游标 - match：匹配指定的key，默认为None，即表示所有的key - count：每次分配最少获取的个数，默认是None即采用redis默认分片法 上述命令的演示示例： 192.168.0.120:6379> SET k1 v1 OK 192.168.0.120:6379> SET k2 v2 OK 192.168.0.120:6379> SET k3 v3 OK 192.168.0.120:6379> GET k1 \"v1\" 192.168.0.120:6379> DEL k3 (integer) 1 192.168.0.120:6379> DBSIZE (integer) 2 192.168.0.120:6379> MOVE k2 1 # 将k2移动到第db1数据库 (integer) 1 192.168.0.120:6379> DBSIZE (integer) 1 192.168.0.120:6379> SELECT 1 # 切换至db1数据库 OK 192.168.0.120:6379[1]> DBSIZE (integer) 1 192.168.0.120:6379[1]> GET k2 \"v2\" 192.168.0.120:6379[1]> SELECT 0 # 切换至db0数据库 OK 192.168.0.120:6379> EXISTS k1 (integer) 1 192.168.0.120:6379> TYPE k1 string 192.168.0.120:6379> DBSIZE (integer) 1 192.168.0.120:6379> KEYS * 1) \"k1\" 192.168.0.120:6379> SET k2 v2 OK 192.168.0.120:6379> SET k3 v3 OK -- 特别的 192.168.0.120:6379> scan 0 match ff* count 3 1) \"5\" # 取 3 条以 ff 开头的 key，记录游标，下次以 5 开始， 2) 1) \"ff5\" 2) \"ff3\" 3) \"ff4\" 192.168.0.120:6379> scan 5 match ff* count 3 1) \"7\" 2) 1) \"ff2\" 2) \"ff6\" 3) \"ff1\" 注意，SCAN的取出顺序实际上是根据二进制来取的，所以可能会造成取出顺序和录入顺序不统一的现象，如下所示： 92.168.0.120:6379> SET first v1 OK 192.168.0.120:6379> SET second v2 OK 192.168.0.120:6379> SET third v3 OK 192.168.0.120:6379> SCAN 0 MATCH * COUNT 1 1) \"1\" 2) 1) \"third\" 192.168.0.120:6379> SCAN 0 MATCH * COUNT 2 1) \"3\" 2) 1) \"third\" 2) \"first\" 192.168.0.120:6379> SCAN 0 MATCH * COUNT 3 1) \"0\" 2) 1) \"third\" 2) \"first\" 3) \"second\" 192.168.0.120:6379> 具体原因可自行进行Biying，这里不再进行深入探究。 高级查询 使用*匹配任意符号，不限数量，使用?配合任意一个符号，使用[]匹配一个指定符号： KEYS re* 查询所有以re开头 KEYS *dis 查询所有以dis结尾 KEYS ??dis 查询所有前面两个字符任意，后面以dis结尾 KEYS user:? 查询所有以user:开头，最后一个字符任意 KEYS u[st]er:1 查询所有以u开头，以er:1结尾，中间包含一个字母，s或t 其他操作 为key更名： RENAME oldkey newkey 对所有key排序： SORT 获取其他key通用操作： H @generic 时效控制 expire与pexpire 假设现在我们有一个优惠券活动，当用户领取优惠券后会有一个过期时间，此时我们可以使用expire或者pexpire来进行设置，下面是它们的使用语法。 为指定key设置过期时间： # expire到期时间，以秒为单位 EXPIRE key seconds EXPIREAT key timestamp # pexpire到期时间，以毫秒为单位 PEXPIRE key milliseconds PEXPIREAT key timestamp # 注意，加了at后缀的命令都是以UNIX时间戳来进行计数的 获取key的有效时间： # expire的获取 TTL key # pexpire PTTL key # 返回结果 +n 代表剩余过期时间 # 返回结果 -1 代表永不过期 # 返回结果 -2 代表键不存在 将key从时效性转换为永久性： PERSIST key TTL的操作演示 操作演示如下： 192.168.0.120:6379> SET k1 v1 OK 192.168.0.120:6379> EXPIRE k1 5 (integer) 1 # 设置成功 192.168.0.120:6379> TTL k1 (integer) 5 192.168.0.120:6379> TTL k1 (integer) 4 192.168.0.120:6379> TTL k1 (integer) 3 192.168.0.120:6379> TTL k1 (integer) 2 192.168.0.120:6379> TTL k1 (integer) 1 192.168.0.120:6379> TTL k1 (integer) -2 # 已被删除 192.168.0.120:6379> EXISTS k1 (integer) 0 强烈注意 如果将一个已经设置了超时时间的key进行重新复制，则TTL会永久时效。 举个例子： 假如用户有一个100元的优惠券，目前正在倒计时中 此时领导发话将这个优惠券的额度从100加为200 要注意了，一旦执行该操作该优惠券就会永不过期： 192.168.0.120:6379> SET k1 100 # 本身是100元的优惠券 OK 192.168.0.120:6379> EXPIRE k1 50 # 超时时间是50s (integer) 1 192.168.0.120:6379> TTL k1 # 正常倒计时中 (integer) 46 192.168.0.120:6379> TTL k1 (integer) 45 192.168.0.120:6379> SET k1 200 # 重新赋值为200元优惠券 OK 192.168.0.120:6379> TTL k1 # 永不过期 (integer) -1 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:48 "},"数据库专栏/Redis/数据类型.html":{"url":"数据库专栏/Redis/数据类型.html","title":"数据类型","keywords":"","body":"字符串 存储方式 Redis的string类型在内存中是一个key对应一个value进行存储的： 设置操作 以下是常用设置操作： 命令 描述 SET key value 设置指定 key 的值 SETNX key value 只有在 key 不存在时设置 key 的值 MSET key value key value … 同时设置一个或多个 key-value 对 MSETNX key value key value ... 同时设置一个或多个 key-value 对，当且仅当所有给定 key 都不存在 示例演示： # 设置k1 192.168.0.120:6379> SET k1 v1 OK # 设置k1，已存在，设置失败 192.168.0.120:6379> SETNX k1 v1 (integer) 0 # 设置k2，未存在，设置成功 192.168.0.120:6379> SETNX k2 v2 (integer) 1 # 批量设置k3，k4，未存在，设置成功 192.168.0.120:6379> MSET k3 v3 k4 v4 OK # 批量设置k3，k4，已存在，设置失败 192.168.0.120:6379> MSETNX k3 v3 k4 v4 (integer) 0 # 批量设置k5，k6，未存在，设置成功 192.168.0.120:6379> MSETNX k5 v5 k6 v6 (integer) 1 # 查询所有 192.168.0.120:6379> KEYS * 1) \"k3\" 2) \"k4\" 3) \"k1\" 4) \"k6\" 5) \"k2\" 6) \"k5\" 获取操作 以下是常用获取操作： 命令 描述 GET key 获取指定 key 的值 MGET key1 key2.. 获取所有(一个或多个)给定 key 的值 GETRANGE key start end 返回 key 中字符串值的子字符 GETSET key value 将给定 key 的值设为 value ，并返回 key 的旧值(old value) STRLEN key 返回 key 所储存的字符串值的长度 示例演示： # 获取1个 127.0.0.1:6379> GET k1 \"v1\" # 获取多个 127.0.0.1:6379> MGET k1 k2 k3 1) \"v1\" 2) \"v2\" 3) \"v3\" # 获取子串，注意Redis中是顾头顾尾的 127.0.0.1:6379> GETRANGE k1 0 1 \"v1\" # 将给定 key 的值设为 value ，并返回 key 的旧值(old value) 127.0.0.1:6379> GETSET k1 newk1 \"v1\" 127.0.0.1:6379> GET k1 \"newk1\" # 返回 key 所储存的字符串值的长度 127.0.0.1:6379> STRLEN k1 (integer) 5 内容修改 以下是常用内容修改操作： 命令 描述 SETRANGE key offset value 用 value 参数覆写给定 key 所储存的字符串值，从偏移量 offset 开始 APPEND key value APPEND 命令将指定的 value 追加到 key 原来值（value）的末尾，前提是该key必须存在 示例演示： # 将newk1修改成nnnk1 127.0.0.1:6379> SETRANGE k1 0 nnn (integer) 5 127.0.0.1:6379> GET k1 \"nnnk1\" # 将nnnk1修改成nnnk1value 127.0.0.1:6379> APPEND k1 value (integer) 10 127.0.0.1:6379> GET k1 \"nnnk1value\" 计数操作 以下是常用计数相关操作： 命令 描述 INCR key 将 key 中储存的整数值值增1 INCRBY key increment 将 key 所储存的整数值加上给定的增量值（increment） DECR key 将 key 中储存的整数值减1 DECRBY key decrement key 所储存的整数值减去给定的减量值（decrement） INCRBYFLOAT key increment 将 key 所储存的数字值加上给定的浮点增量值（increment） 注意：INCR key、INCRBY key increment、DECR key、DECRBY key decrement必须确保修改的数值是整数，浮点数将会失败。 而如果使用INCRBYFLOAT key increment来对浮点数进行自增自减，则不用保证修改的数值必须是整数，浮点数亦可。 计数器减法虽然不支持浮点数，但是可以通过INCRBYFLOAT key increment来指定负数进行减法： INCRBYFLOAT key -1 # 减1.0 另外，一个超越了Redis中数字串最大值的数字，将不能使用计数器对其进行操作，Redis中数字串的最大值为：9223372036854775807 示例演示： 127.0.0.1:6379> SET n1 0 OK # 加1 127.0.0.1:6379> INCR n1 (integer) 1 # 加2 127.0.0.1:6379> INCRBY n1 2 (integer) 3 # 减1 127.0.0.1:6379> DECR n1 (integer) 2 # 减2 127.0.0.1:6379> DECRBY n1 2 (integer) 0 # 最终结果 127.0.0.1:6379> GET n1 \"0\" 127.0.0.1:6379> SET f1 1.0 OK # 加1.5 127.0.0.1:6379> INCRBYFLOAT f1 1.5 \"1.5\" # 减1.4 127.0.0.1:6379> INCRBYFLOAT f1 -1.4 \"0.1\" # 最终结果 127.0.0.1:6379> GET f1 \"0.1\" 时效方法 以下是常用时效性操作： 命令 描述 SETEX key seconds value 将值 value 关联到 key ，并将 key 的过期时间设为 seconds (以秒为单位) PSETEX key milliseconds value 同上，单位为毫秒 示例演示： 127.0.0.1:6379> SETEX t1 10 v1 OK 127.0.0.1:6379> TTL t1 (integer) 7 127.0.0.1:6379> TTL t1 (integer) 4 127.0.0.1:6379> TTL t1 (integer) -2 127.0.0.1:6379> PSETEX t1 10000 v1 OK 127.0.0.1:6379> PTTL t1 (integer) 7986 127.0.0.1:6379> PTTL t1 (integer) 5360 127.0.0.1:6379> PTTL t1 (integer) -2 使用场景 1）普通string：微博粉丝显示数、微博博文数量等 2）计数string：网站访问量、页面访问量、接口访问量 3）时效string：定期优惠券、定时的热门活动 哈希 存储方式 Redis的hash类型在内存中是一个key对应一个hash空间进行存储的： 注意！hash中的value始终是string类型，也只能存string类型。 但是我们在application中可以将其他的数据类型JSON序列化后再进行存放。 设置操作 以下是常用设置操作： 命令 描述 HSET key field value 将哈希表 key 中的字段 field 的值设为 value HSETNX key field value 只有在字段 field 不存在时，设置哈希表字段的值 HMSET key field1 value1 field2 value2 … 同时将多个 field-value (域-值)对设置到哈希表 key 中 示例演示： # 设置1个field 127.0.0.1:6379> HSET h1 f1 v1 (integer) 1 # 设置1个field，只有不存在时生效，所以下面会失效 127.0.0.1:6379> HSETNX h1 f1 v1 (integer) 0 # 设置多个field 127.0.0.1:6379> HSET h1 f2 v2 f3 v3 (integer) 2 获取操作 以下是常用获取操作： 命令 描述 HEXISTS key field 查看哈希表 key 中，指定的字段是否存在 HGET key field 获取存储在哈希表中指定字段的值 HMGET key field1 field2… 获取所有给定字段的值 HLEN key 获取哈希表中字段的数量 HKEYS key 获取所有哈希表中的字段 HVALS key 获取哈希表中所有值 HGETALL key 获取在哈希表中指定 key 的所有字段和值 示例演示： # 查询是否存在某一个field 127.0.0.1:6379> HEXISTS h1 f1 (integer) 1 # 获取某个field的value 127.0.0.1:6379> HGET h1 f1 \"v1\" # 获取多个field的value 127.0.0.1:6379> HMGET h1 f1 f2 f3 1) \"v1\" 2) \"v2\" 3) \"v3\" # 获取长度 127.0.0.1:6379> HLEN h1 (integer) 3 # 获取所有field 127.0.0.1:6379> HKEYS h1 1) \"f1\" 2) \"f2\" 3) \"f3\" # 获取所有value 127.0.0.1:6379> HVALS h1 1) \"v1\" 2) \"v2\" 3) \"v3\" # 获取所有field以及value 127.0.0.1:6379> HGETALL h1 1) \"f1\" 2) \"v1\" 3) \"f2\" 4) \"v2\" 5) \"f3\" 6) \"v3\" 删除操作 以下是常用删除操作： 命令 描述 HDEL key field1 field2... 删除一个或多个哈希表字段 示例演示： 127.0.0.1:6379> HDEL h1 f3 f2 (integer) 2 127.0.0.1:6379> HLEN h1 (integer) 1 计数操作 以下是常用计数器相关操作： 命令 描述 HINCRBY key field increment 为哈希表 key 中的指定字段的整数值加上整数增量 increment HINCRBYFLOAT key field increment 为哈希表 key 中的指定字段的数字值加上浮点增量值 increment 虽然没有对于hash的decr方法，不过我们可以进行加负数的操作，达到相同的结果： HINCRBY key field -10 示例演示： 127.0.0.1:6379> HSET h1 f2 0 (integer) 1 # +100 127.0.0.1:6379> HINCRBY h1 f2 100 (integer) 100 127.0.0.1:6379> HGET h1 f2 \"100\" # -100 127.0.0.1:6379> HINCRBY h1 f2 -100 (integer) 0 127.0.0.1:6379> HGET h1 f2 \"0\" 迭代获取 HSCAN key cursor [MATCH pattern] [COUNT count]用于增量式迭代获取hash中的field与value。 对于存储量大的数据获取非常有用，该方法可以实现分片的获取数据，并非一次性将数据全部获取完，从而防止内存被撑爆，请使用它代替hgetall： HSCAN key cursor [MATCH pattern] [COUNT count] - cursor：游标 - match：匹配指定的field，如果不填则代表所有key - count：每次取多少 示例演示： 127.0.0.1:6379> HMSET url google \"www.google.com\" biying \"www.biying.com\" sougou \"www.sougou.com\" baidu \"www.baidu.com\" OK # 从0开始匹配一个field为google的键值对 127.0.0.1:6379> HSCAN url 0 MATCH \"google\" COUNT 1 1) \"0\" 2) 1) \"google\" 2) \"www.google.com\" 使用场景 1）模拟RDBMS中的一行表数据： ------------------------------ | id | name | age | gender | ------------------------------ | 1 | jack | 18 | male | ------------------------------ HSET user1 name jack age 18 gender male 2）电商购物车相关信息： 列表 存储方式 Redis的list类型在内存中是一个key对应一个list空间进行存储的： 值得注意的是Redis中的列表取值是顾头顾尾的，并且Redis支持负向索引，如-1就是列表尾部的最后一个元素。 同hash一样，原生的Redis-list只能存放string类型的值，但是我们在application中可以将其他的数据类型JSON序列化后再进行存放。 设置操作 以下是常用设置操作： 命令 描述 LPUSH key value1 value2… 将一个或多个值插入到列表头部 LPUSHX key value 将一个值插入到已存在的列表头部 RPUSH key value1 value2… 将一个或多个值插入到列表尾部 RPUSHX key value 将一个值插入到已存在的列表尾部 LSET key index value 通过索引设置列表元素的值 [LINSERT key BEFORE\\ AFTER pivot value](https://www.runoob.com/redis/lists-linsert.html) 在列表的元素前或者后插入元素 示例演示： # [B, C] 127.0.0.1:6379> LPUSH lst C B (integer) 2 # [A, B, C] 127.0.0.1:6379> LPUSHX lst A (integer) 3 # [A, B, C, D, E] 127.0.0.1:6379> RPUSH lst D E (integer) 5 # [A, B, C, D, E, F] 127.0.0.1:6379> RPUSHX lst F (integer) 6 # [有值A, B, C, D, E, F, H] 127.0.0.1:6379> RPUSHX lst H (integer) 7 # [A, B, C, D, E, F, G, H] 127.0.0.1:6379> LINSERT lst BEFORE H G (integer) 8 获取操作 以下是常用获取操作： 命令 描述 LLEN key 获取列表长度 LINDEX key index 通过索引获取列表中的元素 LRANGE key start stop 获取列表指定范围内的元素 LPOP key 移出并获取列表的第一个元素 RPOP key 移出并获取列表的最后一个元素 示例演示： # 获取长度 127.0.0.1:6379> LLEN lst (integer) 8 # 根据索引获取元素 127.0.0.1:6379> LINDEX lst 0 \"A\" 127.0.0.1:6379> LINDEX lst -1 \"H\" # 指定范围取元素，顾头顾尾 127.0.0.1:6379> LRANGE lst 0 -1 1) \"A\" 2) \"B\" 3) \"C\" 4) \"D\" 5) \"E\" 6) \"F\" 7) \"G\" 8) \"H\" # 移出并获取列表的第一个元素 127.0.0.1:6379> LPOP lst \"A\" # 移出并获取列表的最后一个元素 127.0.0.1:6379> RPOP lst \"H\" # 剩余长度为6 127.0.0.1:6379> LLEN lst (integer) 6 删除操作 以下是常用删除操作： 命令 描述 LPOP key 移出并获取列表的第一个元素 RPOP key 移出并获取列表的最后一个元素 LREM key count value 根据元素值移除列表元素 LTRIM key start stop 移除没有在列表start-stop索引之间的元素 LPOP和RPOP不再演示，示例如下： 127.0.0.1:6379> LREM lst 1 B (integer) 1 127.0.0.1:6379> LRANGE lst 0 -1 1) \"C\" 2) \"D\" 3) \"E\" 4) \"F\" 5) \"G\" 127.0.0.1:6379> LTRIM lst 0 2 OK 127.0.0.1:6379> LRANGE lst 0 -1 1) \"C\" 2) \"D\" 3) \"E\" 多列表操作 以下是常用多列表操作： 命令 描述 RPOPLPUSH source destination 移除列表的最后一个元素，并将该元素添加到另一个列表头部并返回 示例演示： 127.0.0.1:6379> RPUSH lst2 B (integer) 1 127.0.0.1:6379> RPUSH lst1 A (integer) 1 127.0.0.1:6379> RPOPLPUSH lst1 lst2 \"A\" 127.0.0.1:6379> LRANGE lst2 0 -1 1) \"A\" 2) \"B\" 生产与消费 下面三个方法，可将列表作为生产者消费者模型。 命令 描述 BLPOP key1 key2 timeout 弹出列表左侧第一个元素，如果没有元素则阻塞多少秒 BRPOP key1 key2 timeout 弹出列表右侧第一个元素，如果没有元素则阻塞多少秒 BRPOPLPUSH source destination timeout 从一个列表的右侧移除一个元素并将其添加到另一个列表的左侧，，如果没有元素则阻塞多少秒 这里具体不再演示了，因为都比较简单。 使用场景 1）微信朋友圈点赞，要求按照点赞顺序显示点赞好友信息，如果取消点赞，移除对应好友信息： 2）twitter、新浪微博、腾讯微博中个人用户的关注列表需要按照用户的关注顺序进行展示，粉丝列表需要将最近关注的粉丝列在前面: 3）新闻、资讯类网站的最新推荐 4）生产者消费者模型，可用于长轮询的消息队列 集合 存储方式 Redis的set类型在内存中是一个key对应一个set空间进行存储的，与list相比，set中的元素不能重复： 同hash、list一样，原生的Redis-set只能存放string类型的值，但是我们在application中可以将其他的数据类型JSON序列化后再进行存放。 设置操作 以下是常用设置操作： 命令 描述 SADD key member1 member2 向集合中添加一个或多个成员 示例演示： 127.0.0.1:6379> SADD clump A A B B C C (integer) 3 获取操作 以下是常用获取操作： 命令 描述 SISMEMBER key member 判断 member 元素是否是集合 key 的成员 SCARD key 获取集合的成员数 SMEMBERS key 返回集合中的所有成员 SPOP key count 移除并返回集合中的一个或多个随机元素 SRANDMEMBER key count 返回集合中一个或多个随机数元素 示例演示： # {A, B, C} 127.0.0.1:6379> SADD clump A A B B C C (integer) 3 # D不在集合中 127.0.0.1:6379> SISMEMBER clump D (integer) 0 # 获取数量 127.0.0.1:6379> SCARD clump (integer) 3 # 获取成员 127.0.0.1:6379> SMEMBERS clump 1) \"C\" 2) \"B\" 3) \"A\" # 随机弹出2个成员 127.0.0.1:6379> SPOP clump 2 1) \"A\" 2) \"C\" # 随机返回3个成员，此时只剩下1个，就直接返回了 127.0.0.1:6379> SRANDMEMBER clump 3 1) \"B\" 删除操作 以下是常用删除操作： 命令 描述 SPOP key count 移除并返回集合中的一个或多个随机元素 SREM key member1 member2 根据元素名移除集合中一个或多个成员 SPOP方法上面已经演示过了，所以直接看SREM方法即可，如下所示： 127.0.0.1:6379> SREM clump B (integer) 1 多集合操作 以下是常用多集合操作： 命令 描述 SMOVE source destination member 将 member 元素从 source 集合移动到 destination 集合 这里不再进行演示，参见list中的多列表操作。 交叉并集 交叉并集的图示如下： 交集相关： SINTER key1 [key2 ...] # 返回给定所有集合的交集 SINTERSTORE destination key [key ...] # 将返回给定所有集合的交集并存储在 destination 新集合中 差集相关： SDIFF key1 [key2 ...] # 回给定所有集合的差集 SDIFFSTORE destination key1 [key2 ...] # 返回给定所有集合的差集并存储在 destination 新集合中 并集相关： SUNION key1 [key2 ...] # 返回所有给定集合的并集 SUNIONSTORE destination key1 [key2 ...] # 将返回给定所有集合的并集并存储在 destination 新集合中 迭代获取 SSCAN key cursor [MATCH pattern] [COUNT count]用于增量式迭代获取，对于数据大的数据非常有用，该方法可以实现分片的获取数据，并非一次性将数据全部获取完，从而防止内存被撑爆，请使用它代替SMEMBERS key SSCAN key cursor [MATCH pattern] [COUNT count] - cursor：游标 - match：匹配指定的field，如果不填则代表所有key - count：每次取多少 使用场景 1）社交软件中的共同爱好、共同好友、共同关注等，用于同兴趣推送服务 2）游戏中装备拾取（背包已有、背包没有） 3）记录网站的不同IP访问数 有序集合 存储方式 Redis的zset类型在内存中是一个key对应一个zset空间进行存储的，与list相比，set中的元素不能重复，与set相比，zset中的元素可以按score进行排序： 同hash、list、set一样，原生的Redis-zset只能存放string类型的值，但是我们在application中可以将其他的数据类型JSON序列化后再进行存放。 设置操作 以下是常用设置操作： 命令 描述 ZADD key score1 member1 score2 member2... 向有序集合添加一个或多个成员，或者更新已存在成员的分数 示例演示： 127.0.0.1:6379> ZADD oclump 100 A 200 B 300 C (integer) 3 获取操作 以下是常用获取操作： 命令 描述 ZCARD key 获取有序集合的成员数 ZLEXCOUNT key min max 获取有序集合中指定字典区间内成员数量 ZCOUNT key min max 获取有序集合中指定分数区间的成员数量 ZSCORE key member 返回有序集合中指定成员的分数值 ZRANK key member 返回有序集合中指定成员的索引值 ZREVRANK key member 返回有序集合中指定成员的排名，有序集成员按分数值递减(从大到小)排序 ZREVRANGE key start stop WITHSCORES 返回有序集合中指定索引区间内的成员，分数从高到低排序 ZREVRANGEBYSCORE key max min WITHSCORES 返回有序集合中指定分数区间内的成员，分数从高到低排序 ZRANGE key start stop WITHSCORES 通过索引区间返回有序集合指定区间内的成员 ZRANGEBYLEX key min max LIMIT offset count 通过字典区间返回有序集合指定区间内的成员 ZRANGEBYSCORE key min max WITHSCORES LIMIT 通过分数区间返回有序集合指定区间内的成员 示例演示： # 获取成员数量 127.0.0.1:6379> ZCARD oclump (integer) 3 # 获取元素区间成员数量 127.0.0.1:6379> ZLEXCOUNT oclump [A [C (integer) 3 # 获取分数区间成员数量 127.0.0.1:6379> ZCOUNT oclump 100 300 (integer) 3 # 返回某个元素的分数 127.0.0.1:6379> ZSCORE oclump C \"300\" # 返回某个元素的索引 127.0.0.1:6379> ZRANK oclump C (integer) 2 # 返回元素在分数降序中的排名 127.0.0.1:6379> ZREVRANK oclump C (integer) 0 127.0.0.1:6379> ZREVRANK oclump A (integer) 2 # 返回索引区间内的元素，顾头顾尾，返回降序 127.0.0.1:6379> ZREVRANGE oclump 0 -1 1) \"C\" 2) \"B\" 3) \"A\" # 返回分数区间内的元素，顾头顾尾，返回降序 127.0.0.1:6379> ZREVRANGEBYSCORE oclump 300 100 1) \"C\" 2) \"B\" 3) \"A\" # 返回索引区间内的元素，顾头顾尾，返回升序 127.0.0.1:6379> ZRANGE oclump 0 -1 1) \"A\" 2) \"B\" 3) \"C\" # 返回字典区间内的元素，顾头顾尾，返回升序 127.0.0.1:6379> ZRANGEBYLEX oclump [A [C 1) \"A\" 2) \"B\" 3) \"C\" # 返回分数区间内的元素，顾头顾尾，返回升序 127.0.0.1:6379> ZRANGEBYSCORE oclump 100 300 1) \"A\" 2) \"B\" 3) \"C\" 删除操作 以下是常用删除操作： 命令 描述 ZREM key member member ... 按照元素名移除有序集合中的一个或多个成员 ZREMRANGEBYLEX key min max 移除有序集合中给定的字典区间的所有成员 ZREMRANGEBYRANK key start stop 移除有序集合中给定的排名区间的所有成员 ZREMRANGEBYSCORE key min max 移除有序集合中给定的分数区间的所有成员 使用方式可参照set与上面的获取操作，这里不再进行演示。 计数操作 以下是常用计数器相关操作： 命令 描述 ZINCRBY key increment member 有序集合中对指定成员的分数加上增量 increment 交叉并集 图示： 交集相关： # 返回给定所有集合的交集 ZINTER numkeys key [key ...] [WEIGHTS weight [weight ...]] [AGGREGATE SUM|MIN|MAX] [WITHSCORES] # 计算给定的一个或多个有序集的交集并将结果集存储在新的有序集合 destination 新集合中 ZINTERSTORE destination numkeys key [key ...] 差集相关： # 返回给定所有集合的差集 ZDIFF numkeys key [key ...] [WEIGHTS weight [weight ...]] [AGGREGATE SUM|MIN|MAX] [WITHSCORES] # 计算给定的一个或多个有序集的并集并将结果集存储在新的有序集合 destination 新集合中 ZDIFFSTORE destination numkeys key [key ...] 并集相关： # 返回给定所有集合的并集 ZUNION numkeys key [key ...] [WEIGHTS weight [weight ...]] [AGGREGATE SUM|MIN|MAX] [WITHSCORES] # 计算给定的一个或多个有序集的并集并将结果集存储在新的有序集合 destination 新集合中 ZUNIONSTORE destination numkeys key [key ...] 迭代获取 ZSCAN key cursor [MATCH pattern] [COUNT count]可用于增量式迭代获取，对于数据大的数据非常有用，该方法可以实现分片的获取数据，并非一次性将数据全部获取完，从而防止内存被撑爆 请使用它代替大规模获取元素操作： ZSCAN key cursor [MATCH pattern] [COUNT count] - cursor：游标 - match：匹配指定的field，如果不填则代表所有key - count：每次取多少 使用场景 1）各类排行榜，亲密度，活跃度统计 2）带有权重类的任务，权重高的先进行执行 3）新消息置顶提示 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:48 "},"数据库专栏/Redis/持久化存储.html":{"url":"数据库专栏/Redis/持久化存储.html","title":"持久化存储","keywords":"","body":"功能概述 Redis会将数据全部存储在内存中，这意味着一旦发生断电等故障情况，所有数据都将丢失。 对此，Redis提供了2种持久化方案，RDB和AOF： RDB：根据配置的指定时间间隔与数据提交频率进行快照存储 AOF：仅记录变更日志，当服务重启后依照变更日志进行回放操作，达到恢复数据的目的 Redis默认开启了RDB持久化存储方案，接下来就详细的探究一下这2种持久化方案吧。 RDB 相关配置 在Redis的配置文件中，可指定RDB快照存储的配置项如下所示，需要注意的是如果开启了AOF日志备份，那么RDB快照备份将会失效： # 是否开启快照保存，注释以下配置项代表禁用，Redis默认是启用状态 save \"\" # 快照策略 save 900 1 save 300 10 save 60 10000 # 指定RDB持久化存储的文件名称，默认为dump.rdb dbfilename dump.rdb # 指定RDB持久化存储的文件所在目录，默认为当前工作目录 dir /db/redis/6379 # 备份出错后，是否允许新的变更操作进行执行？ stop-writes-on-bgsave-error yes # 是否压缩？不建议开启，影响性能 # rdbcompression yes # 导入时是否检查？不建议开启，影响性能 # rdbchecksum yes 1）时间策略： 当900s内有1条变更记录，就触发一次快照备份 当300s内有10条变更记录，就触发一次快照备份 当60s内有10000条变更记录，就触发一次快照备份 手动快照 除开上述配置项中的自动快照备份策略外，我们也可以执行下面2条命令进行手动快照： save：不会fork子进程进行快照备份，会阻塞新的变更操作，不建议使用 bgsave：会fork出一个子进程来进行快照备份，不会阻塞新的变更操作，推荐使用 此外，在对服务进行shutdown的操作且没有开启AOF备份时，Redis会自动的进行一次bgsave操作，避免数据丢失。 如果是kill -9等暴力的将服务进程进行关闭，则Redis不会自动执行bgsave操作，因此应当避免使用kill -9等暴力的进程结束方式。 工作原理 RDB的bgsave命令在触发时，会先检查是否开启AOF日志备份，如果开启，则bgsave命令将会失效： AOF 相关配置 在Redis的配置文件中，可指定AOF日志存储的配置项如下所示： # 是否开启aof appendonly yes # 文件名称 appendfilename \"appendonly.aof\" # 同步方式 appendfsync everysec # aof重写期间是否同步 no-appendfsync-on-rewrite no # 重写触发配置 auto-aof-rewrite-percentage 100 auto-aof-rewrite-min-size 64mb # 回放aof时如果有错如何处理 aof-load-truncated yes # 文件重写策略 aof-rewrite-incremental-fsync yes 1）appendfsync指定同步方式： always：把每个变更命令都立即同步到AOF，很慢，但是很安全 everysec：每秒同步一次，是折中方案，推荐使用 no：redis不处理交给OS来处理，非常快，但是也最不安全 2）aof-load-truncated回放异常处理： yes：继续执行回放 no：必须修复aof文件后再进行回放 手动记录 除开上述配置项中的自动日志备份策略外，我们也可以执行下面这条命令进行手动记录日志： bgrewriteaof 工作原理 AOF的备份策略要比RDB的备份策略优先级更高，下面是它的工作流程： 流程释义： 在重写期间，由于主进程依然在响应命令，为了保证最终备份的完整性；因此它依然会写入旧的AOF file中，如果重写失败，能够保证数据不丢失 为了把重写期间响应的写入信息也写入到新的文件中，因此也会为子进程保留一个buf，防止新写的file丢失数据 重写是直接把当前内存的数据生成对应命令，并不需要读取老的AOF文件进行分析、命令合并 AOF文件直接采用的文本协议，主要是兼容性好、追加方便、可读性高可认为修改修复 此外，AOF文件仅能有1个，这与MySQL的多个binlog进行日志轮询并不一样。 Redis的AOF日志备份仅关注结果，不关注过程，换而言之，如果你的操作是下面这样： set k1 \"v1\" set k1 \"v2\" 则记录的变更日志会根据结果进行精简，只记录一条： set k1 \"v2\" 这样的策略能最大限度减少AOF文件数据大小，但也造成了无法通过AOF恢复误操作数据的情况，因此谨慎使用。 回放过程 以下是Redis的备份回放过程，如果AOF与RDB同时启用，优先回放AOF： 关闭备份 以下两条命令可在redis-shell中临时关闭备份： config set save \"\" # 临时关闭RDB备份 config set appendfsync # 临时关闭AOF备份 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:48 "},"数据库专栏/Redis/事务相关.html":{"url":"数据库专栏/Redis/事务相关.html","title":"事务相关","keywords":"","body":"执行流程 Redis事务可以一次执行多个命令， 并且带有以下三个重要的保证： 批量操作在发送EXEC命令前被放入队列缓存 收到EXEC命令后进入事务执行，事务中任意命令执行失败，其余的命令依然被执行 在事务执行过程，其他客户端提交的命令请求不会插入到事务执行命令序列中 一个事务从开始到执行会经历以下三个阶段： 开始事务 命令入队 执行事务 单个Redis命令的执行是原子性的，但Redis没有在事务上增加任何维持原子性的机制，所以Redis事务的执行并不是原子性的。 事务可以理解为一个打包的批量执行脚本，但批量指令并非原子化的操作，中间某条指令的失败不会导致前面已做指令的回滚，也不会造成后续的指令不做。 相关命令 以下是Redis事务中相关命令： 命令 描述 MULTI 开启一组事务 EXEC 提交一组事务 DISCARD 取消一组事务 WATCH key [key ...] 监视一个(或多个) key ，如果在事务执行之前这个(或这些) key 被其他命令所改动，那么事务将被打断。也就是说一旦监听成功，这个key则不允许被修改，直到UNWATCH UNWATCH 取消 WATCH 命令对所有 key 的监视。 操作演示 以下是Redis事务中的操作演示： 127.0.0.1:6379> MULTI OK 127.0.0.1:6379> SET book-name \"Mastering C++ in 21 days\" QUEUED 127.0.0.1:6379> GET book-name QUEUED 127.0.0.1:6379> SADD tag \"C++\" \"Programming\" \"Mastering Series\" QUEUED 127.0.0.1:6379> SMEMBERS tag QUEUED 127.0.0.1:6379> EXEC 1) OK 2) \"Mastering C++ in 21 days\" 3) (integer) 3 4) 1) \"Mastering Series\" 2) \"C++\" 3) \"Programming\" Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:48 "},"数据库专栏/Redis/主从复制.html":{"url":"数据库专栏/Redis/主从复制.html","title":"主从复制","keywords":"","body":"功能概述 Redis的主从复制和MySQL基本相同，本身并不提供任何高可用方面的功能，需要借助其他的计数进行实现，但却是高可用架构的基础前提。 相较于MySQL来说，Redis的主从复制搭建比较简单，关注的点也比较少，且因内部原因数据同步速率影响较小（如果网速慢另当别论）。 下面我准备使用3台服务器来搭建Redis主从复制，一方面也为后面的高可用架构做基础铺垫。 地址规划 以下是地址规划： 作用 IP地址 服务端口 操作系统 配置 Master 192.168.0.120 6379 Centos7.3 基础设施服务器 2颗CPU 2G内存 20G硬盘 SLAVE1 192.168.0.130 6379 Centos7.3 基础设施服务器 2颗CPU 2G内存 20G硬盘 SLAVE2 192.168.0.140 6379 Centos7.3 基础设施服务器 2颗CPU 2G内存 20G硬盘 所有节点均采用6.2.6的Redis版本。 安装Redis 为所有节点安装Redis： $ cd ~ $ wget https://download.redis.io/releases/redis-6.2.6.tar.gz 为所有节点配置目录： $ mkdir -p /db/redis/6379/{conf,logs,pid} $ tree /db/redis /db/redis/ # redis服务相关文件目录 └── 6379 # 6379端口数据文件相关目录 ├── conf # 6379端口配置文件存放目录 ├── logs # 6379端口日志文件存放目录 └── pid # 6379端口pid文件存放目录 所有节点解压Redis： $ tar -xvf redis-6.2.6.tar.gz -C /db/redis/ 所有节点进入Redis主目录中进行编译安装： $ cd /db/redis/redis-6.2.6/ $ make # 在src目录下生成各种服务命令 $ make install # 添加服务命令软链接至环境变量 所有节点书写配置文件，需要修改的地方已经用!标注出来了： $ vim /db/redis/6379/conf/redis.cnf # 以守护进程模式启动 daemonize yes # !绑定的主机地址，一般设为本地即可，如设置为0.0.0.0则允许所有地址登录 bind 192.168.0.120 # 监听端口 port 6379 # pid文件和log文件的保存地址 pidfile /db/redis/6379/pid/redis_6379.pid logfile /db/redis/6379/logs/redis_6379.log # 设置数据库的数量，默认数据库为0 databases 16 # 指定本地持久化文件的文件名，默认是dump.rdb dbfilename redis_6379.rdb # 本地数据库的目录 dir /db/redis/6379/ 配置hostname： $ hostnamectl set-hostname master # slave1 # slave2 配置hosts文件： $ vim /etc/hosts 192.168.0.120 master 192.168.0.130 node1 192.168.0.140 node2 搭建主从 1）启动Master： $ redis-server /db/redis/6379/conf/redis.cnf 2）启动Slave，并指定其链接从库，其实从库链接主库的方式有3种，我这里选择第2种： $ redis-server /db/redis/6379/conf/redis.cnf --slaveof 192.168.0.120 6379 三种方式分别为： 配置文件中加入 slaveof 主库HOST 主库PORT，Redis服务启动生效 在redis-server启动命令后加入 --slaveof 主库HOST 主库PORT，单次启动生效，重启失效 在redis-shell中使用命令 slaveof 主库HOST 主库PORT 立即生效，重启失效 3）登录Master，查看链接情况： $ redis-cli -h master -p 6379 master:6379> info replication # Replication role:master connected_slaves:2 slave0:ip=192.168.0.130,port=6379,state=online,offset=168,lag=1 slave1:ip=192.168.0.140,port=6379,state=online,offset=168,lag=1 master_failover_state:no-failover master_replid:5a37df4a0cdb3d1c6cc4555bc96caebea7ed2d63 master_replid2:0000000000000000000000000000000000000000 master_repl_offset:182 second_repl_offset:-1 repl_backlog_active:1 repl_backlog_size:1048576 repl_backlog_first_byte_offset:1 repl_backlog_histlen:182 4）主库写入数据： master:6379> LPUSH lst 1 2 3 4 5 (integer) 5 5）从库查看数据是否同步： $ redis-cli -h slave1 -p 6379 slave1:6379> LRANGE lst 0 -1 1) \"5\" 2) \"4\" 3) \"3\" 4) \"2\" 5) \"1\" 6）如果在从库上写入数据，则会发出异常提示，仅允许主库中写入： $ redis-cli -h slave2 -p 6379 slave2:6379> set k1 v1 (error) READONLY You can't write against a read only replica. 解除关系 如果要解除从库与主库的关系，可在从库的redis-cli中使用以下命令： slaveof no one 复制过程 Redis主从的复制过程如下所示： 查看主从节点的日志，为了照顾英文不好的读者，这里使用译文： $ vim /db/redis/6379/logs/redis_6379.log 8788：M 2021年3月31日06：26：15.229 *副本192.168.0.130:6379要求同步 28788：M 2021年3月31日06：26：15.229 *接受了来自192.168.0.130:6379的部分重新同步请求。从偏移量15开始发送0字节的积压。 # 这里是因为主库本身没有任何数据而做的主从关系 28788：M 2021年3月31日06：26：16.607 *副本192.168.0.140:6379要求同步 28788：M 2021年3月31日06：26：16.607 *副本192.168.0.140:6379请求完全重新同步 28788：M 2021年3月31日06：26：16.607 *使用目标：磁盘启动BGSAVE for SYNC 28788：M 2021年3月31日06：26：16.608 *通过pid 33284开始后台保存 33284：C 2021年3月31日06：26：16.610 * DB保存在磁盘上 33284：C 2021年3月31日06：26：16.611 * RDB：0写入时复制使用的内存 28788：M 2021年3月31日06：26：16.687 *背景保存成功终止 28788：M 2021年3月31日06：26：16.688 *与副本192.168.0.140:6379的同步成功 28788：M 2021年3月31日06：26：15.229 *副本192.168.0.130:6379要求同步 28788：M 2021年3月31日06：26：15.229 *接受了来自192.168.0.130:6379的部分重新同步请求。从偏移量15开始发送0字节的积压。 28788：M 2021年3月31日06：26：16.607 *副本192.168.0.140:6379要求同步 28788：M 2021年3月31日06：26：16.607 *副本192.168.0.140:6379请求完全重新同步 28788：M 2021年3月31日06：26：16.607 *使用目标：磁盘启动BGSAVE for SYNC 28788：M 2021年3月31日06：26：16.608 *通过pid 33284开始后台保存 33284：C 2021年3月31日06：26：16.610 * DB保存在磁盘上 33284：C 2021年3月31日06：26：16.611 * RDB：0写入时复制使用的内存 28788：M 2021年3月31日06：26：16.687 *背景保存成功终止 28788：M 2021年3月31日06：26：16.688 *与副本192.168.0.140:6379的同步成功 查看从节点的日志，为了照顾英文不好的读者，这里使用译文： $ vim /db/redis/6379/logs/redis_6379.log 28108：S 2021年3月31日06：26：15.225 * DB从磁盘加载：0.000秒 28108：S 2021年3月31日06：26：15.225 *在变成副本之前，使用我自己的master参数合成一个缓存的master：通过部分传输，我也许可以与新master同步。 28108：S 2021年3月31日06：26：15.225 *准备接受连接 28108：S 2021年3月31日06：26：15.225 *连接至主192.168.0.120:6379 28108：S 2021年3月31日06：26：15.225 * MASTER REPLICA同步开始 28108：S 2021年3月31日06：26：15.226 * SYNC的非阻塞连接触发了该事件。 28108：S 2021年3月31日06：26：15.226 *主服务器回复为PING，复制可以继续... 28108：S 2021年3月31日06：26：15.227 *尝试进行部分重新同步（请求aea7f187e94343b82b229d8a5a3c5e407aedc0f2：15）。 28108：S 2021年3月31日06：26：15.228 *与主机成功完成部分重新同步。 28108：S 2021年3月31日06：26：15.228 * MASTER REPLICA sync：Master接受了部分重新同步。 主库宕机 如果主库宕机后会发生什么？我们可以试试： $ redis-cli -h master -p 6379 shutdown 查看从库日志： $ tail -f /usr/local/redis_cluster/redis_6379/logs/redis_6379.log 28108：S 2021年3月31日06：40：55.037＃SYNC套接字上的错误情况：连接被拒绝 28108：S 2021年3月31日06：40：56.043 *连接至主192.168.0.120:6379 28108：S 2021年3月31日06：40：56.043 * MASTER REPLICA同步开始 28108：S 2021年3月31日06：40：56.044＃SYNC套接字上的错误情况：连接被拒绝 28108：S 2021年3月31日06：40：57.052 *连接至主192.168.0.120:6379 28108：S 2021年3月31日06：40：57.052 * MASTER REPLICA同步开始 28108：S 2021年3月31日06：40：57.053＃SYNC套接字上的错误情况：连接被拒绝 28108：S 2021年3月31日06：40：58.058 *连接至主192.168.0.120:6379 28108：S 2021年3月31日06：40：58.059 * MASTER REPLICA同步开始 28108：S 2021年3月31日06：40：58.059＃SYNC套接字上的错误情况：连接被拒绝 28108：S 2021年3月31日06：40：59.065 *连接至主192.168.0.120:6379 28108：S 2021年3月31日06：40：59.066 * MASTER REPLICA同步开始 28108：S 2021年3月31日06：40：59.067＃SYNC套接字上的错误情况：连接被拒绝 28108：S 2021年3月31日06：41：00.070 *连接至主192.168.0.120:6379 28108：S 2021年3月31日06：41：00.072 * MASTER REPLICA同步开始 28108：S 2021年3月31日06：41：00.072＃SYNC套接字上的错误情况：连接被拒绝 28108：S 2021年3月31日06：41：01.080 *连接至主192.168.0.120:6379 它会不断的请求主库，永不间断。 故障恢复 主库发生故障后，应当将其中一个从库立马转换为主库身份。 如下，将slave1转换为主库身份，首先，slave1的slaveof要设置为空： $ redis-cli -h slave1 -p 6379 slave1:6379> slaveof no one OK 其次，你应该登录slave2，然后进行设置slave1为新主库： $ redis-cli -h slave2 -p 6379 slave2:6379> slaveof 192.168.1.130 6379 OK 查看复制信息： slave2:6379> info replication # Replication role:slave master_host:192.168.1.130 master_port:6379 master_link_status:down master_last_io_seconds_ago:-1 master_sync_in_progress:0 slave_repl_offset:1270 master_link_down_since_seconds:348 slave_priority:100 slave_read_only:1 connected_slaves:0 master_failover_state:no-failover master_replid:aea7f187e94343b82b229d8a5a3c5e407aedc0f2 master_replid2:0000000000000000000000000000000000000000 master_repl_offset:1270 second_repl_offset:-1 repl_backlog_active:1 repl_backlog_size:1048576 repl_backlog_first_byte_offset:15 repl_backlog_histlen:1256 然后将原主库master进行修复后作为从库链接至slave1，这里我不再进行演示了。 另外，如果application原本接入的是已宕机主库master，你还需要通知开发人员进行手动切换。 为了后续章节，我这里再将master上线并设置为主库。 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:48 "},"数据库专栏/Redis/哨兵模式.html":{"url":"数据库专栏/Redis/哨兵模式.html","title":"哨兵模式","keywords":"","body":"功能概述 在Redis的主从模式下，主节点一旦宕机则需要人工进行干预将从节点晋升为主节点，同时还需要修改application链接已宕机主节点的信息等，这对于很多应用场景来说是无法接受的，我们需要的是自动化的故障转移。 为了解决这个问题，Redis在2.8版本发布了一个稳定版本的Redis Sentinel（哨兵），它解决了Redis主从需要人工干预的问题，实现高可用，在实际生产中对提高整个系统可用性是非常有帮助的。 哨兵相较于MySQL的MHA来说，它是一种持续性服务，并非MHA的一次性服务。 架构图如下所示： 每台节点机上开2个实例，一个是哨兵实例、一个是Redis服务实例。 以此组成2套集群，哨兵集群和主从集群。 哨兵集群互相地位相等，并且能够实时的监控主从集群，提供以下服务： 监控：Sentinel会不断的定期的检查Master以及Slave是否工作正常 提醒：当被监控的某个Redis服务出现问题，Sentinel会通过API向管理员或者其他应用程序发送通知 自动故障转移：当主服务器失联后，Sentinel将会从从服务器中选定一个新的节点作为主节点，除此之外，Sentinel还会对application返回新的主节点供application进行链接，前提是application链接的是Sentinel 哨兵本身就是一个分布式架构的集群，为什么不采用单哨兵呢？这样做有以下2点好处： 对于服务节点的故障判断由多个节点共同完成，可以有效防止误判 由于application是链接的是多个Sentinel，当某个Sentinel不可用时也不会影响application的访问与操作 哨兵集群最少3节点，与MHA与MongoDB复制集相同，当主节点失联后，只有奇数节点才能进行投票，否则会进行平票的情况。 哨兵配置 为了节省服务器资源，我将对每一个节点开启2个实例。 1个实例用于Redis的主从服务集群搭建，另1个实例用于哨兵服务集群搭建。 哨兵们并不会存储任何业务数据，仅对Redis主从架构做监控。 以下是地址规划： 作用 IP地址 服务端口 哨兵端口 操作系统 配置 Master 192.168.0.120 6379 26379 Centos7.3 基础设施服务器 2颗CPU 2G内存 20G硬盘 SLAVE1 192.168.0.130 6379 26379 Centos7.3 基础设施服务器 2颗CPU 2G内存 20G硬盘 SLAVE2 192.168.0.140 6379 26379 Centos7.3 基础设施服务器 2颗CPU 2G内存 20G硬盘 所有节点创建哨兵相关目录： $ mkdir -p /db/redis/26379/{conf,pid,logs} 所有节点进行哨兵文件的配置： $ vim /db/redis/26379/conf/redis_26379.cnf # 输入以下信息： # 哨兵相关配置，修改ip即可 bind 192.168.0.120 port 26379 daemonize yes logfile /db/redis/26379/logs/redis_26379.log dir /db/redis/26379/ # 监听的主库，不用动，直接复制粘贴 sentinel monitor node1 192.168.0.120 6379 2 sentinel down-after-milliseconds node1 30000 sentinel parallel-syncs node1 1 sentinel failover-timeout node1 30000 # sentinel auth-pass mymaster password # sentinel notification-script mymaster /root/notice.sh 参数解释： sentinel monitor： ​ - node1代表监听的Redis服务Master的自定义名称 ​ - 2代表如果该服务失联，则至少需要几个哨兵进行确认 ​ - 这里设置为如果Master服务失联，至少需要2个哨兵进行确认 ​ - 一组哨兵架构可以监听多套主从复制，只需要设置不同的主节点名称即可 sentinel down-after-milliseconds： ​ - 哨兵认为Master多少毫秒未有心跳响应则判断失联 ​ - 这里采用默认值，即30000毫秒（3分钟） sentinel parallel-syncs： ​ - 在进行主从复制时，Master最多同一时刻支持多少Slave的复制请求 ​ - 这里设置为1，代表所有Slave串行获取Master的RDB文件 ​ - 值越大，网络需求越高，Master压力越大，同步越快 ​ - 值越小，网络需求越低，Master压力越小，同步越慢 sentinel failover-timeout： ​ - 故障转移最大毫秒数，如超过该毫秒数则认为本次故障转移失败 ​ - 默认是30000毫秒（3分钟） ​ - 这里设置为默认值 sentinel auth-pass： ​ - 如果Master开启安全认证，哨兵链接时通过该配置项输入认证密码 entinel notification-script： ​ - 服务器无法正常联通时，设定的执行脚本，通常调试使用 启动哨兵 为了实验严谨度，我们先关闭3台Redis服务，重新配置主从： # 三台都做 $ redis-cli -h master -p 6379 shutdown # master $ redis-server /db/redis/6379/conf/redis.cnf # slave $ redis-server /db/redis/6379/conf/redis.cnf --slaveof 192.168.0.120 6379 三个节点均开启哨兵： $ redis-sentinel /db/redis/26379/conf/redis_26379.cnf 登录哨兵 哨兵节点是一个特殊的Redis节点，使用以下命令进行登录： $ redis-cli -h master -p 26379 # 关闭哨兵 redis-cli -h master -p 26379 shutdown 有以下的一些哨兵命令： Info Sentinel # 查看哨兵信息 Sentinel Masters # 查看所有的主节点信息（Redis服务） Sentinel master # 查看指定监听的主节点信息（Redis服务） Sentinel slaves # 查看指定监听的从节点信息（Redis服务） Sentinel get-master-addr-by-name # 查看监听的主节点名称与地址 Sentinel failover # 强制进行故障转移，即使主节点未宕机 Sentinel flushconfig # 刷新哨兵配置文件 如果你使用application驱动进行链接，则链接至3个哨兵节点即可。 故障模拟 关闭Master节点： $ redis-cli -h master -p 6379 shutdown 登录Slave1的哨兵，查看新的主节点，如果这一操作够快，你能看见下面的过程：： $ redis-cli -h slave1 -p 26379 slave1:26379> Sentinel get-master-addr-by-name node1 1) \"192.168.0.120\" 2) \"6379\" slave1:26379> Sentinel get-master-addr-by-name node1 1) \"192.168.0.130\" 2) \"6379\" 重启已宕机的Master节点： $ redis-server /db/redis/6379/conf/redis.cnf 在新库Slave1哨兵上查看当前所有从库节点信息，可以发现宕机掉的主库重启后会以新从库的身份重新加入主从： $ Sentinel slaves node1 选举权重 如果想指定某个从节点在故障后具有更高的优先晋升为主节点，可按照下面的方式进行配置，我们就以新从库（刚刚已经宕机的主库master）节点为例： $ redis-cli -h master -p 6379 master:6379> CONFIG GET slave-priority 1) \"slave-priority\" 2) \"100\" # 默认所有从节点都是100，该值越小优先级越高 # 如果为0则永不竞选 你需要将它设置为1或者，反正是小于100且不为0的数字： master:6379> CONFIG SET slave-priority 1 或者你也可以在搭建主从时进行配置，在服务配置文件(注意！不是哨兵配置文件)中填入该项： slave-priority 1 这样，在下次发生故障转移后，该节点将优先晋升为主库。 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:48 "},"数据库专栏/Redis/分片集群.html":{"url":"数据库专栏/Redis/分片集群.html","title":"分片集群","keywords":"","body":"功能概述 Redis Cluster是Redis的自带的官方分布式解决方案，提供数据分片、高可用功能，在3.0版本正式推出。 使用Redis Cluster能解决负载均衡的问题，内部采用哈希分片规则： 基础架构图如下所示： 图中最大的虚线部分为一个Cluster集群，由6个Redis实例组成。 集群分片 整个Cluster集群中有16384个槽位，必须要将这些槽位分别规划在3台Master中。 如果有任意1个槽位没有被分配，则集群创建不成功。 当集群中任意一个Master尝试进行写入操作后，会通过Hash算法计算出该条数据应该落在哪一个Master节点上。 如下图所示： 情况1：如果你未指定任何参数就进行写入，如在Master1上写入数据，经过内部计算发现该数据应该在Master2上写入时，会提示你应该进入Master2写入该条数据，执行并不会成功 情况2：如果你指定了一个特定参数进行写入，如在Master1上写入数据，经过内部计算发现该数据应该在Master2上写入时，会自动将写入环境重定向至Master2，执行成功 同理，读取数据也是这样，这个过程叫做MOVED重定向，如果你是情况1进行操作则必须手动进行重定向，情况2则会自动进行重定向。 集群通信 集群中各个节点的信息是互通的，这种现象由Gossip（流言）协议产生。 Gossip协议规定每个集群节点之间互相交换信息，使其能够彼此知道对方的状态。 在通信建立时，集群中的每一个节点都会单独的开辟一个TCP通道，用于与其他节点进行通信，这个通信端口会在基础端口上+10000。 通信建立成功后，每个节点在固定周期内通过特定规则选择节点来发送ping消息（心跳机制）。 当收到ping消息的节点则会使用pong消息作为回应，也就是说，当有一个新节点加入后，一瞬间集群中所有的其他节点也能够获取到该信息。 Gossip协议的主要职责就是进行集群中节点的信息交换，常见的Gossip协议消息有以下几点区分： meet：用于通知新节点加入，消息发送者通知接受者加入到当前集群 ping：集群内每个节点与其他节点进行心跳检测的命令，用于检测其他节点是否在线，除此之外还能交换其他额外信息 pong：用于回复meet以及ping信息，表示已收到，能够正常通行。此外还能进行群发更新节点状态 fail：当其他节点收到fail消息后立马把对应节点更新为下线状态，此时集群开始进行故障转移 初步搭建 地址规划 3台服务器，每台服务器开启2台实例构建基础主从。 服务器采用centos7.3，Redis版本为6.2.1 地址规划与结构图如下： 在每个节点hosts文件中加入以下内容； $ vim /etc/hosts 192.168.0.120 node1 192.168.0.130 node2 192.168.0.140 node3 集群准备 为所有节点下载Redis： $ cd ~ $ wget https://download.redis.io/releases/redis-6.2.1.tar.gz 为所有节点配置目录： $ mkdir -p /usr/local/redis_cluster/redis_63{79,80}/{conf,pid,logs} 所有节点进行解压： $ tar -zxvf redis-6.2.1.tar.gz -C /usr/local/redis_cluster/ 所有节点进行编译安装Redis： $ cd /usr/local/redis_cluster/redis-6.2.1/ $ make && make install 书写集群配置文件，注意！Redis普通服务会有2套配置文件，一套为普通服务配置文件，一套为集群服务配置文件，我们这里是做的集群，所以书写的集群配置文件，共6份： $ vim /usr/local/redis_cluster/redis_6379/conf/redis.cnf # 快速修改：:%s/6379/6380/g # 守护进行模式启动 daemonize yes # 设置数据库数量，默认数据库为0 databases 16 # 绑定地址，需要修改 bind 192.168.0.120 # 绑定端口，需要修改 port 6379 # pid文件存储位置，文件名需要修改 pidfile /usr/local/redis_cluster/redis_6379/pid/redis_6379.pid # log文件存储位置，文件名需要修改 logfile /usr/local/redis_cluster/redis_6379/logs/redis_6379.log # RDB快照备份文件名，文件名需要修改 dbfilename redis_6379.rdb # 本地数据库存储目录，需要修改 dir /usr/local/redis_cluster/redis_6379 # 集群相关配置 # 是否以集群模式启动 cluster-enabled yes # 集群节点回应最长时间，超过该时间被认为下线 cluster-node-timeout 15000 # 生成的集群节点配置文件名，文件名需要修改 cluster-config-file nodes_6379.conf 启动集群 启动集群 在启动集群时，会按照Redis服务配置文件的配置项判断是否启动集群模式，如图所示： 每个节点上执行以下2条命令进行服务启动： $ redis-server /usr/local/redis_cluster/redis_6379/conf/redis.cnf $ redis-server /usr/local/redis_cluster/redis_6380/conf/redis.cnf 集群模式启动，进程后会加上[cluster]的字样： $ ps -ef | grep redis root 51311 1 0 11:30 ? 00:00:00 redis-server 192.168.0.120:6379 [cluster] root 51329 1 0 11:30 ? 00:00:00 redis-server 192.168.0.120:6380 [cluster] root 51396 115516 0 11:31 pts/1 00:00:00 grep --color=auto redis 同时，查看一下集群节点配置文件，会发现生成了一组集群信息，每个Redis服务都是不同的： $ cat /usr/local/redis_cluster/redis_6379/nodes_6379.conf c8a8c7d52e6e7403e799c75302b6411e2027621b :0@0 myself,master - 0 0 0 connected vars currentEpoch 0 lastVoteEpoch 0 $ cat /usr/local/redis_cluster/redis_6380/nodes_6380.conf baa10306639fcaca833db0d521235bc9593dbeca :0@0 myself,master - 0 0 0 connected vars currentEpoch 0 lastVoteEpoch 0 # 第一段信息是这个Redis服务作为集群节点的一个身份编码 # 别名为集群的node-id 加入集群 现在虽然说每个服务都成功启动了，但是彼此之间并没有任何联系。 所以下一步要做的就是将6个服务加入至一个集群中，如下操作示例： $ redis-cli -h node1 -p 6379 node1:6379> cluster meet 192.168.0.130 6379 node1:6379> cluster meet 192.168.0.140 6379 node1:6379> cluster meet 192.168.0.120 6380 node1:6379> cluster meet 192.168.0.130 6380 node1:6379> cluster meet 192.168.0.140 6380 查看当前集群所有的节点： node1:6379> cluster nodes 214dc5a10149091047df1c61fd3415d91d6204ea 192.168.0.130:6379@16379 master - 0 1617291123000 1 connected baa10306639fcaca833db0d521235bc9593dbeca 192.168.0.120:6380@16380 master - 0 1617291120000 3 connected 7a151f97ee9b020a3c954bbf78cd7ed8a674aa70 192.168.0.140:6379@16379 master - 0 1617291123000 2 connected bae708f7b8df32edf4571c72bbf87715eb45c169 192.168.0.130:6380@16380 master - 0 1617291124175 4 connected fd1dde2a641727e52b4e82cfb351fe3c17690a17 192.168.0.140:6380@16380 master - 0 1617291124000 0 connected c8a8c7d52e6e7403e799c75302b6411e2027621b 192.168.0.120:6379@16379 myself,master - 0 1617291121000 5 connected 查看端口监听，可以发现Gossip监听的1000+端口出现了，此时代表集群各个节点之间已经能互相通信了： $ netstat -lnpt | grep redis tcp 0 0 192.168.0.120:6379 0.0.0.0:* LISTEN 51311/redis-server tcp 0 0 192.168.0.120:6380 0.0.0.0:* LISTEN 51329/redis-server tcp 0 0 192.168.0.120:16379 0.0.0.0:* LISTEN 51311/redis-server tcp 0 0 192.168.0.120:16380 0.0.0.0:* LISTEN 51329/redis-server 主从配置 6个服务之间并没有任何主从关系，所以现在进行主从配置，记录下上面cluster nodes命令输出的node-id信息，只记录主节点： hostname 节点 node-id node1 192.168.0.120:6379 c8a8c7d52e6e7403e799c75302b6411e2027621b node2 192.168.0.130:6379 214dc5a10149091047df1c61fd3415d91d6204ea node3 192.168.0.140:6379 7a151f97ee9b020a3c954bbf78cd7ed8a674aa70 首先是node1的6380，将它映射到node2的6379： $ redis-cli -h node1 -p 6380 node1:6380> cluster replicate 214dc5a10149091047df1c61fd3415d91d6204ea 然后是node2的6380，将它映射到node3的6379： $ redis-cli -h node2 -p 6380 node2:6380> cluster replicate 7a151f97ee9b020a3c954bbf78cd7ed8a674aa70 最后是node3的6380，将它映射到node1的6379： $ redis-cli -h node3 -p 6380 node3:6380> cluster replicate c8a8c7d52e6e7403e799c75302b6411e2027621b 查看集群节点信息，内容有精简： $ redis-cli -h node1 -p 6379 node1:6379> cluster nodes 192.168.0.130:6379@16379 master 192.168.0.120:6380@16380 slave 192.168.0.140:6379@16379 master 192.168.0.130:6380@16380 slave 192.168.0.140:6380@16380 slave 192.168.0.120:6379@16379 myself,master # myself表示当前登录的是那个服务 分配槽位 接下来我们要开始分配槽位了，为了考虑今后的写入操作能分配均匀，槽位也要进行均匀分配。 仅在Master上进行分配，从库不进行分配，仅做主库的备份和读库使用。 使用python计算每个master节点分多少槽位： $ python3 >>> divmod(16384,3) (5461, 1) 槽位分配情况如下，槽位号从0开始，到16383结束，共16384个槽位： 节点 槽位数量 node1:6379 0 - 5461 node2:6379 5461 - 10922 node3:6379 10922 - 16383 开始分配： $ redis-cli -h node1 -p 6379 cluster addslots {0..5461} $ redis-cli -h node2 -p 6379 cluster addslots {5462..10922} $ redis-cli -h node3 -p 6379 cluster addslots {10923..16383} 检查槽位是否分配正确，这里进行内容截取： $ redis-cli -h node1 -p 6379 node1:6379> CLUSTER nodes 192.168.0.130:6379@16379 master - 0 1617292240544 1 connected 5462-10922 192.168.0.140:6379@16379 master - 0 1617292239000 2 connected 10923-16383 192.168.0.120:6379@16379 myself,master - 0 1617292238000 5 connected 0-5461 # 看master节点的最后 检查状态 使用以下命令检查集群状态是否ok： $ redis-cli -h node1 -p 6379 node1:6379> CLUSTER info cluster_state:ok cluster_slots_assigned:16384 cluster_slots_ok:16384 cluster_slots_pfail:0 cluster_slots_fail:0 cluster_known_nodes:6 cluster_size:3 cluster_current_epoch:5 cluster_my_epoch:5 cluster_stats_messages_ping_sent:2825 cluster_stats_messages_pong_sent:2793 cluster_stats_messages_meet_sent:5 cluster_stats_messages_sent:5623 cluster_stats_messages_ping_received:2793 cluster_stats_messages_pong_received:2830 cluster_stats_messages_received:5623 MOVED重定向 现在我们在node1的master节点上进行写入： $ redis-cli -h node1 -p 6379 node1:6379> set k1 \"v1\" (error) MOVED 12706 192.168.0.140:6379 它会提示你去node2的master上进行写入。 这个就是MOVED重定向。 -c参数 如何解决这个问题？其实在登录的时候加上参数-c即可，-c参数无所谓你的Redis是否是集群模式，建议任何登录操作都加上，这样即使是Redis集群也会自动进行MOVED重定向： $ redis-cli -c -h node1 -p 6379 node1:6379> set k1 \"v1\" -> Redirected to slot [12706] located at 192.168.0.140:6379 OK 一并对主从进行验证，这条数据是写入至了node3的Master中，我们登录node2的Slave中进行查看： $ redis-cli -h node2 -p 6380 -c node2:6380> keys * 1) \"k1\" 故障转移 故障模拟 模拟node1的6379下线宕机，此时应该由node3的6380接管它的工作： $ redis-cli -h node1 -p 6379 shutdown 登录集群任意节点查看目前的集群节点信息： node2:6379> cluster nodes 214dc5a10149091047df1c61fd3415d91d6204ea 192.168.0.130:6379@16379 myself,master - 0 1617294532000 1 connected 5462-10922 bae708f7b8df32edf4571c72bbf87715eb45c169 192.168.0.130:6380@16380 slave 7a151f97ee9b020a3c954bbf78cd7ed8a674aa70 0 1617294533000 2 connected # 已下线 c8a8c7d52e6e7403e799c75302b6411e2027621b 192.168.0.120:6379@16379 master,fail - 1617294479247 1617294475173 5 disconnected 7a151f97ee9b020a3c954bbf78cd7ed8a674aa70 192.168.0.140:6379@16379 master - 0 1617294536864 2 connected 10923-16383 # 自动升级为主库，并且插槽也转移了 fd1dde2a641727e52b4e82cfb351fe3c17690a17 192.168.0.140:6380@16380 master - 0 1617294536000 6 connected 0-5461 baa10306639fcaca833db0d521235bc9593dbeca 192.168.0.120:6380@16380 slave 214dc5a10149091047df1c61fd3415d91d6204ea 0 1617294535853 1 connected 恢复工作 重启node1的6379： $ redis-server /usr/local/redis_cluster/redis_6379/conf/redis.cnf 登录node1的6379，发现他已经自动的进行上线了，并且作为node3中6380的从库： $ redis-cli -h node1 -p 6379 node1:6379> cluster nodes # 自动上线 c8a8c7d52e6e7403e799c75302b6411e2027621b 192.168.0.120:6379@16379 myself,slave fd1dde2a641727e52b4e82cfb351fe3c17690a17 0 1617294746000 6 connected cluster命令 以下是集群中常用的可执行命令，命令执行格式为： cluster 下表命令 命令如下，未全，如果想了解更多请执行cluster help操作： 命令 描述 INFO 返回当前集群信息 MEET [] 添加一个节点至当前集群 MYID 返回当前节点集群ID NODES 返回当前节点的集群信息 REPLICATE 将当前节点作为某一集群节点的从库 FAILOVER [FORCE | TAKEOVER] 将当前从库升级为主库 RESET [HARD | SOFT] 重置当前节点信息 ADDSLOTS [ ...] 为当前集群节点增加一个或多个插槽位，推荐在bash shell中执行，可通过{int..int}指定多个插槽位 DELSLOTS [ ...] 为当前集群节点删除一个或多个插槽位，推荐在bash shell中执行，可通过{int..int}指定多个插槽位 FLUSHSLOTS 删除当前节点中所有的插槽信息 FORGET 从集群中删除某一节点 COUNT-FAILURE-REPORTS 返回当前集群节点的故障报告数量 COUNTKEYSINSLOT 返回某一插槽中的键的数量 GETKEYSINSLOT 返回当前节点存储在插槽中的key名称。 KEYSLOT 返回该key的哈希槽位 SAVECONFIG 保存当前集群配置，进行落盘操作 SLOTS 返回该插槽的信息 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:48 "},"数据库专栏/Redis/trib.rb工具.html":{"url":"数据库专栏/Redis/trib.rb工具.html","title":"trib.rb工具","keywords":"","body":"安装介绍 redis-trib.rb是一款由Redis官方提供的集群管理工具，能够大量减少集群搭建的时间。 除此之外，还能够简化集群的检查、槽迁徙、负载均衡等常见的运维操作，但是使用前必须要安装ruby环境。 1）使用yum进行安装ruby： yum install -y rubygems 2）默认的ruby包管理工具镜像源在国外，将国外源删除添加国内源 gem sources --remove https://rubygems.org/ gem sources -a http://mirrors.aliyun.com/rubygems/ gem update --system 3）使用ruby的包管理工具下载必备依赖包，由于我使用的是6.2.1的Redis，可能没有最新的，就下载一个老版本的Redis驱动，经测试没有任何问题： gem install redis -v 3.3.5 另外，在新版Redis中，redis-trib.rb工具的功能都被集成在了redis-cli里，但依然需要ruby环境 搭建前戏 地址规划 首先我们准备2主2从的3台多实例服务器，利用redis-trib.rb工具搭建1个6节点3分片的集群（集群最少6节点）。 然后再使用redis-trib.rb工具增加1台多实例服务器，组成8节点4分片的集群。 之后再使用redis-trib.rb工具下线1台多实例服务器，变为6节点3分片的集群。 地址规划与架构图如下： 在每个节点hosts文件中加入以下内容； $ vim /etc/hosts 192.168.0.120 node1 192.168.0.130 node2 192.168.0.140 node3 192.168.0.150 node4 ！由于该工具具有难以发现的小bug，必定出现以下问题： 主从关系自动构建不准确，需要手动重新搭建主从关系，如果主从构建不合理，一旦发生灾难情况后果不堪设想 集群准备 为所有节点下载Redis： $ cd ~ $ wget https://download.redis.io/releases/redis-6.2.1.tar.gz 为所有节点配置目录： $ mkdir -p /usr/local/redis_cluster/redis_63{79,80}/{conf,pid,logs} 所有节点进行解压： $ tar -zxvf redis-6.2.1.tar.gz -C /usr/local/redis_cluster/ 所有节点进行编译安装Redis： $ cd /usr/local/redis_cluster/redis-6.2.1/ $ make && make install 书写集群配置文件，注意！Redis普通服务会有2套配置文件，一套为普通服务配置文件，一套为集群服务配置文件，我们这里是做的集群，所以书写的集群配置文件，共6份： $ vim /usr/local/redis_cluster/redis_6379/conf/redis.cnf # 快速修改：:%s/6379/6380/g # 守护进行模式启动 daemonize yes # 设置数据库数量，默认数据库为0 databases 16 # 绑定地址，需要修改 bind 192.168.0.120 # 绑定端口，需要修改 port 6379 # pid文件存储位置，文件名需要修改 pidfile /usr/local/redis_cluster/redis_6379/pid/redis_6379.pid # log文件存储位置，文件名需要修改 logfile /usr/local/redis_cluster/redis_6379/logs/redis_6379.log # RDB快照备份文件名，文件名需要修改 dbfilename redis_6379.rdb # 本地数据库存储目录，需要修改 dir /usr/local/redis_cluster/redis_6379 # 集群相关配置 # 是否以集群模式启动 cluster-enabled yes # 集群节点回应最长时间，超过该时间被认为下线 cluster-node-timeout 15000 # 生成的集群节点配置文件名，文件名需要修改 cluster-config-file nodes_6379.conf 集群搭建 启动集群 每个节点上执行以下2条命令进行服务启动： $ redis-server /usr/local/redis_cluster/redis_6379/conf/redis.cnf $ redis-server /usr/local/redis_cluster/redis_6380/conf/redis.cnf 集群模式启动，它的进程后会加上[cluster]的字样： $ ps -ef | grep redis root 78586 1 0 21:56 ? 00:00:00 redis-server 192.168.0.120:6379 [cluster] root 78616 1 0 21:56 ? 00:00:00 redis-server 192.168.0.120:6380 [cluster] root 78636 71501 0 21:56 pts/1 00:00:00 grep --color=auto redis 同时，查看一下集群节点配置文件，会发现生成了一组集群信息，每个Redis服务都是不同的： $ cat /usr/local/redis_cluster/redis_6379/nodes_6379.conf c71b52f728ab58fedb6e05a525ce00b453fd2f6b :0@0 myself,master - 0 0 0 connected vars currentEpoch 0 lastVoteEpoch 0 $ cat /usr/local/redis_cluster/redis_6380/nodes_6380.conf d645d06708e1eddb126a6c3c4e38810c188d0906 :0@0 myself,master - 0 0 0 connected vars currentEpoch 0 lastVoteEpoch 0 # 第一段信息是这个Redis服务作为集群节点的一个身份编码 # 别名为集群的node-id 自动化 现在我们有2个部分还没有做，1是对集群进行分槽工作，2是构建主从关系。 通过redis-trib.rb工具，这个步骤将变得异常简单，由于我的ruby是装在node1上，所以只需要在node1执行下面一句话即可。 $ cd /usr/local/redis_cluster/redis-6.2.1/src/ # 旧版Redis这里以脚本名开头 redis-trib.rb 跟上后面参数即可 $ redis-cli --cluster create 192.168.0.120:6379 192.168.0.140:6380 192.168.0.130:6379 192.168.0.120:6380 192.168.0.140:6379 192.168.0.130:6380 --cluster-replicas 1 参数释义： --cluster-replicas：指定的副本数，其实这一条命令的语法规则是如果副本数为1，第一个ip:port与它后面的1个ip:port建立1主1从关系，如果副本数是2，第一个ip:port与它后面的2个ip:port建立1主2从关系，以此类推 执行完这条命令后，输入yes，会看到以下信息： $ redis-cli --cluster create 192.168.0.120:6379 192.168.0.140:6380 192.168.0.130:6379 192.168.0.120:6380 192.168.0.140:6379 192.168.0.130:6380 --cluster-replicas 1 # 主从相关 >>> Performing hash slots allocation on 6 nodes... Master[0] -> Slots 0 - 5460 Master[1] -> Slots 5461 - 10922 Master[2] -> Slots 10923 - 16383 Adding replica 192.168.0.140:6379 to 192.168.0.120:6379 Adding replica 192.168.0.130:6380 to 192.168.0.140:6380 Adding replica 192.168.0.120:6380 to 192.168.0.130:6379 M: c71b52f728ab58fedb6e05a525ce00b453fd2f6b 192.168.0.120:6379 slots:[0-5460] (5461 slots) master M: 6a627cedaa4576b1580806ae0094be59c32fa391 192.168.0.140:6380 slots:[5461-10922] (5462 slots) master M: 282358c2fb0c7c16ec60f2c4043b52a0eb91e19f 192.168.0.130:6379 slots:[10923-16383] (5461 slots) master S: d645d06708e1eddb126a6c3c4e38810c188d0906 192.168.0.120:6380 replicates 282358c2fb0c7c16ec60f2c4043b52a0eb91e19f S: 7a7392cb66bea30da401d2cb9768a42bbdefc5db 192.168.0.140:6379 replicates c71b52f728ab58fedb6e05a525ce00b453fd2f6b S: ff53e43f9404981a51d4e744de38004a5c22b090 192.168.0.130:6380 replicates 6a627cedaa4576b1580806ae0094be59c32fa391 # 询问是否保存配置？输入yes Can I set the above configuration? (type 'yes' to accept): yes >>> Nodes configuration updated >>> Assign a different config epoch to each node >>> Sending CLUSTER MEET messages to join the cluster Waiting for the cluster to join . # 分槽相关，全部自动进行，无需手动操作 >>> Performing Cluster Check (using node 192.168.0.120:6379) M: c71b52f728ab58fedb6e05a525ce00b453fd2f6b 192.168.0.120:6379 slots:[0-5460] (5461 slots) master 1 additional replica(s) M: 282358c2fb0c7c16ec60f2c4043b52a0eb91e19f 192.168.0.130:6379 slots:[10923-16383] (5461 slots) master 1 additional replica(s) M: 6a627cedaa4576b1580806ae0094be59c32fa391 192.168.0.140:6380 slots:[5461-10922] (5462 slots) master 1 additional replica(s) S: d645d06708e1eddb126a6c3c4e38810c188d0906 192.168.0.120:6380 slots: (0 slots) slave replicates 282358c2fb0c7c16ec60f2c4043b52a0eb91e19f S: 7a7392cb66bea30da401d2cb9768a42bbdefc5db 192.168.0.140:6379 slots: (0 slots) slave replicates c71b52f728ab58fedb6e05a525ce00b453fd2f6b S: ff53e43f9404981a51d4e744de38004a5c22b090 192.168.0.130:6380 slots: (0 slots) slave replicates 6a627cedaa4576b1580806ae0094be59c32fa391 [OK] All nodes agree about slots configuration. >>> Check for open slots... >>> Check slots coverage... [OK] All 16384 slots covered. $ 仔细观察上面的主从关系就可以看到异常，我的规划是所有的6379为主节点，而6380为从节点，显然他没有按照我的意思进行划分主从。 这种情况还算好的，至少不同节点都是岔开的，怕就怕一台机器2个实例组成1主1从，如果是那样的结构主从就没有任何意义。 主从校正 由于上面自动部署时主从关系出现了问题，超乎了我们的预期（这可能是该工具的bug），所以我们要对其进行手动校正。 1）登录node3:6380，让其作为node1:6379的从库，由于node3:6380是一个主库，要想变为从库必须先清空它的插槽，而后进行指定： $ redis-cli -h node3 -p 6380 -c node3:6380> CLUSTER FLUSHSLOTS node3:6380> CLUSTER REPLICATE c71b52f728ab58fedb6e05a525ce00b453fd2f6b 2）登录node3:6379，让该库进行下线，此举是为了重新上线令其角色变为master： $ redis-cli -h node3 -p 6379 -c node3:6379> CLUSTER RESET 3）登录node1:6379（其实任意集群中的一个都行）重新发现node3:6379，并且记录下缺失的插槽信息： $ redis-cli -h node1 -p 6379 -c node1:6379> CLUSTER MEET 192.168.0.140 6379 node1:6379> CLUSTER NODES # 仅关注master最后这一部分信息，槽位 connected 10923-16383 connected 0-5460 # 已分配10923-16383、0-5460，缺失的插槽位为5461-10922 4）为node3:6379分配插槽： $ redis-cli -h node3 -p 6379 cluster addslots {5461..10922} 5）登录node2:6380，让其对应node3:6379，即前者作为后者的从库 $ redis-cli -h node2 -p 6380 node2:6380> CLUSTER REPLICATE 7a7392cb66bea30da401d2cb9768a42bbdefc5db 6）查看集群是否是成功运行的状态： node2:6380> CLUSTER INFO cluster_state:ok cluster_slots_assigned:16384 cluster_slots_ok:16384 cluster_slots_pfail:0 cluster_slots_fail:0 cluster_known_nodes:6 cluster_size:3 cluster_current_epoch:12 cluster_my_epoch:12 cluster_stats_messages_ping_sent:4406 cluster_stats_messages_pong_sent:4225 cluster_stats_messages_meet_sent:1 cluster_stats_messages_sent:8632 cluster_stats_messages_ping_received:4225 cluster_stats_messages_pong_received:4413 cluster_stats_messages_auth-req_received:4 cluster_stats_messages_received:8642 7）检查各个节点关系之间是否正常： node2:6380> CLUSTER NODES d645d06708e1eddb126a6c3c4e38810c188d0906 192.168.0.120:6380@16380 slave 282358c2fb0c7c16ec60f2c4043b52a0eb91e19f 0 1617335179000 3 connected 282358c2fb0c7c16ec60f2c4043b52a0eb91e19f 192.168.0.130:6379@16379 master - 0 1617335177627 3 connected 10923-16383 ff53e43f9404981a51d4e744de38004a5c22b090 192.168.0.130:6380@16380 myself,slave 7a7392cb66bea30da401d2cb9768a42bbdefc5db 0 1617335178000 12 connected 7a7392cb66bea30da401d2cb9768a42bbdefc5db 192.168.0.140:6379@16379 master - 0 1617335180649 12 connected 5461-10922 c71b52f728ab58fedb6e05a525ce00b453fd2f6b 192.168.0.120:6379@16379 master - 0 1617335179000 12 connected 0-5460 6a627cedaa4576b1580806ae0094be59c32fa391 192.168.0.140:6380@16380 slave 7a7392cb66bea30da401d2cb9768a42bbdefc5db 0 1617335179644 12 connected 下面可能是我上面操作时输错了node-id导致的，一般按正确步骤来说不用产生这种情况。 *8）发现节点关系还是不正常，node3:6380也对应了node3:6379，更改一下就好了，让其对应node1的6379： $ redis-cli -h node3 -p 6380 node3:6380> CLUSTER REPLICATE c71b52f728ab58fedb6e05a525ce00b453fd2f6b *9）再次检查，节点关系正常： node3:6380> CLUSTER NODES c71b52f728ab58fedb6e05a525ce00b453fd2f6b 192.168.0.120:6379@16379 master - 0 1617335489929 12 connected 0-5460 6a627cedaa4576b1580806ae0094be59c32fa391 192.168.0.140:6380@16380 myself,slave c71b52f728ab58fedb6e05a525ce00b453fd2f6b 0 1617335490000 12 connected 282358c2fb0c7c16ec60f2c4043b52a0eb91e19f 192.168.0.130:6379@16379 master - 0 1617335487913 3 connected 10923-16383 d645d06708e1eddb126a6c3c4e38810c188d0906 192.168.0.120:6380@16380 slave 282358c2fb0c7c16ec60f2c4043b52a0eb91e19f 0 1617335488000 3 connected 7a7392cb66bea30da401d2cb9768a42bbdefc5db 192.168.0.140:6379@16379 master - 0 1617335489000 12 connected 5461-10922 ff53e43f9404981a51d4e744de38004a5c22b090 192.168.0.130:6380@16380 slave 7a7392cb66bea30da401d2cb9768a42bbdefc5db 0 1617335490931 12 connected node3:6380> 集群扩容 发现节点 现在我们的node4还没有添加进集群，所以将node4进行添加： $ redis-cli -h node1 -p 6379 CLUSTER MEET 192.168.0.150 6379 $ redis-cli -h node1 -p 6379 CLUSTER MEET 192.168.0.150 6380 查看节点信息，对内容进行部分截取： $ redis-cli -h node1 -p 6379 node3:6380> cluster nodes # 这里 f3dec547054791b01cfa9431a4c7a94e62f81db3 192.168.0.150:6380@16380 master - 0 1617337335000 0 connected d1ca7e72126934ef569c4f4d34ba75562d36068f 192.168.0.150:6379@16379 master - 0 1617337337289 14 connected 目前node4的6379和6380并未建立槽位，也没有和其他节点建立联系，所以不能进行任何读写操作。 进行扩容 使用redis-trib.rb工具对新节点进行扩容，大体流程是每个节点拿出一部分槽位分配给node4:6379。 在槽位迁徙时会带着数据一起迁徙，这并不会影响正常业务，属于热扩容。 首先要做4分片的规划，每个节点共分4096个槽位： $ python3 >>> divmod(16384,4) (4096, 0) 接下来开始进行扩容，由于我们只在node1上装了ruby环境，所以在node1上执行： $ cd /usr/local/redis_cluster/redis-6.2.1/src/ # 旧版Redis这里以脚本名开头 redis-trib.rb，并且不需要添加--cluster参数 $ redis-cli --cluster reshard 192.168.0.120 6379 # 你需要分配多少？ How many slots do you want to move (from 1 to 16384)? 4096 # 你要给哪一个集群节点分配插槽？我是给node4节点的6379 what is the receiving node ID? d1ca7e72126934ef569c4f4d34ba75562d36068f # 你要从哪些集群节点给node4节点6379分配插槽呢？可以输入all代表所有节点平均分配 # 也可以输入所有节点node-ID以done结束，我这里是所有节点，需要node1:6379、node2:6379、node3:6379 # 共拿出4096的槽位分配给node4:6379 Please enter all the source node IDs. Type 'all' to use all the nodes as source nodes for the hash slots. Type 'done' once you entered all the source nodes IDs. Source node #1: all 经过漫长的等待，终于扩容完成了： $ redis-cli -h node1 -p 6379 cluster nodes 192.168.0.150:6379@16379 master - 0 1617337961000 14 connected 0-1364 5461-6826 10923-12287 192.168.0.130:6379@16379 master - 0 1617337967569 3 connected 12288-16383 192.168.0.120:6379@16379 myself,master - 0 1617337967000 12 connected 1365-5460 192.168.0.140:6379@16379 master - 0 1617337963000 13 connected 6827-10922 查看集群节点信息，发现他分配的并不是特别均匀，只要误差在2%以内，就算正常范围。 主从修改 如果你在线上生产环境中对Redis集群进行了扩容，一定要注意主从关系。 手动的对主从关系进行校正，这里不再进行演示。 集群缩容 移除节点 下线节点时，节点如果持有槽必须指定将该槽迁徙到别的节点。 在槽迁徙时，数据也会一并迁徙，并不影响业务。 同时，当槽迁徙完成后，可在集群中对该节点进行遗忘。 进行缩容 这里缩容对象还是node4:6379，它本身具有4096个插槽，我们需要分别把4096个插槽移动到node1:6379、node2:6379、node3:6379上。 计算每个节点分多少： $ python3 >>> divmod(4096,3) (1365, 1) # 2个分1365 1个分1366 开始缩容，以下操作做3次： $ cd /usr/local/redis_cluster/redis-6.2.1/src/ # 旧版Redis这里以脚本名开头 redis-trib.rb，并且不需要添加--cluster参数 $ redis-cli --cluster reshard 192.168.0.120 6379 >>> Check for open slots... >>> Check slots coverage... [OK] All 16384 slots covered. # 你想移动多少插槽？2次1365，1次1366 How many slots do you want to move (from 1 to 16384)? 1365 # 你想由谁来接收？ node1:6379、node2:6379、node3:6379的node-id What is the receiving node ID? 282358c2fb0c7c16ec60f2c4043b52a0eb91e19f # 你想指定那个节点发送插槽？ Please enter all the source node IDs. Type 'all' to use all the nodes as source nodes for the hash slots. Type 'done' once you entered all the source nodes IDs. # node4:6379的node-id Source node #1: d1ca7e72126934ef569c4f4d34ba75562d36068f Source node #2: done # 输入yes Do you want to proceed with the proposed reshard plan (yes/no)? yes 扩容完成后检查集群状态： $ redis-cli -h node1 -p 6379 cluster info cluster_state:ok cluster_slots_assigned:16384 cluster_slots_ok:16384 cluster_slots_pfail:0 cluster_slots_fail:0 cluster_known_nodes:8 cluster_size:3 cluster_current_epoch:17 cluster_my_epoch:15 cluster_stats_messages_ping_sent:17672 cluster_stats_messages_pong_sent:26859 cluster_stats_messages_meet_sent:7 cluster_stats_messages_auth-req_sent:10 cluster_stats_messages_auth-ack_sent:2 cluster_stats_messages_update_sent:23 cluster_stats_messages_mfstart_sent:1 cluster_stats_messages_sent:44574 cluster_stats_messages_ping_received:17283 cluster_stats_messages_pong_received:24508 cluster_stats_messages_meet_received:5 cluster_stats_messages_fail_received:1 cluster_stats_messages_auth-req_received:2 cluster_stats_messages_auth-ack_received:5 cluster_stats_messages_mfstart_received:1 cluster_stats_messages_received:41805 查看node4:6379是否有未分配出去的插槽： $ redis-cli -h node1 -p 6379 cluster nodes # 没有占据任何槽位、已被全部分配出去 d1ca7e72126934ef569c4f4d34ba75562d36068f 192.168.0.150:6379@16379 master - 0 1617349187107 14 connected f3dec547054791b01cfa9431a4c7a94e62f81db3 192.168.0.150:6380@16380 master - 0 1617349182874 0 connected 进行下线 现在就可以对node4:6379与node4:6380进行下线了，任意登录集群中某一节点，输入以下命令： $ redis-cli -h node1 -p 6379 cluster FORGET d1ca7e72126934ef569c4f4d34ba75562d36068f $ redis-cli -h node1 -p 6379 cluster FORGET f3dec547054791b01cfa9431a4c7a94e62f81db3 检查是否以从节点中移除： $ redis-cli -h node1 -p 6379 cluster nodes ff53e43f9404981a51d4e744de38004a5c22b090 192.168.0.130:6380@16380 slave 7a7392cb66bea30da401d2cb9768a42bbdefc5db 0 1617349417000 17 connected d645d06708e1eddb126a6c3c4e38810c188d0906 192.168.0.120:6380@16380 slave 282358c2fb0c7c16ec60f2c4043b52a0eb91e19f 0 1617349415310 16 connected 282358c2fb0c7c16ec60f2c4043b52a0eb91e19f 192.168.0.130:6379@16379 master - 0 1617349414244 16 connected 5461-6825 12288-16383 c71b52f728ab58fedb6e05a525ce00b453fd2f6b 192.168.0.120:6379@16379 myself,master - 0 1617349414000 15 connected 0-5460 7a7392cb66bea30da401d2cb9768a42bbdefc5db 192.168.0.140:6379@16379 master - 0 1617349416000 17 connected 6826-12287 6a627cedaa4576b1580806ae0094be59c32fa391 192.168.0.140:6380@16380 slave c71b52f728ab58fedb6e05a525ce00b453fd2f6b 0 1617349417761 15 connected 至此，node4:6379以及node4:6380成功下线。 主从修改 如果你在线上生产环境中对Redis集群进行缩容，一定要注意主从关系。 手动的对主从关系进行校正，这里不再进行演示。 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:48 "},"数据库专栏/Redis/清理策略.html":{"url":"数据库专栏/Redis/清理策略.html","title":"清理策略","keywords":"","body":"删除策略 基本介绍 Redis数据存放在内存中，具有3种删除策略： 定时删除 惰性删除 定期删除 定时删除 之前介绍过几种对Redis的键做时效性的设置： 通用: expireat pexpireat 字符串: setex psetex 查询: TTL PTTL 定时删除的策略无外乎对key做这种时效性操作，当到期后则执行自动删除的策略。 优点：节约内存，到时就删，释放比较快速 缺点：CPU压力大，在key到期时，无论CPU多么繁忙，它都会让CPU把自己立马删除，会影响Redis服务器响应时间和指令吞吐量 总结：时间换空间，CPU性能换存储空间 惰性删除 当数据到达过期时间后，不做任何处理，等待下次访问数据时做操作： 如果未过期，返回数据 如果过期了，删除，返回不存在 优点：节约CPU性能，发现到了非删不可的时候才删 缺点：内存压力大，会出现长期占用内存的数据 总结：用存储空间换区处理器性能，也就是时间换空间 定期删除 周期性的轮询Redis数据库中时效性数据，采用随机抽取的策略，利用过期数据占比的方式控制删除频度。 特点1：CPU性能占用设有峰值，检测频度可自定义设置 特点2：内存压力不是很大，长期占用内存的冷数据会被持续清理 总结：周期性抽查内存空间（随机抽查、重点抽查） 逐出算法 基本介绍 逐出算法指的是当有新的数据进行插入，此时内存却又不足该怎么办。 总共有8种逐出算法。 Redis使用内存存储数据，在执行每一个命令前，会调用freeMemoryIfNeeded()检测内存是否充足。如 果内存不满足新加入数据的最低存储要求，redis要临时删除一些数据为当前指令清理存储空间。清理数据 的策略称为逐出算法。 注意:逐出数据的过程不是100%能够清理出足够的可使用的内存空间，如果不成功则反复执行。当对所 有数据尝试完毕后，如果不能达到内存清理的要求，将出现错误信息。 相关配置 以下的配置是影响数据逐出的因素： 1）最大可使用内存： maxmemory 占用物理内存的比例，默认为0代表不受限制，生成中建议设置为50%左右。 2）每次选取待删除数据的个数： maxmemory-samples 选取数据时并不会全库扫描，因为这导致严重的性能消耗，降低读写性能。 故采用随机获取数据的方式作为待检测删除数据 3）删除策略 maxmemory-policy 达到最大内存后，对被挑选出来的数据进行删除的策略 相关算法 检测易失数据(可能会过期的数据集server.db[i].expires ) ： volatile-lru：挑选最近最少使用的数据淘汰 volatile-lfu：挑选最近使用次数最少的数据淘汰 volatile-ttl：挑选将要过期的数据淘汰 volatile-random：任意选择数据淘汰 检测全库数据(所有数据集server.db[i].dict )： allkeys-lru：挑选最近最少使用的数据淘汰 allkeys-lfu：挑选最近使用次数最少的数据淘汰 allkeys-random：任意选择数据淘汰 放弃数据驱逐： no-enviction(驱逐)：禁止驱逐数据(redis4.0中默认策略)，会引发错误OOM(Out Of Memory) Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:48 "},"数据库专栏/Redis/缓存相关.html":{"url":"数据库专栏/Redis/缓存相关.html","title":"缓存相关","keywords":"","body":"应用场景 Redis常用于数据缓存，与MySQL进行搭配能有良好的效果。 如下图所示： Redis数据存储在内存中，读取操作比MySQL从磁盘数据页读取快了不止千倍，因此使用Redis作为缓存是十分明智的选择。 但是这样的使用场景依然会发生很多意料之外的问题，本文将对其进行简单的探究。 缓存雪崩 名词认识 缓存数据大面积同一时间失效，造成所有查询操作都直逼MySQL，查询速度大幅度降低，并发量高的情况下MySQL可能产生宕机。 导致因素： 缓存数据设置了相同的TTL Reids挂掉了 解决方案 1）缓存数据时为每一个缓存加上随机值，让其过期时间均有不同 setRedis（Key，value，time + Math.random() * 10000）； 2）热点数据永不删除，如首页轮播图等重要数据，只有当MySQL更新后才对该热点缓存进行更新 除此之外，做好主从+哨兵或者集群的高可用架构，分担单Redis服务的压力，防止单服务宕机 当事发时，采用本地缓存+限流的策略，减少MySQL的压力 事发后使用Redis持久化对数据进行恢复 缓存击穿 名词认识 缓存雪崩是指大面积缓存同一时刻失效，而缓存击穿是指一个key过于热门，导致大并发频繁请求该key 此时如果该key的过期时间一到，所有请求都直接访问MySQL，这就是缓存击穿 解决方案 1）对热点缓存进行分析，设置其永不过期，只有当MySQL更新后才对该热点缓存进行更新 2）限流策略，当热点缓存失效后进行限流，减少MySQL承载的并发量 缓存穿透 名词认识 缓存穿透是指大量的请求在缓存中和MySQL中都不存在。 假设，请求时的条件为id = -1，这是一个非法数据，缓存和数据库都没有，经过2次查询之后发现啥都没有，造成额外的查询资源消耗 可能导致的因素： 用户误操作 恶意竞争 黑客攻击 解决方案 1）在用户请求时屏蔽非法请求，如id 2）使用性能代价较小的查询对其进行过滤，如布隆过滤器 3）设置一个空值（存活时间短）到缓存中，如请求 id 如果你想了解布隆过滤器，可点击跳转 双写一致性 名词认识 当查询时： 读走缓存 缓存没有查MySQL 查到了更新缓存，查不到进行返回 结合本文第一幅图进行了解 双写一致性的问题是，当MySQL数据更新后如何更新缓存中的数据，如下图？ 如何一致 前提：两方的修改必须要同时成功或者同时失败，所以这会演变成一个分布式事务的问题。 方案1）先操作数据库再操作缓存： 更新数据库 删除缓存 这里为什么是删除缓存而非更新缓存呢？ 其实我们只需要等待下一次对该数据的读取操作进行时再设置缓存即可。 这样做能带来2点好处： 保证了分布式事务的一致性，基于日志优先写的原则，如果数据库没有进行落盘操作而缓存更新了，则可能会导致接下来的操作出现问题 减缓写入时间，只写进MySQL而直接删除缓存在高并发情况下是良好的策略，如果此时更新完MySQL的数据再去更新缓存，势必造成写入时间过长，用户体验不好的情况（删除操作比更新操作处理更简单） 方案2）先操作缓存，再操作数据库： 删除缓存 更新数据库 这个方案比较麻烦一点，必须设置这一过程为串行化，否则在高并发情况下可能出现问题。 以下场景示例： 线程A删除了缓存 线程B查询，发现缓存已不存在 线程B去数据库查询得到旧值 线程B将旧值写入缓存 线程A将新值写入数据库 解决过程是做一个串行化的任务队列，将每个线程的操作存放在队列中进行逐一执行，保证2边数据的一致性： 综上所述，更推荐方案1，方案2在高并发下的表现并不如意.. Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2022-06-05 17:54:48 "}}