{"./":{"url":"./","title":"Introduction","keywords":"","body":"专题阅读 我从2016年开始系统学习编程之后，便一直零零散散的记录着各种各样的笔记。 其中收集过很多相关资料，但是一直没有汇集成册。 刚好最近比较有空闲，就将自己的学习笔记汇聚成册，希望能够给大家提供帮助。 整体笔风可能不是特别面向新手，但是也应该能够对你有所帮助。 涵盖3大编程语言：Python\\Golang\\JavaScript 涵盖4大数据库产品：MySQL\\Redis\\Elasticsearch\\MongoDB 关于系统着重使用MacOS 10.14.6以及CentOS 7.3，暂时不提供Windows的相关文章。 系统配置是Core i5 4核心4线程、8G RAM、256SSD，也算是比较老的配置了。 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-05-12 17:14:06 "},"杂谈专栏/summary.html":{"url":"杂谈专栏/summary.html","title":"杂谈专栏","keywords":"","body":"这一个专题更加的符合通用性，不拘泥于语言，或者说适用于大部分语言。 为什么命名为杂谈呢？因为实在是不好归类... Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-05-12 16:57:15 "},"杂谈专栏/编程语言区别.html":{"url":"杂谈专栏/编程语言区别.html","title":"编程语言区别","keywords":"","body":"低级语言 语言的高级和低级之分并不是说语言本身的层次高低，而是指的是与底层硬件的密切程度。 就如同机器语言与汇编语言就是直接与底层硬件打交道的语言，故也被称为低级语言。 机器语言 机器语言是不通过任何操作系统就可以直接与底层硬件打交道的语言，说白了就是计算机能读懂的二进制。 想要使用机器语言就得充分的了解计算机底层硬件的各个知识。 虽然这可能会花上你半生的时间，但是机器语言的执行效率却是无与伦比的高，计算机不需要通过任何编译就能直接运行。 与之相反的是机器语言的开发效率却是慢到令人发指，除了你需要去学习底层硬件相关的知识外还需要对每一条二进制指令烂熟于心，更加恐怖的是面对满屏的010101如果敲错一个字符就全部推倒重来，显然这已经超出了普通人所能承受的极限。 #指令部份的示例 0000 代表 加载（LOAD） 0001 代表 存储（STORE） ... ​ #暂存器部份的示例 0000 代表暂存器 A 0001 代表暂存器 B ... ​ #存储器部份的示例 000000000000 代表地址为 0 的存储器 000000000001 代表地址为 1 的存储器 000000010000 代表地址为 16 的存储器 100000000000 代表地址为 2^11 的存储器 ​ #集成示例 0000,0000,000000010000 代表 LOAD A, 16 0000,0001,000000000001 代表 LOAD B, 1 0001,0001,000000010000 代表 STORE B, 16 0001,0001,000000000001 代表 STORE B, 1[1] 名词 描述 执行效率 极高 开发效率 极低 跨平台性 极差（由于必须依赖具体的硬件，故移植性极差） 汇编语言 汇编语言仅仅是用一个英文标签代表一组二进制指令，毫无疑问，比起机器语言，汇编语言是一种进步，但汇编语言的本质仍然是直接操作硬件，因此汇编语言仍是比较低级/底层的语言、因为它十分的贴近计算机硬件。 汇编的中打印一句hello world，需要写十多行，如下： ; hello.asm section .data ; 数据段声明 msg db \"Hello, world!\", 0xA ; 要输出的字符串 len equ $ - msg ; 字串长度 section .text ; 代码段声明 global _start ; 指定入口函数 _start: ; 在屏幕上显示一个字符串 mov edx, len ; 参数三：字符串长度 mov ecx, msg ; 参数二：要显示的字符串 mov ebx, 1 ; 参数一：文件描述符(stdout) mov eax, 4 ; 系统调用号(sys_write) int 0x80 ; 调用内核功能 ; 退出程序 mov ebx, 0 ; 参数一：退出代码 mov eax, 1 ; 系统调用号(sys_exit) int 0x80 ; 调用内核功能 名词 描述 执行效率 极高 开发效率 低 跨平台性 极差（由于必须依赖具体的硬件，故移植性极差） 高级语言 高级语言并不关心底层硬件到底怎么样，因为高级语言是在和操作系统打交道。 而操作系统又是管控硬件的软件，所以高级语言相较于低级语言来说它的开发效率肯定是要快上不少，但是在执行效率上却有所损失。 对于语言的好坏一味的按照执行效率来区分并非是正确的，语言本身只是一种工具，使用语言的人才是真正的操纵者。 语言的对比只应场景适不适用，其本身并无强弱之分。 比如要对底层硬件进行开发，那么无疑汇编语言是最佳的选择，它能与本机硬件打交道所以能充分发挥自己执行效率高的特性，再比如要做一款网络爬虫相关的软件，由于网络具有延迟性会拖慢程序整体的运行速度，故使用汇编语言来编写爬虫便成了弱势（开发周期长，网络环境让汇编语言的高执行效率也体现不出来）。 高级语言中按照翻译方式的不同又大体可分为两类，分别是编译型语言与解释型语言。 编译型语言 如Golang，C语言等均为编译型语言。 编译型语言特点： 执行效率高：生成的目标文件可以脱离语言环境独立执行（因为都是存的二进制指令） 开发效率低：如果程序需要修改某一功能则必须修改源程序中的代码后再次生成目标程序，倘若只有目标程序而没有源程序的话则修改原本的功能是一件很困难的事情，这样做的好处是保证了代码的安全性，除开通过反编译技术手段否则看不见源代码 跨平台性差：大多数编译型语言的代码只针对某一个平台下进行编译，前平台下的编译结果（目标程序）无法拿到不同的平台上使用 其他：现在大多数的编程语言都是编译型的。编译程序（GCC）将源程序翻译成目标程序后保存在另一个文件中，该目标程序可脱离编译程序直接在计算机上多次运行。大多数软件产品都是以目标程序形式发行给用户的，不仅便于直接运行提升执行效率，同时又使他人难于盗用其中的技术 解释型语言 如Python，JavaScript均为解释型语言。 解释型语言特点： 执行效率低：在解释型语言的实现中，解释器并不产生目标机器代码，而是产生易于执行的中间代码。这种中间代码与机器代码是不同的，中间代码的解释是由软件支持的，不能直接使用硬件，软件解释器通常会导致执行效率偏低 开发效率高：用解释型语言编写的程序是由另一个可以理解中间代码的解释程序执行的，与编译程序不同的是，解释程序的任务是逐一将源程序的语句解释成可执行的机器指令，不需要将源程序翻译成目标代码再执行。解释程序的优点是当语句出现语法错误时，可以立即引起程序员的注意。让程序员在程序开发期间就能进行校正，故开发效率高于编译性语言 跨平台性强：代码运行是依赖于解释器，不同平台有对应版本的解释器，所以解释型语言的跨平台性更强 其他：对于解释型Basic语言，需要一个专门的解释器解释执行Basic程序，每条语句只有在执行时才被翻译，这种解释型语言每执行一次就翻译一次，因而效率低下。一般地，动态语言都是解释型的，例如：Tcl、Perl、Ruby、VBScript、JavaScript等 除此之外，还有一种混合型语言，如Java：Java语言首先会生成Java汇编，然后通过虚拟机进一步转换成计算机可以识别的二进制汇编语言。 动态与静态 动态类型：如果一门语言可以在运行时改变变量的类型，那我们称之为动态类型语言（如Python） 静态类型：相反，如果一门语言不可以在运行时改变变量的类型，则称之为静态类型语言（如Golang） 动态类型示例（Python演示）： >>> string = str(\"hello,world\") >>> type(string) >>> string = b\"\" >>> type(string) >>> 静态类型示例（Golang演示）： func main() { var str string str = \"hello,world\" fmt.Printf(\"%T\",str) str = 't' // 编译出现异常，不允许改变类型 } 强类型与弱类型 强类型：如果一门语言不倾向于对变量的类型做隐式转换，那我们将其称之为强类型语言（如Python） 弱类型：相反，如果一门语言倾向于对变量的类型做隐式转换，那我们则称之为弱类型语言（如JavaScript） 强类型示例（Python演示）： >>> 1 == \"1\" False 弱类型示例（JavaScript演示）： \"use strict\"; console.log(1 == \"1\"); // true Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-05-12 17:01:52 "},"杂谈专栏/详解字符编码.html":{"url":"杂谈专栏/详解字符编码.html","title":"详解字符编码","keywords":"","body":"字符编码 计算机使用计算机语言（2进制）表示数据，人类使用自然语言表示数据。 人类若想和计算机进行无障碍沟通，必须要通过一本记载着计算机语言与自然语言关系的词典。 而通过这本词典与计算机进行沟通交互的过程即可被称为字符的编码、解码的过程： 编码是指将自然语言转换为计算机语言的过程。 解码是指将计算机语言转换为自然语言的过程。 ASCII 计算机由西方世界发明，所以第一个字符编码表仅记录了一些英文与符号，该表也被称为ASCII码表。 它仅支持一些英文字符与特殊符号，不支持其他国家的语言字符。 实际上ASCII码表在设计之初，就预留了一些位置，最初的ASCII码表中每一个字符仅占用7bit的位置，也就最多表示128个字符。 最初的ASCII码表仅有128个字符，后来经过扩展，又新增了128个字符，此时的ASCII码表中，一个字符占用1Bytes（8bit）的位置。： GBK 随着计算机在世界范围内高速发展，ASCII码表已经不满足广大用户的需求了。 此时，各个国家开始推出自己的字符编码表，如： 日本的Shift-JIS表等 韩国的Euc-Kr表等 中国的gb2312、GBK表等 ... 这些表都有一个特点，即除了包含原本的ASCII码表之外还包含了本国的通用语言。 在GBK编码表中，一个英文字符占用1Bytes(8bit)，而一个中文字符则占用2Bytes(16bit)。 此时，出现了1个严重的问题，即跨国的通信问题，如下图所示： Unicode 为了解决这个问题，在1990年的时候推出了Unicode表，并且在1994年正式使用。 它详细的记录了所有自然语言与计算机语言的对应关系，在（usc2标准）中每一个字符不管是英文还是中文都占用2个Bytes（16bit），而在（usc4标准）中则统一占用4个Bytes（32bit），这样就解决了跨国通信的问题。 对比ASCII码表英文字符仅占用1个Bytes而言，如果直接使用Unicode编码进行文件存储则存储空间会直接翻倍，因此Unicode表仅存在于内存之中，而在网络传输以及文件存储上则采用了另外的编码格式。 换句话说，Unicode仅作为翻译词典存在于计算机内部，Unicode因为包含了所有自然语言与计算机语言的关系，因此作为翻译词典是最合适不过的。 UTF8 如下图，中文网站由GBK编码存储，国内的计算机中应该都有GBK编码，所以访问该网站非常轻松，而在日本计算机上若想访问该网站则必须要先下载GBK后方能以GBK的解码形式打开该网站，否则会产生乱码问题。 那么有没有一种编码，能够统一整个互联网，让所有计算机都用这种编码进行文件存储、网络传输呢？ 此时，出现了UTF8编码，全称为Unicode Transformation Format，即Unicode的转换格式，它是一种可变长的编码格式。 在UTF8编码格式中，英文字符统一占用1Bytes(8bit)的位置，而中文字符则占用3Bytes(24bit)或者4Bytes(32Bytes)的位置。 UTF8编码是未来的发展趋势，它与Unicode对比的唯一区别在于它不包含其他字符编码表。 在依然存在以GBK编码格式、Shift-JIS编码格式进行文件存储的环境下，使用UTF8作为翻译词典并不合适。 但是如果有一天所有人都统一使用UTF8进行文件存储网络传输的话，那么就不再需要包含其他字符编码表了，此时UTF8将会真正代替Unicode入驻内存中成为翻译词典，当然这是后话，目前还没有达到这样的理想情况。 UTF8的编解码 UTF8与Unicode的关系如下： 编码过程 如我们要将“云”字根据UTF8格式存储到磁盘中： 1.通过Python3中的hex()和ord()函数先得出该字符Unicode的16进制表现形式： >>> hex(ord(\"云\")) '0x4e91' 2.再将这个16进制的Unicode字符转换为2进制，那么这个2进制就是“云”字在内存中存储的样子： >>> bin(int(\"4e91\",base=16)) '0b100111010010001' 3.现在，计算机要把“云”字写入磁盘中，由于是使用的UTF8编码格式，所以先确定它的占用空间是3Bytes还是4Bytes，规则如下，套用表即可： 码位范围（Unicode十六进制） utf-8 0000 ~ 007F 用1个Bytes表示 0080 ~ 07FF 用2个Bytes表示 0800 ~ FFFF 用3个Bytes表示 4e91 在这里，第3分区 10000 ~ 10FFFF 用4个Bytes表示 4.确定了“云”字占用3Bytes，我们可以通过一个模板，将Unicode的2进制转换为UTF8的2进制： 码位范围（十六进制） 转换模板 0000 ~ 007F 0XXXXXXX 0080 ~ 07FF 110XXXXX 10XXXXXX 0800 ~ FFFF 1110XXXX 10XXXXXX 10XXXXXX 10000 ~ 10FFFF 11110XXX 10XXXXXX 10XXXXXX 10XXXXXX 5.根据分区信息，选用3Bytes的模板，进行转换，从右至左依次填充，不够的使用0进行填充： 1110XXXX 10XXXXXX 10XXXXXX 100 111010 010001 1110XXXX 10XXXXXX 10XXXXXX 0100 111010 010001 # 填充0 11100100 10111010 10010001 # 结果 所以最后得出的结果，“云”用UTF8格式保存至磁盘的话，2进制格式为11100100 10111010 10010001。 解码过程 如果要将“云”字UTF8的2进制格式转换为字符，则还是需要通过Unicode进行解码过程。 当计算机读取到这个文件是以UTF8格式进行存储后，内部已经做好了通过UTF8进行解码的准备。 开始读取后，计算机会将硬盘中存储的UTF8的2进制格式文字信息加载至内存中： 11100100 10111010 10010001 现在，Unicode会参照模板，通过UTF8分区信息提取出该文字Unicode的2进制格式： 码位范围（十六进制） 转换模板 0000 ~ 007F 0XXXXXXX 0080 ~ 07FF 110XXXXX 10XXXXXX 0800 ~ FFFF 1110XXXX 10XXXXXX 10XXXXXX 10000 ~ 10FFFF 11110XXX 10XXXXXX 10XXXXXX 10XXXXXX 11100100 10111010 10010001 “云”字的二进制信息格式刚好对应第3分区，那么我们按照第3分区的模板格式对UTF8的2进制表现形式进行掐头工作，将它转变为Unicode的2进制表现格式。 1110XXXX 10XXXXXX 10XXXXXX 11100100 10111010 10010001 0100 111010 010001 # 掐头 100111010010001 # 结果 得到了结果为100111010010001，现在可以通过一系列Python3函数将它转换为Unicode字符，转换过程如下所示： >>> int(\"100111010010001\",base=2) 20113 >>> hex(20113) '0x4e91' >>> \"\\u4e91\" '云' Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-10 13:36:03 "},"杂谈专栏/放一些常见题目.html":{"url":"杂谈专栏/放一些常见题目.html","title":"常见问题大全","keywords":"","body":"常见问题 Python 基础知识 %accordion%解释器版本升级%accordion% py2项目如何迁移成py3? 答案： six模块 使用py3自带的2to3.py工具将py2转换为py3 %/accordion% %accordion%值比较与引用比较%accordion% 聊聊is和==的区别？ 答案： is会判断2个对象是否来自同一引用 ==仅2个对象的判断表现形式是否相同 %/accordion% %accordion%内存管理%accordion% Python是如何进行内存管理的? Python的程序会内存泄漏吗?说说有没有什么方面阻止或检测内存泄漏 答案： python是使用私有堆进行内存管理的，我们无法访问，只能通过接口进行一些相关操作，python程序存在内存泄漏，主要是由于python是使用的引用计数的方式进行内存管理的，而如果重写__del__方法时声明了变量，因为计数还未变为0，所以会存在内存泄露。 阻止或检测的方法： 1. 程序员管理好每个python对象的引用，尽量在不需要使用对象的时候，断开所有引用 2. 尽量少通过循环引用组织数据，可以改用weakref做弱引用或者用id之类的句柄访问对象 3. 通过gc模块的接口可以检查出每次垃圾回收有哪些对象不能自动处理，再逐个逐个处理 %/accordion% %accordion%深浅拷贝%accordion% 简述Python深浅拷贝？ 答案： 不可变类型没有深浅拷贝，所有对不可变类型的深浅拷贝均是引用 所以深浅拷贝仅针对容器类型： 浅拷贝：仅拷贝容器的第一层，将不是不可变类型的对象都复制一份 深拷贝：递归的拷贝容器中所有层，将不是不可变类型的对象都复制一份 %/accordion% %accordion%循环打印乘法表%accordion% 用Python实现99乘法表(用两种不同的方法实现) 答案1： for i in range(1, 10): for j in range(1, 1 + i): print(\"{} * {} = {}\".format(i, j, i * j), end=\"\\t\") print(\"\") 答案2： i = 1 j = 1 while i %/accordion% %accordion%文件读取%accordion% 一个大小为100G的文件etl_log.txt, 要读取文件中的内容, 写出具体过程代码？ 答案： with open(\"fileName\", mode=\"rt\", encoding=\"utf8\") as f: for item in f: print(item) # file对象就是一个迭代器，具有惰性求值的功能 %/accordion% %accordion%计数器实现%accordion% 有一个数组[3, 4, 1, 2, 5, 6, 6, 5, 4, 3, 3] 请写一个函数, 找出该数组中没有重复的数的总和 ，例如上面数据的没有重复的总和为1+2=3。 答案： def add(seq): result = 0 saveTable = {} for item in seq: if item not in saveTable: saveTable[item] = 1 else: saveTable[item] += 1 for sumNumber in saveTable: if saveTable[sumNumber] == 1: result += sumNumber return result print(add([3, 4, 1, 2, 5, 6, 6, 5, 4, 3, 3])) %/accordion% 数据类型 %accordion%布尔类型判断%accordion% 下列哪种说法是错误的 除字典类型外, 所有标准对象均可用于布尔测试 空字符串的布尔值是False 空列表对象的布尔值是False 值为0的任何数字对象的布尔值是False 答案： 1 字典类型也能用于布尔测试 %/accordion% %accordion%字典的hash%accordion% 选择代码的运行结果： country_counter ={} def addone(country): if country in country_counter: country_counter[country ]+=1 else: country_counter[country ]= 1 addone(\"China\") addone(\"Japan\") addone(\"china\") print len(country_counter ) A:0 B:1 C:2 D:3 E:4 答案：D，China和china的hash值不同 %/accordion% %accordion%字典的key是否存在？%accordion% 如何判断一个字典中的key是否存在？方法越多越好 答案： dic = {chr(i):i for i in range(65, 65 + 26)} # 1 print(dic.get(\"A\")) # 2 print(\"A\" in dic) # 3 print(dic[\"A\"]) # 4 print(dic.pop(\"A\")) %/accordion% %accordion%列表推导式%accordion% 如何用一行代码生成[1, 4, 9, 16, 25, 36, 49, 64, 81, 100] ? 答案： print( [i ** 2 for i in range(1, 11)] ) %/accordion% %accordion%序列翻转%accordion% 翻转1个字符串，如”1234“翻转为”4321“： 答案： string = \"1234\" print(string[::-1]) print(str.join(\"\", list(reversed(string)))) %/accordion% %accordion%字典的setdefault()方法%accordion% 将列表内的元素,根据位数合并成字典，列表如下： lst = [1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 32769, 65536, 4294967296] 答案： lst = [1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 32769, 65536, 4294967296] dic = {} for i in lst: k = len(str(i)) # 如果不存在该键，这该键等同于一个空列表 dic.setdefault(k, []) dic[k].append(i) print(dic) %/accordion% 函数相关 %accordion%形参类型必须为不可变%accordion% 写出程序运行结果： def add_end(l=[]): l.append(\"end\") return l add_end() add_end() 答案： [\"end\"] [\"end\", \"end\"] %/accordion% %accordion%命名空间%accordion% 全局变量和局部变量的区别, 如何给function里面的一个全局变量赋值? 答案： 全局变量是指存放在global namespace中的变量，它允许在任何命名空间中访问 全局有效，全局存活 局部变量是指存放在local namespace中的变量，它仅允许在当前函数的运行时访问，同时，也允许该函数中嵌套定义的子函数在运行时访问 局部有效，局部存活。 function里面如果要对1个全局变量进行赋值，可使用global关键字，如： x = 1 def func(): global x x += 1 %/accordion% %accordion%标识符命名冲突问题%accordion% 请写出下面程序的运行结果： a = 1 def fun(a): a = 2 fun(a) print(a) a = [] def fun(a): a.append(1) fun(a) print(a) 答案： 1 [1] %/accordion% %accordion%lambda表达式？%accordion% 简述lambda表达式格式以及应用场景。 答案： 格式如下： lambda x, y : x + y 形参可以没有，不必显式return 常与内置函数搭配使用，如filter，map，sorted，max等 %/accordion% %accordion%多装饰器嵌套%accordion% 请给出下面代码片段的输出： def say_hi(func): def wrapper(*args, **kwargs): print(\"HI\") ret = func(*args, **kwargs) print(\"BYE\") return ret return wrapper def say_yo(func): def wrapper(*args, **kwargs): print(\"YO\") return func(*args, **kwargs) return wrapper @say_hi @say_yo def func(): print(\"ROCK & ROLL\") func() 答案： print(\"HI\") print(\"YO\") print(\"ROCK & ROLL\") print(\"BYE\") %/accordion% %accordion%生成器与普通函数的区别？%accordion% 解释生成器与函数的不同, 并实现和简单使用generator 答案： 当一个函数中具有yield关键字时，此函数即为生成器函数 区别如下： 普通函数加括号是立即调用函数，执行函数体内部代码 生成器函数加括号是返回一个生成器对象，必须通过for循环或者手动使用send(None)或者调用其下的next()方法进行启动 生成器函数比普通函数的运行栈帧会多一个保存当前函数挂起状态的C语言结构体，因为yield关键字之后会将函数状态进行挂起，而return直接会返回并将函数栈帧从系统调用栈中踢出来 生成器对象可以通过send()方法与生成器函数体中yield进行数据交互，而普通的函数则不行，一经return直接结束函数运行 值得一提的是低版本中，yield和return不能同时出现 def genFunc(): yield 1 yield 2 yield 3 genObject = genFunc() for item in genObject: print(item) %/accordion% %accordion%递归打印%accordion% 有一个多层嵌套的列表A=[1,2,[3,4,[\"434\",...]]], 请写一段代码遍历A中的每一个元素并打印出来 答案： def func(li): for item in li: if isinstance(item, list): func(item) else: print(item) func([1, 2, [3, 4, [\"434\"]]]) %/accordion% %accordion%sorted()函数中key参数的使用%accordion% 将以下字典按照value的大小进行排序： d = {\"a\": 26, \"g\": 20, \"e\": 20, \"c\": 24, \"d\": 23, \"f\": 21, \"b\": 25} 答案： d = {\"a\": 26, \"g\": 20, \"e\": 20, \"c\": 24, \"d\": 23, \"f\": 21, \"b\": 25} print(sorted(d, key=lambda k:d[k])) %/accordion% %accordion%zip的使用%accordion% 写代码 tupleA = (\"a\",\"b\",\"c\",\"d\",\"e\") tupleB = (1,2,3,4,5) RES = {\"a\":1,\"b\":2,\"c\":3,\"d\":4,\"e\":5} 写出由tupleA和tupleB得到res的及具体实现过程 答案： dict(zip(tupleA, tupleB)) %/accordion% %accordion%ord()和chr()使用%accordion% 写一个base62encode函数，实现62进制解码。 范围0-10，a-z，A-Z def base62encode(number): if number 61: raise ValueError(\"Must be between 0 - 61\") encodeTable = ( *[i for i in range(10)], *[chr(i) for i in range(97, 123)], *[chr(i) for i in range(65, 91)],) return encodeTable[number] print(base62encode(61)) # Z %/accordion% %accordion%生成器编写斐波拉契数列%accordion% 使用生成器编写fib函数，函数声明为fib(max)，输入一个参数max值，使得该函数可以这样调用： for i in range(0,100): print fib(1000) 并产生如下结果(斐波那契数列) 1, 1, 2, 3, 5, 8, 13, 21... 答案： def fib(max): count, currentValue, nextValue = 0, 0, 1 while count %/accordion% %accordion%IP地址转换%accordion% 请编写一个函数实现将IP地址转换成一个整数。 如 10.3.9.12 转换规则为： 10 00001010 3 00000011 9 00001001 12 00001100 再将以上二进制拼接起来计算十进制结果：00001010 00000011 00001001 00001100 = ？ 答案： def transformIpAddr(ip): bitIpList = list(map(lambda x: str(bin(int(x)))[ 2:].rjust(8, \"0\"), ip.strip().split(\".\"))) return int(\"\".join(bitIpList), base=2) print(transformIpAddr(\"10.3.9.12\")) %/accordion% %accordion%计时装饰器实现%accordion% 请实现一个装饰器, 限制该函数被调用的频率, 如10秒一次 答案： import datetime import time def warpper(s=10): def outer(func): nextRunTime = None def inner(*args, **kwargs): nonlocal nextRunTime nowTime = datetime.datetime.now() if nextRunTime is None or nowTime > nextRunTime: result = func(*args, **kwargs) nextRunTime = datetime.timedelta(seconds=s) + nowTime return result print(nextRunTime - nowTime) return inner return outer @warpper(10) def func(): print(\"run...\") for i in range(10): time.sleep(2) func() %/accordion% %accordion%可迭代对象%accordion% 下列数据结构中,哪一种是不可迭代的 A. dict B. object C. set D. str 答案： B %/accordion% 算法与数构 %accordion%哈希冲突回避算法有哪几种, 分别有什么特点？%accordion% 开放定址法： 所谓的开放定址法就是一旦发生了冲突，就去寻找下一个空的散列地址，只要散列表足够大，空的散列地址总能找到，并将记录存入 再哈希法： 再哈希法又叫双哈希法，有多个不同的Hash函数，当发生冲突时，使用第二个，第三个，….，等哈希函数 计算地址，直到无冲突。虽然不易发生聚集，但是增加了计算时间。 链地址法： 链地址法的基本思想是：每个哈希表节点都有一个next指针，多个哈希表节点可以用next指针构成一个单向链表，被分配到同一个索引上的多个节点可以用这个单向链表向后排列。 建立公共溢出区： 这种方法的基本思想是：将哈希表分为基本表和溢出表两部分，凡是和基本表发生冲突的元素，一律填入溢出表 %/accordion% 模块相关 %accordion%pip命令的使用%accordion% 如何安装第三方模块？ 答案： pip install module name %/accordion% %accordion%datetime模块%accordion% 输入某年某日, 判断这是这一年的第几天?(可以用Python的内置模块) 答案： import datetime def dayofyear(): year = input(\"请输入年份：\") month = input(\"请输入月份：\") day = input(\"请输入天：\") date1 = datetime.date(year=int(year),month=int(month),day=int(day)) date2 = datetime.date(year=int(year),month=1,day=1) return (date1 - date2).days + 1 print(dayofyear()) %/accordion% %accordion%random使用%accordion% 如何生成一个随机数？ 答案： random.random() 生成0-1之间的随机小数。 %/accordion% %accordion%sys与模块路径查找%accordion% sys.path.append(\"/root/mods\")的作用？ 答案： 添加/root/mods路径至硬盘模块查找中 %/accordion% %accordion%os模块应用%accordion% 如何用Python删除1个文件？ os.remove() %/accordion% %accordion%文件递归%accordion% 写代码实现查看一个目录下的所有文件。 答案： import os def pathRecursion(path): print(path) if os.path.isdir(path): for subPath in os.listdir(path): pathRecursion(os.path.join(path, subPath)) pathRecursion(os.path.abspath(os.getcwd())) %/accordion% %accordion%JSON转中文%accordion% json序列化时，默认遇到中文会转换成unicode，如果想要保留中文怎么办？ 答案： 序列化时添加参数： ensure_ascii=False %/accordion% %accordion%JSON扩展%accordion% json序列化时，可以处理的数据类型有哪些？如何定制支持datetime类型？ 答案: json序列化只能序列化Python基本数据类型。 如果要想序列化非Python基本数据类型，则可以使用参数cls进行定制，详情参见Python模块一章。 json.dumps(data, cls=自己写的类) %/accordion% %accordion%简述logging模块作用%accordion% logging模块的作用？以及应用场景？ 答案： 日志记录 %/accordion% %accordion%正则表达式贪婪匹配%accordion% 什么是正则的贪婪匹配？或 正则匹配中的贪婪模式与非贪婪模式的区别？ 答案： *+?{n, m}都是贪婪模式，即有多个的时候匹配多个。 通过?可取消贪婪模式，即及时有多个也取最少的 %/accordion% %accordion%正则表达式%accordion% 请写出以字母或下划线开始, 以数字结束的正则表达式 答案： import re result = re.search(pattern=r\"^[A-Za-z0-9_].*\\d$\", string=\"321\") print(result.group()) %/accordion% %accordion%re模块中search和match的区别？%accordion% 请问re模块中search()和match()有什么区别？ 答案： search和match都有1个共同点，即只会成功匹配1次 不同点在于match只会匹配开头，相当于search基础上加了^ %/accordion% %accordion%如何判断一个邮箱是否合法？%accordion% 如何判断一个邮箱是否合法？ 答案： ^[a-zA-Z0-9_-]+@[a-zA-Z0-9_-]+(\\.[a-zA-Z0-9_-]+)+$ %/accordion% %accordion%itertools模块%accordion% 写代码：用户输入一个字符串，打印该字符串的所有不重复排列组合。 答案： from itertools import permutations a = input() for i in permutations(a, len(a)): print(''.join(i)) %/accordion% 面向对象 %accordion%简述oop三大特性%accordion% 请简述oop三大特性。 答案： 封装：将代码封装起来，只留下接口，通过接口访问对象 继承：实现多复用，子类的公用方法和属性可以从父类继承，减少代码冗余 多态，面向对象最灵活的地方，可以动态绑定，一种事物，多种形态，也称鸭子类型 %/accordion% %accordion%类变量和实例变量的区别%accordion% 请简述类变量和实例变量的区别。 答案： 实例变量仅存在实例对象的内存空间，类是无法调用实例变量。 类变量 存在整个类对象的内存空间，所有该类实例化出来的对象都可以调用到这些变量 %/accordion% %accordion%类与实例作用域%accordion% 以下代码输出是什么? 请给出答案并解释： class Parent(object): x = 1 class Child1(Parent): pass class Child2(Parent): pass print Parent.x, Child1.x, Child2.x Child1.x = 2 print Parent.x, Child1.x, Child2.x Parent.x = 3 print Parent.x, Child1.x, Child2.x 答案： 1 1 1 1 2 1 3 2 3 详情参见类与对象一篇，类与实例命名空间和标识符查找顺序。 %/accordion% %accordion%类方法与静态方法%accordion% 请简单解释Python中的static method(静态方法)和class method(类方法),并将以下代码填写完整 class A(object): def foo(self,x) print 'executing foo(%s, %s)'%(self,x) @classmethod def class_foo(cls,x): print 'executing class_foo(%s, %s)'%(cls,x) @staticmethod def static_foo(x): print 'executing static_foo(%s)'%(x) a= A() # 调用foo函数,参数传入1 ____________________ # 调用class_foo函数,参数传入1 ____________________ # 调用static_foo函数,参数传入1 答案： @classmethod：类的绑定方法，只能由类调用 @staticmethod：类的静态方法，类和instance都能调用 a.foo(1) A.class_foo(1) A.static_foo(1) a.static_foo(1) %/accordion% %accordion%上下文管理机制%accordion% 有用过with statement（语句）吗？它的好处是什么？ 答案： 上下文管理，with完成后自动调用__exit__(). 故可以在__exit__()中关闭系统占用资源 %/accordion% %accordion%上下文管理器实现%accordion% 参考下面代码片段 class Context: pass with Content() as ctx: ctx.do_something() 请在Context类下添加代码完成该类的实现 答案： class Context: def __enter__(self): print(\"run .. enter\") return self def __exit__(self,exc_type,exc_val,exc_tb): print(\"run .. exit\") return self def do_something(self): print(\"run .. do something\") return self with Context() as ctx: ctx.do_something() %/accordion% %accordion%super()方法%accordion% super()的作用？ 答案： 根据mro属性查找顺序列表来依次访问父类、超类、基类。 达到方法借用的目的。 %/accordion% %accordion%单例模式%accordion% 实现一个Singleton单例类, 要求遵循基本语言编程规范（用尽量多的方式）。 方式1，元类实现： class MetaClass(type): def __call__(self, *args, **kwargs): \"\"\" self : class Singleton \"\"\" if not hasattr(self, \"ins\"): insObject = super(__class__, self).__call__(*args, **kwargs) setattr(self, \"ins\", insObject) return getattr(self, \"ins\") class Singleton(object, metaclass=MetaClass): pass if __name__ == \"__main__\": ins = Singleton() print(id(ins)) ins = Singleton() print(id(ins)) 方式2，继承实现： class ParentClass: def __new__(cls, *args, **kwargs) -> object: \"\"\" cls : class Singeton \"\"\" if not hasattr(cls, \"ins\"): insObject = super(__class__, cls).__new__(cls, *args, **kwargs) setattr(cls, \"ins\", insObject) return getattr(cls, \"ins\") class Singleton(ParentClass): pass if __name__ == \"__main__\": ins = Singleton() print(id(ins)) ins = Singleton() print(id(ins)) 方式3，装饰器实现： def warpper(clsObject): def inner(*args, **kwargs): if not hasattr(clsObject, \"ins\"): insObject = clsObject(*args, **kwargs) setattr(clsObject, \"ins\", insObject) return getattr(clsObject, \"ins\") return inner @warpper class Singleton: pass if __name__ == \"__main__\": ins = Singleton() print(id(ins)) ins = Singleton() print(id(ins)) 方式4，模块实现： - foo.py --> ins = Singleton() - bar.py --> from foo import ins 方式5，@classmethod实现单例模式： class Singleton: @classmethod def getSingletonInstanceObject(cls, *args, **kwargs): if not hasattr(cls, \"ins\"): insObject = cls(*args, **kwargs) setattr(cls, \"ins\", insObject) return getattr(cls, \"ins\") if __name__ == \"__main__\": ins = Singleton.getSingletonInstanceObject() print(id(ins)) ins = Singleton.getSingletonInstanceObject() print(id(ins)) %/accordion% %accordion%双下方法举例%accordion% 列举面向对象中带双下划线的特殊方法。 答案： __getitem__ __setitem__ __delitem__ __getattr__ __setattr__ __delattr__ __continar__ .. %/accordion% %accordion%isinstance和type%accordion% 简述isinstance()和type()的区别。 答案： isinstance判断一个对象是否来自于一个类的实例，返回布尔值 type用于返回指定实例的类型，返回类对象本身 %/accordion% %accordion%简述duke type%accordion% 什么是鸭子类型？ 答案： 如果它走起来像鸭子，而且叫起来像鸭子，那么它就是鸭子 也就是说，我们只关注对象行为而不关注对象本身 %/accordion% %accordion%单下划线和双下划线的区别？%accordion% 简述单下划线开头的变量名和双下滑先开的变量名有什么区别？ 答案： 单下划线开头的变量名逻辑上是私有变量，即不推荐外部进行访问，但是外部仍然可以访问到，并未对变量名本身做任何处理。 双下划线开头的变量名逻辑上是私有变量，即禁止外部进行访问，会将变量名重命名，规则为 _类名.__变量名 %/accordion% %accordion%简述mro%accordion% mro是什么？有什么作用？如何获取？ 答案： mro是属性查找顺序列表，由c3算法生成。 仅新式类具有该属性，经典类没有。 调用方式： className.mro() or className.__mro__ %/accordion% %accordion%可调用对象%accordion% python中如何判断一个对象是否可调用? 那些对象可以是可调用对象?如何定义一个类, 使其对象本身就是可调用对象? 答案： 使用callable(Object)判断一个对象是否可调用 函数，类都是可调用对象 如果想 className() ，则需要在其metaclass中定义 __call__() 方法， 如果想instanceName()， 则需要在其实现类中定义 __call__() 方法 %/accordion% 格式 %accordion%Some title here%accordion% Any content here %/accordion% Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-13 15:08:52 "},"Python/summary.html":{"url":"Python/summary.html","title":"Python专栏","keywords":"","body":"…还没想好写什么 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-05-17 12:05:21 "},"Python/Python快速入门/summary.html":{"url":"Python/Python快速入门/summary.html","title":"Python快速入门","keywords":"","body":" Python简介 Python安装 pip简单使用 Python虚拟环境 Python常用工具 PEP8规范说明 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-13 13:35:28 "},"Python/Python快速入门/Python简介.html":{"url":"Python/Python快速入门/Python简介.html","title":"Python简介","keywords":"","body":"Python简述 Python诞生于1989年圣诞节，由仁慈的独裁者（Benevolent Dictator For Life，缩写BDFL）吉多·范罗苏姆（Guido van Rossum）基于C语言开发。 Python的名字来源于龟叔（Guido van Rossum在Python界的爱称）十分喜欢的一部名为Monty Python's Flying的电视剧，一想到这个风靡全球的编程语言名字居然来的这么随意，不禁让人哑然失笑。 作为一门解释性的动态强类型语言，Python的开发效率奇高，因此在Python界流传着这样一句至理名言： 人生苦短，我用Python Python并不是毫无缺点的孩子，作为一门动态语言，它的执行效率是偏低的。 作为80年代的产物，它的并发性支持也可能不太好，但是这并不妨碍我们对它的热爱，相信只要拥入Python的怀抱你一定会爱上这一门优雅的语言。 Python解释器 由于是动态语言，Python在代码执行时必须先将代码转换为字节码，然后通过字节码再转换为机器可读的机器码。 而解释器就是负责这一切工作的小蜜蜂。 我们常说的Python是基于C语言开发而来的CPython，除此之外还有基于Java开发而来的Jython、以及基于C#开发而来的IronPython。 不论是Jython还是IronPython，我们在学习时都不会去考虑，而是统一选择CPython，因为它们相较于传统的CPython多了一个转换环节所以会导致执行效率的降低。 低效率的执行 动态语言是逐行翻译，我们可以将它理解为一种边跑边看的策略。 这样做的后果是方便代码排查，缺点是拉低执行效率。 常见的Python解释器（包括CPython）等都是采用这种策略，故Python的执行效率一直被人诟病。 PyPy解释器 熟悉Python的朋友都知道，有一款Python解释器打破了人们对于Python低执行效率的印象。 它就是PyPy解释器，PyPy是另一个Python解释器，它的目标是执行速度。 PyPy采用JIT技术，对Python代码进行动态编译（注意不是解释），所以可以显著提高Python代码的执行速度。 绝大部分Python代码都可以在PyPy下运行，但是PyPy和CPython有一些是不同的，这就导致相同的Python代码在两种解释器下执行可能会有不同的结果。 如果你的代码要放到PyPy下执行，就需要了解PyPy和CPython的不同点。 你可以简单的这么理解： 代码第一次运行时：进行动态编译，生成目标文件 代码第二次运行时：使用目标文件进行运行，没必要再进行逐行翻译，故执行效率提升 如果你需要较高的执行效率，可以选用该解释器，但是本专题中不会使用它。 因为PyPy终究不是正统，所以对很多第三方库的依赖性和兼容性不如CPython。 版本介绍 由于我们平常讲的Python实际上都为CPython，故我们接下来的学习也是围绕CPython（以下简称Python）展开的。 目前Python版本已经更迭到了3.9。 以下是Python的发展历程： 1989年，Guido开始写Python语言的解释器。 1991年，第一个Python解释器诞生，它是用C语言实现的，并能够调用C语言的库文件。 从一出生，Python已经具有了：类，函数，异常处理，包含表和词典在内的核心数据类型，以及模块为基础的拓展系统。 Granddaddy of Python web frameworks, Zope 1 was released in 1999 Python 1.0 - January 1994 增加了 lambda, map, filter and reduce. Python 2.0 - October 16, 2000，加入了内存回收机制，构成了现在Python语言框架的基础 Python 2.4 - November 30, 2004, 同年目前最流行的WEB框架Django诞生 Python 2.5 - September 19, 2006 Python 2.6 - October 1, 2008 Python 2.7 - July 3, 2010 In November 2014, it was announced that Python 2.7 would be supported until 2020, and reaffirmed that there would be no 2.8 release as users were expected to move to Python 3.4+ as soon as possible Python 3.0 - December 3, 2008 Python 3.1 - June 27, 2009 Python 3.2 - February 20, 2011 Python 3.3 - September 29, 2012 Python 3.4 - March 16, 2014 Python 3.5 - September 13, 2015 Python 3.6 - 2016-12 Python 3.7 - 2018 Python 3.8 - 2019 ... 细心的读者会发现，08年时就推出了3.0，2010年反而又推出了2.7？ 这是因为3.0不向下兼容2.0，而很多公司已经基于2.0版本开发出了大量程序，公司已然投入了大量的人财物力，这就导致大家都拒绝升级3.0，无奈官方只能推出2.7过渡版本，之后我们都应该采用3.0解释器开发程序，但为了方便读者维护2.0版本的软件，在遇到两种版本的差异时会专门指出来。 应用方向 Python的应用领域十分广泛，如：人工智能，数据处理，爬虫，金融量化，云计算，WEB开发，自动化运维/测试，游戏开发，网络服务，图像处理等众多领域。 并且国内外很多知名的企业也都在使用Python，如：Youtube、DropBox、BT、Quora（中国知乎）、豆瓣、知乎、Google、Yahoo、FaceBook、NASA、百度、腾讯、汽车之家、美团等等。 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-05-21 12:17:29 "},"Python/Python快速入门/Python安装.html":{"url":"Python/Python快速入门/Python安装.html","title":"Python安装","keywords":"","body":"本机示例 虽然目前的Python版本已经更迭到了3.9，但是在这里将会使用Python3.6.8来进行开发。 Python3.6系列应该是目前使用最为广泛的一个版本系列，相较于最新版的3.9来说它支持的库更多、兼容性更好。 需要注意的是在类Unix平台中，Python2版本已经自带，所以我们只需安装Python3.6即可。 MAC安装 MAC下有源码安装Source，和界面化.pkg安装，我们选择pkg安装。 第一步：打开Python官网，点我跳转： 第二步，下载对应版本的pkg安装程序： 第三步，一直点击下一步即可： 上述的安装方式会自动将Python安装至以下目录： /Library/Frameworks/Python.framework/Versions/3.6/ 安装完成之后系统会自动的将常用软件ln -s到/usr/local/bin中： $ ls /usr/local/bin/ | grep p.*3 pip3 pip3.6 pydoc3 pydoc3.6 python3 python3-config python3.6 python3.6-config python3.6m python3.6m-config pyvenv-3.6 Linux安装 Linux下有源码安装Source，和免编译安装Binary，我们选择免编译安装。 第一步，下载gcc工具： $ yum install gcc gcc-c++ -y 第二步，下载wget工具： $ yum install wget -y 第三步，下载Python3.6.8的Binary版本： $ cd ~ $ wget https://www.python.org/ftp/python/3.6.8/Python-3.6.8.tgz 第五步，将归档文件tgz解压至当前目录： $ > tar xvf Python-3.6.8.tgz -C ./ $ > ls anaconda-ks.cfg Python-3.6.8 Python-3.6.8.tgz 第六步，进入解压的目录中，进行编译安装（由于CPython基于C语言，而C语言又是编译性语言，故需要进行编译后安装）： $ > cd Python-3.6.8 $ > ./configure --prefix=/usr/local/Python36 $ > make $ > make install 第七步，添加环境变量： $ vim /etc/profile # 写入内容 export PATH=/usr/local/Python36/bin:$PATH $ source /etc/profile 交互测试 安装完成之后，分别在shell中输入python（自带的版本）以及python3，查看是否能进入交互式环境中。 如果能成功进入则按照成功，如果不能请谷歌排查原因。 若想退出交互式环境，输入exit()即可： $ python Python 2.7.10 (default, Feb 22 2019, 21:55:15) [GCC 4.2.1 Compatible Apple LLVM 10.0.1 (clang-1001.0.37.14)] on darwin Type \"help\", \"copyright\", \"credits\" or \"license\" for more information. >>> exit() $ python3 Python 3.6.8 (v3.6.8:3c6b436a57, Dec 24 2018, 02:04:31) [GCC 4.2.1 Compatible Apple LLVM 6.0 (clang-600.0.57)] on darwin Type \"help\", \"copyright\", \"credits\" or \"license\" for more information. >>> exit() Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-05-12 18:00:22 "},"Python/Python快速入门/pip简单使用.html":{"url":"Python/Python快速入门/pip简单使用.html","title":"pip简单使用","keywords":"","body":"pip工具 pip是Python的包管理工具，该工具提供了对Python第三方包的查找、下载、安装、卸载等功能。 Python 2.7.9+ 或 Python 3.4+ 以上版本都自带pip工具，在安装Python时会一并安装。 如果你安装了两个版本的Python，则对应的pip命令就是pip2或者pip3。 $ ls /usr/local/bin/pip* /usr/local/bin/pip /usr/local/bin/pip2 /usr/local/bin/pip2.7 /usr/local/bin/pip3 /usr/local/bin/pip3.6 Ps：类似于NodeJS的NPM 常用命令 在shell中可使用的pip常用命令如下： 命令 描述 pip --version 显示版本和路径 pip --help 获取帮助 pip install -U pip pip升级 pip install 包名 安装包 pip install --upgrade 包名 升级包 pip uninstall 包名 卸载包 pip search 包名 搜索包 pip list 查看所有已安装的包 pip list -o 查看所有可升级的包 pip升级 使用以下命令进行pip工具进行升级： Windows平台： $ python -m pip install -U pip # python2.x $ python -m pip3 install -U pip # python3.x Linux&Mac平台： $ pip install --upgrade pip # python2.x $ pip3 install --upgrade pip # python3.x 换源配置 pip下载的包默认是从国外源下载，速度较慢，因此可以为其设置为国内源（阿里云）。 下面介绍类Unix平台与Windows平台的换源方式。 Windows 直接在user目录中创建一个pip目录，如：C:\\Users\\username\\pip，新建文件pip.ini，然后填入以下内容： [global] index-url = https://mirrors.aliyun.com/pypi/simple Unix 类Unix平台需要依次运行如下命令： $ cd ~ # 进入用户家目录 $ mkdir .pip # 创建隐藏文件夹 $ vim .pip/pip.conf # 创建pip3的配置文件 然后在配置文件pip.conf中填入以下内容： [global] index-url = https://mirrors.aliyun.com/pypi/simple Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-05-12 18:06:07 "},"Python/Python快速入门/Python虚拟环境.html":{"url":"Python/Python快速入门/Python虚拟环境.html","title":"Python虚拟环境","keywords":"","body":"虚拟环境 虚拟环境是真实的Python解释器的一份拷贝。 由于真实的Python解释器可能在不断的添加各种第三方库，而我们的项目中又没有用到这些库所以就会造成一个环境的污染，可能会造成打包exe文件后体积过大等问题。 一个项目的环境干净是十分重要的，而虚拟环境就是为了净化项目环境而生的一种措施。 我们在这里使用virtualenv与virtualenvwrapper这两个第三方模块来更加方便的管理我们的虚拟环境。 Windows 需要使用两个第三方模块，在终端中使用pip3命令下载安装： $ pip3 install virtualenv $ pip3 install virtualenvwrapper-win 创建虚拟环境工作目录，新建一个文件夹，从此之后所有的虚拟环境都会存放至该文件夹下： $ D: mkdir .virtualenvs 然后需要配置虚拟环境工作目录： 打开环境变量，在用户变量中新建，变量名为WORKON_HOME，值为虚拟环境的配置路径，即.virtualenvs的路径 打开原本的Python3环境安装目录，找到Scripts文件夹，双击执行其下的virtualenvwrapper.bat Linux&Mac 需要使用两个第三方模块，在shell中使用pip3命令下载安装： $ pip3 install -i https://pypi.douban.com/simple virtualenv $ pip3 install -i https://pypi.douban.com/simple virtualenvwrapper 创建虚拟环境工作目录，新建一个文件夹，从此之后所有的虚拟环境都会存放至该文件夹下： $ mkdir ~/.virtualenvs 配置环境变量，编辑userHome/.bash_profile文件，如果是Mac用户且终端为zsh，则配置userHome/.zshrc文件，新增以下内容： # Setting virtual environment save path # 填入你的虚拟环境存放目录 export WORKON_HOME=\"~/.virtualenvs\" # Setting virtual environment copy python path # 填入你的真实Python3解释器路径，用于虚拟环境的拷贝 export VIRTUALENVWRAPPER_PYTHON=/Library/Frameworks/Python.framework/Versions/3.6/bin/python3.6 # Setting virtualenvwrapper.sh run path # 填入virtualenvwrapper.sh的脚本路径 source /Library/Frameworks/Python.framework/Versions/3.6/bin/virtualenvwrapper.sh 最后刷新一下该文件的配置： $ source ~/.bash_profile 命令概览 shell中可指定的命令如下： 命令 描述 workon 列出所有虚拟环境 mkvirtualenv -p python3 虚拟环境名字 创建新的虚拟环境 rmvirtualenv 虚拟环境名字 删除指定的虚拟环境 workon 虚拟环境名字 使用指定的虚拟环境 示例演示，创建一个LearnPython的虚拟环境： $ mkvirtualenv -p python3 LearnPython $ workon 现在你会发现，shell的提示符改变了： (LearnPython) YunYadeMacBook-Pro:~ yunya$ Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-05-12 18:08:04 "},"Python/Python快速入门/Python常用工具.html":{"url":"Python/Python快速入门/Python常用工具.html","title":"Python常用工具","keywords":"","body":"运行方式 REPL交互式 REPL名为交互式解释器（Read Eval Print Loop），提供了一个CLI(command-line interface:命令行界面)下读取值、求值、输出值、循环代码的环境。 这种交互式的方式会经常用到，适用于快速的进行一些功能测试，如函数传参、求值测试等。 现在让我们以REPL交互式来运行第一条Python代码，在shell中进行执行： $ python3 >>> print(\"hello world\") hello world >>> 如果要退出REPL环境，则使用exit()即可。 脚本调用式 外部调用 在一个文件中，书写好Python代码后进行调用的方式被称为脚本调用式。 也是非常常用的一种方式，通常文件后缀名以py结尾，标识这是一个Python脚本文件。 使用Python调用脚本时，其实并不关心文件后缀名是什么，后缀名更多的作用是给使用者看的，便于区分不同类型的文件 $ echo \"print('hello world')\" > helloWorld.py $ python3 helloWorld.py hello world 在此示例中我们使用Python3的解释器在外部对其进行调用，并执行了其中的代码打印了hello world。 内部调用 除开外部调用，我们也可以在脚本内部指定Python解释器，并通过./进行代码执行，对上述文件内容进行修改： #!/usr/bin/env python3 print('hello world') 修改完成并保存，再修改文件的执行权限： $ chmod 775 helloWorld.py 直接使用./进行代码执行： $ ./helloWorld.py hello world 使用内部调用需要注意：指定Python解释器的语句一定要放在文件头部，因此该代码也被称为头文件代码。 常见的头文件代码除开指定Python解释器以外，还有指定解释器解码格式、声明作者和日期等，如下所示： #!/usr/bin/env python3 # -*- coding:utf-8 -*- # author: YunYa # date: 2017-01-28 头文件代码调用说明：env是类Unix平台的环境变量别称，当我们在头文件代码中指定/usr/bin/env python3的时候，它内部会运行env | grep python3，找到python3解释器，并对文件进行执行，前提是该文件必须具有可执行权限。 $ env | grep python3 VIRTUALENVWRAPPER_PYTHON=/Library/Frameworks/Python.framework/Versions/3.6/bin/python3.6 执行过程 一个Python程序被解释器解释并执行，可粗略的分为三个步骤： 启动Python解释器 Python解释器发起系统调用，将脚本内容载入内存，此时并不会做任何处理 Python解释器开始识别Python语法，解释并执行内存中存储的脚本文件内容 IDE介绍 IDE简介 IDE的全称是Integrated Development Environment，即集成开发环境。 它是一种辅助程序开发人员开发软件的应用软件，在开发工具内部就可以辅助编写源代码文本、并编译打包成为可用的程序，有些甚至可以设计图形接口。 如果单纯的touch出一个文本，并在其内部书写代码是很容易出现问题的。 没有语法高亮，这意味着某个字符少打了、某个单词拼错了都不能被及时发现，并且这样学习对新手难度极大 没有debug功能，当业务逻辑越来越复杂时，程序不可避免的会出现一些bug，此时如果没有debug程序来检测出现问题的原因，整个排查的过程将变的异常艰难 而使用IDE开发则可以完全避免这些问题。 Python IDLE Python自带了一款类似的工具，名为Python IDLE，是Python的集成开发和学习环境。 官方文档：https://docs.python.org/3/library/idle.html 它自带了2种模式，一种是REPL交互模式，一种是脚本调用模式。 当你打开它后默认会进入REPL交互模式，此时只需要新建一个文件即可开始编写我们的代码。 CTRL+N：新建文件 CTRL+S：保存文件 F5：运行程序 可以发现，当我们想使用print()功能时，它会提示该功能需要哪些参数： 当编写完代码后，即可使用F5来进行文件的保存与运行，如下所示： IDLE适用于刚入门起步学习Python的同学，但对于大的项目构建来说还是十分的不方便。 推荐指数：⭐️⭐️⭐️ PyCharm PyCharm是由JetBrains公司开发，也是最受欢迎的Python IDE工具。 官方网站：https://www.jetbrains.com/pycharm/ 优点是功能强大，你能想到的不能想到的它都给你提供了。 缺点是收费，并且软件本身比较臃肿，但是比起它的优秀来说这些缺点可以忽略不计。 推荐指数：⭐️⭐️⭐️⭐️⭐️ VsCode VsCode是由Microsoft Corporation开发，是近年来最火的一款轻量级编辑器。 官方网站：https://code.visualstudio.com/ 优点是支持多语言，Golang、C、Python等手到擒来，此外它是完全免费的。 缺点是配置比较繁琐，对新手不太友好。 推荐指数：⭐️⭐️⭐️⭐️ 个人使用 我自己平常写一些小的脚本，会首选VsCode，若是要搭建一些比较大型的项目，则会选择PyCharm。 在这里并没有详细指出每种工具的安装，因为互联网上类似的教程太多了。 推荐在初次接触Python时，建议统一使用Python IDLE，因为PyCharm本身会对Python许多地方做出优化，而恰好这些优化对新手并不友好。 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-05-15 21:21:59 "},"Python/Python快速入门/PEP8规范说明.html":{"url":"Python/Python快速入门/PEP8规范说明.html","title":"PEP8规范说明","keywords":"","body":"PEP8规范 每种语言都有其一种特定的书写规范，而PEP8规范则是Python中的书写规范。 以下的内容对于初学者来说可能会显得有些超纲，但是我为什么要将它放在第一章呢？就是为了警示你书写规范其实很重要。 尽管现在你可能看不懂，但是没有关系，你看得懂的时候就一定要去学会遵守它。 Ps：其实我自己就是一个不太遵守规范的家伙... 缩进与续行 每一级缩进使用4个空格，而不是使用table def main(): print(\"hello,world\") # --- def main(): print(\"hello,world\") 续行应该与其包裹元素对齐，要么使用圆括号、方括号和花括号内的隐式行连接来垂直对齐，要么使用挂行缩进对齐 def main( param1, param2, param3, param4 ): print(\"hello,world\") # --- def main(param1, param2, param3, param4 ): print(\"hello,world\") 分割与宽度 每行最大的字符数不可超过79，文档字符或者注释每行不可超过72 def main(): # this is a test function ... # this is a test function ... # this is a test function ... print(\"hello,world\") # --- def main(): # this is a test function ... this is a test function ... this is a test function ... print(\"hello,world\") 顶层函数和类的定义，前后用两个空行隔开，类里的方法定义用一个空行隔开 模块的导入 导入不同模块，应当进行分行 导入模块的位置应当总是位于文件顶部，且在头文件代码之后 标准库导入放最前、相关第三方库导入放其次，而后是本地库导入 每一组导入语句之间加入空行分割，以区分是内置库、三方库、还是自建库 推荐使用绝对导入 import sys import os # --- import sys, os 注释 在更改代码之前，推荐先更改注释 释应该是完整的句子。如果一个注释是一个短语或句子，它的第一个单词应该大写，除非它是以小写字母开头的标识符(永远不要改变标识符的大小写！) 如果注释很短，结尾的句号可以省略。块注释一般由完整句子的一个或多个段落组成，并且每句话结束有个句号 在句尾结束的时候应该使用两个空格 当用英文书写时，遵循Strunk and White （译注：《Strunk and White, The Elements of Style》）的书写风格 在非英语国家的Python程序员，请使用英文写注释，除非你120%的确信你的代码不会被使用其他语言的人阅读 块注释通常适用于跟随它们的某些（或全部）代码，并缩进到与代码相同的级别。块注释的每一行开头使用一个#和一个空格（除非块注释内部缩进文本）。 块注释内部的段落通过只有一个#的空行分隔 有节制地使用行内注释 行内注释是与代码语句同行的注释。行内注释和代码至少要有两个空格分隔。注释由#和一个空格开始 文档字符串 要为所有的公共模块，函数，类以及方法编写文档说明 非公共的方法没有必要，但是应该有一个描述方法具体作用的注释。这个注释应该在def那一行之后 PEP 257描述了写出好的文档说明相关的约定。特别需要注意的是，多行文档说明使用的结尾三引号应该自成一行，例如： \"\"\"Return a foobang Optional plotz says to frobnicate the bizbaz first. \"\"\" 对于单行的文档说明，尾部的三引号应该和文档在同一行 命名规范 应该避免的名字 永远不要使用字母‘l’（小写的L），‘O’（大写的O），或者‘I’（大写的I）作为单字符变量名 在有些字体里，这些字符无法和数字0和1区分，如果想用‘l’，用‘L’代替 类名 类名一般使用首字母大写的约定 在接口被文档化并且主要被用于调用的情况下，可以使用函数的命名风格代替 注意，对于内置的变量命名有一个单独的约定：大部分内置变量是单个单词（或者两个单词连接在一起），首字母大写的命名法只用于异常名或者内部的常量 函数名 函数名应该小写，如果想提高可读性可以用下划线分隔 大小写混合仅在为了兼容原来主要以大小写混合风格的情况下使用（比如 threading.py），保持向后兼容性 函数和方法参数 始终要将 self 作为实例方法的的第一个参数 始终要将 cls 作为类静态方法的第一个参数 如果函数的参数名和已有的关键词冲突，在最后加单一下划线比缩写或随意拼写更好。因此 class_ 比 clss 更好（也许最好用同义词来避免这种冲突） 编程建议 代码应该用不损害其他Python实现的方式去编写（PyPy，Jython，IronPython，Cython，Psyco 等） 比如，不要依赖于在CPython中高效的内置字符连接语句 a += b 或者 a = a + b 这种优化甚至在CPython中都是脆弱的（它只适用于某些类型）并且没有出现在不使用引用计数的实现中。在性能要求比较高的库中，可以用“”.join() 代替 这可以确保字符关联在不同的实现中都可以以线性时间发生 和像None这样的单例对象进行比较的时候应该始终用 is 或者 is not，永远不要用等号运算符 另外，如果你在写 if x 的时候，请注意你是否表达的意思是 if x is not None。举个例子，当测试一个默认值为None的变量或者参数是否被设置为其他值的时候。这个其他值应该是在上下文中能成为bool类型false的值 使用 is not 运算符，而不是 not … is 虽然这两种表达式在功能上完全相同，但前者更易于阅读，所以优先考虑 推荐： if foo is not None 不推荐： if not foo is None: Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-05-12 18:20:25 "},"Python/Python基础知识/summary.html":{"url":"Python/Python基础知识/summary.html","title":"Python基础知识","keywords":"","body":" 代码与注释 变量与常量 整形与浮点型 列表类型 元组类型 字符串类型 字典类型 集合类型 布尔类型 单例None 内存管理 深浅拷贝 输入与输出 运算符相关 分支结构 流程控制 推导式 字符编码 文件操作 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-13 13:32:57 "},"Python/Python基础知识/代码与注释.html":{"url":"Python/Python基础知识/代码与注释.html","title":"代码与注释","keywords":"","body":"代码注释 学习任何一门语言首要的就是学习它的注释。注释就是说你的脚本程序在运行过程中不会被解释器解释与执行的一部分，它的功能主要是给人阅读方便代码的后期维护。 在Python中（Python2和Python3均可），主要有3种注释方式，其中单行注释1种，多行注释2种。 #号注释 单个#号注释是属于单行注释，如下示例： # This is a single line comment 要注意的是，我们一般会在#后面添加上一个空格，如果#号前面有代码，一般会间隔两个空格。 print(\"HELLO,WORLD\") # 它将打印HELLO,WORLD -- - 三单引号注释 ''' '''三个单引号可以进行跨行注释，如下示例： def func(): ''' 用于进行一个功能的描述与说明 ''' pass 三双引号注释 \"\"\" \"\"\"三个双引号的注释与三个单引号的注释语义相同，基本上在能够使用三个单引号的地方都可以使用三个双引号： def func(): \"\"\" 用于进行一个功能的描述与说明 \"\"\" pass Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-09 12:39:47 "},"Python/Python基础知识/变量与常量.html":{"url":"Python/Python基础知识/变量与常量.html","title":"变量与常量","keywords":"","body":"标识符与对象 在Python中有一个核心的概念，叫做一切皆对象。 我们定义的数据、资源等皆可称之为对象，对象均存放在内存中。 而如果要使用这个对象，则必须通过标识符与对象进行绑定，说的通俗一点就是，为对象取一个名字。 一般来讲，一次绑定分为三部分操作： 创建资源对象（值） 创建标识符（名字） 建立绑定关系（赋值符号） 如下所示： 整个绑定的过程，被称为常量\\变量赋值或者对象定义，用=号将标识符与对象进行链接。 如下所示，我们用多个对象表示一个人的信息： name = \"yunya\" age = 18 height = 1.92 print(\"name : %s\\nage : %s\\nheight : %s\\n\" % (name, age, height)) # name : yunya # age : 18 # height : 1.92 先定义后使用 对象必须先定义，后使用，如果未定义就使用则会抛出异常。 print(\"My name is :\", name) name = \"yunya\" # NameError: name 'name' is not defined 命名风格 下面介绍几种常用的标识符命名方式： Camel-Case之小驼峰式：个人比较喜欢的风格，但是Python中并不建议使用小驼峰。 单词开头的字母小写，而后每个单词的分割首字母采用大写形式： userAge = 18 Camel-Case之大驼峰式：大驼峰式在Python中比较常见，一般定义类名时使用，不要滥用大驼峰。 每个单词都首字母都大写 UserInfo = {} 匈牙利类型标记法：前面的小写字母为变量类型，如，i代表int类型、s代表str类型： iUserAge = 18 蛇形命名法：小写+下划线，是Python中更推荐使用的标识符命名方式： user_age = 18 命名规范 标识符的命名需要遵从以下规范： 标识符应当见名知意 标识符由数字，字母，下划线组成。并且开头不能为数字 标识符不能使用Python中的关键字 错误的示范： $name = 'yunya' # 具有特殊字符 1year = 365 # 数字开头 *_size = 1024 # 具有特殊字符 and = 123 # 使用了关键字 年级 = 3 # 强烈不建议使用中文（占用内存大） (color) = 'red' # 虽然这种命名方式可行但是也极为不推荐 正确的示范： name = 'yunya' __age = 18 # Python中双下划线开头的标识符一般有隐私的这种说法，因此一般不建议使用 page_1 = 'home page' 同时，个人十分不推荐在标识符中加上任何的数字，这样的做法显得很莽撞。如item1，item2等... 绑定映射 Python中所有的数据均被称之为对象（object），对象存放至堆（heap）区内存中。 在对象存入堆区内存时，会为对象开辟一块内存空间并保存。 而在栈（stack）区内存中，则存放对象的引用（reference），即对象在堆区内存中的地址。 当一个对象被赋值给一个标识符后，在栈区内存中会创建一种映射（mapping）关系，此时标识符和对象就建立了联系，并且标识符本身也会被存放至栈区内存中。 name = \"yunya\" age = 18 height = 1.92 盒子声明 在很多其他的编程语言中，声明一个数据的过程可以被称作盒子声明，当遇到赋值操作时，它会进行如下的流程： 创建一个具体的盒子（开辟内存，创建盒子，并且为盒子打上标识） 放入具体的数据（将对象放入盒子中） 而在Python中，则没有盒子声明这种说法，我更喜欢将它称作贴纸声明，当遇到赋值操作时，它会进行如下的流程： 先创建一个对象（自动的在遇到=符号时，开辟内存并创建对象，如果该对象已存在，则进行引用） 将=符号左侧的标识符与对象绑定（像贴纸一样） 两者对比一下： 其他编程语言中总是先进行标识符盒子的初始化，再之后将数据对象放入盒子中 Python中总是先创建对象，并且再将标识符与对象做绑定 如下图所示： 引用传递 Python中所有的标识符与对象的绑定均为引用，不论是函数传参，单纯赋值等，标识符都与对象的内存地址做绑定，而不和对象本身的值做绑定。 Python中一个对象可以被多个标识符所引用，而一个标识符仅能引用一个对象。 你可以理解为Python中所有数据类型均为引用类型，没有值类型。 如下所示，我们将声明2个不同的标识符，标识符都指向了同一个int对象： oldAge = 18 newAge = oldAge print(id(oldAge)) print(id(newAge)) # 4550527568 # 4550527568 如下图所示： 在Golang中，如果进行上面的操作，因为盒子声明的缘故新的标识符newAge会创建出一片新的内存空间，并且将oldAge的值进行一次拷贝后存放至新内存空间中： package main import \"fmt\" func main() { var oldAge int = 18 var newAge int = oldAge fmt.Println(oldAge, &oldAge) fmt.Println(newAge, &newAge) } // 18 0xc42008e168 // 18 0xc42008e190 如下图所示： 变量 变量指的是该标识符所绑定的对象允许在运行时刻发生变化，是用来记录事物变化状态的一种东西。 举个例子： 进入游戏：等级为0 一天之后：等级为10 一月之后：等级为100 标识符（等级）与表示等级的对象所绑定，并且该等级在不断的变化，那么这个标识符可以称为变量标识符，与变量标识符绑定的对象是可以随意改变的： # 进入游戏 level = 0 # 一天后 level = 10 # 一月后 level = 100 # 现在的等级 print(level) # 100 变量命名 变量标识符的命名一般以蛇形命名法和小驼峰命名法为准。 不可使用大驼峰式命名法，同时全大写命名法也不要进行使用。 匿名变量 如果一个变量标识符为_，则代表该变量为匿名变量。 匿名变量的作用是当做一个垃圾桶，对于一些不会用到的对象可以命名为_，仅做到一个占位的作用，这在解构赋值中经常会被使用到。 其实官方没有匿名变量的定义，这也是Python社区中一条不成文的规定，因为实在是懒得对一个不用的对象想名字，干脆就用_进行命名。 常量 常量指的是该标识符所绑定的对象不允许在运行时刻发生变化，表示一个恒定的数据。 举个例子： 圆周率PI是恒定的，不能因为程序的运行而改变 人的性别是恒定的，不能因为程序的运行而改变 很遗憾，在应用领域来说Python并未提供常量的定义，但是在Python社区中有一个不成文的规定。 如果一个标识符所有字母都是大写的话，则认为该标识符是常量标识符： PI = 3.1415926535897 SEX = \"男\" 常量池 上面说过，尽管在应用领域中Python并未提供常量的定义，但是在内部实现中处处可见常量的影子。 如小整数常量池就是一个很好的例子。 在其他的编程语言，类似Golang、JavaScript中，常量定义的关键词为const，很快你也会在Python中见到这个单词。 相关方法 id() 使用id()函数可拿到标识符所对应对象在堆区内存中的地址号。 name = \"yunya\" print(id(name)) # 2933298725640 type() 使用type()函数可获取到该标识符对应对象的数据类型，返回类本身。 name = \"yunya\" print(type(name)) # del 使用del跟上标识符名字，将对该标识符所关联的对象进行解绑操作，同时也会取消该标识符的定义，将其从栈区内存中抹去。 name = \"yunya\" del name print(name) # NameError: name 'name' is not defined Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-13 14:54:53 "},"Python/Python基础知识/整形与浮点型.html":{"url":"Python/Python基础知识/整形与浮点型.html","title":"整形与浮点型","keywords":"","body":"整形 整形概述 Python中对于整形的划分非常简单，仅仅只有一个int类型。 整形是不可变类型，即对象本身的属性不会根据外部变化而变化 整形属于原子类型，即不可被分割 基本声明 以下是使用类实例化的形式进行对象声明： age = int(12) print(\"value : %r\\ntype : %r\" % (age, type(age))) # value : 12 # type : 也可以选择使用更方便的字面量形式进行对象声明： age = 12 print(\"value : %r\\ntype : %r\" % (age, type(age))) # value : 12 # type : 类型转换 整形可以与布尔型，浮点型，字符串等做转换，使用对应的工厂函数即可： num = 1 strNum = str(num) boolNum = bool(num) floatNum = float(num) print(\"value : %r\\ntype : %r\" % (strNum, type(strNum))) print(\"value : %r\\ntype : %r\" % (boolNum, type(boolNum))) print(\"value : %r\\ntype : %r\" % (floatNum, type(floatNum))) # value : '1' # type : # value : True # type : # value : 1.0 # type : 进制转换 使用以下三个内置函数，可进行进制转换： 函数名 描述 bin() 十进制转二进制 oct() 十进制转八进制 hex() 十进制转十六进制 示例如下： num = 100 print(bin(num)) print(oct(num)) print(hex(num)) # 0b1100100 # 0o144 # 0x64 如果想二进制、八进制、十六进制转换十进制，则可通过指定int()的第二参数base实现，如下所示： print(int(\"0b1100100\", base=2)) print(int(\"0o144\", base=8)) print(int(\"0x64\", base=16)) # 100 # 100 # 100 Unicode转换 使用以下两个内置函数，可进行整形与Unicode互转： 函数名 描述 chr() 传入0-1114111之间的整形，将其转换为Unicode字符 ord() 传入单个Unicode字符，将其转换为Unicode字符十进制整形 示例如下： >>> chr(65) 'A' >>> ord(\"A\") 65 long类型 在Python2中，如果整形后面加上L则代表长整型，在Python3中取消了这种设定。 >>> num = 100L >>> type(num) 浮点型 浮点型概述 Python中对于浮点型的划分非常简单，仅仅只有一个float类型。 浮点形是不可变类型，即对象本身的属性不会根据外部变化而变化 浮点形属于原子类型，即不可被分割 基本声明 以下是使用类实例化的形式进行声明： f = float(3.15) print(\"value : %r\\ntype : %r\" % (f, type(f))) # value : 3.15 # type : 也可以选择使用更方便的字面量形式： f = 3.15 print(\"value : %r\\ntype : %r\" % (f, type(f))) # value : 3.15 # type : 类型转换 浮点形可以与布尔型、整型、字符串等做转换，使用对应的工厂函数即可： num = 1.9 strNum = str(num) boolNum = bool(num) intNum = int(num) print(\"value : %r\\ntype : %r\" % (strNum, type(strNum))) print(\"value : %r\\ntype : %r\" % (boolNum, type(boolNum))) print(\"value : %r\\ntype : %r\" % (intNum, type(intNum))) # value : '1.9' # type : # value : True # type : # value : 1 # type : 四则运算 整形与浮点型均支持四则运算。 但是需要注意的是当整形与浮点型进行运算后，所得到的结果必然是浮点型： print(100 * 1.0) # 100.0 同时，整形也可以与字符串进行乘法运算： print(\"hello\" * 3) # hellohellohello 他两都支持与布尔型进行运算，布尔型的本质就是1和0，这里不再例举。 _的形式 在Python3中提供了对数字的_分割表现形式。 旨在更加方便阅读大数字： >>> a = 100_00 >>> a 10000 >>> b = 100_00.1 >>> b 10000.1 强类型 由于Python是强类型语言，故不会出现隐式转换的问题（Python2中是允许字符串与数字做比较的，且数字永远小于字符串）。 如下，使用整形与字符串做对比，返回的结果永远是False。 print(\"100\" == 100) # False 但是整形可以和浮点型做比较，因为它们同属于数值类型： print(100.00 == 100) # True 他两都支持与布尔型进行比较，布尔型的本质就是1和0，这里不再例举。 小整数池 Python解释器觉得有一些整数会经常被使用（-5到255之间），故当脚本程序运行前就将这些数字写入堆区内存中。 当用户定义int对象且使用到其中的数值时会直接将该数值的内存地址引用到存在于栈内存的变量标识符上，这样做极大节省了内存空间。 如：一个程序中使用了100000次1这个数值，那么如果没有Python的这个机制则会开辟出100000个内存空间用来存放相同的数值。 这么做显然极大的浪费了内存。 故Python的这种机制是十分高效且合理的，并且它的名字叫做小整数常量池，或简称为小整数池（范围：-5,255）： int_1 = 1 int_2 = 1 print(id(int_1)) # 1558801440 print(id(int_2)) # 1558801440 # 超出小整数池范围 int_3 = -6 int_4 = -6 print(id(int_3)) # 2264143854288 print(id(int_4)) # 2264143854448 绝对引用 数值拥有绝对引用的特性，无论是深拷贝还是浅拷贝，都不会获得其副本，而是直接对源对象进行引用： >>> import copy >>> oldN = 1_0000 >>> id(oldN) 4373791728 >>> n1 = copy.copy(oldN) >>> id(n1) 4373791728 >>> n2 = copy.deepcopy(oldN) >>> id(n2) 4373791728 声明速率 时间对比 对于所有的Python内置数据模型来说，字面量形式的对象声明永远要比类实例化的形式对象声明速度要快。 时间差大约3倍或者更多，我们可以做一个小实验来观察，使用timeit模块检测2者时间差： $ python3 -m timeit -n 1000000 -r 5 -v \"int(1)\" raw times: 0.138 0.136 0.135 0.152 0.16 1000000 loops, best of 5: 0.135 usec per loop $ python3 -m timeit -n 1000000 -r 5 -v \"1\" raw times: 0.00974 0.00961 0.0107 0.0107 0.00991 1000000 loops, best of 5: 0.00961 usec per loop ❶ -n 语句执行多少次 ❷ -r 重复计时器的次数，默认为5 可以看类实例化声明1百万次int类型时长为0.135秒。 而字面量形式声明1百万次int类型时长为0.00961秒。 整个差距居然有14倍！当然，如果是一些复杂的类型声明，这个差距会变小。 底层探究 为什么会出现这样的情况，可以使用dis模块来探索，该模块会通过反汇编来查看到语句执行情况的字节码。 $ echo \"int(1)\" > demo.py $ python3 -m dis demo.py 1 0 LOAD_NAME 0 (int) 2 LOAD_CONST 0 (1) 4 CALL_FUNCTION 1 6 POP_TOP 8 LOAD_CONST 1 (None) 10 RETURN_VALUE $ echo \"1\" > demo.py $ python3 -m dis demo.py 1 0 LOAD_CONST 0 (None) 2 RETURN_VALUE 使用类实例化声明对象时，必定会调用到底层函数__init__()，而调用函数的过程会发起系统调用栈的进出栈操作，故更加耗时。 此外，我们也从上面的LOAD_CONST可以观察出，int类型小整数1确实会从小整数常量池中加载数据。 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-10 14:45:56 "},"Python/Python基础知识/列表类型.html":{"url":"Python/Python基础知识/列表类型.html","title":"列表类型","keywords":"","body":"列表 Python中的列表（list）是最常用的数据类型之一。 Python中的列表可以存储任意类型的数据，这与其他语言中的数组（array）不同。 被存入列表中的内容可称之为元素（element）或者数据项（data item）亦或是值（value）。 虽然Python列表支持存储任意类型的数据项，但不建议这么做，事实上这么做的概率也很低。 列表特性 列表特性如下： 列表属于线性容器序列 列表属于可变类型，即对象本身的属性会根据外部变化而变化，例如长度 列表底层由顺序存储组成，而顺序存储是线性结构的一种 基本声明 以下是使用类实例化的形式进行对象声明： lst = list((1, 2, 3, 4, 5)) print(\"value : %r\\ntype : %r\" % (lst, type(lst))) # value : [1, 2, 3, 4, 5] # type : 也可以选择使用更方便的字面量形式进行对象声明，利用[]对数据项进行包裹，并且使用逗号将数据项之间进行分割： lst = [1, 2, 3, 4, 5] print(\"value : %r\\ntype : %r\" % (lst, type(lst))) # value : [1, 2, 3, 4, 5] # type : 多维列表 当一个列表中嵌套另一个列表，该列表就可以称为多维列表。 如下，定义一个2维列表： lst = [1, 2, [\"三\",\"四\"]] print(\"value : %r\\ntype : %r\" % (lst, type(lst))) # value : [1, 2, ['三', '四']] # type : 续行操作 在Python中，列表中的数据项如果过多，可能会导致整个列表太长，太长的列表是不符合PEP8规范的。 每行最大的字符数不可超过79，文档字符或者注释每行不可超过72 Python虽然提供了续行符\\，但是在列表中可以忽略续行符，如下所示： lst = [ 1, 2, 3, 4, 5 ] print(\"value : %r\\ntype : %r\" % (lst, type(lst))) # value : [1, 2, 3, 4, 5] # type : 类型转换 列表支持与布尔型、字符串、元组、以及集合类型进行类型转换： lst = [1, 2, 3] bLi = bool(lst) strLi = str(lst) tupLi = tuple(lst) setLi = set(lst) print(\"value : %r\\ntype : %r\" % (bLi, type(bLi))) print(\"value : %r\\ntype : %r\" % (strLi, type(strLi))) print(\"value : %r\\ntype : %r\" % (tupLi, type(tupLi))) print(\"value : %r\\ntype : %r\" % (setLi, type(setLi))) # value : True # type : # value : '[1, 2, 3]' # type : # value : (1, 2, 3) # type : # value : {1, 2, 3} # type : 如果一个2维列表遵循一定的规律，那么也可以将其转换为字典类型： lst = [[\"k1\", \"v1\"], [\"k2\", \"v2\"], [\"k3\", \"v3\"]] dictList = dict(lst) print(\"value : %r\\ntype : %r\" % (dictList, type(dictList))) # value : {'k1': 'v1', 'k2': 'v2', 'k3': 'v3'} # type : 四则运算 列表支持与元组，列表进行加法运算： +：合并2个列表并生成新列表： lst1 = [1, 2, 3] lst2 = [4, 5, 6] newLi = lst1 + lst2 print(newLi) # [1, 2, 3, 4, 5, 6] +=：扩展已有列表，相当于extend()方法： oldLi = [1, 2, 3] newLi = [4, 5, 6] oldLi += newLi print(oldLi) # [1, 2, 3, 4, 5, 6] 列表支持与数字进行乘法运算： *：生成一个重复旧列表数据项的新列表： oldLi = [1, 2, 3] newLi = oldLi * 3 print(newLi) # [1, 2, 3, 1, 2, 3, 1, 2, 3] *=：扩展已有列表，将已有列表的数据项进行重复添加： oldLi = [1, 2, 3] oldLi *= 3 print(oldLi) # [1, 2, 3, 1, 2, 3, 1, 2, 3] 索引切片 索引的概念 列表底层是以一种连续的顺序结构存储数据项，故可以使用索引（index）对数据项进行获取、删除、截取、替换等操作。 ----------------------------| | A | B | C | D | E | F | G | ----------------------------| | 0 | 1 | 2 | 3 | 4 | 5 | 6 | |-7 |-6 |-5 |-4 |-3 |-2 |-1 | 正向索引都是从0开始，负向索引都是从-1开始。 enumerate() 我们以一个内置函数enumerate()来举例，该函数返回一个迭代器，将其转换为list()后可以查看数据项以及正向索引： lst = [\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\"] print(list(enumerate(lst))) # [(0, 'A'), (1, 'B'), (2, 'C'), (3, 'D'), (4, 'E'), (5, 'F'), (6, 'G')] 更多的关于enumerate()函数的妙用，将会放在循环章节中进行探讨。 slice() slice()函数有三个参数： start：索引开始的位置 stop：索引结束的位置 step：步长间距，默认为1 如果为正数代表正取，如果为负数代表倒取 如果为1代表连续取，如果为2代表隔一个取一个，以此类推 使用方法如下示例，先使用slice()确定截取数据项的范围，然后再使用列表的[]操作形式取出指定范围的数据项。 注意：所有的切片都是顾头不顾尾： lst = [\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\"] # 取出A # 释义：从0开始取，取1个，步长为0 s = slice(0, 1, None) print(lst[s]) # ['A'] [::]形式 使用slice()函数会比较繁琐，直接使用[::]形式进行切片会比较简单。 签名如下： [start:stop:step] 参数描述和slice()相同，当某一参数不设置时可省略前面的参数。 增删改截操作演示： >>> # 获取第2个数据项 >>> lst = [\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\"] >>> lst[1] 'B' >>> # 删除第3个数据项 >>> del lst[2] >>> lst ['A', 'B', 'D', 'E', 'F', 'G'] >>> # 从第1个数据项开始向后替换2个数据项，替换内容为123 >>> lst[0:3] = 1,2,3 >>> lst [1, 2, 3, 'E', 'F', 'G'] >>> # 从第1个数据项开始获取2个数据项 >>> lst[0:3] [1, 2, 3] >>> # 试图访问一个超出索引之外的数据项，将引发异常 >>> lst[100] IndexError: lstst index out of range 需要注意的是，如果使用[:]则会创建一个新的列表，再将原有列表中的数据项全部引用至新的列表中，类似于浅拷贝的概念。 如下所示： lst1 = [\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\"] lst2 = lst1[:] print(\"value : %r\\naddr : %r\" % (lst1, id(lst1))) print(\"value : %r\\naddr : %r\" % (lst2, id(lst2))) # value : ['A', 'B', 'C', 'D', 'E', 'F', 'G'] # addr : 4307969608 # value : ['A', 'B', 'C', 'D', 'E', 'F', 'G'] # addr : 4308270792 正向切片 正向切片即使用正向索引进行切片，索引从0处开始进行切片。 如下示例： >>> lst = [\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\"] >>> lst[0:3] ['A', 'B', 'C'] 反向切片 反向切片即使用反向索引进行切片，索引从-1处开始进行切片。 如下示例： >>> lst = [\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\"] >>> lst[-3:] ['E', 'F', 'G'] 多维切片 列表是支持多维切片的，如下示例，拿出2维列表中的数据项A： >>> lst = [1, 2, [\"A\", \"B\"]] >>> lst[-1][0] 'A' 高级切片 反向和正向切片可以混合使用，下面是一些高级切片的用法： >>> lst = [\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\"] >>> lst[:] ❶ ['A', 'B', 'C', 'D', 'E', 'F', 'G'] >>> lst[2:4] ❷ ['C', 'D'] >>> lst[::2] ❸ ['A', 'C', 'E', 'G'] >>> lst[::-2] ['G', 'E', 'C', 'A'] ❹ >>> lst[::-1] ❺ ['G', 'F', 'E', 'D', 'C', 'B', 'A'] >>> lst[:-5:-2] ❻ ['G', 'E'] >>> lst[0::-1] ❼ ['A'] >>> lst[5::-2] ❽ ['F', 'D', 'B'] 如何一眼读懂高级切片，通过以下步骤判定： 第一步先观察step，是负数还是正数，负数代表倒着取 第二步观察start，确定切片的开始位置 第三步观察stop，确定切片的结束位置 上述示例演示的说明，带*的是比较重要的方式。 ❶：列表的[:]操作是创建一个新的列表，再将原有列表中的数据项全部引用一次至新的列表* ❷：步长为空，代表正着取，从第2号索引位置的数据项开始，到第4号索引位置的数据项结束，根据顾头不顾尾原则，取2，3号索引的数据项* ❸：步长为2，代表正着取，隔一个取一个，即从0号索引位置的数据项开始，每次往后数到2的时候再取* ❹：步长为-2，代表倒着取，隔一个取一个，即从-1号索引位置的数据项开始，每次向前数到2的时候再取* ❺：步长为-1，代表倒着取，即从-1号索引位置的数据项开始，取到索引0号位置结束* ❻：步长为-2，代表倒着取，隔一个位置取一个，取到-5索引位置结束，根据顾头不顾尾原则，不取-5索引位置的数据项 ❼：步长为-1，代表倒着取，开始位置为0，结束位置未标记，则取1个 ❽：步长为-2，代表倒着取，隔一个取一个，开始位置为5号索引，则从第5号索引开始向前取 解构方法 *语法 使用*语法可对列表进行解构，将列表中的数据项全部提取出来： lst = [1, 2, 3] print(*lst) # 1 2 3 我们可以利用*语法的特性，来达到两个列表进行合并产生新列表的效果，类似于+： lst1 = [1, 2, 3] lst2 = [4, 5, 6] result = [*lst1, *lst2] print(result) # [1, 2, 3, 4, 5, 6] 解构赋值 如果一个列表中的数据项需要赋值到变量中，可使用解构赋值，需要注意的是变量接收位置与列表中的数据项位置需要一一对应： lst = [\"A\", \"B\"] item1, item2 = lst print(item1, item2) # A B 我们只想取出列表中前2个数据项时，可使用*语法将剩下的数据项全部打包到一个变量中： lst = [\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\"] item1, item2, *otherItems = lst print(item1, item2) print(otherItems) # A B # ['C', 'D', 'E', 'F', 'G'] 如果只想取第1个后和最后2个，中间的都不想要怎么办？也可以通过*语法： lst = [\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\"] itemFirst, *_, itemLast1, itemLast2 = lst # ❶ print(itemFirst, itemLast1, itemLast2) print(_) # A F G # ['B', 'C', 'D', 'E'] ❶：_为匿名变量，参见变量与常量一章节中的释义 常用方法 方法一览 常用的list方法一览表： 方法名 返回值 描述 append() None 将数据项添加至列表的末尾 extend() None 通过附加来自可迭代对象的数据项来扩展列表 insert() None 在索引之前插入对象 pop() item 删除并返回索引处的项目（默认为-1）。如果列表为空或索引超出范围，则引发IndexError copy() list 返回L的浅拷贝 remove() None 删除列表中第一次出现的数据项。如果不存在该数据项，则引发ValueError clear() None 从L移除所有项目 count() integer 返回数据项在L中出现的次数 index() integer 返回第一个数据项在L中出现位置的索引，若值不存在，则抛出ValueError sort() None 对列表进行原地排序，可指定参数reverse，若不指定该参数则默认升序排列，指定该参数则为降序排列 基础公用函数： 函数名 返回值 描述 len() integer 返回容器中的项目数 enumerate() iterator for index, value of iterable 返回一个可迭代对象，其中以小元组的形式包裹数据项与正向索引的对应关系 reversed() ... 详情参见函数章节 sorted() ... 详情参见函数章节 获取长度 使用len()方法来获取列表的长度。 返回int类型的值。 lst = [\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\"] print(len(lst)) # 7 Python在对内置的数据类型使用len()方法时，实际上是会直接的从PyVarObject结构体中获取ob_size属性，这是一种非常高效的策略。 PyVarObject是表示内存中长度可变的内置对象的C语言结构体。 直接读取这个值比调用一个方法要快很多。 追加元素 使用append()方法为当前列表追加一个数据项。 返回None： lst = [\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\"] lst.append(\"H\") print(lst) # ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H'] 你也可以使用+=进行操作，但个人并不推荐这样使用。 lst = [\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\"] lst += \"H\" print(lst) # ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H'] 列表合并 使用extend()方法来让当前列表与另一个可迭代对象进行合并。 返回None： lst1 = [\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\"] lst2 = [\"H\", \"J\", \"K\", \"L\"] lst1.extend(lst2) print(lst1) # ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'J', 'K', 'L'] 你也可以使用+=进行操作，但个人并不推荐这样使用。 lst1 = [\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\"] lst2 = [\"H\", \"J\", \"K\", \"L\"] lst1 += lst2 print(lst1) # ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'J', 'K', 'L'] 插入元素 使用insert()方法将数据项插入当前列表中的指定位置。 返回None： lst = [\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\"] lst.insert(0, \"a\") print(lst) # ['a', 'A', 'B', 'C', 'D', 'E', 'F', 'G'] 列表拷贝 使用copy()方法将当前列表进行浅拷贝。 返回当前列表的拷贝对象： oldLi = [\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\"] newLi = oldLi.copy() print(oldLi) print(newLi) print(id(oldLi)) print(id(newLi)) print(id(oldLi[0])) print(id(oldLi[0])) # ['A', 'B', 'C', 'D', 'E', 'F', 'G'] # ['A', 'B', 'C', 'D', 'E', 'F', 'G'] # 4329305992 # 4329607688 # 4328383520 # 4328383520 弹出元素 使用pop()方法弹出当前列表中在此索引位置的数据项，列表中该数据项将被删除，并返回被弹出的数据项。 若不指定位置，则默认弹出-1号索引位置的数据项： lst = [\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\"] popItem1 = lst.pop() popItem2 = lst.pop(2) print(lst) print(popItem1) print(popItem2) # ['A', 'B', 'D', 'E', 'F'] # G # C 删除元素 使用remove()方法删除当前列表中的数据项，根据数据项的名字进行删除。 如果具有多个同名的数据项，则只会删除第一个。 返回None： lst = [\"A\", \"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\"] lst.remove(\"A\") print(lst) # ['A', 'B', 'C', 'D', 'E', 'F', 'G'] 我们也可以使用del lst[index]进行数据项的删除： lst = [\"A\", \"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\"] del lst[0] print(lst) # ['A', 'B', 'C', 'D', 'E', 'F', 'G'] 这种方式还可以删除多个： lst = [\"A\", \"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\"] del lst[0:3] print(lst) # ['C', 'D', 'E', 'F', 'G'] 清空元素 使用clear()方法将当前列表进行清空，即删除所有数据项。 返回None： lst = [\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\"] lst.clear() print(lst) # [] 我们也可以使用del lst[:]进行列表的清空： lst = [\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\"] del lst[:] print(lst) # [] 统计次数 使用count()方法统计数据项在该列表中出现的次数。 返回int： lst = [\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\", \"A\"] aInLiCount = lst.count(\"A\") print(aInLiCount) # 2 查找位置 使用index()方法找到数据项在当前列表中首次出现的位置索引值，如数据项不存在则抛出异常。 返回int。 lst = [\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\", \"A\"] aInLiIndex = lst.index(\"A\") print(aInLiIndex) # 0 顺序排列 使用sort()方法将当前列表中的数据项按照ASCII码顺序进行排列，默认从小到大。 可指定参数resverse，用于是否翻转列表，如翻转列表则代表从大到小。 返回None： lst = [\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\", \"A\"] lst.sort(reverse=True) print(lst) # ['G', 'F', 'E', 'D', 'C', 'B', 'A', 'A'] sort()方法内部采用timsort算法，这是一种非常优秀的算法，速度快且稳定。 底层探究 容器序列 这里引出一个新的概念，线性容器序列： 线性是指该对象内部是由连续的内存空间组成 容器中能存放不同类型的数据项，如list就是标准的一个容器 序列是指具有长度的对象，且该对象能使用index进行内部数据项的操作 容器序列存放的是它们所包含的任意类型的对象的引用，如下定义了一个列表： x = [“A”, “B”, “C”] 它的内部存储结构如下图所示： 在CPython源码中，列表数据项的引用为PyObject **ob_item属性，即指针的指针。 元素调整 列表中，pop()和insert()方法都具有指定索引值的功能。 如果使用pop(0)，或者insert(0)则都会引起整个列表中数据项的调整。 pop(0)会将队首的数据项弹出并删除，后面的所有数据项都要向前挪一个位置。1变成0，2变成1，以此类推 insert(0)会将新的数据项插入至队首，后面的所有数据项都要向后挪一个位置。0变成1，1变成2，以此类推 而单纯的使用pop()或者append()则不会发生数据项调整，因为它们总是在队尾做操作。 总而言之，任何一个方法只要不是操作的队尾数据项，都会引起该列表中其他所有数据项的调整。 图示如下： 扩容机制 在对列表进行添加数据项时，如果列表内部的容量已满则会触发扩容机制。 我们要理解2个概念： 容量：容量指的是列表底层在开辟内存时，开辟了多大的内存空间，能够容纳多少数据项，可以理解为一共有多少个槽位 大小：大小指的是当前列表中，数据项已占据的容量，可以理解为已用了多少个槽位 在CPython源码中，列表容量的属性为Py_ssize_t allocated，而列表大小的属性为Py_ssize_t ob_size 在初始化列表时，容量和大小总是等于数据项的总个数，如： 一个空列表，容量和大小都为0 有8个槽位的列表，容量和大小都为8 如果对一个已有的列表进行增加数据项的操作时会有以下2条判断，判定当前列表是否需要扩容： 当前列表容量 > 已有数据项个数+1 and 已有数据项个数 >= 当前列表容量的一半 则直接添加数据项，不进行扩容 并且新增数据项个数 Py_ssize_t ob_size + 1 当前列表容量 则先进行扩容后再添加数据项 扩容是一种线性增长，增长规律为：0、4、8、16、24、32、40、52、64、76 …，总是为4的倍数 在扩容时不必担心发生内存溢出，因为内部已经设置了最大值 为：PY_SSIZE_T_MAX *（9/8）+ 6 缩容机制 缩容机制建立在列表有空余空间的情况下。 我们如果使用pop()方法删除了最后一个数据项，其实并不会将最后一个列表槽位所占用的内存空间给释放掉而是进行保留，内部仅进行一次Py_ssize_t ob_size - 1的操作。 这样做的好处是，后面再添加数据项时，其实就不用再次进行扩容了。 但是在添加数据项之前，会判断整个列表的容量是否过大，如果过大即代表还有很多空的位置，此时要进行缩容机制： 如果数据项个数 + 1 则进行缩容，删除空的列表槽位 如果是clear()清空列表中的数据项，则直接非常干脆的将容量以及大小都重置为0，并且将该列表所有槽位占据的内存空间进行释放。 迁徙机制 因为列表底层是顺序存储，必须占用一个连续的内存空间。 如果在进行扩容时，发现后面连续的内存空间被其他对象所占据，则会将整个列表进行一次拷贝。 然后迁徙到新的位置开辟内存，确保所有的列表槽位都是连续的。 列表缓存 当删除一个列表之后，会将该列表中槽位引用的数据项地址全部清空。 并且将该列表的引用存放至一个叫做free_list的缓存中，下次如果再需要创建列表，则直接从free_list缓存中获取。 free_list最多可以缓存80个列表 示例，旧列表被删除后将空列表的引用存放至free_list缓存中，当再次创建一个新列表时，会直接从free_list缓存中获取旧列表，并且填入数据项： lst1 = [1, 2, 3] print(id(lst1)) del lst1 lst2 = [4, 5, 6, 7] print(id(lst2)) # 4405732936 # 4405732936 listobject.c源码 官网参考：点我跳转 源码一览：点我跳转 以下是截取了一些关键性源代码，并且做上了中文注释，方便查阅。 每一个列表都有几个关键性的属性： Py_ssize_t ob_refcnt; // 引用计数器 PyObject **ob_item; // 列表内部槽位的数据项指针，即指针的指针 Py_ssize_t ob_size; // 列表大小 Py_ssize_t allocated; // 列表容量 创建列表 PyObject * PyList_New(Py_ssize_t size) { // 空列表 if (size numfree != -1); #endif // 判断是否有free_list中是否有缓存 if (state->numfree) { // 有缓存，free_list缓存的列表个数减1 state->numfree--; op = state->free_list[state->numfree]; // 建立新的引用关系 _Py_NewReference((PyObject *)op); } else { // 无缓存，创建新列表，先开辟内存 op = PyObject_GC_New(PyListObject, &PyList_Type); if (op == NULL) { return NULL; } } if (size ob_item = NULL; } else { // 如果列表不是空的，则将每个槽位的数据项地址进行引用 op->ob_item = (PyObject **) PyMem_Calloc(size, sizeof(PyObject *)); if (op->ob_item == NULL) { Py_DECREF(op); return PyErr_NoMemory(); } } // 设置列表中数据项占据的容量大小 Py_SET_SIZE(op, size); // 设置列表的整体容量 op->allocated = size; // 将列表放入双向链表中以进行内存管理 _PyObject_GC_TRACK(op); // 返回列表的结构体指针 return (PyObject *) op; } 添加元素 static int app1(PyListObject *self, PyObject *v) { // 获取列表的大小（已占用容量） Py_ssize_t n = PyList_GET_SIZE(self); assert (v != NULL); assert((size_t)n + 1 static int list_resize(PyListObject *self, Py_ssize_t newsize) { PyObject **items; size_t new_allocated, num_allocated_bytes; Py_ssize_t allocated = self->allocated; /* Bypass realloc() when a previous overallocation is large enough to accommodate the newsize. If the newsize falls lower than half the allocated size, then proceed with the realloc() to shrink the list. */ // 扩容、缩容机制调用realloc()函数 // allocated = 容量 // newsize代表已存在的数据项个数 + 1 // 当前列表容量 > 已有数据项个数+1 and 已有数据项个数 >= 当前列表容量的一半 if (allocated >= newsize && newsize >= (allocated >> 1)) { assert(self->ob_item != NULL || newsize == 0); // 则直接添加数据项，不进行扩容 // 并新增数据项个数 Py_ssize_t ob_size + 1 Py_SET_SIZE(self, newsize); return 0; } /* This over-allocates proportional to the list size, making room * for additional growth. The over-allocation is mild, but is * enough to give linear-time amortized behavior over a long * sequence of appends() in the presence of a poorly-performing * system realloc(). * Add padding to make the allocated size multiple of 4. * The growth pattern is: 0, 4, 8, 16, 24, 32, 40, 52, 64, 76, ... * Note: new_allocated won't overflow because the largest possible value * is PY_SSIZE_T_MAX * (9 / 8) + 6 which always fits in a size_t. */ new_allocated = ((size_t)newsize + (newsize >> 3) + 6) & ~(size_t)3; /* Do not overallocate if the new size is closer to overallocated size * than to the old size. */ // 如果数据项个数 + 1 (Py_ssize_t)(new_allocated - newsize)) new_allocated = ((size_t)newsize + 3) & ~(size_t)3; // 全是空的 if (newsize == 0) new_allocated = 0; num_allocated_bytes = new_allocated * sizeof(PyObject *); // 基于realloc()进行扩容或者缩容，内部会包含数据项的位置调整 items = (PyObject **)PyMem_Realloc(self->ob_item, num_allocated_bytes); if (items == NULL) { PyErr_NoMemory(); return -1; } // 重新设置列表的 ob_item、obsize、allocated self->ob_item = items; Py_SET_SIZE(self, newsize); self->allocated = new_allocated; return 0; } 插入元素 static int ins1(PyListObject *self, Py_ssize_t where, PyObject *v) { // 获取数据项个数 Py_ssize_t i, n = Py_SIZE(self); PyObject **items; // 插入数据项确保不是NULL if (v == NULL) { PyErr_BadInternalCall(); return -1; } assert((size_t)n + 1 n) where = n; // 拿到列表中所有数据项的引用 items = self->ob_item; // 让插入位置之后的所有数据项开始向后挪动1个位置，腾出位置来插入新的数据项 for (i = n; --i >= where; ) // i + 1指的是数据项指针地址，每次 - 1 items[i+1] = items[i]; // 新增数据项的引用计数 + 1 Py_INCREF(v); // 新的数据项索引位置和值做绑定 items[where] = v; return 0; } int PyList_Insert(PyObject *op, Py_ssize_t where, PyObject *newitem) { // 传入列表的引用， 插入的位置，还有新的数据项引用，并且验证列表和数据项 if (!PyList_Check(op)) { PyErr_BadInternalCall(); return -1; } // 进行插入 return ins1((PyListObject *)op, where, newitem); } 移除元素 static PyObject * list_pop_impl(PyListObject *self, Py_ssize_t index) // 传入列表的引用，列表的弹出数据项索引位置 { PyObject *v; int status; // 如果是一个空列表，则抛出异常 if (Py_SIZE(self) == 0) { /* Special-case most common failure cause */ PyErr_SetString(PyExc_IndexError, \"pop from empty list\"); return NULL; } if (index ob_item[index]; // 如果弹出的数据项是列表中的最后一个 if (index == Py_SIZE(self) - 1) { // list_resize()内部只会做size - 1，而不会回收内存进行缩容 status = list_resize(self, Py_SIZE(self) - 1); if (status >= 0) return v; /* and v now owns the reference the list had */ else return NULL; } // 增加一次引用计数器 Py_INCREF(v); // 如果弹出的数据项不是列表中的最后一个，则需要进行位置调整 status = list_ass_slice(self, index, index+1, (PyObject *)NULL); if (status 清空元素 static int _list_clear(PyListObject *a) { Py_ssize_t i; PyObject **item = a->ob_item; if (item != NULL) { /* Because XDECREF can recursively invoke operations on this list, we make it empty first. */ i = Py_SIZE(a); // 重新设置大小为0 Py_SET_SIZE(a, 0); // 将列表中插槽引用的对象全部设置为None a->ob_item = NULL; // 重新设置容量为0 a->allocated = 0; // 循环列表中的数据项，令所有数据项的引用计数-1 while (--i >= 0) { Py_XDECREF(item[i]); } PyMem_Free(item); } /* Never fails; the return value can be ignored. Note that there is no guarantee that the list is actually empty at this point, because XDECREF may have populated it again! */ return 0; } 删除列表 static void list_dealloc(PyListObject *op) { Py_ssize_t i; // 内部会判断这个列表是否还有其他标识符引用，如果为0则代表没有其他标识符引用 // 可以通过内部GC机制将该列表所占据的内存空间进行释放 PyObject_GC_UnTrack(op); Py_TRASHCAN_BEGIN(op, list_dealloc) if (op->ob_item != NULL) { /* Do it backwards, for Christian Tismer. There's a simple test case where somehow this reduces thrashing when a *very* large list is created and immediately deleted. */ // 获取列表中已有数据项的个数（即大小） i = Py_SIZE(op); // 循环列表中的数据项，令所有数据项的引用计数-1 while (--i >= 0) { Py_XDECREF(op->ob_item[i]); } PyMem_Free(op->ob_item); } struct _Py_list_state *state = get_list_state(); #ifdef Py_DEBUG // list_dealloc() must not be called after _PyList_Fini() assert(state->numfree != -1); #endif // 判断free_list中的已缓存列表个数是否大于80，这里是没满 // 在free_list中添加空列表的引用即可 if (state->numfree free_list[state->numfree++] = op; } else { // 如果free_list的大小已达到容量限制 // 则直接在内存中销毁列表的结构体对象 Py_TYPE(op)->tp_free((PyObject *)op); } Py_TRASHCAN_END } Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-10 14:50:19 "},"Python/Python基础知识/元组类型.html":{"url":"Python/Python基础知识/元组类型.html","title":"元组类型","keywords":"","body":"元组 Python中的元组容器序列（tuple）与列表容器序列（list）具有极大的相似之处，因此也常被称为不可变的列表。 但是两者之间也有很多的差距，元组侧重于数据的展示，而列表侧重于数据的存储与操作。 它们非常相似，虽然都可以存储任意类型的数据，但是一个元组定义好之后就不能够再进行修改。 元组特性 元组特性如下： 元组属于线性容器序列 元组属于不可变类型，即对象本身的属性不会根据外部变化而变化 元组底层由顺序存储组成，而顺序存储是线性结构的一种 基本声明 以下是使用类实例化的形式进行对象声明： tpl = tuple((1, 2, 3, 4, 5)) print(\"value : %r\\ntype : %r\" % (tpl, type(tpl))) # value : (1, 2, 3, 4, 5) # type : 也可以选择使用更方便的字面量形式进行对象声明，使用逗号对数据项之间进行分割： tpl = 1, 2, 3, 4, 5 print(\"value : %r\\ntype : %r\" % (tpl, type(tpl))) # value : (1, 2, 3, 4, 5) # type : 为了美观，我们一般会在两侧加上()，但是要确定一点，元组定义是用逗号来分隔数据项，而并非是用()包裹数据项： tpl = (1, 2, 3, 4, 5) print(\"value : %r\\ntype : %r\" % (tpl, type(tpl))) # value : (1, 2, 3, 4, 5) # type : 多维元组 当一个元组中嵌套另一个元组，该元组就可以称为多维元组。 如下，定义一个2维元组： tpl = (1, 2, (\"三\", \"四\")) print(\"value : %r\\ntype : %r\" % (tpl , type(tpl))) # value : (1, 2, ('三', '四')) # type : 续行操作 在Python中，元组中的数据项如果过多，可能会导致整个元组太长，太长的元组是不符合PEP8规范的。 每行最大的字符数不可超过79，文档字符或者注释每行不可超过72 Python虽然提供了续行符\\，但是在元组中可以忽略续行符，如下所示： tpl = ( 1, 2, 3, 4, 5 ) print(\"value : %r\\ntype : %r\" % (tpl, type(tpl))) # value : (1, 2, 3, 4, 5) # type : 类型转换 元组支持与布尔型、字符串、列表、以及集合类型进行类型转换： tpl = (1, 2, 3) bTpl = bool(tpl) strTpl = str(tpl) lstTpl = list(tpl) setTpl = set(tpl) print(\"value : %r\\ntype : %r\" % (bTpl, type(bTpl))) print(\"value : %r\\ntype : %r\" % (strTpl, type(strTpl))) print(\"value : %r\\ntype : %r\" % (lstTpl, type(lstTpl))) print(\"value : %r\\ntype : %r\" % (setTpl, type(setTpl))) # value : True # type : # value : '(1, 2, 3)' # type : # value : [1, 2, 3] # type : # value : {1, 2, 3} # type : 如果一个2维元组遵循一定的规律，那么也可以将其转换为字典类型： tpl = ((\"k1\", \"v1\"), (\"k2\", \"v2\"), (\"k3\", \"v3\")) dictTuple = dict(tpl) print(\"value : %r\\ntype : %r\" % (dictTuple, type(dictTuple))) # value : {'k1': 'v1', 'k2': 'v2', 'k3': 'v3'} # type : 索引操作 元组由于是线性结构，故支持索引和切片操作 但只针对获取，不能对其内部数据项进行修改。 使用方法参照列表的索引切片一节。 绝对引用 元组拥有绝对引用的特性，无论是深拷贝还是浅拷贝，都不会获得其副本，而是直接对源对象进行引用。 但是列表没有绝对引用的特性，代码验证如下： >>> import copy >>> # 列表的深浅拷贝均创建新列表... >>> oldLi = [1, 2, 3] >>> id(oldLi) 4542649096 >>> li1 = copy.copy(oldLi) >>> id(li1) 4542648840 >>> li2 = copy.deepcopy(oldLi) >>> id(li2) 4542651208 >>> # 元组的深浅拷贝始终引用老元组 >>> oldTup = (1, 2, 3) >>> id(oldTup) 4542652920 >>> tup1 = copy.copy(oldTup) >>> id(tup1) 4542652920 >>> tup2 = copy.deepcopy(oldTup) >>> id(tup2) 4542652920 Python为何要这样设计？其实仔细想想不难发现，元组不能对其进行操作，仅能获取数据项。 那么也就没有生成多个副本提供给开发人员操作的必要了，因为你修改不了元组，索性直接使用绝对引用策略。 值得注意的一点：[:]也是浅拷贝，故对元组来说属于绝对引用范畴。 元组的陷阱 Leonardo Rochael在2013年的Python巴西会议提出了一个非常具有思考意义的问题。 我们先来看一下： >>> t = (1, 2, [30, 40]) >>> t[-1] += [50, 60] Traceback (most recent call last): File \"\", line 1, in TypeError: 'tuple' object does not support item assignment 现在，t到底会发生下面4种情况中的哪一种？ t 变成 (1, 2, [30, 40, 50, 60])。 因为 tuple 不支持对它的数据项赋值，所以会抛出 TypeError 异常。 以上两个都不是。 a 和 b 都是对的。 正确答案是4，t确实会变成 (1, 2, [30, 40, 50, 60])，但同时元组是不可变类型故会引发TypeError异常的出现。 >>> t (1, 2, [30, 40, 50, 60]) 如果是使用extend()对t[-1]的列表进行数据项的增加，则答案会变成1。 我当初在看了这个问题后，暗自告诉自己了1件事情： tuple中不要存放可变类型的数据，如list、set、dict等.. 元组更多的作用是展示数据，而不是操作数据。 举个例子，当用户根据某个操作获取到了众多数据项之后，你可以将这些数据项做出元组并返回。 用户对被返回的原对象只能看，不能修改，若想修改则必须创建新其他类型对象。 解构方法 元组的解构方法与列表使用相同。 使用方法参照列表的解构方法一节。 常用方法 方法一览 常用的tuple方法一览表： 方法名 返回值 描述 count() integer 返回数据项在T中出现的次数 index() integer 返回第一个数据项在T中出现位置的索引，若值不存在，则抛出ValueError 基础公用函数： 函数名 返回值 描述 len() integer 返回容器中的项目数 enumerate() iterator for index, value of iterable 返回一个可迭代对象，其中以小元组的形式包裹数据项与正向索引的对应关系 reversed() ... 详情参见函数章节 sorted() ... 详情参见函数章节 获取长度 使用len()方法来获取元组的长度。 返回int类型的值。 tpl = (\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\") print(len(tpl)) # 7 Python在对内置的数据类型使用len()方法时，实际上是会直接的从PyVarObject结构体中获取ob_size属性，这是一种非常高效的策略。 PyVarObject是表示内存中长度可变的内置对象的C语言结构体。 直接读取这个值比调用一个方法要快很多。 统计次数 使用count()方法统计数据项在该元组中出现的次数。 返回int： tpl = (\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\", \"A\") aInTupCount = tpl.count(\"A\") print(aInTupCount) # 2 查找位置 使用index()方法找到数据项在当前元组中首次出现的位置索引值，如数据项不存在则抛出异常。 返回int。 tpl = (\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\", \"A\") aInTupIndex = tpl.index(\"A\") print(aInTupIndex) # 0 底层探究 内存开辟 Python内部实现中，列表和元组还是有一定的差别的。 元组在创建对象申请内存的时候，内存空间大小便进行了固定，后续不可更改（如果是传入了一个可迭代对象，例如tupe(range(100))，这种情况会进行扩容与缩容，下面的章节将进行详细研究）。 而列表在创建对象申请内存的时候，内存空间大小不是固定的，如果后续对其新增或删除数据项，列表会进行扩容或者缩容机制。 元组创建 空元组 若创建一个空元组，会直接进行创建，然后将这个空元组丢到缓存free_list中。 元组的free_list最多能缓存 20 * 2000 个元组，这个在下面会进行讲解。 如图所示： 元组转元组 下面的代码会进行元组转元组： tup = tuple((1, 2, 3)) 首先内部的参数本身就是一个元组（1， 2， 3），所以会直接将内部的这个元组拿出来并返回引用，并不会再次创建。 代码验证： >>> oldTpl = (1, 2, 3) >>> id(oldTpl) 4384908128 >>> newTpl = tuple(oldTpl) >>> id(newTpl) 4384908128 >>> 列表转元组 列表转元组会将列表中的每一个数据项都拿出来，然后放入至元组中： tpl = tuple([1, 2, 3]) 所以你会发现，列表和元组中的数据项引用都是相同的： >>> lst = [\"A\", \"B\", \"C\"] >>> tpl = tuple(lst) >>> print(id(lst[0])) 4383760656 >>> print(id(tpl[0])) 4383760656 >>> 可迭代对象转元组 可迭代对象是没有长度这一概念的，如果是可迭代对象转换为元组，会先对可迭代对象的长度做一个猜想。 并且根据这个猜想，为元组开辟一片内存空间，用于存放可迭代对象的数据项。 然后内部会获取可迭代对象的迭代器，对其进行遍历操作，拿出数据项后放至元组中。 如果猜想的长度太小，会导致元组内部的内存不够存放下所有的迭代器数据项，此时该元组会进行内部的扩容机制，直至可迭代对象中的数据项全部被添加至元组中。 rangeObject = range(1, 101) tpl = tuple(rangeObject) // 假如猜想的是9 // 第一步：+ 10 // 第二步：+ (原长度+10) * 0.25 // 其实，就是增加【原长度*0.25 + 2.5】 // 即第一次新增4个槽位 如果猜想的长度太大，而实际上迭代器中的数据量偏少，则需要对该元组进行缩容。 切片取值 对元组进行切片取值的时候，会开辟一个新元组用于存放切片后得到的数据项。 tpl = (1, 2, 3) newSliceTpl = tpl[0:2] 当然，如果是[:]的操作，则参照绝对引用，直接返回被切片的元组引用。 代码验证： >>> id(tpl) 4384908416 >>> newSliceTpl = tpl[0:2] >>> id(newSliceTpl) 4384904392 缓存机制 free_list缓存 元组的缓存机制和列表的缓存机制不同。 元组的free_list会缓存0 - 19长度的共20种元组，其中每一种长度的元组通过单向链表横向扩展缓存至2000个，如下图所示： 当每一次del操作有数据项的元组时，都会将该元组数据项清空并挂载至free_list单向链表的头部的位置。 del (1, 2, 3) --> (None, None, None) \\ del (4, 5, 6) --> (None, None, None) -> free_list 长度3的元组 ... del (7, 8, 9) --> (None, None, None) / 如下图所示： 当要创建一个元组时，会通过创建元组的长度，从free_list单向链表的头部取出一个元组，然后将数据项存放进去。 前提是free_list单向链表中缓存的有该长度的元组。 tup = (1, 2, 3) # 长度为3，从free_list的长度为3的元组中取 空元组与非空元组的缓存 空元组的缓存是一经创建就缓存到free_list单向链表中。 而非空元组的缓存必须是del操作后才缓存到free_list单向链表中。 空元组的创建 第一次创建空元组后，空元组会缓存至free_list单向链表中。 以后的每一次空元组创建，返回的其实都是同一个引用，也就是说空元组在free_list单向链表中即使被引用了也不会被销毁。 >>> t1 = () >>> id(t1) 4511088712 >>> t2 = () >>> id(t2) 4511088712 非空元组的创建 创建非空元组时，先检查free_list，当free_list单向链表中有相同长度的元组时，会进行引用并删除。 这个在上图中已经示例过了，就是这个： 代码示例： $ python3 Python 3.6.8 (v3.6.8:3c6b436a57, Dec 24 2018, 02:04:31) [GCC 4.2.1 Compatible Apple LLVM 6.0 (clang-600.0.57)] on darwin Type \"help\", \"copyright\", \"credits\" or \"license\" for more information. >>> v1 = (None, None, None) >>> id(v1) 4384907696 >>> v2 = (None, None, None) >>> id(v2) 4384908056 >>> del v1 >>> del v2 # ❶ >>> v3 = (None, None, None) >>> id(v3) # ❷ 4384908056 >>> v4 = (None, None, None) >>> id(v4) # ❸ 4384907696 >>> ❶：free_list num_free=3 单向链表结构：v2 —> v1 ❷：创建了v3，拿出v2的空元组，填入v3数据项，故v2和v3的id值相等，证明引用同一个元组，此时free_list num_free=3 单向链表结构为：—> v1 ❸：创建了v4，拿出v1的空元组，填入v4数据项，故v1和v4的id值相等，证明引用同一个元组 tupleobject.c源码 官网参考：点我跳转 源码一览：点我跳转 以下是截取了一些关键性源代码，并且做上了中文注释，方便查阅。 每一个元组都有几个关键性的属性： Py_ssize_t ob_refcnt; // 引用计数器 Py_ssize_t ob_size; // 数据项个数，即元组大小 PyObject *ob_item[1]; // 存储元组中的数据项 [指针, ] 关于缓存free_list的属性： PyTuple_MAXSAVESIZE // 相当于图中的 free_num ，最大20，即纵向扩展的缓存元组长度 PyTuple_MAXFREELIST // 图中 free_list 的横向扩展缓存列表个数，最大2000 创建元组 空元组 PyObject * PyTuple_New(Py_ssize_t size) { PyTupleObject *op; // 缓存相关 Py_ssize_t i; // 元组的大小不能小于0 if (size 0 // 创建空元组，优先从缓存中获取 // size = 0 表示这是一个空元组，从free_list[0]中获取空元组 if (size == 0 && free_list[0]) { // op就是空元组 op = free_list[0]; // 新增空元组引用计数器 + 1 Py_INCREF(op); #ifdef COUNT_ALLOCS tuple_zero_allocs++; #endif // 返回空元组的指针 return (PyObject *) op; } // 如果创建的不是空元组，且这个创建的元组数据项个数小于20，并且free_list[size]不等于空，表示有缓存 // 则从缓存中去获取，不再重新开辟内存 if (size ob_item[0]; // num_free减1 numfree[size]--; #ifdef COUNT_ALLOCS fast_tuple_allocs++; #endif /* Inline PyObject_InitVar */ // 初始化，定义这个元组的长度为数据项个数 #ifdef Py_TRACE_REFS Py_SIZE(op) = size; // 定义类型为 tuple Py_TYPE(op) = &PyTuple_Type; #endif // 增加一次新的引用 _Py_NewReference((PyObject *)op); } // 如果是空元组 else #endif { // 检查内存情况，是否充足 /* Check for overflow */ if ((size_t)size > ((size_t)PY_SSIZE_T_MAX - sizeof(PyTupleObject) - sizeof(PyObject *)) / sizeof(PyObject *)) { return PyErr_NoMemory(); } // 开辟内存，并获得一个元组：op op = PyObject_GC_NewVar(PyTupleObject, &PyTuple_Type, size); if (op == NULL) return NULL; } // 空元组的每一个槽位都是NULL for (i=0; i ob_item[i] = NULL; #if PyTuple_MAXSAVESIZE > 0 // 缓存空元组 if (size == 0) { free_list[0] = op; ++numfree[0]; Py_INCREF(op); /* extra INCREF so that this is never freed */ } #endif #ifdef SHOW_TRACK_COUNT count_tracked++; #endif // 将元组加入到GC机制中，用于内存管理 _PyObject_GC_TRACK(op); return (PyObject *) op; } 可迭代对象转元组 这个不在tupleobject.c源码中，而是在abstract.c源码中。 官网参考：点我跳转 源码一览：点我跳转 PyObject * PySequence_Tuple(PyObject *v) { PyObject *it; /* iter(v) */ Py_ssize_t n; /* guess for result tuple size */ PyObject *result = NULL; Py_ssize_t j; if (v == NULL) { return null_error(); } /* Special-case the common tuple and list cases, for efficiency. */ // 如果是元组转换元组，如 tup = (1, 2, 3) 或者 tup = ((1, 2, 3))直接返回内存地址 if (PyTuple_CheckExact(v)) { Py_INCREF(v); return v; } // 如果是列表转换元组，则执行PyList_AsTuple()，将列表转换为元组 // 如 tup = ([1, 2, 3]) if (PyList_CheckExact(v)) return PyList_AsTuple(v); /* Get iterator. */ // 获取迭代器， tup = (range(1, 4).__iter__()) it = PyObject_GetIter(v); if (it == NULL) return NULL; /* Guess result size and allocate space. */ // 猜想迭代器长度，也就是猜一下有多少个数据项 n = PyObject_LengthHint(v, 10); if (n == -1) goto Fail; // 根据猜想的迭代器长度，进行元组的内存开辟 result = PyTuple_New(n); if (result == NULL) goto Fail; /* Fill the tuple. */ // 将迭代器中每个数据项添加至元组中 for (j = 0; ; ++j) { PyObject *item = PyIter_Next(it); if (item == NULL) { if (PyErr_Occurred()) goto Fail; break; } //如果迭代器中数据项比猜想的多，则证明开辟内存不足需要需要进行扩容 if (j >= n) { size_t newn = (size_t)n; /* The over-allocation strategy can grow a bit faster than for lists because unlike lists the over-allocation isn't permanent -- we reclaim the excess before the end of this routine. So, grow by ten and then add 25%. */ // 假如猜想的是9 // 第一步：+ 10 // 第二步：+ (原长度+10) * 0.25 // 其实，就是增加【原长度*0.25 + 2.5】 newn += 10u; newn += newn >> 2; // 判断是否超过了元组的数据项个数限制（sys.maxsize） if (newn > PY_SSIZE_T_MAX) { /* Check for overflow */ PyErr_NoMemory(); Py_DECREF(item); goto Fail; } n = (Py_ssize_t)newn; // 扩容机制 if (_PyTuple_Resize(&result, n) != 0) { Py_DECREF(item); goto Fail; } } // 将数据项放入元组之中 PyTuple_SET_ITEM(result, j, item); } /* Cut tuple back if guess was too large. */ // 如果猜想的数据项太多，而实际上迭代器中的数据量偏少 // 则需要对该元组进行缩容 if (j 列表转元组 这个不在tupleobject.c源码中，而是在listobject.c源码中。 官网参考：点我跳转 源码一览：点我跳转 PyObject * PyList_AsTuple(PyObject *v) { PyObject *w; PyObject **p, **q; Py_ssize_t n; // 例如：tup = ([1, 2, 3]) // 进行列表的验证 if (v == NULL || !PyList_Check(v)) { PyErr_BadInternalCall(); return NULL; } // 获取大小，即数据项个数 n = Py_SIZE(v); // 开辟内存 w = PyTuple_New(n); // 如果是空元组 if (w == NULL) return NULL; // 执行迁徙操作 p = ((PyTupleObject *)w)->ob_item; q = ((PyListObject *)v)->ob_item; // 将列表中数据项的引用，也给元组进行引用 // 这样列表中数据项和元组中的数据项都引用同1个对象 while (--n >= 0) { // 数据项引用计数 + 1 Py_INCREF(*q); *p = *q; p++; q++; } // 返回元组 return w; } 切片取值 PyObject * PyTuple_GetSlice(PyObject *op, Py_ssize_t i, Py_ssize_t j) // 切片会触发该方法 { // 如果对空元组进行切片，则会抛出异常 if (op == NULL || !PyTuple_Check(op)) { PyErr_BadInternalCall(); return NULL; } // 内部的具体实现方法 return tupleslice((PyTupleObject *)op, i, j); } static PyObject * tupleslice(PyTupleObject *a, Py_ssize_t ilow, Py_ssize_t ihigh) { PyTupleObject *np; PyObject **src, **dest; Py_ssize_t i; Py_ssize_t len; // 计算索引位置 if (ilow Py_SIZE(a)) ihigh = Py_SIZE(a); if (ihigh ob_item + ilow; dest = np->ob_item; // 对源元组中的数据项的引用计数+1 for (i = 0; i 缓存相关 static void tupledealloc(PyTupleObject *op) { Py_ssize_t i; Py_ssize_t len = Py_SIZE(op); PyObject_GC_UnTrack(op); Py_TRASHCAN_SAFE_BEGIN(op) // 如果元组的长度大于0，则不是一个非空元组 if (len > 0) { i = len; // 将内部的数据项引用计数都 - 1 while (--i >= 0) Py_XDECREF(op->ob_item[i]); #if PyTuple_MAXSAVESIZE > 0 // 准备缓存，判断num_free是否小于20，并且单向链表中的已缓存元组个数小于2000 if (len ob_item[0] = (PyObject *) free_list[len]; // 将num_free + 1 numfree[len]++; free_list[len] = op; goto done; /* return */ } #endif } // 内存中进行销毁 Py_TYPE(op)->tp_free((PyObject *)op); done: Py_TRASHCAN_SAFE_END(op) } Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-10 14:53:42 "},"Python/Python基础知识/字符串类型.html":{"url":"Python/Python基础知识/字符串类型.html","title":"字符串类型","keywords":"","body":"字符串 字符串（str）一般是指Unicode字符串，见名知意，字符串是由多个字符所构成的一个串。 它是Python中最常用的数据类型之一，因此十分重要。 字符串有一个最显著的特征，即不可变，也就是说你无法使用索引来改变字符串中的字符，仅限于获取。 字符串特性 字符串特性如下： 字符串属于线性扁平序列 字符串是不可变的，即对象本身的属性不会根据外部变化而变化 字符串底层是一段连续的内存空间 基本声明 以下是使用类实例化的形式进行对象声明： string = str(\"ABCDEFG\") print(\"value : %r\\ntype : %r\" % (string, type(string))) # value : 'ABCDEFG' # type : 也可以选择使用更方便的字面量形式进行对象声明，使用英文状态下的单引号、双引号、三单引号、三双引号将数据项进行包裹即可： string = \"ABCDEFG\" print(\"value : %r\\ntype : %r\" % (string, type(string))) # value : 'ABCDEFG' # type : 个人并不推荐常规的使用三单引号或三双引号进行字符串定义，因为除了字符串定义外它们还具有文档注释的功能。 续行操作 在Python中，如果一个字符串过长，可能会导致不符合PEP8规范的情况出现。 每行最大的字符数不可超过79，文档字符或者注释每行不可超过72 如果要定义这样的长字符串，推荐使用三单引号或者三双引号进行定义，这样即可进行换行（但会保留特殊字符，如\\n）: string = \"\"\" 江雪 柳宗元 千山鸟飞绝 万径人踪灭 孤舟蓑笠翁 独钓寒江雪 \"\"\" print(\"value : %r\\ntype : %r\" % (string, type(string))) # value : '\\n 江雪\\n 柳宗元\\n千山鸟飞绝\\n万径人踪灭\\n孤舟蓑笠翁\\n独钓寒江雪\\n' # type : 类型转换 字符串支持与布尔型、整形、以及浮点型进行转换，这是最常用的操作： string = \"100\" iStr = int(string) bStr = bool(string) fStr = float(string) print(\"value : %r\\ntype : %r\" % (iStr, type(iStr))) print(\"value : %r\\ntype : %r\" % (bStr, type(bStr))) print(\"value : %r\\ntype : %r\" % (fStr, type(fStr))) # value : 100 # type : # value : True # type : # value : 100.0 # type : 需要注意的是，如果一个字符串不是纯数字，那么将其转换为整形或浮点型时将会出现异常： string = \"Non-digital string: 100\" iStr = int(string) fStr = float(string) print(\"value : %r\\ntype : %r\" % (iStr, type(iStr))) print(\"value : %r\\ntype : %r\" % (fStr, type(fStr))) # ValueError: invalid literal for int() with base 10: 'Non-digital string: 100' 此外，字符串也支持转换为列表以及集合： string = \"①〇②④\" setStr = set(string) listStr = list(string) print(\"value : %r\\ntype : %r\" % (setStr, type(setStr))) print(\"value : %r\\ntype : %r\" % (listStr, type(listStr))) # value : {'①', '〇', '②', '④'} # type : # value : ['①', '〇', '②', '④'] # type : 特殊的\\ 在普通的声明字符串中，\\后面一般都会跟上一个特殊字符。 该字符具有特殊的意义，如\\n代表换行，\\t代表制表符等，这种具有特殊意义的\\char组合被称为转义字符。 转义字符 意义 ASCII码值（十进制） \\a 响铃(BEL) 007 \\b 退格(BS) ，将当前位置移到前一列 008 \\f 换页(FF)，将当前位置移到下页开头 012 \\n 换行(LF) ，将当前位置移到下一行开头 010 \\r 回车(CR) ，将当前位置移到本行开头 013 \\t 水平制表(HT) （跳到下一个TAB位置） 009 \\v 垂直制表(VT) 011 \\ 代表一个反斜线字符''' 092 \\' 代表一个单引号（撇号）字符 039 \\\" 代表一个双引号字符 034 ? 代表一个问号 063 \\0 空字符(NUL) 000 \\ddd 1到3位八进制数所代表的任意字符 三位八进制 \\xhh 十六进制所代表的任意字符 十六进制 如果你还是不能理解，那么可看下面这个示例： 我想打印 hello”world，并且我的字符串字面量声明采用 “ 进行包裹。 我们必须进行“的转义，让它变为一个普通字符，而非Python中字符串字面量语法表示符： print(\"hello\\\"world\") # hello\"world r字符串 如果在声明字符串的前面加上字符r，则代表该字符串中不会存在转义字符，所有字符将按照普通的方式进行解读。 r字符串也被称为原始字符串： s1 = r\"\\n\\t\\b\" print(s1) # \\n\\t\\b 字节串 字节串（bytes）是字符串的另一种表现形式。 它记录内存中的原始数据，你可以将它理解为2进制数据。 字节串可用于网络传输、多媒体持久化存储中，它和字符串拥有相同的特性，即不可变。 字节串仅在Python3中出现，Python2中不存在该类型。 基本声明 以下是使用类实例化的形式进行对象声明，必须传入一个字符串及指定该字符串的编码格式，如不传入字符串，则默认生成空的bytes对象： bitStr = bytes(\"ABCDEFG\".encode(\"u8\")) print(\"value : %r\\ntype : %r\" % (bitStr, type(bitStr))) # value : b'ABCDEFG' # type : 也可以选择使用更方便的字面量形式进行对象声明，使用英文状态下的小写b加上单引号、双引号、三单引号、三双引号将数据项进行包裹即可，注意数据项必须位于ASCII码表之内： bitStr = b\"ABCDEFG\" print(\"value : %r\\ntype : %r\" % (bitStr, type(bitStr))) # value : b'ABCDEFG' # type : 个人并不推荐常规的使用三单引号或三双引号进行字节串定义，它们还具有文档注释的功能。 编码解码 一个非ASCII标准字符串要变为字节串，必须通过encode()方法来做指定编码格式。 而一个字节串要想变为非ASCII标准字符串，也必须通过decode()方式做指定解码格式。 s = \"你好，世界，hello，world!\" bitStr = bytes(s.encode(encoding=\"u8\")) print(bitStr) string = str(bitStr.decode(encoding=\"u8\")) print(string) # b'\\xe4\\xbd\\xa0\\xe5\\xa5\\xbd\\xef\\xbc\\x8c\\xe4\\xb8\\x96\\xe7\\x95\\x8c\\xef\\xbc\\x8chello\\xef\\xbc\\x8cworld!' # 你好，世界，hello，world! 如果直接使用str.encode()则自动将str转变为bytes类型。 反之，如果直接使用bytes.decode()时bytes也会自动转为str类型。 因此我们可以省略bytes()和str()在外部的包裹： s = \"你好，世界，hello，world!\" bitStr = s.encode(encoding=\"u8\") print(bitStr) string = bitStr.decode(encoding=\"u8\") print(string) # b'\\xe4\\xbd\\xa0\\xe5\\xa5\\xbd\\xef\\xbc\\x8c\\xe4\\xb8\\x96\\xe7\\x95\\x8c\\xef\\xbc\\x8chello\\xef\\xbc\\x8cworld!' # 你好，世界，hello，world! 四则运算 基本操作 字符串支持与字符串进行加法运算，做到拼接的效果，由于字符串是不可变的，所以会生成一个新的字符串： s1 = \"string1\" s2 = \"string2\" print(s1 + s2) # string1string2 字符串支持与整形进行乘法运算，做到重复打印的效果，由于字符串是不可变的，所以会生成一个新的字符串： s1 = \"*\" print(s1 * 3) # *** “可变”的字符串 str可以使用+=操作，来使原本的字符串与新的字符串进行拼接。 +=是一种常见的操作，所以CPython内部为其做了优化。 一个str在初始化内存的时候，程序会为它留出额外的可扩展空间，因此进行增量操作的时候，并不会涉及复制原有字符串到新位置这类操作，而是在原有字符串位置的后面添加上新的字符串。 基于这个点，我们看一个有趣的问题： >>> a 'hello world !' >>> id(a) 140521043795728 >>> a+=\"d\" >>> id(a) 140521043795728 >>> a+=\"d\" >>> id(a) 140521043795728 >>> a 'hello world !dd' 乍看之下其实会发现字符串的+=操作并不会开辟额外的内存空间，但是事实并非如此。 CPython的字符串在底层依旧是不可变的，当这个字符串被+=新的字符串时，会产生一个新的字符串，恰好该字符串会复用之前字符串的id()值。 这个问题在stackoverflow上已经有人问过了，这里贴出原贴： 点我跳转 字符间隙 看一个有趣的例子： s1 = \"HELLO\" boolRET = \"\" in s1 print(boolRET) # True 下一个例子，使用count()方法计算该字符串中空白字符的数量： s1 = \"HELLO\" print(s1.count(\"\")) # 6 小问号你是否充满了很多朋友？ 实际上，Python内部进行str存储的时候会为每个字符之间留一个空隙，如下所示： 所以才会造成上述情况的发生。 intern机制 intern机制是Python解释器为了节省内存而做出的一种策略。 当第一次创建一个短字符串的时候，都会用一个全局的字典将该字符串进行存储，而短字符串的定义如下： 长度不超过20 不含空格 当再次创建这个短字符串，会先查看全局字典中是否存在该短字符串，如果存在则不创建而是直接进行引用。 这种策略也被称之为短字符串驻留机制。 下面这个示例字符串是符合短字符串的，因此会进行驻留： >>> s1 = \"Python\" >>> s2 = \"Python\" >>> s1 is s2 True 由于字符串中含有空格，故该字符串不会触发驻留机制： >>> s1 = \"Pytho n\" >>> s2 = \"Pytho n\" >>> s1 is s2 False 字符串长度超过20，也不会触发驻留机制： >>> s1 = \"Python\" * 10 >>> s2 = \"Python\" * 10 >>> s1 is s2 False 如果是空字符串，也会有驻留机制： >>> s1 = \"\" >>> s2 = \"\" >>> id(s1) 4360137392 >>> id(s2) 4360137392 绝对引用 字符串拥有绝对引用的特性，则无论是深拷贝还是浅拷贝，都不会获得其副本，而是直接对源对象进行引用： >>> import copy >>> oldStr = \"0\" * 100 >>> id(oldStr) 4373971144 >>> s1 = copy.copy(oldStr) >>> id(s1) 4373971144 >>> s2 = copy.deepcopy(oldStr) >>> id(s2) 4373971144 索引切片 字符串由于是线性结构，故支持索引和切片操作。 由于字符串是不可变类型，所以索引操作也仅支持获取数据项，不支持删改数据项。 使用方法参照列表的索引切片一节。 常用方法 方法一览 常用的str方法一览： 方法名 返回值 描述 strip() str 移除字符串两侧指定的字符，如不进行指定，则默认移除\\n、\\t以及空格。 split() list 按照指定字符进行从左到右的分割，以列表形式返回。可指定maxslipt限制切分次数 rsplit() list 按照指定字符进行从右到左的分割，以列表形式返回。可指定maxslipt限制切分次数 join() str 将一个列表中的数据项以指定字符拼接成新的字符串 replace() str 将字符串中的指定子串替换成另一个子串 count() integer 统计子串在父串中出现的次数 title() str 令字符串中的每一个单词首字母大写 capitalize() Str 令字符串中的句首单词首字母变为大写 find() integer 查找子串首次出现在父串中的索引值，若存在则返回索引，若不存在则返回-1，从左至右查找 rfind() integer 同上，从右至左查找 upper() str 令字符串中所有的小写字母转换为大写 lower() str 令字符串中所有的大写字母转换为小写 startswith() bool 判断字符串是否以特定子串开头 endswith() bool 判断字符串是否以特定子串结束 isdigit() bool 判断该字符串是否是一个数字串 基础公用函数： 函数名 返回值 描述 len() integer 返回容器中的项目数 enumerate() iterator for index, value of iterable 返回一个可迭代对象，其中以小元组的形式包裹数据项与正向索引的对应关系 reversed() ... 详情参见函数章节 sorted() ... 详情参见函数章节 获取长度 使用len()方法来进行字符串长度的获取。 返回int类型的值。 s1 = \"abcdefg\" print(len(s1)) # 7 Python在对内置的数据类型使用len()方法时，实际上是会直接的从PyVarObject结构体中获取ob_size属性，这是一种非常高效的策略。 PyVarObject是表示内存中长度可变的内置对象的C语言结构体。 直接读取这个值比调用一个方法要快很多。 移除空白 使用strip()方法移除字符串两侧指定的字符，如不进行指定，则默认移除\\n、\\t以及空格。 返回str类型的值。 s1 = \" abcdefg $$$\" res = s1.strip(\" $\") print(res) # abcdefg 拆分列表 使用split()方法按照指定字符进行从左到右的分割，以列表形式返回。可指定maxslipt限制切分次数。 返回list类型的值。 s1 = \"ab,cd,ef,gh\" res = s1.split(\",\",maxsplit=1) print(res) # ['ab', 'cd,ef,gh'] 使用rsplit()方法按照指定字符进行从右到左的分割，以列表形式返回。可指定maxslipt限制切分次数。 返回list类型的值。 s1 = \"ab,cd,ef,gh\" res = s1.rsplit(\",\",maxsplit=1) print(res) # ['ab,cd,ef', 'gh'] 列表合并 使用join()方法将一个列表中的数据项以指定字符拼接成新的字符串。 返回str类型的值。 l1 = [\"a\",\"b\",\"c\"] res = \"-\".join(l1) print(res) # a-b-c 替换操作 使用replace()方法将字符串中的指定子串替换成另一个子串。 返回str类型的值。 s1 = \"ABCDEFG\" res = s1.replace(\"BCD\",\"bcd\") print(res) # AbcdEFG 次数统计 使用count()方法统计子串在父串中出现的次数。 返回int类型的值。 s1 = \"HELLO\" res = s1.count(\"L\") print(res) # 2 词首大写 使用title()方法令字符串中的每一个单词首字母大写。 返回str类型的值。 s1 = \"hello world\" res = s1.title() print(res) # Hello World 句首大写 使用capitalize()方法令字符串中的句首单词变为大写。 返回str类型的值。 s1 = \"hello world\" res = s1.capitalize() print(res) # Hello world 索引位置 使用find()方法查找子串首次出现在父串中的索引值，若存在则返回索引，若不存在则返回-1，这是从左至右查找，rfind()则是从右至左查找。 返回int类型的值。 s1 = \"hello world\" res = s1.find(\"w\") print(res) # 6 小写转大写 使用upper()方法令字符串中所有的小写字母转换为大写。 返回str类型的值。 s1 = \"hello world\" res = s1.upper() print(res) # HELLO WORLD 大写转小写 使用lower()方法令字符串中所有的大写字母转换为小写。 返回str类型的值。 s1 = \"HELLO WORLD\" res = s1.lower() print(res) # hello world 指定开头 使用startswith()方法判断字符串是否以特定子串开头。 返回bool类型的值。 s1 = \"HELLO WORLD\" res = s1.startswith(\"HE\") print(res) # True 指定结尾 使用endswith()方法判断字符串是否以特定子串结束。 返回bool类型的值。 s1 = \"HELLO WORLD\" res = s1.endswith(\"LD\") print(res) # False 数字串 使用isdigit()方法判断该字符串是否是一个数字串。 返回bool类型的值。 s1 = \"100\" res = s1.isdigit() print(res) # True 其他方法 以下是一些其他不太常用的方法： 方法名 返回值 描述 index() integer 同find()，唯一区别找不到抛出异常，find()是返回-1，从左至右查找 rindex() integer 同上，从右至左查找 swapcase() str 字符串中大小进行翻转。大写转小写，小写转大写。 expandtabs() str 指定字符串中的tab长度，\\t代表制表符，默认长度为8 center() str 指定宽度，指定字符。若字符串的长度不够则将字符串放在中间，两侧使用指定字符填充 ljust() str 指定宽度，指定字符。若字符串的长度不够则将字符串放在左边，右侧使用指定字符填充 rjust() str 指定宽度，指定字符。若字符串的长度不够则将字符串放在右边，左侧使用指定字符填充 zfill() str 同rjust()，但是不可指定填充字符。按0进行填充 isdecimal() bool 判断字符串是否由数字组成。只支持unicode并且没有bytes的使用 isnumeric() bool 判断字符串是否由数字组成。只支持unicode，中文数字，罗马数字并且没有bytes的使用 isalnum() bool 判断字符串是否仅由数字和字母构成 isalpha() bool 判断字符串是否仅由字母构成 isspace() bool 判断字符串是否仅由空格构成 islower() bool 判断字符串是否纯小写 isupper() bool 判断字符串是否纯大写 istitle() bool 判断字符串中的单词是否首字母大写 index()与rindex()方法： s1 = \"Python\" s1.index(\"a\") s1.rindex(\"a\") # ValueError: substring not found 字符串翻转swapcase()方法： s1 = \"Python\" print(s1.swapcase()) # pYTHON 指定制表符长度的expandtabs()方法，默认制表符的长度为8，下面指定为4： s1 = \"P\\ty\\tt\\th\\to\\tn\" print(s1) print(s1.expandtabs(4)) # P y t h o n # P y t h o n 字符填充系列： s2 = \"H\" print(s2.center(20, \"+\")) print(s2.ljust(20, '+')) print(s2.rjust(20, '+')) print(s2.zfill(20)) # 0 填充，不可指定填充字符 # 其实总体来说就是将一个字符必须按照指定字符扩展为指定长度 # 区别在于源字符串的位置在指定填充符的中间、左侧、还是右侧 # +++++++++H++++++++++ # H+++++++++++++++++++ # +++++++++++++++++++H # 0000000000000000000H 字符串判断系列之数字串检测： s1 = b\"4\" # 字节数字串 s2 = u\"4\" # unicode数字串，默认Python3的str就是unicode编码，可以不用加u s3 = \"四\" # 中文数字串 s4 = \"Ⅳ\" # 罗马数字串 # isdigt()检测是否为数字串，只支持bytes和unicode print(s1.isdigit()) # True print(s2.isdigit()) # True print(s3.isdigit()) # False print(s4.isdigit()) # False # isdecimal()检测是否为数字串，只支持unicode字符串，如果是bytes字节串则抛出异常 print(s2.isdecimal()) # True print(s3.isdecimal()) # False print(s4.isdecimal()) # False # isnumeric()检测是否为数字串，不支持bytes字节串，支持unicode字符串、中文数字串、罗马数字串 print(s2.isnumeric()) # True print(s3.isnumeric()) # True print(s4.isnumeric()) # True 字符串判断之成员检测： s1 = \"Python3.6.8\" # isalnum() 判断字符串是否仅由数字和字母构成 print(s1.isalnum()) # False # isalpha() 判断字符串是否仅由字母构成 print(s1.isalpha()) # False # isspace() 判断字符串是否仅由空格构成 print(s1.isspace()) # False 字符串判断之大小写检测： s1 = \"Python3.6.8\" # islower() 判断字符串是否纯小写 print(s1.islower()) # False # isupper() 判断字符串是否纯大写 print(s1.isupper()) # False # istitle() 判断字符串中的单词是否首字母大写 print(s1.istitle()) # True 版本区别 数字与字符串对比 在Python2中是支持字符串与数字进行比较的，字符串永远比数字大： >>> \"0\" > 1 True 但是在Python3中，这种比较会抛出异常： >>> \"0\" > 1 Traceback (most recent call last): File \"\", line 1, in TypeError: '>' not supported between instances of 'str' and 'int' 表现形式 Python2的字符串表现形式为原始字节序列，也就是说Python2的str其实实际上是Python3的字节串，故仅支持在ASCII码表之内的字符： >>> s1 = \"你好，世界\" >>> s1 '\\xe4\\xbd\\xa0\\xe5\\xa5\\xbd\\xef\\xbc\\x8c\\xe4\\xb8\\x96\\xe7\\x95\\x8c' 但是在Python3中的字符串表现形式不是这样的，Python3中的字符串统一都为Unicode字符串： >>> s1 = \"你好，世界\" >>> s1 '你好，世界' 底层探究 扁平序列 这里引出一个新的概念，线性扁平序列。 扁平序列其实更加紧凑，但是它里面只能存放诸如字符、字节和数值这种基础类型 扁平序列里存放的是值而不是引用 扁平序列不支持多维的说法，仅有一个维度 字符串为什么要设计成不可变类型？这是由于字符串内部是采用连续存储的方式。 因为字符串是连续的一块内存存放（在c语言体现中其实是一个数组，以\\0结尾），被看做为一个整体，修改其中某一个数据项那么必定会导致后面的内存发生变化，链式反应滚起雪球需要处理的数据量很庞大，于是Python干脆不支持修改字符串。 strobject.c源码 官网参考：点我跳转 源码一览：点我跳转 关于字符串的源码阅读，感兴趣的朋友可以看一下，这里不再进行延伸阅读。 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-10 10:04:31 "},"Python/Python基础知识/字典类型.html":{"url":"Python/Python基础知识/字典类型.html","title":"字典类型","keywords":"","body":"字典 Python中的字典（dict）也被称为映射（mapping）或者散列（hash），是支持Python底层实现的重要数据结构。 同时，它也是应用最为广泛的数据结构，内部采用hash存储，存储方式为键值对。 字典本身属于可变容器类型，但键（key）必须为不可变类型，而值（value）可以是任意类型。。 字典的优点是单点查找速度极快，但不能够支持范围查找，此外也比较占用内存。 字典特性 字典特性如下： 字典是一个可变的容器类型 字典内部由散列表组成 字典的单点读写速度很快，但是不支持范围查找 字典的key必须是不可变的，只有不可变对象才能被hash 字典在3.6之后变得有序了，这样做提升了遍历效率 基本声明 以下是使用类实例化的形式进行对象声明： userInfo = dict(name=\"YunYa\", age=18, hobby=[\"football, music\"]) print(\"value : %r\\ntype : %r\" % (userInfo, type(userInfo))) # value : {'name': 'YunYa', 'age': 18, 'hobby': ['football, music']} # type : 也可以选择使用更方便的字面量形式进行对象声明，使用{}对键值对进行包裹，键值对采用k:v的形式分割，多个键值对之间使用逗号进行分割： userInfo = {\"name\": \"YunYa\", \"age\": 18, \"hobby\": [\"football, music\"]} print(\"value : %r\\ntype : %r\" % (userInfo, type(userInfo))) # value : {'name': 'YunYa', 'age': 18, 'hobby': ['football, music']} # type : 声明字典时，千万注意key只能是不可变类型。 如字符串（str），整形（int），浮点型（float），布尔型（bool），元组类型（tuple）等等均可设置为字典的key，但使用可变类型作为key时则会抛出异常。 续行操作 在Python中，字典中的键值对如果过多，可能会导致整个字典太长，太长的字典是不符合PEP8规范的。 每行最大的字符数不可超过79，文档字符或者注释每行不可超过72 Python虽然提供了续行符\\，但是在字典中可以忽略续行符，如下所示： userInfo = { \"name\": \"YunYa\", \"age\": 18, \"hobby\": [\"football, music\"]} print(\"value : %r\\ntype : %r\" % (userInfo, type(userInfo))) # value : {'name': 'YunYa', 'age': 18, 'hobby': ['football, music']} # type : 多维嵌套 字典中可以进行多维嵌套，如字典套字典，字典套元组，字典套列表等： dic = { \"k1\": [1, 2, 3], \"k2\": (1, 2, 3), \"k3\": { \"k3-1\": 1, \"k3-2\": 2, }, } 类型转换 字典可以与布尔类型和字符串进行转换，这是最常用的： dic = {\"k1\": \"v1\", \"k2\": \"v2\"} boolDict = bool(dic) strDict = str(dic) print(\"value : %r\\ntype : %r\" % (boolDict, type(boolDict))) print(\"value : %r\\ntype : %r\" % (strDict, type(strDict))) # value : True # type : # value : \"{'k1': 'v1', 'k2': 'v2'}\" # type : 如果要将字典转换为列表、元组、集合类型，直接转换只会拿到键，并不会拿到值。 尤其注意这一点，但是其实这样用的场景十分少见，记住就行了： dic = {\"k1\": \"v1\", \"k2\": \"v2\"} listDict = list(dic) tupleDict = tuple(dic) setDict = set(dic) print(\"value : %r\\ntype : %r\" % (listDict, type(listDict))) print(\"value : %r\\ntype : %r\" % (tupleDict, type(tupleDict))) print(\"value : %r\\ntype : %r\" % (setDict, type(setDict))) # value : ['k1', 'k2'] # type : # value : ('k1', 'k2') # type : # value : {'k1', 'k2'} # type : 重复key 一个字典中的key必须是唯一的，若不是唯一的则value可能面临被覆盖的危险： dic = {\"name\": \"云崖\", \"age\": 18, \"name\": \"Yunya\"} print(dic) # {'name': 'Yunya', 'age': 18} 同理，True和1，False和0也会彼此进行覆盖： dic = {True: \"云崖\", \"age\": 18, 1: \"Yunya\"} print(dic) # {True: 'Yunya', 'age': 18} []操作字典 由于字典并非线性结构，故不支持索引操作。 但是字典也提供了[]操作语法，它是根据key来操作value的。 增删改查 以下示例展示了如何使用[]对字典中的value进行操纵： dic = {\"k1\": \"v1\", \"k2\": \"v2\"} # 增 dic[\"k3\"] = \"v3\" print(dic) # {'k1': 'v1', 'k2': 'v2', 'k3': 'v3'} # 删，如果没有该key，则抛出keyError del dic[\"k2\"] print(dic) # {'k1': 'v1', 'k3': 'v3'} # 改，如果没有该key，则抛出keyError dic[\"k3\"] = \"VV3\" print(dic) # {'k1': 'v1', 'k3': 'VV3'} # 查，如果没有该key，则抛出keyError result = dic[\"k1\"] print(result) # v1 多维操作 字典套列表的多维操作如下，首先需要拿到该列表： dic = {\"k1\": [1, 2, 3, 4]} # 取出3 result = dic[\"k1\"][2] print(result) # 3 # k1的列表，添加数据项 \"A\" dic[\"k1\"].append(\"A\") print(dic) # {'k1': [1, 2, 3, 4, 'A']} 字典套字典的多维操作如下，首先需要拿到被操纵的字典： dic = { \"k1\":{ \"k1-1\":{ \"k1-2\":{ \"k1-3\":\"HELLO,WORLD\", } } } } # 拿到 k1-3 对应的value result = dic[\"k1\"][\"k1-1\"][\"k1-2\"][\"k1-3\"] print(result) # HELLO,WORLD 解构语法 **语法 **语法用于将字典中的k:v全部提取出来。 我们可以利用该语法的特性来对字典进行合并，将两个旧字典合并成一个新字典： dic_1 = {\"d1k1\": \"A\", \"d1k2\": \"B\"} dic_2 = {\"d2k1\": \"C\", \"d2k2\": \"D\"} result = {**dic_1, **dic_2} print(result) # {'d1k1': 'A', 'd1k2': 'B', 'd2k1': 'C', 'd2k2': 'D'} 解构赋值 字典支持平行变量赋值操作吗？当然可以！但是这样只会拿到字典的key： dic = {\"k1\": \"v1\", \"k2\": \"v2\"} first, last = dic print(first) print(last) # k1 # k2 有办法拿到value么？借助字典的values()方法即可做到，它的本质是将value全部提取出来，组成一个可迭代对象： dic = {\"k1\": \"v1\", \"k2\": \"v2\"} first, last = dic.values() print(first) print(last) # v1 # v2 你可以理解为，将value全部提取出来组成一个列表，类似于[“v1”, “v2”]，在Python2中的确是这样，但是到了Python3中做法改变了，目前按下不表。 对于一些不想要的数据项，你也可以按照列表的解构赋值操作来进行，这里不再举例。 常用方法 方法一览 常用的dict方法一览： 方法名 返回值 描述 get() v or None 取字典key对应的value，如果key不存在返回None setdefault() v 获取字典key对应的value，如该字典中不存在被获取的key则会进行新增k:v，并返回v update() None 对原有的字典进行更新 pop() v 删除该字典中的键值对，如果不填入参数key或者key不存在则抛出异常 keys() Iterable 返回一个可迭代对象，该可迭代对象中只存有字典的所有key values() Iterable 返回一个可迭代对象，该可迭代对象中只存有字典的所有value items() Iterable 返回一个可迭代对象，该可迭代对象中存有字典中所有的key与value，类似于列表套元组 clear() None 清空当前字典 基础公用函数： 函数名 返回值 描述 len() integer 返回容器中的项目数 获取长度 使用len()方法来进行字典长度的获取。 返回int类型的值。 dic = {\"name\": \"云崖\", \"age\": 18} print(len(dic)) # 2 一组键值对被视为一个数据项，故2组键值对长度为2 Python在对内置的数据类型使用len()方法时，实际上是会直接的从PyVarObject结构体中获取ob_size属性，这是一种非常高效的策略。 PyVarObject是表示内存中长度可变的内置对象的C语言结构体。 直接读取这个值比调用一个方法要快很多。 get() 使用get()方法获取字典key对应的value，相比于[]操作更加的人性化，因为[]一旦获取不存在的key则会抛出异常，而该方法则是返回None。 dic = {\"name\": \"云崖\", \"age\": 18} username = dic.get(\"name\") userhobby = dic.get(\"hobby\") print(\"用户姓名:\",username) print(\"用户爱好:\",userhobby) # 用户姓名: 云崖 # 用户爱好: None setdefault() 使用setdefault()方法来获取字典key对应的value，如该字典中不存在被获取的key则会进行新增k:v，并返回v。 返回字典原有的value或者新设置的k:v。 dic = {\"name\": \"云崖\", \"age\": 18} # 字典有name，则取字典里的name username = dic.setdefault(\"name\",\"云崖先生\") # 字典没有hobby，则设置hobby的value为足球与篮球并返回 userhobby = dic.setdefault(\"hobby\",\"足球与篮球\") print(\"用户姓名:\",username) print(\"用户爱好:\",userhobby) # 用户姓名: 云崖 # 用户爱好: 足球与篮球 update() 使用update()方法对原有的字典进行更新。 返回None。 dic = {\"name\": \"云崖\", \"age\": 18} dic.update( {\"hobby\": [\"篮球\", \"足球\"]} ) print(dic) # {'name': '云崖', 'age': 18, 'hobby': ['篮球', '足球']} pop() 使用pop()方法删除该字典中的键值对，如果不填入参数key或者key不存在则抛出异常。 返回被删除的value。 dic = {\"name\": \"云崖\", \"age\": 18} result = dic.pop(\"age\") print(result) print(dic) # 18 # {'name': '云崖'} keys() 返回一个可迭代对象，该可迭代对象中只存有字典的所有key。 Python2中返回的是列表，Python3中返回的是可迭代对象。 dic = {\"name\": \"云崖\", \"age\": 18} key_iter = dic.keys() print(key_iter) # dict_keys(['name', 'age']) Python3中返回的对象被称为字典视图。它们提供了字典条目的一个动态视图，这意味着当字典改变时，视图也会相应改变。 values() 返回一个可迭代对象，该可迭代对象中只存有字典的所有value。 Python2中返回的是列表，Python3中返回的是可迭代对象。 dic = {\"name\": \"云崖\", \"age\": 18} value_iter = dic.values() print(value_iter) # dict_values(['云崖', 18]) Python3中返回的对象被称为字典视图。它们提供了字典条目的一个动态视图，这意味着当字典改变时，视图也会相应改变。 items() 返回一个可迭代对象，该可迭代对象中存有字典中所有的key与value，类似于列表套元组。 Python2中返回的是二维列表，Python3中返回的是可迭代对象。 dic = {\"name\": \"云崖\", \"age\": 18} items_iter = dic.items() print(items_iter) # dict_items([('name', '云崖'), ('age', 18)]) Python3中返回的对象被称为字典视图。它们提供了字典条目的一个动态视图，这意味着当字典改变时，视图也会相应改变。 clear() 清空当前字典。 返回None。 dic = {\"name\": \"云崖\", \"age\": 18} dic.clear() print(dic) # {} 其他方法 方法 返回值 描述 popitem() (k, v) 随机删除一组键值对,并将删除的键值放到元组内返回 fromkeys(iter,value) dict 第一个参数是可迭代对象，其中每一个数据项都为新生成字典的key，第二个参数为同一的value值 示例演示： dic1 = dict(k1=\"v1\", k2=\"v2\", k3=\"v3\", k4=\"v4\") print(dic1.popitem()) # ('k4', 'v4') dic2 = dict.fromkeys([1, 2, 3, 4], None) print(dic2) # {1: None, 2: None, 3: None, 4: None} 底层探究 高效查找 为什么要有字典这种数据结构？ 如果对一个无序的列表查找其中某一个value（前提是不能对列表进行排序），必须经过一个一个的遍历，速度会很慢。 [3, 2, 8, 9, 11, 13] # 如果要获取数据项11，必须经过5次查找 有没有一种办法，能够让速度加快？ 为了不违背不能排序的前提，我们只能在列表存入value的时候做文章。 我们可以为每个value都造一个独一无二的身份标识，根据这个身份标识符计算出value需要插入到列表的索引位置。 在取的时候同理，通过身份标识符直接就可以拿到value所在列表的索引值，无疑速度会快很多。 一个小总结： 有一个身份标识，身份标识必须是唯一的 提供一个根据身份标识计算出插入位置的算法 回到字典的本质，字典的key就是value的身份标识，而根据key计算出插入位置的算法被封装在了hash()函数中，这个算法也被称之为hash算法。 为什么key必须是唯一的，参照下面这个示例： [\"k1\", \"k2\", \"k3\", \"k4\", \"k5\", \"k6\"] ↓ ↓ ↓ ↓ ↓ ↓ [ 3, 2, 8, 9, 11, 13] 假如k5变成了k6，那么就有2个k6对应2个不同的value 这么做的后果就是，使用k6获取value的时候，根本不知道你需要的value是哪一个 所以，干脆Python规定，key必须是不可变类型！如果有重复则新的覆盖旧的。 或者说，只有不可变对象才能被hash。 hash过程 如何通过hash()函数，确定value的插入位置？ 实际上每个键值对在存入字典之前，都会通过hash()函数对key计算出一个hash值（也被称为散列值）： >>> hash(\"k1\") 7036545863130266253 而字典的底层结构是由一个2维数组嵌套组成的，也被称为散列表、hash表。 如下所示，每次创建字典的时候，字典都会初始化生成一个固定长度且内容全是空的2维数组，Python内部生成的散列表长度为8（可参见dictobject.c结构体源码）： [ ① ② ③ [空, 空, 空], index: 0 [空, 空, 空], index: 1 [空, 空, 空], index: 2 [空, 空, 空], index: 3 [空, 空, 空], index: 4 [空, 空, 空], index: 5 [空, 空, 空], index: 6 [空, 空, 空] index: 7 ] ❶：存放根据key计算出的hash值 ❷：存放key的引用 ❸：存放value的引用 现在，我们要存储name:yunya的键值对，对name计算hash值： >>> hash(\"name\") 3181345887314224636 用计算出的hash值与散列表长度进行求余运算： >>> 3181345887314224636 % 8 4 得到结果是4，就在散列表4的索引位置插入： [ ① ② ③ [空, 空, 空], index: 0 [空, 空, 空], index: 1 [空, 空, 空], index: 2 [空, 空, 空], index: 3 [3181345887314224636, \"name\"的引用, \"yunya\"], index: 4 [空, 空, 空], index: 5 [空, 空, 空], index: 6 [空, 空, 空] index: 7 ] 再次插入age:18，并用计算出的hash值与散列表长度进行求余运算: >>> hash(\"age\") 7064862892218627464 >>> 7064862892218627464 % 8 0 得到的结果是0，就在散列表0的索引位置插入： [ ① ② ③ [7064862892218627464, \"age\"的引用, 18], index: 0 [空, 空, 空], index: 1 [空, 空, 空], index: 2 [空, 空, 空], index: 3 [3181345887314224636, \"name\"的引用, \"yunya\"], index: 4 [空, 空, 空], index: 5 [空, 空, 空], index: 6 [空, 空, 空] index: 7 ] 可以看见，这个2维数组不是按照顺序进行插入的，总有一些空的位置存在，因此该数组也被称为稀松数组。 由于数组是稀松的，所以dict不支持范围获取（能获取到空值），但单点存取的速度很快。 读取的时候也同理，但是Python的hash函数底层实现是否真的利用hash值对稀松数组长度进行简单的求余运算，这个还有待商榷。 因为hash算法的实现有很多种，长度求余只是最为简单的一种而已，这里用作举例，如果想具体了解其算法可以查看Python源码，dictobject.c中的perturb。 散列冲突 现在，我们的这个散列表中0和4的索引位置都已经存在数据了。 如果现在存入一个teacher:wang，那么结果会是怎么样？ >>> hash(\"teacher\") 4789346189807557228 >>> 4789346189807557228 % 8 4 可以发现，teacher的hash值求余算结果也是4，这个时候就会发生散列冲突。 最常见的做法是，向后挪！因为索引5的位置是空的，我们可以将这个键值对插入到索引5的位置： [ ① ② ③ [7064862892218627464, \"age\"的引用, 18], index: 0 [空, 空, 空], index: 1 [空, 空, 空], index: 2 [空, 空, 空], index: 3 [3181345887314224636, \"name\"的引用, \"yunya\"], index: 4 [4789346189807557228, \"teacher\"的引用, \"wang\"], index: 5 [空, 空, 空], index: 6 [空, 空, 空] index: 7 ] 这种查找空位的方法叫做开放定址法（openaddressing），向后查找也被称为线性探测（linearprobing）。 如果此时又插入一个数据项，最后key的插入索引位置也是4，则继续向后查找空位，如果查找到7还是没有空位，又从0开始找。 上述方法是解决散列冲突的基础方案，当然也还有更多的其他解决方案，这里再说就过头了，放在后面数构一章中再进行介绍吧。 扩容机制 Python的dict会对散列表的容量做出判定。 当容量超过三分之二时，即进行扩容（resize）机制。 如果散列表大小为8，在即将插入第5个键值对时进行扩容，扩容策略为已有散列表键值对个数 * 2。 即散列表大小扩展为12。 如果整个散列表已有键值对个数达到了50000，则扩容策略为已有散列表键值对个数 * 4。 此外，dict只会进行扩容，不会进行缩容，如果删除了1个键值对，其内存空间占用的位置并不会释放。 不同key的优化 整形是其本身 整形的hash值是其本身： >>> hash(1) 1 >>> hash(2) 2 >>> hash(3) 3 >>> hash(10000) 10000 加盐策略 在Python3.3开始，str、bytes、datetime等对象在计算散列值的时候会进行加盐处理。 这个盐引用内部的一个常量，该常量在每次CPython启动时会生成不同的盐值。 所以你会发现每次重启Python3.3以后的解释器，对相同字符串进行hash()求散列值得出的结果总是不一样的： $ python3 Python 3.6.8 (v3.6.8:3c6b436a57, Dec 24 2018, 02:04:31) [GCC 4.2.1 Compatible Apple LLVM 6.0 (clang-600.0.57)] on darwin Type \"help\", \"copyright\", \"credits\" or \"license\" for more information. >>> hash(\"k1\") 8214688532022610754 >>> exit() $ python3 Python 3.6.8 (v3.6.8:3c6b436a57, Dec 24 2018, 02:04:31) [GCC 4.2.1 Compatible Apple LLVM 6.0 (clang-600.0.57)] on darwin Type \"help\", \"copyright\", \"credits\" or \"license\" for more information. >>> hash(\"k1\") -7444020267993088839 >>> exit() 再看Python2.7，由于没有加盐策略，所以每次重启Python解释器后相同key得到的hash结果是相同的： $ python Python 2.7.10 (default, Feb 22 2019, 21:55:15) [GCC 4.2.1 Compatible Apple LLVM 10.0.1 (clang-1001.0.37.14)] on darwin Type \"help\", \"copyright\", \"credits\" or \"license\" for more information. >>> hash(\"k1\") 13696082283123634 >>> exit() $ python Python 2.7.10 (default, Feb 22 2019, 21:55:15) [GCC 4.2.1 Compatible Apple LLVM 10.0.1 (clang-1001.0.37.14)] on darwin Type \"help\", \"copyright\", \"credits\" or \"license\" for more information. >>> hash(\"k1\") 13696082283123634 >>> exit() 有序字典 字典无序的观念似乎已经深入人心，但那已经都是过去式了。 在Python3.6之后，字典变的有序了。 2012年12月10日星期一的时候，R. David Murray向Python官方发送了一封邮件，提出建议让Python的字典变的有序。 这样的做法能够让Python字典的空间占用量更小，迭代速度更快，以下是邮件内容： https://mail.python.org/pipermail/python-dev/2012-December/123028.html 我们先看看2.7中的字典： >>> {chr(i) : i for i in range(10)} {'\\x01': 1, '\\x00': 0, '\\x03': 3, '\\x02': 2, '\\x05': 5, '\\x04': 4, '\\x07': 7, '\\x06': 6, '\\t': 9, '\\x08': 8} 再来看3.6中的字典： >>> {chr(i) : i for i in range(10)} {'\\x00': 0, '\\x01': 1, '\\x02': 2, '\\x03': 3, '\\x04': 4, '\\x05': 5, '\\x06': 6, '\\x07': 7, '\\x08': 8, '\\t': 9} 果然！它确实变的有序了，关于具体细节，可以参照这封邮件，已经表述的很清楚了，下面做一个简单的示例。 首先，以前的散列表就是一个单纯的稀松二维数组： [ [空, 空, 空], index: 0 [空, 空, 空], index: 1 [空, 空, 空], index: 2 ... ] 键值对的读取顺序来源与填加顺序。 索引靠前的会被先遍历拿到，索引靠后只能后被遍历出来。 如果这个散列表长度为8，前7个都没有数据项存入，仅有8才有，那么遍历完整个散列表需要8次： [ [空, 空, 空], index: 0 [空, 空, 空], index: 1 [空, 空, 空], index: 2 ... [hash值, key的引用, value的引用], index: 7 ] 而Python3.6之后，又新增了一个顺序数组，该数组与散列表的长度相等，初始均为8，并且会跟随散列表的扩容而进行扩容，如下示例初始状态： [None, None, None, ...] [ [空, 空, 空], index: 0 [空, 空, 空], index: 1 [空, 空, 空], index: 2 ... ] 如果说第1个键值对，被插入到散列表索引1的位置，那么在顺序数组中，则在索引0处记录下该键值对被插入在散列表中的位置(1)，如下图所示： [1, None, None, ...] [ [空, 空, 空], index: 0 [hash值, key的引用, value的引用], index: 1 [空, 空, 空], index: 2 ... ] 如果第2个键值对，被插入到散列表索引0的位置，那么在顺序数组中，则在索引1处记录下该键值对被插入在散列表中的位置(0)，如下图所示： [1, 0, None, ...] [ [hash值, key的引用, value的引用], index: 0 [hash值, key的引用, value的引用], index: 1 [空, 空, 空], index: 2 ... ] 再插入一个键值对，该键值对被插到了索引7的位置，那么在顺序数组中，则在索引2处记录下该键值对被插入在散列表中的位置(7)，如下图所示： [1, 0, 7, None, None, None, None, None] [ [hash值, key的引用, value的引用], index: 0 [hash值, key的引用, value的引用], index: 1 [空, 空, 空], index: 2 ... [hash值, key的引用, value的引用], index: 7 ] 在遍历的时候，会遍历这个顺序数组，然后通过索引值拿到散列表中对应位置的数据项，如果遍历到的值为None就结束遍历，而不用遍历完整个散列表： 类似于： hashTableOrderArray = [1, 0, 7, None, None, None, None, None] hashTable = [ [\"hash\", \"k2\", \"v2\"], [\"hash\", \"k1\", \"v1\"], [None, None, None], [None, None, None], [None, None, None], [None, None, None], [None, None, None], [\"hash\", \"k3\", \"v3\"], ] n = 0 while n 这样只需遍历3次即可，而如果没有这个顺序数组，则要完整遍历整个散列表，即8次才能拿出所有的键值对。 dictobject.c源码 官网参考：点我跳转 源码一览：点我跳转 关于字典的源码阅读，感兴趣的朋友可以看一下，这里不再进行延伸阅读。 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-10 10:44:15 "},"Python/Python基础知识/集合类型.html":{"url":"Python/Python基础知识/集合类型.html","title":"集合类型","keywords":"","body":"集合 Python中的集合（set）内部存储也采用hash存储，所以说它也可以归类为映射容器类型之中。 集合与字典有很多类似之处，你可以将集合理解为没有value的字典（仅有key）。 集合本身是可变的数据类型，但是其内部数据项必须是不可变的，能被hash()的对象，这与字典的key特性相同。 集合特性 集合特性如下： 集合是一个可变的容器类型 集合中的数据项必须是不可变类型 集合更多的是用来操纵数据，而不是存储数据 嗯，再说一个冷门知识点，集合的速度比字典的存读速度更快！因为它的数据项仅有1部分，而字典的数据项拥有2部分，即key与value。 基本声明 以下是使用类实例化的形式进行对象声明： s = set((1, 2, 3, 4, 5)) print(\"value : %r\\ntype : %r\" % (s, type(s))) # value : {1, 2, 3, 4, 5} # type : 也可以选择使用更方便的字面量形式进行对象声明，使用{}对数据项进行包裹，每个数据项间用逗号进行分割： s = {1, 2, 3, 4, 5} print(\"value : %r\\ntype : %r\" % (s, type(s))) # value : {1, 2, 3, 4, 5} # type : 注意一个集合声明的陷阱，如果要声明一个空集合必须使用类实例的形式进行声明。 如果用一个空的{}进行字面量声明会生成一个字典。 声明集合时，千万注意数据项只能是不可变类型。 如字符串（str），整形（int），浮点型（float），布尔型（bool），元组类型（tuple）等等，使用可变类型作为数据项加入至集合中会抛出TypeError异常。 续行操作 在Python中，集合中的数据项如果过多，可能会导致整个集合太长，太长的集合是不符合PEP8规范的。 每行最大的字符数不可超过79，文档字符或者注释每行不可超过72 Python虽然提供了续行符\\，但是在集合中可以忽略续行符，如下所示： s = { 1, 2, 3, 4, 5 } print(\"value : %r\\ntype : %r\" % (s, type(s))) # value : {1, 2, 3, 4, 5} # type : 类型转换 集合可以和布尔型、列表、元组、字符串类型进行转换： s = {1, 2, 3, 4, 5} boolSet = bool(s) strSet = str(s) listSet = list(s) tupleSet = tuple(s) print(\"value : %r\\ntype : %r\" % (boolSet, type(boolSet))) print(\"value : %r\\ntype : %r\" % (strSet, type(strSet))) print(\"value : %r\\ntype : %r\" % (listSet, type(listSet))) print(\"value : %r\\ntype : %r\" % (tupleSet, type(tupleSet))) # value : True # type : # value : '{1, 2, 3, 4, 5}' # type : # value : [1, 2, 3, 4, 5] # type : # value : (1, 2, 3, 4, 5) # type : 无序特性 Python本身并未对集合新增顺序数组，因此集合不论是Python3还是Python2中都是无序的。 Python2.7.10示例： >>> {chr(i) for i in range(10)} set(['\\x01', '\\x00', '\\x03', '\\x02', '\\x05', '\\x04', '\\x07', '\\x06', '\\t', '\\x08']) Python3.6.8示例： >>> {chr(i) for i in range(10)} {'\\x07', '\\x06', '\\t', '\\x02', '\\x00', '\\x05', '\\x04', '\\x03', '\\x01', '\\x08'} 去重特性 得益于内部hash存储方式，集合具有去处重复的特性，我们可以让其与列表结合，将列表中重复的数据项剔除： repeatList = [1, 1, 2, 2, 3, 4, 5, 1, 2] newList = list(set(repeatList)) print(newList) # [1, 2, 3, 4, 5] 集合中的数据项怎么拿出来 集合虽然是容器类型，但是更多的作用是操作数据项，存储非它所长（存了就不好取了）。 集合没有提供[]语法： 它没有key，无法像字典一样通过key来操作value 也没有index，因为它不是顺序存储的线性结构。 虽然set中没有提供单拿数据项的方法，但是我们可以将其转换为list后再通过index将某个数据项拿出来。 或者是通过遍历。 常用方法 常用的set方法一览，set有一部分方法可以进行符号操作： 方法名 符号表示 返回值 描述 add() 无 None 为集合中新增数据项 pop() 无 Data item 弹出随机数据项 remove() 无 None 删除指定数据项，若不存在则抛出异常 discard() 无 None 同上、但不存在不会抛出异常 clear() 无 None 清空集合 copy() 无 set 对集合进行浅拷贝 update() 无 None 原地更新集合 intersection() & set 求a集合与b集合的交集 difference() - set 求a集合与b集合的差集 union() set 求a集合与b集合的合集/并集 symmetric_difference() ^ set 求a集合与b集合的对称差集 issuperset() >或者>= bool 判定a集合是否为b集合的父级 issubset() bool 判断a集合是否为b集合的子集 isdisjoint() 无 bool 判断两个集合是否完全独立没有共同部分返回 intersection_update() 无 None 求出a集合与b集合的交集后并更新a集合 difference_update() 无 None 求出a集合与b集合的差集后并更新a集合 基础公用函数： 函数名 返回值 描述 len() integer 返回容器中的项目数 数据管理 示例演示： s1 = set() # 增加数据项 s1.add(1) print(s1) # {1} # 更新数据项 s1.update({2, 3, 4, 5}) print(s1) # {1, 2, 3, 4, 5} # 删除数据项， 不存在则抛出异常 s1.remove(2) print(s1) # {1, 3, 4, 5} # 删除数据项， 即使不存在也不会抛出异常 s1.discard(2) print(s1) # {1, 3, 4, 5} # 随机弹出数据项 print(s1.pop()) # 1 print(s1) # {3, 4, 5} # 浅拷贝 print(s1.copy()) # {3, 4, 5} # 清空数据项 s1.clear() print(s1) # set() 关系图解 集合关系图示： 关系获取 示例演示： s1 = {1, 2, 3, 4, 5} s2 = {4, 5, 6, 7, 8} # 交集 print(s1 & s2) print(set.intersection(s1, s2)) # {4, 5} # 差集 print(s1 - s2) print(set.difference(s1, s2)) # {1, 2, 3} # 合集、并集 print(s1 | s2) print(set.union(s1, s2)) # {1, 2, 3, 4, 5, 6, 7, 8} # 对称差集 print(s1 ^ s2) print(set.symmetric_difference(s1, s2)) # {1, 2, 3, 6, 7, 8} # 父子集 s3 = {1, 2, 3} s4 = {1,2} # 父级 print(s3 > s4) print(s3 >= s4) print(set.issuperset(s3, s4)) # True # 子集 print(s4 不可变的集合 frozenset()创建的集合拥有元组的特性，一旦集合创建完成后将不可以修改。 fs = frozenset((1, 2, 3)) print(fs) # frozenset({1, 2, 3}) 可以与普通的set集合进行关系获取，但是不能够进行数据项管理（可以copy，copy也是绝对引用）。 2.3以前怎么办 Python2.3的set和frozenset首次以模块的形式加入到Python中。 并且在Python2.6之后，提升为内置模块。 在Python2.3以前，我们常用字典来进行与集合相同的操作，因为字典的key也具有去重的特性嘛！ repeatList = [1, 1, 2, 2, 3, 4, 5, 1, 2] newList = list(dict.fromkeys(repeatList, None).keys()) print(newList) # [1, 2, 3, 4, 5] 如果是求交叉并集这种关系，则实现会更加复杂一点，这里不再举例。 dictobject.c源码 官网参考：点我跳转 源码一览：点我跳转 关于集合的源码阅读，感兴趣的朋友可以看一下，这里不再进行延伸阅读。 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-10 10:48:33 "},"Python/Python基础知识/布尔类型.html":{"url":"Python/Python基础知识/布尔类型.html","title":"布尔类型","keywords":"","body":"布尔类型 布尔类型的值被称为布尔值，常用于分支流程中，仅有2种表现形式： True：代表条件为真 False：代表条件为假 布尔属于不可变类型，同时也是基础的原子类型，即不可分割，不能容纳其他对象。 基本声明 以下是使用类实例化的形式进行对象声明： term = bool(True) print(\"value : %r\\ntype : %r\" % (term, type(term))) # value : True # type : 也可以选择使用更方便的字面量形式进行对象声明： term = True print(\"value : %r\\ntype : %r\" % (term, type(term))) # value : True # type : 类型转换 布尔值仅能转换为数字、字符串，使用对应的工厂函数即可： termTrue = True termFalse = False iTrue = int(termTrue) iFalse = int(termFalse) fTrue = float(termTrue) fFalse = float(termFalse) sTrue = str(termTrue) sFalse = str(termFalse) print(\"value : %r\\ntype : %r\" % (iTrue, type(iTrue))) print(\"value : %r\\ntype : %r\" % (iFalse, type(iFalse))) print(\"value : %r\\ntype : %r\" % (fTrue, type(fTrue))) print(\"value : %r\\ntype : %r\" % (fFalse, type(fFalse))) print(\"value : %r\\ntype : %r\" % (sTrue, type(sTrue))) print(\"value : %r\\ntype : %r\" % (sFalse, type(sFalse))) # value : 1 # type : # value : 0 # type : # value : 1.0 # type : # value : 0.0 # type : # value : 'True' # type : # value : 'False' # type : 除此之外，使用bool()将任意类型对象包裹均能获得其布尔值的表现形式。 以下举例Python内置数据类型在不同状态下的布尔值表示： 类型 True False int&float 不为0 为0 str&bytes 不为空串 为空串 list&tuple 不为空序列 为空序列 dict&set 不为空映射 为空映射 示例如下： >>> # --- int & float --- >>> bool(0) False >>> bool(1) True >>> bool(-1) True >>> bool(0.1) True >>> bool(-0.1) True >>> # --- str & bytes --- >>> bool(\"\") False >>> bool(b\"\") False >>> bool(\"string\") True >>> bool(b\"bytes\") True >>> # --- list & tuple --- >>> bool(list()) False >>> bool(tuple()) False >>> bool(list((1, 2, 3))) True >>> bool(tuple((1, 2, 3))) True >>> # --- dict & set --- >>> bool(dict()) False >>> bool(set()) False >>> bool(dict(k1=\"v1\", k2=\"v2\")) True >>> bool(set((\"ele1\", \"ele2\"))) True 布尔常量池 True和False是会被经常使用到的，因此在Python解释器启动时就会进行创建，我将他两归类为布尔常量池中（实际上并不存在）。 与小整数常量池中的数字类似，即使经历不同的实例化过程，但每次得到的True和False都来自同一引用： >>> id(True) 4495471488 >>> id(False) 4495471456 >>> id(bool(1)) 4495471488 >>> id(bool(0)) 4495471456 True&False与1&0 布尔值参与四则运算的时候，True等价于1，False等价于0： >>> True + 1 2 >>> False + 1 1 >>> True - False 1 实际上，True和False当采用运算时将会从小整数池中取出1和0，但是若使用id()方法查看True和1的地址号，会发现是不同的： >>> id(True) 4495471488 >>> id(1) 4495853616 为什么会出现这种情况？其实点开bool类型的源代码就可以发现，在Python3中bool类继承至int类： class bool(int): 当传入一个任意类型构建bool类的实例对象时，通过内部一系列判定都会返回True或者False这种形式。 若要将布尔类型直接参与运算（四则运算、hash运算），则会通过内部某种特殊的机制拿到1或者0。 id()方法返回的是对象的地址号，而bool的实例对象和int的实例对象必定在堆区内存中由不同的位置进行存储，故它们的结果不一样。 而运算时，布尔类型会去小整数池中拿到对应的整型值来参与运算，故True和1的hash运算的结果都是相同的。 如下图所示： 绝对引用 布尔类型拥有绝对引用的特性，则无论是深拷贝还是浅拷贝，都不会获得其副本，而是直接对源对象进行引用： >>> import copy >>> oldBool = True >>> id(oldBool) 4369122176 >>> b1 = copy.copy(oldBool) >>> id(b1) 4369122176 >>> b2 = copy.deepcopy(oldBool) >>> id(b2) 4369122176 boolobject.c源码 官网参考：点我跳转 源码一览：点我跳转 现有的名称 Py_False 和 Py_True 引用独一无二的布尔对象 False 和 True （之前，它们分别引用了值为 0 和 1 的静态整数对象，是众多整数之一）。 一个新的 API，即PyObject *PyBool_FromLong(long) ，会接收一个 C长整型参数，并返回对 Py_False （当参数为零时）或 Py_True （当非零时）的新引用。 要检查对象是否为布尔对象，可以使用宏PyBool_Check()。 布尔实例的类型是 PyBoolObject*。 布尔类型对象可作为PyBool_Type使用。 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-09 13:10:49 "},"Python/Python基础知识/单例None.html":{"url":"Python/Python基础知识/单例None.html","title":"单例None","keywords":"","body":"None None是Python中经常出现的一种类型，但其实关于它的描述并不是很多，因此None也经常被人忽略。 None是一种不可变类型，同时也是基础的原子类型，即不可分割，不能容纳其他对象。 它常用于初始化数据，并且是函数默认的返回值。 基本声明 None的声明方式仅有字面量声明： empty = None print(\"value : %r\\ntype : %r\" % (empty, type(empty))) # value : None # type : NoneType与单例 尽管可以看到None的实例化类为NoneType，但是你可能无法直接找到NoneType： print(NoneType) # NameError: name 'NoneType' is not defined NoneType实现了单例模式，我们虽然无法直接拿到NoneType这个类，但是可以通过 __class__属性拿到。 以下实例化多个None，查看id()是否相同： NoneType = None.__class__ none1 = NoneType() none2 = NoneType() print(id(none1)) print(id(none2)) # 4377856088 # 4377856088 绝对引用 None类型也是绝对引用，无论是深拷贝还是浅拷贝，都不会获得其副本，而是直接对源对象进行引用： >>> import copy >>> oldNone = None >>> id(oldNone) 4369221720 >>> no1 = copy.copy(oldNone) >>> id(no1) 4369221720 >>> no2 = copy.deepcopy(oldNone) >>> id(no2) 4369221720 None的使用 None一般用于对一个变量进行初始化，可能我们还没想好这个变量存什么内容时可以用None先代替进行存入。 这种变量可称之为临时变量，即只在一定的场景下进行使用，而并不会常驻使用： temp = None Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-09 13:12:19 "},"Python/Python基础知识/内存管理.html":{"url":"Python/Python基础知识/内存管理.html","title":"内存管理","keywords":"","body":"Gc简介 Gc（garbage collection）中文直译为垃圾回收，是一种回收内存空间避免内存泄漏的机制。 我们在程序的运行中会产生大量的对象用于保存数据，而有时候有些对象已经没有用了就需要被清理释放掉该对象所占据的内存空间。 在一些较为低级的语言中对于内存空间的释放是需要编程人员来手动进行的，这种与底层硬件直接打交道的操作是十分的危险与繁琐的，而基于C语言开发而来的Python为了解决掉这种顾虑则自带了一种垃圾回收机制，从而让开发人员不必过分担心内存的使用情况而可以全身心的投入到开发中去。 引用计数 最简单的Gc机制，引用计数。 首先将堆区内存中的对象与栈区内存中标识符的绑定数量做一个计数。 示例如下： >>> a = \"Python\" >>> b = \"Python\" >>> c = \"Python\" 我们的图示按照标识符的引用次数为准，并忽略临时引用，下图中Python这个str对象的引用计数目前为3： 每次标识符与对象取消绑定关系，则计数-1，当计数减到0的时候将自动清理该对象。 示例如下： >>> del a >>> del b >>> del c 标记清除 循环引用 引用计数能够解决百分之九十的问题，但是有一种特殊的情况是引用计数处理不了的，即循环引用（也被称为交叉引用）。 什么是循环引用，举一个简单的例子就是列表的互相嵌套，如下所示，l1和l2的引用计数都为2（标识符+1次引用，两个列表的[-1]索引处+1次引用）： >>> l1 = [1,2,3] >>> l2 = [1,2,3,l1] >>> l1.append(l2) >>> l1 [1, 2, 3, [1, 2, 3, [...]]] >>> l2 [1, 2, 3, [1, 2, 3, [...]]] 接着往下看，我们取消标识符与对象的绑定关系： >>> del l1 >>> del l2 现在，由于2个列表对象的计数都为1，故引用计数的策略显得不好使了。 因为2个列表对象的引用计数都未清0： 解决方案 为了解决循环引用带来的内存泄露问题，出现了标记清除法。 标记清除的意思在于当应用程序可用内存空间即将被耗尽时便开始遍历栈区所有的标识符，并且会顺着栈区标识符对其引用的在堆区中的对象做一个标记。 如果堆区内存中存在没有与栈区标识符进行绑定的对象，该对象则会认为是无用的对象，将会被清理。 分代回收 基于引用计数的垃圾回收机制每一次执行清理操作前都会将整个堆区对象的引用计数做一次遍历统计。 这样做是非常消耗时间的，所以Python垃圾回收机制为了效率的提升加入了分代回收的策略。 即： 当多次扫描后，若该对象的引用计数一直不为0，且也没有被标记清除法所清理掉，则证明 该对象会被经常使用，因此降低该对象的扫描频率，以提升效率。 优秀文章推荐 其实Python内部的内存管理机制远不如此。 所以这里推荐一个知乎博主写的系列文章，感兴趣的朋友可以跳转后继续深入阅读，该博主对Python底层内存机制剖析的极为透彻，是不可多得的好文章： 点我跳转 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-05-14 18:24:54 "},"Python/Python基础知识/深浅拷贝.html":{"url":"Python/Python基础知识/深浅拷贝.html","title":"深浅拷贝","keywords":"","body":"拷贝 copy即拷贝，意在将相同的数据进行复制，以便将复制出的副本应用于不同的操作上，而本体不会受到任何影响。 绝大多数语言中都有深浅拷贝的概念，故此篇文章也是属于通用性文章。 在Python中，除开手动导入copy模块并使用deepcopy()函数的拷贝是深拷贝，其他的所有的拷贝操作都是浅拷贝。 在开始之前，介绍几个基本概念： 不可变类型：int、float、str、bool、None、tuple、frozenset 可变类型：list、dict、set（均是容器） 绝对引用：所有的不可变类型，都具有绝对引用的特性，即深浅拷贝都不会获得其副本，而是直接对源对象进行引用 赋值 赋值就是引用，代码如下： #!/usr/bin/env python3 # -*- coding:utf-8 -*- oldLi = [\"A\", [1, ], (1,)] newLi = oldLi if id(oldLi) == id(newLi): print(\"外部大容器：可变类型：list来自同一个引用\") else: print(\"外部大容器：可变类型：list来自不同的引用\") if id(oldLi[0] == id(newLi[0])): print(\"内部第1个元素：不可变类型：str来自同一个引用\") else: print(\"内部第1个元素：不可变类型：str来自不同的引用\") if id(oldLi[1]) == id(newLi[1]): print(\"内部第1个大容器：可变类型：list来自同一个引用\") else: print(\"内部第1个大容器：可变类型：list来自不同的引用\") if id(oldLi[1][0]) == id(newLi[1][0]): print(\"内部第1个大容器的数据项：不可变类型：int ：%r来自同一个引用\" % oldLi[1][0]) else: print(\"内部第1个大容器的数据项：不可变类型：int ：%r来自不同的引用\" % oldLi[1][0]) if id(oldLi[2]) == id(newLi[2]): print(\"内部第2个大容器：不可变类型：tuple来自同一个引用\") else: print(\"内部第2个大容器：不可变类型：tuple来自不同的引用\") if id(oldLi[2][0]) == id(newLi[2][0]): print(\"内部第2个大容器的数据项：不可变类型：int ：%r来自同一个引用\" % oldLi[2][0]) else: print(\"内部第2个大容器的数据项：不可变类型：int ：%r来自不同的引用\" % oldLi[2][0]) # 外部大容器：可变类型：list来自同一个引用 # 内部第1个元素：不可变类型：str来自同一个引用 # 内部第1个大容器：可变类型：list来自同一个引用 # 内部第1个大容器的数据项：不可变类型：int ：1来自同一个引用 # 内部第2个大容器：不可变类型：tuple来自同一个引用 # 内部第2个大容器的数据项：不可变类型：int ：1来自同一个引用 如图所示： 所有引用都相同，这代表着oldLi中任意一个数据项改变后，newLi中的数据项也会跟着发生改变： oldLi[0] = \"B\" print(\"oldLi -> index0:type=str -> %r\" % oldLi[0]) print(\"newLi -> index0:type=str -> %r\" % newLi[0]) oldLi[1][0] = 10 print(\"oldLi -> index1:type=list --> index0:type=int -> %r\" % oldLi[1][0]) print(\"newLi -> index1:type=list --> index0:type=int -> %r\" % newLi[1][0]) # oldLi -> index0:type=str -> 'B' # newLi -> index0:type=str -> 'B' # oldLi -> index1:type=list --> index0:type=int -> 10 # newLi -> index1:type=list --> index0:type=int -> 10 图示如下： 浅拷贝 被浅拷贝的对象如果是可变类型，则创建副本，如果是不可变类型，则是引用，浅拷贝仅拷贝1层。 代码如下： #!/usr/bin/env python3 # -*- coding:utf-8 -*- import copy oldLi = [\"A\", [1, ], (1,)] newLi = copy.copy(oldLi) if id(oldLi) == id(newLi): print(\"外部大容器：可变类型：list来自同一个引用\") else: print(\"外部大容器：可变类型：list来自不同的引用\") if id(oldLi[0] == id(newLi[0])): print(\"内部第1个元素：不可变类型：str来自同一个引用\") else: print(\"内部第1个元素：不可变类型：str来自不同的引用\") if id(oldLi[1]) == id(newLi[1]): print(\"内部第1个大容器：可变类型：list来自同一个引用\") else: print(\"内部第1个大容器：可变类型：list来自不同的引用\") if id(oldLi[1][0]) == id(newLi[1][0]): print(\"内部第1个大容器的数据项：不可变类型：int ：%r来自同一个引用\" % oldLi[1][0]) else: print(\"内部第1个大容器的数据项：不可变类型：int ：%r来自不同的引用\" % oldLi[1][0]) if id(oldLi[2]) == id(newLi[2]): print(\"内部第2个大容器：不可变类型：tuple来自同一个引用\") else: print(\"内部第2个大容器：不可变类型：tuple来自不同的引用\") if id(oldLi[2][0]) == id(newLi[2][0]): print(\"内部第2个大容器的数据项：不可变类型：int ：%r来自同一个引用\" % oldLi[2][0]) else: print(\"内部第2个大容器的数据项：不可变类型：int ：%r来自不同的引用\" % oldLi[2][0]) # 外部大容器：可变类型：list来自不同的引用 # 内部第1个元素：不可变类型：str来自同一个引用 # 内部第1个大容器：可变类型：list来自同一个引用 # 内部第1个大容器的数据项：不可变类型：int ：1来自同一个引用 # 内部第2个大容器：不可变类型：tuple来自同一个引用 # 内部第2个大容器的数据项：不可变类型：int ：1来自同一个引用 如图所示，浅拷贝为什么浅，因为只拷贝了一层： 如果修改oldLi第1层的index指向，newLi并不会受到影响，而如果修改oldLi第2层的index指向，则newLi会受到影响，如下所示： oldLi[0] = \"B\" print(\"oldLi -> index0:type=str -> %r\" % oldLi[0]) print(\"newLi -> index0:type=str -> %r\" % newLi[0]) oldLi[1][0] = 10 print(\"oldLi -> index1:type=list --> index0:type=int -> %r\" % oldLi[1][0]) print(\"newLi -> index1:type=list --> index0:type=int -> %r\" % newLi[1][0]) # oldLi -> index0:type=str -> 'B' # newLi -> index0:type=str -> 'A' # oldLi -> index1:type=list --> index0:type=int -> 10 # newLi -> index1:type=list --> index0:type=int -> 10 图示如下： 深拷贝 深拷贝是递归的拷贝，即在浅拷贝的基础上也会递归的判定其子数据项是否能被拷贝。 如果是可变类型则拷贝，如果是不可变类型则不拷贝，代码如下： #!/usr/bin/env python3 # -*- coding:utf-8 -*- import copy oldLi = [\"A\", [1, ], (1,)] newLi = copy.deepcopy(oldLi) if id(oldLi) == id(newLi): print(\"外部大容器：可变类型：list来自同一个引用\") else: print(\"外部大容器：可变类型：list来自不同的引用\") if id(oldLi[0] == id(newLi[0])): print(\"内部第1个元素：不可变类型：str来自同一个引用\") else: print(\"内部第1个元素：不可变类型：str来自不同的引用\") if id(oldLi[1]) == id(newLi[1]): print(\"内部第1个大容器：可变类型：list来自同一个引用\") else: print(\"内部第1个大容器：可变类型：list来自不同的引用\") if id(oldLi[1][0]) == id(newLi[1][0]): print(\"内部第1个大容器的数据项：不可变类型：int ：%r来自同一个引用\" % oldLi[1][0]) else: print(\"内部第1个大容器的数据项：不可变类型：int ：%r来自不同的引用\" % oldLi[1][0]) if id(oldLi[2]) == id(newLi[2]): print(\"内部第2个大容器：不可变类型：tuple来自同一个引用\") else: print(\"内部第2个大容器：不可变类型：tuple来自不同的引用\") if id(oldLi[2][0]) == id(newLi[2][0]): print(\"内部第2个大容器的数据项：不可变类型：int ：%r来自同一个引用\" % oldLi[2][0]) else: print(\"内部第2个大容器的数据项：不可变类型：int ：%r来自不同的引用\" % oldLi[2][0]) # 外部大容器：可变类型：list来自不同的引用 # 内部第1个元素：不可变类型：str来自同一个引用 # 内部第1个大容器：可变类型：list来自不同的引用 # 内部第1个大容器的数据项：不可变类型：int ：1来自同一个引用 # 内部第2个大容器：不可变类型：tuple来自同一个引用 # 内部第2个大容器的数据项：不可变类型：int ：1来自同一个引用 如图所示，深拷贝把能拷贝的，不是绝对引用的都拷贝了： 无论怎么修改oldLi，newLi都不会受到影响： oldLi[0] = \"B\" print(\"oldLi -> index0:type=str -> %r\" % oldLi[0]) print(\"newLi -> index0:type=str -> %r\" % newLi[0]) oldLi[1][0] = 10 print(\"oldLi -> index1:type=list --> index0:type=int -> %r\" % oldLi[1][0]) print(\"newLi -> index1:type=list --> index0:type=int -> %r\" % newLi[1][0]) # oldLi -> index0:type=str -> 'B' # newLi -> index0:type=str -> 'A' # oldLi -> index1:type=list --> index0:type=int -> 10 # newLi -> index1:type=list --> index0:type=int -> 1 图示如下： Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-05-14 18:28:25 "},"Python/Python基础知识/输入与输出.html":{"url":"Python/Python基础知识/输入与输出.html","title":"输入与输出","keywords":"","body":"输入与输出 输入（output）让计算机能够听懂人类的指令，输入（input）能够告诉人类程序目前的状态。 标准输出 print() 在Python3中，print()函数默认会将对象的表现形式输出至屏幕上： print(\"hello world\") # hello world 而在Python2中，print后面不必加括号，直接加上对象即可： print \"hello world\" 除此之外，print()函数还可以接收3个参数，分别是：sep、end、file sep参数 该参数用来显示逗号间隔中的链接字符，默认为一个空格： # 不指定sep参数 print(\"hello\", \"world\") # hello world # 指定sep参数 print(\"hello\", \"world\", sep=\"☺\") # hello☺world end参数 该参数用于指定当print()完成后所在行尾指定的字符，默认为\\n即换行符。 print(\"hello\", end=\"\\t\") print(\"world\") # hello world file参数 该参数默认内部为标准输出，即输出至用户屏幕，我们可以通过该参数来指定print()的内容写入到某个指定的文件句柄中： with open(\"testFile.txt\", mode=\"wt\", encoding=\"utf8\") as f: print(\"this line written in file\", file=f) 格式化输出 如果我们想将一个字符串与一个对象的表现形式相结合，可使用格式化输出。 % %格式化的历史悠久，很多码龄较长的程序员都喜欢用它进行格式化输出。 我们来看一个例子： name = \"YunYaSir\" age = 19 s1 = \"name : %s\\nage : %d\" % (name, age) # ❶ print(s1) # name : YunYaSir # age : 19 ❶：字符串中的%s、%d等都是占位符，占位符要和对象匹配，在进行格式化时%char会被对象的表现形式所代替。 常见的占位符如下表所示： 占位符 描述 %s 接收任意类型的值，以字符串形式显示 %r 接收任意类型的值，以r字符串形式显示 %c 只接收单个字符 %b 接收int类型的值，二进制整数形式显示 %d 接收int类型的值，十进制整数形式显示 %i 接收int类型的值，十进制整数形式显示 %o 接收int类型的值，八进制整数形式显示 %x 接收int类型的值，十六进制整数形式显示 %e 接收float类型的值，指数形式显示 (基底写为e) %E 接收float类型的值，指数形式显示 (基底写为E) %f 接收float类型的值，浮点数形式显示 %F 接收float类型的值，浮点数形式显示 %g 接收float类型的值，指数(e)或浮点数 (根据显示长度) %G 接收float类型的值，指数(E)或浮点数 (根据显示长度) %% 即打印1个百分号 位置传参 一个占位符对应一个对象，当对象与占位符有多个时便需要将%后面的对象跟上括号做出一个元组，如若只有一个则不需要加上括号，%后元组中的对象数量必须与占位符的数量一致，且位置要一一对应： name = \"YunYaSir\" age = 19 s1 = \"name : %s\\nage : %d\" % (name, age) # ❶ print(s1) # name : YunYaSir # age : 19 如上所示：%s对应name、%d对应age。 优点：便于维护 缺点：对象与占位符必须一一对应，数量必须保持一致 关键字传参 使用关键字传参可以打破位置传参中占位符和标识符顺序以及数量必须统一的限制： name = \"YunYaSir\" age = 19 s1 = \"name : %(name)s\\nage : %(age)d\" % {\"age\": age, \"name\": name} # ❶ print(s1) # name : YunYaSir # age : 19 如上所示：%(name)s代表将dict中key为name的值转换为字符串形式显示，而%(age)d则代表将dict中key为age的值转换为字符串形式显示。 优点：使用灵活 缺点：如果被格式化的占位符过多，可能导致维护不便的情况发生 格式化百分号 如果想打印%占比，则可以使用下面的方式 %%代表一个% 。放在 %d后面的%则代表格式化出后的结果是3%: s1 = \"%d%%\"%3 print(s1) # 3% 格式化精度控制 如果要格式化一个小数，保留点后2位该怎么做？ 如下示例： PI = 3.1415926 print(\"pi = %.2f\" % PI) # pi = 3.14 format() %虽然能够满足基本需求。但在Python2.6中新增的format()方法，它更加强大且速度更快。 推荐今后使用format()的方法进行字符串格式化 。 注意:format()中的s只接受str类型的传值而不接受全部类型 如下所示，必须一个{}对应format()中的一个对象： name = \"YunYaSir\" age = 19 s1 = \"name : {}\\nage : {}\".format(name, age) # ❶ print(s1) # name : YunYaSir # age : 19 ❶：第1个{}对应format()中传入的第1个对象name，而第2个{}对应format()中传入的第2个对象age 或者也可以使用对象的方法调用形式： name = \"YunYaSir\" age = 19 s1 = str.format(\"name : {}\\nage : {}\", name, age) print(s1) # name : YunYaSir # age : 19 位置传参 基本使用，采用{}进行占位，需要注意的是format中的s不是接收全部类型的对象，只能接收str类型的对象： name = \"YunYaSir\" age = 19 s1 = \"name : {:s}\\nage : {:d}\".format(name, age) print(s1) # name : YunYaSir # age : 19 如果不指定类型，则{}中默认接收全部类型的对象： name = \"YunYaSir\" age = 19 s1 = \"name : {}\\nage : {}\".format(name, age) print(s1) # name : YunYaSir # age : 19 索引传参 索引传参是format()方法所独有的。 采用{}进行占位，并在其中传入format()中被格式化对象的位置信息，如下所示： name = \"YunYaSir\" age = 19 s1 = \"name : {0:s}\\nage : {1:d}\".format(name, age) print(s1) # name : YunYaSir # age : 19 需要注意，索引传参时必须为正向索引，不支持负向索引。 关键字传参 format()方法传参时使用键值对的方式进行传参： name = \"YunYaSir\" age = 19 s1 = \"name : {name:s}\\nage : {age:d}\".format(name=name, age=age) print(s1) # name : YunYaSir # age : 19 你也可以直接传入一个字典，通过**语法对字典解包： name = \"YunYaSir\" age = 19 s1 = \"name : {name:s}\\nage : {age:d}\".format(**{\"name\": name, \"age\": age}) print(s1) # name : YunYaSir # age : 19 字符填充功能 format()方法格式化时支持字符填充，如下表所示： 填充位置符号 描述 字符串居左、往右填充数据项 > 字符串居右、往左填充数据项 ^ 字符串居中、两侧填充数据项 示例如下： char = \"M\" # 右填充*，字符串长度为10时停止填充 rightFill = str.format(\"{0:*10}\", char) print(leftFill) # *********M # 两侧填充*，字符串长度为10时停止填充 midFill = str.format(\"{0:*^10}\", char) print(midFill) # ****M***** 格式化百分号 format()方法格式化百分号方法如下，它比%的格式化更加简单： s1 = str.format(\"{0}%\", 3) print(s1) # 3% 格式化{}大括号 如果使用format()方法，格式化时要输出“{char}“该怎么做？ 在外部套用2次大括号即可，如下所示： s1 = str.format(\"{{{0}}}\", \"☺\") print(s1) # {☺} 内部的{0}代表要格式化后面的☺，而外部的2个{}格式化完成后则表现为1个{}。 格式化精度控制 如果要使用format()方法格式化一个小数，保留点后2位该怎么做？ 如下示例： PI = 3.1415926 print(\"pi = {0:.2f}\".format(PI)) # pi = 3.14 其他的格式化 进制转换、如下所示： # 进制转换 sBit = str.format(\"{:b}\", 10) # 2进制 sOct = str.format(\"{:o}\", 10) # 8进制 sHex = str.format(\"{:x}\", 10) # 16进制 print(sBit) # 1010 print(sOct) # 12 print(sHex) # a 如果1代表百分之百，该怎么表示？如下所示： # .2%中的2代表保留2小数点后2位 s1 = str.format(\"{:.2%}\", 1) print(s1) s2 = str.format(\"{:.2%}\", 0.5) print(s2) # 100.00% # 50.00% 千分位表示，用逗号进行分割： s = str.format(\"{:,}\", 100000000) print(s) # 100,000,000 f 尽管format()已经非常方便了。但是如果传入的参数值太多依旧会看着十分混乱，于是Python3.6中新增了 f 格式字符串的操作。 这种方法的速度最快，但是却不推荐使用，因为程序还要考虑一个向下兼容性的问题。 name = \"YunYaSir\" age = 19 s1 = f\"name : {name}\\nage : {age}\" print(s1) # name : YunYaSir # age : 19 具体使用方法参照上面，与原始字符串r使用差不多，用f添加在字符串前面，并且使用{}进行占位，{}中放入对象即可。 关于其他的字符串填充、精度控制、格式化转换等功能均和format()使用相同，这里不再举例。 标准输入 input() Python2和Python3中均有input()函数来接收用户的输入。 需要注意的是，Python3中input()所得到的所有用户输入的数据，类型都是str，举个例子，用户输入小键盘数字1，程序得到的类型为str而不是int，所以我们可能需要额外的进行类型转换。 而在Python2中，则会自动转换类型为int，Python2会检测用户输入的内容是否符合Python语法，如不符合语法就会抛出异常，因此Python3中才摈弃了这种设定。 Python3中获得的所有输入结果类型均为str： username = input(\"Please type in your name:\") userage = input(\"Please enter age:\") print(\"value : %r\\ntype : %r\" % (username, type(username))) print(\"value : %r\\ntype : %r\" % (userage, type(userage))) # Please type in your name:YunYaSir # Please enter age:18 # value : 'YunYaSir' # type : # value : '18' # type : 用户年龄应当是int类型，所以我们需要对其做一次类型转换： username = input(\"Please type in your name:\") userage = int(input(\"Please enter age:\")) Python2中如果用户没有按照Python语法进行数据的录入，则会抛出异常： # coding:u8 username = input(\"Please type in your name:\") userage = input(\"Please enter age:\") print u\"value : %r\\ntype : %r\" % (username, type(username)) print u\"value : %r\\ntype : %r\" % (userage, type(userage)) # -- 输入了 yunya 会抛出 name 'yunya' is not defined # -- 而输入了 \"yunya\" 则会正常 raw_input() raw_input()是Python2中独有的，与Python3的input()效果相同。 这还是因为Python2中input()的缺点而导致raw_input()的诞生，用户必须熟知Python语法才能与程序进行交互，这是不现实的。 >>> name = input(\"Please type in your name:\") Please type in your name: yunya ❶ NameError: name 'yunya' is not defined >>> name = input(\"Please type in your name:\") Please type in your name: \"yunya\" ❷ >>> name 'yunya' ❶：这里没加引号，Python2的input()会认为这是一个变量，但该变量并未被定义，所以抛出 yunya 未定义的这么一个异常。 ❷：加了引号，表明这是一个字符串 更进一步了解输出 stdin&stdout&stderr 在Linux下，当一个用户进程被创建的时候，系统会自动为该进程创建三个数据流，分别是stdin、stdout、stderr。 stdin：标准输入、指向用户键盘 stdout：标准输出、指向用户屏幕 stderr：标准错误、指向用户屏幕 print()的指向 Python3的print()函数，内部则是引用了stdout，也就是说会默认的将数据显示在用户屏幕上。 我们可以从Python中print()函数签名中看到： def print(self, *args, sep=' ', end='\\n', file=None): # known special case of print \"\"\" print(value, ..., sep=' ', end='\\n', file=sys.stdout, flush=False) Prints the values to a stream, or to sys.stdout by default. Optional keyword arguments: file: a file-like object (stream); defaults to the current sys.stdout. sep: string inserted between values, default a space. end: string appended after the last value, default a newline. flush: whether to forcibly flush the stream. \"\"\" pass 而关于flush参数，则可以理解为刷新机制。 默认是False即代表是流式的输出，而改为True则会拥有类似于帧动画的特性，以下代码将进行验证，推荐使用Python IDLE查看效果： import time print(\"downloading\\t\", end=\"\") for i in range(100): time.sleep(0.1) if i == 99: print('#', flush=True, end=\"\\tdownload complate\\n\") break print('#', flush=True, end=\"\") Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-09 15:59:28 "},"Python/Python基础知识/运算符相关.html":{"url":"Python/Python基础知识/运算符相关.html","title":"运算符相关","keywords":"","body":"算数运算符 符号意义 以下是常用的算数运算符： 符号 意义 + 加法运算 - 减法运算 * 乘法运算 / 除法运算，精确除法（返回float） // 除法运算，地板除法（向下取整，生成int） ** 幂运算 % 求余运算 注意事项： float与int或者bool做运算，得到的结果均为float >>> 1 + 1.0 2.0 >>> 1 - 1.0 0.0 >>> 1 * 1.0 1.0 >>> 1 / 1.0 1.0 **幂运算仅支持int 、float、 bool 三种类型 >>> 2 ** 3 8 >>> 2.0 ** 3 8.0 >>> True ** 3 1 >>> %求余运算只支持 int 、float、 bool 三种类型，如果被求余数小于求余数，那么余数就为被求余数本身 >>> 6 % 8 6 示例演示 加法运算 print(1 + 1) print(1 + 1.1) print(1 + True) print([1, 2, 3] + [4, 5, 6]) print('OldStr ' + ' NewStr') # Change the reference value, generate new objects print((1, 2, 3) + (4, 5, 6)) # Change the reference value, generate new objects # 2 # 2.1 # 2 # OldStr NewStr # [1, 2, 3, 4, 5, 6] # (1, 2, 3, 4, 5, 6) 减法运算 print(1 - 1) print(1 - 1.1) print(1 - True) # 0 # -0.10000000000000009 # 0 乘法运算 s1 = '￥' l1 = [1, 2, 3] t1 = (1, 2, 3) print(1 * 2) print(1 * 2.0) print(1 * True) print(3 * l1) print(3 * s1) # Change the reference value to generate a new STR object print(3 * t1) # Change the reference value to generate a new Tuple object # 2 # 2.0 # 1 # [1, 2, 3, 1, 2, 3, 1, 2, 3] # ￥￥￥ # (1, 2, 3, 1, 2, 3, 1, 2, 3) 精确除法 print(10 / 2) print(10 / 2.0) print(10.1 / True) print(10.1 / True) print(10.1 / True) print(10.1 / True) print(False / 10) print(True / 2) print(True / 2.0) # 5.0 # 5.0 # 10.1 # 10.1 # 10.1 # 10.1 # 0.0 # 0.5 # 0.5 赋值运算符 符号意义 以下是常用的赋值运算符： 符号 意义 = 普通的赋值 + 增量加法赋值 - 增量减法赋值 * 增量乘法赋值 / 增量精确除法赋值 // 增量地板除法赋值 ** 增量幂运算赋值 % 增量求余赋值 普通赋值 赋值运算符为=，切记一个=才是赋值： >>> x = 1 >>> x 1 增量赋值 在原本标识符所指向的对象基础上进行增量的运算后，再将运算结果赋值给原本的标识符。 增量赋值运算符就是将赋值符号和算术运算符结合起来达到简写的目的： 普通的先运算后赋值： >>> x = 1 >>> x = x + 10 >>> x 11 >>> x = x - 10 >>> x 1 >>> x = x * 10 >>> x 10 >>> x = x / 10 >>> x 1.0 >>> x = x // 10 >>> x 0.0 >>> x = x ** 10 >>> x 0.0 >>> x = x % 10 >>> x 0.0 简便的增量运算符： >>> x = 1 >>> x += 10 >>> x 11 >>> x -= 10 >>> x 1 >>> x *= 10 >>> x 10 >>> x /= 10 >>> x 1.0 >>> x //= 10 >>> x 0.0 >>> x **= 10 >>> x 0.0 >>> x %= 10 >>> x 0.0 平行赋值 平行赋值，一次为多个标识符进行赋值： >>> x, y, z = 1, 2, 3 >>> x 1 >>> y 2 >>> z 3 链式赋值 链式赋值，多个标识符引用同一个对象： >>> x = y = z = \"Object\" >>> x 'Object' >>> y 'Object' >>> z 'Object' 链式赋值也被称之为间接赋值。 交叉赋值 交叉赋值，将2个标识符所指向的对象进行互换： >>> x = \"Object001\" >>> y = \"Object002\" >>> x, y = y, x >>> x 'Object002' >>> y 'Object001' 解压赋值 解压赋值这里不再进行赘述了，前面在介绍内置数据类型的时候已经介绍过了。 比较运算符 符号意义 比较运算符的返回结果总是为True或者False，一般是用于比较2个相同类型的值的大小。 常用于条件分支结构中： 符号 意义 > 大于 小于 == 等于 != 不等于 >= 大于或者等于 小于或者等于 示例演示 比较运算符得到的结果必然是bool类型： >>> 1 >> 1 > 2 False >>> 1 == 1.0 True >>> 1 == True True 比较方式 字符串与字符串之间的比较会一位一位对照ASCII表来进行比对： >>> ord(\"y\") 121 >>> ord(\"k\") 107 >>> \"y\" > \"k\" True 如果是非ASCII字符，则会调用其他的比较机制，如调用locale模块下的strxfrm()函数对字符串进行本地化处理： print(\"中\" > \"美\") 如果是数字串，则会一位一位进行比较： >>> \"100\" > \"4\" False # 第一位比较：1 小于 4，后续不再比较 数字与数字之间的比较会之间比较整体： >>> 100 > 1000 False 元组、列表之间的比较会根据相同的索引值进行一位一位的比较： >>> (\"100\", ) > (\"45\", \"b\") False # 1比4小 逻辑运算符 逻辑词汇 不同于其他编程语言的&&和||，Python中使用单词代表与或非。 单词 意义 not 非，统一取反 and 与，一真一假取一假，两个为真才取真 or 或，一真一假取一真，两个为假才取假 优先级 优先级的意思是如下： not True and False or True # 第一个True是该给not还是and做运算呢？ 牢记：NOT>AND>OR 故上面的结果为： True 以下是推算流程： False and False or True False or True True 示例演示 使用not进行取反： >>> not 1 > 2 True 使用and进行多条件连接： >>> name = \"Yunya\" >>> age = 18 >>> name == \"Yunya\" and age == 18 True >>> 使用or进行或逻辑判断： >>> name = \"Yunya\" >>> age = 18 >>> name == \"Yunya\" or age == 100 True >>> 短路运算 如果一次逻辑运算中的逻辑运算符号全部为 and 或者 or 则会从左至右依次进行逻辑运算。 如果每一次都进行运算是很消耗时间的，所以这个时候出现了短路机制。 看图说话： 与或运算 如果不是对True或者False进行and or运算而是对数字进行and or运算呢？ 只需要牢记0是False非0是True即可： >>> 1 and 0 or 3 3 >>> 3 + 1 and 4 or 0 4 每次的结果，都取最后一个True值： >>> 1 and 2 2 >>> 2 and 1 1 >>> 1 or 0 1 >>> 0 or 1 1 成员运算符 in in用来判断容器类型的某一个数据项是否在其中，支持的类型有str、list、tuple、dict、set、frozenset，所有的判定严格区分大小写。 in：在其中 not in：不在其中 需要注意的是如果是对dict做in的成员判定，只会判定key是否在其中： >>> string = \"ABCDEFG\" >>> \"A\" in string True >>> \"a\" in string False >>> li1 = [1, 2, 3] >>> 1 in li1 True >>> 0 in li1 False >>> tup = (1, 2, 3) >>> 1 in tup True >>> 0 in tup False >>> dic = {\"k1\" : \"v1\", \"k2\" : \"v2\"} >>> \"k1\" in dic True >>> \"v1\" in dic False >>> s1 = {1, 2, 3} >>> 1 in s1 True >>> 0 in s1 False 身份运算符 is is判定对象是否来自同一引用，即是否是同一个对象，用来判断引用是否相等： >>> x = y = z = \"I love Python\" >>> x is y True >>> x is z True is&==的异同 ==仅判断对象的值是否相同，不关心是否引用自同一对象： >>> x = \"I love Python\" >>> y = \"I love Python\" >>> x == y True >>> x is y False 两者的区别在于使用is时相当于使用 id(obj) == id(obj)，即对象是否为同一引用： >>> x = \"I love Python\" >>> y = \"I love Python\" >>> id(x) 4305667952 >>> id(y) 4305668016 >>> id(x) == id(y) # is False 而==则不会判定id，仅判断2个对象的形式值是否相同： >>> x = \"I love Python\" >>> y = \"I love Python\" >>> id(x) 4305667952 >>> id(y) 4305668016 >>> x == y True 小结： is：引用判定，引用相等的对象则必然值相等 ==：值判定，值相等的对象引用不一定相等 is None 一般来说，我们对None做判断时都会使用is None而不是 == None，这是因为None本身就是一个单例对象。 所有的None对象其实内部都引用自同一对象，在PEP8规范中明确表示，对于None的判定应该使用is而不是==： r = None print(r is None) print(r == None) # True # True 虽然这么使用毫无问题，但是在PyCharm中会报出PEP8不规范的提示： 对象的增量与普通运算操作 记住一句话，增量是原地操作，不会开辟新的内存空间（字符串的+=除外）。 而普通的运算操作则会开辟新的内存空间，返回1个新对象。 我们以列表举例： >>> lst1 = [1, 2, 3] >>> lst2 = lst1 * 3 >>> lst1 is lst2 False >>> lst2 [1, 2, 3, 1, 2, 3, 1, 2, 3] >>> lst1 = [1, 2, 3] >>> id(li1) 4346207752 >>> lst1 *= 3 >>> id(li1) 4346207752 >>> lst1 [1, 2, 3, 1, 2, 3, 1, 2, 3] Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-10 10:55:52 "},"Python/Python基础知识/分支结构.html":{"url":"Python/Python基础知识/分支结构.html","title":"分支结构","keywords":"","body":"分支结构 分支结构能够让计算机像人一样进行思考，应对不同的场景做出不同的回应。 Python中不支持switch语法，目前仅支持if/else形式，但是在Python3.10的测试版本中，貌似支持了switch语法，这里不做例举。 if 多条if语句出现会逐行进行判断，条件为真则执行其下的代码块，条件为假则略过： if 条件判断： 逻辑代码... if 条件判断: 逻辑代码... if 条件判断: 逻辑代码... 示例演示： userAge = int(input(\"Please enter your age:\")) if userAge = 18 and userAge = 30 and userAge = 60 and userAge = 80: print(\"Can still meal\") if/else if代表如果怎样就怎样，else代表否则怎样就怎样。 一组if/else只会执行其中的一个。 以下是Python中if/else语法： if 条件判断： 逻辑代码... else： 逻辑代码... 示例演示： userinput = input(\"Enter any character, determine if it is a numeric string:\") if userinput.isdigit(): print(\"Is a digital string\") else: print(\"Not a digital string\") if/elif/else 多条if会按顺序依次执行，对每一条if语句都进行判定，而如果使用elif则只会从多条逻辑判定中取出最先为True的进行执行，后续的判定将不会被执行。 也就是说，if/elif/else三者只会执行一个。 语法使用如下： if 条件判断： 逻辑代码... elif 条件判断: 逻辑代码... elif 条件判断: 逻辑代码... else: 逻辑代码 示例演示： userAge = int(input(\"Please enter your age:\")) if userAge 三元表达式 三元表达式中有三个重要的元素： 条件是第一元素 　 条件成立返回的值是第二元素 　 条件不成立返回的值是第三元素 普通形式 如果只是一个简单if/else判定，我们可以将代码写在一行，语法如下： if else 示例演示： age = int(input(\"Please enter your age:\")) result = \"adult\" if age >= 18 else \"underage\" print(result) 其他形式 上面的三元表达式是最常见的一种，除此之外再介绍几种不常见的。 第二种，这种有一个BUG，不能区分0或者Fasle： and or 如下所示，如果1大于0就返回0，否则返回False，但是第二种的返回的结果永远是False： result = 1 > 0 and 0 or False print(result) # False 如果使用第一种，就不会有这样的问题： result = 0 if 1 > 0 else False print(result) # False 第三种，语法如下： (, )[condition] 示例如下： age = int(input(\"Please enter your age:\")) result = (\"underage\", \"adult\")[age >= 18] print(result) 第四种，语法如下： {True: , False: }[] 示例如下： age = int(input(\"Please enter your age:\")) result = {True: \"adult\", False: \"underage\"}[age >= 18] print(result) Python语法糖 链式比较 在Python中的判定支持一种链式比较，下面是常规的比较： age = 13 if age > 12 and age 通过链式比较进行简写： age = 13 if 12 12 and age 获得布尔值 判定用户输入的是否为数字串，如果为数字串result变量为True，否则为False。 很多情况下，初学者可能会写出下面这种代码： userInput = input(\"Please enter your age:\") result = None if userInput.isdigit(): result = True else: result = False print(result) 其实一行代码就可以搞定： userInput = input(\"Please enter your age:\") result = bool(userInput.isdigit()) print(result) 或者你也可以使用另一种方式： userInput = input(\"Please enter your age:\") result = userInput.isdigit() or False print(result) 实例练习 输入一个数字，判断该数字是奇数还是偶数： num = int(input(\"Enter a number: \")) if (num % 2) == 0: print(\"%s an even number\" % num) else: print(\"%s an odd number\" % num) 输入一个年份，判断该年份是否是闰年？ year = int(input(\"Enter a year: \")) if (year % 4) == 0: if (year % 100) == 0: if (year % 400) == 0: print(\"%s is a leap year\" % year) # 整百年能被400整除的是闰年 else: print(\"%s not is leap year\" % year) else: print(\"%s is a leap year\" % year) # 非整百年能被4整除的为闰年 else: print(\"%s not is leap year\" % year) 输入某年某月某日，判断这一天是这一年的第几天？ year = int(input('year:\\n')) month = int(input('month:\\n')) day = int(input('day:\\n')) sumInt = None months = (0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334) if 0 2): sum += 1 print('it is the %dth day.' % sum) Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-09 13:22:16 "},"Python/Python基础知识/流程控制.html":{"url":"Python/Python基础知识/流程控制.html","title":"流程控制","keywords":"","body":"流程控制 流程控制以循环为主，旨在让计算机重复的去做某一件事情。 在介绍流程控制一章节前，引入一个叫做遍历的概念： 遍历是指对一个可迭代对象类型（暂时理解为容器类型），进行数据项的依次访问行为 下面这个是遍历行为轨迹示意： # [1, 2, 3, 4, 5, 6] # ------------------> 重复的取值也在遍历范畴： # [1, 2, 3, 4, 5, 6] # -----> # # 条件循环 while while循环是基于条件的循环，while本身具有if判断的功能，当条件为真时开始重复执行子代码块中的内容直至条件为假后跳出循环。 tag = 10 while tag > 5: print(\"current tag value : %s\" % tag) tag -= 1 print(\"while cycle end tag of value : %s\" % tag) # current tag value : 10 # current tag value : 9 # current tag value : 8 # current tag value : 7 # current tag value : 6 # while cycle end tag of value : 5 条件退出 while只有在每一次的循环开始前才会检测条件是否为真，如果条件在子代码块内部发生改变则本次的循环并不会立即退出，如下所示： tag = 10 while tag != 5: print(\"current tag value : %s\" % tag) tag = 5 print(\"no stop continue to run\") print(\"while cycle end tag of value : %s\" % tag) # current tag value : 10 # no stop continue to run\" # while cycle end tag of value : 5 while/else while循环正常结束后，会执行else代码块中的代码： 正常结束的while循环是指不被强制break的while循环 tag = 3 while tag: print(tag) tag -= 1 else: print(\"else...\") # 3 # 2 # 1 # else... 死循环 当while的结果永远为真时，将引发死循环。 单纯的死循环不会引来性能损耗问题，但是如果做一些计算操作则必将会对CPU带来极大的性能压力，因为CPU没有一刻的休息时间。 tag = 1 while 1: tag += 10 取值循环 for for循环内部是基于while循环来完成的，for循环在对可迭代对象的取值上比while循环更加的方便，故也被称为取值循环。 for循环常用于遍历可迭代对象进行取值操作，以下是语法介绍： for 迭代变量 in 可迭代对象（暂时可理解为容器类型） 逻辑操作... 以下是使用while循环遍历可迭代对象进行取值，相当麻烦： lst = [1, 2, 3, 4, 5] index = 0 while 1: try: print(lst[index]) except IndexError: break index += 1 # 1 # 2 # 3 # 4 # 5 如果使用for循环，那么就变的简单许多： lst = [1, 2, 3, 4, 5] for i in lst: print(i) # 1 # 2 # 3 # 4 # 5 结束退出 for循环的正常退出是遍历完整个可迭代对象之后进行退出。 lst = [1, 2, 3, 4, 5] for i in lst: print(i) print(\"for cycle end\") # 1 # 2 # 3 # 4 # 5 # for cycle end for/else 当for循环正常退出结束后，会执行else下的代码块： 正常结束的for循环是指不被强制break的for循环 lst = [1, 2, 3, 4, 5] for i in lst: print(i) else: print(\"else..\") # 1 # 2 # 3 # 4 # 5 # else.. range() 我们有一个需求需要让计算机重复打印5次hello,world，你可能会这样做： count = 5 while count: print(\"hello,world\") count -= 1 也可以使用for循环来进行完成，但是这样会很麻烦，由于使用for循环必须遍历一个可迭代对象，所以要先创建一个可迭代对象： count = [0, 1, 2, 3, 4] for i in count: print(\"hello,world\") 如果你使用range()，这一切都会变得非常简单，range()会帮助你快速的创建一个可迭代对象，我们只需要指定它的次数即可： for i in range(5): print(\"hello,world\") 关于range()方法的其他讲解，会在下面进行。 容器遍历 字符串遍历 示例演示： string = \"hello world\" for i in string: print(\"index : %s, value : %s\"%(string.index(i), i)) # index : 0, value : h # index : 1, value : e # index : 2, value : l # index : 2, value : l # index : 4, value : o # index : 5, value : # index : 6, value : w # index : 4, value : o # index : 8, value : r # index : 2, value : l # index : 10, value : d 列表遍历 普通遍历： lst = [1, 2, 3, 4] for i in lst: print(i) 通过enumerate()函数来同时遍历2个相同长度的列表： lst1 = [\"A\", \"B\", \"C\", \"D\"] lst2 = [\"a\", \"b\", \"c\", \"d\"] for index, item in enumerate(lst1): lst1Message = str.format( \"lst1 index position {} is data item {}\", index, item) print(lst1Message) lst2Message = str.format( \"lst2 index position {} is data item {}\", index, lst2[index]) print(lst2Message) 通过[::-1]来反向遍历列表： lst = [\"A\", \"B\", \"C\", \"D\"] for i in lst[::-1]: print(i) 隔一个取一个的遍历列表： lst = [\"A\", \"B\", \"C\", \"D\"] for i in lst[::2]: print(i) 字典遍历 普通的遍历只会遍历出key，这样的操作等同于遍历dict.keys()： dic = { \"k1\": \"v1\", \"k2\": \"v2\", \"k3\": \"v3\", } for k in dic: print(k) # k1 # k2 # k3 如果你想取出value，则可以遍历dict.values()： dic = { \"k1\": \"v1\", \"k2\": \"v2\", \"k3\": \"v3\", } for v in dic.values(): print(v) # v1 # v2 # v3 如果你想同时取出key和value，则可以遍历dict.items(): dic = { \"k1\": \"v1\", \"k2\": \"v2\", \"k3\": \"v3\", } for k, v in dic.items(): print(k, v) # k1 v1 # k2 v2 # k3 v3 局部作用域 如果一个迭代变量的命名为i，那么这个迭代变量能在外部访问到吗？答案是能！ 其实在Python2和Python3中，普通的for循环语句是没有局部作用域这一个说法的，希望在未来版本能有所改进。 for i in range(10): pass print(i) # 9 循环控制 continue 在while/for中均可以使用continue跳过本次循环。 以下用for循环进行举例： for i in range(5): if i == 3: continue else: print(i) # 0 # 1 # 2 # 4 break 在while/for中均可以使用break结束本层循环。 以下用for循环进行举例： for i in range(5): if i == 3: break else: print(i) # 0 # 1 # 2 循环嵌套 while嵌套 while循环支持多层嵌套，在使用时注意下面的事项： 如果是使用基于条件退出那么所有的while循环都必须遵循同一个条件才能退出 break只针对当前的while循环体退出，对于非当前的while循环体不生效 continue只针对当前while循环体跳过，对于非当前的while循环体不生效。 如下示例： tag = True while tag: print(\"outer while cycle start, current tag value is : %s\" % tag) while tag: print(\"intermediate while cycle start, current tag value is : %s\" % tag) while tag: print(\"inner while cycle start, current tag value is : %s\" % tag) tag = False # outer while cycle start, current tag value is : True # intermediate while cycle start, current tag value is : True # inner while cycle start, current tag value is : True for嵌套 for循环同样支持嵌套。 外层执行1次，内层的for循环要全部循环完成才回到外层执行第2次。 for i in range(65, 68): print(\"outer for cycle, current cycle value is : %s\" % chr(i)) for j in range(97, 100): print(\"inner for cycle, current cycle value is : %s\" % chr(j)) print(\"\") # outer for cycle, current cycle value is : A # inner for cycle, current cycle value is : a # inner for cycle, current cycle value is : b # inner for cycle, current cycle value is : c # outer for cycle, current cycle value is : B # inner for cycle, current cycle value is : a # inner for cycle, current cycle value is : b # inner for cycle, current cycle value is : c # outer for cycle, current cycle value is : C # inner for cycle, current cycle value is : a # inner for cycle, current cycle value is : b # inner for cycle, current cycle value is : c 以下是使用for循环打印乘法表的例子： for i in range(1, 10): for j in range(1, i+1): print(\"%s * %s = %s\" % (i, j, i*j), end=\"\\t\") print(\"\") range()详解 range() range()方法在Python2中返回的是一个列表，而在Python3中返回的是一个可迭代对象（这种可迭代对象不会存值，而是惰性求值，类似于生成器）。 range()方法有三个参数，如下表所示： 参数介绍 描述 start 从几开始生成 stop 生成到几结束 step 步长间距 在使用range()进行生成时，需要注意顾头不顾尾。 如下所示： lst = list(range(1, 10, 2)) print(lst) # [1, 3, 5, 7, 9] xrange() Python2中的xrange()与Python3中的range()相同，均返回可迭代对象，而非列表。 关于为什么做，其实是为了节省内存空间。 列表中的具体值会存在内存中，而如果是一个通过计算可惰性求值的可迭代对象，则不会消耗太大的内存，以下是自定义range()的实现。 class Range: def __init__(self, stop, start=0, step=1): self.start = start self.stop = stop self.step = step self.current = None def __iter__(self): return Range_iterator(self.stop, self.start, self.step) class Range_iterator: def __init__(self, stop, start, step): self.start = start self.stop = stop self.step = step self.current = self.start def __next__(self): if self.current 实例练习 将列表内的元素,根据位数合并成字典，列表如下： lst = [1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 32769, 65536, 4294967296] 答案： lst = [1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 32769, 65536, 4294967296] dic = {} for i in lst: k = len(str(i)) # 如果不存在该键，这该键等同于一个空列表 dic.setdefault(k, []) dic[k].append(i) print(dic) 使用for循环打印三角形： for i in range(1, 6): for j in range(1, 6 - i): print(\" \", end=\"\") for k in range(1, i + 1): print(\"* \", end=\"\") print(\"\") # * # * * # * * * # * * * * # * * * * * 有四个数字：1、2、3、4，能组成多少个互不相同且无重复数字的三位数？各是多少？ count = 0 for i in range(5): for j in range(1, 5): for k in range(1, 5): if (i != k) and (i != j) and (j != k): count += 1 print(i, j, k) print(count) # 36 斐波拉契数列是这样的一个数列：0、1、1、2、3、5、8、13、21、34、…… 前2个值加起来的结果恰好等于第3个值，求一个长度为10的斐波拉契数列： n = 10 fibArray = [] a , b = 0, 1 for i in range(n): fibArray.append(a) a, b = b, a + b print(fibArray) # [0, 1, 1, 2, 3, 5, 8, 13, 21, 34] 输入2个数字，求2个数字的最小公倍数： x = int(input(\">>>\")) y = int(input(\">>>\")) minCommonMultiple = None if x > y: greater = y else: greater = x while 1: if ((greater % x == 0 ) and (greater % y == 0)): minCommonMultiple = greater break greater += 1 msg = str.format(\"{0}和{1}的最小公倍数为{2}\", x, y, minCommonMultiple) print(msg) 输入2个数字，求2个数字的最大公约数： x = int(input(\">>>\")) y = int(input(\">>>\")) maxCommonDivisor = None if x > y: smaller = y else: smaller = x for i in range(1, smaller + 1): if ((x % i == 0) and (y % i == 0)): maxCommonDivisor = i msg = str.format(\"{0}和{1}的最大公约数为{2}\", x, y, maxCommonDivisor) print(msg) Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-10 15:02:36 "},"Python/Python基础知识/推导式.html":{"url":"Python/Python基础知识/推导式.html","title":"推导式","keywords":"","body":"推导式 Python从Haskell语言中取得灵感，创建了一系列的Python推导式（comprehension）。 它可以在不丧失代码可读性的前提下创建一系列容器，是Python颇受好评的特性。 列表推导式 应用场景 有一个列表中存了一些人名和性别的元组数据项，我需要将性别为男性（male）的数据项提取至一个新的列表中。 如下所示，在没有学习列表推导式之前， 你可能会这样做： oldList = [ (\"Tom\", \"Male\"), (\"Jack\", \"Male\"), (\"Mary\", \"Female\"), (\"Laura\", \"Female\") ] newList = [] for tpl in oldList: if tpl[-1].lower() == \"male\": newList.append(tpl) print(newList) # [['Tom', 'Male'], ['Jack', 'Male']] 如果有列表推导式的帮助，它就会简单许多，语法如下： newList = [ 被添加/操作的数据项 for 迭代变量 in 可迭代对象 if 条件] 列表推导式操作如下所示： oldList = [ (\"Tom\", \"Male\"), (\"Jack\", \"Male\"), (\"Mary\", \"Female\"), (\"Laura\", \"Female\") ] newList = [tpl for tpl in oldList if tpl[-1].lower() == \"male\"] # ❶ print(newList) # [['Tom', 'Male'], ['Jack', 'Male']] ❶：当数据项的判断为True时将自动添加至newList中，不能指定else条件 快速创建列表 使用列表推导式可以快速的创建一个列表。 如下所示，推导出数据项从1-10的列表： newLi = [i for i in range(1, 11)] print(newLi) # [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] 下面的示例中，我们可以快速的使用双层循环推导出了一副扑克牌的列表： newLi = [ i + str(j) for i in [\"❤\", \"♧\", \"♤\", \"♢\"] for j in range(1, 14)] newLi.append(\"bigKing\") newLi.append(\"smallKing\") print(newLi) 结果如下： ['❤1', '❤2', '❤3', '❤4', '❤5', '❤6', '❤7', '❤8', '❤9', '❤10', '❤11', '❤12', '❤13', '♧1', '♧2', '♧3', '♧4', '♧5', '♧6', '♧7', '♧8', '♧9', '♧10', '♧11', '♧12', '♧13', '♤1', '♤2', '♤3', '♤4', '♤5', '♤6', '♤7', '♤8', '♤9', '♤10', '♤11', '♤12', '♤13', '♢1', '♢2', '♢3', '♢4', '♢5', '♢6', '♢7', '♢8', '♢9', '♢10', '♢11', '♢12', '♢13', 'bigKing', 'smallKing'] 元素的处理 数据项在添加至列表之前，可以为其进行一些操作。 比如在上面扑克牌的示例中，我们将int对象转换为了str对象，同理也可以做一些别的操作。 如下示例，我们将推导出一个含有26字母的列表： newLi = [chr(i) for i in range(65, 91)] print(newLi) # ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'] 迭代变量 需要注意的是，迭代变量与条件成立后添加的数据项没有任何关系，如下所示，一行代码创建10个A： newLi = [\"A\" for i in range(10)] print(newLi) # ['A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A'] 对于这个题目，有一种更简便的解法： newLi = [\"A\"] * 10 字典推导式 使用示例 字典推导式和列表推导式大体差不多，但是外部是用花括号包裹，并且要有:进行key和value的区分。 如下所示，快速的推导出标准ASCII码表的对照关系： asciiDict = {i: chr(i) for i in range(0, 128)} print(asciiDict) 结果如下： {0: '\\x00', 1: '\\x01', 2: '\\x02', 3: '\\x03', 4: '\\x04', 5: '\\x05', 6: '\\x06', 7: '\\x07', 8: '\\x08', 9: '\\t', 10: '\\n', 11: '\\x0b', 12: '\\x0c', 13: '\\r', 14: '\\x0e', 15: '\\x0f', 16: '\\x10', 17: '\\x11', 18: '\\x12', 19: '\\x13', 20: '\\x14', 21: '\\x15', 22: '\\x16', 23: '\\x17', 24: '\\x18', 25: '\\x19', 26: '\\x1a', 27: '\\x1b', 28: '\\x1c', 29: '\\x1d', 30: '\\x1e', 31: '\\x1f', 32: ' ', 33: '!', 34: '\"', 35: '#', 36: '$', 37: '%', 38: '&', 39: \"'\", 40: '(', 41: ')', 42: '*', 43: '+', 44: ',', 45: '-', 46: '.', 47: '/', 48: '0', 49: '1', 50: '2', 51: '3', 52: '4', 53: '5', 54: '6', 55: '7', 56: '8', 57: '9', 58: ':', 59: ';', 60: '', 63: '?', 64: '@', 65: 'A', 66: 'B', 67: 'C', 68: 'D', 69: 'E', 70: 'F', 71: 'G', 72: 'H', 73: 'I', 74: 'J', 75: 'K', 76: 'L', 77: 'M', 78: 'N', 79: 'O', 80: 'P', 81: 'Q', 82: 'R', 83: 'S', 84: 'T', 85: 'U', 86: 'V', 87: 'W', 88: 'X', 89: 'Y', 90: 'Z', 91: '[', 92: '\\\\', 93: ']', 94: '^', 95: '_', 96: '`', 97: 'a', 98: 'b', 99: 'c', 100: 'd', 101: 'e', 102: 'f', 103: 'g', 104: 'h', 105: 'i', 106: 'j', 107: 'k', 108: 'l', 109: 'm', 110: 'n', 111: 'o', 112: 'p', 113: 'q', 114: 'r', 115: 's', 116: 't', 117: 'u', 118: 'v', 119: 'w', 120: 'x', 121: 'y', 122: 'z', 123: '{', 124: '|', 125: '}', 126: '~', 127: '\\x7f'} 第2个例子，对于迭代一些特殊格式的容器，可以直接生成出一个字典： userMessage = [(\"name\", \"Yunya\"), (\"age\", 18), (\"gender\", \"male\")] newDict = {k: v for k, v in userMessage} print(newDict) # {'name': 'Yunya', 'age': 18, 'gender': 'male'} 集合推导式 使用示例 集合推导式只需要将列表推导式的[]改为{}即可。 以下是示例演示，很显然，由于是集合推导式，故下面的双层循环并不会产生重复元素： newSet = {j for i in range(10) for j in range(10)} print(newSet) # {0, 1, 2, 3, 4, 5, 6, 7, 8, 9} 局部作用域 之前聊过普通的for循环中是不存在局部作用域的，那么在推导式当中是否存在局部作用域呢？ 以列表举例： newList = [i for i in range(10)] print(i) # NameError: name 'i' is not defined 可以看见，在推导式中的局部作用域是存在的。 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-10 09:45:33 "},"Python/Python基础知识/字符编码.html":{"url":"Python/Python基础知识/字符编码.html","title":"字符编码","keywords":"","body":"存储编码 一般来说，我们用什么方式进行文件存储，就用什么编码方式对其进行打开，一般使用UTF8进行存储和打开文件即可。 执行编码 Python3中在执行代码时，解释器都会按照UTF8编码格式将脚本文件中的代码加载至内存中，所以一般不会出现问题。 但是在Python2里解释器则是使用ASCII的编码格式进行脚本文件内容的解码。 所以你可能会遇上下面的情况： SyntaxError:Non-ASCII character .... in file ... 解决这个办法，可以利用头文件代码，让Python解释器在解码脚本文件内容时，以UTF8格式进行解码： # --*-- coding:UTF8 --*-- # 开始书写你的代码 可以使用sys的getdefaultencoding()方法来查看Python解释器默认采用的执行编码格式： >>> # Python2 >>> import sys >>> sys.getdefaultencoding() 'ascii' >>> # Python3 >>> import sys >>> sys.getdefaultencoding() 'utf-8' Unicode字符串 Python2中的str类型，本质是Python3中的bytes，所以仅支持ASCII码表中的字符。 如果想将其转换为Unicode字符串，则必须在前面加上u： print u\"这是Unicode字符串\" Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-10 11:00:09 "},"Python/Python基础知识/文件操作.html":{"url":"Python/Python基础知识/文件操作.html","title":"文件操作","keywords":"","body":"open() Python中提供了open()方法用于对文件进行操作，该方法会返回一个文件对象。 由于被读取的文件内容本身全部属于str类型，故使用open()方法对其进行操作必然涉及字符编码的问题。 以下是open()方法的函数签名： def open(file: Union[str, bytes, int, _PathLike[Any]], mode: str = ..., buffering: int = ..., encoding: Optional[str] = ..., errors: Optional[str] = ..., newline: Optional[str] = ..., closefd: bool = ..., opener: Optional[Callable[[str, int], int]] = ...) -> IO[Any]: 下面是对常用参数的解释： 参数名 描述 file 必需，文件路径（相对或者绝对路径） mode 可选，文件内容读取与操作模式，*t模式以为文本内容读取模式打开文件。需要填入encoding，b模式为二进制模式读取文件内容，默认该参数为*t 。*代表操作模式 encoding 可选（Python2没有该参数），当mode为 *t 时指定编码或解码格式。一般设置为 utf-8。如不指定Windows平台默认为GBK，Mac和Linux平台为utf-8 buffering 设置缓冲 errors 报错级别 newline 是否区分换行符，默认为True closefd 传入的file参数类型 以下是在Python3中进行读取文件的简单示例： f = open(file=\"test.txt\", mode=\"rt\", encoding=\"utf-8\") print(f.read()) # ❶ f.close() # ❷ ❶：read()读取所有内容 ❷：关闭文件句柄 with语句 在open()后要切记关闭文件句柄，释放系统资源，这是一项非常重要但很容易被人忽视的细节点。 故推荐使用with语句进行文件操作，它将在with子代码块结束后自动关闭文件句柄。 with open(file=\"test.txt\", mode=\"rt\", encoding=\"utf-8\") as f: print(f.read()) 使用with语句还可以同时打开多个文件，示例如下，\\可进行换行： with open(file=\"test.txt\",mode=\"rt\",encoding=\"utf-8\") as f1,\\ open(file=\"test2.txt\",mode=\"rt\",encoding=\"utf-8\") as f2: data1 = f1.read() print (data1) data2 = f2.read() print (data2) 读写内容模式 t模式 当打开一个文件时，默认以*t模式打开。 t代表以文本方式读取文件内容，读取的都是字符。 with open(file=\"test.txt\", mode=\"rt\", encoding=\"utf-8\") as f: result = f.read(3) # ❶ print(result) ❶：指定读取的字符数量 b模式 如果以b模式打开文件，则读取到的都是字节。 若使用字节模式打开文件，则不存在字符编码的问题 with open(file=\"test.txt\", mode=\"rb\") as f: result = f.read(3) # ❶ print(result) # b'\\xe6\\xb5\\x8b' hans = result.decode(\"utf-8\") print(hans) # ❷ ❶：指定读取的字节数量 ❷：解码 读写操作模式 r模式 r代表只读，使用r模式打开文件时文件的指针将跑到最开始。 如果文件不存在将会抛出异常，并且只能使用读取相关的方法。 with open(file=\"test.txt\", mode=\"rb\") as f: print(f.readlines()) w模式 w模式代表只写，使用w模式打开文件时就相当于新建一个文件。 如果文件已存在将清空原本文件中所有的内容，如果文件不存在则创建新文件，并且只能使用写入相关的方法。 with open(file=\"test.txt\", mode=\"wb\") as f: data = \"你好世界\" f.write(data.encode(\"utf-8\")) a模式 a模式为追写模式，当文件不存在时创建新文件，只能执行写相关的操作。 当文件存在时则打开文件，文件指针放到最后，所以被称为追写模式。 强调 w 模式与 a模式的异同： 相同点：在打开的文件不关闭的情况下，连续的写入，新写的内容总会跟在前写的内容之后 不同点：以 a 模式重新打开文件，不会清空原文件内容，会将文件指针直接移动到文件末尾，新写的内容永远写在最后 with open(file=\"test.txt\", mode=\"ab\") as f: f.write(b'\\nnew line...') x模式 x模式与w模式都相同。 唯一不同的地方在于如果需要打开的文件已存在，x模式会抛出异常。 而w模式会新建一个同名文件并且删除掉旧文件。 with open(file=\"test.txt\", mode=\"xb\") as f: f.write(b'\\nnew line...') # FileExistsError: [Errno 17] File exists: 'test.txt' +模式 +这里是对 r w a 的一种扩展。 代表可读可写，但是打开文件后文件指针的位置还是依照 r w a 原本的位置，应该尽量少用+方法。 with open(file=\"test.txt\", mode=\"r+b\") as f: data = f.read() print(data) f.seek(0, 2) f.write(b\"A new line again\\n\") 文件指针 使用seek()函数可以对文件指针进行操作。 以下是seek()函数的签名： def seek(self, offset: int, whence: int = 0) -> int 注意，使用文件指针应该在*b模式下进行使用，它的移动将会按照字节进行移动。 如果是*t模式下，按照字符移动可能会出现某些错误。 参数 描述 offset 偏移量，负数代表向前移动指针，正数代表向后移动指针 whence 偏移位置，0代表起始位置，1代表当前位置，2代表结束位置 示例如下： with open(file=\"test.txt\", mode=\"rb\") as f: # ❶ print(f.tell()) # ❷ f.seek(2, 0) f.seek(10, 0) f.seek(20, 0) print(f.tell()) # ❸ f.seek(-2, 1) f.seek(-3, 1) f.seek(-4, 1) print(f.tell()) # ❹ # 0 # 20 # 11 ❶：注意，文件指针除了（0，0）和（0，2）外，其他都应该用b模式进行。 ❷：打印当前文件指针的位置 0 ❸：打印当前文件指针的位置 20 ❹：由于是相对定位，故可以累加。 20 - 9 ，文件指针在 11 循环读取 for循环 如果直接使用f.read()，当文件内容过于庞大时，这些内容全部会存放于Python程序的内存空间中。 会给内存带来极大的压力，故在文件较小时才使用f.read()，太大的话将使用其他解决方案，如下面的for循环进行读取： data = b\"\" with open(\"test.txt\", mode=\"rb\") as f: for line in f: # ❶ data += line print(data.decode(\"utf-8\")) ❶：直接读取f代表每次读一行，以\\n为单位 while循环 如果一个文件只有一行，如压缩版的前端代码。 在读取时则可使用while循环进行读取，示例如下： data = b\"\" with open(\"test.txt\", mode=\"rb\") as f: while 1: temp = f.read(512) data += temp if not len(temp): break print(data.decode(\"utf-8\")) 文件写入 内存写入 文本编辑器的原理是在打开一个文本文件时其中所有的内容都会加载并存放至内存中。 对该文本内容的修改实际上全部都是在修改内存中的数据，当修改完成后点击保存时才会将内存的数据重新写入至硬盘中。 你应该深有体会，打开一个特别大的文本文件时速度很慢，哪怕没做任何修改保存时速度也还是很慢，实际上就是这个原因导致的。 以下是模拟内存写入，打开文件后将“计算机”替换为“电脑”： data = \"\" # ❶ with open(file=\"BigFileTest.txt\", mode=\"rt\", encoding=\"utf-8\") as f: # ❷ while 1: temp = f.read(512) data += temp # ❸ print(data) # ❹ if not len(temp): # ❺ break print(\"读取完毕..\") data = data.replace(\"计算机\", \"电脑\") # ❻ with open(file=\"BigFileTest.txt\", mode=\"wt\", encoding=\"utf-8\") as f: # ❼ f.write(data) print(\"写入完毕..\") ❶：用于存放数据 ❷：r模式的指针默认放在0位置 ❸：代表每次读取512个字符 ❹：这里可以做其他操作 ❺：代表没有新的内容。 len(temp) == 0 ❻：模拟手动修改文件内容。将计算机修改为电脑，注意此时修改的是内存中的数据 ❼：读取后将Python应用程序中维护的data变量中的数据全部写入该文件。w模式会清空源文件的内容 硬盘时刷 文本编辑器的做法是在内部维护了一个变量，用于提供给用户修改内容。 这么做的好处就是用户可以在修改文件内容时能够查看到所有的文件内容，但是坏处是占用内存空间太大。 这里再介绍一种减少内存压力的方式。 注意：两种方式没有优劣之分，只有使用场景不同的区别，还是和上面一样的操作，将“计算机”替换为“电脑”。 import os with open(file=\"BigFileTest.txt\", mode=\"rt\", encoding=\"utf-8\") as f1, \\ open(file=\".BigFileTest.txt.swap\", mode=\"wt\", encoding=\"utf-8\") as f2: # ❶ for line in f1: line = line.replace(\"计算机\", \"电脑\") # ❷ f2.write(line) # ❸ print(\"操作完成..\") os.remove(\"BigFileTest.txt\") # ❹ os.rename(\".BigFileTest.txt.swap\", \"BigFileTest.txt\") # ❺ 这么做的坏处是没办法随时的修改内存中的变量数据，因为内存中根本没存文本文件内容。 只能按照设定好的程序走一遍，但是极大的节省了内存空间的占用。 ❶：以. 开头的文件代表隐藏文件。以swap结尾的文件代表交换文件（可以理解为临时文件） ❷：每次拿到和修改的只有line ❸：写入交换文件中 ❹：删除源文件 ❺：修改临时文件的名字。与源文件保持一致 操作方法 以下是文件操作中常用的方法： 方法 描述 read() 读取某个文件(全部内容)。也可指定大小，t模式的大小为字符单位，b模式为字节单位 readline() 读取一行文件内容 readlines() 读取所有文件内容并返回一个列表，以行割开 write() 写入一行数据，默认不会\\n需要手动换行 writelines() 写入一行数据，通过列表的方式写到文件里面 tell() 显示当前文件光标的位置 seek() 移动当前文件光标的位置(字节为单位，建议在b模式下使用) readable() 文件是否可读 writable() 文件是否可写 closed 文件是否关闭 encoding 如果文件打开模式是b,则没有该属性 flush() 立刻将文件内容从内存刷到硬盘（测试模式下使用） Python2-open() 由于Python2中不能使用encoding参数指定编解码的方式。所以我们看看在Python2中open()应该怎样使用： #!/usr/bin/env python2 # coding:utf-8 # import sys # reload(sys) # sys.setdefaultencoding('utf-8') # 设置默认的解码方式为 utf-8。如果这样操作就不用设置decode()了。 f = open(file=\"test.txt\",mode=\"rt\",) data = unicode(f.read().decode(\"utf-8\")) # unicode()将读取出的字符转为unicode字符存储于内存中。 print data f.close() Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-10 09:52:00 "},"Python/Python函数相关/summary.html":{"url":"Python/Python函数相关/summary.html","title":"Python函数相关","keywords":"","body":" 初识函数 使用函数 参数详解 命名空间 高阶函数 递归函数 匿名函数 内置函数 装饰器 迭代器 生成器 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-13 13:33:06 "},"Python/Python函数相关/初识函数.html":{"url":"Python/Python函数相关/初识函数.html","title":"初识函数","keywords":"","body":"函数 在编程语言中的函数不同于数学中的函数（function）。 不管是数学上的函数还是编程语言中的函数都是为了完成特定的某一功能而诞生的，他们的区别在于： 数学中的函数当输入的值是固定的情况下那么输出的值也一定是固定的。 它内部不允许原本输入的值状态发生改变。 编程语言中的函数则可以允许传入的值进行修改的。 如果按照数学函数的定义来做编程语言的函数，那么这种函数则被称为纯函数（pure function） 分类 在Python中，函数主要有两类： 内置函数（Built-in function） 自定义函数（Custom function） 如，id()、type()、print()等均属于内置函数，内置函数又被称为工厂函数。 内置函数的实现初衷是将一些经常使用的功能进行封装，并且同Python解释器一起提供给开发者，开发者开箱即用，不必关心底层的算法实现。 而自定义函数是指在内置函数无法完成需求的情况下，由开发人员去自己创作的为了满足特定的某一项功能的可重复使用的具体代码集合。 函数的特点 函数主要解决流式代码的2大问题： 代码冗余度高，程序的组织结构不清晰，可读性差 可维护性以及可扩展性差 函数的特点如下： 提供封装性，用户在外部不用关心内部如何实现 提供可重复调用，开发人员最大限度的减少了重复代码的实现 提升程序可读性，对特定的功能进行分类，使后期维护变的简单 举一个简单的例子，如果没有定义函数，要打印100次“hello world”则需要写一百行下面的代码： print(\"hello world\") print(\"hello world\") print(\"hello world\") print(\"hello world\") ... 而如果使用了函数，则只需调用100次函数即可： def func(): print(\"hello world\") func() func() func() ... 函数与方法 函数（function）与方法（method）都是一个具体功能的实现，它们本质都是一个东西。 区别在于函数允许大多数类型进行调用，而方法只允许特定类型进行调用。 如： id()：允许所有类型进行调用，因此被称为 “函数” format()：只允许str类型进行调用，因此被称为 “方法” 可调用性 函数和方法都是可调用的，如何判断一个对象是否可调用？ 可以使用内置函数callable()进行判断，如下所示，只需在callable()中传入函数名即可： >>> callable(print) True >>> callable(input) True Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-05-17 12:30:17 "},"Python/Python函数相关/使用函数.html":{"url":"Python/Python函数相关/使用函数.html","title":"使用函数","keywords":"","body":"函数使用 内置函数 内置函数是被内部定义好的一些函数，直接调用即可。 但是要严格传入函数所需要的参数，为此，你可以查看Python内置函数源代码，获得函数签名： def bin(*args, **kwargs): # real signature unknown; NOTE: unreliably restored from __doc__ \"\"\" Return the binary representation of an integer. >>> bin(2796202) '0b1010101010101010101010' \"\"\" pass 自定义函数 对于自定义函数来说，与对象声明相同，必须先定义后使用。 以下是语法格式： def 函数标识符(参数1, 参数2): # ❶ \"\"\"功能描述文档\"\"\" # ❷ 逻辑体代码块 # ❸ return 返回值 # ❹ ❶：def为关键字，用于定义一个函数。函数名即函数标识符，参照变量标识符的命名规则。参数是可选的，可以没有 ❷：功能描述文档可有可无，这是提供给用户的帮助信息，可以使用help()函数通过传入函数标识符获得该功能描述文档 ❸：函数的逻辑体代码块，用于具体实现某一功能 ❹：用于返回给用户需要的结果，如果不返回默认返回None 如何使用 函数标识符指向的是函数对象在内存空间的引用，也就是函数体代码块： >>> print 当加上括号后，将自动调用该函数，此时则根据函数签名需求传入对应参数即可： >>> print(\"hello world\") hello world 也就是说，函数标识符不加括号不会调用，只是拿到函数的引用，而加括号后才会执行函数内部的逻辑代码。 定义函数 无参函数 无参函数大多数情况下只是希望该函数单纯的做一点什么事情而并不需要该函数给返回一个结果。 常用于一段特定功能的重复调用，如我想在某种特定的情况下打印出WARNING信息，此时就可以定义一个无参函数： import sys import datetime def warning(): message = str.format( \"WARNING time: file:[{1}] - line:[{2}]\", datetime.datetime.now(), # ❶ sys._getframe().f_code.co_filename, # ❷ sys._getframe().f_back.f_lineno # ❸ ) print(message) warning() print(datetime.datetime.now()) # WARNING time: file:[/Users/Project/demo.py] - line:[13] ❶：获取当前时间 ❷：获取被调用函数所在模块文件名 ❸：获取被调用函数在被调用时所处代码行数 有参函数 函数的参数用于接收用户传入的对象，可以认为传入的对象是指“待加工原材料”。 当函数执行完成后，通过加工“原材料”将会返回一个加工后的“产品”。 以下示例中将计算2个值的相加结果： def add(x, y): res = x + y return res # ❶ result = add(1, 2) print(result) # 3 ❶：返回加工完成后的“产品”，该产品被外部使用result标识符进行接收 空函数 只定义函数名并未做具体实现的函数叫做空函数，空函数在逻辑构思中常被用到。 关键词：pass或者Ellipsis对象。 如下所示： def add(x, y): pass # ❶ def sub(x, y): ... # ❷ ❶：代表省略 ❷：Ellipsis对象，代表省略，仅在Python3中适用 函数调用 语句形式 在函数标识符后加上括号进行调用即可： >>> print(\"hello world\") hello world 表达式形式 表达式形式可以将函数返回的对象赋值给一个标识符，如下所示： def add(x, y): res = x + y return res result = add(1, 2) print(result) # 3 也可以直接对这个函数返回的对象进行操作，如下所示： def add(x, y): res = x + y return res result = add(1, 2) * 10 print(result) # 30 参数调用形式 函数可以作为参数传递给其他函数： def add(x, y): res = x + y return res result = add(add(1, 2), 3) # ❶ print(result) # 6 ❶：相当于add(3, 3) 函数返回值 默认返回值 Python中的函数一定具有返回值。 如果没有显式的使用return关键字指定返回值，则默认会返回None。 def add(x, y): ... result = add(1, 2) print(result) # None return返回值 return有2个作用： 返回函数的执行结果，可以返回1个，也可以返回多个，若返回多个则以元组形式返回 跳出所有的循环体（如果在多层的循环中使用return，将直接跳出所有循环，并且将结果进行返回） 如下示例， 获得指定范围区间的累加结果： def accumulate(start, stop): res = 0 for i in range(start, stop + 1): res += i return res result = accumulate(1, 100) print(result) # 5050 返回多个值时，将以元组形式进行返回，如下示例中输入一个ASCII码表的字符，返回其ASCII码表中对应的大小写编号（a - z具有2个编号，符号只有1个编号）： def getAscii(char): asciiTable = {chr(i) : i for i in range(0, 128)} lowerKey = char.lower() capitalKey = char.upper() return asciiTable[lowerKey], asciiTable[capitalKey] lowInt, capitalInt = getAscii(\"a\") print(lowInt, capitalInt) # 98 66 函数执行 函数必须先定义后使用，否则无法执行： func() def func(): print(\"run ...\") # NameError: name 'func' is not defined 嵌套调用 Python是解释性语言，解释一行执行一行。 当碰见def关键字开头的语句，内部会检测一下该代码块的语法，如果没有出现问题则代表该函数定义好了。 只有碰到函数名加括号的情况下才会去执行该函数。 所以，函数也可以进行嵌套调用，不过我个人不太喜欢这种调用方法，我更倾向于传参调用，在代码维护时更加的方便： def func1(): print(\"run ... func1\") def func2(): print(\"run ... func2\") func1() print(\"run stop\") func2() # run ... func2 # run ... func1 # run stop 内部逻辑 当定义一个函数时，会发生3件事情： 申请内存空间，保存函数体代码 将内存地址编号绑定给函数标识符（函数名） 定义函数并不会执行函数体内部代码，但是会检测函数体的语法 当调用一个函数时，也会发生3件事情： 通过函数标识符找到函数在内存中存在的位置 加上括号是一种语法格式，代表执行函数体内部的代码 调用系统调用栈，创建一个函数的栈帧片段并压入栈中 我们以函数嵌套的例子来分析它的定义和执行流程： def func1(): print(\"run ... func1\") def func2(): print(\"run ... func2\") func1() print(\"run stop\") func2() 定义函数 在Python解释器解释到到第1行、第3行的时候，会加载函数体代码，检查函数体语法，若无误则将其编译为字节码： 随后会加载函数标识符，func1与func2，并且会在内存中将函数体代码进行保存，让函数标识符与在内存中保存的函数体代码进行绑定： 如上图所示，现在还未开始执行函数，内存中已有func1，func2了。 执行函数 开始分析第9行的执行函数func2()，当Python解释器发现函数标识符加了一个括号后，知道这是要调用函数，会顺着函数名找到在内存中的函数体代码： 当开始真正执行func2()函数体代码后，系统调用栈会创建出一个独一无二的函数栈帧，函数栈帧会将函数的字节码、谁调用的它、以及函数内部定义的变量（如参数）等关键信息进行保存。 在第6行，发现又执行func1()，这个func1()是在func2()内部执行的所以Python解释器会在func2()栈帧的基础上运行func1()的代码，同理也会创建func1()函数的栈帧： 当func1()执行完毕后，发现没有返回值，则加载常量None并做为默认的返回结果，此时会一并弹出func1()的栈帧，常量None将返回给func1()的调用处： 然后func2()也执行完毕，发现没有返回值，加载常量None并做为默认的返回结果，此时会一并弹出func2()的栈帧，常量None将返回给func2()的调用处： Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-10 18:13:01 "},"Python/Python函数相关/参数详解.html":{"url":"Python/Python函数相关/参数详解.html","title":"参数详解","keywords":"","body":"形参与实参 什么是传参 将需要被处理的对象传递给函数的行为，被称为传参。 形参介绍 在定义函数时，函数需要使用1个或者多个标识符来接收到外部传递进的对象。 这个标识符就是形参： def func(x, y, z): \"\"\" :param x: 形参x :param y: 形参y :param z: 形参z :return: None \"\"\" ... 可以理解为形参是函数（工厂）的预留位置，你将“原材料”放在这些位置上才能被工厂所接收到。 实参介绍 在调用函数时，外部向函数传入的对象则被称为实参。 def func(x, y, z): \"\"\" :param x: 形参x :param y: 形参y :param z: 形参z :return: None \"\"\" ... # 传入实参1，2，3 func(1, 2, 3) 可以理解为实参是待加工的“原材料”， 需要将这些“原材料”放到指定的工厂预留位置上（形参）才能被工厂所接收。 两者关系 由于Python中一切皆引用，故实参传递给形参的也就是同一个对象，这种传参被称为引用传参。 2者总结关系有3点： 在函数调用时，实参将对象传递给形参后，对象的引用计数会+1 在函数内部，可以通过形参访问到该对象 形参与对象的绑定关系在函数调用结束后就会被取消掉 下面示例将验证形参和实参引用的都是同1个对象： x = 1 def func(x): print(id(x)) func(x) print(id(x)) # 4518684720 # 4518684720 形参定义 位置参数 函数定义时从左至右依次排列的没有特殊意义的形参被称为位置形参，位置形参必须被对象传入，多一个少一个都不行。 如果传入的不够、或者传入的过多，将会抛出异常： def func(x, y, z): ... 传少了： func(1) # TypeError: func() missing 2 required positional arguments: 'y' and 'z' 传多了： func(1, 2, 3, 4) # TypeError: func() takes 3 positional arguments but 4 were given 默认参数 默认形参是指可以不用被传递对象的形参，它拥有1个默认的对象。 如果调用函数时没有传入对象，则使用该默认的对象 如果调用函数时传入了1个对象，则使用接收到的对象 需要注意在定义默认形参时必须放在位置形参后面，否则会抛出异常。 def func(x, y, z=3): print(x, y, z) func(1, 2) func(\"A\", \"B\", \"C\") # 1 2 3 # A B C 传参方式 位置传参 如果是位置形参，则实参传入对象时必须严格按照形参的位置顺序、形参的总体数量进行传入。 如果传入的不够、或者传入的过多，将会抛出异常： def func(x, y, z): ... 传少了： func(1) # TypeError: func() missing 2 required positional arguments: 'y' and 'z' 传多了： func(1, 2, 3, 4) # TypeError: func() takes 3 positional arguments but 4 were given 关键字传参 使用位置传参时，我们要牢记形参的位置，这样比较麻烦。 可以直接通过 key = value 的形式进行传入，避免了需要记住形参位置的繁琐步骤，但是关键字传参必须放置在位置传参后面，也是个人比较推崇的一种传参方式： def func(x, y, z=3): print(x, y, z) func(y=2, x=1, z=3) func(1, z=3, y=2) # 1 2 3 # 1 2 3 *与**语法使用 *的形参接收 *语法用在形参上，代表该形参可以接收任意数量的位置传参对象。 该形参将会变成一个元组形式，接收所有的位置传参对象，这种形参必须定义在位置形参与默认形参的后面： def func(x, y=2, *args): print(x, y, args) func(1, 2, 3, 4, 5, 6, 7, 8, 9) # 1 2 (3, 4, 5, 6, 7, 8, 9) **的形参接收 **语法用在形参上，代表该形参可以接收任意数量的关键字传参对象。 该形参将会变成一个字典形式，接收所有的关键字传参对象，这种形参必须定义在位置形参与默认形参以及*形参的后面： def func(x, y=2, *args,**kwargs): print(x, y, args, kwargs) func(1, 2, 3, 4, 5, 6, 7, 8, 9, a=ord(\"a\"), b=ord(\"b\"), c=ord(\"c\")) # 1 2 (3, 4, 5, 6, 7, 8, 9) {'a': 97, 'b': 98, 'c': 99} *的实参传入 通过*语法，我们可以将1个容器序列根据位置传参的方式把其中的数据项对象传递给形参，如下所示： def func(x, y, z): print(x, y, z) func(*(1, 2, 3)) # 1 2 3 **的实参传入 通过**语法，我们也可以将1个字典根据关键字传参的方式把字典中的value对象传递给形参，如下所示： def func(x, y, z): print(x, y, z) func(**{\"x\": 1, \"y\": 2, \"z\": 3}) # 1 2 3 *args与**kwargs *形参通常命名为*args，这是一种约定的俗称。 同理，**形参则被命名为**kwargs。 指定传入方式 形参中，如果存在一个*名字的特殊标识，则该标识不用传递对象。 该标识是规定了哪些形参必须是接收位置传入的对象、哪些形参是必须接收关键字传入的对象，如下所示： def func(a, b=2, *, c=3, d): # ❶ print(a, b, c, d) func(1, d=4) ❶：在 *左边的都是位置传入，在*右边的都是关键字传入 a：位置传入，不是默认参数，则必须通过位置传参的方式传入对象 b：位置传入，是默认参数，可以不用通过位置传参的方式传入对象 c：关键字传入，不是默认参数，则必须通过关键字传参的方式传入对象 d：关键字传入，是默认参数，可以不用通过关键字传参的方式传入对象 形参的定义顺序 形参的定义顺序如下所示： 位置形参 -> 默认形参 -> *args -> **kwargs 示例演示： def func(a, b, c=\"c\", *args, **kwargs): print(\"\"\" position params: {} {} default params: {} * params:{} ** params:{} \"\"\".format(a, b, c, args, kwargs)) func(\"A\", \"B\", \"C\", 1, 2, 3, 4, 5, k1=\"v1\", k2=\"v2\") # position params: A B # default params: C # * params:(1, 2, 3, 4, 5) # ** params:{'k1': 'v1', 'k2': 'v2'} 实参的传入顺序 实参的传入顺序牢记位置传参在前，关键字传参在后即可。 或者统一使用关键字传参，示例如下： def func(a, b, c, d, e, f): pass func(\"A\", *[\"B\", \"C\"], d=\"D\", **{\"e\": \"E\", \"f\": \"F\"}) # eq： # func(\"A\", \"B\", \"C\", d=\"D\", e=\"E\", f=\"F\") 嵌套调用中*与** 当函数2作为函数1的一层外包装，我们想调用函数2的时候实际上是调用的函数1，并且参数也要完整的传递过去，该怎么做呢？ Ps：这其实是装饰器的一个前瞻知识点 def func(x, y, z): print(x, y, z) def wrapper(*args, **kwargs): func(*args, **kwargs) # ❶ ❷ wrapper(1, y=\"v1\", z=\"v2\") # 1 v1 v2 ❶：实参用 * 和 ** 拆分开， * 是位置传参，**是关键字传参 ❷：args = (1)，kwargs = {\"y\":\"v1\",\"z\":\"v2”}，然后再通过解构进行传递给func函数，func相当于接收了 func(1, y=“v1”, z=“v2”) 函数标注 Python3.5之后新增了函数标注（function annotation），即类型提示功能如下所示，仅做提示，并不会限制传递参数时的类型： def add(x: int or float, y: int or float) -> int or float: # ❶ print(x) print(y) return x + y ❶：->代表返回值，返回int或者float类型 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-10 18:20:51 "},"Python/Python函数相关/命名空间.html":{"url":"Python/Python函数相关/命名空间.html","title":"命名空间","keywords":"","body":"Python之禅 传奇的Python核心开发者，Tim Peters为我们总结了Python核心思想点，收录在了内置模块this中： >>> import this The Zen of Python, by Tim Peters Beautiful is better than ugly. Explicit is better than implicit. Simple is better than complex. Complex is better than complicated. Flat is better than nested. Sparse is better than dense. Readability counts. Special cases aren't special enough to break the rules. Although practicality beats purity. Errors should never pass silently. Unless explicitly silenced. In the face of ambiguity, refuse the temptation to guess. There should be one-- and preferably only one --obvious way to do it. Although that way may not be obvious at first unless you're Dutch. Now is better than never. Although never is often better than *right* now. If the implementation is hard to explain, it's a bad idea. If the implementation is easy to explain, it may be a good idea. Namespaces are one honking great idea -- let's do more of those! Python之禅 by Tim Peters 优美胜于丑陋（Python 以编写优美的代码为目标） 明了胜于晦涩（优美的代码应当是明了的，命名规范，风格相似） 简洁胜于复杂（优美的代码应当是简洁的，不要有复杂的内部实现） 复杂胜于凌乱（如果复杂不可避免，那代码间也不能有难懂的关系，要保持接口简洁） 扁平胜于嵌套（优美的代码应当是扁平的，不能有太多的嵌套） 间隔胜于紧凑（优美的代码有适当的间隔，不要奢望一行代码解决问题） 可读性很重要（优美的代码是可读的） 即便假借特例的实用性之名，也不可违背这些规则（这些规则至高无上） 不要包容所有错误，除非你确定需要这样做（精准地捕获异常，不写 except:pass 风格的代码） 当存在多种可能，不要尝试去猜测 而是尽量找一种，最好是唯一一种明显的解决方案（如果不确定，就用穷举法） 虽然这并不容易，因为你不是 Python 之父（这里的 Dutch 是指 Guido ） 做也许好过不做，但不假思索就动手还不如不做（动手之前要细思量） 如果你无法向人描述你的方案，那肯定不是一个好方案；反之亦然（方案测评标准） 命名空间是一种绝妙的理念，我们应当多加利用（倡导与号召） 而今天我们主要探索的内容就是这最后一句，命名空间。 以下内容将围绕Python之禅最后一句话来进行逐一解惑。 Tim Peters是一位高产的Python开发者，在Python1.0版本之前就已经贡献出大量的代码，如li.sort()的排序算法TimSort就是Tim Peters所贡献，并且最终在Python2.x版本中进行使用 NameSpaces 命名空间即存储所有标识符（变量名、函数名、类名）的地方。 它本身是一种虚拟的概念，实际上并不存在。 命名空间分为3大类： 内置命名空间（Builtin NameSpaces） 全局命名空间（Global NameSpaces） 局部命名空间（Local NameSpaces） 不同的命名空间，存储的标识符范畴也不同，如下所示： 内置命名空间：存储Python解释器自带的标识符 全局命名空间：存储未在类、函数、方法中定义的标识符 局部命名空间：在调用类、函数、方法时产生的标识符 我们以一个代码和一幅图来举例： name = \"Jack\" age = 18 gender = \"male\" def add(x , y): res = x + y return res def sub(x, y): res = x - y return res Builtin NameSpaces 内置命名空间： 存放的标识符：Python解释器自带的函数标识符、变量标识符、类标识符等，如print、input、open等... 生命周期：Python解释器启动时产生，关闭时销毁 允许的数量：至多1个 示例演示： >>> print >>> input >>> open Global NameSpaces 全局命名空间： 存放的标识符：未在类、函数、方法中定义的标识符 生命周期：Python脚本文件执行时产生，执行完毕时销毁 允许的数量：至多1个 示例演示： name = \"Jack\" age = 18 gender = \"male\" def mathFunctionSet(method, x, y): def add(x, y): res = x + y return res def sub(x, y): res = x - y return res methodNameMapping = { \"add\":add, \"sub\":sub } return methodNameMapping[method](x,y) 上述示例中共有1个全局命名空间，存储的标识符有： name age gender # 变量标识符 mathFunctionSet # 函数标识符 Local NameSpaces 局部命名空间： 存放的标识符：在调用类、函数、方法时产生的标识符 生命周期：对于函数的局部命名空间来说，函数调用时存活，调用完毕则销毁 允许的数量：可以有多个局部命名空间，取决于内存大小 示例演示： name = \"Jack\" age = 18 gender = \"male\" def mathFunctionSet(method, x, y): def add(x, y): res = x + y return res def sub(x, y): res = x - y return res methodNameMapping = { \"add\":add, \"sub\":sub } return methodNameMapping[method](x,y) 上述示例中共有3个局部命名空间，如下所示： mathFunctionSet的局部命名空间存储的标识符： method x y add sub methodNameMapping add局部命名空间存储的标识符： x y res sub局部命名空间存储的标识符: x y res 顺序相关 加载和销毁顺序 加载顺序：内置命名空间 -> 全局命名空间 -> 局部命名空间 销毁顺序：局部命名空间 -> 全局命名空间 -> 内置命名空间 命名空间封闭性 在全局命名空间中无法访问局部命名空间定义的标识符，但是局部命名空间中可以访问全局命名空间的标识符，如下所示： globalName = \"global\" def function(): localName = \"function\" print(localName) function() print(localName) # function # NameError: name 'localName' is not defined 当然，内置命名空间是在哪里都可以进行访问。 标识符查找顺序 先在自己的命名空间中找，找不到就往定义自己的命名空间中找，最后查找内置命名空间。 如下代码示例： name = \"global\" def outer(): name = \"outer\" inner() # ❷ def inner(): print(name) # ❸ outer() # ❶ 首先我们是在全局命名空间中定义了outer()函数的标识符、inner()函数的标识符以及name变量标识符。 ❶：运行outer()函数 ❷：运行inner()函数 ❸：inner()中查找name，inner()的局部命名空间中没有name标识符，往定义自己的命名空间找，即到全局命名空间，最终找到name标识符 标识符的覆盖特性 如果全局/局部命名空间与内置命名空间中的标识符发生冲突，则最先查找到全局/局部命名空间中的标识符。 这也是为什么在第一章的时候就说到标识符的命名应该避免关键字，示例如下： print(callable(input)) # ❶ input = \"..\" print(callable(input)) # ❷ # True # False ❶：input此时引用的是内置命名空间的input()函数，所以可调用 ❷：全局命名空间中已经定义了input，此时的input引用的是全局命名空间中的字符串“..”，所以不可调用 预先检测的标识符 我们来看一个有趣的例子： x = 1 def function(x): print(x) x = 1 function(x) # 1 将这个代码稍微改动： x = 1 def function(): print(x) x = 1 function() # UnboundLocalError: local variable 'x' referenced before assignment 按理说，例子2中的x会引用全局命名空间中的x，那么为何会抛出异常呢？ 我们说过，在初始化函数时，会预先检测其中的语法是否出现错误： 例子1中的x最早出现在形参中，也就是说第3行的形参中定义了x，所以下面再使用x时是没有任何问题的 例子2中的x是定义在第5行，但是在第4行里就进行了使用，违反了对象必须先声明后使用的原则，故抛出异常 方法介绍 global引入 一个例子 先看一个简单的例子吧： x = 1 # ❶ def function(): x = 3 # ❸ print(x) # ❹ function() # ❷ print(x) # ❺ # 3 # 1 图示如下： ❶：全局命名空间定义了变量x，指向内存中的1 ❷：开始调用函数function() ❸：函数function()的局部命名空间中也声明了x，并且指向内存中的3 ❹：打印x，打印语句在函数内部，所以先从function()的局部命名空间中找x，这个x指向的3 ❺：打印x，打印语句在函数外部，所以在全局命名空间中找x，这个x指向的1 所以最后的结果是：3、1 方法使用 gloabl关键词可以在函数中使用，该关键词后面出现的标识符在函数内部也可以进行使用，但是该标识符的对象会指向全局命名空间中的对象。 我们对上面例子加上一句代码，结果就变的不同了： x = 1 # ❶ def function(): global x # ❷ x = 3 # ❸、❹ print(x) # ❺ function() print(x) # ❻ # 3 # 3 如下图所示： ❶：全局命名空间定义了变量x，指向内存中的1 ❷：在函数function()执行时，引入了外部的x，指向内存中的1 ❸、❹：将x重新指向3 ❺：打印x，打印语句在函数内部，所以先从function()的局部命名空间中找x，这个x就是外部的x，指向1 ❻：打印x，打印语句在函数外部，所以在全局命名空间中找x，这个x当然也指向的1 nonlocal引入 一个例子 先看一个简单的例子吧： x = 1 def outer(): x = 2 def inner(): x = 3 print(x) inner() print(x) outer() print(x) # 3 # 2 # 1 这个参照上面的global引入图示。 第1个print()是在inner()函数的局部命名空间中打印x，所以打印了3 第2个print()是在outer()函数的局部命名空间中打印x，所以打印了2 第3个print()是在全局命名空间中打印x，所以打印了3 方法使用 nonlocal关键字与global使用相同，不同的是gloabl引用的是全局命名空间中的标识符对象，而nonlocal则是引用上层局部命名空间中的标识符对象。 将代码稍微改动，于是你便发现结果又变了： x = 1 def outer(): x = 2 def inner(): nonlocal x print(x) inner() print(x) outer() print(x) # 2 # 2 # 1 第1个print()是在inner()函数的局部命名空间中打印x，该x指向的是上层局部命名空间中的x，所以打印了2 第2个print()是在outer()函数的局部命名空间中打印x，所以打印了2 第3个print()是在全局命名空间中打印x，所以打印了3 LEGB 我们在nonlocal例子中看见了一共有4个命名空间，分别如下： 内置命名空间 全局命名空间 函数outer的局部命名空间 函数inner的局部命名空间 这样划分会显得有些杂乱，所以可以将它用新的命名方式来表示，总计划分为4层： B-Builtin(Python)：Python解释器的内置命名空间，用B来表示 G-Global(module)；函数定义所在模块（文件）的命名空间，即全局命名空间，用G来表示 E-Enclosing function locals：外部嵌套函数的命名空间，即outer的局部命名空间，用E来表示，因为它是封闭的 L-Local(function)：被嵌套的函数命名空间，即inner的局部命名空间，用L来表示，即代码执行最里层的本地空间 作用域 在很多其他的教程中，可能会有作用域的划分，将3个命名空间分为了2个作用域： 全局作用域：包含内置命名空间与局部命名空间 局部作用域：即局部命名空间 这是一种比较粗暴直白的划分，并没有命名空间的划分来的详细，本质都是1个东西，这里不再举例。 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-05-19 12:49:53 "},"Python/Python函数相关/高阶函数.html":{"url":"Python/Python函数相关/高阶函数.html","title":"高阶函数","keywords":"","body":"高阶函数 在Python中函数是一等公民，它与普通的数据项对象并没有什么区别，唯一的区别可能在于函数是能被调用的吧。 这意味着，Python中的函数可以做下面的事情： 可以赋值 可以将一个函数对象传递给另一个函数对象的形参 一个函数中可以返回另一个函数 可以将函数当做容器类型中的一个数据项元素 赋值 函数标识符本来仅是一个贴纸，指向了函数体代码在内存中的位置。 那么我们可以再加上一个贴纸标识符，让它与函数标识符指向内存中相同的位置，如下所示： def function(): print(\"function ...\") func = function func() # function ... 传参 可以将一个函数对象传递给另一个函数对象的形参，如下所示： def outer(func): print(\"start\") func() print(\"stop\") def inner(): print(\"inner ..\") outer(inner) # start # inner .. # stop 返回值 一个函数中可以返回另一个函数，这样的做法常用于嵌套定义函数。 Ps：嵌套定义函数和嵌套调用函数还是有所不同的，嵌套定义的2个函数不在同一命名空间中进行声明，而是具有包含关系，而嵌套调用的函数大部分情况在同一命名空间中进行定义声明。 def outer(): def inner(): print(\"inner\") return inner func = outer() func() # inner 因为函数具有封装线，故外部无法访问内部，但是如果E层函数主动返回L层函数，那么外部就可以拿到L层的函数进行调用。 数据项 函数可以作为容器对象中的数据项： def f1(): print(\"f1\") def f2(): print(\"f2\") def f3(): print(\"f3\") li1 = [f1, f2, f3] for func in li1: func() # f1 # f2 # f3 应用实例 函数的嵌套调用 函数的嵌套调用会很常见。 如果有2个函数，我们可以将2个函数的功能进行分类： 函数1主要负责为外部使用者提供入口，而不负责逻辑关系的处理 函数2主要负责内部逻辑关系的处理，对于外部调用者而言它是隐藏的 如下所示，我们使用2个函数来实现从1个容器类型中拿出最大数据项的功能： def getMaxValue(*args): \"\"\"interface\"\"\" currentMaxItem = args[0] for item in args[1:]: currentMaxItem = computeMaxValue(item, currentMaxItem) return currentMaxItem def computeMaxValue(x, y): \"\"\"logic\"\"\" return x if x > y else y result = getMaxValue(*[8, 1, 2, 3, 5, 4]) print(result) # 8 基于函数的封装 我们只需要在函数内部定义函数，将1堆类似功能的函数封装在1个抽象函数中即可。 如下我们定义了1个数学工具类函数，它将包含了求长方形、长发体的面积： def mathFormula(select, length, width, height=None): \"\"\"长方形，求面积输入长宽，求体积输入长宽高\"\"\" def area(length, width): \"\"\"长方形面积\"\"\" return length * width def bulk(length, width, height): \"\"\"长方体体积\"\"\" return length * width * height if select == 1: return area(length, width) elif select == 2: return bulk(length, width, height) else: print(\"输入有误\") res = mathFormula(select=1, length=20, width=20) print(res) # 400 基于函数的字典 修改学生信息的一个小例子，如下所示： studentMessage = { \"1\": {\"name\": \"Tom\", \"gender\": \"male\", \"age\": 18, \"height\": 192, \"weight\": 140}, \"2\": {\"name\": \"Jack\", \"gender\": \"male\", \"age\": 17, \"height\": 172, \"weight\": 120}, \"3\": {\"name\": \"Kelly\", \"gender\": \"female\", \"age\": 20, \"height\": 168, \"weight\": 130}, } def check(): \"\"\"查\"\"\" for item in studentMessage: print(\"学生编号:{0}\".format(item)) for key, value in studentMessage[item].items(): print(\"{0: >10} | {1: Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-10 18:33:02 "},"Python/Python函数相关/递归函数.html":{"url":"Python/Python函数相关/递归函数.html","title":"递归函数","keywords":"","body":"递归函数 递归的特性 递归（recursion）是一种函数的调用方式，简而言之就是自己调用自己。 递归可以将一个大规模的问题分解成更小的相同问题，经过持续分解到最后问题规模小到可以用非常简单直接的方式来解决，或者将一个问题拆分成不同的各个部分，达到分而解决分而治之的目的。 一个递归函数必须要满足3要素： 必须有一个基本结束条件 必须能改变问题规模 必须调用自身 如下所示，这就是一个标准的递归函数： def function(count): if count: print(count) function(count=count - 1) return function(5) # 5 # 4 # 3 # 2 # 1 回溯与递推 函数递归必然经历2个阶段，一个是回溯阶段，一个是递推阶段： 回溯：函数不断递归调用自身时的阶段被称为回溯阶段 递推：当函数退出递归调用时的阶段被称为递推阶段 下面是一个问姓名的问题，可以非常直白的阐述回溯和递推的2个概念。 首先，你问A多少岁，A会回答你他比B大10岁，然后你又问B多少岁，B会回答你它比C大10岁... 这样直至E，E说他的年龄是18岁，最后问A多少岁？ 如上图所示，当你问A年龄的时候，回溯阶段开始。 而当你得知E的年龄后，递推阶段开始，根据E反推出A年龄的过程即递推的过程。 代码表现形式如下： def getAge(n): if n == 1: return 18 return getAge(n - 1) + 10 a = getAge(5) print(a) # 58 实例练习 数据项提取 有1个不知道维度的列表，现在要将它转换为1维列表，并且按照升序进行排序： oldList = [10, 1.2, [3, 345, 2.2, [15, [88.6, [78, [89.3, 99, [50]]]]]]] newList = [] def listSort(li): for i in li: if isinstance(i, list): listSort(i) else: newList.append(i) newList.sort() listSort(oldList) print(newList) # [1.2, 2.2, 3, 10, 15, 50, 78, 88.6, 89.3, 99, 345] 爬楼梯问题 有1个n阶的楼梯，每次可以爬1个台阶或者2个台阶，求解有多少种方法爬完整个楼梯。 def climbTheStairs(n): if n == 1: return 1 # ❶ if n == 2: return 2 # ❷ return climbTheStairs(n - 1) + climbTheStairs(n - 2) # ❸ print(climbTheStairs(3)) # 3 ❶：只有1个台阶，就只有1种走法，一次走1步 ❷：只有2个台阶，就只有2中走法，一次走1步或者一次走2步 ❸：将1次走1步的算出来，将1次走2步的算出来进行相加 递归与while 递归与while循环有一些类似之处，比如都要设置结束条件，但是两者不可一概而论。 如果一个问题规模不被确定，使用递归是最好的方案。 而如果一个问题的规模已被确定，则可以使用while循环进行解决。 但是递归要比while循环的效率更加的低下，因为递归的过程中会进行函数的调用，而函数调用则必定会对内存造成更大的压力，这来源于系统调用栈的栈帧会跟随每一次递归而不断的生成。 递归的深度 系统调用栈栈帧的生成不能毫无限制，所以Python对递归的深度进行了最大1000层的限定。 你可以随时修改这个层次，但是如果问题规模过大导致递归层次过多，则可能发生爆内存的情况，因为每一次的栈帧都会保存在内存中，以下是修改递归最大深度限制的方法： >>> import sys >>> sys.setrecursionlimit(100000) # ❶ >>> sys.getrecursionlimit() # ❷ 100000 ❶：修改最大默认递归层次为10000层 ❷：获取当前最大的递归层次 尾递归优化 递归函数中，每一次的栈帧生成都是相同的。 每一个递归函数的栈帧都拥有相同的调用方（自身）、拥有相同的字节码（相同的函数）、用于相同的命名空间（标识符）。 由于栈帧在系统调用栈中会占用大量的内存，对于某些语言如Java而言，会针对递归函数做一些优化，具体是指如果1个函数是进行递归调用，则只生成1个栈帧。 这种优化策略能够极大的减少内存空间的占用，也被称之为尾递归优化。 遗憾的是，Python并未实现尾递归优化。 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-05-18 19:22:52 "},"Python/Python函数相关/匿名函数.html":{"url":"Python/Python函数相关/匿名函数.html","title":"匿名函数","keywords":"","body":"匿名函数 匿名函数即没有名字的函数，最早出现在LISP语言中，Python对其进行了引用。 匿名函数的作用就是在不丧失代码可读性的前提下为精简代码提供的一种方式，以下是定义匿名函数的语法，通过lambda关键字进行定义。 注意！函数不管有名没名，都必须先定义后使用 语法如下： lambda 形参1, 形参2 ... : 返回值 # ❶ ❷ ❶：形参可以有多个，也可以没有 ❷：返回值不用跟return，直接写逻辑语句即可，将会自动的把逻辑语句的结果进行返回 定义和使用匿名函数的实际示例，求2个数的和： res = (lambda x, y : x + y)(1, 2) print(res) 匿名函数常用于定义一些非常简单的逻辑，不支持多行，因此要尽量写的简洁易懂。 使用方式 为匿名函数取名 匿名函数也可以通过一个标识符进行命名，但是一般都不会这样做： add = lambda x, y : x + y res = add(1, 2) print(res) # 3 自执行和自销毁 自执行函数即定义了匿名函数之后就立刻加括号调用，这种函数只会运行一次。 并且由于没有标识符的引用绑定关系，故使用完成后就会被GC机制所立即回收掉： res = (lambda x, y : x + y)(1, 2) # ❶ print(res) # 3 ❶：自执行的匿名函数必须在括号中进行定义 内置函数搭配使用 匿名函数常用于与内置函数进行搭配使用，如下将使用内置函数max()搭配匿名函数求得下列薪资最高的人员名字： salaries = { 'Ken': 3000, 'Tom': 7000, 'Jack': 2000 } name = max(salaries, key=lambda k: salaries[k]) # ❶ print(name) ❶：max()函数的key参数可指定1个函数，此时函数的返回结果就是本次求最大值的对比条件，这个例子就是指定薪资作为对比条件 常用搭配函数 lambda表达式与一些函数配合，才能发挥出最大的威力。 Python中出名的诸如map()、filter()、reduce()函数等均来自Lisp语言的设计，它们实在是太方便了，其实说到底一门优秀的语言必定大量借鉴了其他语言的优秀特性。 max()与min() max()函数用于从1个可迭代对象中返回最大的数据项，而min()是返回最小的，其他都一样。 max()函数签名如下： def max(*args, key=None): pass 参数详解： args：一个可迭代对象，拥有1个形参 key：传入1个可调用对象（通常是指函数），指定本次的大小对比方式，默认是根据数据项值本身对比 默认比对是比对的值本身，如果是字典则拿key的值进行比对，以下示例中，由于C的ASCII码比A大，所以返回了C： dic = {\"A\": 100, \"B\": 50, \"C\": 20} res = max(dic) print(res) # C 传入参数key，修改对比方式为字典的value，那么最后A的value最大，故返回A： dic = {\"A\": 100, \"B\": 50, \"C\": 20} res = max(dic, key=lambda k:dic[k]) print(res) # A 手动实现max()函数： from collections.abc import Iterable def customizeMax(*args, key=None): def default(args): \"\"\"默认对比规则\"\"\" it = iter(args) if not isinstance(args[0], Iterable) else iter(args[0]) currentMaxItem = next(it) for item in it: if currentMaxItem map() map()函数会从一个可迭代对象中依次取出1个数据项，并且会按照指定函数对数据项进行处理，处理完成后生成新的map可迭代对象并返回该map可迭代对象。 map()函数签名如下： def __init__(self, func, *iterables): pass 参数详解： func：一个可调用对象（通常是指函数），拥有1个形参，对iterables的数据项进行遍历并将返回值加入至新的map容器中，迭代完成后返回新的map容器 iterables：一个可迭代对象 其实map()能做的推导式都能做，如将整个可迭代对象中的数据项+100，并返回新的可迭代对象： newMapObject = map(lambda x:x+100, range(10)) print(list(newMapObject)) newList = [(lambda x:x+100)(i) for i in range(10)] print(newList) # [100, 101, 102, 103, 104, 105, 106, 107, 108, 109] # [100, 101, 102, 103, 104, 105, 106, 107, 108, 109] 手动实现map()函数： from collections.abc import Iterable def customizeMap(func, *iterables): it = iter(iterables) if not isinstance(iterables[0], Iterable) else iter(iterables[0]) for item in it: yield func(item) print(list(customizeMap(lambda x:x + 100, range(10)))) # [100, 101, 102, 103, 104, 105, 106, 107, 108, 109] filter() filter()函数会从一个可迭代对象中依次取出1个数据项，并且会按照指定函数对数据项进行筛选，符合条件的数据项加入新的filter对象中，不符合条件的数据项会直接丢弃，当遍历完整个可迭代对象后会返回新的filter对象。 filter()函数签名如下： def __init__(self, function_or_None, iterable): pass 参数详解： function_or_None：一个可调用对象（通常是指函数），拥有1个形参，指筛选条件，如果是None则筛选条件，此时会按照数据项本身的布尔值进行筛选 iterable：一个可迭代对象 其实filter()能做的推导式都能做，如遍历整个容器对象，将是偶数的数据项筛选出来： newFilterObject = filter(lambda x: x % 2 == 0, range(10)) print(list(newFilterObject)) newList = [i for i in range(10) if i % 2 == 0] print(newList) # [0, 2, 4, 6, 8] # [0, 2, 4, 6, 8] 手动实现filter()函数： def customizeFilter(function_or_None, iterable): it = iter(iterable) if function_or_None is None: for item in it: # 若没有指定筛选函数，则按照数据项本身的布尔值进行筛选 if item: yield item for item in it: res = function_or_None(item) if res: yield item print(list(customizeFilter(lambda x: x % 2 == 0, range(10)))) # [0, 2, 4, 6, 8] reduce() reduce()函数有1个初始值，你可以指定该初始值或者不指定。 每次对可迭代对象数据项进行迭代后，都会调用函数处理该数据项，并且将该数据项与初始值进行操作。 常用于累积运算，如累加，累乘等。 虽然该函数在Python3中已经被移除至内置函数的范畴，但是其强大的功能却很少被人熟练应用。 reduce()函数签名如下： def reduce(function, sequence, initial=None): pass 参数详解： function：一个可调用对象（通常是指函数），拥有2个形参，接收来自可迭代对象的2个数据项 sequence：一个可迭代对象 initial：一个初始值，它会随着可调用对象传入的参数进行运算而不断的改变，最终返回 简单的使用示例，求1 - 100的累加总和： from functools import reduce seqSum = reduce(lambda x,y:x+y, range(1, 101)) print(seqSum) # 5050 使用reduce()能够快速的完成寻求最大最小值的操作： from functools import reduce seqMax = reduce(lambda x, y: x if x > y else y, [1, 5, 10, 100, 399, 29]) print(seqMax) # 399 如果指定了初始值，那么则在初始值的基础上进行操作，如下所示初始值是English，每次的x，y进行相加后会再与初始值进行相加，最后会返回初始值： from functools import reduce seqSumStr = reduce(lambda x, y: x + y, [chr(i) for i in range(65, 65 + 26)], \"English:\") print(seqSumStr) # English:ABCDEFGHIJKLMNOPQRSTUVWXYZ 手动实现reduce()函数，了解底层实现原理： def customizeReduce(function, sequence, initial=None): it = iter(sequence) if initial: value = initial else: value = next(it) for item in it: value = function(value, item) return value seqSum = customizeReduce(lambda x, y: x + y, range(1, 101)) print(seqSum) seqMax = customizeReduce(lambda x, y: x if x > y else y, [1, 5, 10, 100, 399, 29]) print(seqMax) seqSumStr = customizeReduce(lambda x, y: x + y, [chr(i) for i in range(65, 65 + 26)], \"English:\") print(seqSumStr) # 5050 # 399 # English:ABCDEFGHIJKLMNOPQRSTUVWXYZ sorted() sorted()函数可以将一个可迭代对象传入，返回一个经过排序的列表，默认是升序排序。 第一参数：可迭代对象 第二参数，关键字key：一个可调用对象（通常是指函数），拥有1个形参，返回结果即为排序的对比规则，如不指定则按照Python默认排序对比规则进行排序对比 第三参数，关键字reverse：一个布尔值，当排序完成后是否对新列表进行翻转，默认是False即不翻转整个列表，如果是True则进行翻转，相当于对可迭代对象进行降序排序 sorted()函数与li.sort()方法的区别在于它会返回一个新的排好序的列表，而li.sort()则是原地排序。 此外sorted()函数支持对字典排序，这样做会返回1个包含字典key的列表，而li.sort()方法仅支持对列表排序。 使用如下，按照哈希值进行排序，并且翻转整个新的排序列表： newList = sorted([chr(i) for i in range(65, 65 + 26)], key=lambda item: hash(item), reverse=True) print(newList) # ['X', 'J', 'R', 'L', 'Q', 'C', 'U', 'T', 'M', 'O', 'I', 'Y', 'A', 'V', 'S', 'N', 'D', 'E', 'G', 'K', 'W', 'F', 'H', 'Z', 'B', 'P'] reversed() reversed()函数不可与lambda表达式进行搭配，放到这里的主要原因是因为它与sorted()的reverse参数、li.sort()的reverse参数作用相同，用于生成一个被翻转过后的新列表，如下所示，返回的结果是一个reversed可迭代对象，必须将它转换为list或者tuple后才能查看其中数据项： print( tuple(reversed([i for i in range(10)])) ) # (9, 8, 7, 6, 5, 4, 3, 2, 1, 0) 注意：该方法是生成新的对象，而不是原地翻转。 版本区别 Python2中的reduce()是内置模块，直接使用即可。 并且Python2中的map()、filter()的返回结果均为列表，而不是map对象和filter对象。 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-10 18:38:24 "},"Python/Python函数相关/内置函数.html":{"url":"Python/Python函数相关/内置函数.html","title":"内置函数","keywords":"","body":"查看方式 Python3中常用的内置函数可通过导入builtins模块查看： print(builtins.__dict__) 下面将挑选常用的且以前很少使用的内置函数进行示例。 基础 常用函数： 函数 返回值 描述 关注度 help() None 打印对象下的doc文档注释信息 5 hash() int 返回不可变对象的hash表现形式 5 id() int 返回对象在内存中的标识，即地址空间编号 5 print() None 向终端输入一则信息 5 input() str 获得用户在终端中输入的内容 5 open() fileObject 打开一个文件，获得文件句柄 5 exit() None 关闭并退出当前的Python解释器 3 quit() None 与exit()相同 3 help()获得帮助文档： >>> help(int) Help on class int in module builtins: class int(object) | int(x=0) -> integer | int(x, base=10) -> integer ... exit()和quit()都是退出解释器，结束脚本的继续执行。 类型转换 常用函数： 函数 返回值 描述 关注度 bool() bool 返回对象的布尔值 5 int() int 返回整形 5 float() float 返回浮点型 5 str() str 返回字符串 5 bytes() bytes 返回字节串 5 list() list 返回列表 5 tuple() tuple 返回元组 5 dict() dict 返回字典 5 set() set 返回集合 5 frozenset() frozenset 返回不可变集合 5 数学 常用函数： 函数 返回值 描述 关注度 hex() str 传入整形，返回其16进制表现形式 5 oct() str 传入整形，返回其8进制表现形式 5 bin() str 传入整形，返回其2进制表现形式 5 divmod() tuple 返回x与y的整除结果与求余结果 5 pow() int 返回x的y次乘阶 3 round() int 对数字的小数位数进行四舍五入 2 abs() int 返回参数的绝对值 2 divmod()返回x与y的整除结果与求余结果： >>> divmod(10, 3) (3, 1) 相当于10 // 3，10 % 3。 pow()返回x的y次乘阶，相当于x ** y： >>> pow(3, 3) 27 round()对数字的小数位数进行四舍五入： >>> round(3.4) 3 >>> round(3.5) 4 abs()返回参数的绝对值： >>> abs(-1) 1 字符串 常用函数： 函数 返回值 描述 关注度 chr() str 传入整形，将其转换为Unicode的16进制编码表现形式 5 ord() int 传入单个Unicode字符，将其转换为整形 5 ascii() str 返回对象的纯ASCII表示形式 1 format() str 获得对象内部双下format()方法的结果 1 repr() str 返回对象的规范字符串表示形式 2 eval() any 执行一个字符串形式的Python语句，并且返回执行结果 3 exec() any 执行一个字符串形式的Python语句，不会返回执行结果 3 repr()返回对象的规范字符串表示形式，相当于%r： >>> repr(1) '1' >>> 1 1 eval()执行一个字符串形式的Python语句，并且返回执行结果： >>> string = \"1 + 2\" >>> res = eval(string) >>> res 3 exec()执行一个字符串形式的Python语句，不会返回执行结果： >>> string = \"print('hello world')\" >>> exec(string) hello world 容器 常用函数： 函数 返回值 描述 关注度 len() int 返回容器中的项目数 5 slice() sliceObject 返回索引切片对象 2 iter() iterator 调用对象的双下iter()方法，获得专属迭代器 4 next() Item 从迭代器返回下一个数据项 4 range() rangeObject 返回range可迭代对象 5 enumerate() enumerateObject 返回可迭代对象的枚举类型 5 zip() zipObject 接收2个可迭代对象，将其合并为1个可迭代对象并返回，拉链函数 3 max() item 返回容器中最大的数据项 4 min() item 返回容器中最小的数据项 4 sum() int or float 迭代一个可迭代对象，并对其中数据项进行累加，返回求和结果 4 map() mapObject 对一个可迭代对象进行遍历，并对其中数据项挨个做操作，处理完成后返回map对象 5 filter() filterObject 对一个可迭代对象进行遍历，将符合条件的数据项返回至新的filter对象中 5 sorted() list 对一个容器进行排序，返回新的容器 5 reversed() reversedObject 对一个容器进行翻转，返回新的reversed对象 5 all() bool 如果容器中的数据项均为真，则返回True，否则返回False，若是空容器返回True 3 any() bool 如果容器中的数据项有1个为真，则返回True，否则返回False，若是空容器返回False 3 iter()和next()在迭代器一章节中会详细介绍。 zip()接收2个可迭代对象，将其合并为1个可迭代对象并返回，拉链函数： >>> li1 = [\"k1\", \"k2\", \"k3\"] >>> li2 = [\"v1\", \"v2\", \"v3\"] >>> list(zip(li1, li2)) [('k1', 'v1'), ('k2', 'v2'), ('k3', 'v3')] 可以用它快速将2个列表合成1个字典： >>> dict(zip(li1, li2)) {'k1': 'v1', 'k2': 'v2', 'k3': 'v3'} sum()迭代一个可迭代对象，并对其中数据项进行累加，返回求和结果： >>> sum(range(1, 101)) 5050 all()如果容器中的数据项均为真，则返回True，否则返回False，若是空容器返回True： >>> all([1,None,0]) False >>> all([(),{},[],None,0]) False >>> all([]) True any()如果容器中的数据项有1个为真，则返回True，否则返回False，若是空容器返回False： >>> any([1,None,0]) True >>> any([(),{},[],None,0]) False >>> any([]) False 面向对象 常用函数： 函数 返回值 描述 关注度 type() str 获得对象的类型 4 callable() bool 返回对象是否可调用 4 dir() list 返回对象的所有类实现方法，以及类属性 5 vars() dict 当不传入对象时相当于locals()方法，传入对象后相当于调用对象底层的双下字典 1 hasattr() bool 判断一个对象下某一个属性或者方法是否存在 5 getattr() attr 获取一个对象下某一个属性或者方法 5 setattr() None 新增或者设置一个对象的属性或者方法 5 delattr() None 删除一个对象下某一个属性或者方法 5 isinstance() bool 返回对象是类的实例还是子类的实例 5 issubclass() bool 判断一个类是否是另一个类的子类 5 super() method 调用父类的同名方法 5 type()函数已经见过了，其他函数将放在面向对象一栏中详细介绍。 作用域 常用函数： 函数 返回值 描述 关注度 globals() dict 返回全局命名空间的字典 2 locals() dict 返回当前代码执行的局部命名空间的字典 2 没什么用，完全可以不在意。 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-05-20 15:32:05 "},"Python/Python函数相关/装饰器.html":{"url":"Python/Python函数相关/装饰器.html","title":"装饰器","keywords":"","body":"装饰器 开闭原则 根据设计模式中的6大设计原则中的开闭原则来说，一个良好的项目应该具有以下2个特性： 对扩展开放：项目应当具有良好的扩展性 对修改关闭：当项目需要做功能变更时，不应该修改源代码，而应该增添新的功能，达到热插拔的效果 装饰器 装饰器（decorator）的功能就是在不违背开闭原则的前提下为一个原有功能增加上一些新的功能。 但是原有功能的调用、源代码都不会被修改，类似于一种在外部打补丁的方式。 装饰器有函数装饰器，类装饰器等分别，这里介绍函数装饰器，其实它们的运行原理都是相同的。 功能需求 我们有2个函数，upload()和download()，现在有1个需求，分别求出2个函数的运行时间。 同时还有3点限制： 不能修改源函数内部代码 不能改变源函数的调用方式 要以最精简的代码量完成需求 源代码如下： import time import random def download(fileName): time.sleep(random.randint(1, 3)) return \"下载文件{}完成\".format(fileName) def upload(fileName): time.sleep(random.randint(1, 3)) return \"下载文件{}完成\".format(fileName) downResult = download(\"testDownload.text\") upResult = upload(\"testUpload.text\") 解决过程 外部代码 最简单的方式是添加外部代码，来看一下效果： import time import random def download(fileName): time.sleep(random.randint(1, 3)) return \"下载文件{}完成\".format(fileName) def upload(fileName): time.sleep(random.randint(1, 3)) return \"下载文件{}完成\".format(fileName) downStartTime = time.time() downResult = download(\"testDownload.text\") downEndTime = time.time() downTotalTime = downEndTime - downStartTime print(\"函数:{} 运行共花费时长:{}\".format(download.__name__, downTotalTime)) upStartTime = time.time() upResult = upload(\"testUpload.text\") upEndTime = time.time() upTotalTime = upEndTime - upStartTime print(\"函数:{} 运行共花费时长:{}\".format(upload.__name__, downTotalTime)) # 函数:download 运行共花费时长:2.002652883529663 # 函数:upload 运行共花费时长:2.002652883529663 优点： 没有改变源函数的调用方式 没有修改源函数内部代码 缺点： 代码冗余量过大，每一次函数执行都至少要添加4行代码（开始时间，结束时间，总计时间，打印语句） 传参方式 对上述代码进行优化，再来看看效果： import time import random def showTotalRunTime(func, *args, **kwargs): startTime = time.time() res = func(*args, **kwargs) endTime = time.time() totalTime = endTime - startTime print(\"函数:{} 运行共花费时长:{}\".format(func.__name__, totalTime)) return res def download(fileName): time.sleep(random.randint(1, 3)) return \"下载文件{}完成\".format(fileName) def upload(fileName): time.sleep(random.randint(1, 3)) return \"下载文件{}完成\".format(fileName) downResult = showTotalRunTime(download, \"testDownload.text\") upResult = showTotalRunTime(upload, \"testUpload.text\") print(downResult) print(upResult) 优点： 极大的减少了代码冗余量 没有修改源函数内部代码 缺点： 改变了源函数的调用方式，若想在使用原本功能的前提下获得统计时长的功能，则必须运行showTotalRunTime()函数 闭包函数 闭包函数介绍 闭包函数是装饰器的核心知识点。 闭函数通常是指L层的函数，即被嵌套定义在另一个函数中的函数 包函数通常是指E层的函数，即该函数的内部嵌套定义了另一个函数 它的基本概念在于： 标识符的查找顺序以定义阶段为标准。当前命名空间没找到名字时则往定义自己的命名空间中查找标识符。 如下所示，这就是一个完整的闭包函数： def outer(): # ❶ def inner(): # ❷ pass return inner ❶：outer()函数是包函数 ❷：inner()函数是闭函数 闭包方案 在闭包函数中，E层的包函数命名空间里所有的标识符对象都不会被销毁（即使包函数已经进行了return），在L层的闭函数中，可以通过命名空间标识符向上查找的特性拿到E层包函数的命名空间标识符。 故我们可以使用闭包函数来进行问题的解决，下面的warpper()函数其实就是装饰器函数： import time import random def warpper(func): def inner(*args, **kwargs): startTime = time.time() res = func(*args, **kwargs) # ❹ endTime = time.time() totalTime = endTime - startTime print(\"函数:{} 运行共花费时长:{}\".format(func.__name__, totalTime)) return res return inner def download(fileName): time.sleep(random.randint(1, 3)) return \"下载文件{}完成\".format(fileName) def upload(fileName): time.sleep(random.randint(1, 3)) return \"下载文件{}完成\".format(fileName) download = warpper(download) # ❶ upload = warpper(upload) # ❷ downResult = download(\"testDownload.text\") # ❸ print(downResult) upResult = upload(\"testUpload.text\") print(upResult) ❶：调用warpper()函数，func形参存储的对象为download()函数，并返回inner()函数，此时外部的download标识符指向了inner()函数 ❷：调用warpper()函数，func形参存储的对象为upload()函数，并返回inner()函数，此时外部的upload标识符指向了inner()函数 ❸：调用download标识符所指向的inner()函数，并且传入了参数”testDownload.text”，开始执行inner()函数 ❹：在L层命名空间找func标识符，找不到，向上找到E层的命名空间，找到了func标识符形参，指向了download()函数，执行download()函数 ... 可以看到，通过闭包函数完美的完成了需求。 优点： 极大的减少了代码冗余量 没有修改源函数内部代码 在没有改变了源函数的调用方式前提下，新增了计时的功能 缺点： 我们必须对源函数做1个包装，将它的标识符由指向源函数改为指向为包函数的返回值，即闭函数，每一个需要增加统计时长功能的函数都要添加这样的一行代码，即❶，❷处。 整个过程图示，注意查看全局命名空间的标识符指向改变： @语法糖 无参装饰器 针对闭包方案的缺点，我们可以使用@语法糖的形式来进行进一步改进。 @语法糖内部会做2件事情： 自动加括号执行@后面的函数名，并且将@下面的被装饰函数当做第1个参数传入（注意，这个自动调用仅调用一次，当嵌套层数过多时则不会自动调用） 自动将@下面的被装饰函数的标识符重新指向内层返回的闭函数 如下所示： import time import random def warpper(func): def inner(*args, **kwargs): startTime = time.time() res = func(*args, **kwargs) endTime = time.time() totalTime = endTime - startTime print(\"函数:{} 运行共花费时长:{}\".format(func.__name__, totalTime)) return res return inner @warpper # ❶ def download(fileName): time.sleep(random.randint(1, 3)) return \"下载文件{}完成\".format(fileName) @warpper def upload(fileName): time.sleep(random.randint(1, 3)) return \"下载文件{}完成\".format(fileName) downResult = download(\"testDownload.text\") # ❷ print(downResult) upResult = upload(\"testUpload.text\") print(upResult) ❶：Python解释器检查语法，发现函数头上有个@装饰器函数，开始做2件事情: 自动调用warpper()函数，并且将@下面被装饰函数download()当做参数传递给func参数 自动将@下面的被装饰函数的标识符download重新指向内层返回的闭函数inner ❷：此时执行的download()函数其实是inner()函数，inner()函数执行时发现要找func，L层命名空间没有func，则往定义自己的warpper()函数的E层命名空间找func，找到了func指向的是download()函数，然后执行并返回 为了验证上面的例子，我们可以打印一下download的__name__属性进行查看： @warpper def download(fileName): time.sleep(random.randint(1, 3)) return \"下载文件{}完成\".format(fileName) print(download.__name__) # inner 如果不加装饰器呢？ def download(fileName): time.sleep(random.randint(1, 3)) return \"下载文件{}完成\".format(fileName) print(download.__name__) # download @手动传参 @如果手动加括号会怎么样？它会将执行结果对象返回给被装饰器函数的标识符。 如下示例，首先是打印了int类型的帮助信息，然后返回了一个None，func指向了None，如果func加上括号进行调用，则会抛出异常： @help(int) def func(): print(\"func...\") # Help on class int in module builtins: # # class int(object) # | int(x=0) -> integer # | int(x, base=10) -> integer func() # TypeError: 'NoneType' object is not callable 有参装饰器 一个新的需求： 下载或时候如果用户是普通用户，则享用10M带宽，如果是VIP用户，则享用100M带宽 如果用@语法糖来解决这个问题，则需要在外部再嵌套一层函数： import time import random def outer(genre): def warpper(func): def inner(*args, **kwargs): if genre == \"VIP\": print(\"欢迎您，尊贵的VIP用户，您的下载速度是100M/s\") else: print(\"欢迎您，亲爱的普通用户，您的下载速度是10M/s\") startTime = time.time() res = func(*args, **kwargs) endTime = time.time() totalTime = endTime - startTime print(\"函数:{} 运行共花费时长:{}\".format(func.__name__, totalTime)) return res return inner return warpper @outer(genre=\"VIP\" if random.randint(1, 2) == 1 else \"common\") def download(fileName): time.sleep(random.randint(1, 3)) return \"下载文件{}完成\".format(fileName) downResult = download(\"testDownload.text\") print(downResult) 执行流程如下： 手动调用一次outer()函数，并且为genre传入参数，返回了warpper()函数。 此时会变成这个样子，由于手动在装饰器函数后面加了括号，所以本次的返回值会依然当做装饰器添加在头上，并不会改变download()： @warpper def download(fileName): pass 自动调用一次（仅一次）warpper()函数，并且将@下面被装饰函数download()当做参数传递给func参数 自动将@下面的被装饰函数的标识符download重新指向内层的inner()函数 此时执行的download()函数其实是inner()函数，然后根据命名空间查找特性，找到genre形参变量标识符与func形参函数标识符 @自动执行 Python中的@语法糖对闭包函数只会自动的执行1次，如下所示： def warpper(x): print(\"执行第1次，返回f1\") def f1(x): print(\"执行第2次，返回f2\") def f2(x): print(\"执行第3次，返回None\") return f2 return f1 @warpper def func(): ... # 执行第1次，返回f1 而我们手动的对@后的函数进行调用，则在1层自动执行的基础上又加上了1次手动执行： def warpper(x): print(\"执行第1次，返回f1\") def f1(x): print(\"执行第2次，返回f2\") def f2(x): print(\"执行第3次，返回None\") return f2 return f1 @warpper(\"x\") def func(): ... # 执行第1次，返回f1 这是手动执行的1次 # 执行第2次，返回f2 这是自动执行的1次 也就是说Python的@语法最大仅能支持3层嵌套定义的闭包函数，如果太深则里面的就拿不到了，因为你不能手动调用2次，这样会抛出语法错误： @warpper(\"x\")(\"c\") def func(): ... # SyntaxError: invalid syntax 多个装饰器 多个装饰器叠放的场景你今后肯定会遇见，只需要记住一句话即可： 定义顺序自下而上，执行顺序自上而下 如下所示： def f1(func): print(\"定义f1装饰器\") def inner(*args, **kwargs): print(\"执行f1装饰器\") func() return inner def f2(func): print(\"定义f2装饰器\") def inner(*args, **kwargs): print(\"执行f2装饰器\") func() return inner @f1 @f2 def func(): ... func() # 定义f2装饰器 # 定义f1装饰器 # 执行f1装饰器 # 执行f2装饰器 流程分析： # Python解释器执行到 @f1 时，想自动运行一下，发现下面被装饰的不是一个函数，就不自动运行了 # Python解释器执行到 @f2 时，想自动运行一下，发现下面被装饰的是一个函数，于是开始自动运行 # print(\"定义f2装饰器\") # 然后返回了 inner 函数，现在 func -> inner 函数，变成了这个样子 # # @f1 # def func(): # ... # # 然后，Python解释器发现 @f1 下面是一个函数了，于是开始自动运行 # print(\"定义f1装饰器\") # 然后又返回 inner 函数，现在 func -> 新的 inner 函数 # # Python解释器继续向下走，发现 func() # 由于 func -> 新的 inner 函数 故开始运行 f1的 inner 函数： # print(\"执行f1装饰器\") # 打印完成后又要执行 func() # 那么这里的 func 是旧的 inner 函数，故开始运行f2的 inner 函数： # print(\"执行f2装饰器\") @wraps分析 @wraps其实是functiontools中自带的一款有参装饰器，它能够做到很好的隐藏功能。 如，普通装饰器的标识符被改变指向为L层函数后，通过查看__name__还是会看到原本L层函数的名字： def warpper(func): def inner(*args, **kwargs): result = func() return result return inner @warpper def func(): ... print(func.__name__) # inner 如果对内层L函数加上@wraps后，就会将内层函数的大部分属性变为原本标识符所指向的被装饰函数，如下所示： from functools import wraps def warpper(func): @wraps(func) def inner(*args, **kwargs): result = func() return result return inner @warpper def func(): ... print(func.__name__) # func 这个仅是换了1个属性，实际上内存地址还是inner的，通过以下示例进行验证： from functools import wraps def warpper(func): @wraps(func) def inner(*args, **kwargs): result = func() return result print(\"内部打印 inner() 函数的内存地址\", id(inner)) return inner @warpper def func(): ... print(\"内部打印 func 所指向函数的内存地址\", id(func)) # 内部打印 inner() 函数的内存地址 4451701896 # 内部打印 func 所指向函数的内存地址 4451701896 装饰器模板 无参装饰器 from functools import wraps def warpper(func): @wraps(func) def inner(*args, **kwargs): # 开始前的逻辑 result = func() # 结束后的逻辑 return result return inner @warpper def func(): ... func() 有参装饰器 from functools import wraps def warpper(*args, **kwargs): def outer(func): @wraps(func) def inner(*args, **kwargs): # 参数的使用 # 开始前的逻辑 result = func() # 结束后的逻辑 return result return inner return outer @warpper(k1=\"v1\") def func(): ... func() Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-10 18:46:54 "},"Python/Python函数相关/迭代器.html":{"url":"Python/Python函数相关/迭代器.html","title":"迭代器","keywords":"","body":"迭代器 迭代是什么 迭代指的是一个重复的过程，每次重复都必须基于上一次的结果而继续，单纯的重复并不是迭代，如Python中的for循环就是一个非常好的迭代例子。 for item in range(10): print(item) 迭代必须向前推进，不能后退，如下所示： # [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] # ------------------------------> 下面这种方式就不属于迭代： # [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] # --------> # 迭代器协议 在学习迭代器的整个知识点中，迭代器协议占据了非常重要的位置。 迭代器协议中包含了2个最基本的概念，分别是可迭代对象和迭代器对象。 可迭代对象（Iterable）：内部实现了__iter__()方法的对象则被称为可迭代对象 迭代器对象（Iterator）：内部实现了__next__()方法的对象则被称之为迭代器对象 两者之间的关系： 在Python中，迭代器对象一定属于可迭代对象范畴，也就说迭代器对象必须具有__iter__()方法以及__next__()方法 在Python中，可迭代对象不一定属于迭代器对象范畴，也就是说可迭代对象只需要实现__iter__()方法即可 介绍2个函数： iter(Object)函数，它底层会执行Object.__iter__()方法 next(Object)函数，它底层会执行Object.__next__()方法 内置类型 通过collections.abc下的Iterable类和Iterator类进行判定，可快速的判定出所有内置类型是否是一个可迭代对象或者迭代器对象： >>> from collections.abc import Iterable >>> from collections.abc import Iterator >>> isinstance(list(), Iterable) True >>> isinstance(list(), Iterator) False 经过测试，所有的容器类型（list、tuple、str、dict、set、frozenset）均属于可迭代对象，但不属于迭代器对象 原子类型（bool、int、float、None）等均不属于可迭代对象，更不属于迭代器对象。 也可以通过另一种方式进行验证，通过hasattr()函数，检查类中是否定义了某一个方法： >>> hasattr(list,\"__iter__\") True >>> hasattr(list,\"__next__\") False 迭代原理 当可迭代对象被for循环进行调用后，底层执行流程如下所示： 将自动的执行iter()方法，该方法内部会查找可迭代对象的__iter__()方法，如果具有该方法，则返回一个该可迭代对象的专属迭代器对象，如果没有该方法，则抛出TypeError object is not iterable的异常。 Ps：每次的for循环都会返回一个全新的迭代器对象 不断的调用迭代器对象的__next__()方法，并且返回迭代器对象中下一个数据项，当遍历完成整个迭代器后，引发Stopiteration异常终止迭代 Ps：迭代器本身并不存储任何数据项，存储的只是一个指针，该指针指向可迭代对象中真正存储的数据项，它指向当前被遍历到的数据项索引位置，下一次遍历则向后推进这个位置 for循环自动的捕捉Stopiteration异常，并且停止迭代 Ps:for循环底层就是while循环实现的，只不过多加了3个步骤： 第一步：执行可迭代对象的__iter()__方法并保存返回的专属迭代器 第二步：不断的执行迭代器的__next()__方法 第三步：捕获Stopiteration异常 我们手动的实现一个for循环： li1 = list(range(10)) iteratorObject = iter(li1) # ❶ while 1: try: print(next(iteratorObject)) # ❷ except StopIteration as e: # ❸ break ❶：执行可迭代对象的__iter__()方法并保存返回的专属迭代器 ❷：不断的执行迭代器的__next__()方法 ❸：捕获Stopiteration异常 线性可迭代对象与迭代器的实现 如果是一个线性容器的可迭代对象，那么它一定具有索引值，我们可以让它的__iter__()方法返回一个专属的迭代器对象。 然后专属迭代器对象中记录本次迭代遍历的索引值，根据这个索引值返回可迭代对象中的数据项，当索引值达到可迭代对象中数据项总个数-1的时候，抛出异常，本次迭代结束： class LinearTypeContainer: def __init__(self, array): if isinstance(array, list) or isinstance(array, tuple): self.array = array else: raise TypeError(\"argument array must is linear container\") def __iter__(self): return LinearContainer_iterator(self.array) # ❶ class LinearContainer_iterator: def __init__(self, array): self.index = 0 self.array = array self.len = len(self.array) def __next__(self): if self.index ❶：Python中的一切传参均为引用传递 故LinearTypeContainer中的self.array和LinearContainer_iterator的self.array都是一个对象，并不会额外开辟内存空间 这也就是为什么可迭代对象创建的专属迭代器不会消耗太多的内存空间原因了。 ❷：迭代器对象一定属于可迭代对象范畴，所以在这里我们为迭代器对象LinearContaineriterator类也新增了\\_iter__()方法 这样做的好处在于如果单独的拎出了这个迭代器对象，则它也会支持for循环的遍历： def __iter__(self): return self containerIterator = LinearTypeContainer([i for i in range(10)]).__iter__() for item in containerIterator: print(item) # 0 # 1 # 2 # 3 # 4 # 5 # 6 # 7 # 8 # 9 如果取消了linearContaineriterator类的这个\\_iter__()方法，则不支持for循环的遍历： # def __iter__(self): # return self containerIterator = LinearTypeContainer([i for i in range(10)]).__iter__() for item in containerIterator: print(item) # TypeError: 'LinearContainer_iterator' object is not iterable 非线性可迭代对象与迭代器实现 如果是一个非线性容器的可迭代对象，可以先判断它的类型，如果传入的容器是一个字典，则将迭代的数据项集合转换为元组，里面存储的全部是字典的key即可。 如果传入的容器是一个集合，则将迭代的数据项集合转换为元组，再参照线性可迭代对象与迭代器的实现。 具体实现： class MappingTypeContainer: def __init__(self, mapping): self.mapping = mapping if not ( isinstance(self.mapping, dict) or isinstance(self.mapping, set) or isinstance(self.mapping, frozenset) ): raise TypeError(\"argument mapping must is mapping container\") def __getattr__(self, name: str): try: return dict.__getattribute__(self.mapping, name) except AttributeError: return set.__getattribute__(self.mapping, name) def __str__(self): return str(self.mapping) def __iter__(self): return MappingContainer_iterator(tuple(self.mapping)) class MappingContainer_iterator: def __init__(self, array): self.index = 0 self.array = array self.len = len(self.array) def __next__(self): if self.index 迭代器对象的特性 每一次for循环创建出的可迭代对象的专属迭代器都是一次性的，用完后就没用了： ... # ❶ containerIterator = LinearTypeContainer([i for i in range(3)]).__iter__() for item in containerIterator: print(item) # 0 # 1 # 2 for item in containerIterator: print(item) # ❷ print(\"?\") ❶：直接拿出一个迭代器对象 ❷：在第2次循环中，迭代器对象中存储的索引值已经最大了，每次调用iter()都会抛出异常返回出来再被for处理，所以print()函数根本不会运行 迭代器对象并不存储可迭代对象中的真正迭代数据，而是仅存储长度和索引，所以内存的占用并不多： class LinearContainer_iterator: def __init__(self, array): self.index = 0 # ❶ self.array = array # ❷ self.len = len(self.array) # ❸ ... ❶：占用额外的内存空间 ❷：引用对象，并不开辟内存 ❸：占用额外的内存空间 惰性求值与及早求值 迭代器对象中对于返回的数据项，是进行实时演算的，这种实时演算的特性求值方式被称为惰性求值，即你需要的时候我算出来后再给你： def __next__(self): if self.index 除开惰性求值，还有一种及早求值的方案，即使你要1个，我也把所有的都给你。 如Python2中的range()、map()、filter()、dict.items()、dict.keys()、dict.values()，它们均返回的是一个纯粹的列表，这样的设计是不合理的，参见要命的问题③。 因为返回的列表会占用很大的内存空间，而Python3中则统一优化为惰性求值方案，即返回一个可迭代对象。 要命的问题 一个非常有趣的问题： Python中的所有自带容器类型为何不自己设置成迭代器？ 而是在for循环时实例出一个专属的迭代器？ 直接在这些自带类型的底层实现__next__()方法不好吗？ 这样岂不是更加减少了内存的消耗，少定义了类和实例化了类吗？ 答：这真是一个要命的问题，这个问题我也想过很久，最后是在stackoverflow提问并且获得了满意的答案才记录下来的。 因为它确实是可以实现的，如下所示，只需要在加上❶处代码即可： class LinearTypeContainer: def __init__(self, array): if isinstance(array, list) or isinstance(array, tuple): self.array = array else: raise TypeError(\"argument array must is Linear container\") self.index = 0 self.len = len(self.array) def __iter__(self): return self def __next__(self): if self.index 但是这样做在某种特殊情况下会出现问题： container = LinearTypeContainer(list(range(5))) for item in container: print(item) if container.index == 3: break print(\"*\"*20) for item in container: print(item) # 0 # 1 # 2 # ******************** # 3 # 4 你会发现如果第一次for循环到了1半的时候退出，第二次for循环会接着根据第一次for循环进行继续。 能够解决一下吗？只需要加上一个标志位即可： class LinearTypeContainer: def __init__(self, array): if isinstance(array, list) or isinstance(array, tuple): self.array = array else: raise TypeError(\"argument array must is Linear container\") self.index = 0 self.len = len(self.array) self.iter = False # ❶ def __iter__(self): if self.iter: # ❷ self.index = 0 self.iter = True return self def __next__(self): if self.index ❶：判断是不是一次新的调用 ❷：如果是新的调用，则将index重新置为0即可 那么为何Python不这样设计呢？我们应该更多的考虑多线程的情况下，多个for循环使用同一个迭代器它是否是线程安全的，上面的示例中这个共享迭代器并不是线程安全的，此外它也不支持嵌套循环，如下所示，这样会造成无限循环： container = LinearTypeContainer(list(range(5))) for item in container: print(item) for j in container: print(j) 综上各个方面的考虑，Python将内置的数据类型，都设置了在for循环时返回专属迭代器的做法，这是非常好的设计，但是对于有些内置的对象，则是将它本身做成了迭代器，如文件对象。 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-10 19:12:26 "},"Python/Python函数相关/生成器.html":{"url":"Python/Python函数相关/生成器.html","title":"生成器","keywords":"","body":"生成器 生成器（generator）是迭代器的一种特殊实现方式，有2种方式可以创建，一种是通过生成器函数创建，另一种是生成器表达式进行创建。 生成器继承了迭代器的一切优点，简而言之是迭代器的一种升级版本。 在前面的迭代器一章节中介绍过，如果要想获取一个迭代器，必须要先创建一个可迭代对象，然后调用其下的__iter__()方法才能拿到一个迭代器，这样做会产生一些问题，如下所示： 我们只想要一个迭代器，并不需要可迭代对象的前提下该怎么办 可迭代对象中的数据项会占据大量内存空间，如果要想获取1个含有1000万个数据项的列表迭代器，则必须先创建1个列表对象，再获取其专属的迭代器，虽然迭代器不耗费内存，但是可迭代对象必然耗费内存 而生成器则是简化了这种操作，只需要创建生成器函数就可以拿到一个单纯的迭代器。 如果要判断一个对象是否属于生成器，推荐使用collections.abc下的Generator进行判定： >>> from collections.abc import Generator >>> isinstance(list,Generator) False 生成器函数 如果一个函数中出现yield关键字，则它就是一个生成器函数，当一个生成器函数加括号进行调用时，并不会立即运行逻辑体代码，而是返回一个生成器对象。 当对这个生成器对象调用next()方法时，将启动该生成器对象，生成器对象开始执行函数逻辑体代码。 而在执行函数逻辑体代码时如果碰见yield则会发生2件事情： 返回yield后面的值，类似于return函数 挂起当前生成器函数的运行状态，而不是结束生成器函数的运行，也就是说这个生成器对象不会被销毁 再次对生成器对象调用next()方法时恢复暂停状态，继续上述流程进行运行。 一个简单的例子： def generatorFunction(): n = 3 while n: yield n n-=1 # return None ❶ # ❷ generatorObject = generatorFunction() print(generatorObject) # ❸ print(next(generatorObject)) print(next(generatorObject)) print(next(generatorObject)) # ❹ print(next(generatorObject)) # # 3 # 2 # 1 # StopIteration ❶：默认的函数返回值即为None，在Python3之前的较低版本中，return关键字和yield关键字不可以同时出现在一个函数中，但是目前已经取消了这种设定 ❷：生成器函数加括号，返回生成器对象 ❸：生成器对象调用next()方法，开始执行函数体代码 ❹：由next()方法抛出的StopIteration异常，并不是生成器对象抛出的 斐波拉契数列 下面的示例中将使用生成器函数获取斐波拉契数列中指定位数之前所有的数据项。 仅获取数据项，并不产生存储，因此使用生成器函数极为方便： def getFibPositionValue(n): count, currentValue, nextValue = 0, 0, 1 while count 而如果是要对斐波拉契数列本身进行存储，使用普通函数则更好一点： def createFibArray(n): fibArray = [] count, currentValue, nextValue = 0, 0, 1 while count 生成器表达式 生成器表达式类（generator expression）似于列表推导式，用于快速的创建一个生成器对象，使用()对表达式进行包裹： genObject = (i for i in range(3)) print(genObject) # at 0x10bed0db0> 如果外部已经拥有一个括号，则可以忽略这大括号，如将生成器对象转换为元组的完整写法如下： tup = tuple((i for i in range(3))) print(tup) # (0, 1, 2) 忽略括号： tup = tuple(i for i in range(3)) print(tup) # (0, 1, 2) send() close() 生成器的特性不仅如此，它还能够实现一种双向的生成器外部调用代码与生成器内部逻辑代码的信息交互功能。 因为yield不仅可以返回值，还可以接收值。 如下示例，外部通过send()方法发送的信息将被yield所接收，当整个生成器对象迭代完毕后，可以调用close()方法关闭这个生成器对象： def generatorFunction(): print(\"generator object run ...\") firstRecvExternal = yield 1 # ① print(firstRecvExternal) # 打印A secondRecvExternal = yield 2 # ② print(secondRecvExternal) # 打印B lastRecvExternal = yield 3 # ③ print(lastRecvExternal) # 打印C genObject = generatorFunction() # ❶：启动生成器对象，执行函数，运行至①处返回 1，并暂停 genStartResult = genObject.send(None) print(genStartResult) # 打印1 # ❷：继续运行生成器对象，发送了字符串A，被生成器①处的firstRecvExternal所接收到，并进行了一次打印 A # 直至运行至②处，返回结果2 genSecondSend = genObject.send(\"A\") print(genSecondSend) # 打印2 # ❸：继续运行生成器对象，发送了字符串B，被生成器②处的secondRecvExternal所接收到，并且进行了一次打印 B # 直至运行至③处，返回了结果3 genThirdSend = genObject.send(\"B\") print(genThirdSend) # 打印3 try: # 继续运行生成器函数，发送了字符串C，被生成器③处的lastRecvExternal所接收到，并且进行了一次打印 C # 然后再往下运行发现 return None，于是 __next__()函数抛出了 StopIteration 的异常，但是被这里处理了 genLastSend = genObject.send(\"C\") # StopIteration except StopIteration: # 处理异常，关闭生成器对象 genObject.close() # generator object run ... # 1 # A # 2 # B # 3 # C yield form 生成器函数加括号不会执行函数体内部代码，而是返回生成器对象，生成器对象的启动必须通过next()或者send(None)。 for循环底层会调用生成器对象的__next__()方法进行启动和向下运行，因此通过for循环来操纵生成器是十分方便的： def genFunction(): count = 0 while 1: if count ❶：首先将生成器函数转换为生成器对象，然后通过for不断的进行调用 如果是2个嵌套调用的生成器函数，外部嵌套生成器函数需要时刻yield子调用生成器函数的值，似乎用for循环来完成这个需求是最好的选择： def outer(): yield \"run outer...\" for item in inner(): # ❶ yield item def inner(): yield \"run inner 1 ...\" yield \"run innner 2 ...\" yield \"run inner 3 ...\" for item in outer(): print(item) # run outer... # run inner 1 ... # run innner 2 ... # run inner 3 ... ❶：首先将生成器函数转换为生成器对象，然后通过for不断的进行调用 在Python3.3版本之后，你有了新的选择，使用yield from关键字，yield from关键字必须定义在一个生成器函数之中，它将会自动的在底层运行for循环进行调用另一个生成器函数，并将另一个生成器函数的结果进行返回： def outer(): yield \"run outer...\" yield from inner() # ❶ def inner(): yield \"run inner 1 ...\" yield \"run innner 2 ...\" yield \"run inner 3 ...\" for item in outer(): print(item) # run outer... # run inner 1 ... # run innner 2 ... # run inner 3 ... ❶：yield from关键字底层就是for循环，所以这里的代码会更加的精简 yield from关键字后面必须跟上一个可迭代对象，如迭代器、生成器： def outer(): yield \"run outer...\" yield from range(3) for item in outer(): print(item) # run outer... # 0 # 1 # 2 生成器函数栈帧 生成器函数为什么能够挂起当前状态？普通函数为什么不可以？其实根本原因还是在栈帧上。 普通的函数栈帧组成图： 生成器函数栈帧组成图： 函数栈帧结构体 一个函数其实完整的栈帧是由很多部分组成的，参见CPython源码，感兴趣的可以研究一下： typedef struct _frame { PyObject_VAR_HEAD struct _frame *f_back; /* previous frame, or NULL */ PyCodeObject *f_code; /* code segment */ PyObject *f_builtins; /* builtin symbol table (PyDictObject) */ PyObject *f_globals; /* global symbol table (PyDictObject) */ PyObject *f_locals; /* local symbol table (any mapping) */ PyObject **f_valuestack; /* points after the last local */ /* Next free slot in f_valuestack. Frame creation sets to f_valuestack. Frame evaluation usually NULLs it, but a frame that yields sets it to the current stack top. */ PyObject **f_stacktop; PyObject *f_trace; /* Trace function */ char f_trace_lines; /* Emit per-line trace events? */ char f_trace_opcodes; /* Emit per-opcode trace events? */ /* Borrowed reference to a generator, or NULL */ PyObject *f_gen; int f_lasti; /* Last instruction if called */ /* Call PyFrame_GetLineNumber() instead of reading this field directly. As of 2.3 f_lineno is only valid when tracing is active (i.e. when f_trace is set). At other times we use PyCode_Addr2Line to calculate the line from the current bytecode index. */ int f_lineno; /* Current line number */ int f_iblock; /* index in f_blockstack */ char f_executing; /* whether the frame is still executing */ PyTryBlock f_blockstack[CO_MAXBLOCKS]; /* for try and loop blocks */ PyObject *f_localsplus[1]; /* locals+stack, dynamically sized */ } PyFrameObject; 本章总结 这一章可以说及其重要，Python的协程编程中本章知识是绝对的核心基础，只有理解了生成器才用可能理解协程。 还是以问答形式进行记录吧： ①：生成器和迭代器有什么不同？ 答：生成器就是迭代器的另一种实现，普通的迭代器必须通过iter()函数进行创建，也就是说普通的迭代器必须依赖可迭代对象才能够创建出来，但是可迭代对象会占用大量内存，所以产生了生成器，即不通过可迭代对象就能拿到的迭代器。 ②：yield form的作用？ 答：yield form只能定义在一个生成器函数中，该生成器函数内部如果嵌套调用了另一个生成器函数时就可以使用yield form进行另一个生成器函数的调用，它底层会自动经过for循环对另一个生成器对象进行操纵，且将值返回给最外部。 ③：生成器函数和普通函数有什么不同？ 答：生成器函数加括号得到生成器对象，生成器对象调用其下__next__()方法才会执行函数体代码。而普通函数加括号直接执行函数体代码。 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-10 19:15:03 "},"Python/Python模块与包/summary.html":{"url":"Python/Python模块与包/summary.html","title":"Python模块与包","keywords":"","body":" 目录规范 Python模块 Python包 内置模块：time 内置模块：datetime 内置模块：random 内置模块：os 内置模块：sys 内置模块：json&pickle&shelve 内置模块：hashlib 内置模块：configparser 内置模块：subprocess 内置模块：logging 内置模块：re 内置模块：importlib 内置模块：collections 内置模块：itertools 内置模块：functools 模块包库框架的区别 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-13 19:42:48 "},"Python/Python模块与包/目录规范.html":{"url":"Python/Python模块与包/目录规范.html","title":"目录规范","keywords":"","body":"目录规范 为了提高程序的可读性与可维护性，我们应该为软件设计良好的目录结构，这与规范的编码风格同等重要。 软件的目录规范并无硬性标准，只要清晰可读即可。 但是有一些规范还是十分合理的，我们应当予以遵守： 目录层次不超过5层 目录尽量以复数形式命名，如imgs而不是img 目录命名尽量清晰易懂 目录说明 bin 目录级别：一级目录 目录作用：通常用于存放项目启动脚本 其他命名：暂无 注意事项：如果拥有此目录，则启动脚本需要考虑模块导入路径的问题 core 目录级别：一级目录 目录作用：存放主程序、业务逻辑源代码 其他命名：src 注意事项：可根据不同的子业务继续划分二级目录 api 目录级别：一级目录 目录作用：通常用于存放项目接口文件，使得项目能够在启动后和外部通信 其他命名：interface 注意事项：可根据不同的子业务需要继续划分二级目录 db 目录级别：一级目录 目录作用：存放操作数据库相关文件，主要用于与数据库交互 其他命名：暂无 注意事项：暂无 lib 目录级别：一级目录 目录作用：存放程序中常用的自定义模块 其他命名：暂无 注意事项：暂无 conf 目录级别：一级目录 目录作用：存放项目所需要的配置文件 其他命名：config 注意事项：暂无 logs 目录级别：一级目录 目录作用：存放项目运行时所产生的日志文件 其他命名：暂无 注意事项：暂无 docs 目录级别：一级目录 目录作用：存放项目的详细说明文档 其他命名：暂无 注意事项：暂无 plugins 目录级别：一级目录 目录作用：存放项目中所需要的第三方插件 其他命名：utils、tools、helpers 注意事项：暂无 common 目录级别：一级目录 目录作用：存放项目中大部分需求都能使用到的功能，相当于公共插件 其他命名：暂无 注意事项：暂无 test 目录级别：一级目录 目录作用：存放项目测试代码 其他命名：暂无 注意事项：暂无 static 目录级别：一级目录 目录作用：存放项目中所需要的静态文件 其他命名：暂无 注意事项：暂无 views 目录级别：一级目录 目录作用：存放项目中所需要的模板文件，MVC模型中的视图 其他命名：templates 注意事项：暂无 controller 目录级别：一级目录 目录作用：存放项目中的主流算法，MVC模型中的控制 其他命名：暂无 注意事项：暂无 models 目录级别：一级目录 目录作用：存放项目中与数据库打交道的脚本，MVC模型中的模型 其他命名：暂无 注意事项：暂无 文件说明 run.py 文件位置：项目根目录下，或者bin目录下 文件作用：项目的启动脚本 其他命名：start.py 注意事项：如果启动脚本是在bin目录下，则需要考虑sys.path setup.py 文件位置：项目根目录下 文件作用：安装、部署、打包的脚本，一键安装所需要的所有依赖环境 其他命名：暂无 注意事项：暂无 一般来说，用setup.py来管理代码的打包、安装、部署问题。业界标准的写法是用Python流行的打包工具setuptools来管理这些事情，这种方式普遍应用于开源项目中。 不过这里的核心思想不是用标准化的工具来解决这些问题，而是说，一个项目一定要有一个安装部署工具，能快速便捷的在一台新机器上将环境装好、代码部署好和将程序运行起来。 settings.py 文件位置：conf文件夹下 文件作用：项目配置文件 其他命名：有的是py脚本，后缀就是.py，而有的是.ini 、.conf、.yaml等 注意事项：暂无 requirements.txt 文件位置：项目根目录下 文件作用：存放所有项目第三方依赖库、模块的名字及版本 其他命名：暂无 注意事项：这个一般都是用第三方模块生成的 　requirements.txt文件的存在是为了方便开发者维护软件的依赖库。我们需要将开发过程中依赖库的信息添加进该文件中，避免在 setup.py安装依赖时漏掉软件包，同时也方便了使用者明确项目引用了哪些Python包。 README.md 文件位置：项目根目录下 文件作用：项目整体描述信息，设计思路，设计目标等 其他命名：暂无 注意事项：暂无 关于README.me的内容，这个应该是每个项目都应该有的一个文件，目的是能简要描述该项目的信息，让读者快速了解这个项目。它需要说明以下几个事项: 软件定位，软件的基本功能； 运行代码的方法: 安装环境、启动命令等； 简要的使用说明； 代码目录结构说明，更详细点可以说明软件的基本原理； 常见问题说明。 其他文件 CHANGELOG.md ：描述项目每个版本的更新信息，说明版本号、更新内容、修复了哪些问题等 humans.txt ：保存网站信息和网站建设者信息 ，格式规范参考官网http://humanstxt.org/ LICENSE.txt：项目基于的许可协议 robots.txt：规定爬虫程序能够获取本网站的那些信息 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-10 19:16:11 "},"Python/Python模块与包/Python模块.html":{"url":"Python/Python模块与包/Python模块.html","title":"Python模块","keywords":"","body":"Python模块 Python中的模块是一系列功能的集合体，总计可分为3大类： 内置模块：Python自带的一些内置库，开箱即用 第三方模块：通过pip命令下载到的模块，无需自己定义，Python拥有海量的第三方模块 自定义模块：一个.py文件就是一个模块，所以自己编写的.py文件也可以当做模块使用，例如文件名为m.py的文件就是一个名为m的自定义模块 自定义模块 自定义模块即自己写的模块，好处如下： 将相同功能的代码进行分类 降低代码耦合度，减少代码冗余 使整个程序组织结构更清晰，便于后期维护 结构分类 由于一个.py文件即为一个模块，故我们可以创建2个.py文件，一个当做程序入口文件，一个当做功能模块文件，以下是结构图： . ├── m1.py # 功能模块文件 └── run.py # 程序入口文件 首先在m1.py中写一个基本的函数： # m1.py print(\"this is module m1\") def add(x, y): return x + y 其次是在run.py中写上一个打印语句： # run.py print(\"run ..\") import简单使用 如果run.py中想要使用到m1.py中的add()函数，该怎么做？ 只需要在run.py中导入m1.py里定义的add()函数即可，注意在使用时也必须按m1开头才行： # run.py import m1 # ❶ print(\"run ..\") result = m1.add(1, 2) # ❷ print(result) # this is module m1 # run .. # 3 ❶：当解释器发现import m1时，会查找m1.py文件，并且会执行m1.py中的所有代码，所以下面会打印出 this is module m1的字样 ❷：使用了m1中的add()函数 针对❶，提出一个问题，如果导入多次这个m1文件，是否也会执行多次其中的代码呢？ 结果是否，也就是说只有第一次导入模块时，才会执行模块中的代码，多次导入只执行一次，其根本原因参照Python模块查找一节。 # run.py import m1 import m1 import m1 print(\"run ..\") result = m1.add(1, 2) print(result) # this is module m1 ❶ # run .. # 3 模块命名空间 现在我们有2个模块文件： . ├── m1.py ├── m2.py └── run.py 且2个模块文件中的代码都大部分相似： # m1.py print(\"this is module m1\") def add(x, y): return x + y # m2.py print(\"this is module m2\") def add(x, y): return x + y 在run中导入2个模块，且分别使用其下的add()函数时，内部发生了什么事情？ # run.py import m1 import m2 print(\"run ..\") resultM1 = m1.add(1, 2) resultM2 = m2.add(1, 2) print(resultM1) print(resultM2) # this is module m1 # this is module m2 # run .. # 3 # 3 run.py执行时，会按照import的顺序执行m1.py和m2.py文件中的代码 当m1，m2执行完成之后，会产生一个模块的命名空间 run.py的全局命名空间中将产生2个标识符，分别指向了m1.py和m2.py的模块命名空间 模块命名空间如下所示： 当要使用m1.add()时，则run.py通过全局命名空间中的标识符m1，去m1模块的命名空间中查找函数标识符add。 当要使用m2.add()时，则run.py通过全局命名空间中的标识符m2，去m2模块的命名空间中查找函数标识符add。 __name__与__main__ 当一个模块编写完成后，将要对其进行测试工作，确保代码无误才能投入使用。 如下，m1的测试代码写上： # m1.py print(\"this is module m1\") def add(x, y): return x + y # test print(add(1, 2)) 测试没问题后，run.py中对其进行功能引用： # run.py import m1 import m2 print(\"run ..\") resultM1 = m1.add(1, 2) resultM2 = m2.add(1, 2) print(resultM1) print(resultM2) # this is module m1 # 3 ❶ # this is module m2 # run .. # 3 当运行run.py后，会发现1处多打印了个3，这是因为在执行m1模块时，也将测试代码给执行了。 如何避免这种问题？我们可以在m1.py中加上一个判断语句： # m1.py print(\"this is module m1\") def add(x, y): return x + y # test if __name__ == \"__main__\": # ❶ print(add(1, 2)) ❶：__name__：如果该.py文件当做脚本被执行，则该变量为__main__，如果该.py文件当做模块导入被执行，则该变量为.py文件的名字，如m1.py就是m1 所以说，加入这条测试语句的目的在于，.py文件在不同的方式使用时可以执行不同的代码： 当做脚本被执行时，会运行测试代码 当做模块被导入时，不会运行测试代码 模块导入 import .. import语句的使用方式： import 模块名 导入的最小单元是模块 使用import导入模块的优缺点： 优点：不会和当前的全局命名空间标识符产生冲突 缺点：在使用模块功能时必须加上import右边的标识符前缀 如下所示，2个不同模块的相同标识符函数并不会产生冲突： import time import datetime print(time.time()) print(datetime.time()) # 1621665686.779634 # 00:00:00 也可以一行导入多个模块，使用逗号进行分割： import time, datetime from .. import .. from语句的使用方式： from 模块名 import 标识符 导入的最小单元是具体功能 使用from语句导入模块的优缺点： 优点：在使用模块功能时必须加上import右边的标识符前缀，如果直接导入了一个具体功能，则不用加前缀 缺点：容易和当前的全局命名空间标识符产生冲突 如下示例，由于datetime模块后导入，所以它的time函数标识符替代了time模块的time函数标识符： from time import time from datetime import time print(time()) print(time()) # 00:00:00 # 00:00:00 也可以在一行导入同一模块下的多个功能，以逗号进行分割： from time import time, sleep, ctime 别名的使用 使用as语句来为冲突的标识符取一个别名： from time import time as ttime from datetime import time as dtime print(ttime()) print(dtime()) # 1621665953.605452 # 00:00:00 *与__all__ 使用from 模块名 import *的方式，可以导入该模块下的所有标识符。 如果你是该模块的开发者，则可以通过__all__属性规定这种导入方式允许哪些标识符被导入。 在__all__中的标识符，可以被from 模块名 import *的方式进行导入 未在__all__中的标识符，不会被from 模块名 import *的方式进行导入 如果未定义__all__属性，则所有的标识符都会from 模块名 import *的方式进行导入 如下，在m1.py模块文件中，定义了1个getMax()的接口暴露函数，此外还有1个内部处理函数computeMax()以及模块说明变量desc： # m1.py def getMax(iterable): currentMax = None for index, item in enumerate(iterable): if index == 0: currentMax = computeMax(item, iterable[index + 1]) elif currentMax != item: currentMax = computeMax(currentMax, item) return currentMax def computeMax(x, y): return x if x > y else y desc = \"this is module m1\" __all__ = (\"getMax\", \"desc\") # ❶ ❶：__all__的格式必须是Tuple(str, str) 现在run.py中如果使用from m1 import *，则会将__all__中的所有标识符进行导入，下面示例中由于使用了未在__all__中定义的标识符，则抛出NameError的异常： # run.py from m1 import * print(getMax) print(desc) print(computeMax) # # this is module m1 # NameError: name 'computeMax' is not defined 循环导入问题 模块a中导入模块b，模块b中又导入了模块a，且导入语句都在首行，此时将引发循环导入的问题。 示例如下： # run.py import m1 print(m1.desc) # m1.py import m2 desc = \"this is module m1\" print(m2.desc) # m2.py import m1 desc = \"this is module m2\" print(m1.desc) 运行run.py，结果如下： AttributeError: module 'm2' has no attribute 'desc' 异常原因在于： run.py首行导入了m1，m1首行导入了m2，m2首行又导入了m1，导致m1.desc未能成功进行对象声明，故抛出异常。 执行步骤： run.py：import m1 (将m1加载至内存中) m1.py：import m2 (将m2加载至内存中) m2.py：import m1 (m1已经执行了，不重复执行了) m2.py：desc = \"this is module m2” m2.py：print(m1.desc)）(m1.desc没有进行对象声明，抛出异常) 解决办法： 将m1导入m2的语句放在行尾 将m1导入m2的语句放入函数中，并在行尾执行函数 办法1： # m1.py desc = \"this is module m1\" import m2 print(m2.desc) 办法2： desc = \"this is module m1\" def importFunction(): import m2 print(m2.desc) importFunction() 模块查找 查找优先级 无论是from .. import ..语句还是import语句，在导入模块时都会涉及到模块位置查找的问题。 模块查找优先级如下： 先查找内存 后查找硬盘 当一个模块被导入过一次后，就会加载至内存中，重复导入便可直接从内存中拿到该模块，而存在于内存中的模块代码是不会被执行的。 sys.modules sys.modules用于查看存在于内存中的模块，如果要导入的模块存在于这里面，就直接进行导入，而不执行其中的代码： >>> import sys >>> sys.modules ... 当一个存在于硬盘之上的模块被导入时，则会将该模块加载至内存中，只要是存在于内存中的模块，重复导入时就不会执行其中的代码了。 如下示例，第一次导入存在于硬盘之上的m1模块后，它被加载至了内存中： >>> tuple(sys.modules.items())[-1] ('rlcompleter', ) >>> import m1 >>> tuple(sys.modules.items())[-1] (('m1', )) Ps：其实当Python解释器启动时，会自动的运行一遍所有的内置模块并加载至内存中，因为这些内置模块也是存放在磁盘下的，你可以在Python解释器安装根目录的lib目录下找到它们。 sys.path 当内存中没有模块路径时，将按照sys.path的路径顺序依次在磁盘中查找。 如果在PyCharm下打印sys.path，它会做一些优化处理，比原生的REPL环境多出一些查找路径，下面使用#号进行标注： [ # '/Users/yunya/PycharmProjects/Project', # '/Users/yunya/PycharmProjects/Project', # '/Applications/PyCharm.app/Contents/plugins/python/helpers/pycharm_display', '/Library/Frameworks/Python.framework/Versions/3.6/lib/python36.zip', '/Library/Frameworks/Python.framework/Versions/3.6/lib/python3.6', '/Library/Frameworks/Python.framework/Versions/3.6/lib/python3.6/lib-dynload', '/Users/yunya/Library/Python/3.6/lib/python/site-packages', '/Library/Frameworks/Python.framework/Versions/3.6/lib/python3.6/site-packages', # '/Applications/PyCharm.app/Contents/plugins/python/helpers/pycharm_matplotlib_backend' ] 原生的REPL环境打印： >>> import sys >>> sys.path [ '', '/Library/Frameworks/Python.framework/Versions/3.6/lib/python36.zip', '/Library/Frameworks/Python.framework/Versions/3.6/lib/python3.6', '/Library/Frameworks/Python.framework/Versions/3.6/lib/python3.6/lib-dynload', '/Users/yunya/Library/Python/3.6/lib/python/site-packages', '/Library/Frameworks/Python.framework/Versions/3.6/lib/python3.6/site-packages' ] >>> 模块导入规范 导入模块时要遵循的一些规范： 导入顺序：内置模块在最上面，第三方模块在中间，自定义模块在下面 自定义模块名风格：蛇形式命名 Ps：Python2中有些模块是驼峰式命名，但是在Python3中都更改为蛇形式命名了，如PyMySQL，更名为pymysql 此外，模块也是一等公民，运行被赋值、传参等等。 模块编写规范 如果要编写自定义模块，也需要遵循一些规范： 首行添加模块文档描述，让别人知道你的模块是干嘛的 减少全局变量的使用，这样在第一次导入模块时会加快导入速度 模块中的类、函数等都需要写好注释 使用 if __name__ == “__main__”:的语句写好测试案例 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-10 20:15:54 "},"Python/Python模块与包/Python包.html":{"url":"Python/Python模块与包/Python包.html","title":"Python包","keywords":"","body":"Python包 包是一个含有__init__.py的文件夹（Python2中必须拥有，Python3中可以省略）。 包的基础单元是模块，当然一个包中也可以包含其他的包，是一组模块的集合。 包的导入 当导入一个包时，将会先执行包下__init__.py文件，于此同时会产生一个包的命名空间。 而在__init__中定义的标识符都会丢入到这个命名空间中。 现在，我们定义了一个包： ├── package # 顶级包 │ ├── __init__.py │ ├── sub1 # 子级包 │ │ ├── __init__.py │ │ └── m1.py # 含有add()函数 │ └── sub2 # 子级包 │ ├── __init__.py │ └── m2.py # 含有multiplication()函数 └── run.py # 启动文件 产生2个问题： 作为包的使用者而言，run.py如何调用到包中的某一个功能呢？ 作为包的开发者而言，包中任意一个模块，如何调用到另一个模块中的功能？ 外部导入 外部导入时，只能通过绝对路径来进行导入，如： # run.py from package.sub1.m1 import add 但如果package的__init__文件中，定义了add的路径，如： # package/__init__.py from package.sub1.m1 import add 则在外部可以省略绝对导入，直接通过package拿到add()函数： # run.py from package import add 这是因为顶级包package的命名空间中，已经有了add()函数的具体指向，所以外部的导入可以简写。 内部导入 内部导入分为绝对导入和相对导入两种。 绝对导入，必须以顶级包作为起始，如我想在m2.py文件中调用m1.py文件中的功能： # package/sub2/m2.py from package.sub1.m1 import add 相对导入是通过1个点和2个点来进行区分，1个点代指当前目录，2个点代指上层目录，如果在m2.py用相对导入调用m1.py文件中的功能，则代码如下所示： # package/sub2/m2.py from ..sub1.m1 import add 导入的约束 外部导入时，如果顶级包__init__.py文件中没有定义某一个功能的具体指向，你只能通过绝对导入的方式。 内部导入时，可以使用绝对导入和相对导入2种方式，个人更喜欢相对导入。 其次，在导包时一定要注意，不论是import还是from语法，.点的左边只能是一个包或者子模块（相对导入除外，.点的左边可以为空），如下所示： # run.py from package.sub1.m1 import add 顶级包 子级包 子模块 使用时没有这种限制，只需要记住使用时必须带上import语句后所有的标识符即可： # 导入时 from package import sub1 # 使用时 sub1.m1.add(1, 2) # 导入时 from package.sub1 import m1 # 使用时 m1.add(1, 2) 包的开发者 做为一名包的开发者，你需要尽可能的方便包的使用者。 多在__init__.py文件中写入子模块、功能的指向。 写好注释，测试用例。 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-05-22 18:07:35 "},"Python/Python模块与包/time.html":{"url":"Python/Python模块与包/time.html","title":"内置模块：time","keywords":"","body":"time简介 time模块是Python自带的模块，提供了时间的访问和转换功能。 官方文档 time模块中，对时间的表示包含3个概念： 时间戳形式：从1970.1.1 08:00:00（Unix纪元）开始到现在所经历的毫秒数，它int类型 结构化形式：以元组包裹的形式进行时间的展示，它tuple类型 字符串形式：以字符串的形式进行时间的展示，它是str类型 3种表示时间的方式之间可以互相转换，如下图所示： 时间获取 获取时间的方法： 方法 描述 表现形式 time.time() 获取时间戳形式的时间 时间戳 time.localtime() 获取结构化的本地时间 结构化 time.gmtime() 获取结构化的世界时间 结构化 time.asctime() 获取字符串形式的本地时间 字符串 time.ctime() 获取字符串形式的世界时间 字符串 time.strftime() 获取自定义格式的本地时间 字符串 Ps：本地时间在中国以东八区，上海时间时间为准，和世界时间（UTC）差了8小时 示例演示： >>> import time >>> time.time() 1621693706.0193129 >>> time.localtime() time.struct_time(tm_year=2021, tm_mon=5, tm_mday=22, tm_hour=22, tm_min=28, tm_sec=43, tm_wday=5, tm_yday=142, tm_isdst=0) >>> time.gmtime() time.struct_time(tm_year=2021, tm_mon=5, tm_mday=22, tm_hour=14, tm_min=29, tm_sec=0, tm_wday=5, tm_yday=142, tm_isdst=0) >>> time.asctime() 'Sat May 22 22:29:05 2021' >>> time.ctime() 'Sat May 22 22:29:09 2021' >>> time.strftime(\"%Y-%m-%d %H:%M:%S\") '2021-05-22 22:29:45' 结构化时间说明 在time.localtime()和time.gmtime()中，可以看到元组中有很多看不懂的数据项属性组成，它们的释义如下： 属性 描述 tm_year 年 tm_mon 月 tm_mday 日 tm_ hour 时 tm_min 分 tm_sec 秒 tm_wday 星期几，从0开始计算，一周就是0-6 tm_yday 该年份的第几天 tm_isdst 夏令营时间 这些属性都可以单独的提取出来，如获取这一年的年、月、日： >>> time.localtime().tm_year 2021 >>> time.localtime().tm_mon 5 >>> time.localtime().tm_mday 22 time.strftime() 放入一段字符串，将时间格式化出来，如下所示： >>> time.strftime(\"%Y-%m-%d %H:%M:%S\") '2021-05-22 22:29:45' %Y-%m%d这些都代表格式化时间的占位符，分别代表年月日等信息。 如下表所示： 符号 描述 %Y 格式化年份 %m 格式化月份 %d 格式化天数 %H 格式化小时 %M 格式化分钟 %S 格式化秒数 %X 等同于 “%H:%M:%S” 如想了解更多，参照官网示例截图： %accordion%点我查看%accordion% %/accordion% 时间转换 转换方法 以下是时间表现形式互相转换的方法： 方法 描述 time.mktime() 放入结构化时间，转换为时间戳时间 time.strftime() 放入结构化时间，转换为字符串时间 time.strptime() 放入字符串时间，转换为结构化时间 time.localtime() 放入时间戳时间，转换为结构化的本地时间 time.gmtime() 放入时间戳时间，转换为结构化的世界时间 示例演示： >>> time.mktime(time.localtime()) 1621694964.0 >>> time.strftime(\"%Y-%m-%d %X\", time.gmtime()) '2021-05-22 14:50:01' >>> time.strptime(time.ctime()) time.struct_time(tm_year=2021, tm_mon=5, tm_mday=22, tm_hour=22, tm_min=50, tm_sec=15, tm_wday=5, tm_yday=142, tm_isdst=-1) >>> time.localtime(time.time()) time.struct_time(tm_year=2021, tm_mon=5, tm_mday=22, tm_hour=22, tm_min=50, tm_sec=33, tm_wday=5, tm_yday=142, tm_isdst=0) >>> time.gmtime(time.time()) time.struct_time(tm_year=2021, tm_mon=5, tm_mday=22, tm_hour=14, tm_min=51, tm_sec=4, tm_wday=5, tm_yday=142, tm_isdst=0) 常用操作 将时间戳转换为固定的UTC时间字符串格式： >>> time.ctime(00) 'Thu Jan 1 08:00:00 1970' 将时间戳转换为本地时间的字符串表现形式： >>> t = 1293495903 # 有一个时间戳 >>> stuct = time.localtime(t) # 先将其转为本地的结构化时间 >>> stringTime = time.strftime(\"%Y-%m-%d %X\", stuct) # 再将其转换为字符串时间 >>> stringTime '2010-12-28 08:25:03' 将时间戳转换为世界时间的字符串表现形式： >>> t = 1293495903 # 有一个时间戳 >>> stuct = time.gmtime(t) # 先将其转为世界的结构化时间 >>> stringTime = time.strftime(\"%Y-%m-%d %X\", stuct) # 再将其转换为字符串时间 >>> stringTime '2010-12-28 00:25:03' 将一个字符串时间转换为时间戳： >>> stringTime = \"1998-01-26 00:00:10\" # 有一个字符串时间 >>> stuct = time.strptime(stringTime, \"%Y-%m-%d %X\") # 先将其转换为结构化时间 >>> stamp = time.mktime(stuct) # 再将其转换为时间戳 >>> stamp 885744010.0 线程睡眠 通过time.sleep()方法，可指定主线程睡眠多少秒，如下所示，第2个print()将在2秒后运行： import time print(\"start\") time.sleep(2) print(\"end\") 其他操作 日期判断 根据时间戳，获取7天后的时间： >>> currentTime = time.time() >>> sum7dayTime = currentTime + 7 * 86400 >>> time.strftime(\"%Y-%m-%d\", time.localtime(sum7dayTime)) '2021-05-29' 根据时间戳，获取3天前的时间： >>> currentTime = time.time() >>> sub3dayTime = currentTime - 3 * 86400 >>> time.strftime(\"%Y-%m-%d\", time.localtime(sub3dayTime)) '2021-05-19' 如果是时间戳操作，谨记1天是86400秒即可。 定时任务 脚本启动后，每隔一分钟，向屏幕打印一次hello world： import time currentSec = time.localtime().tm_sec while 1: if time.localtime().tm_sec == currentSec: print(\"hello world\") time.sleep(1) 延时任务 脚本启动后的一分钟时，打印一次hello world： import time currentTime = time.time() runTime = currentTime + 60 while 1: if time.time() == runTime: print(\"hello world\") break print(\"任务执行完毕\") Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-10 21:33:28 "},"Python/Python模块与包/datetime.html":{"url":"Python/Python模块与包/datetime.html","title":"内置模块：datetime","keywords":"","body":"datetime简介 datetime模块是Python内置模块，相比于time模块能够更加方便的操纵时间。 官方文档 以下举例部分常用方法： 方法 描述 datetime.datetime() 实例化返回一个datetime的对象 datetime.datetime.now() 获取本地时间，返回一个datetime的对象 datetime.datetime.utcnow() 获取世界时间，返回一个datetime的对象 datetime.datetime.fromtimestamp() 放入时间戳时间，直接转换为本地的datetime对象时间 datetime.datetime.utcfromtimestamp() 放入时间戳时间，直接转换为世界的的datetime对象时间 datetime.timedelta() 在一个datetime对象时间的基础上进行加减，返回一个新的datetime的对象 datetime.datetime.weekday() 放入一个datetime对象，获取该对象是那一周的第几天，从0开始计算，一周就是0-6 对象获取 datetime.datetime.now()和datetime.datetime.utcnow()都可以获取一个表示当前时间的datetime对象。 >>> import datetime >>> datetime.datetime.now() datetime.datetime(2021, 5, 22, 23, 31, 43, 468077) >>> datetime.datetime.utcnow() datetime.datetime(2021, 5, 22, 15, 31, 52, 841214) 为datetime.datetime.fromtimestamp()放入一个时间戳可直接获取到表示本地时间的datetime的对象： >>> datetime.datetime.fromtimestamp(11111) datetime.date(1970, 1, 1) >>> datetime.datetime.utcfromtimestamp(11111) datetime.datetime(1970, 1, 1, 3, 5, 11) datetime对象是str类型的更高一级封装，你可以将datetime对象转换为str类型： >>> str(datetime.datetime.now()) '2021-05-23 00:06:03.271989' 对象属性 一个datetime对象拥有很多时间属性，如下表所示： 属性 描述 year 年份（int） month 月份（int） day 天数（int） hour 时数（int） minute 分数（int） second 秒数（int） microsecond 毫秒数（int） 你可以快速的获取它们： >>> currentTime = datetime.datetime.now() >>> currentTime.year 2021 >>> currentTime.month 5 >>> currentTime.day 22 >>> currentTime.hour 23 >>> currentTime.minute 48 >>> currentTime.second 52 >>> currentTime.microsecond 527012 对象方法 一个datetime对象拥有很多方法，如下表所示： 方法 描述 datetimeObject.timestamp() 返回一个时间戳，不同于time模块的时间戳，该方法返回的是一个float类型 datetimeObject.timetuple() 返回与time.localtime()兼容的本地时间元组 datetimeObject.utctimetuple() 返回与time.gmtime()兼容的UTC时间元组 datetimeObject.ctime() 返回ctime()样式字符串 datetimeObject.isoformat() 根据ISO格式返回时间字符串 datetimeObject.strptime() 类似于time.strptime() datetimeObject.tzname() 返回时区名字 datetimeObject.replace() 替换一个字符串格式的时间中某部分，返回一个新的datetime的对象 由于这些方法使用的时候并不多，所以只举例一个时间替换。 将当前时间的年份替换为1998年： >>> currentTime = datetime.datetime.now() >>> currentTime.replace(year=1998) datetime.datetime(1998, 5, 23, 0, 22, 24, 698922) 时间加减 datetime对象允许通过和datetime.timedelta()进行加减，以便进行时间的计算。 时间加减中不支持年份的计算，可以用365天代替 当前时间加3天： >>> sum3dayTime = datetime.timedelta(+3) + currentTime >>> sum3dayTime datetime.datetime(2021, 5, 26, 0, 15, 15, 405378) 当前时间-3天： >>> sub3dayTime = datetime.timedelta(-3) + currentTime >>> sub3dayTime datetime.datetime(2021, 5, 20, 0, 15, 15, 405378) 当前时间加3小时： >>> sum3hours = datetime.timedelta(hours=+3) + currentTime >>> sum3hours datetime.datetime(2021, 5, 23, 3, 15, 15, 405378) 当前时间减3小时： >>> sub3hours = datetime.timedelta(hours=-3) + currentTime >>> sub3hours datetime.datetime(2021, 5, 22, 21, 15, 15, 405378) Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-05-23 14:11:16 "},"Python/Python模块与包/random.html":{"url":"Python/Python模块与包/random.html","title":"内置模块：random","keywords":"","body":"random简介 random模块是Python自带的模块，该模块实现了各种分布的伪随机数生成器。 官方文档 以下举例部分常用方法： 方法 描述 random.randint(1, 3) 从1-3之间随机生成一个整数 random.randrange(1, 3) 从1-2之间随机生成一个整数 random.random() 生成大于0且小于1的浮点数 random.uniform(1, 3) 生成大于1且小于3的浮点数 random.choice(seq) 从序列中随机取出1个数据项 random.sample(seq, 2) 从序列中随机取出指定个数据项，这里是2，以列表形式返回 random.shuffle(seq) 将传入的拥有索引的序列进行打乱，原地打乱，不返回新序列 整数生成 random.randint()是顾头顾尾的生成随机整数： >>> import random >>> random.randint(1, 3) 1 >>> random.randint(1, 3) 2 >>> random.randint(1, 3) 3 random.randrange()是顾头不顾尾的生成随机整数： >>> random.randrange(1, 3) 1 >>> random.randrange(1, 3) 2 浮点数生成 random.random()生成浮点数的范围总是介于0和1之间： >>> random.random() 0.818462343335113 random.uniform()可指定生成浮点数的范围： >>> random.uniform(1, 3) 2.810443694822667 数据项抽取 random.choice()可以从一个序列中随机抽取出一个数据项： >>> random.choice(range(10)) 1 random.sample()可以从一个序列中随机抽取出多个数据项： >>> random.sample(range(10), 2) [1, 0] 它们貌似均不支持字典的随机抽取。 生成乱序列 random.shuffle()可以传入一个线性结构的序列，并将其中的数据项进行随机的打乱： >>> li1 = [i for i in range(10)] >>> random.shuffle(li1) >>> li1 [1, 5, 6, 3, 7, 2, 9, 8, 4, 0] >>> random.shuffle(li1) >>> li1 [1, 5, 4, 3, 7, 0, 9, 6, 8, 2 生成验证码 验证码总是随机的，因此可以通过random模块进行实现生成： import random def getVerificationCode(bitNumber): code = \"\" for i in range(bitNumber): code += random.choice( [ str(random.randint(1, 9)), chr(random.randint(65, 91)) # ❶ ] ) return code code = getVerificationCode(6) print(code) ❶：65-90是大写的A-Z的ASCII码表示范围 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-10 19:22:17 "},"Python/Python模块与包/os.html":{"url":"Python/Python模块与包/os.html","title":"内置模块：os","keywords":"","body":"os简介 os模块是Python内置模块，提供了各种使用Python对操作系统提供操纵的接口。 官方文档 以下举例部分常用方法和属性： 方法/属性 描述 os.curdir 总是返回一个字符串，“.”，代指当前目录 os.pardir 总是返回一个字符串，“..”，代指当前父级目录 os.sep 返回当前平台下的路径分隔符，Windows下为“\\”，Unix下为“/” os.linesep 返回当前平台下的行终止符，Windows下为“\\r\\n”，Unix下为“\\n” os.pathsep 返回当前平台下的用于分割文件的分隔符，Windows下为“;”，Unix下为“:” os.name 返回当前平台的信息，Windows下为“nt”，Unix下为“posix” os.environ 获取系统环境变量 os.system(“command”) 运行shell命令 os.listdir(“dirName”) 获取指定目录下的所有项目，相当于ls命令，以列表方式返回结果 os.getcwd() 获取当前脚本的工作目录，相当于pwd命令 os.chdir(“dirName”) 改变当前脚本的工作目录，相当于cd命令 os.makedir(“dirName”) 生成单级的空目录，相当于mkdir命令 os.makedirs(“dirName1/dirName2”) 生成多层递归目录，相当于mkdir -p命令 os.rmdir(“dirName”) 删除单级的空目录 os.removedirs(“dirName”) 删除多层递归目录，前提是该目录必须为空 os.remove(“fileName”) 删除一个文件 os.rename(“oldName”, “newName”) 重命名文件/目录 os.path.abspath(“path”) 返回当前path的绝对路径 os.path.split(“path”) 将path分为2部分，返回元组，索引0是路径，索引1是文件 os.path.dirname(“path”) 返回path的路径部分，相当于上面方法的索引0 os.path.basename(“path”) 返回path的路径部分，相当于上面方法的索引1，如果path是以“/”或者“\\”结尾，则返回None os.path.join(“path1”, “path2”) 将多个path进行组合，相当于os.path.split()的反操作 os.path.exists(“path”) 判断path是否存在，返回布尔值 os.path.isabs(“path”) 判断path是否是绝对路径，返回布尔值 os.path.isfile(“path”) 判断path是否是一个文件路径，返回布尔值 os.path.isdir(“path”) 判断path是否是一个目录路径，返回布尔值 os.stat(“path”) 获取path所指文件/目录的相关信息 os.path.getatime(“path”) 获取path所指文件/目录的最后存取时间 os.path.getmtime(“path”) 获取path所指文件/目录的最后修改时间 os.path.getsize(“path”) 获取path所指文件/目录的大小 平台信息 根据以下一些属性，可获取平台信息： 属性 描述 os.curdir 总是返回一个字符串，“.”，代指当前目录 os.pardir 总是返回一个字符串，“..”，代指当前父级目录 os.sep 返回当前平台下的路径分隔符，Windows下为“\\”，Unix下为“/” os.linesep 返回当前平台下的行终止符，Windows下为“\\t\\n”，Unix下为“\\n” os.pathsep 返回当前平台下的用于分割文件的分隔符，Windows下为“;”，Unix下为“:” os.name 返回当前平台的信息，Windows下为“nt”，Unix下为“posix” os.environ 获取系统环境变量 os.environ是一个全局字典，你可以将它当做普通字典进行操作。 >>> os.environ ... >>> os.environ[\"k1\"] = \"v1\" >>> os.environ.get(\"k1\") 'v1' 此外，它是全局的，这意味着同一个项目之中任何地方都能随时获取到它，因此可以用它来存储一些较为私密的信息，如数据库链接IP+PORT+USER+PASSWORLD。 使用该字典时需要注意key必须是str类型，若是其他类型则会抛出异常。 目录操作 使用以下一些方法，可对目录做出操作： 方法 描述 os.system(“command”) 运行shell命令 os.listdir(“dirName”) 获取指定目录下的所有项目，相当于ls命令，以列表方式返回结果 os.getcwd() 获取当前脚本的工作目录，相当于pwd命令 os.chdir(“dirName”) 改变当前脚本的工作目录，相当于cd命令 os.makedir(“dirName”) 生成单级的空目录，相当于mkdir命令 os.makedirs(“dirName1/dirName2”) 生成多层递归目录，相当于mkdir -p命令 os.rmdir(“dirName”) 删除单级的空目录 os.removedirs(“dirName”) 删除多层递归目录，前提是该目录必须为空 os.remove(“fileName”) 删除一个文件 os.rename(“oldName”, “newName”) 重命名文件/目录 os.system()应该是一个比较常用的方法，它可以运行任何的shell命令： >>> os.system(\"tree .\") >>> os.system(\"ifconfig\") 但是os.system()如果在Windows环境下的PyCharm中进行使用，则会抛出异常。 因为Windows平台执行命令的返回结果是采用GBK编码，而PyCharm中使用UTF8对结果进行解码就会产生乱码问题。 路径操作 路径操作应该是os模块中比较常用的： 方法 描述 os.path.abspath(“path”) 返回当前path的绝对路径 os.path.split(“path”) 将path分为2部分，返回元组，索引0是路径，索引1是文件 os.path.dirname(“path”) 返回path的路径部分，相当于上面方法的索引0 os.path.basename(“path”) 返回path的路径部分，相当于上面方法的索引1，如果path是以“/”或者“\\”结尾，则返回None os.path.join(“path1”, “path2”) 将多个path进行组合，相当于os.path.split()的反操作 os.path.exists(“path”) 判断path是否存在，返回布尔值 os.path.isabs(“path”) 判断path是否是绝对路径，返回布尔值 os.path.isfile(“path”) 判断path是否是一个文件路径，返回布尔值 os.path.isdir(“path”) 判断path是否是一个目录路径，返回布尔值 示例演示os.path.join()和os.path.split()： >>> dirName, fileName = os.path.split(\"/Users/yunya/document/os模块.md\") >>> dirName '/Users/yunya/document' >>> fileName 'os模块.md' >>> newPath = os.path.join(\"/\", \"Users\", \"yunya\", \"document\", \"os模块.md\") >>> newPath '/Users/yunya/document/os模块.md' >>> 信息获取 信息获取也有时候会用到： 方法 描述 os.stat(“path”) 获取path所指文件/目录的相关信息 os.path.getatime(“path”) 获取path所指文件/目录的最后存取时间 os.path.getmtime(“path”) 获取path所指文件/目录的最后修改时间 os.path.getsize(“path”) 获取path所指文件/目录的大小 项目模块查找 项目启动不了? 在之前介绍Python模块一章节中说到PyCharm和原生解释器在查找模块时的sys.path会有所不同。 PyCharm会自动的新增几行模块查找路径，而原生解释器则不会进行新增。 这样会产生一个问题，即项目上线后通过原生解释器进行启动项目时会发现找不到模块。 如，我们有一个下面结构的项目： Project │ ├── bin │ └── run.py # 入口文件 └── view ├── __init__.py └── views.py # 视图层 定义了main()函数 当run.py进行执行后，Python工作目录就被定义在了Project/bin/run.py一层。 from view.views import main if __name__ == '__main__': main() 如果在PyCharm中执行run.py，则不会抛出异常，它能顺利的找到view模块，这是因为PyCharm将工作目录的上层、上上层也加入到了sys.path即模块查找路径中： [ '/Users/yunya/PycharmProjects/Project/bin', '/Users/yunya/PycharmProjects/Project', '...' ] 这样查找模块范围就会大很多： Project # 上上层能找到 │ ├── bin # 上层找不到 │ └── run.py # 本层找不到 └── view ├── __init__.py └── views.py 但是如果在Python原生解释器环境下，调用执行run.py脚本，则会提示找不到view模块，因为view模块仅能在上上层被找到： Project # 这里才能找到 │ ├── bin │ └── run.py # 找不到 └── view ├── __init__.py └── views.py 如何解决这个问题？只需要在run.py脚本中将上上层路径加入至sys.path即可： import sys import os sys.path.append(os.path.abspath(os.path.dirname(os.path.dirname(__file__)))) from view.views import main if __name__ == '__main__': main() 这样再次使用Python原生解释器通过run.py脚本启动项目，就不会发生任何问题了。 OpenStack对路径的处理 在OpenStack中，对这种项目模块查找路径的处理采用了截然不同的方式： import os import os, sys print(os.path.abspath(__file__)) possible_topdir = os.path.normpath(os.path.join( # ❶ __file__, os.pardir, # 上一级，相当于手动输入\"..\" os.pardir, )) print(possible_topdir) ❶：os.path.normpath()可以将一个不规范的路径变为规范路径 这样也能够达到相同的效果。 Django3.x对路径的处理 Django3以前，对项目模块查找路径的处理采用了和我们相同的方式： BASE_DIR = os.path.dirname(os.path.dirname(__file__)) print(BASE_DIR) 在Django3之后，则使用pathlib模块代替了os模块，其实本质都是一样的： from pathlib import Path root = Path(__file__) res = root.parent.parent # ❶ print(res) ❶：取上层的上层 补充一点pathlib的知识，对于pathlib的路径拼接直接使用 / 符号即可，符号左边为Path对象，右边为str类型。 与os.path.join()拥有相同的效果。 print(Path(\"User/YunYa\") / r\"a/b/c\") # User\\YunYa\\a\\b\\c 无论是os.path.join()还是pathlib的/进行路径拼接，都会选择出适合当前平台的路径分隔符。 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-05-23 17:30:15 "},"Python/Python模块与包/sys.html":{"url":"Python/Python模块与包/sys.html","title":"内置模块：sys","keywords":"","body":"sys简介 sys模块是Python内置模块，提供了各种系统相关的参数和函数。 官方文档 以下举例部分常用方法和属性： 方法/属性 描述 sys.platform 返回操作系统平台名称 sys.version 获取Python解释程序的版本信息 sys.builtin_module_names 获取内置的所有模块名，元组形式返回 sys.modules 返回以加载至内存之中的模块及路径 sys.path 返回模块在硬盘中的搜索路径 sys.stdin Python标准输入通道，input()函数的底层实现 sys.stdout Python标准输出通道，print()函数的底层实现 sys.stderr Python标准输入错误通道 sys.getrecursionlimit() 获取当前Python中最大递归层级 sys.setrecursionlimit() 设置当前Python中最大递归层级 sys._getframe(0).f_code.co_name 获取被调用函数的名称 sys._getframe(1).f_code.co_name 获取被调用函数是被哪一个函数所嵌套调用的，若不是被嵌套调用则返回module sys._getframe().f_back.f_lineno 获取被调用函数在被调用时所处代码行数 sys._getframe().f_code.co_filename 获取被调用函数所在模块文件名 sys.getrefcount() 获取对象的引用计数 sys.argv 获取通过脚本调用式传递的数据 修改递归层级 修改递归层级已经介绍过一次了，默认Python的最大递归层级是1000层，我们可以对其进行修改： >>> sys >>> sys.getrecursionlimit() 1000 >>> sys.setrecursionlimit(10000) >>> sys.getrecursionlimit() 10000 函数栈帧信息 sys._getframe()能够获取到函数的栈帧对象，我们知道函数的栈帧对象中封存了一些函数运行时的信息。 那么通过下面这些属性就能拿到函数里栈帧的某些数据： sys._getframe(0).f_code.co_name：获取被调用函数的名称 sys._getframe(1).f_code.co_name：获取被调用函数是被哪一个函数所嵌套调用的，若不是被嵌套调用则返回module sys._getframe().f_back.f_lineno：获取被调用函数在被调用时所处代码行数 sys._getframe().f_code.co_filename：获取被调用函数所在模块文件名 import sys def func(): print(sys._getframe(0).f_code.co_name) print(sys._getframe(1).f_code.co_name) print(sys._getframe().f_back.f_lineno) print(sys._getframe().f_code.co_filename) func() 脚本传入参数 我们都知道Python解释器可以通过以下方式进行.py文件的调用： $ python3 demo.py 但是你可能不知道通过sys.argv属性可以获取通过脚本调用式传递的数据，如下启动.py脚本时传入了1、2、3： $ python3 demo.py 1 2 3 那么现在sys.argv就会接受到这3个数据，变成下面的格式： sys.argv = [\"scriptPath\", \"1\", \"2\", \"3\"] 基于这个特性，我们来做一个下载模拟器： import random import sys import time def download(): scale = 40 print(\"开始下载文件:{0}\".format(sys.argv[2]).center(scale + 10, '-')) totalSize = random.randint(1000, 2000) currentSize = totalSize / scale for i in range(scale + 1): a = '█' * i b = '_' * (scale - i) c = (i / scale) * 100 print('''\\r{0:^3.2f}% | {1}{2} | {3:.2f}/{4:.2f}(MB)'''.format(c, a, b, currentSize * i, totalSize), end=\"\") time.sleep(0.1) print(\"\\n\" + \"执行结束\".center(scale + 10, '-')) def main(): try: runFunc = eval(sys.argv[1]) except Exception: print(\"输入有误！\", file=sys.stderr) exit() else: runFunc() if __name__ == '__main__': main() 启动时输入参数： python3 ./bin/run.py download test.text Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-05-23 19:03:13 "},"Python/Python模块与包/json&pickle&shelve.html":{"url":"Python/Python模块与包/json&pickle&shelve.html","title":"内置模块：json&pickle&shelve","keywords":"","body":"序列化 序列化是指将在内存中的数据变成为可存储或者可传输的数据。 Python中称序列化为pickling，而其他编程语言中则称之为serialization、marshalling、flattening等等，都是一个意思。 序列化最重要的目的是数据持久化保存，以及数据跨平台传输： 持久化保存：数据无法在内存中长期驻留，因此可以将其转变为某种格式并写入到磁盘之中 跨平台传输：不同的编程语言中对于数据的表示都是不同的，如Python中的set在很多语言中就不具备，故可以将数据进行序列化，变为一种大家都认识的格式 json JSON格式最早来源于JavaScript语言，现在已经成为跨平台语言传输的通用格式。 它的操纵及其简单，以下是JSON与Python中数据类型的对应关系： Python数据类型 JSON格式表示 dict {} list [] str string int or float int or float True or False true or false None Null JSON优点是操纵简单、跨语言传输十分方便，因为它采用字符串进行存储。 JSON缺点是仅支持Python基本数据类型，像函数、类这种都不被支持。 Python中进行JSON格式化，可以选择内置的json模块： 官方文档 常用方法一览： 方法 描述 json.dumps() 将Python中的基本数据类型序列化为JSON格式的字符串 json.loads() 将JSON格式字符串反序列化为Python中的基本数据类型 json.dump() 同json.dumps()，不过写入文件更方便 json.load() 同json.loads()，不过读取文件更方便 序列化 使用json.dumps()可以将Python中的基本数据类型序列化为JSON格式的字符串： >>> import json >>> userMessage = {\"name\" : \"yunya\", \"age\" : \"18\", \"gender\" : True, \"hobby\" : [\"read\", \"playGame\"]} >>> json.dumps(userMessage) '{\"name\": \"yunya\", \"age\": \"18\", \"gender\": true, \"hobby\": [\"read\", \"playGame\"]}' 如果想将序列化的结果进行持久化保存，可以使用json.dump()方法，它可以指定输出对象为文件句柄，如下示例： >>> import json >>> userMessage = {\"name\" : \"yunya\", \"age\" : \"18\", \"gender\" : True, \"hobby\" : [\"read\", \"playGame\"]} >>> with open(file=\"test.json\", mode=\"wt\", encoding=\"utf8\") as f: json.dump(userMessage,fp=f) 反序列化 使用json.loads()可以将JSON格式字符串反序列化为Python中的基本数据类型： >>> userJsonStr = '{\"name\": \"yunya\", \"age\": \"18\", \"gender\": true, \"hobby\": [\"read\", \"playGame\"]}' >>> json.loads(userJsonStr) {'name': 'yunya', 'age': '18', 'gender': True, 'hobby': ['read', 'playGame']} 如果想从文件中读取JSON字符串并进行反序列化，可以使用json.load()方法，它可以指定读取对象为文件句柄，如下所示： >>> import json >>> with open(file=\"test.json\", mode=\"rt\", encoding=\"utf8\") as f: userMessage = json.load(fp=f) >>> userMessage {'name': 'yunya', 'age': '18', 'gender': True, 'hobby': ['read', 'playGame']} 序列化的过程 Python的基本数据类型转换为JSON字符串时，经历了什么？ 总计可分为2步： 修改str的单引号为双引号 根据JSON与Python中数据类型的对应关系，将数据进行包装转换为JSON表现形式 示例、修改str的单引号为双引号： >>> pyStr = 'string' >>> jsonStr = json.dumps(pyStr) >>> jsonStr '\"string\" 示例、根据JSON与Python中数据类型的对应关系，将数据进行包装转换为JSON表现形式： >>> pyType = None >>> jsonType = json.dumps(pyType) >>> jsonType 'null' 中文显示 如果JSON序列化的字符串中带有中文，则将其转变为Unicode的16进制表现形式： >>> pyStr = \"云崖先生\" >>> json.dumps(pyStr) '\"\\\\u4e91\\\\u5d16\\\\u5148\\\\u751f\"' 你可以指定序json.dumps()中的关键字参数ensure_ascii为False，此时不会对中文字符进行转换： >>> json.dumps(pyStr, ensure_ascii=False) '\"云崖先生\"' 猴子补丁介绍 Monkey Patch是指用一个补丁偷偷的将一个原本的功能进行替换，使用者并不知道目前使用的功能是已经替换后的功能。 第三方模块ujson相比于json来说性能更加的高效，你可以将它作为猴子补丁偷偷的替换掉json，只需要在项目运行时的入口加入并运行一个替换函数： import json import ujson def monkeyPatchJson(): json.__name__ = \"ujson\" json.dumps = ujson.dumps json.loads = ujson.loads monkeyPatchJson() 修改完毕后，重启项目，后面的代码甚至不需要任何修改，就能使用性能更高的ujson了。 采用猴子补丁之后，如果发现ujson不符合预期，那也可以快速撤掉补丁，删除掉函数的执行语句即可。 序列化非基本数据类型 datetime类型并非是Python基本的数据类型，所以JSON不支持对它的序列化。 import datetime import json now = datetime.datetime.now() strNow = json.dumps(now, ensure_ascii=False) print(strNow) # TypeError: Object of type 'datetime' is not JSON serializable 此时我们可以手动的扩展json.dumps()的功能，让其支持datetime的序列化。 具体思路是将非Python基本数据类型转换为基本数据类型后再使用json.dumps()对其进行序列化，实现步骤如下所示： import datetime import json from json.encoder import JSONEncoder class JsonRealize(JSONEncoder): \"\"\" 该类是自定义序列化非Python基本数据类型的逻辑实现类 主要作用是继承并覆写父类JSONEncoder的default() \"\"\" def default(self, serializeObject): # 发现序列化对象是datetime类型的话，就将其转换为str类型 if isinstance(serializeObject, datetime.datetime): return str(serializeObject) # 如果是其他类型，则交由JSONEncoder的default()进行处理 return JSONEncoder.default(self, serializeObject) if __name__ == '__main__': now = datetime.datetime.now() strNow = json.dumps(now, cls=JsonRealize, ensure_ascii=False) print(strNow) # \"2021-05-23 20:40:49.446823\" json模块使用注意事项 Python3.5中不支持序列化bytes类型。 其他版本中均可以支持。 pickle 　pickle模块是Python自带的模块，它和json模块的方法全部一致，区别在于pickle序列化后的类型是bytes类型，而json序列化后的类型是字符串类型。 由于要考虑到多语言的兼容性问题，json模块并不支持Python除基本数据类型之外的类型。如：函数类型，类等等。 但是pickle由于只支持Python使用，所以有了更强的对Python序列化对象的支持。 pickle可以序列化函数，类等等，但是并不推荐这么做，因为保存的只有一个内存地址。 另外，由于pickle的局限性太强所以更推荐使用JSON进行序列化操作。 由于很少使用，以及与json模块的方法一致，这里不再进行演示了。 官方文档 shelve shelves是Python自带的模块，它能够更加方便的将Python数据进行持久化保存。 官方文档 它将整个文件看做一个大的字典，将字典中的key看做Python中的标识符，将value看做存储的对象，因此操作起来十分方便。 只需要记住2个方法即可： shelve.open()：打开一个文件，这个文件是可读可写的 shelve.close()：关闭文件 示例演示： >>> import shelve >>> with shelve.open(\"test.txt\") as f: f[\"name\"] = \"Yunya\" f[\"age\"] = 18 f[\"hobby\"] = [\"readBook\", \"playGame\"] >>> with shelve.open(\"test.txt\") as f: name = f.get(\"name\") >>> name 'Yunya' Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-10 21:38:59 "},"Python/Python模块与包/hashlib.html":{"url":"Python/Python模块与包/hashlib.html","title":"内置模块：hashlib","keywords":"","body":"hashlib简介 密码学是一个庞大的领域，总体来说可将该领域中的加密方式分为2大类： 对称加密：可通过加密值反解出内容 非对称加密：不可通过加密值反解出内容 而今天介绍的hashlib模块是Python3中所独有的，提供了一系列的非对称加密算法：hash算法。 在Python2中hashlib模块被拆分成了md5模块和sha模块，它们提供的功能和Python3的hashlib模块相同。 官方文档 以下是该模块提供的部分常用方法及属性： 属性/方法 描述 hashlib.algorithms_guaranteed 以集合方式，列出所有平台所支持的hash算法 hashlib.algorithms_available 以集合方式，列出当前所运行的Python解释器所支持的hash算法 hash.digest_size 以字节表示结果hash对象的大小 hash.block_size 以字节表示的hash算法的内部块大小 hash.name 返回hash对象的规范名称 hash.copy() 返回hash对象的拷贝副本 hash.update() 在已有基础上对hash对象的内容进行更新 hash.hexdigest() 返回16进制的字符串hash值 hash.digest() 返回2进制的字节串hash值 hash特性 Python的字典在键值对数据存储和读取时，就用到了hash算法。 比如：\"k1\" : \"v1\"的键值对在存储过程中，\"k1\"会通过hash()函数得出1个hash值，该hash值与v1一一对应，后续通过dict.get()方法通过\"k1\"找\"v1\"时，内部也是利用的这个hash值来进行查找。 通过字典的种种特性，我们可以顺势推导出hash的一些特性： 相同的内容求hash值，得到的hash结果也必然相同 不能通过hash值反解出内容（或者说反解的代价大到不可能实现，但也不是绝对的） 如果采用相同的hash算法，无论需要校验的内容由多大，得到的hash值长度总是固定的 我们使用内置的hash()函数来验证这3点结论： 1）相同的内容求hash值，得到的hash结果也必然相同： >>> hash(\"hello world\") -484803057 >>> hash(\"HELLO WORLD\") 264022494 >>> hash(\"hello world\") -484803057 2）不能通过hash值反解出内容： >>> hash(\"k1\") -714364401 >>> hash(\"-714364401\") 1936952577 3）如果采用相同的hash算法，无论需要校验的内容有多大，得到的hash值长度总是固定的： >>> hash(\"hello\") 313408759 >>> hash(\"hello, Python3\") -1705693388 算法区别 由于hash算法的特性，它常被用于一致性校验、密码存储等领域。 其中最著名的hash算法就是MD5，它被称为永不可破的hash算法，但随着技术的发展MD5已经不那么可靠了，它可以用撞库的方式对其进行反解。 而SHA256作为MD5的加强版，是目前的主流方案。 关于MD5和SHA家族的区别在于使用的加密算法不一样，以及它们生成的hash值长度不同： MD5较SHA家族的hash值要短一些，因此生成速度更快一点 对暴力破解来说，SHA家族的hash值比MD5的hash值更安全，更值得信赖 MD5：128位 SHA1：160位 SHA256：256位 如果你的项目安全等级较高，可采用SHA256作为加密方式，其他情况下使用MD5即可。 模块使用 hashlib模块的使用非常简单，总体来说先要生成一个hash对象，然后再填入字节串即可。 首先是普通的使用，以MD5举例： >>> import hashlib >>> m = hashlib.md5(\"hello world\".encode(\"u8\")) >>> m.digest() b'^\\xb6;\\xbb\\xe0\\x1e\\xee\\xd0\\x93\\xcb\"\\xbb\\x8fZ\\xcd\\xc3' 如果对一个大字符串生成hash值，可使用update()方法在原有hash对象基础上进行内容更新： >>> m = hashlib.md5() >>> m.update(\"line1\".encode(\"u8\")) >>> m.update(\"line2\".encode(\"u8\")) >>> m.update(\"line3\".encode(\"u8\")) >>> m.digest() b'\\xcc\\x0c\\x81\\xcdsha256的加密方式与md5的加密使用相同，如下所示： >>> m = hashlib.sha256(\"hello world\".encode(\"u8\")) >>> m.digest() b\"\\xb9M'\\xb9\\x93M>\\x08\\xa5.R\\xd7\\xda}\\xab\\xfa\\xc4\\x84\\xef\\xe3zS\\x80\\xee\\x90\\x88\\xf7\\xac\\xe2\\xef\\xcd\\xe9\" 基本使用就介绍完毕了，是不是非常简单呢？ 撞库介绍 在密码破解领域，有一个百试不爽的方法就是撞库破解。 撞库是指通过一个庞大的数据库来记录未加密字符串与加密后的值的一种映射关系，理论上来说只要这个数据库无限大，那么生成的hash值都能在这里找到其对应的生成字符串。 举个例子： 我现在有1个字符串，I LOVE YOU。 对他进行hash加密得到的结果假设为3242。 现在将这个对应关系放到数据库中，及3242这个hash值对应的字符串为I LOVE YOU。 如果有人要对3242进行反解，通过查询数据库即可知道结果。 这个思路非常的简单粗暴，但个人是不可能进行数据库的完善和搭建。 在Google上如果搜索MD5反解，应该能找到一些撞库网站，但大多数都是付费的，如果感兴趣可以试一试。 加盐验证 为了防止你的加密内容被撞库反解，我们可以使用加盐的策略来对已加密的内容进行二次加密。 整体思路如下，我们以一个普通的用户登陆作为案例： Server端有一个固定的字符串，被称之为盐 用户第一次注册后，要将用户名和密码写入到数据库中，此时数据库中的密码应当密文存储，且不可被反解，做到仅有用户知道自己的密码，连开发人员都不得而知的状态是最完美的 存储密码的时候，对明文密码进行hash加密，并在其中掺盐，得到密文hash密码进行存储 用户登陆的时候，将用户登陆时发送的明文密码也进行hash加密和掺盐，并且通过登陆的用户名获取到存储在数据库中的密文hash密码，两者进行比对，若一致则登陆成功，若不一致则登陆失败 当数据库被黑客攻破后，只要保证盐不泄露，那么他就没有任何办法破解出用户的密码 理论很复杂，实操很简单。如下所示： >>> salt = \"slat\".encode(\"u8\") >>> userPwd = \"123456\".encode(\"u8\") >>> hashObject = hashlib.md5(salt) # ❶ >>> hashObject.update(userPwd) # ❷ >>> savePwd = hashObject.digest() # ❶ >>> savePwd b'ELr\\x05\\x14$z=\\x1d\\x19(^4L>n' >>> >>> >>> reLoginPwd = \"123456\".encode(\"u8\") >>> hashObject = hashlib.md5(salt) # ❶ >>> hashObject.update(reLoginPwd)　 # ❷ >>> getPwd = hashObject.digest() # ❸ >>> getPwd == savePwd # ❹ True ❶：加盐 ❷：加入用户内容 ❸：获得存储密码 ❹：对比用户重登陆的密码hash值是否和以存储的密码hash值一致 文件校验 在Server端对Client端发送文件的过程中，该文件可能被黑客截取做出一些篡改，如下所示： server端 ---------> client端 | | 可能被黑客窃取，修改下载文件 此时就需要使用文件校验来确保安全性了： 在发送文件的时候要让用户知道我们文件本身的hash校验值 用户下载完成后将得出的结果与我们的hash校验值做对比 如果一致则文件没有被篡改过 如果不一致则文件已被篡改过 我们有2种方式，来进行文件校验的实现。 下面将采用模拟Server端生成文件校验hash值的整个过程。 首先是方式1，将文件所有内容hash校验一遍，安全系数最高，速度最慢。 res = \"\"m = hashlib.sha256()f = open(file=\"test.txt\",mode=\"rb\")while 1: temp = f.read(1024) # ❶ m.update(temp) # ❷ if not len(temp): f.close() hash_res = m.hexdigest() # ❸ breakprint(hash_res) # 48dd13d8629b4a15f791dec773cab271895187a11683a3d19d4877a8c256cb70 ❶：更新hash值 ❷：由于打开文件的模式是rb，故temp本身就是bytes类型，所以不用encode() ❸：当所有内容读取完毕后，生成文件的校验hash值 其次是方式2，文件指定指针点来更新hash值，安全系数小幅度降低，但速度大幅度提升。 迅雷等下载软件均采用此种方式，前提是要让用户知道我们seek()的文件指针点在哪里: m = hashlib.sha256()f = open(file=\"1.txt\",mode=\"rb\")# ❶f.seek(20,0)temp = f.read(10)m.update(temp)# ❷f.seek(20,1)temp = f.read(10)m.update(temp)# ❸f.seek(-20,2)temp = f.read(10)m.update(temp)# ❹hash_res = m.hexdigest()print(hash_res) # daffa21b2be95802d2beeb1f66ce5feb61195e31074120a605421563f775e360 ❶：在文件的开始位置，读取10个bytes，用作生成hash值的源内容部分 ❷：在文件的中间位置，读取10个bytes，用作生成hash值的源内容部分 ❸：在文件的末尾位置，读取10个bytes，用作生成hash值的源内容部分 ❹：生成文件校验的hash值，该hash值共由30个bytes组成，分别来自文件的开始、中间、末尾位置。Ps：指针点越多，安全性越高，但是速度越慢 hmac模块 hmac模块的使用与hashlib大同小异。但是在某些方面会比hashlib更优秀： 它也是一个内置模块，以下是简单的使用： >>> import hmac>>> hmacObject = hmac.new(\"hello world\".encode(\"u8\"), digestmod=\"md5\")>>> hmacObject.update(\"salt\".encode(\"u8\"))>>> hashValue = hmacObject.digest()>>> hashValueb'\\xf3Q\\xff\\xb2V{\\x88\\xfe\\x0e\\x9aX\\x19\\xbf\\x12\\xf3>> Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-10 20:22:53 "},"Python/Python模块与包/configparser.html":{"url":"Python/Python模块与包/configparser.html","title":"内置模块：configparser","keywords":"","body":"configparser简介 configparser模块是Python的内置模块，提供了配置文件创建、解析、修改等功能。 官方文档 值得注意的是，在Python2中，它的命名是驼峰式的，为ConfigParser。 认识配置文件 配置文件常以.ini或者.cfg作为后缀，注释方式有2种。 #注释与;注释，一个配置项是以键值对方式进行存储，通过:或者=分割。 [regulator] user_name : Yunya age = 21 sex = male is_admin = true salary = 20 [path] RUN_LOG_FILE = log/run.log $true ERROR_LOG_FILE = log/error.log $true 如果某一个配置项后面加上了$true，则$true在解析的时候将被替换为BASE_DIR，也就说该$true会被替换为完整的路径。 我个人喜欢将一个配置文件分成3部分，尽管下面的叫法并不是非常的正确： 配置项分类（classify）：以[]包裹的数据项，或者称为block 配置项的键（key）：:或者=左边的数据项 配置项的值（value）：:或者=右边的数据项 字典一样操作 configparser模块能够让配置文件像字典一样进行操作。 下面介绍3个该模块提供的基本方法： 方法 描述 ConfigParser() 创建文档对象 documentObject.read(filenames, encoding=None) 读取配置文件 documentObject.write(fp) 将文档对象写入磁盘 如下示例，对配置文件进行读取： import configparser # 创建文档对象，并且读取配置文件 documentObject = configparser.ConfigParser() documentObject.read(filenames=\"./config.ini\", encoding=\"u8\") # 获取所有classify classifyAllTuple = tuple(documentObject.items()) # 获取所有的key和value for classify in documentObject.values(): print(dict(classify.items())) # 获取指定classify下的指定key的value # 需要自己做类型转换 userAge = documentObject[\"regulator\"][\"age\"] print(int(userAge)) 新增一个配置文件，先创建一个空的文档对象，然后加入一些子字典，将他看做嵌套字典，最后进行写入磁盘即可： import configparser # 先创建一些classify以及kev-value配置项 defaultClassify = { \"ip\": \"0.0.0.0\", \"port\": 65535, } serverClassify = { \"ip\": \"192.168.0.120\", \"port\": 65536, } loginClassify = { \"user\": \"root\", \"password\": \"123456\", \"db\": 1, \"verify\": False, } # 创建一个空文档对象 noneDocumentObject = configparser.ConfigParser() # 为这个空文档对象，添加classify，将它看成字典操作即可 noneDocumentObject[\"DEFAULT\"] = defaultClassify noneDocumentObject[\"SERVER\"] = serverClassify noneDocumentObject[\"LOGIN\"] = loginClassify # 将文档对象写入到磁盘 with open(file=\"./newConfig.ini\", mode=\"wt\", encoding=\"utf8\") as f: noneDocumentObject.write(fp=f) 修改一个配置项，对字典中的value进行更新。最后将文档对象写入到磁盘： import configparser # 创建文档对象，并且读取配置文件 documentObject = configparser.ConfigParser() documentObject.read(filenames=\"./config.ini\", encoding=\"u8\") # 修改regulator下的age为30岁，注意这里必须为str类型 documentObject[\"regulator\"][\"age\"] = \"30\" # 写入磁盘 with open(\"./config.ini\", mode=\"wt\", encoding=\"utf8\") as f: documentObject.write(fp=f) 读取配置文件 configparser模块此外也为文档对象提供了一些专用的方法，来操作配置文件。 如下所示： 方法 描述 sections(self) 拿到所有的classify options(self, section) 指定一个classify，拿到其下所有的key items(self, section=_UNSET, raw=False, vars=None) 指定一个classify，拿到其下所有的key和value get(self, section, option) 指定classify和key，拿到具体的value，并将其转换为Python中的str类型 getint(self, section, option) 指定classify和key，拿到具体的value，并将其转换为Python中的int类型 getfloat(self, section, option) 指定classify和key，拿到具体的value，并将其转换为Python中的float类型，保留1位小数 getboolean(self, section, option) 指定classify和key，拿到具体的value，并将其转换为Python中的bool类型 示例演示： import configparser # 初始化文档对象，并且读取配置文件 documentObject = configparser.ConfigParser() documentObject.read(filenames=\"./config.ini\", encoding=\"utf8\") # 获取配置文件中所有的classify allClassify = documentObject.sections() print(allClassify) # ['regulator', 'path'] # 获取classify（regulator）下所有的key regulatorKeys = documentObject.options(section=allClassify[0]) print(regulatorKeys) # ['user_name', 'age', 'sex', 'is_admin', 'salary'] # 获取classify(regulator)下所有的键值对 regulatorItems = documentObject.items(section=allClassify[0]) print(regulatorItems) #　[('user_name', 'Yunya'), ('age', '21'), ('sex', 'male'), ('is_admin', 'true'),('salary', '20')] # 获取classify(regulator)下的key(user_name)对应的value # get()会自动将value转换为str类型 name = documentObject.get(section=allClassify[0], option=\"user_name\") print(name) # Yunya # 获取classify(regulator)下的key(age)对应的value # getint()会自动将value转换为int类型 age = documentObject.getint(section=allClassify[0], option=\"age\") print(age) # 21 # 获取classify(regulator)下的key(is_admin)对应的value # getboolean()会自动将value转换为bool类型 isAdimin = documentObject.getboolean(section=allClassify[0], option=\"is_admin\") print(isAdimin) # True # 获取classify(regulator)下的key(salary)对应的value # getfloat()会自动将value转换为float类型，并保留一位小数 salary = documentObject.getfloat(section=allClassify[0], option=\"salary\") print(salary) # 20.0 修改配置文件 configparser模块也提供了一些修改配置文件的方法。 如下表所示，但我很少会使用到，所以不再进行案例书写了： 方法 描述 add_section(self, section) 向文档对象中增加一个classify set(self, section, option, value=None) 设置或添加文档对象的键值对 remove_section(self, section) 删除文档对象中的的一个classify remove_options(self, section, option) 删除文档对象中的一组键值对 has_section(self, section) 判断文档对象中的一个classify是否存在 has_options(self, section, option) 判断文档对象中的一个key是否存在 个人更加倾向于通过字典的方式操纵文档对象。 特殊的DEFAULT 配置文件中有1个名为DEFAULT的classify，它提供了一些默认设置。 如果你的配置文件中没有显式的配置DEFAULT这个classify，则通过字典操作任然会获取到到它。但是若通过方法进行操作，该classify则不会出现。 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-10 21:40:16 "},"Python/Python模块与包/subprocess.html":{"url":"Python/Python模块与包/subprocess.html","title":"内置模块：subprocess","keywords":"","body":"subprocess简介 subprocess模块最早在Python2.4中引入，它会生成一个子进程，该子进程可以执行shell命令，并且会监听系统的标准输入管道、标准输出管道、标准错误管道，在命令执行完毕后，将结果进行返回到对应的管道中。 官方文档 如下图所示： 它的功能虽然看上去十分单一，但是应用是非常广泛的。 试想，你是一名运维人员，编写了1个脚本，每天定时定点的在100台机器上获得它们的状态信息，就可以用到该模块。 让脚本在宿主机上通过该模块执行命令，并且拿到命令的返回结果，再通过网络返回结果并对其进行分析，依此判定各个宿主机的工作状态。 简单的使用 对于简单的使用，记住这4个方法即可，如下表所示： 方法 描述 subprocess.Popen(...) 执行系统命令，并将执行结果放入对应的管道中，返回一个Popen对象 PopenObject.stdout.read() 从标准输出管道中获取执行结果 PopenObject.stderr.read() 从标准错误管道中获取执行结果 PopenObject.stdin.write() 通过标准输入管道与系统进行交互 subprocess.Popen()的可指定参数比较多，下面是它的签名： def __init__(self, args, bufsize=-1, executable=None, stdin=None, stdout=None, stderr=None, preexec_fn=None, close_fds=_PLATFORM_DEFAULT_CLOSE_FDS, shell=False, cwd=None, env=None, universal_newlines=False, startupinfo=None, creationflags=0, restore_signals=True, start_new_session=False, pass_fds=(), *, encoding=None, errors=None): 常用参数的释义如下： args：将要执行的命令，可以是str类型或者list、tuple类型 bufsize：指定缓冲大小，0是没有，1是默认 executable：要执行的替换程序 stdin/stdout/stderr：标准输入、输出、错误管道的句柄 preexec_fn：仅在Unix平台下有效。指定一个可调用对象，通常是指函数，它将在fork出的子程序运行之前调用 close_sds：在Windows平台下，如果该参数指定为True，则fork出的子程序将不会继承父程序的标准输入、输出、错误管道中传输的内容，一般设置默认即可 shell：如果为True，则通过shell执行命令 cwd：设置子进程执行时的工作目录 env：用于指定子进程的环境变量，如果为None，子进程将继承父进程的环境变了 Universal_newlines：如果为True，则不区分平台，统一将换行符定义为\\n 简单的执行命令并获取返回结果： import subprocess popenObject = subprocess.Popen( args=\"ping www.baidu.com\", shell=True, stdin=subprocess.PIPE, stderr=subprocess.PIPE, stdout=subprocess.PIPE, ) successMessage, errorMessage = popenObject.stdout.read(), popenObject.stderr.read() print(successMessage.decode(\"gbk\")) print(errorMessage.decode(\"gbk\")) popenObject.stdout.close() popenObject.stderr.close() 注意事项： 如果你的测试环境是Windows，则对执行结果的解码方式需要使用GBK，因为Windows的终端字符编码方式就是GBK。而如果是Unix平台只需要使用UTF8即可。 通过stdin与与宿主机进行交互： import subprocess # 执行的语句 stdInCommand = \"\"\"print (\\\"Hello, world\\\")\"\"\" # 通过subprocess在测试机上启动1个新的Python REPT交互式环境 popenObject = subprocess.Popen( args=\"python\", shell=True, stdin=subprocess.PIPE, stderr=subprocess.PIPE, stdout=subprocess.PIPE, ) # 写入内容，进行交互，注意每次交互完毕后都要立即关闭管道 popenObject.stdin.write(stdInCommand.encode(\"utf8\")) popenObject.stdin.close() # 获取并打印结果 successMessage, errorMessage = popenObject.stdout.read(), popenObject.stderr.read() print(successMessage.decode(\"gbk\")) print(errorMessage.decode(\"gbk\")) popenObject.stdout.close() popenObject.stderr.close() 更多的操作 以下方法了解即可，其实用的并不多： 方法 描述 subprocess.run() 执行命令，不返回结果，拥有timeout参数，可设定超时时间 subprocess.call() 执行命令，并且返回执行状态（bool类型，0成功，1失败） subprocess.check_call() 执行命令，并且返回执行结果和执行状态，如果命令执行失败则抛出异常， subprocess.getstatusoutput() 执行命令，返回1个tuple，[0]是执行状态，[1]是执行结果 subprocess.getoutput() 执行命令，返回执行结果（str类型） subprocess.check_output() 执行命令，返回执行结果（bytes类型） 这里就不再进行演示了，感兴趣的可以参见官方文档。 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-10 20:29:13 "},"Python/Python模块与包/logging.html":{"url":"Python/Python模块与包/logging.html","title":"内置模块：logging","keywords":"","body":"logging简介 Python内置模块logging提供了日志记录相关功能，是一款非常强大且常用的模块。 官方文档 它的使用如果刨根问底可能比较复杂，所以里仅介绍1种最方便的使用方式，其他的使用方式日常开发中基本不会用到，故不进行介绍。 简单了解 logging模块中规定日志拥有6个级别，每个级别都有单词、数字2种表现形式，如下表所示： level number 描述 logging.critical 50 致命错误 logging.error 40 常规错误 logging.warning 30 警告信息 logging.info 20 普通信息 logging.debug 10 调试信息 logging.NOSET 0 ... logging.NOSET一般不会进行使用，所以你也可以认为logging的日志级别只有5个。 等级越低，越能看到更多的日志信息，它会根据等级依次向上推进，如下图所示： 默认的等级是30，也就是warning级别，仅能看到critical、error、warning这个级别的日志，而info和debug则看不见。 如下所示： import logging logging.debug(\"debug\") logging.info(\"info..\") logging.warning(\"warning..\") logging.error(\"error..\") logging.critical(\"critical..\") # ❶ ❷ # WARNING:root:warning.. # ERROR:root:error.. # CRITICAL:root:critical.. ❶：root指的是记录日志的用户，默认就是root ❷：默认的日志输出位置是向屏幕，也可以将日志输出至文件 配置文件 如果想快速的使用logging模块进行日志记录。 可以使用配置文件的形式，一般来说该配置文件会存放至settings.py中： import os # 定义2种日志记录格式 # 标准的：standard_format # 简单的：simple_format standard_format = \"[%(asctime)s][%(threadName)s:%(thread)d][username:%(name)s][%(filename)s:%(lineno)d]\" \\ \"[%(levelname)s][%(message)s]\" simple_format = \"[%(levelname)s][%(asctime)s][%(filename)s:%(lineno)d]%(message)s\" # 定义日志存放路径 LOG_DIR = os.path.dirname(os.path.abspath(__file__)) if not os.path.isdir(os.path.join(LOG_DIR, \"log\")): os.mkdir(os.path.join(LOG_DIR, \"log\")) LOG_PATH = os.path.join(LOG_DIR, \"log\", \"run.log\") # LOGGING的应用配置字典，无需太大改动，开箱即用 LOGGING_SETTING = { \"version\": 1, \"disable_existing_loggers\": False, # 添加2种日志记录格式 \"formatters\": { \"standard\": { \"format\": standard_format }, \"simple\": { \"format\": simple_format }, }, # 控制流相关配置 \"handlers\": { # 输出到终端(logging.StreamHandler)，采用简单的日志记录格式 \"screen\": { \"level\": \"DEBUG\", \"class\": \"logging.StreamHandler\", \"formatter\": \"simple\" }, # 输出到文件(logging.handlers.RotatingFileHandler)，采用标准的日志记录格式 \"file\": { \"level\": \"DEBUG\", \"class\": \"logging.handlers.RotatingFileHandler\", \"formatter\": \"standard\", # 日志文件位置及名称，若不指定则默认在当前目录下 \"filename\": LOG_PATH, # 每个日志文件最大5M，当存在5个日志文件后开启日志轮转 \"maxBytes\": 1024*1024*5, \"backupCount\": 5, \"encoding\": \"utf-8\", }, }, # 定义不同用户采用的控制流 \"loggers\": { # 如果不指定用户，或指定用户未在loggers字典中，则采用该配置 \"\": { \"handlers\": [\"screen\", \"file\"], # 以控制流相关配置中过滤级别为准，这里是1次过滤，控制流中是2次过滤 \"level\": \"DEBUG\", # 关闭日志冒泡，切勿手动更改 \"propagate\": False, }, # 若指定用户为testUser，则采用该配置 \"testUser\": { \"handlers\": [\"screen\"], \"level\": \"DEBUG\", \"propagate\": False, } } } 项目应用 如何使用该配置文件？我们假设项目目录如下： Project/ |-- bin/ | |-- run.py # 启动脚本 | |-- view/ | |-- main.py # 主程序 | |-- common.py # 公用模块 |-- settings.py # logging配置文件 首先是启动脚本： # bin/run.py import os import sys sys.path.append( os.path.dirname(os.path.dirname(__file__)) ) from view.main import main if __name__ == \"__main__\": main() 其次是主程序： # view/main.py from common import logger def main(): logger.debug(\"debug\") logger.info(\"info..\") logger.warning(\"warning..\") logger.error(\"error..\") logger.critical(\"critical..\") 最后是公用模块： # common.py from logging import config from logging import getLogger from settings import LOGGING_SETTING config.dictConfig(LOGGING_SETTING) logger = getLogger(\"adminstartion\") 可以看到在公用模块中导入了配置字典，并且将它应用进了logging模块。 然后获取了一个日志对象logger，在以后使用时都使用这个logger进行日志记录即可，这里getLogger()的用户名是adminstartion，未定义在LOGGIN_SETTING的loggers中，故会采用第一个配置，也就是下面这个： \"loggers\": { # 如果不指定用户，或指定用户未在loggers字典中，则采用该配置 \"\": { \"handlers\": [\"screen\", \"file\"], \"level\": \"DEBUG\", \"propagate\": False, }, ... } Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-10 20:30:04 "},"Python/Python模块与包/re.html":{"url":"Python/Python模块与包/re.html","title":"内置模块：re","keywords":"","body":"re简介 正则表达式其本身就是一种小型的，高度专业化的编程语言。 在Python中，它被内嵌在了re模块里面，正则表达式模式被编译成一系列的字节码，然后由用C编写的匹配引擎执行。 官方文档 本文仅针对可能用到的方法进行描述，对不常用的方法等进行了筛选。 方法一览 符号大全 以下是正则表达式的符号大全： 符号 中文名称 释义 . 通配符 匹配除\\n之外的任意字符，如果想匹配\\n可更换匹配模式为re.S或re.DOTALL ^ 开始符 匹配以特定字符开始的字符串，在检测时只会检测开头第一个字符并立即返回结果 $ 结束符 匹配以特定字符结尾的字符串，在检测时只会检测结尾最后一个字符并立即返回结果 * 可有重复符 代表可以取0-∞位*号前面的字符（默认贪婪取值，可通过?取消贪婪模式） + 必有重复符 代表可以取1-∞位+号前面的字符（默认贪婪取值，可通过?取消贪婪模式） ? 单一重复符 代表可以取1-∞位?号前面的字符（默认贪婪取值，可通过?取消贪婪模式） {n,m} 范围重复符 代表可以取到n-m位{n,m}前面的字符（默认贪婪取值，可通过?取消贪婪模式） {n} 精确重复符 代表可以精确取到n位{n}前面的字符 [] 字符集 在[]中多个字符仅能匹配到1个，并且字符集中所有符号失去特殊意义，仅有- ^ \\ 这3个符号在字符集中具有特殊意义 [-] 区间符 字符集中的-号代表可以取从多少到多少区间的值，按照ASCII码排序，比如[a-z0-9A-Z]代表这1位取全部的英文字母和数字 排除符 字符集中的^号代表非的作用，比如[^0-9]代表这1位并非是数字 [\\] 转义符 转义符如果在字符集中使用，可以为特定的字符赋予特殊的意义 \\ 转义符 转义符如果在字符集外使用，可以为特定的字符赋予特殊的意义，并且还可以让特定的字符失去特殊的意义，但是如果未用r原始字符串进行正则匹配，则可能会导致令人意外的情况发生 \\d ... 匹配任何十进制数，它相当于在字符集中使用[0-9] \\D ... 匹配任何非十进制数，它相当于在字符集中使用[^0-9] \\s ... 匹配任何空白字符，它相当于在字符集中使用[\\t\\n\\r\\f\\v] \\S ... 匹配任何非空白字符，它相当于在字符集中使用[^\\t\\n\\r\\f\\v] \\w ... 匹配任何字母数字下划线字符,它相当于在字符集中使用[a-z A-Z 0-9] \\W ... 匹配任何非字母数字下划线字符,它相当于在字符集中使用[a-z A-Z 0-9] \\b ... 匹配一个特殊字符边界，比如空格,&.#等(不常用) 管道符 相当于或，注意与字符集里的区别，管道符将前后分为2段，左右看做1个整体，而字符集中的或仅仅代表从众多选项中拿出1个 () 分组符 将多个元素字符看做一个整体，也就是将它们当做一个元素字符进行匹配，若整个匹配规则中无子分组，则默认的匹配结果为一组 (?=exp) 零宽先行断言 匹配后面为exp的内容 (? 零宽后行断言 匹配前面为exp的内容 (?!exp) 零宽负向先行断言 匹配后面不能是exp的内容 (? 零宽负向后行断言 匹配前面不能是exp的内容 匹配方法 以下是re模块提供的正则匹配方法： 方法 描述 findall() 将所有的匹配结果返回至1个列表中 finditer() 将所有的匹配结果返回至1个迭代器中 search() 将首次匹配的结果返回至search对象中，可通过group()进行取值 match() 在search()基础上添加了^，使之只能在开头匹配 group() 通过该方法对search对象进行取值操作，返回一个或者多个匹配的子组 groups() 通过该方法对search对象进行取值操作，返回一个元组，包含所有匹配的子组 groupdict() 通过该方法对search对象进行取值操作，返回一个字典，包含了所有的具名子组 split() 对字符串进行分割，其算法可能导致令人意外的情况发生 sub() 对字符串进行替换，最少需要3个参数，返回一个新的字符串 subn() 对字符串进行替换，最少需要3个参数，返回一个元祖，其中包含了替换成功了几次 complie() 可以将一个标示符赋予指定的规则，达到简化重复操作的目的 匹配模式 以下是re模块提供的正则匹配模式： 模式简写 模式全写 描述 re.I re.IGNORECASE 不分大小写字母的匹配模式 re.M re.MULTILINE 视为多行的匹配模式，以\\n作为行分割符 re.S re.DOTALL 视为单行的匹配模式，即通配符可以匹配\\n re.U re.UNICODE 宽字符匹配模式，即支持匹配占4个字符的UTF-16匹配模式 创建正则 re.findall() 在测试阶段，我们大部分示例都会使用re.findall()方法进行测试。 它的函数签名如下： def findall(pattern, string, flags=0): 参数释义： pattern：匹配规则 string：被匹配字符串 flags：匹配模式 一次简单的使用，匹配以hello开头且以exp结尾的子串，采用多行匹配模式： import re string = \"hello world\\nhello regexp\\nhello python\\n\" resultList = re.findall( pattern=r\"^hello.*exp$\", string=string, flags=re.M ) print(resultList) # ['hello regexp'] 基础符号 . 通配符 .通配符会匹配除\\n之外的任意字符，如果想匹配\\n可更换匹配模式为re.S或re.DOTALL。 如下示例，匹配11个除开\\n之外的任意字符组成的子串： import re rule = \".\" * 11 string = \"hello world\\n123456abcdeABCDE\" resultList = re.findall(pattern=rule, string=string) print(resultList) # ['hello world', '123456abcde'] ^ 开始符 ^开始符会匹配以特定字符开始的字符串，在检测时只会检测开头第一个字符并立即返回结果。 如下示例，匹配以P开头且后面必须是ython加上7个除开\\n的任意字符的子串： import re rule = \"^Python.......\" string = \"Python regexp module\" resultList = re.findall(pattern=rule, string=string) print(resultList) # ['Python regexp'] $ 结束符 $结束符会匹配以特定字符结尾的字符串，在检测时只会检测结尾最后一个字符并立即返回结果。 如下所示，匹配以p结束，且前面2个字符必须是E与x的子串，区分大小写： import re rule = \"Exp$\" string = \"Python regexp regExp RegExp\" resultList = re.findall(pattern=rule, string=string) print(resultList) # ['Exp'] 重复符 * 可有重复 *代表可以取0-∞位*号前面的字符（默认贪婪取值，可通过?取消贪婪模式） 如下示例，匹配必须是以h开头，后面可以有0个也可以有多个除了\\n外的任意字符，紧接着\\n后继续匹配0个或者n个除了\\n外的任意字符，最后必须以p进行结尾的子串： import re rule = \"^h.*\\n.*p$\" string = \"hello Python\\nregexp\" resultList = re.findall(pattern=rule, string=string) print(resultList) # ['hello Python\\nregexp'] 上面这个示例，有3个条件是必须的。 h开头 中间必须有\\n p结束 所以下面这个字符串也会被匹配到： string = \"h\\np\" + 必有重复 +代表可以取1-∞位+号前面的字符（默认贪婪取值，可通过?取消贪婪模式） 如下示例，匹配必须是以h开头，后面可以有1个也可以有多个除了\\n外的任意字符，紧接着\\n后继续匹配1个或者n个除了\\n外的任意字符，最后必须以p进行结尾的子串： import re rule = \"^h.+\\n.+p$\" string = \"hello Python\\nregexp\" resultList = re.findall(pattern=rule, string=string) print(resultList) # ['hello Python\\nregexp'] 上面这个示例，有5个条件是必须的： h开头 h后面必须至少有1个任意字符 中间必须有\\n \\n后面必须至少有1个任意字符 p结束 所以下面这个字符串不会被匹配到： string = \"h\\np\" ? 单一重复 ?代表可以取1-∞位?号前面的字符（默认贪婪取值，可通过?取消贪婪模式） 如下示例，匹配可以是1开头，也可以不是1开头且后面是2345678且以9结尾的字符串： import re rule = \"^1?23456789$\" string = \"123456789\" resultList = re.findall(pattern=rule, string=string) print(resultList) # ['123456789'] 上面这个示例，有2个条件是必须的： 字符串的开头如果不是1，则必须是2 后面必须跟上345678，且以9结尾 所以下面这个字符串也会被匹配到： string = \"23456789\" {n,m} 范围重复 {n,m}代表可以取到n-m位{n,m}前面的字符，（默认贪婪取值，可通过?取消贪婪模式） 如下示例，匹配包含4个或者3个连续是1的子串： import re rule = \"1{3,4}\" string = \"1111111\" resultList = re.findall(pattern=rule, string=string) print(resultList) # ['1111', '111'] {n} 精确重复 {n}代表可以精确取到n位{n}前面的字符。 如下示例，匹配包含3个连续的1的子串： import re rule = \"1{3}\" string = \"1111111\" resultList = re.findall(pattern=rule, string=string) print(resultList) # ['111', '111'] 取消贪婪匹配 默认的*，+，?，{n,m}都是贪婪取值。 即有多个就取多个，没有多个才少取。 在它们后面加上?即可取消贪婪匹配，如下示例： import re ruleList = [ # 取0个或者多个a，取消贪婪后取0个 \"a*?\", # 取1个或者多个a，取消贪婪后取1个 \"a+?\", # 取0个或者1个a，取消贪婪后取0个 \"a??\", # 取3个或者4个a，取消贪婪后取3个 \"a{3,4}\" ] string = \"a\" * 7 for rule in ruleList: resultList = re.findall(pattern=rule, string=string) print(resultList) # ['', '', '', '', '', '', '', ''] # ['a', 'a', 'a', 'a', 'a', 'a', 'a'] # ['', '', '', '', '', '', '', ''] # ['aaaa', 'aaa'] 字符集 [] 字符集 在[]中多个字符仅能匹配到1个，并且字符集中所有符号失去特殊意义，仅有- ^ \\ 这3个符号在字符集中具有特殊意义。 如下示例，匹配包含1a或者2a或者3a的子串： import re rule = \"[123]a\" string = \"1a2a3a1b2b3b\" resultList = re.findall(pattern=rule, string=string) print(resultList) # ['1a', '2a', '3a'] [-]区间符 字符集中的-号代表可以取从多少到多少区间的值，按照ASCII码排序，比如[a-z0-9A-Z]代表这1位取全部的英文字母和数字。 如下示例，匹配所有由连续的字母或者数字组成的子串： import re rule = \"[0-9A-Za-z]+\" string = \"1b23c4d\\n2342bbc\" resultList = re.findall(pattern=rule, string=string) print(resultList) # ['1b23c4d', '2342bbc'] 排除符 字符集中的^号代表非的作用，比如[^0-9]代表这1位并非是数字。 如下所示，匹配结尾不为数字的子串，匹配模式为多行匹配： import re rule = \".+[^0-9]$\" string = \"abc\\n12x\\n345\" resultList = re.findall(pattern=rule, string=string, flags=re.M) print(resultList) # ['abc', '12x'] [\\]转义符 转义符如果在字符集中使用，可以为特定的字符赋予特殊的意义。 如下所示，\\w是具有特殊意义的字符，作用是匹配字母数字下划线字符。 它可以在字符集中使用： import re rule = \"[\\w]+\" string = \"abc\\n12x\\n345\" resultList = re.findall(pattern=rule, string=string, flags=re.M) print(resultList) # ['abc', '12x', '345'] 转义字符 \\ 转义符 转义符如果在字符集外使用，可以为特定的字符赋予特殊的意义，并且还可以让特定的字符失去特殊的意义，但是如果未用r原始字符串进行正则匹配，则可能会导致令人意外的情况发生。 如，失去特殊意义： .本来是通配符，如果是\\.就是普通的.，再也没有任何意义了。 如下示例，匹配一个url： import re rule = \"w{3}\\.\\w+\\.com\" string = \"www.google.com www.biying.com\" resultList = re.findall(pattern=rule, string=string) print(resultList) # ['www.google.com', 'www.biying.com'] 以下是常用加上\\后就拥有特殊意义的字符： 符号 中文名称 释义 \\d ... 匹配任何十进制数，它相当于在字符集中使用[0-9] \\D ... 匹配任何非十进制数，它相当于在字符集中使用[^0-9] \\s ... 匹配任何空白字符，它相当于在字符集中使用[\\t\\n\\r\\f\\v] \\S ... 匹配任何非空白字符，它相当于在字符集中使用[^\\t\\n\\r\\f\\v] \\w ... 匹配任何字母数字下划线字符,它相当于在字符集中使用[a-z A-Z 0-9] \\W ... 匹配任何非字母数字下划线字符,它相当于在字符集中使用[a-z A-Z 0-9] \\b ... 匹配一个特殊字符边界，比如空格,&.#等(不常用) \\d和\\D \\d可以匹配任何十进制数，它相当于在字符集中使用[0-9]： import re rule = \"\\d+\" string = \"123 abc 1a2b3c\" resultList = re.findall(pattern=rule, string=string) print(resultList) # ['123', '1', '2', '3'] \\D可以匹配任何非十进制数，它相当于在字符集中使用[^0-9]： import re rule = \"\\D+\" string = \"123 abc 1a2b3c\" resultList = re.findall(pattern=rule, string=string) print(resultList) # [' abc ', 'a', 'b', 'c'] \\s和\\S \\s可以匹配任何空白字符，它相当于在字符集中使用[\\t\\n\\r\\f\\v]： import re rule = \"\\s\" string = \"123 abc 1a2b3c\" resultList = re.findall(pattern=rule, string=string) print(resultList) # [' ', ' '] \\S匹配任何非空白字符，它相当于在字符集中使用[^\\t\\n\\r\\f\\v]： import re rule = \"\\S\" string = \"123 abc 1a2b3c\" resultList = re.findall(pattern=rule, string=string) print(resultList) # ['1', '2', '3', 'a', 'b', 'c', '1', 'a', '2', 'b', '3', 'c'] \\w和\\W \\w可以匹配任何字母数字下划线字符,它相当于在字符集中使用[a-z A-Z 0-9]： import re rule = \"\\w+\" string = \"user_name123 \\t\\n\\f\" resultList = re.findall(pattern=rule, string=string) print(resultList) # ['user_name123'] \\W可以匹配任何非字母数字下划线字符,它相当于在字符集中使用[a-z A-Z 0-9]： import re rule = \"\\W+\" string = \"user_name123 \\t\\n\\f\" resultList = re.findall(pattern=rule, string=string) print(resultList) # [' \\t\\n\\x0c'] 原始字符串 下面这种情况，可能导致re匹配的结果和预料的结果不符。 我想匹配1个\\或者\\d： import re rule = \"[\\\\d]\" string = \"123\\\\456\\\\\" resultList = re.findall(pattern=rule, string=string) print(resultList) # ['1', '2', '3', '4', '5', '6'] 是什么原因导致了这样的情况？由于re模块建立在Python解释器之上，所以\\\\d会被分解成\\d，故会出现这样的情况。如下图所示： 如何解决这个问题呢？你可能想使用这个匹配规则： rule = \"[\\\\\\\\d]\" 但是这样的匹配结果是： ['\\\\', '\\\\'] d被当成了单独的普通匹配字符了。 其实最有效的办法是对rule采用原始字符串处理： import re rule = r\"[\\\\\\d]\" string = \"123\\\\456\\\\\" resultList = re.findall(pattern=rule, string=string) print(resultList) # ['1', '2', '3', '\\\\', '4', '5', '6', '\\\\'] 所以无论今后在什么场合下，对于rule都使用原始字符串定义就ok了。 管道 | 管道符 |管道符相当于或，注意与字符集里的区别，管道符将前后分为2段，左右看做1个整体，而字符集中的或仅仅代表从众多选项中拿出1个。 如下所示，匹配abc123或者456xyz的子串： import re rule = r\"abc123|456xyz\" string = \"abcdefgabc123xyzqud456xyz\" resultList = re.findall(pattern=rule, string=string) print(resultList) # ['abc123', '456xyz'] 分组 推荐在分组时，使用re.search()或者re.match()进行操作。 () 分组符 ()分组符将多个元素字符看做一个整体，也就是将它们当做一个元素字符进行匹配。若整个匹配规则中无子分组，则默认的匹配结果为一组： 如下，没有定义子分组，则默认的匹配结果为1组。 因此可通过group(0)方法获取整组内容： import re rule = r\".*\" string = \"hello world\" searchObject = re.search(pattern=rule, string=string) print(searchObject.group(0)) # hello world 匿名分组 匿名分组即没有名字的分组，单纯的用括号包裹即可。 如果定义了子分组，则可以通过groups()方法来查看所有的子分组。 如下所示，定义了3个匿名分组，分别是拿到标签名字，标签内容，标签结束 import re rule = r\"(.*)\" string = \"hello world\" searchObject = re.search(pattern=rule, string=string) print(searchObject.groups()) # ('div', 'hello world', 'div') 具名分组 具名分组的意思是为每一个子分组取一个别名。 语法是(?P\\regexp)，对于具名分组来说，可以使用方法groupdict()来查看分组的名字和分组匹配到的内容。 如下所示，定义了3个具名分组，分别是拿到标签名字，标签内容，标签结束： import re rule = r\"\\w+)>(?P.*)\\1)>\" string = \"hello world\" searchObject = re.search(pattern=rule, string=string) print(searchObject.groupdict()) # {'tagName': 'div', 'tagContext': 'hello world', 'tagEnd': 'div'} 分组引用 没有定义子分组时，整个匹配结果就是1个分组，编号为0. 而定义了子分组后，子分组的编号从1开始，向后排列，如下图所示： 我们可以利用这个索引编号在后面引用前面分组匹配的内容作为后面的匹配规则，语法格式如下： \\编号 示例如下所示： import re rule = r\"(.*)\" string = \"hello world\" searchObject = re.search(pattern=rule, string=string) print(searchObject.groups()) # ('div', 'hello world', 'div') 分组1匹配到什么，后面的\\1的匹配规则就是什么。 如果字符串变成了这个样子就会抛出异常，匹配不到。 因为分组1匹配到的内容是div，所以\\1也只能匹配div： string = \"hello world\" 如果前面分组是1个具名分组，后面也可以通过名字进行引用，语法格式如下： (?P=分组名) 示例如下所示： import re rule = r\"\\w+)>(?P.*)(?P=tagName))>\" string = \"hello world\" searchObject = re.search(pattern=rule, string=string) print(searchObject.groupdict()) # {'tagName': 'div', 'tagContext': 'hello world', 'tagEnd': 'div'} 取消记录 每一个子分组都具有编号，如果想取消某个子分组的编号，则可以使用(?:)来进行分组，若这样做则该子分组不可被后面引用，也不可被获取到，如下示例： import re rule = r\"(.*)\" string = \"hello world\" searchObject = re.search(pattern=rule, string=string) print(searchObject.groups()) # ('hello world',) 可以看见，只有1个子分组。 断言匹配 断言匹配虽然都有1个括号，但它们并不是子分组。 故括号中的内容也不会当做结果进行保持，可以将它们理解为匹配时的条件。 (?=exp) 零宽先行断言匹配后面为exp的内容。 如下示例，匹配后面是world的内容： import re rule = r\".+(?=world)\" string = \"hello world\" searchObject = re.search(pattern=rule, string=string) print(searchObject.group(0)) # hello (? 零宽后行断言，匹配前面为exp的内容。 如下示例，匹配前面是hello的内容： import re rule = r\"(?(?!exp) 零宽负向先行断言，匹配后面不能是exp的内容。 如下示例，匹配hello后面不能是Java的内容： import re rule = r\"hello (?!Java).*\" string = \"hello Java hello Golang hello Python\" searchObject = re.search(pattern=rule, string=string) print(searchObject.group(0)) # hello Golang hello Python (? (? 如下示例，匹配hello前面不能是Golang的内容： import re rule = r\"(?re方法 findall() 将所有的匹配结果返回至1个列表中。 其实说实话这种方法在日常开发中也很少用到，由于直接返回的是1个列表，所以比较占用内存。 import re rule = r\"\\d+\" string = \"123A567\" resultList = re.findall(pattern=rule, string=string) print(resultList) # ['123', '567'] finditer() 将所有的匹配结果返回至1个迭代器中。 finditer()比findall()更节省内存，因此推荐使用。 import re rule = r\"\\d+\" string = \"123A567\" resultIter = re.finditer(pattern=rule, string=string) print(resultIter) # search() 将首次匹配的结果返回至search对象中，可通过group()进行取值。 这个方法是最常用的方法，推荐使用，但是只能返回首次的匹配结果： import re rule = r\"\\d+\" string = \"123A567\" searchObject = re.search(pattern=rule, string=string) print(searchObject) # match() 在search()基础上添加了^，使之只能在开头匹配。 这个方法用到的场景也不多吧，简单介绍一下： import re rule = r\"\\d+\" string = \"123A567\" searchObject = re.match(pattern=rule, string=string) print(searchObject) # group() 通过该方法对search对象进行取值操作，返回一个或者多个匹配的子组。 可以取值的情况： 当没有分组时默认取大组，直接使用group()方法或指定编号0 能对匿名的子组进行取值，输入子组编号即可，子组编号从1开始 能对具名的子组进行取值，输入子组别名即可 我们上面介绍过，默认最大的组就是所有匹配结果，编号为0. 子组编号从1开始向后排列，通过该方法可以取出任意一个分组。 如，没有子组，可以使用group(0)或者直接使用group()取出最大的默认组： import re rule = r\".+\" string = \"123A567\" searchObject = re.search(pattern=rule, string=string) print(searchObject.group()) # 123A567 如果有多分组，则可以指定1个或者多个子组的编号，将它们取出来： import re rule = r\"(\\d+)([A-Z])(\\d+)\" string = \"123A567\" searchObject = re.search(pattern=rule, string=string) print(searchObject.group(0, 1, 2, 3)) # ('123A567', '123', 'A', '567') 如果有具名分组，则可以指定分组名将它们取出来： import re rule = r\"(?P\\d+)(?P[A-Z])(?P\\d+)\" string = \"123A567\" searchObject = re.search(pattern=rule, string=string) print(searchObject.group(0, \"first\", \"second\", \"last\")) # ('123A567', '123', 'A', '567') groups() 通过该方法对search对象进行取值操作，返回一个元组，包含所有匹配的子组。 注意事项： 它不能返回最大组，仅能以元组的方式返回所有的子组 能返回匿名子组、具名子组 示例如下，groups()不能像group()那样指定组的编号进行取值，它直接返回的就是1个元组： import re rule = r\"(?P\\d+)(?P[A-Z])(?P\\d+)\" string = \"123A567\" searchObject = re.search(pattern=rule, string=string) print(searchObject.groups()) # ('123A567', '123', 'A', '567') groupdict() 通过该方法对search对象进行取值操作，返回一个字典，包含了所有的具名子组 注意事项： 它不能返回最大组，仅能以字典的方式返回所有的具名子组 不能返回匿名子组 示例如下： import re rule = r\"(?P\\d+)(?P[A-Z])(?P\\d+)\" string = \"123A567\" searchObject = re.search(pattern=rule, string=string) print(searchObject.groupdict()) # {'first': '123', 'second': 'A', 'last': '567'} split() 对字符串进行分割，其算法可能导致令人意外的情况发生。 函数签名如下： def split(pattern, string, maxsplit=0, flags=0): 参数释义： pattern：匹配规则 string：被切分的字符串 maxsplit：最大切分的次数 flags：匹配模式 普通的3个小示例： import re # 按空格切分 print(re.split(r\" \", \"hello abc def\")) # ['hello', 'abc', 'def'] # 按空格或 | 分 print(re.split(r\" |\\|\",\"hello abc|def\")) # ['hello', 'abc', 'def'] # 按空格或 | 分 print(re.split(r\"[ |]\",\"hello abc|def\")) # ['hello', 'abc', 'def'] 意外的情况示例： import re # 先按照a切分，后按照b切分 print(re.split(r\"[ab]\",\"asdabcd\")) # 第一次按a来分：['', 'sd', 'bcd'] # 第二次按b来分: ['', 'sd', '', 'cd'] # 按b的分法由于是空。故前进一位 # 结果 # ['', 'sd', '', 'cd'] sub() 对字符串进行替换，最少需要3个参数，返回一个新的字符串。 函数签名如下： def sub(pattern, repl, string, count=0, flags=0): 参数释义： pattern：匹配规则 repl：新的字符 string：被替换的字符串 count：替换次数 flags：匹配模式 示例如下： import re print(re.sub(r\"a|b\", \"N\", \"123a456b\")) # 123N456N subn() 对字符串进行替换，最少需要3个参数，返回一个元祖，其中包含了替换成功了几次。 函数签名如下： def subn(pattern, repl, string, count=0, flags=0): 参数释义： pattern：匹配规则 repl：新的字符 string：被替换的字符串 count：替换次数 flags：匹配模式 示例如下： import re print(re.subn(r\"a|b\", \"N\", \"123a456b\")) # ('123N456N', 2) complie() complie()可以将一个标示符赋予指定的规则，达到简化重复操作的目的。 函数签名如下： def compile(pattern, flags=0): 参数释义： pattern：匹配规则 flags：匹配模式 示例演示，我有一个HTML文档。现在，我要匹配每个a标签的链接、a标签的内容： import re #　step01：指定匹配规则 rule = re.compile(r\"(.*)\", flags=re.I) # step02: 书写HTML文档 htmlDocument = \"\"\" 百度搜索 谷歌搜索 必应搜索 \"\"\" # step03:开始匹配 resultList = rule.findall(htmlDocument) print(resultList) # [('www.baidu.com', '百度搜索'), ('www.google.com', '谷歌搜索'), ('www.biying.com', '必应搜索')] re模式 re.I I模式下不区分大小写，此模式下[a-z]等同于[a-zA-Z]： import re rule = \"[a-z]+\" string = \"ABC1abc\" resultList = re.findall(pattern=rule, string=string, flags=re.I) print(resultList) # ['ABC', 'abc'] re.M M模式下会将每一行单独匹配，主要是对^和$的修饰。 如下示例，匹配必须以j开头且为p结尾的子串： import re rule = \"^J.+t$\" string = \"Python\\nJavaScript\\nGolang\" resultList = re.findall(pattern=rule, string=string, flags=re.M) print(resultList) # ['JavaScript'] re.S S模式下会将多行视为单行，这意味着.通配符可以匹配\\n了。 import re rule = \".+\" string = \"\\n\\n\\n\\n\\n\" resultList = re.findall(pattern=rule, string=string, flags=re.S) print(resultList) # ['\\n\\n\\n\\n\\n'] re.U U模式使用的不多，主要针对占4个Bytes的字符进行匹配支持，尽在Python2中适用，因为Python3里的字符都是Unicode字符了。 import re rule = \"𝒳𝒴\" string = \"𝒳𝒴𝒳𝒴𝒳𝒴\" resultList = re.findall(pattern=rule, string=string, flags=re.U) print(resultList) # ['𝒳𝒴', '𝒳𝒴', '𝒳𝒴'] 通用正则表达式大全 原文转载至：Java后端 原文地址：点我跳转 数字校验 数字：^[0-9]*$ n位的数字：^\\d{n}$ 至少n位的数字：^\\d{n,}$ m-n位的数字：^\\d{m,n}$ 零和非零开头的数字：^(0|[1-9][0-9]*)$ 非零开头的最多带两位小数的数字：^([1-9][0-9]*)+(.[0-9]{1,2})?$ 带1-2位小数的正数或负数：^(\\-)?\\d+(\\.\\d{1,2})?$ 正数、负数、和小数：^(\\-|\\+)?\\d+(\\.\\d+)?$ 有两位小数的正实数：^[0-9]+(.[0-9]{2})?$ 有1~3位小数的正实数：^[0-9]+(.[0-9]{1,3})?$ 非零的正整数：^[1-9]\\d*$ 或 ^([1-9][0-9]*){1,3}$ 或 ^\\+?[1-9][0-9]*$ 非零的负整数：^\\-[1-9][]0-9\"*$ 或 ^-[1-9]\\d*$ 非负整数：^\\d+$ 或 ^[1-9]\\d*|0$ 非正整数：^-[1-9]\\d*|0$ 或 ^((-\\d+)|(0+))$ 非负浮点数：^\\d+(\\.\\d+)?$ 或 ^[1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*|0?\\.0+|0$ 非正浮点数：^((-\\d+(\\.\\d+)?)|(0+(\\.0+)?))$ 或 ^(-([1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*))|0?\\.0+|0$ 正浮点数：^[1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*$ 或 ^(([0-9]+\\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\\.[0-9]+)|([0-9]*[1-9][0-9]*))$ 负浮点数：^-([1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*)$ 或 ^(-(([0-9]+\\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\\.[0-9]+)|([0-9]*[1-9][0-9]*)))$ 浮点数：^(-?\\d+)(\\.\\d+)?$ 或 ^-?([1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*|0?\\.0+|0)$ 字符校验 汉字：^[\\u4e00-\\u9fa5]{0,}$ 英文和数字：^[A-Za-z0-9]+$ 或 ^[A-Za-z0-9]{4,40}$ 长度为3-20的所有字符：^.{3,20}$ 由26个英文字母组成的字符串：^[A-Za-z]+$ 由26个大写英文字母组成的字符串：^[A-Z]+$ 由26个小写英文字母组成的字符串：^[a-z]+$ 由数字和26个英文字母组成的字符串：^[A-Za-z0-9]+$ 由数字、26个英文字母或者下划线组成的字符串：^\\w+$ 或 ^\\w{3,20} 中文、英文、数字包括下划线：^[\\u4E00-\\u9FA5A-Za-z0-9_]+$ 中文、英文、数字但不包括下划线等符号：^[\\u4E00-\\u9FA5A-Za-z0-9]+$ 或 ^[\\u4E00-\\u9FA5A-Za-z0-9]{2,20}$ 可以输入含有^%&',;=?$\\\"等字符：[^%&',;=?$\\x22]+ 禁止输入含有~的字符[^~\\x22]+ 其他校验 .*匹配除 \\n 以外的任何字符。 /[\\u4E00-\\u9FA5]/ 汉字 /[\\uFF00-\\uFFFF]/ 全角符号 /[\\u0000-\\u00FF]/ 半角符号 钱币校验 1.有四种钱的表示形式我们可以接受:\"10000.00\" 和 \"10,000.00\", 和没有 \"分\" 的 \"10000\" 和 \"10,000\"：^[1-9][0-9]*$ 2.这表示任意一个不以0开头的数字,但是,这也意味着一个字符\"0\"不通过,所以我们采用下面的形式：^(0|[1-9][0-9]*)$ 3.一个0或者一个不以0开头的数字.我们还可以允许开头有一个负号：^(0|-?[1-9][0-9]*)$ 4.这表示一个0或者一个可能为负的开头不为0的数字.让用户以0开头好了.把负号的也去掉,因为钱总不能是负的吧.下面我们要加的是说明可能的小数部分：^[0-9]+(.[0-9]+)?$ 5.必须说明的是,小数点后面至少应该有1位数,所以\"10.\"是不通过的,但是 \"10\" 和 \"10.2\" 是通过的：^[0-9]+(.[0-9]{2})?$ 6.这样我们规定小数点后面必须有两位,如果你认为太苛刻了,可以这样：^[0-9]+(.[0-9]{1,2})?$ 7.这样就允许用户只写一位小数.下面我们该考虑数字中的逗号了,我们可以这样：^[0-9]{1,3}(,[0-9]{3})*(.[0-9]{1,2})?$ 8.1到3个数字,后面跟着任意个 逗号+3个数字,逗号成为可选,而不是必须：^([0-9]+|[0-9]{1,3}(,[0-9]{3})*)(.[0-9]{1,2})?$ 生活需求 Email地址：^\\w+([-+.]\\w+)*@\\w+([-.]\\w+)*\\.\\w+([-.]\\w+)*$ 域名：[a-zA-Z0-9][-a-zA-Z0-9]{0,62}(/.[a-zA-Z0-9][-a-zA-Z0-9]{0,62})+/.? InternetURL：[a-zA-z]+://[^\\s]* 或 ^http://([\\w-]+\\.)+[\\w-]+(/[\\w-./?%&=]*)?$ 手机号码：^(13[0-9]|14[5|7]|15[0|1|2|3|5|6|7|8|9]|18[0|1|2|3|5|6|7|8|9])\\d{8}$ 电话号码(\"XXX-XXXXXXX\"、\"XXXX-XXXXXXXX\"、\"XXX-XXXXXXX\"、\"XXX-XXXXXXXX\"、\"XXXXXXX\"和\"XXXXXXXX)：^(\\(\\d{3,4}-)|\\d{3.4}-)?\\d{7,8}$ 国内电话号码(0511-4405222、021-87888822)：\\d{3}-\\d{8}|\\d{4}-\\d{7} 身份证号(15位、18位数字)：^\\d{15}|\\d{18}$ 短身份证号码(数字、字母x结尾)：^([0-9]){7,18}(x|X)?$ 或 ^\\d{8,18}|[0-9x]{8,18}|[0-9X]{8,18}?$ 帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：^[a-zA-Z][a-zA-Z0-9_]{4,15}$ 密码(以字母开头，长度在6~18之间，只能包含字母、数字和下划线)：^[a-zA-Z]\\w{5,17}$ 强密码(必须包含大小写字母和数字的组合，不能使用特殊字符，长度在8-10之间)：^(?=.*\\d)(?=.*[a-z])(?=.*[A-Z]).{8,10}$ 日期格式：^\\d{4}-\\d{1,2}-\\d{1,2} 一年的12个月(01～09和1～12)：^(0?[1-9]|1[0-2])$ 一个月的31天(01～09和1～31)：^((0?[1-9])|((1|2)[0-9])|30|31)$ xml文件：^([a-zA-Z]+-?)+[a-zA-Z0-9]+\\\\.[x|X][m|M][l|L]$ 中文字符的正则表达式：[\\u4e00-\\u9fa5] 双字节字符：[^\\x00-\\xff] (包括汉字在内，可以用来计算字符串的长度(一个双字节字符长度计2，ASCII字符计1)) 空白行的正则表达式：\\n\\s*\\r (可以用来删除空白行) HTML标记的正则表达式：]*>.*?| (网上流传的版本太糟糕，上面这个也仅仅能部分，对于复杂的嵌套标记依旧无能为力) 首尾空白字符的正则表达式：^\\s*|\\s*$或(^\\s*)|(\\s*$) (可以用来删除行首行尾的空白字符(包括空格、制表符、换页符等等)，非常有用的表达式) 腾讯QQ号：[1-9][0-9]{4,} (腾讯QQ号从10000开始) 中国邮政编码：[1-9]\\d{5}(?!\\d) (中国邮政编码为6位数字) IP地址：\\d+\\.\\d+\\.\\d+\\.\\d+ (提取IP地址时有用) IP地址：((?:(?:25[0-5]|2[0-4]\\\\d|[01]?\\\\d?\\\\d)\\\\.){3}(?:25[0-5]|2[0-4]\\\\d|[01]?\\\\d?\\\\d)) IP-v4地址：\\\\b(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\\\b (提取IP地址时有用) 校验IP-v6地址:(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])) 子网掩码：((?:(?:25[0-5]|2[0-4]\\\\d|[01]?\\\\d?\\\\d)\\\\.){3}(?:25[0-5]|2[0-4]\\\\d|[01]?\\\\d?\\\\d)) 校验日期:^(?:(?!0000)[0-9]{4}-(?:(?:0[1-9]|1[0-2])-(?:0[1-9]|1[0-9]|2[0-8])|(?:0[13-9]|1[0-2])-(?:29|30)|(?:0[13578]|1[02])-31)|(?:[0-9]{2}(?:0[48]|[2468][048]|[13579][26])|(?:0[48]|[2468][048]|[13579][26])00)-02-29)$(“yyyy-mm-dd“ 格式的日期校验，已考虑平闰年。) 抽取注释： 查找CSS属性:^\\\\s*[a-zA-Z\\\\-]+\\\\s*[:]{1}\\\\s[a-zA-Z0-9\\\\s.#]+[;]{1} 提取页面超链接:(]*)(href=\"https?:\\\\/\\\\/)((?!(?:(?:www\\\\.)?'.implode('|(?:www\\\\.)?', $follow_list).'))[^\" rel=\"external nofollow\" ]+)\"((?!.*\\\\brel=)[^>]*)(?:[^>]*)> 提取网页图片:\\\\]*[src] *= *[\\\\\"\\\\']{0,1}([^\\\\\"\\\\'\\\\ >]*) 提取网页颜色代码:^#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$ 文件扩展名效验:^([a-zA-Z]\\\\:|\\\\\\\\)\\\\\\\\([^\\\\\\\\]+\\\\\\\\)*[^\\\\/:*?\"<>|]+\\\\.txt(l)?$ 判断IE版本：^.*MSIE [5-8](?:\\\\.[0-9]+)?(?!.*Trident\\\\/[5-9]\\\\.0).*$ Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-10 21:36:42 "},"Python/Python模块与包/importlib.html":{"url":"Python/Python模块与包/importlib.html","title":"内置模块：importlib","keywords":"","body":"importlib简介 importlib模块作为Python内置模块，提供了更多导入模块的方式。 官方文档 常用方法： importlib.import_module(str)：根据字符串导入1个模块，该字符串以.为路径分割，如\"package.module\" 项目示例 假设我的项目之中包含了多个中间件，并且这些中间件会在项目正式启动之前先行启动。 我该如何集中式的管理这些中间件，让它们在需要的时候能够快速加上，不需要的时候能够快速去除呢？ 使用importlib模块是最明智的选择，整个项目目录如下： PYTHONPROJECT │ ├─bin │ | run.py │ ├─middleware │ │ first_middle.py │ │ init.py │ │ second_middle.py │ │ __init__.py │ ├─view │ │ main.py │ │ settings.py 首先先查看一下run.py，它主要处理项目模块路径、中间件初始化以及主程序的运行： #　run.py import os import sys BASE_DIR = os.path.dirname(os.path.dirname(__file__)) sys.path.append(BASE_DIR) from middleware.init import init from view.main import main if __name__ == \"__main__\": # init middleware init() # run main main() 再来看一下中间件的启动，它会从配置文件中拿到被集中化管理的需要启动的中间件，然后利用importlib模块对其进行导入后执行其下的某一个方法： # middleware/init.py import importlib import settings def init(): for stringPath in settings.LOAD_MIDDLEWARE: modulePath, funcName = stringPath.rsplit(\".\", maxsplit=1) # 利用importlib模块根据字符串路径导入模块 module = importlib.import_module(modulePath) # 模块也是对象，所以利用反射拿到函数对象并执行 funcObject = getattr(module, funcName) funcObject() 被集中管理的需要加载的中间件被定义在了settings.py的1个列表中。 其中每条数据项代表1个需要被加载的中间件，以BASE_DIR为准，用.进行分割，确定了中间件的导入路径与运行函数： # settings.py LOAD_MIDDLEWARE = [ \"middleware.first_middle.m1\", \"middleware.second_middle.m2\" ] 当后续需要新增中间件，只需要在middleware包中添加好.py文件并且在settings.py中按照格式把路径和运行函数填入即可。 如果要取消某个中间件的加载，直接在列表中对它进行注释即可。 总结2点： 如何规定模块导入的格式，参见LOAD_MIDDLEWARE列表 如何使用importlib快速导入模块且执行模块下的某一个函数，参见init.py文件 把其他代码也补上吧，中间件的启动函数： # middleware/first_middle.py def m1(): print(\"middleware 1 run..\") # middleware/second_middle.py def m2(): print(\"middleware 2 run..\") 主程序函数： # view/main.py def main(): print(\"view main run...\") 运行结果： middleware 1 run.. middleware 2 run.. view main run... Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-10 20:34:29 "},"Python/Python模块与包/collections.html":{"url":"Python/Python模块与包/collections.html","title":"内置模块：collections","keywords":"","body":"collections简介 collections模块提供了许多容器的数据类型，是Python内置数据类型的一种升级。 官方文档 collections模块所提供的内置容器或者基类如下所示： 容器/基类 描述 namedtuple() 创建命名元组子类的工厂函数 deque 类似列表(list)的容器，实现了在两端快速添加(append)和弹出(pop) ChainMap 类似字典(dict)的容器类，将多个映射集合到一个视图里面 Counter 字典的子类，提供了可哈希对象的计数功能 OrderedDict 字典的子类，保存了他们被添加的顺序 defaultdict 字典的子类，提供了一个工厂函数，为字典查询提供一个默认值 UserDict 封装了字典对象，简化了字典子类化 UserList 封装了列表对象，简化了列表子类化 UserString 封装了列表对象，简化了字符串子类化 ChainMap ChainMap能够让多个字典链接起来，返回类似于字典视图的功能，可以直接将多个互相分离的字典当做1个大的整体字典来用，ChainMap支持所有字典方法，如get()，pop()等。 可能有的朋友会想，那为什么不新创建1个字典然后update()旧的字典呢？ 这是因为ChainMap和字典视图很相似，所以oldDict的数据如果发生更新，则ChainMap也会同步进行更新。 但使用dict.update()创建的newDict就没有这种特性了，它不会随着oldDict的数据改变而发生改变。 如下图所示： 快速使用 如下示例，将链接2个字典，组成英文字母大小写对照ASCII码表： from collections import ChainMap uppercaseAlphabet = {chr(i): i for i in range(65, 91)} lowercaseAlphabet = {chr(i): i for i in range(97, 123)} letterTable = ChainMap(uppercaseAlphabet, lowercaseAlphabet) print(letterTable) 生成的对象如下所示： ChainMap({'A': 65, 'B': 66, 'C': 67, 'D': 68, 'E': 69, 'F': 70, 'G': 71, 'H': 72, 'I': 73, 'J': 74, 'K': 75, 'L': 76, 'M': 77, 'N': 78, 'O': 79, 'P': 80, 'Q': 81, 'R': 82, 'S': 83, 'T': 84, 'U': 85, 'V': 86, 'W': 87, 'X': 88, 'Y': 89, 'Z': 90}, {'a': 97, 'b': 98, 'c': 99, 'd': 100, 'e': 101, 'f': 102, 'g': 103, 'h': 104, 'i': 105, 'j': 106, 'k': 107, 'l': 108, 'm': 109, 'n': 110, 'o': 111, 'p': 112, 'q': 113, 'r': 114, 's': 115, 't': 116, 'u': 117, 'v': 118, 'w': 119, 'x': 120, 'y': 121, 'z': 122}) maps ChainMap的底层其实是用了1个列表，来存放了oldDict的引用。 格式如下： [ {oldDict1..}, {oldDict2..}, ... ] 在查询时，如果oldDict1和oldDict2具有重复的key，则会查出oldDict1，因为它是挨个字典的向后进行查找，其他的操作也是同理： 如下示例，oldDict1和oldDict2都有为a的key，那么操纵ChainMap的a时必定先拿到oldDict1的a： from collections import ChainMap oldDict1 = {\"a\": 1, \"b\": 2, \"c\": 3} oldDict2 = {\"a\": 10, \"b\": 20, \"c\": 30} newMap = ChainMap(oldDict1, oldDict2) print(newMap.get(\"a\")) # 1 如果直接想操作oldDict2的a，则可以通过ChainMap.maps拿到存储字典映射的列表，指定索引值来操作第2个字典也就是oldDict2，示例如下： from collections import ChainMap oldDict1 = {\"a\": 1, \"b\": 2, \"c\": 3} oldDict2 = {\"a\": 10, \"b\": 20, \"c\": 30} newMap = ChainMap(oldDict1, oldDict2) print(newMap.maps[1].get(\"a\")) # 10 new_child(m=None) 该方法会在旧的ChainMap上生成1个新的ChainMap，并且新增1个空字典在最前面。 如下图所示： 代码示例： from collections import ChainMap oldDict1 = {\"a\": 1, \"b\": 2, \"c\": 3} oldDict2 = {\"a\": 10, \"b\": 20, \"c\": 30} oldMap = ChainMap(oldDict1, oldDict2) newMap = oldMap.new_child() print(newMap) # ChainMap({}, {'a': 1, 'b': 2, 'c': 3}, {'a': 10, 'b': 20, 'c': 30}) 你也可以选择，在使用该方法的时候传入1个新的字典，让它填补第1个位置： ... newMap = oldMap.new_child({\"new\": None}) print(newMap) # ChainMap({'new': None}, {'a': 1, 'b': 2, 'c': 3}, {'a': 10, 'b': 20, 'c': 30}) parents 返回ChainMap的父ChainMap，相较于子ChainMap来说，父ChainMap永远没有子ChainMap的第1个oldDict。 如下图所示： 示例如下： from collections import ChainMap oldDict1 = {\"a\": 1, \"b\": 2, \"c\": 3} oldDict2 = {\"a\": 10, \"b\": 20, \"c\": 30} oldMap = ChainMap(oldDict1, oldDict2) print(oldMap.parents) # ChainMap({'a': 10, 'b': 20, 'c': 30}) 使用场景 在官方文档中举例了一个非常好的使用场景。 有1个简单的脚本，它拥有一些默认的参数变量。 当启动该脚本时，会有以下3种情况发生： 如果在命令行启动脚本时，指定了参数，则使用命令行指定的参数 如果没有在命令行启动脚本时指定参数，则会查找os的环境变量试图获取该参数 如果os的环境变量中也没有该参数，则使用默认的参数 这里它就是用了ChainMap来实现的，具体代码如下，避免了大量的if和else，非常方便： import os import argparse from collections import ChainMap defaults = {'color': 'red', 'user': 'guest'} parser = argparse.ArgumentParser() parser.add_argument('-u', '--user') parser.add_argument('-c', '--color') namespace = parser.parse_args() command_line_args = {k: v for k, v in vars(namespace).items() if v} combined = ChainMap(command_line_args, os.environ, defaults) print(combined['color']) print(combined['user']) 测试1，命令行传入了参数： python3 demo.py -c Black -u Yunya Black Yunya 测试2，命令行和os的环境变量中都没有参数，则用默认的参数： python3 demo.py red guest Counter Counter能够快速的获取一个可迭代对象中每一个数据项所出现的次数。 因此可以用来做词频统计，排行榜等一类的工具。 Counter是Dict的派生类，故支持大部分的字典方法，如get()，pop()等。 序列记数 直接为Counter()传入1个可迭代对象，返回一个dict，包含数据项和出现次数，按照降序排列，如下所示： from collections import Counter seq = [\"A\", \"A\", \"B\", \"C\", \"C\", \"D\"] c = Counter(seq) print(c) # Counter({'A': 2, 'C': 2, 'B': 1, 'D': 1}) 计数获取 如果你想获取1个数据项的出现次数，可通过[]的操作或者get()方法来完成，像操纵字典一样操纵Counter即可。 值得一提的是，当Counter通过[item]来获取数据项出现次数的话，如果这个数据项不存在则会返回0，而不是抛出KeyError。 from collections import Counter seq = [\"A\", \"A\", \"B\", \"C\", \"C\", \"D\"] c = Counter(seq) print(c.get(\"A\")) print(c.get(\"Z\")) print(c[\"Z\"]) # 2 # None # 0 排行获取 Counter.most_common()会返回1一个列表，按照Counter的排列顺序从大到小进行返回，如下所示，返回出现次数最多的3个数据项： from collections import Counter seq = [\"A\", \"A\", \"B\", \"C\", \"C\", \"D\"] c = Counter(seq) print(sorted(c.most_common(3))) # [('A', 2), ('C', 2), ('B', 1)] 如果想返回出现次数最少的3个数据项该怎么办呢？ 如下所示： from collections import Counter seq = [\"A\", \"A\", \"B\", \"C\", \"C\", \"D\"] c = Counter(seq) print(sorted(c.items(), key=lambda li:li[1])[:3]) # [('B', 1), ('D', 1), ('A', 2)] 词频统计 打开一个文件，做词频统计： from collections import Counter result = Counter() with open(\"./data/input.txt\",\"r\") as f: while True: lines = f.read(1024).splitlines() if lines==[]: break lines = [lines[i].split(\" \") for i in range(len(lines))] words = [] for line in lines: words.extend(line) tmp = Counter(words) result+=tmp print (result.most_common(10)) deque deque是collections模块提供的一大杀器，名为双端队列。 虽然普通的list也能够在队列2端进行数据项操作，但诸如insert(0, item)， pop(0)等方法都会引起数据项在内存中的挪动，从而使这2个方法的时间复杂度降低到O(n)。 而deque针对insert(0, item)和pop(0)做出了优化，让它们的时间复杂度都降到了O(1)。 如果仅在队首、队尾做操作，那么使用双端队列是最合适的。 如果要在队列中部做操作，还是推荐使用list。 方法一览 下面是deque所提供的方法和属性： 方法/属性 描述 deque(iterable, maxlen) 返回新的双端队列，可指定该队列的最大容量，如果不指定最大容量，则内部会根据数据项个数进行自动扩容 append(item) 添加数据项至队尾 appendleft(item) 添加数据项至队首 clear() 清空队列中的数据项 copy() 创建一份浅拷贝 count(item) 返回item在队列中出现的次数 extend(iterable) 通过附加来自可迭代对象的数据项来扩展队列，数据项添加至队尾 extendleft(iterable) 通过附加来自可迭代对象的数据项来扩展队列，数据项添加至队首 index(item, start, stop) 返回第一个数据项在队列中出现位置的索引，若值不存在，则抛出ValueError，可指定start和stop的索引区间 insert(index, item) 在索引之前插入数据项 pop() 删除并弹出队尾的数据项，若队列为空则抛出IndexError popleft() 删除并弹出队首的数据项，若队列为空则抛出IndexError remove(item) 删除队列中第一次出现的数据项。如果不存在该数据项，则引发ValueError reverse() 翻转整个队列，返回None，即原地翻转 rotate(n=1) 如果为正数，将队尾n个数据项移动至队首，如果是负数，将队首n个数据项移至队尾 maxlen 返回队列的最大容量 除了以上方法和属性之外，deque还支持迭代，枚举，len(d), reversed(d), copy.copy(d), copy.deepcopy(d), 成员测试 in 操作符，和下标引用 d[-1]，但是不支持切片[::] 。 注意！len()和maxlen是不同的： len()取的是队列中以有多少个数据项 maxlen取的是队列中最多可容纳多少数据项 如下所示： from collections import deque q = deque(range(3), maxlen=10) print(q.maxlen) print(len(q)) # 10 # 3 此外，rotate()方法可以在队列中进行数据项的位置迁移，如下所示。 n为正数，将队尾n个数据项移动至队首： from collections import deque q = deque(range(5), maxlen=10) print(q) q.rotate(2) print(q) # deque([0, 1, 2, 3, 4], maxlen=10) # deque([3, 4, 0, 1, 2], maxlen=10) n为负数，将队首n个数据项移至队尾： from collections import deque q = deque(range(5), maxlen=10) print(q) q.rotate(-2) print(q) # deque([0, 1, 2, 3, 4], maxlen=10) # deque([2, 3, 4, 0, 1], maxlen=10) defaultdict defaultdict本身是一个字典，继承了dict类并覆写了__missing__()方法。 在实例化defaultdict对象时我们可以为字典设置1个默认值，当使用[key]获取value时，若[key]不存在将会返回默认值而不是直接抛出keyError。 快速使用 如下所示，在使用了defaultdict后，用[key]操作获取value时若key不存在则会返回设定的默认值： from collections import defaultdict dic = defaultdict(lambda : None) #　❶ dic[\"k1\"] = \"v1\" print(dic[\"k1\"]) print(dic[\"k2\"]) # v1 # None ❶：设定默认值，必须是1个可调用对象，将其返回值作为defaultdict的默认值 计数统计 统计数据项在列表中出现的次数，如果是普通的dict你可能需要这么做： li1 = [\"A\", \"A\", \"B\", \"C\", \"C\", \"D\"] dic = {} for item in li1: dic.setdefault(item, 0) dic[item] += 1 print(dic) # {'A': 2, 'B': 1, 'C': 2, 'D': 1} 如果是defaultdict，则可以让代码更精简一点： from collections import defaultdict li1 = [\"A\", \"A\", \"B\", \"C\", \"C\", \"D\"] dic = defaultdict(lambda: 0) for item in li1: dic[item] += 1 print(dic) # defaultdict( at 0x0127B6A8>, {'A': 2, 'B': 1, 'C': 2, 'D': 1}) namedtuple namedtuple翻译过来就是具名元组，因为元组的主要功能是数据的展示，如果能够将1个元组中每个数据项的意思也表达出来就更好了。 如下所示，一个普通的元组： (\"Jack\", 18, \"male\", \"123456\") 乍一看前3个你可能都能看懂是什么意思，那么最后1个呢？是不是一脸懵逼？ 而通过具名元组，你就能知道最后1个的意思了，如下所示： (name='Jack', age=18, gender='male', password='123456') 可能这里有的同学会说，那我为什么不用dict？而偏要这么麻烦的用collections中的namedtuple？ 别搞忘了，dict是可变类型，namedtuple则是继承了tuple的特性，是不可变的，数据仅作展示时使用具名元组是最好的选择。 此外，具名元组是元组的子类，所以可以使用所有元组的方法，除此之外它还新增了一些方法和属性。 对象创建 使用namedtuple()方法来初始化一个类。 函数签名如下： def namedtuple(typename, field_names, *, verbose=False, rename=False, module=None): pass 参数释义： typename：将要实例化出的类的名称 field_names：具名元组中每个字段的名称 ... 示例演示： from collections import namedtuple UserMessage = namedtuple(\"userMessage\", [\"name\", \"age\" ,\"gender\", \"password\"]) u = UserMessage(\"Jack\", 18, \"male\", \"123456\") print(u) # userMessage(name='Jack', age=18, gender='male', password='123456') _make() 若1个序列的数据项个数与具名元组类的字段个数相同，通过该方法可直接将这个序列传入并生成新的具名元组对象。 如下所示，u的数据项个数与具名元组类的字段个数相同，直接根据u创建1个具名元组对象： from collections import namedtuple UserMessage = namedtuple(\"userMessage\", [\"name\", \"age\" ,\"gender\", \"password\"]) u = (\"Jack\", 18, \"male\", \"123456\") print(UserMessage._make(u)) # userMessage(name='Jack', age=18, gender='male', password='123456') _asdict() 将具名元组对象转换为有序字典（注：不是dict，而是Orderdict）： from collections import namedtuple UserMessage = namedtuple(\"userMessage\", [\"name\", \"age\" ,\"gender\", \"password\"]) u = UserMessage(\"Jack\", 18, \"male\", \"123456\") print(u._asdict()) # OrderedDict([('name', 'Jack'), ('age', 18), ('gender', 'male'), ('password', '123456')]) _replace() 由于具名元组不可改变，所以通过该方法会生成1个新的具名元组，用于替换旧的具名元组中的某一个数据项值： from collections import namedtuple UserMessage = namedtuple(\"userMessage\", [\"name\", \"age\" ,\"gender\", \"password\"]) oldUser = UserMessage(\"Jack\", 18, \"male\", \"123456\") newUser = oldUser._replace(name=\"Tom\", password=\"abcdef\") print(newUser) # userMessage(name='Tom', age=18, gender='male', password='abcdef') _fields 返回具名元组的字段列表： from collections import namedtuple UserMessage = namedtuple(\"userMessage\", [\"name\", \"age\" ,\"gender\", \"password\"]) u = UserMessage(\"Jack\", 18, \"male\", \"123456\") print(u._fields) # ('name', 'age', 'gender', 'password') 字典转换 若想将具名元组转换为普通字典，可通过如下方法： from collections import namedtuple UserMessage = namedtuple(\"userMessage\", [\"name\", \"age\" ,\"gender\", \"password\"]) u = UserMessage(\"Jack\", 18, \"male\", \"123456\") print( dict(zip(u._fields, u[:])) ) # {'name': 'Jack', 'age': 18, 'gender': 'male', 'password': '123456'} 若想将普通字典转换为具名元组，可通过如下方法： from collections import namedtuple userDict = {'name': 'Jack', 'age': 18, 'gender': 'male', 'password': '123456'} UserMessage = namedtuple(\"userMessage\", [\"name\", \"age\" ,\"gender\", \"password\"]) print(UserMessage(**userDict)) # userMessage(name='Jack', age=18, gender='male', password='123456') OrderDict OrderDict见字生意，即有序字典。 但是Python3.6之后字典已经变的有序了，所以这里不再举例它的用法。 感兴趣可以参照collections的官方文档进行查阅。 继承基类 collections中提供了3个基类，分别是UserList，UserDict，UserString。 它们并没有什么实质性的功能，只是针对list、dict、string的C语言实现用Python重写了一遍。 如果你对这些数据类型的实现比较感兴趣，可翻阅一下它们的源码。 此外，如果在自定义序列时，也建议继承这3个类，而不是继承内置的3个类。 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-10 20:53:11 "},"Python/Python模块与包/itertools.html":{"url":"Python/Python模块与包/itertools.html","title":"内置模块：itertools","keywords":"","body":"itertools简介 itertools是Python内置模块，提供了大量为高效循环而创建的迭代器函数，当你有以下一些特殊需求时就可以使用它们，而不必再自己动手造轮子。 官方文档 由于提供的迭代器众多，故不可能每个都记得，这里放上摘自官网的迭代器一览表。 首先是无穷迭代器如下表所示，即能够无限被迭代的迭代器： 迭代器 实参 结果 示例 count() start, [step] start, start+step, start+2*step, … count(10) --> 10 11 12 13 14 ... cycle() p p0, p1, … plast, p0, p1, … cycle('ABCD') --> A B C D A B C D ... repeat() elem [,n] elem, elem, elem, … 重复无限次或n次 repeat(10, 3) --> 10 10 10 其次是可停止的迭代器： 迭代器 实参 结果 示例 accumulate() p [,func] p0, p0+p1, p0+p1+p2, … accumulate([1,2,3,4,5]) --> 1 3 6 10 15 chain() p, q, … p0, p1, … plast, q0, q1, … chain('ABC', 'DEF') --> A B C D E F chain.from_iterable() iterable – 可迭代对象 p0, p1, … plast, q0, q1, … chain.from_iterable(['ABC', 'DEF']) --> A B C D E F compress() data, selectors (d[0] if s[0]), (d[1] if s[1]), … compress('ABCDEF', [1,0,1,0,1,1]) --> A C E F dropwhile() pred, seq seq[n], seq[n+1], … 从pred首次真值测试失败开始 dropwhile(lambda x: x 6 4 1 filterfalse() pred, seq seq中pred(x)为假值的元素，x是seq中的元素。 filterfalse(lambda x: x%2, range(10)) --> 0 2 4 6 8 groupby() iterable[, key] 根据key(v)值分组的迭代器 islice() seq, [start,] stop [, step] seq[start:stop:step]中的元素 islice('ABCDEFG', 2, None) --> C D E F G starmap() func, seq func(seq[0]), func(seq[1]), … starmap(pow, [(2,5), (3,2), (10,3)]) --> 32 9 1000 takewhile() pred, seq seq[0], seq[1], …, 直到pred真值测试失败 takewhile(lambda x: x 1 4 tee() it, n it1, it2, … itn 将一个迭代器拆分为n个迭代器 zip_longest() p, q, … (p[0], q[0]), (p[1], q[1]), … zip_longest('ABCD', 'xy', fillvalue='-') --> Ax By C- D- 然后是排列组合迭代器： 迭代器 实参 结果 product() p, q, … [repeat=1] 笛卡尔积，相当于嵌套的for循环 permutations() p[, r] 长度r元组，所有可能的排列，无重复元素 combinations() p, r 长度r元组，有序，无重复元素 combinations_with_replacement() p, r 长度r元组，有序，元素可重复 product('ABCD', repeat=2) AA AB AC AD BA BB BC BD CA CB CC CD DA DB DC DD permutations('ABCD', 2) AB AC AD BA BC BD CA CB CD DA DB DC combinations('ABCD', 2) AB AC AD BC BD CD combinations_with_replacement('ABCD', 2) AA AB AC AD BB BC BD CC CD DD 自认为比较重要的方法有：chain()，zip_longset()，permutations()。 除此之外的方法局限性太强，不适合所有场景。 无穷迭代器 count() 创建1个迭代器，初始值是start，步长是step，结束是无限。 函数签名如下： itertools.count(start=0, step=1) 官方文档的实现： def count(start=0, step=1): # count(10) --> 10 11 12 13 14 ... # count(2.5, 0.5) -> 2.5 3.0 3.5 ... n = start while True: yield n n += step 注意，可以生成浮点数，这是range所不支持的。 cycle() 创建1个迭代器，对传入的可迭代对象元素进行无限复制。 函数签名如下： itertools.cycle(iterable) 官方文档的实现： def cycle(iterable): # cycle('ABCD') --> A B C D A B C D A B C D ... saved = [] for element in iterable: yield element saved.append(element) while saved: for element in saved: yield element repeat() 创建1个迭代器，对传入的可迭代对象进行无限复制，或通过times参数指定复制的次数： 函数签名如下： itertools.repeat(object[, times]) 官方文档的实现： def repeat(object, times=None): # repeat(10, 3) --> 10 10 10 if times is None: while True: yield object else: for i in range(times): yield object 可停止的迭代器 accumulate() 该函数可接收2个参数，1个可迭代对象和1个具有2参数的可调用对象，返回1个迭代器。 该迭代器的值生成基于可调用对象对传入数据项的处理。 函数签名如下： itertools.accumulate(iterable[, func]) 官方文档实现： def accumulate(iterable, func=operator.add): 'Return running totals' # accumulate([1,2,3,4,5]) --> 1 3 6 10 15 # accumulate([1,2,3,4,5], operator.mul) --> 1 2 6 24 120 it = iter(iterable) try: total = next(it) except StopIteration: return yield total for element in it: total = func(total, element) yield total 示例演示： import itertools print(list(itertools.accumulate(range(5), lambda x,y:x+y))) # [0, 1, 3, 6, 10] 过程解析： # range(5) lambda x,y : x+y # [0, 1, 2, 3, 4] # 第一次：返回0 -> [0] # 第二次：0 + 1 = 1 -> [0, 1] # 第三次：1 + 2 = 3 -> [0, 1, 3] # 第四次：3 + 3 = 6 -> [0, 1, 3, 6] # 第五次：4 + 6 = 10 -> [0, 1, 3, 6, 10] # 结果： # [0, 1, 3, 6, 10] chain() 该函数可接收无限多的可迭代对象，并将它们进行合并成1个迭代器进行返回。 函数签名如下： itertools.chain(*iterables) 官方文档实现： def chain(*iterables): # chain('ABC', 'DEF') --> A B C D E F for it in iterables: for element in it: yield element from_iterable() 该函数可接收一个多维度的可迭代对象，并将多维展开合并成1个平面迭代器进行返回。 函数签名如下： itertools.chain.from_iterable(iterable) 官方文档实现： def from_iterable(iterables): # chain.from_iterable(['ABC', 'DEF']) --> A B C D E F for it in iterables: for element in it: yield element compress 创建一个迭代器，它返回data中经selectors真值测试为True的元素。迭代器在两者较短的长度处停止。 函数签名如下： itertools.compress(data, selectors) 官方文档实现： def compress(data, selectors): # compress('ABCDEF', [1,0,1,0,1,1]) --> A C E F return (d for d, s in zip(data, selectors) if s) dropwhile() 创建一个迭代器，如果predicate为true，迭代器丢弃这些元素，然后返回其他元素。 注意，迭代器在predicate首次为false之前不会产生任何输出，所以可能需要一定长度的启动时间。 函数签名如下： itertools.dropwhile(predicate, iterable) 官方文档实现： def dropwhile(predicate, iterable): # dropwhile(lambda x: x 6 4 1 iterable = iter(iterable) for x in iterable: if not predicate(x): yield x break for x in iterable: yield x filterfalse() 创建一个迭代器，只返回iterable中predicate为False 的元素。如果predicate是None，返回真值测试为false的元素。 其实说白了就相当于filter()的反函数。 函数签名如下： itertools.filterfalse(predicate, iterable) 官方文档实现： def filterfalse(predicate, iterable): # filterfalse(lambda x: x%2, range(10)) --> 0 2 4 6 8 if predicate is None: predicate = bool for x in iterable: if not predicate(x): yield x islice() 创建一个迭代器，该函数接收3个参数，总体效果和切片取子序列类似，能指定开始位置、结束位置、步长等。 函数签名如下： itertools.islice(iterable, start, stop[, step] 官方文档实现： def islice(iterable, *args): # islice('ABCDEFG', 2) --> A B # islice('ABCDEFG', 2, 4) --> C D # islice('ABCDEFG', 2, None) --> C D E F G # islice('ABCDEFG', 0, None, 2) --> A C E G s = slice(*args) start, stop, step = s.start or 0, s.stop or sys.maxsize, s.step or 1 it = iter(range(start, stop, step)) try: nexti = next(it) except StopIteration: # Consume *iterable* up to the *start* position. for i, element in zip(range(start), iterable): pass return try: for i, element in enumerate(iterable): if i == nexti: yield element nexti = next(it) except StopIteration: # Consume to *stop*. for i, element in zip(range(i + 1, stop), iterable): pass starmap() 创建一个迭代器，使用从可迭代对象中获取的参数来计算该函数。当参数对应的形参已从一个单独可迭代对象组合为元组时（数据已被“预组对”）可用此函数代替 map()。map()与starmap()之间的区别可以类比 function(a,b)与function(*c)的区别。 函数签名如下： itertools.starmap(function, iterable) 官方文档实现： def starmap(function, iterable): # starmap(pow, [(2,5), (3,2), (10,3)]) --> 32 9 1000 for args in iterable: yield function(*args) 注意，function必须接收2个参数，而传入的Iterable也必须符合上述格式。 takewhile() 相当于filter()，创建一个迭代器，只要predicate为真就从可迭代对象中返回元素。 函数签名如下： itertools.takewhile(predicate, iterable) 官方文档实现： def takewhile(predicate, iterable): # takewhile(lambda x: x 1 4 for x in iterable: if predicate(x): yield x else: break zip_longset() 创建一个迭代器，从每个可迭代对象中收集元素。如果可迭代对象的长度未对齐，将根据fillvalue填充缺失值。迭代持续到耗光最长的可迭代对象。 函数签名如下： itertools.zip_longest(*iterables, fillvalue=None) 官方文档实现： class ZipExhausted(Exception): pass def zip_longest(*args, **kwds): # zip_longest('ABCD', 'xy', fillvalue='-') --> Ax By C- D- fillvalue = kwds.get('fillvalue') counter = len(args) - 1 def sentinel(): nonlocal counter if not counter: raise ZipExhausted counter -= 1 yield fillvalue fillers = repeat(fillvalue) iterators = [chain(it, sentinel(), fillers) for it in args] try: while iterators: yield tuple(map(next, iterators)) except ZipExhausted: pass 其他的迭代器 这里省略了2个迭代器，tee()和groupby()，因为我实在想不通在怎样的场景下会去使用它们.. 排序组合迭代器 product() 返回可迭代对象输入的笛卡儿积，存在重复元素。 函数签名如下： itertools.product(*iterables, repeat=1) 官方文档实现： def product(*args, repeat=1): # product('ABCD', 'xy') --> Ax Ay Bx By Cx Cy Dx Dy # product(range(2), repeat=3) --> 000 001 010 011 100 101 110 111 pools = [tuple(pool) for pool in args] * repeat result = [[]] for pool in pools: result = [x+[y] for x in result for y in pool] for prod in result: yield tuple(prod) permutations() 连续返回由iterable元素生成长度为r的排列。 如果r未指定或为None ，r默认设置为iterable的长度，这种情况下，生成所有全长排列。 排列依字典序发出。因此，如果iterable是已排序的，排列元组将有序地产出。 即使元素的值相同，不同位置的元素也被认为是不同的。如果元素值都不同，每个排列中的元素值不会重复。 函数签名如下： itertools.permutations(iterable, r=None 官方文档实现： def permutations(iterable, r=None): # permutations('ABCD', 2) --> AB AC AD BA BC BD CA CB CD DA DB DC # permutations(range(3)) --> 012 021 102 120 201 210 pool = tuple(iterable) n = len(pool) r = n if r is None else r if r > n: return indices = list(range(n)) cycles = list(range(n, n-r, -1)) yield tuple(pool[i] for i in indices[:r]) while n: for i in reversed(range(r)): cycles[i] -= 1 if cycles[i] == 0: indices[i:] = indices[i+1:] + indices[i:i+1] cycles[i] = n - i else: j = cycles[i] indices[i], indices[-j] = indices[-j], indices[i] yield tuple(pool[i] for i in indices[:r]) break else: return combinations() 返回由输入iterable中元素组成长度为 r 的子序列。 组合按照字典序返回。所以如果输入iterable是有序的，生成的组合元组也是有序的。 即使元素的值相同，不同位置的元素也被认为是不同的。如果元素各自不同，那么每个组合中没有重复元素。 函数签名如下： itertools.combinations(iterable, r) 官方文档实现： def combinations(iterable, r): # combinations('ABCD', 2) --> AB AC AD BC BD CD # combinations(range(4), 3) --> 012 013 023 123 pool = tuple(iterable) n = len(pool) if r > n: return indices = list(range(r)) yield tuple(pool[i] for i in indices) while True: for i in reversed(range(r)): if indices[i] != i + n - r: break else: return indices[i] += 1 for j in range(i+1, r): indices[j] = indices[j-1] + 1 yield tuple(pool[i] for i in indices) combinations_with_replacement() 返回由输入iterable中元素组成的长度为r的子序列，允许每个元素可重复出现。 组合按照字典序返回。所以如果输入iterable是有序的，生成的组合元组也是有序的。 不同位置的元素是不同的，即使它们的值相同。因此如果输入中的元素都是不同的话，返回的组合中元素也都会不同。 函数签名如下： itertools.combinations_with_replacement(iterable, r) 官方文档实现： def combinations_with_replacement(iterable, r): # combinations_with_replacement('ABC', 2) --> AA AB AC BB BC CC pool = tuple(iterable) n = len(pool) if not n and r: return indices = [0] * r yield tuple(pool[i] for i in indices) while True: for i in reversed(range(r)): if indices[i] != n - 1: break else: return indices[i:] = [indices[i] + 1] * (r - i) yield tuple(pool[i] for i in indices) Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-10 20:42:15 "},"Python/Python模块与包/functools.html":{"url":"Python/Python模块与包/functools.html","title":"内置模块：functools","keywords":"","body":"functools简介 functools是非常强大的内置模块，它提供了许多装饰器与函数，适用于对所有可调用对象的应用。 官方文档 这里主要着重介绍2种常用的函数与装饰器，它们适用于绝大部分的场景。 函数/装饰器 描述 partial() 冻结可调用对象的某些参数，因此该函数也被称为偏函数 @lru_cache 为函数提供缓存功能，当某一函数的两次调用参数均一致，则直接返回前一次调用的结果 在该模块中，我们之前也已经接触过它所提供的redue()与@warps装饰器，所以这里不再进行举例。 partial() 传入1个可调用对象和它的某一个或多个调用参数，返回1个新的可调用对象，并且该对象中的某些参数是被固定的。 函数签名如下： functools.partial(func, *args, **keywords) 官方文档实现： def partial(func, *args, **keywords): def newfunc(*fargs, **fkeywords): newkeywords = keywords.copy() newkeywords.update(fkeywords) return func(*args, *fargs, **newkeywords) newfunc.func = func newfunc.args = args newfunc.keywords = keywords return newfunc 示例演示： import functools def add(x, y): return x + y # newFunc = add(1, 2) newFunc = functools.partial(add, 1, 2) print(newFunc()) # 3 再来一个2进制转10进制的函数： import functools binToDecimal = functools.partial(int, base=2) print(binToDecimal(\"110\")) # 6 @lru_cache 一个为函数提供缓存功能的装饰器，缓存maxsize组传入参数，在下次以相同参数调用时直接返回上一次的结果。用以节约高开销或I/O函数的调用时间。 由于使用了字典存储缓存，所以该函数的固定参数和关键字参数必须是可哈希的。 函数签名如下： @functools.lru_cache(maxsize=128, typed=False) 参数释义： 如果maxsize设置为None，LRU功能将被禁用且缓存数量无上限。maxsize设置为2的幂时可获得最佳性能。 如果typed设置为true，不同类型的函数参数将被分别缓存。例如，f(3)和f(3.0)将被视为不同而分别缓存。 一个简单的例子： 第一次运行函数，传入参数1和2，计算结果为3，缓存这2个参数和结果 第二次运行函数，传入参数1和2，查询缓存，缓存有就直接获得结果，根本不运行函数，所以没有看到print()的打印效果 第三次运行函数，传入参数1.0和2，查询缓存，由于typed为True，故严格区分浮点型和整形，再次运行函数，结果计算为3.0 如下示例： import functools @functools.lru_cache(maxsize=128, typed=True) def add(x, y): print(\"add run...\") return x+y print(add(1, 2)) print(add(1, 2)) print(add(1.0, 2)) # add run... # 3 # 3 # add run... # 3.0 乍一看之下好像没什么作用，不就是缓存了一下嘛，实际上，在对递归函数上加上该装饰器，性能将会得到质的提升。 如下示例了加上该装饰器函数求解上楼梯问题和不加该装饰器函数求解上楼梯问题的总计运行时间。 对35阶梯楼梯的计算，加了该装饰器的运行几乎是瞬间完成，而不加该装饰器大概需要耗费十秒左右： import functools import time @functools.lru_cache(maxsize=256, typed=False) def haveCache(n): if n == 1: return 1 if n == 2: return 2 return haveCache(n - 1) + haveCache(n - 2) def dontHaveCache(n): if n == 1: return 1 if n == 2: return 2 return dontHaveCache(n - 1) + dontHaveCache(n - 2) s = time.time() haveCache(35) print(\"HaveCache - >\", time.time() - s) s = time.time() dontHaveCache(35) print(\"dontHaveCache - >\", time.time() - s) # HaveCache - > 0.0 # dontHaveCache - > 11.06638216972351 如果最大缓存设为2，则运行时间会慢一点，但是32阶的上楼梯问题也是在短短0.2秒之内得到解决了： @functools.lru_cache(maxsize=2, typed=False) ... # HaveCache - > 0.23421168327331543 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-10 20:56:47 "},"Python/Python模块与包/模块包库框架的区别.html":{"url":"Python/Python模块与包/模块包库框架的区别.html","title":"模块包库框架的区别","keywords":"","body":"模块 Python中1个.py文件就是一个模块。 模块是指为了解决某一单独功能而专门诞生的。 如用户登录注册功能中包含验证码发送，针对这一个小功能可以单独拎出来做一个模块。 verification_code.py 包 包其实就是一个包含有__init__.py的文件夹。 一个包中可以包含另一个包，包的基础单元是由模块构成。 包将一些近似功能的模块组合到一起，如登录注册这2个大功能可以形成一个顶级包，可分为登录包、注册包、功能包3个子包： login_register/ # 顶级包：登录组成 ├── __init__.py │ ├── features # 子级包：功能类 │ └── verification_code.py # 发送验证码 │ │ ├── login # 子级包：登录类 │ ├── __init__.py │ ├── email.py # 邮箱登录 │ ├── phone.py # 手机登录 │ ├── qq.py # QQ登录 │ └── weichat.py # 微信登录 │ │ └── register # 子级包：注册类 ├── __init__.py ├── other.py # 其他注册 ├── email.py # 邮箱注册 └── phone.py # 手机注册 库 库更像是针对某个功能的解决工具包，一般来说由一个或多个包组成。 如想获取时间相关功能的操作，有内置库time进行提供。 如想获取日志相关功能的操作，有内置库logging进行提供。 再比如想获取网络功能的操作，有第三方库requests进行提供。 在Python中，很多人通常将一些内置库称为内置模块，严格意义上来说并不准确，应该叫做Python内置库更好一点。 框架 框架是一套通用的解决方案，通常由多个库组成。 使用框架能够提供一整套的服务，它将所有可能用到的资源进行了整合。 如想搭建一个网站，有Django框架可以快速完成需求。 如想进行数据分析，有Numpy框架可以助你锦上添花。 再比如想开始网络爬虫，有Scrapy框架可以让你进行花式爬取。 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-05-22 13:52:55 "},"Python/Python面向对象/summary.html":{"url":"Python/Python面向对象/summary.html","title":"Python面向对象","keywords":"","body":" 编程范式 类与对象 类的方法 属性代理 封装 继承 多态 抽象基类 自省反射 双下大全 描述符类 元类编程 异常处理 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-13 13:32:40 "},"Python/Python面向对象/编程范式.html":{"url":"Python/Python面向对象/编程范式.html","title":"编程范式","keywords":"","body":"编程范式 编程范式只是一种程序设计思维，本身并无优劣之分。 与任何语言都无关，不要觉得面向对象就一定比面向过程好，实际上恰恰相反。 面向过程才是所有代码在内存中最终的状态。 面向过程 面向过程（OPP）编程思想的重点是将注意力放在事物本身上，更多的是关心下一步操作该怎么做，以正在发生为目的。 将1个大的问题逐步拆解成多个小问题，一旦问题解决后代码上线将很少有改动的场景。 特性：模块化、流程化 优点：代码可读性高，并且性能高 缺点：不利于维护与扩展 著名的以面向过程思想为指导的设计产品有Linux内核，git等软件。 可以说如果一个项目是按照面向过程思维进行开发，它应该是从小的细节一步一步实现，最终变为一个整体。 面向对象 面向对象（OOP）编程思想是目前主流的编程思想，它在对业务的分析上更加侧重于应当由谁来完成这份工作，将注意力放在了人的上面，而并非事物本身。 特性：抽象、封装、继承、多态 优点：易于维护、易于扩展 缺点：继承使得代码耦合度提高，并且性能较于面向过程来说略有损失 面向对象的本质就是整合，将具有某一共同特性的不同功能整合到一起进行分类。 如果一个项目是按照面向对象思维进行开发，它应该是先构建整体大局观，然后进行细节的丰富，而细节的丰富又最终回到了面向过程的思维上，因此面向对象和面向过程是不可分离的。 面向切面 面向切面（AOP）编程思想是面向对象的一种衍生。它旨在与将主逻辑业务和副逻辑业务进行切分，让彼此之间最大限度的降低耦合度。 此外，面向切面也能够在不损失已有功能的前提下，植入一个新的功能。 如Python装饰器函数，就是面向切面编程思想的最好体现。 特性：分离，低耦合，高内聚 优点：对扩展及其友好，因为各部都是分离的所以新功能添加上不会有太多的问题产生 缺点：如果设计过于混乱，则会让代码可读性降低，如一味使用装饰器来进行缝补，还不如重构整个项目 面向接口 面向接口（PO）编程思想是近些年来逐渐火热起来的一种编程思想，它将抽象与实现互相抽离，先定义接口规范，后进行逻辑实现。 面向接口与面向对象相结合，能够让项目更加健壮，并且可读性扩展性都会得到一定程度的提升。 特性：现实与抽象分离，抽象定义规范，现实指定逻辑 优点：具有良好的扩展性，增强代码可读性，便与后期维护 缺点：大幅度增加代码量 函数式编程 函数式编程是与数学函数高度结合的编程方式，纯粹的函数式编程语言没有变量只有常量，代码重复率较低，且功能一旦完善就不会出错。 在函数中没有for循环，所有的for循环用递归实现，函数式编程的一个特点就是允许把函数本身作为参数传入另一个参数，还允许返回一个函数。 此外，Python中的lambda以及filter，map，reduce等等都是从一些函数式编程语言如haskell中提取出来的一些优秀且符合Python核心思想的好案例。 特性：无变量，无for循环 优点：代码重复率低 缺点：程序易读性差 Python特性 Python本身是一门纯粹的面向对象语言，除此之外它也支持： 面向切面：装饰器就是最好的面向切面实现 面向接口：严格意义上来说Python并未提供真正完全的面向接口语法，但仍然可以实现 函数式编程：lambda、filter、map等都是Python中拥有的函数式编程实现 一门优秀的语言总是融百家之长，Python当然也不例外。 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-11 10:13:06 "},"Python/Python面向对象/类与对象.html":{"url":"Python/Python面向对象/类与对象.html","title":"类与对象","keywords":"","body":"类和对象 类是一个抽象的概念，而对象是一个实体的存在。 对象由类创造而出，每个对象之间互相独立互不影响，一个对象只能由一个类创建，但是一个类可以创建出多个对象，而实例化就是指通过某个类创建出对象的过程。 类与对象的关系类似于模具与产品，必须先有模具，然后才能根据这个模具制作出各式各样的产品。 基础介绍 定义类 Python中定义类，使用class关键字，具体语法如下: class 类标示符(继承类): # ❶ \"\"\" 类的描述文档 # ❷ \"\"\" 标示符 = 对象 # ❸ def __init__(self): # ❹ self.标示符 = 对象 def 实例方法(self): # ❺ pass ❶：类标识符以大驼峰命名 ❷：类的描述文档，用于介绍该类的作用 ❸：类属性，用于存放所有实例对象都可能用到的变量 ❹：初始化方法，用于初始化实例对象独有属性变量 ❺：实例化方法，用于提供给实例对象调用的函数 当一个类被定义时，将会发生以下的事情： 申请内存空间，保存类体代码 将内存空间的地址绑定给类的标示符 创建类的局部命名空间（注意与函数命名空间区分，函数是加括号调用执行后才创建） 执行类体代码（注意与函数的执行时机区分，函数是加括号调用后才会执行函数体代码） 下面将定义一个人类： class Person: \"\"\" Person：人类 class attr：眼耳口鼻 每个人都具有共同特性，可定义为类属性 instance attr: 姓名性别年龄 每个人不同的特征，可定义为实例属性 instance method: 吃饭 每个人都具有共同行为，可定义为实例方法 \"\"\" eye = 2 ear = 2 mouth = 2 nose = 1 def __init__(self, name, age, gender) -> None: self.name = name self.age = age self.gender = gender def eat(self, food): return \"%s eating %s\"%(self.name, food) def getInfo(self): return \"name : %s\\nage : %s\\ngender : %s\\n\"%(self.name, self.age, self.gender) 实例化 如何通过类创建出一个具体的对象？只需要在类标示符后加上括号即可，如下所示： if __name__ == \"__main__\": jack = Person(name=\"Jack\", age=18, gender=\"male\") print(jack.eat(\"fish\")) print(jack.getInfo()) # Jack eating fish # name : Jack # age : 18 # gender : male 类实例化的过程中会做很多事情，大概可分为下面3个步骤： 调用类下的__new__()方法构建一个空的实例对象 调用类下的__init__()方法对空实例对象进行初始化 于此同时，创建实例的专属命名空间 如何验证这一过程呢？我们可通过自定义__new__()方法进行证明： class A: def __new__(cls, *args, **kwargs) -> object: print(\"Run ... new\") instanceObject = super(A, cls).__new__(cls) return instanceObject def __init__(self, attr): print(\"Run ... init\") self.instanceAttr = attr if __name__ == \"__main__\": instanceA = A(\"a\") # Run ... new # Run ... init self、__new()__、__init__() __new__()方法是类实例化过程中运行的方法，作用是构建空的实例化对象，因此该方法也被称之为构造方法。 __init__()方法也是类实例化过程中运行的方法，作用是为空的实例化对象增添实例属性，因此该方法也被称之为对象的初始化方法，注意该方法必须返回None。 self其实就是指实例化对象本身，在实例化操作开始后实例化对象会由__new__()方法经过__init__()方法进行创建并返回。 所以你会看见下面3个标示符都是指向同1个对象： class A: def __new__(cls, *args, **kwargs) -> object: print(\"Run ... new\") instanceObject = super(A, cls).__new__(cls) print(id(instanceObject)) return instanceObject def __init__(self) -> None: print(\"Run ... init\") print(id(self)) def getInstanceId(self): print(\"Run ... instance method\") print(id(self)) if __name__ == \"__main__\": print(\"instance start\") instanceA = A() print(\"instance end\") print(id(instanceA)) instanceA.getInstanceId() # instance start # Run ... new # 29435600 # Run ... init # 29435600 # instance end # 29435600 # Run ... instance method # 29435600 __dict__ 类和实例对象都有一个__dict__，它是一个字典，包含类和对象的一些特征属性。 对于类的__dict__来说，它包含类属性、类方法、实例方法等一系列东西。 而对实例的__dict__来说，它仅包含实例属性。 如下所示： class A: name = \"class\" def __init__(self) -> None: self.name = \"instance\" def instanceMethod(self): pass if __name__ == \"__main__\": instanceA = A() print(A.__dict__) print(instanceA.__dict__) 结果展示，类的__dict__，包含的东西非常多： {'__module__': '__main__', 'name': 'class', '__init__': , 'instanceMethod': , '__dict__': , '__weakref__': , '__doc__': None} 而实例对象的__dict__只包含自身的实例属性，甚至连实例方法都在类的__dict__中： {'name': 'instance'} 属性与方法 类属性 如果要在类的外部获取类属性，可通过下面两种方式： 类.属性 类.__dict__[\"属性\"] 更加推荐第一种方式，它更加的直白，让人一眼就能看到这是在获取属性，而不是操纵字典： class A: name = \"class\" def __init__(self) -> None: self.name = \"instance\" def instanceMethod(self): pass if __name__ == \"__main__\": print(A.name) print(A.__dict__[\"name\"]) print(A.__dict__.get(\"name\")) # class # class # class 其他的类属性增删改查，也都是通过这两种方式进行操作，这里不再举例。 实例属性 外部获取实例属性与类属性一样，都是通过下面2种方式： 实例.属性 实例.__dict__[\"属性\"] 如下所示： class A: name = \"class\" def __init__(self) -> None: self.name = \"instance\" def instanceMethod(self): pass if __name__ == \"__main__\": instanceA = A() print(instanceA.name) print(instanceA.__dict__[\"name\"]) print(instanceA.__dict__.get(\"name\")) # instance # instance # instance 其他的操作诸如增删改等，都比较少用到，故不再进行举例。 实例方法 实例方法其实就是函数，我们可以看一下下面这个方法： class A: name = \"class\" def __init__(self) -> None: self.name = \"instance\" def instanceMethod(self, params): print(params) 如何调用它呢？ 方式1，通过实例对象调用它，会自动的将对象本身传递给self： if __name__ == \"__main__\": instanceA = A() instanceA.instanceMethod(\"hello world\") # hello world 方式2，通过类来调用它，但是需要你手动的为self传递参数： class A: name = \"class\" def __init__(self) -> None: self.name = \"instance\" def instanceMethod(self, params): print(params) if __name__ == \"__main__\": instanceA = A() A.instanceMethod(instanceA, \"hello world\") 方式2可能比较少见，但我们之前已经用过了，比如str.format()。 def format(self, *args: object, **kwargs: object) -> str 相同的结果，不同的调用方式，如下所示，self就是字符串\"hello {}\"： classRunFormatMethod = str.format(\"hello {}\", \"world\") instanceRunFormatMethod = \"hello {}\".format(\"world\") print(classRunFormatMethod) print(instanceRunFormatMethod) # hello world # hello world 内部获取 类属性可以在实例方法中进行获取，获取方式有2种： 类.属性 self.属性 # 前提是self.__dict__中没有同名属性 推荐使用第一种，指名道姓的说我要获取类属性： class A: name = \"class\" def __init__(self) -> None: self.name = \"instance\" def instanceMethod(self): print(A.name) print(self.name) if __name__ == \"__main__\": instanceA = A() A.instanceMethod(instanceA) # class # instance 实例属性在实例方法中获取直接通过下面的方式即可： self.属性 如下所示： class A: name = \"class\" def __init__(self) -> None: self.name = \"instance\" def instanceMethod(self): print(self.name) if __name__ == \"__main__\": instanceA = A() A.instanceMethod(instanceA) # instance 实例方法中可以嵌套调用另一个方法，也可以调用外部的函数，如下所示： class A: name = \"class\" def __init__(self) -> None: self.name = \"instance\" def func1(self): print(\"func1\") self.func2() globalFunc() def func2(self): print(\"func2\") def globalFunc(): print(\"globalFunc\") if __name__ == \"__main__\": instanceA = A() instanceA.func1() # func1 # func2 # globalFunc 命名空间 类和实例的命名空间 类和实例的命名空间说白了就是__dict__字典。 一个类拥有多个实例，一个实例仅来自于一个类。 因此我们可以画出下面这幅图： 首先，类的命名空间是无法访问实例的命名空间的。 但是实例命名空间可以访问类的命名空间，类似于函数嵌套LEGB的关系。 标示符查找顺序 如果一个实例要查找某一个属性，自身存在就获取自身的，若自身不存在则取拿类的。 查看实例自身的__dict__，若没有 则查看类的__dict__，若没有 则抛出异常 我们来看一下下面这个例子： class A: name = \"ClassAttr:A\" if __name__ == \"__main__\": instanceOne = A() instanceTwo = A() instanceThree = A() print(instanceOne.name) print(instanceTwo.name) print(instanceThree.name) A.name = \"ClassAttr:B\" print(instanceOne.name) print(instanceTwo.name) print(instanceThree.name) instanceOne.name = \"InstanceAttr:a\" print(instanceOne.name) print(instanceTwo.name) print(instanceThree.name) # ClassAttr:A # ClassAttr:A # ClassAttr:A # ClassAttr:B # ClassAttr:B # ClassAttr:B # InstanceAttr:a # ClassAttr:B # ClassAttr:B 采用图解的方式来进行代码注释。 第一种情况，三个实例的__dict__中都没有name，所以会去类的__dict__中查找： 第二种情况，类__dict__中的name被修改，三个实例再次访问name，自身的__dict__没有故到类的__dict__中找，会获取到修改后的name： 第三种情况，第一个实例对象One的__dict__中具有实例属性name，故它会拿到自己的，其他2个实例对象都没有，依然会去拿类的： Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-11 10:18:58 "},"Python/Python面向对象/类的方法.html":{"url":"Python/Python面向对象/类的方法.html","title":"类的方法","keywords":"","body":"实例方法 实例方法是存储在类的__dict__字典中，实例方法都有一个固定的参数名为self，位于第一个位置。 实例方法通常会通过实例对象调用，当实例对象调用实例方法时，会自动的将自身传递给self。 如下所示： class Student: def __init__(self, name): self.name = name def show(self): return \"my name is %s\"%self.name if __name__ == \"__main__\": instanceOne = Student(\"Jack\") instanceTwo = Student(\"Tom\") print(instanceOne.show()) # self = instanceOne print(instanceTwo.show()) # self = instanceTwo # my name is Jack # my name is Tom 它的底层是怎么做的呢？ 其实还是要从属性查找顺序开始剖析，如下所示： 第一步：查找实例自身的__dict__试图获取实例方法，但实例方法都存于与类的__dict__中，故找不到 第二步：查找类的__dict__成功获取实例方法 第三步：根据类的__dict__中所定义的实例方法，自动的为self参数传递进调用者，生成一个新的方法 所以你会看见下面这样的场景，3个方法，3个存储空间： class Student: def __init__(self, name): self.name = name def show(self): return \"my name is %s\"%self.name if __name__ == \"__main__\": instanceOne = Student(\"Jack\") instanceTwo = Student(\"Tom\") print(instanceOne.show) print(instanceTwo.show) print(Student.show) # > # > # 类的方法 类方法是指头部带有@classmethod装饰器的方法，类方法都有一个固定的参数名为cls，位于第一个位置。 类方法通常由类进行调用，同时会自动的将类传递进方法cls参数中，如下所示： class Student: def __init__(self, name): self.name = name def show(self): return \"my name is %s\"%self.name @classmethod def learn(cls): print(cls.__name__) return \"students must learn\" if __name__ == \"__main__\": print(Student.learn()) # cls = Student # Student # students must learn 当然也可以通过实例对象调用类方法，cls接收的对象不是实例本身而是类，但是不建议这么做： class Student: def __init__(self, name): self.name = name def show(self): return \"my name is %s\"%self.name @classmethod def learn(cls): print(cls.__name__) return \"students must learn\" if __name__ == \"__main__\": instanceObject = Student(\"Jack\") print(instanceObject.learn()) # cls = Student # Student # students must learn 静态方法 静态方法是指头部带有@staticmethod装饰器的方法。 常作为类的工具箱出现，类和实例都可以随意的对其调用，没有自动传入的参数self或者cls，就是一个类中的普通函数： class MathTools: @staticmethod def getMax(x, y): return x if x > y else y if __name__ == \"__main__\": print(MathTools.getMax(1, 2)) instanceObject = MathTools() print(instanceObject.getMax(1, 2)) # 2 # 2 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-11 10:20:57 "},"Python/Python面向对象/属性代理.html":{"url":"Python/Python面向对象/属性代理.html","title":"属性代理","keywords":"","body":"属性代理 属性代理是指通过@property描述符装饰器来规定用户对类或者实例中某一属性的操作做出行为限制的方式。 类似于JavaScript中的代理器，Vue中的计算属性等，Python中则称之为描述符。 计算获取 　BMI指数是用来衡量一个人的体重与身高对健康影响的一个指标，计算公式为： BMI指数计算公式: BMI = 体重(kg) / (身高m**2) BMI正常值在20至25之间，超过25为超重，30以上则属肥胖 身高或体重是不断变化的，因而每次想查看BMI值都需要通过计算才能得到，但很明显BMI听起来更像是一个特征而非功能。 为此Python专门提供了一个装饰器@property，可以将类中的方法伪装成属性，对象在访问该特殊属性时会触发功能的执行，然后将返回值作为本次访问的结果，例如： class Person: def __init__(self, name, height, weight): self.name = name self.height = height self.weight = weight @property def bmi(self): v = self.weight / (self.height ** 2) if 20 25: return \"overweight\" return \"obesity\" if __name__ == \"__main__\": instanceObject = Person(\"ken\", height=1.76, weight=77) # autoRun instanceObjectMethod => bmi(self=instanceObject) print(instanceObject.bmi) #　normal 行为控制 你也可以使用其他的形式，来控制属性的删改查等行为，如下所示： class Person: def __init__(self): self.__attr = None @property def name(self): \"\"\"获取name时自动触发该方法，只有当__attr不为None才能被获取到\"\"\" if not self.__attr is None: return self.__attr else: raise AttributeError(\"name is not set\") @name.setter def name(self, params): \"\"\"设置name时自动触发该方法，只有当params为 'Jack' 时才能成功为__attr赋值\"\"\" if params != \"Jack\": raise AttributeError(\"name must setting is string 'Jack', but you set is %s\"%params) else: self.__attr = params @name.deleter def name(self): \"\"\"删除name时自动触发该方法，不允许删除name\"\"\" raise AttributeError(\"name not should delete\") if __name__ == \"__main__\": instanceObject = Person() instanceObject.name = \"Jack\" print(instanceObject.name) del instanceObject.name # Jack # AttributeError: name not should delete 行为控制 行为控制还有另外一种形式，它是固定的用法，如下所示，效果和上面一样： class Person: def __init__(self): self.__attr = None def nameGet(self): \"\"\"获取name时自动触发该方法，只有当__attr不为None才能被获取到\"\"\" if not self.__attr is None: return self.__attr else: raise AttributeError(\"name is not set\") def nameSet(self, params): \"\"\"设置name时自动触发该方法，只有当params为 'Jack' 时才能成功为__attr赋值\"\"\" if params != \"Jack\": raise AttributeError(\"name must setting is string 'Jack', but you set is %s\"%params) else: self.__attr = params def nameDelete(self): \"\"\"删除name时自动触发该方法，不允许删除name\"\"\" raise AttributeError(\"name not should delete\") name = property(fget=nameGet, fset=nameSet, fdel=nameDelete) if __name__ == \"__main__\": instanceObject = Person() instanceObject.name = \"Jack\" print(instanceObject.name) del instanceObject.name # Jack # AttributeError: name not should delete Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-11 10:23:24 "},"Python/Python面向对象/封装.html":{"url":"Python/Python面向对象/封装.html","title":"封装","keywords":"","body":"oop封装 封装是oop思想中最重要的一个，也是所有面向对象程序设计中始终绕不开的话题，说白了就是将数据和功能整合到一起。 类本身就属于封装，如定义一个类，该类中的属性以及方法只有该类或者其实例化对象才能调用，这就是类封装的体现。 除此之外，oop封装中还有2个十分重要的名词，即： 私有属性 公有属性 私有属性 类的私有属性是指在类中以_下划线开头，或者以__下划线开头命名的标示符。 它们都是指将该标示符属性隐藏，仅用于类的内部调用，不希望甚至不支持在类的外部访问这些属性。 单下封装 单下封装是指在类中以_下划线开头的标示符，它意味着使用者不应该在类的外部访问该属性，但实际上外部仍然可以访问。 如下示例，对于女孩子来说，年龄是一项比较私密的属性，因此可以使用单下命名法将该属性隐藏。 即告诉别人，我不想要你知道我的年龄，但是你要强求也是可以得到的： class Person: def __init__(self, name, age, gender) -> None: self.name = name self.gender = gender if self.gender == \"male\": self.age = age elif self.gender == \"female\": self._age = age def getInfo(self): message = \"name : %s\\ngender : %s\\n\"%(self.name, self.gender) if self.gender == \"male\": message += \"age : %d\"%self.age elif self.gender == \"female\": if 18 > self._age: # ❶ message += \"age : underage\" elif 18 ❶：对于单下命名的属性，应当在类的内部进行调用 ❷：虽然能够在外部获取到Mary的年龄，但是不建议这样使用，正确的做法应该是调用getInfo()方法获取信息 双下封装 双下封装是指在类中以__下划线开头的标示符，它意味着使用者应当禁止在类的外部访问该属性，但通过特殊的手段也是能访问到的。 如下示例，对于女孩子来说，体重是一项绝对私密的属性，因此可以使用双下命名法将该属性隐藏。 即告诉别人，你不可以通过常规手段获得我的体重： class Person: def __init__(self, name, gender, weight) -> None: self.name = name self.gender = gender if self.gender == \"male\": self.weight = weight elif self.gender == \"female\": self.__weight = weight def getInfo(self): message = \"name : %s\\ngender : %s\\n\" % (self.name, self.gender) if self.gender == \"male\": message += \"weight : %s(kg)\" % self.weight elif self.gender == \"female\": if 45 > self.__weight: # ❶ message += \"weight : thin\" elif 45 55: message += \"weight : normal\" else: message += \"weight : fat\" return message if __name__ == \"__main__\": jack = Person(name=\"Jack\", gender=\"male\", weight=60) print(jack.getInfo()) print(jack.weight) mary = Person(name=\"Mary\", gender=\"female\", weight=50) print(mary.getInfo()) print(mary.__weight) # ❷ # name : Jack # gender : male # weight : 60(kg) # 60 # name : Mary # gender : female # weight : fat # AttributeError: 'Person' object has no attribute '__weight' ❶：对于双下命名的属性，应当在类的内部进行调用 ❷：外部调用该属性直接抛出异常，找不到，所以应当使用getInfo()方法获取信息 双下重命名 其实双下封装法只是将属性重命名了，通过实例对象的__dict__可以查看到： if __name__ == \"__main__\": mary = Person(name=\"Mary\", gender=\"female\", weight=50) print(mary.__dict__) # {'name': 'Mary', 'gender': 'female', '_Person__weight': 50} 命名规则是： _类名__属性 所以，双下封装的属性其实在外部也能获取到，但是不推荐这么做，有悖于规范，如下所示： if __name__ == \"__main__\": mary = Person(name=\"Mary\", gender=\"female\", weight=50) print(mary._Person__weight) # 50 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-11 10:23:29 "},"Python/Python面向对象/继承.html":{"url":"Python/Python面向对象/继承.html","title":"继承","keywords":"","body":"oop继承 继承介绍 继承作为oop三大特性之一，可以说是最难的一章知识点，但是用的非常多。 继承是指创建类的一种方式，极大程度上规避了类与类之间代码的重复问题。 在Python中，是支持多继承的，即一个类可以继承多个类，这是其他大多数语言中所不支持的。 被继承的类可以称为父类，超类或者基类 继承的类可以称为子类或者派生类 派生类可以使用父类所有的属性及方法，但是父类是不能使用派生类的属性或方法的。 以下是语法格式： class 类标示符(父类1, 父类2): ... 举一个简单的例子，下面定义了一个狼（Wolf）类和狗（Dog）类，它们都具有相同的方法咬人（bite）、跑步（run）等，由于继承的存在故不用将该方法书写两次，直接使用狗类继承狼类即可： class Wolf: def __init__(self, name) -> None: self.name = name def bite(self, personName): return \"%s biting %s\" % (self.name, personName) def run(self): return \"%s runing...\" % self.name class Dog(Wolf): pass if __name__ == \"__main__\": wolfInstance = Wolf(\"King Kong\") print(wolfInstance.bite(\"Tom\")) print(wolfInstance.run()) print(\"=\" * 10) dogInstance = Dog(\"Small Black\") print(dogInstance.bite(\"Jack\")) print(dogInstance.run()) # King Kong biting Tom # King Kong runing... # ========== # Small Black biting Jack # Small Black runing... 方法覆写 如果派生类中拥有和父类同名的方法或者属性，则派生类或者其实例对象在查找这些属性或方法时只会拿自己的。 如下所示，在Dog类中重写了bite，让它不再咬人： class Wolf: def __init__(self, name) -> None: self.name = name def bite(self, personName): return \"%s biting %s\" % (self.name, personName) def run(self): return \"%s runing...\" % self.name class Dog(Wolf): def bite(self, personName): return \"%s not biting, %s escaped \" % (self.name, personName) if __name__ == \"__main__\": wolfInstance = Wolf(\"King Kong\") print(wolfInstance.bite(\"Tom\")) print(wolfInstance.run()) print(\"=\" * 10) dogInstance = Dog(\"Small Black\") print(dogInstance.bite(\"Jack\")) print(dogInstance.run()) # King Kong biting Tom # King Kong runing... # ========== # Small Black not biting, Jack escaped # Small Black runing... Python3 新式类 Python3中默认的所有类都继承了object类，这样的类被称为新式类： class A: # eq class A(object) pass if __name__ == \"__main__\": print(A.__bases__) # (,) 单继承 新式类单继承查找公有属性、方法时，每轮按照一条线的向上查找次序，如下图所示： 代码示例： class A: def show(self): print(\"--- A.show run ---\") self.info() def info(self): print(\"--- A.info run ---\") def __getattribute__(self, name: str): print(\"find A.%s\" % name) return super().__getattribute__(name) class B(A): def info(self): print(\"--- B.info run ---\") def __getattribute__(self, name: str): print(\"find B.%s\" % name) return super().__getattribute__(name) class C(B): def info(self): print(\"--- C.info run---\") def __getattribute__(self, name: str): print(\"find C.%s\" % name) return super().__getattribute__(name) if __name__ == \"__main__\": instanceC = C() instanceC.show() # find C.show # find B.show # find A.show # --- A.show run --- # find C.info # find B.info # find A.info # --- C.info run--- 而新式类如果是单继承查找私有属性、方法则结果又不一样，如下图所示： 代码示例： class A: def show(self): print(\"--- A.show run ---\") self.__info() def __info(self): print(\"--- A.__info run ---\") def __getattribute__(self, name: str): print(\"find A.%s\" % name) return super().__getattribute__(name) class B(A): def __info(self): print(\"--- B.__info run ---\") def __getattribute__(self, name: str): print(\"find B.%s\" % name) return super().__getattribute__(name) class C(B): def __info(self): print(\"--- C.__info run---\") def __getattribute__(self, name: str): print(\"find C.%s\" % name) return super().__getattribute__(name) if __name__ == \"__main__\": instanceC = C() instanceC.show() # find C.show # find B.show # find A.show # --- A.show run --- # find C._A__info # find B._A__info # find A._A__info # --- A.__info run --- 普通多继承 Python3中的新式类普通多继承，会按照深度优先的查找策略查找整个继承树。 深度优先：从左至右查找，每条分支查到最顶部，最后查找object类 如下图所示： 代码示例： class A: def __getattribute__(self, name: str): print(\"find A.%s\" % name) return super().__getattribute__(name) class B(A): def __getattribute__(self, name: str): print(\"find B.%s\" % name) return super().__getattribute__(name) class C(B): def show(self): print(\"--- C.show run ---\") def __getattribute__(self, name: str): print(\"find C.%s\" % name) return super().__getattribute__(name) class D: def __getattribute__(self, name: str): print(\"find D.%s\" % name) return super().__getattribute__(name) class E(D): def __getattribute__(self, name: str): print(\"find E.%s\" % name) return super().__getattribute__(name) class F: def __getattribute__(self, name: str): print(\"find F.%s\" % name) return super().__getattribute__(name) class G(C, E, F): def __getattribute__(self, name: str): print(\"find G.%s\" % name) return super().__getattribute__(name) if __name__ == \"__main__\": instanceG = G() instanceG.show() # find G.show # find C.show # find B.show # find A.show # find E.show # find D.show # find F.show # --- C.show run --- 钻石多继承 钻石多继承也被称为死亡菱形继承，继承关系如下所示： Python3中的新式类钻石多继承，会按照广度优先的查找策略查找整个继承树。 广度优先：从左至右查找，每条分支查到顶部第二个类超类，也就是不查钻石基类，如果都没有才查找钻石基类，最后查找object类 如下图所示： 代码示例： class A: def show(self): print(\"--- A.show run ---\") def __getattribute__(self, name: str): print(\"find A.%s\" % name) return super().__getattribute__(name) class B(A): def __getattribute__(self, name: str): print(\"find B.%s\" % name) return super().__getattribute__(name) class C(A): def __getattribute__(self, name: str): print(\"find C.%s\" % name) return super().__getattribute__(name) class D(A): def __getattribute__(self, name: str): print(\"find D.%s\" % name) return super().__getattribute__(name) class E(B): def __getattribute__(self, name: str): print(\"find E.%s\" % name) return super().__getattribute__(name) class F(C): def __getattribute__(self, name: str): print(\"find F.%s\" % name) return super().__getattribute__(name) class G(D): def __getattribute__(self, name: str): print(\"find G.%s\" % name) return super().__getattribute__(name) class H(E): def __getattribute__(self, name: str): print(\"find H.%s\" % name) return super().__getattribute__(name) class I(H, F, G): def __getattribute__(self, name: str): print(\"find I.%s\" % name) return super().__getattribute__(name) if __name__ == \"__main__\": instanceI = I() instanceI.show() # find I.show # find H.show # find E.show # find B.show # find F.show # find C.show # find G.show # find D.show # find A.show # --- A.show run --- Python2 经典类 Python2中如果一个类没有继承object类，这种类被称为经典类。 反之，如果继承了object类，则被称为新式类。 如下所示： # Python2中的经典类，也就是Python3中的新式类 class A: pass # Python2中的新式类 class A(object): pass 换而言之，Python2的类有新式类和经典类2种，Python3中仅有新式类，取消了经典类的设定。 不论是Python2的新式类还是Python3的新式类，它们的查找过程都是相同的，故下面只会例举经典类的查找顺序。 单继承 经典类在单继承的情况下，和新式类的查找顺序一致。 普通多继承 不管是新式类还是经典类，在普通多继承的查找下都是深度优先策略： 深度优先：从左至右查找，每条分支查到最顶部 由于不能使用__getattribute__()方法来查看整个查找过程，故这里就不再进行代码示例了。 感兴趣的朋友可以自行测试一下。 钻石多继承 钻石多继承中，经典类采用的是深度优先策略，而新式类则采用的广度优先策略。 深度优先：从左至右查找，每条分支查到最顶部，也就是说钻石基类在第一轮就会被查到 图示如下： 由于不能使用__getattribute__()方法来查看整个查找过程，故这里就不再进行代码示例了。 感兴趣的朋友可以自行测试一下。 双下属性 __class__ instanceObject.__class__属性可以查看实例对象所属的类： class A: pass if __name__ == \"__main__\": instanceObject = A() print(instanceObject.__class__) # __main__.A __base__ className.__base__属性可查看到类的父类，仅Python3有效，返回类对象： class A: pass class B(A): pass class C(B): pass if __name__ == \"__main__\": print(C.__base__) # __bases__ className.__bases__属性可查看到类的父类，仅Python3有效，返回元组，索引0处是其父类： class A: pass class B(A): pass class C(B): pass if __name__ == \"__main__\": print(C.__bases__) # (,) __mro__ 类的属性查找顺序在类定义时底层会根据C3算法生成，使用className.__mro__可调用出该查找顺序。 返回一个列表，列表中嵌套各种父类、超类，也就是说这是一个属性查找顺序列表。 注意，仅在Python3中生效。 下面是新式类普通多继承属性查找顺序，和上面测试的结果一致： class A: pass class B(A): pass class C(B): pass class D: pass class E(D): pass class F: pass class G(C, E, F): pass if __name__ == \"__main__\": print(G.__mro__) # (, , , , , , , ) 下面是新式类钻石多继承属性查找顺序，和上面测试的结果一致： class A: pass class B(A): pass class C(A): pass class D(A): pass class E(B): pass class F(C): pass class G(D): pass class H(E): pass class I(H, F, G): pass if __name__ == \"__main__\": print(I.__mro__) # (, , , , , , , , , ) 方法借用 class.attr 如果一个类和另一个类没有任何关系，但是要借用运行其下方法时，可以选择指名道姓的通过类来调用其下方法。 必须手动传入所有参数，如下所示： class A: def func(self): print(\"run A instance method\") class B: def func(self): print(\"run B instance method\") A.func(self=self) if __name__ == \"__main__\": B().func() # run B instance method # run A instance method super() 如果一个类和另一个类有继承关系，则可以通过super()方法自动向后查找其父类中需要借用的方法并执行。 它本质上会做两件事： 调用__mro__，拿到属性查找顺序列表 确定当前类在列表中的位置，并且拿到其父类，再自动使用class.attr的方式指名道姓的运行父类方法 所以，使用super()方法进行方法借用时，也需要手动传入所有参数，但是传入的参数与class.attr的方式有所不同。 具体的函数签名如下： super(__class__, ) 使用案例： class A: def func(self): print(\"run A instance method\") class B(A): def func(self): print(\"run B instance method\") super(__class__, self).func() # ❶ ❷ if __name__ == \"__main__\": B().func() # run B instance method # run A instance method ❶：传入__class__，用于确认该类在__mro__所返回的属性查找顺序列表中的位置，以便确定后面的父类查找 ❷：传入self，它将自动把self传递给A.func()的第一个参数 注意事项： Python3的super()方法中参数可以不传递，它会自动进行补充 Python2的经典类如果想使用super()方法，则必须在文件顶部添加一句代码 ： __metaclass__ = type，否则无法使用 Python2的super()方法中参数必须传递，不可进行省略 Mixins机制 Python由于支持多继承的关系，故在某些情况下可能导致代码逻辑不通顺的问题出现，如下所示： 为了能让基类的作用更加强大，符合一切交通工具的特性，你可能会在交通工具基类里面定义下面的方法： 飞行方法 抛锚方法 刹车方法 那么这个时候就已经产生了逻辑问题： 轮船不会飞，也不会刹车，但作为交通工具基类的派生类，它也能调用这些方法 汽车不会飞，也不会抛锚，但作为交通工具基类的派生类，它也能调用这些方法 飞机不会刹车，也不会抛锚，但作为交通工具基类的派生类，它也能调用这些方法 代码示例： class Transportation: def __init__(self, name) -> None: self.name = name def fly(self): \"\"\" 飞 \"\"\" print(\"%s flying\" % self.name) def brake(self): \"\"\" 刹车 \"\"\" print(\"%s braking\" % self.name) def anchor(self): \"\"\" 抛锚 \"\"\" print(\"%s anchor\" % self.name) class Aircraft(Transportation): pass class Car(Transportation): pass class Ship(Transportation): pass if __name__ == \"__main__\": aircraft = Aircraft(\"Boeing 747\") car = Car(\"BMW\") ship = Ship(\"Titanic\") # Serious Problem aircraft.brake() aircraft.anchor() car.fly() car.anchor() ship.fly() ship.brake() # Boeing 747 braking # Boeing 747 anchor # BMW flying # BMW anchor # Titanic flying # Titanic braking 如何解决这个问题呢？我们可以使用Mixins机制，将刹车、抛锚、飞行这3个不同的功能单独的封装到下面3个类中： 汽车功能类：刹车 飞机功能类：飞行 轮船功能类：抛锚 子类只需要继承交通工具基类和对应的功能类即可，如下图所示： 代码示例如下： class Transportation: def __init__(self, name) -> None: self.name = name class AircraftMixin: def fly(self): \"\"\" 飞 \"\"\" print(\"%s flying\" % self.name) class CarMixin: def brake(self): \"\"\" 刹车 \"\"\" print(\"%s braking\" % self.name) class ShipMixin: def anchor(self): \"\"\" 抛锚 \"\"\" print(\"%s anchor\" % self.name) class Aircraft(Transportation, AircraftMixin): pass class Car(Transportation, CarMixin): pass class Ship(Transportation, ShipMixin): pass if __name__ == \"__main__\": aircraft = Aircraft(\"Boeing 747\") car = Car(\"BMW\") ship = Ship(\"Titanic\") aircraft.fly() car.brake() ship.anchor() # Boeing 747 flying # BMW braking # Titanic anchor Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-11 16:59:43 "},"Python/Python面向对象/多态.html":{"url":"Python/Python面向对象/多态.html","title":"多态","keywords":"","body":"oop多态 多态更多的是指的一种思想，而非具体技术。 因为继承的存在，从而引发了多态，举个例子，所有的生物都是由一个单细胞生物不断演化而来，迄今为止它们的差异越来越大，这就是多态的体现。 多态的定义其实更准确的说法是：在不同类中实例化得到的不同对象调用一个相同方法时，它们的实现过程并不一样。 Python本身就实现了多态，其中len()方法就是最好的多态体现，2个不同类的实例化对象调用相同方法，该方法内部的处理是完全不同的： lst = [i for i in range(10)] tpl = tuple(i for i in range(10)) print(len(lst)) print(len(tpl)) # 10 # 10 多态实现 为了能够更好的理解多态，我们可以用下面这段代码来阐述。 首先，有一个犬科（Canine）的类，实现了吼叫（howl）的方法。 然后，狼（Wolf）和狗（Dog）类均继承自该类，它们都有一个吼叫的方法，但是由于狼和狗还是有很大差距的，所以该方法的内部实现过程并不一样，这就是多态的体现。 即：犬科具有吼叫方法，但同属犬科的狼和狗的吼叫是不同的。 class Canine: def howl(self): pass class Wolf(Canine): def howl(self): return \"wolf howling : ao~ ao~ ao~\" class Dog(Canine): def howl(self): return \"dog howling : wang~ wang~ wang~\" if __name__ == \"__main__\": wolfInstance = Wolf() dogInstance = Dog() print(wolfInstance.howl()) print(\"=\" * 10) print(dogInstance.howl()) # wolf howling : ao~ ao~ ao~ # ========== # dog howling : wang~ wang~ wang~ duke type 鸭子类型（duke type）是一个很有趣的词汇。 它指的是我不管你是不是鸭子，只要你具备了某些鸭子的特性，如会嘎嘎嘎，走路会摇摇晃晃等我就认为你是鸭子。 那它到底有什么好处呢？其实这样做是为了方便使用者进行方法调用。 如tuple和list，它们何其相似，如果你知道list.index()这个方法，你肯定也会尝试tuple.index()方法，结果发现居然还真的有。 鸭子类型与继承毫无关系，它强调的也是一种抽象的分类，如list和tuple同属线性结构，应该都能使用index()方法，也应当都能使用len()方法。 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-11 14:42:24 "},"Python/Python面向对象/抽象基类.html":{"url":"Python/Python面向对象/抽象基类.html","title":"抽象基类","keywords":"","body":"抽象基类 接口（interface）和抽象基类（abstract base class）是非常相似的，Python中并未提供真正意义上的接口，但是提供了抽象基类的使用。 它们的作用在于： 约束子类实现，子类必须实现抽象基类中的某一个方法才能被实例化，否则将不可被实例化 举个例子，羊（Sheep）和狼（Wolf）都属于哺乳类（Breastfeeding），那么它们都至少具有1个方法名为哺乳（feeding），如果没有该方法，则该类不能被实例化。 其实说白了，抽象基类的作用就是规范子类实现，所以： 抽象基类仅用于被继承，不必对其进行实例化 抽象基类内部方法不必实现 abc Python中用abc模块定义抽象基类，只需要将抽象基类的metaclass=abc.ABCMeta即可。 除此之外，它还提供了3个装饰器： abc.abstractclassmethod：抽象类方法 abc.abstractstaticmethod：抽象静态方法 abc.abstractmethod：抽象实例方法 代码示例如下： import abc class Breastfeeding(metaclass=abc.ABCMeta): @abc.abstractmethod def feeding(self): pass class Sheep(Breastfeeding): def feeding(self): return \"sheep feeding\" class Wolf(Breastfeeding): pass if __name__ == \"__main__\": sheepInstance = Sheep() print(\"sheep class instance success!\") wolfInstance = Wolf() # sheep class instance success! # TypeError: Can't instantiate abstract class Wolf with abstract methods feeding 这个例子中，羊实现了哺乳的方法，所以实例化成功了，而狼则没有实现哺乳方法，故实例化失败了。 如果有1个狗（Dog）类继承了狼类，那么狗类能否受到抽象基类的影响呢？ 答案是不能，抽象基类只能影响其下一代继承类的实现，不能影响其孙系类。 如下所示： import abc class Breastfeeding(metaclass=abc.ABCMeta): @abc.abstractmethod def feeding(self): pass class Sheep(Breastfeeding): def feeding(self): return \"sheep feeding\" class Wolf(Breastfeeding): def feeding(self): return \"wolf fedding\" class Dog(Wolf): pass if __name__ == \"__main__\": sheepInstance = Sheep() print(\"sheep class instance success!\") wolfInstance = Wolf() print(\"wolf class instance success!\") dogInstance = Dog() print(\"dog class instance success!\") # sheep class instance success! # wolf class instance success! # dog class instance success! 继承约束 通过继承，也能进行子类的行为约束，但是常规手段不能禁止其实例化。 如下所示，狼类没有实现哺乳方法，依然实例化成功了，但是不能调用哺乳方法： class Breastfeeding: def feeding(self): raise AssertionError(\"%s must implement method feeding\" % (self.__class__.__name__)) class Sheep(Breastfeeding): def feeding(self): return \"sheep feeding\" class Wolf(Breastfeeding): pass if __name__ == \"__main__\": sheepInstance = Sheep() print(\"sheep class instance success!\") print(sheepInstance.feeding()) wolfInstance = Wolf() print(\"wolf class instance success!\") print(wolfInstance.feeding()) # sheep class instance success! # sheep feeding # wolf class instance success! # AssertionError: Wolf must implement method feeding 上面这种方式在很多框架中也被经常使用到，但如果你想实现和ABCMeta同样的效果，可以覆写基类的__new__()方法，如下所示： class Breastfeeding: def __new__(cls) -> object: for attr in Breastfeeding.__dict__: if attr.startswith(\"__\"): continue if attr not in cls.__dict__: raise TypeError(\"Can't instantiate abstract class %s with abstract methods %s\" % (cls.__name__, attr)) return super(Breastfeeding, cls).__new__(cls) def feeding(self): pass class Sheep(Breastfeeding): def feeding(self): return \"sheep feeding\" class Wolf(Breastfeeding): pass if __name__ == \"__main__\": sheepInstance = Sheep() print(\"sheep class instance success!\") print(sheepInstance.feeding()) wolfInstance = Wolf() print(\"wolf class instance success!\") print(wolfInstance.feeding()) # sheep class instance success! # sheep feeding # TypeError: Can't instantiate abstract class Wolf with abstract methods feeding Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-11 14:43:24 "},"Python/Python面向对象/自省反射.html":{"url":"Python/Python面向对象/自省反射.html","title":"自省反射","keywords":"","body":"自省反射 自省和反射是两个比较专业化的术语，释义如下： 自省是指获取对象的能力 反射是指操纵对象的能力 由于Python是一门强类型的动态解释型语言，所以它的自省和反射使用非常简单。 我们在某些时候并不知道对象中具有的属性与方法，尤其是接手别人的项目时这种情况更加明显。 在这种情况下，我们不能直接通过Object.__dict__来获取其对象的属性与方法（因为这样获取不到继承的属性），而应当先使用自省来获取对象信息后，再使用反射来操纵对象，故自省和反射的学习显得尤为重要。 以下举例常见自省与反射的函数： 函数 返回值 描述 help(object) None 获取对象文档帮助信息 dir(object) list 获取对象下所有能被.操纵的属性与方法 hasattr(object, str) bool 返回对象是否具有给定名称的属性或方法 getattr(object, str, default) attr 获取对象中指定的属性或方法，若该属性或方法不存在，则抛出AttributeError异常，若设置默认值，则在属性或方法不存在时返回默认值 setattr(object, str, any) None 设置对象中某一属性或方法的值 delattr(object, str) None 删除对象中某一指定属性或方法 issubclass(subClass, parentClass) bool 判定一个类是否是另一个类的子类 isinstance(instance, class) bool 判定一个对象是否是另一个类的实例 callable(object) bool 判定该对象是否可调用 示例演示 help(object)能够获取对象文档帮助信息。 返回None： >>> help(int) Help on class int in module builtins: class int(object) | int(x=0) -> integer | int(x, base=10) -> integer | | Convert a number or string to an integer, or return 0 if no arguments | are given. If x is a number, return x.__int__(). For floating point | numbers, this truncates towards zero. | | If x is not a number or if base is given, then x must be a string, | bytes, or bytearray instance representing an integer literal in the | given base. The literal can be preceded by '+' or '-' and be surrounded ... dir(object)能够获取对象下所有能被.操纵的属性与方法。 返回list： >>> dir(list) ['__add__', '__class__', '__contains__', '__delattr__', '__delitem__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__getitem__', '__gt__', '__hash__', '__iadd__', '__imul__', '__init__', '__init_subclass__', '__iter__', '__le__', '__len__', '__lt__', '__mul__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__reversed__', '__rmul__', '__setattr__', '__setitem__', '__sizeof__', '__str__', '__subclasshook__', 'append', 'clear', 'copy', 'count', 'extend', 'index', 'insert', 'pop', 'remove', 'reverse', 'sort'] hasattr(object, str)能够返回对象是否具有给定名称的属性或方法。 返回bool： >>> hasattr(list, \"index\") True >>> hasattr(list, \"items\") False getattr(object, str, default)能够获取对象中指定的属性或方法，若该属性或方法不存在，则抛出AttributeError异常，若设置默认值，则在属性或方法不存在时返回默认值： >>> method = getattr(list, \"index\") >>> method >>> method([1, 2, 3], 2) 1 setattr(object, str, any)能够设置对象中某一属性或方法的值。 返回None： >>> class A: ... pass ... >>> A.__doc__ None >>> setattr(A, \"__doc__\", \"help message\") >>> A.__doc__ help message delattr(object, str)能够删除对象中某一指定属性或方法。 返回None： >>> class A: ... classAttr = \"attr\" ... >>> A.classAttr 'attr' >>> delattr(A, \"classAttr\") >>> A.classAttr AttributeError: type object 'A' has no attribute 'classAttr' issubclass(subClass, parentClass)可以判定一个类是否是另一个类的子类。 返回bool： >>> issubclass(bool, int) True isinstance(instance, class)可以判定一个对象是否是另一个类的实例。 返回bool： >>> isinstance(1, bool) False >>> isinstance(True, bool) True 常用操作 当不确定对象中是否具有某一属性或方法时，可以使用hasattr()，getattr()以及callable()进行组合使用。 如下所示： import sys class YunPan: \"\"\" this is YunPan. You can specify start-up parameters on the command line. If the specified parameter is attribute, this property will be displayed. If the specified parameter is called, the method is performed The parameters you can specify now are: Help: Get help information The method you can specify is: Download: Test Download Features, Parameters -> Str UPLOAD: Test Upload Energy, Parameters -> Str Raises: TypeError: If there is no such method or attribute in the class, it will throw an exception. \"\"\" help = __doc__ def __init__(self) -> None: self.attrOrMethod = sys.argv[1] self.fileName = sys.argv[2] if len(sys.argv) > 2 else None self.choices() def download(self): print(\"downloading file : %s\"%self.fileName) def upload(self): print(\"uploading file : %s\"%self.fileName) def choices(self): if not hasattr(self, self.attrOrMethod): raise TypeError(\"%s not implement method or attributes:%s\"%(self.__class__.__name__, self.attrOrMethod)) attrOrMethod = getattr(self, self.attrOrMethod) if callable(attrOrMethod): return attrOrMethod() print(attrOrMethod) if __name__ == \"__main__\": YunPan() 测试结果： $ python3 .\\demo.py help this is YunPan. You can specify start-up parameters on the command line. If the specified parameter is attribute, this property will be displayed. If the specified parameter is called, the method is performed The parameters you can specify now are: Help: Get help information The method you can specify is: Download: Test Download Features, Parameters -> Str UPLOAD: Test Upload Energy, Parameters -> Str Raises: TypeError: If there is no such method or attribute in the class, it will throw an exception. $ python3 .\\demo.py download TestFile downloading file : TestFile $ python3 .\\demo.py upload TestFile uploading file : TestFile $ python3 .\\demo.py func .. TypeError: YunPan not implement method or attributes:func Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-11 14:47:11 "},"Python/Python面向对象/双下大全.html":{"url":"Python/Python面向对象/双下大全.html","title":"双下大全","keywords":"","body":"特殊的双下 在Python中有很多特殊的方法函数，如__init__()、__new__()等。 除此之外，也有很多特殊的属性变量，如__base__，__class__等。 这些属性变量或者方法函数经常被人称其为“魔法方法”，个人并不是很喜欢这种叫法。 我更喜欢称呼他们为双下方法或者双下属性，因为“魔法”一词总是带有玄幻的色彩，但在计算机领域中如果你觉得一个知识点过于玄幻，说明你并未真正的理解它。 言归正传，那么它们具体有什么作用呢？如下所示： 双下方法：在满足某一特定的条件下进行自动调用 双下属性：本身就含有一定的意义 本章节我们将先探讨双下方法，而后探讨双下属性。 双下方法 对象相关 __new__() 对象的构造方法，用于构建实例对象。 在类加括号时自动调用，创建并返回一个空的实例对象。 参数释义： cls：被实例化的类本身 args： 实例化类时传入的位置参数 kwargs： 实例化类时传入的关键字参数 返回值： object：实例化对象 应用场景： 实现单例模式，函数二次封装等 如下所示： class Category: def __new__(cls, *args, **kwargs) -> object: print(cls) print(args) print(kwargs) instanceObject = super(__class__, cls).__new__(cls) return instanceObject if __name__== \"__main__\": instance = Category(\"positionParams\", k=\"keyWordParams\") # # ('positionParams',) # {'k': 'keyWordParams'} __init__() 对象的初始化方法，用于构建实例对象，可以理解为为实例对象的__dict__填充内容。 在类加括号时自动调用，返回None： 参数释义： self：实例本身，也就是由__new__()创建出的空对象 返回值： None：该方法必须返回None 应用场景： 基本上适用于所有定义类的场景 如下所示： class Category: def __init__(self, params) -> None: self.k = params if __name__== \"__main__\": instance = Category(\"v\") print(instance.__dict__) # {'k': 'v'} __call__() 对象的调用方法，当对象后面加上括号时自动触发。 参数释义： self：实例本身，也就是由__new__()创建出的空对象 返回值： Any：任意值 应用场景： 它是内置函数callable()的判断依据，当callable(object)时，会判断object内部是否实现了该方法从而返回True或者False 如下所示，经过该方法实现，现在普通实例对象加括号会打印出其属性查找顺序： class Category: x = 1 def __call__(self): findList = list(self.__class__.__mro__) findList.insert(0, self) return tuple(findList) if __name__== \"__main__\": instance = Category() print(instance()) # (, , ) __del__() 对象的析构方法，当手动 del object 删除对象，或者在程序运行结束后自动触发。 参数释义： self：实例本身，也就是由__new__()创建出的空对象 返回值： None 应用场景： 用于关闭一些占据系统资源的操作，如文件资源，网络资源 如下所示： class Category: x = 1 def __del__(self): print(\"run ... __del__()\") if __name__== \"__main__\": instance = Category() del instance # run ... __del__() 示例，自定义文件操作类，可用于自动关闭文件： class OpenFile: def __init__(self, *args, **kwargs) -> None: self.__file = open(*args, **kwargs) def __getattr__(self, name:str): return getattr(self.__file, name) def __del__(self): print(\"auto file close\") self.__file.close() if __name__== \"__main__\": fileObject = OpenFile(file=\"./test.txt\", mode=\"rt\", encoding=\"utf8\") print(fileObject.read(32)) 属性操作 __getattribute__() 当要查找某一个属性或者方法时，都会触发该方法。 如要查找的属性或者方法存在，则返回该属性或方法。 否则抛出AttributeError的异常。 参数释义： self：实例本身，也就是 . 前面的对象 name：要查找的属性或方法 返回值： Any：要查找的方法或者属性 应用场景：自定义容器的方法查找，内置函数getattr()的底层其实就是该方法 如下所示： from typing import Any class Category: def __getattribute__(self, name: str) -> Any: print(\"run ..\") try: return super(__class__, self).__getattribute__(name) except AttributeError as e: return \"don't have attribute %s\" % name if __name__== \"__main__\": instance = Category() print(instance.x) # run .. # don't have attribute x __getattr__() 在对对象进行 . 操作试图获取对象下的某一属性或方法时而恰好该属性或方法不存在时自动触发。 若__getattribute__()与__getattr__()同时出现，则只会调用__getattribute__()。 参数释义： self：实例本身，也就是 . 前面的对象 name：要查找的属性或方法 返回值： Any：任意给定的值 应用场景：自定义类的方法借用，或者代理类 示例1，只定义了__getattr__()，它会在获取对象下的某一属性或方法不存在时触发： from typing import Any class Category: x = 1 def __getattr__(self, name: str) -> Any: print(\"run ..\") return \"%s not existing\" % name if __name__== \"__main__\": instance = Category() print(\"Find the existing properties and not call __getattr__()\") print(instance.x) print(\"Find the property that does not exist will call __getattr__()\") print(instance.y) # Find the existing properties and not call __getattr__() # 1 # Find the property that does not exist will call __getattr__() # run .. # y not existing 示例2，如果同时定义了__getattr__()和__getattribute__()则无论什么情况都不会触发__getattr__()： from typing import Any class Category: x = 1 def __getattribute__(self, name: str) -> Any: print(\"run __getattribute__()\") try: return super(Category, self).__getattribute__(name) except AttributeError as e: return \"don't have attribute %s\" % name def __getattr__(self, name: str) -> Any: print(\"run __getattr__()\") return \"%s not existing\" % name if __name__== \"__main__\": instance = Category() print(instance.x) print(instance.y) # run __getattribute__() # 1 # run __getattribute__() # don't have attribute y __setattr__() 在对对象进行 . 操作试图修改对象下的某一属性或方法时自动触发。 参数释义： self：实例本身，也就是 . 前面的对象 name：要设置的属性或方法 value：要为属性和方法设置的新值 返回值： None 应用场景：自定义代理类，内置函数setattr()的底层其实就是该方法 如下所示： from typing import Any class Category: x = 1 def __setattr__(self, name: str, value: Any) -> None: print(\"run .. __setattr__()\") self.__dict__[name] = value if __name__== \"__main__\": instance = Category() instance.y = \"newAttribute\" # run .. __setattr__() 一个容易被人忽视的地方，如果__setattr__()中设置成这样，则会引发无限递归，无数次调用自身： def __setattr__(self, name: str, value: Any) -> None: self.name = value __delattr__() 在对对象进行 . 操作试图删除对象下的某一属性或方法时自动触发。 参数释义： self：实例本身，也就是 . 前面的对象 name：要删除的属性或方法 返回值： None 应用场景：自定义不可变容器，内置函数delattr()的底层其实就是该方法 如下所示： class Category: x = 1 def __delattr__(self, name: str) -> None: print(\"run .. __delattr__()\") del self.__dict__[name] if __name__== \"__main__\": instance = Category() instance.attr = \"newAttr\" del instance.attr # run .. __delattr__() __getitem__() 在对对象进行 [] 操作试图获取对象下的某一对象属性或方法时自动触发。 除此之外，它也能代替__iter__()方法创建专属迭代器。 参数释义： self：实例本身，也就是 [] 前面的对象 name：要获取的属性或方法 返回值： None 应用场景：自定义映射容器，实现类似字典的操作 dict[k] 如下所示： from typing import Any class Category: x = 1 def __getitem__(self, name: str) -> Any: print(\"run .. __getitem__()\") return self.__dict__[name] if __name__== \"__main__\": instance = Category() instance.attr = \"newAttr\" print(instance[\"attr\"]) # run .. __getitem__() # newAttr 此外，如果类中实现了该方法，则该类的实例化对象就是可迭代对象： from typing import Any class Category: x = 1 def __getitem__(self, name: str) -> Any: print(\"run .. __getitem__()\") return self.__dict__[name] if __name__== \"__main__\": instance = Category() print(iter(instance)) # ❶ # ❶：即使该类没实现__iter__()，但是仍然可以创建专属迭代器 __setitem__() 在对对象进行 [] 操作试图修改对象下的某一对象属性或方法时自动触发。 参数释义： self：实例本身，也就是 [] 前面的对象 name：要设置的属性或方法 value：要为属性和方法设置的新值 返回值： None 应用场景：自定义映射容器，实现类似字典的操作 dict[k] = v 如下所示： from typing import Any class Category: x = 1 def __setitem__(self, name: str, value: Any) -> None: print(\"run .. __setitem__()\") self.__dict__[name] = value if __name__== \"__main__\": instance = Category() instance[\"y\"] = \"newAttr\" # run .. __setitem__() __delitem__() 在对对象进行 [] 操作试图删除对象下的某一对象属性或方法时自动触发。 参数释义： self：实例本身，也就是 [] 前面的对象 name：要删除的属性或方法 返回值： None 应用场景：自定义映射容器，实现类似字典的操作 del dict[k] 如下所示： class Category: x = 1 def __delitem__(self, name: str) -> None: print(\"run .. __delitem__()\") del self.__dict__[name] if __name__== \"__main__\": instance = Category() instance.attr = \"newAttr\" del instance[\"attr\"] # run .. __delitem__() 输出相关 __str__() print(object)时自动触发该方法。 参数释义： self：实例本身，也就是 . 前面的对象 返回值： 必须是str类型 应用场景：非常常用，如Django框架admin，models类中都会定义该方法进行数据项展示 如下所示： class Category: x = 1 def __str__(self) -> str: return \"it is class %s instance object\" % self.__class__.__name__ if __name__== \"__main__\": instance = Category() print(instance) # it is class Category instance object __repr__() 交互式环境下输入对象标识符，print(object)时自动触发该方法。 参数释义： self：实例本身，也就是 . 前面的对象 返回值： 必须是str类型 应用场景：与__str__()应用场景相当，但是比它要强大一点。 如果没有实现__str__()方法，则会在print(object)时使用该方法。 如下所示： class Category: x = 1 def __repr__(self) -> str: return \"it is class %s instance object\" % self.__class__.__name__ if __name__== \"__main__\": instance = Category() print(instance) # it is class Category instance object __format__() format(object)时自动触发该方法。 参数释义： self：实例本身，也就是 . 前面的对象 format_spec：模板{:}中:后面的值 返回值： 必须是str类型 应用场景：自定义时间类，格式化打印相关 如下所示： class Date: formatStyle = { \"ymd\": \"{0.year}:{0.month}:{0.day}\", \"dmy\": \"{0.day}/{0.month}/{0.year}\", \"mdy\": \"{0.month}-{0.day}-{0.year}\", } def __init__(self, year, month, day) -> None: self.year = year self.month = month self.day = day def __format__(self, format_spec: str) -> str: if format_spec is None or format_spec not in __class__.formatStyle: format_spec = \"ymd\" return __class__.formatStyle[format_spec].format(self) if __name__== \"__main__\": instance = Date(2011, 1, 23) print(format(instance)) print(\"{:mdy}\".format(instance)) # 2011:1:23 # 1-23-2011 组合套餐 __enter__()与__exit__() __enter__()与__exit__()方法可实现上下文管理协议。 使用with语句将自动触发__enter__()方法的执行。 with语句代码块执行完毕后或者with语句代码块执行过程中抛出异常都会自动触发__exit__()方法的执行。 上下文管理作用如下： 使用with语句的目的就是把代码块放入with中执行，with结束后，自动完成清理工作，无须手动干预 在需要管理一些资源比如文件，网络连接和锁的编程环境中，可以在__exit__()中定制自动释放资源的机制，你无须再去关心这个问题，这将大有用处 函数签名如下： def __enter__(self) -> object: pass def __exit__(self, exc_type, exc_val, exc_tab) -> bool: pass __enter__()方法说明： 参数释义： self：实例本身，也就是 . 前面的对象 返回值： 返回的对象会被as语句当做句柄接收 __exit__()方法说明： 参数释义： self：实例本身，也就是 . 前面的对象 exc_type：异常类型 exc_val：异常值 exc_tab：异常回溯信息 返回值： 如果返回False则代表立即抛出异常，如果返回True则代表捕获本次异常 示例演示，通过__new__()方法和上下文管理协议，实现文件类封装： class OpenFile: fileObject = None __doc__= open.__doc__ def __new__(cls, *args, **kwargs) -> object: cls.fileObject = open(*args, **kwargs) return cls.fileObject def __enter__(self): return __class__.fileObject def __exit__(exc_type, exc_val, exc_tab): __class__.fileObject.close() return False def __del__(self): __class__.fileObject.close() def __getattr__(self, name: str): return getattr(__class__.fileObject, name) if __name__== \"__main__\": with OpenFile(\"./test.txt\", mode=\"rt\", encoding=\"utf8\") as f: print(f.read()) print(help(OpenFile)) __iter__()与__next__() __iter__()与__next__()可实现迭代器协议。 具体参照迭代器一章节，这里不再具体演示。 容器相关 __len__() 当使用len(object)时将会自动执行该方法。 该方法应当返回int类型。 示例如下： class Category: x = 1 def __len__(self): return 100 if __name__== \"__main__\": instance = Category() print(len(instance)) # 100 __contains__() 当使用 item in object 时将会自动执行该方法。 该方法应当返回bool类型。 示例如下： class Category: x = 1 def __contains__(self, item): return True if __name__== \"__main__\": instance = Category() print(\"a\" in instance) # True 双下方法一览表 以上介绍的均是常见的双下方法，足以应付大部分使用场景。 下面是双下方法大全表： __new__(cls[, …]) ： 是在一个对象实例化的时候所调用的第一个方法，它的第一个参数是这个类，其他的参数是用来直接传递给 __init__方法。决定是否要使用该 __init__方法，因为 __new__可以调用其他类的构造方法或者直接返回别的实例对象来作为本类的实例，如果 __new__没有返回实例对象，则 __init__不会被调用。 __new__主要是用于继承一个不可变的类型比如一个 tuple 或者 string。 __init__(self[, …])： 构造器，当一个实例被创建的时候调用的初始化方法 __del__(self)： 析构器，当一个实例被销毁的时候调用的方法 __call__(self[, args…])： 允许一个类的实例像函数一样被调用：x(a, b) 调用 x.__call__(a, b) __len__(self)： 定义当被 len() 调用时的行为 __repr__(self)： 定义当被 repr() 调用时的行为 __str__(self)： 定义当被 str() 调用时的行为 __bytes__(self)： 定义当被 bytes() 调用时的行为 __hash__(self)： 定义当被 hash() 调用时的行为 __bool__(self)： 定义当被 bool() 调用时的行为，应该返回 True 或 False __format__(self, format_spec)： 定义当被 format() 调用时的行为 有关属性 __getattr__(self, name)： 定义当用户试图获取一个不存在的属性时的行为 __getattribute__(self, name)： 定义当该类的属性被访问时的行为 __setattr__(self, name, value)： 定义当一个属性被设置时的行为 __delattr__(self, name)： 定义当一个属性被删除时的行为 __dir__(self)： 定义当 dir() 被调用时的行为 __get__(self, instance, owner)： 定义当描述符的值被取得时的行为 __set__(self, instance, value)： 定义当描述符的值被改变时的行为 __delete__(self, instance)： 定义当描述符的值被删除时的行为 比较操作符 __lt__(self, other)： 定义小于号的行为：x y 调用 x.gt(y) __ge__(self, other) ： 定义大于等于号的行为：x >= y 调用 x.ge(y) 算数运算符 __add__(self, other)： 定义加法的行为：+ __sub__(self, other)： 定义减法的行为：- __mul__(self, other)： 定义乘法的行为：* __truediv__(self, other)： 定义真除法的行为：/ __floordiv__(self, other)： 定义整数除法的行为：// __mod__(self, other)： 定义取模算法的行为：% __divmod__(self, other)： 定义当被 divmod() 调用时的行为 __pow__(self, other[, modulo])： 定义当被 power() 调用或 ** 运算时的行为 __lshift__(self, other)： 定义按位左移位的行为：> __and__(self, other)： 定义按位与操作的行为：& __xor__(self, other)： 定义按位异或操作的行为：^ __or__(self, other)： 定义按位或操作的行为：| 反运算 __radd__(self, other)： （与上方相同，当左操作数不支持相应的操作时被调用） __rsub__(self, other) ： （与上方相同，当左操作数不支持相应的操作时被调用） __rmul__(self, other) ： （与上方相同，当左操作数不支持相应的操作时被调用） __rtruediv__(self, other)： （与上方相同，当左操作数不支持相应的操作时被调用） __rfloordiv__(self, other)： （与上方相同，当左操作数不支加粗样式持相应的操作时被调用） __rmod__(self, other)： （与上方相同，当左操作数不支持相应的操作时被调用） __rdivmod__(self, other)： （与上方相同，当左操作数不支持相应的操作时被调用） __rpow__(self, other)： （与上方相同，当左操作数不支持相应的操作时被调用） __rlshift__(self, other)： （与上方相同，当左操作数不支持相应的操作时被调用） __rrshift__(self, other)： （与上方相同，当左操作数不支持相应的操作时被调用） __rand__(self, other)： （与上方相同，当左操作数不支持相应的操作时被调用） __rxor__(self, other)： （与上方相同，当左操作数不支持相应的操作时被调用） __ror__(self, other)： （与上方相同，当左操作数不支持相应的操作时被调用） 增量赋值运算 __iadd__(self, other)： 定义赋值加法的行为：+= __isub__(self, other)： 定义赋值减法的行为：-= __imul__(self, other)： 定义赋值乘法的行为：*= __itruediv__(self, other)： 定义赋值真除法的行为：/= __ifloordiv__(self, other)： 定义赋值整数除法的行为：//= __imod__(self, other)： 定义赋值取模算法的行为：%= __ipow__(self, other[, modulo])： 定义赋值幂运算的行为：**= __ilshift__(self, other)： 定义赋值按位左移位的行为：>= __iand__(self, other)： 定义赋值按位与操作的行为：&= __ixor__(self, other)： 定义赋值按位异或操作的行为：^= __ior__(self, other)： 定义赋值按位或操作的行为：|= 一元操作符 __pos__(self)： 定义正号的行为：+x __neg__(self)： 定义负号的行为：-x __abs__(self)： 定义当被 abs() 调用时的行为 __invert__(self)： 定义按位求反的行为：~x 类型转换 __complex__(self)： 定义当被 complex() 调用时的行为（需要返回恰当的值） __int__(self)： 定义当被 int() 调用时的行为（需要返回恰当的值） __float__(self)： 定义当被 float() 调用时的行为（需要返回恰当的值） __round__(self[, n])： 定义当被 round() 调用时的行为（需要返回恰当的值） __index__(self)： 当对象是被应用在切片表达式中时，实现整形强制转换，若定义了一个可能在切片时用到的定制的数值型,应该定义 __index__，若 __index__被定义，则 __int__也需要被定义，且返回相同的值 上下文管理（with 语句） __enter__(self)： 定义当使用 with 语句时的初始化行为，返回值被 with 语句的目标或者 as 后的名字绑定 __exit__(self, exc_type, exc_value, traceback)： 定义当一个代码块被执行或者终止后上下文管理器应该做什么，一般被用来处理异常，清除工作或者做一些代码块执行完毕之后的日常工作 容器类型 __len__(self)： 定义当被 len() 调用时的行为（返回容器中元素的个数） __getitem__(self, key)： 定义获取容器中指定元素的行为，相当于 self[key] __setitem__(self, key, value)： 定义设置容器中指定元素的行为，相当于 self[key] = value __delitem__(self, key)： 定义删除容器中指定元素的行为，相当于 del self[key] __iter__(self)： 定义当迭代容器中的元素的行为 __reversed__(self)： 定义当被 reversed() 调用时的行为 __contains__(self, item)： 定义当使用成员测试运算符（in 或 not in）时的行为 双下属性 类的属性 __doc__ 类的帮助信息，使用help(class or instanceObject)时，将获得该信息。 class Category: __doc__ = \"hello magic attribute\" if __name__== \"__main__\": help(Category) # class Category(builtins.object) # | hello magic attribute # | # | Data descriptors defined here: # ... __dict__ 类或者实例对象的底层字典。 详情参见类与对象一章。 __slots__ __slots__可以代替__dict__作为类或者实例的属性存储容器。 它还能限制实例对象属性的增加，如下只允许实例对象具有name和age属性，当添加gender属性时抛出异常： class Category: __slots__ = (\"name\", \"age\") if __name__== \"__main__\": instance = Category() instance.name = \"Jack\" print(instance.name) instance.age = 18 print(instance.age) instance.gender = \"male\" # Jack # 18 # AttributeError: 'Category' object has no attribute 'gender' __class__ 在类中调用__class__获得类本身。 通过self.__class__获得实例化出self的类。 推荐使用它来获取类属性，在类中使用__class__.attr而不是className.attr，这样更加灵活。 __base__ 通过className.__base__可获得类的父类，返回父类对象。 详情参见继承一章。 __bases__ 通过className.__bases__可获得类的父类，返回父类对象元组。 详情参见继承一章。 __mro__ 通过className.__mro__可获得该类的属性查找顺序列表。 详情参见继承一章。 全局属性 __file__ 获取当前脚本文件路径： print( __file__ ) # /Users/yunya/PythonProject/demo.py __name__ 如果使用__class__.name，则获取当前类的名称，而不是返回类对象： print( None.__class__ ) print( None.__class__.__name__ ) # # NoneType 如果在全局使用__name__则会判断执行方式是脚本“main”还是模块“module”。 详情参见模块一章。 __all__ 定义模块中允许被import *导入的标识符。 详情参见模块一章。 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-11 20:06:44 "},"Python/Python面向对象/描述符类.html":{"url":"Python/Python面向对象/描述符类.html","title":"描述符类","keywords":"","body":"描述符类 我们在之前接触了代理属性@property装饰器，它其实就是一个描述符，本质上而言是一个新式类。 如果想自定义一个描述符类，则必须实现以下三种双下方法的任意一个或多个： __get__()：获取描述符类实例时，触发该方法 __set__()：设置描述符类实例时，触发该方法 __delete__()：删除描述符类实例时，触发该方法 于此同时还需要注意在定义描述符类时的2点细节： 描述符类本身应该定义成新式类，被代理的类也应该是新式类 必须把描述符实例定义成这个类的类属性，不能定义到__init__()中成为实例属性 简单的属性代理示例，如下所示： 当访问Category.name时，会触发Proxy.__get__()方法 当设置Category.name时，会触发Proxy.__set__()方法 当删除Category.name时，会触发Proxy.__delete__()方法： class Proxy: proxyName = None def __get__(self, instance, owner): # ❶ print(\"run ... Proxy.__get__()\") return __class__.proxyName def __set__(self, instance, value): # ❷ print(\"run ... Proxy.__set__()\") __class__.proxyName = value def __delete__(self, instance): # ❸ print(\"run ... Proxy.__delete__()\") del __class__.proxyName class Category: name = Proxy() if __name__== \"__main__\": ins = Category() ins.name = \"King Kong\" print(ins.name) del ins.name # run ... Proxy.__set__() # run ... Proxy.__get__() # King Kong # run ... Proxy.__delete__() ❶：instance即实例对象本身，就是外部的ins标识符指向的对象，owner即实例对象拥有者，就是Category类 ❷：instance即实例对象本身，就是外部的ins标识符指向的对象，value是新设置的值，即23行的King Kong ❸：instance即实例对象本身，就是外部的ins标识符指向的对象 描述符类的种类 描述符类可分为数据描述符类和非数据描述符类，如下所示： 数据描述符类：至少实现了__get__()和__set__()方法的类 非数据描述符类：只实现了__get__()方法的类 数据描述符类和非数据描述符类对实例对象属性查找极其重要，所以这里特别指出。 如下，定义一个数据描述符类： class Proxy: def __get__(self, instance, owner): print(\"run ... Proxy.__get__()\") return __class__.proxyName def __set__(self, instance, value): print(\"run ... Proxy.__set__()\") __class__.proxyName = value 如下，定义一个非数据描述符类： class Proxy: def __get__(self, instance, owner): print(\"run ... Proxy.__get__()\") return __class__.proxyName 代理属性设置优先级 现在有1个类（Category），它的类属性（name）被代理了，并且代理类（Proxy）中设置了__set__()方法，于此同时被代理类（Category）中也设置了__setattr__()方法。 当对Category的实例对象进行. 操作试图修改name时，会执行哪一个方法？ Category.__setattr__()的优先级是高于Proxy.__set__()的，故会执行Category.__setattr__()方法。 如下所示： class Proxy: proxyName = None def __get__(self, instance, owner): print(\"run ... Proxy.__get__()\") return __class__.proxyName def __set__(self, instance, value): print(\"run ... Proxy.__set__()\") __class__.proxyName = value def __delete__(self, instance): print(\"run ... Proxy.__delete__()\") del __class__.proxyName class Category: name = Proxy() def __setattr__(self, name, value): print(\"run ... Category.__setattr__()\") self.__dict__[name] = value if __name__ == \"__main__\": ins = Category() ins.name = \"King Kong\" # run ... Category.__setattr__() 如果被代理类（Category）没有实现__setattr__()方法，则修改被代理属性name时，会触发Proxy.__set__()方法的执行： class Proxy: proxyName = None def __get__(self, instance, owner): print(\"run ... Proxy.__get__()\") return __class__.proxyName def __set__(self, instance, value): print(\"run ... Proxy.__set__()\") __class__.proxyName = value def __delete__(self, instance): print(\"run ... Proxy.__delete__()\") del __class__.proxyName class Category: name = Proxy() if __name__ == \"__main__\": ins = Category() ins.name = \"King Kong\" # run ... Proxy.__set__() 代理属性查找优先级 当具有描述符类存在时，属性查找顺序不再是一味的从实例开始查找到类及其超类。 而是按照以下流程： object.__getattribute__() 数据描述符 实例对象__dict__ 非数据描述符 类即超类__dict__ 类即超类__getattr__() 整个流程如图下所示： 1）数据描述符的查找优先于实例属性 class Proxy: proxyName = None def __get__(self, instance, owner): print(\"run ... Proxy.__get__()\") return __class__.proxyName def __set__(self, instance, value): print(\"run ... Proxy.__set__()\") __class__.proxyName = value def __delete__(self, instance): print(\"run ... Proxy.__delete__()\") del __class__.proxyName class Category: name = Proxy() def __init__(self) -> None: self.name = \"Proxy.proxyName\" if __name__ == \"__main__\": ins = Category() print(ins.__dict__) print(ins.name) # run ... Proxy.__set__() # {} # run ... Proxy.__get__() # Proxy.proxyName ❶：self.name的时候，由于name本身是一个被数据描述符类代理的属性，且Category未实现__setattr__()故会执行Proxy.__set__()方法，现在Proxy.proxyName = “Proxy.proxyName” ❷：由于self.name操作触发了Proxy代理类的__set__()方法执行，故instance.__dict__中并未拥有任何实例属性 ❷：28行print()操作试图获取这个被数据描述符类代理的属性，故会执行Proxy.__get__()方法获取并返回Proxy.proxyName 2）实例属性的查找优先于非数据描述符 class Proxy: proxyName = None def __get__(self, instance, owner): print(\"run ... Proxy.__get__()\") return __class__.proxyName class Category: name = Proxy() def __init__(self) -> None: self.name = \"instance name\" # ❶ if __name__ == \"__main__\": ins = Category() print(ins.__dict__) print(ins.name) # {'name': 'instance name'} # instance name ❶：self.name的时候，由于name不是一个被数据描述符类代理的属性，故底层会执行object.__setattr__()方法，将name变更为实例属性存储至instance.__dict__中 3）实例属性的查找优先于类属性 class Category: name = \"class name\" def __init__(self) -> None: self.name = \"instance name\" if __name__ == \"__main__\": ins = Category() print(ins.__dict__) print(ins.name) # {'name': 'instance name'} # instance name 描述符类简单应用 众所周知，Python是动态语言，即参数的赋值没有类型限制，下面我们通过描述符机制来实现类型限制功能。 注意点：如果对传入值进行参数设置，其被描述符代理属性的类千万不要设置 __setattr__()，因为__setattr__()方法的优先级高于描述符的__get__()方法。 class Proxy: def __init__(self, key, expectedType) -> None: self.key = key self.expectedType = expectedType def __get__(self, instance, owner): if instance is None: # ❶ return self return instance.__dict__[self.key] def __set__(self, instance, value): if not isinstance(value, self.expectedType): raise TypeError(\"parameter type error, expected %s type %s, but you give type is %s\" % ( self.key, self.expectedType, type(value))) instance.__dict__[self.key] = value def __delete__(self, instance): del instance.__dict__[self.key] class Category: name = Proxy(\"name\", str) age = Proxy(\"age\", int) def __init__(self, name: str, age: int) -> None: self.name = name self.age = age if __name__ == \"__main__\": ins = Category(\"Jack\", 18) print(ins.name, type(ins.name)) print(ins.age, type(ins.age)) # Jack # 18 ❶：这个判断条件是针对使用Category.被代理属性，如果是这样直接返回Proxy实例即可 类装饰器 装饰器可以给类装饰 装饰器的本质就是将@decorator下面的可调用对象当做参数自动传入到装饰器中，类本身是可调用的，因此我们也可以给类的上面套一个装饰器。 类的无参装饰器： def warpper(object): object.attr = \"newAttr\" return object @warpper class Category: pass if __name__ == \"__main__\": print(Category.attr) # newAttr 类的有参装饰器： def warpper(**kwargs): def inner(object): for k, v in kwargs.items(): setattr(object, k, v) return object return inner @warpper(name=\"Category\", type=\"class\") class Category: pass if __name__ == \"__main__\": for k,v in Category.__dict__.items(): if not k.startswith(\"__\"): print(k, v) # name Category # type class 类也可以作为装饰器 一定要理解，装饰器的本质只是将@decorator下对象的引用传入至形参中，所以我们也可以将类作为装饰器： class Warpper: def __new__(cls, instanceClass) -> object: instanceClassObject = instanceClass(\"Jack\", 18, \"male\") return instanceClassObject @Warpper class Category: def __init__(self, name, age, gender) -> None: self.name = name self.age = age self.gender = gender if __name__ == \"__main__\": print(Category) print(Category.name) print(Category.age) print(Category.gender) # # Jack # 18 # male 在这个例子中，Category其实是Category的instance对象。 描述符与类装饰器应用 属性类型限制 我们在学习了类的装饰器后，已经可以将其与描述符类相结合，完成以下功能了。 1）通过给类添加有参装饰器实现动态添加类属性： def addClassAttribute(**kwargs): def inner(cls): for k, v in kwargs.items(): setattr(cls, k, v) return cls return inner @addClassAttribute(name=\"Jack\", age=18, gender=\"male\") class Person: pass if __name__ == \"__main__\": for k, v in Person.__dict__.items(): if not k.startswith(\"__\"): print(k, v) # name Jack # age 18 # gender male 2）通过给类添加有参装饰器以及配合数据描述符实现实例属性类型检测： class Proxy: def __init__(self, key, expectedType) -> None: self.key = key self.expectedType = expectedType def __get__(self, instance, owner): if instance is None: # ❶ return self return instance.__dict__[self.key] def __set__(self, instance, value): if not isinstance(value, self.expectedType): raise TypeError(\"parameter type error, expected %s type %s, but you give type is %s\" % ( self.key, self.expectedType, type(value))) instance.__dict__[self.key] = value def __delete__(self, instance): del instance.__dict__[self.key] def addClassAttribute(**kwargs): def inner(cls): for k, v in kwargs.items(): setattr(cls, k, Proxy(key=k, expectedType=v)) return cls return inner @addClassAttribute(name=str, age=int, gender=str) class Person: def __init__(self, name: str, age: int, gender: str) -> None: self.name = name self.age = age self.gender = gender if __name__ == \"__main__\": for k, v in Person.__dict__.items(): if not k.startswith(\"__\"): print(k, v) ins = Person(name=\"Jack\", age=\"19\", gender=1) # name # age # gender # TypeError: parameter type error, expected type , but you give type is ❶：这个判断条件是针对使用Person.被代理属性，如果是这样直接返回Proxy实例即可 自定义property @property本身是通过描述符类实现的，因此我们也可以自己实现: class Property: def __init__(self, method) -> None: self.method = method def __get__(self, instance, owner): if instance is None: # ❶ return self else: v = self.method(instance) # ❷ # instance.__dict__[self.method.__name__] = v # ❸ return v class Person: def __init__(self, name, height, weight): self.name = name self.height = height self.weight = weight @Property def bmi(self): v = self.weight / (self.height ** 2) if 20 25: return \"overweight\" return \"obesity\" if __name__ == \"__main__\": instanceObject = Person(\"ken\", height=1.76, weight=77) print(instanceObject.bmi) #　normal ❶：这个判断条件是针对使用Person.被代理属性的操作，如果是这样直接返回Proxy实例即可 ❷：手动的为self传递参数为instance ❸：这里是做一个缓存功能，将第一次求值结果存放至实例字典中。 如果要做缓存功能，则需要注意自定义的这个描述符种类必须是非数据描述符，因为数据描述符属性的查找顺序是在实例之前。 此外，如果添加上缓存功能，后续该实例的身高体重一旦发生改变，则会导致二次求值结果不准确，因此一般不做这个缓存 自定义classmethod @classmethod本身是通过描述符类实现的，因此我们也可以自己实现: class ClassMethod: def __init__(self, method) -> None: self.clsMethod = method def __get__(self, instance, owner): def inner(*args, **kwargs): return self.clsMethod(owner, *args, **kwargs) return inner class Person: desc = \"This is person class\" @ClassMethod def show(cls, x, y, z): print(x, y, z) print(cls.desc) if __name__ == \"__main__\": Person.show(1, 2, 3) # 1 2 3 # This is person class 自定义staticmethod @staticmethod本身是通过描述符类实现的，因此我们也可以自己实现： class StaticMethod: def __init__(self, method) -> None: self.staticMethod = method def __get__(self, instance, owner): def inner(*args, **kwargs): return self.staticMethod(*args, **kwargs) return inner class Person: @StaticMethod def show(x, y, z): print(x, y, z) if __name__ == \"__main__\": Person.show(1, 2, 3) # 1 2 3 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-12 12:48:28 "},"Python/Python面向对象/元类编程.html":{"url":"Python/Python面向对象/元类编程.html","title":"元类编程","keywords":"","body":"一切皆对象 函数是对象 Python中一切皆对象，故函数也是一个实例对象。 通过function.__class__，可以拿到创建出函数这个实例对象的类： >>> func = lambda : 1 >>> print(func.__class__) 我们还可以为函数实例对象增添实例属性，虽然没人会这样做： >>> func.attr = \"intance attribute\" >>> func.attr 'intance attribute' 类也是对象 由于一切皆对象的缘故，故类也是一个实例对象。 而创建出类这个实例对象的类，被称为元类（metaclass），Python中只有1个内置元类，为type。 如下示例，使用class.__class__即可拿到元类type： >>> int.__class__ >>> list.__class__ >>> class Category: pass >>> Category.__class__ 什么是元类 经过上面的例子，我们可以看见所有类都是由元类type类进行实例化而得到的。 故元类即为创造类的类，它的作用主要有2个： 用于生产出类对象 用于生产出类对象的实例对象 class定义内部机制 当我们使用class关键字定义一个类之后，底层的创建步骤大体可分为4步： 拿到类标识符 拿到类的基类 执行类体代码，创建类的命名空间 调用元类，默认为type类，得到实例化出的类对象 创建类不一定非要使用class关键字，也可以有其他形式，下面这个示例将重现上面4大步骤： # first step : get class name className = \"Person\" # second step : get class parent class and super class and bases classes classBasesClass = (object, ) # third step 1 : definition class __dict__ ， Now this is empty classDict = {} # third step 2 : get class body code , It is interpreted by Python is a string classBody = \"\"\" def __init__(self, name, age, gender): self.name = name self.age = age self.gender = gender def show(self): return \"name : %s age : %s gender : %s\"%(self.name, self.age, self.gender) \"\"\" # first param : class body code # second param : global name space # last param : class __dict__ , is class local name space exec(classBody, {}, classDict) # Now, class __dict__ have content, class initing end print(classDict) # last step # class name give global identifier Person Person = type(className, classBasesClass, classDict) if __name__ == \"__main__\": ins = Person(name=\"Jack\", age=18, gender=\"male\") print(ins.show()) 自定义元类 如何自定义元类 如果一个类继承了type类，那么他就是一个元类： class MetaClass(type): pass print(type(MetaClass)) # 元类如何生产出类对象 元类如何生成出一个类呢？实际上class ClassName后执行脚本时这一系列过程都是自动的。 在元类中会经历2大步骤： 调用元类自己的__new__()方法，构建出1个空的类对象 调用元类自己的__init__()方法，为空的类对象增添属性 详细的整体过程如图所示： 如下示例，我们如果要指定1个类的元类，则必须在其继承括号中添加上 metaclass = className 的字样： class MetaClass(type): def __new__(cls, *args, **kwargs) -> object: \"\"\" cls : meta class args : (class name, (class bases, ), { class __dict__ }) kwargs : empty dict Returns: object: meta class instance object \"\"\" # must transfer all params return super(__class__, cls).__new__(cls, *args, **kwargs) def __init__(self, *args, **kwargs) -> None: \"\"\" self : meta class instance object args : (class name, (class bases, ), { class __dict__ }) kwargs : empty dict Returns: None \"\"\" super(__class__, self).__init__(*args, **kwargs) class Person(object, metaclass=MetaClass): pass if __name__ == \"__main__\": pass 当解释器执行到25行时，会自动调用元类__new__()方法开始构造类对象。 元类如何生产出类的实例对象 一个普通的类如果创建实例对象，必定会使用className()的形式。 那么他底层会做什么事情呢？如下所示： 当className()时， 类自动调用元类下的_call\\_()方法 元类下的__call__()方法会自动调用类的__new__()方法，创建出一个空的实例化对象 元类下的__call__()方法会自动调用类的__init__()方法，为这个空实例化对象增添实例属性 元类下的__call__()方法将返回造好的这个实例化对象 如下所示： class MetaClass(type): # create cls object method : __new__() 、 __init__() def __new__(cls, *args, **kwargs) -> object: return super(__class__, cls).__new__(cls, *args, **kwargs) def __init__(self, *args, **kwargs) -> None: super(__class__, self).__init__(*args, **kwargs) # create cls instance obj method : __call__() def __call__(cls, *args, **kwargs) -> object: \"\"\" cls : meta class instance object args : cls instance position params kwargs : cls instance keyword params Returns : cls instance object \"\"\" clsInstanceObject = cls.__new__(cls, *args, **kwargs) cls.__init__(clsInstanceObject, *args, **kwargs) return clsInstanceObject class Person(object, metaclass=MetaClass): def __new__(cls, *args, **kwargs) -> object: return super(__class__, cls).__new__(cls) def __init__(self, name, age, gender) -> None: self.name = name self.age = age self.gender = gender if __name__ == \"__main__\": ins = Person(name=\"Jack\", age=18, gender=\"male\") 过程图示如下： 实例对象与类对象的属性查找 查找的区别 我们如果对ins加上括号，会不会调用元类的__call()__方法呢？ 答案是不会，实例对象和类对象的属性查找是不一样的，验证如下所示： class MetaClass(type): # create cls object method : __new__() 、 __init__() def __new__(cls, *args, **kwargs) -> object: return super(__class__, cls).__new__(cls, *args, **kwargs) def __init__(self, *args, **kwargs) -> None: super(__class__, self).__init__(*args, **kwargs) # create cls instance obj method : __call__() def __call__(cls, *args, **kwargs) -> object: clsInstanceObject = cls.__new__(cls, *args, **kwargs) cls.__init__(clsInstanceObject, *args, **kwargs) return clsInstanceObject class Person(object, metaclass=MetaClass): def __new__(cls, *args, **kwargs) -> object: return super(__class__, cls).__new__(cls) def __init__(self, name, age, gender) -> None: self.name = name self.age = age self.gender = gender if __name__ == \"__main__\": ins = Person(name=\"Jack\", age=18, gender=\"male\") ins() # TypeError: 'Person' object is not callable 类对象的属性查找顺序 类对象如果要进行属性查找，它会去父类、超类、object基类以及type元类中查找。 如图所示： 示例如下： class MetaClass(type): findAttr = \"MetaClass.attr\" class A: # findAttr = \"A.attr\" pass class B(A): # findAttr = \"B.attr\" pass class C(B, metaclass=MetaClass): # findAttr = \"C.attr\" pass if __name__ == \"__main__\": print(C.findAttr) 实例对象的属性查找顺序 类的实例对象如果要进行属性查找，它会去父类、超类、object基类中查找，不会去元类层。 如图所示： 示例如下： class MetaClass(type): findAttr = \"MetaClass.attr\" class A: findAttr = \"A.attr\" pass class B(A): # findAttr = \"B.attr\" pass class C(B, metaclass=MetaClass): # findAttr = \"C.attr\" pass if __name__ == \"__main__\": ins = C() print(ins.findAttr) 实例练习 类的命名规则检测 有了自定义元类，我们可以将自定义类的命名规定为必须大驼峰，否则抛出异常： class MetaClass(type): def __new__(cls, *args, **kwargs): if not args[0].istitle(): raise NameError(\"class %s name must upper\" % args[0]) super(__class__, cls).__new__(cls, *args, **kwargs) class category(metaclass=MetaClass): pass # NameError: class name must upper 类的文档信息检测 有了自定义元类，我们可以规定类必须书写文档信息，即__doc__，否则抛出异常： class MetaClass(type): def __new__(cls, *args, **kwargs): if \"__doc__\" not in args[-1] : raise SyntaxError(\"class %s must have help doc\" % args[0]) super(__class__, cls).__new__(cls, *args, **kwargs) class Category(metaclass=MetaClass): pass # SyntaxError: class Category must have help doc Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-12 15:56:18 "},"Python/Python面向对象/异常处理.html":{"url":"Python/Python面向对象/异常处理.html","title":"异常处理","keywords":"","body":"异常介绍 异常分类 　　程序中难免出现错误，总共可分为两种。 　　1.逻辑错误 　　2.语法错误 　　对于刚接触编程的人来说，这两个错误都会经常去犯，但是随着经验慢慢的积累，语法错误的情况会越来越少反而逻辑错误的情况会越来越多（因为工程量巨大）。 不论多么老道的程序员都不可避免出现这两种错误。 异常信息 　异常其实就是程序运行时发生错误的信号，我们写代码的过程中不可避免也最害怕的就是出现异常，然而当程序抛出异常时实际上会分为三部分，即三大信息。 常见异常 在Python中一切皆对象，异常本身也是由一个类生成的，NameError其实本身就是一个异常类，其他诸如此类的异常类还有很多，如下表所示。 异常类 描述 AttributeError 属性错误，被查找属性不存在 IOError IO错误，文件无法打开 ImportError 导包错误，导入模块或包时给定了错误的路径或导入了没有的功能 IndentaionError 缩进错误，代码没有正确对齐 KeyError 键错误，获取字典中不存在的键 NameError 标识符错误，试图使用一个未被赋值的标识符 SyntaxError 语法错误，代码写错了 TypeError 类型错误，传入对象的类型和预期不符 ValueError 值错误，传入一个调用者不期望的值，即使值的类型是正确的 AssertionError 断言异常 异常处理 我们可以来用某些方法进行异常捕捉，当出现异常时我们希望代码以另一种逻辑运行，使得我们的程序更加健壮，这个就叫做异常处理。 异常处理是非常重要的，本身也并不复杂，千万不可马虎大意，但是切记不可滥用异常处理，这会使得你的代码可读性变差。 if else处理异常 if和else本身就具有处理异常的功能，他们更多的是在我们能预测到可能出现异常的范围内进行规避异常，对于我们不能预测的异常来说就显得不是那么的好用。 如下所示，我们仅期待用户输入数字，如果是输入其他内容则会被其他逻辑所处理： while 1: choice = input(\"Please enter a digital string:\") if choice.isdigit(): print(\"success!!\") break else: print(\"You input not is a digital string!!\") try/except try和except是最常用的一种异常处理方式。 try：代表要检测可能出现异常的代码块 except：当特定异常出现后的处理情况 执行流程如下： try中检测的代码块 如果有异常 执行except代码块 执行正常逻辑 执行完毕 try中检测的代码块 如果无异常 执行完try中代码快 执行正常逻辑 执行完毕 如图所示： 示例如下，try中未抛出异常： lst = [i for i in range(3)] try: print(\"run try\") print(lst[2]) except IndexError as e: print(\"run except\") print(\"normal code\") # run try # 2 # normal code 示例如下，try中抛出异常： lst = [i for i in range(3)] try: print(\"run try\") print(lst[3]) except IndexError as e: print(\"run except\") print(\"normal code\") # run try # run except # normal code 多段except捕捉多异常 使用1个try和多个except来捕捉多种可能出现的异常： lst = [i for i in range(3)] dic = dict.fromkeys((chr(i) for i in range(65, 68)), None) try: print(lst[2]) print(dic[\"D\"]) except IndexError as e: print(\"index error %s \" % e) except KeyError as e: print(\"key error %s\" % e) print(\"normal code\") # 2 # key error 'D' # normal code 元组捕获多异常 使用多段except处理多异常会显得麻烦，可以使用except (error1, error2)来处理多个异常。 但是多个异常只有1个处理结果，故处理逻辑可能会写的比较麻烦： lst = [i for i in range(3)] dic = dict.fromkeys((chr(i) for i in range(65, 68)), None) try: print(lst[2]) print(dic[\"D\"]) except (IndexError, KeyError) as e: if isinstance(e, IndexError): print(\"index error %s\" % e) elif isinstance(e, KeyError): print(\"key error %s\" % e) print(\"normal code\") # 2 # key error 'D' # normal code except捕获万能异常 使用except Exception来捕捉所有可能出现的异常，Exception是所有异常的基类。 Exception类的父类则是BaseException类，而BaseException的父类则是object类 lst = [i for i in range(3)] dic = dict.fromkeys((chr(i) for i in range(65, 68)), None) try: print(lst[2]) print(dic[\"D\"]) except Exception as e: if isinstance(e, IndexError): print(\"index error %s\" % e) elif isinstance(e, KeyError): print(\"key error %s\" % e) print(\"normal code\") # 2 # key error 'D' # normal code try/except/esle else代表没有异常发生的情况下执行的代码，如下图所示： 如下示例： lst = [i for i in range(3)] dic = dict.fromkeys((chr(i) for i in range(65, 68)), None) try: print(lst[2]) print(dic[\"A\"]) except Exception as e: if isinstance(e, IndexError): print(\"index error %s\" % e) elif isinstance(e, KeyError): print(\"key error %s\" % e) else: print(\"don't have throw an exception\") print(\"normal code\") # 2 # None # don't have throw an exception # normal code try/except/else/finally finally代表不论抛异常与否都会执行，因此常被用作关闭系统资源的操作。 如下图所示： 如下示例： lst = [i for i in range(3)] dic = dict.fromkeys((chr(i) for i in range(65, 68)), None) try: print(lst[2]) print(dic[\"A\"]) except Exception as e: if isinstance(e, IndexError): print(\"index error %s\" % e) elif isinstance(e, KeyError): print(\"key error %s\" % e) else: print(\"don't have throw an exception\") finally: print(\"last run this\") print(\"normal code\") # 2 # None # don't have throw an exception # last run this # normal code 主动抛出异常 在某些时候我们可能需要主动的去阻止程序的运行，主动的抛出一个异常。 以防止逻辑越错越远。 raise raise可以主动的抛出一个异常，如下所示： lst = [i for i in range(3)] l = input(\"please input %s length >>>\" % lst) if not l.isdigit(): raise TypeError(\"you must input number\") if int(l) != len(lst): raise ValueError(\"your length input error, he length is not %s\" % l) if int(l) == len(lst): print(\"success!!\") assert 断言内部会进行if判断，如果判断结果为False则抛出AssertionError异常，如果为True就不抛出AssertionError异常。 如下所示： lst = [i for i in range(3)] l = input(\"please input %s length >>>\" % lst) assert l.isdigit(), \"you must input number\" assert int(l) == len(lst), \"your length input error, he length is not %s\" % l print(\"success!!\") 自定义异常 前面已经说过一切皆对象，异常也来自一个对象，所以我们可以自定义一个异常，只需要继承BaseException类即可。 如下示例，内置异常没有InputTypeError，我们来自己定义一个： class InputTypeError(BaseException): pass lst = [i for i in range(3)] l = input(\"please input %s length >>>\" % lst) if not l.isdigit(): raise InputTypeError(\"you must input number\") if int(l) != len(lst): raise ValueError(\"your length input error, he length is not %s\" % l) if int(l) == len(lst): print(\"success!!\") Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-12 19:00:41 "},"Python/Python数算基础/summary.html":{"url":"Python/Python数算基础/summary.html","title":"Python数算基础","keywords":"","body":"Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-05-12 13:02:58 "},"Python/Python设计模式/summary.html":{"url":"Python/Python设计模式/summary.html","title":"Python设计模式","keywords":"","body":"Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-05-12 13:02:58 "},"Python/Python设计模式/普通工厂模式.html":{"url":"Python/Python设计模式/普通工厂模式.html","title":"普通工厂模式","keywords":"","body":"普通工厂模式 Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-06-09 12:22:19 "},"Python/Python网络编程/summary.html":{"url":"Python/Python网络编程/summary.html","title":"Python网络编程","keywords":"","body":"Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-05-12 13:02:58 "},"Python/Python并发编程/summary.html":{"url":"Python/Python并发编程/summary.html","title":"Python并发编程","keywords":"","body":"Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-05-12 13:02:58 "},"Python/Python驱动程序/summary.html":{"url":"Python/Python驱动程序/summary.html","title":"Python驱动程序","keywords":"","body":"Copyright © 云崖先生 2016 all right reserved，powered by Gitbook该文件修订时间： 2021-05-12 16:48:48 "}}