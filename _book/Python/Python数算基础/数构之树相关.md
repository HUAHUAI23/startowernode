# 树的知识

## 什么是树

树是一种基本的非线性数据结构，在操作系统、图形学、数据库系统、计算机网络等领域被广泛使用。

跟自然界中的树一样，数据结构树也分为：根、枝、叶三个部分，一般数据结构的图示会把根放在上方，叶放在下方，就像一颗倒置的树，如下示例：

<img src="https://images-1302522496.cos.ap-nanjing.myqcloud.com/img/image-20210423175442117.png" alt="image-20210423175442117" style="zoom:90%;" />

## 相关术语

### 节点(node)

节点是组成树的基本部分，每个节点具有不同的名称或“键值”属性。

除此之外，节点还可以保存额外数据项，数据项根据不同的应用而变化。

<img src="https://images-1302522496.cos.ap-nanjing.myqcloud.com/img/image-20210423183240968.png" alt="image-20210423183240968" style="zoom:80%;" />



### 边(edge)

边是组成树的另一个基本部分，每条边恰好连接两个节点，表示节点之间具有关联。

除此之外，边还具有出入方向：

- 每个节点（除根节点）恰好有一条来自另一节点的入边。


- 每个节点可以有多条连到其它节点的出边。


<img src="https://images-1302522496.cos.ap-nanjing.myqcloud.com/img/image-20210423183637054.png" alt="image-20210423183637054" style="zoom:80%;" />



### 根(root)

根是树中唯一一个没有入边的节点，即最顶端的节点。

<img src="https://images-1302522496.cos.ap-nanjing.myqcloud.com/img/image-20210423183100473.png" alt="image-20210423183100473" style="zoom:80%;" />

### 路径(path)

路径是由边依次连接在一起的节点组成的有序列表，如：HTML->BODY->UL->LI就是一条路径。

<img src="https://images-1302522496.cos.ap-nanjing.myqcloud.com/img/image-20210423183853742.png" alt="image-20210423183853742" style="zoom:80%;" />



### 子节点(children)

入边均来自于同一个节点的若干节点，称为这个节点的子节点。

<img src="https://images-1302522496.cos.ap-nanjing.myqcloud.com/img/image-20210423182947004.png" alt="image-20210423182947004" style="zoom:80%;" />



### 父节点(parent)

一个节点是其所有出边所连接节点的父节点。

<img src="https://images-1302522496.cos.ap-nanjing.myqcloud.com/img/image-20210423182906981.png" alt="image-20210423182906981" style="zoom:80%;" />



### 兄弟节点(sibling)

具有同一个父节点的节点之间称为兄弟节点.

<img src="https://images-1302522496.cos.ap-nanjing.myqcloud.com/img/image-20210423182758607.png" alt="image-20210423182758607" style="zoom:80%;" />



### 子树(subtree)

子树是一个节点和其所有子孙节点，以及相关边的集合。

一个树中有多个子树，每个子树是独立的一颗树。

<img src="https://images-1302522496.cos.ap-nanjing.myqcloud.com/img/image-20210423181607109.png" alt="image-20210423181607109" style="zoom:80%;" />



### 叶子节点(leaf)

没有子节点的节点称为叶节点。

<img src="https://images-1302522496.cos.ap-nanjing.myqcloud.com/img/image-20210423182646416.png" alt="image-20210423182646416" style="zoom:80%;" />



### 层级(level)

根节点开始到达一个节点的路径，所包含的边的数量，称为这个节点的层级。

Root从0开始计数，也可以从1开始计数：

<img src="https://images-1302522496.cos.ap-nanjing.myqcloud.com/img/image-20210423182551238.png" alt="image-20210423182551238" style="zoom:80%;" />



### 高度(height)

树中所有节点的最大层级称为树的高度。

如下图树的高度为2：

<img src="https://images-1302522496.cos.ap-nanjing.myqcloud.com/img/image-20210423182307745.png" alt="image-20210423182307745" style="zoom:80%;" />



### 度(degree)

一个枝的度代表它有几条出边，而一颗树的度则取决于树中节点的最大度。

如，一颗树中最大的度为2，这可树可被称为二叉树，除此之外还有三叉、四叉树等结构。

如下图，这是一颗三叉树：

<img src="https://images-1302522496.cos.ap-nanjing.myqcloud.com/img/image-20210425141745353.png" alt="image-20210425141745353" style="zoom:80%;" />



# 认识二叉树

## 普通二叉树

普通的二叉树没什么要求，树的最大度为2即可。

![image-20210621164133152](https://images-1302522496.cos.ap-nanjing.myqcloud.com/img/image-20210621164133152.png)



## 完全二叉树

在完全二叉树中，枝节点必须全部是满的，叶子节点可以不满。

但是新的节点添加时必须从左至右依次添加，不能先添加右边后添加左边。

![image-20210621163836955](https://images-1302522496.cos.ap-nanjing.myqcloud.com/img/image-20210621163836955.png)

## 平衡二叉树

树的左右子树高度差不超过1的树被称为平衡二叉树，空树也是平衡二叉树的一种。

![image-20210621165147344](https://images-1302522496.cos.ap-nanjing.myqcloud.com/img/image-20210621165147344.png)



## 满二叉树

满二叉树的意思就是无论是枝节点还是叶子节点，必须全部都是满的。

![image-20210621165624388](https://images-1302522496.cos.ap-nanjing.myqcloud.com/img/image-20210621165624388.png)

# 二叉树表示

## 列表表示法

在Python中，我们可以使用多维的列表来表示一颗不确定度的多叉树。

这样的做法有一个好处，每一个列表都是一颗子树，索引值1是左子树，索引值2是右子树。

同时，如果要增加某个节点的度，则向其添加一个空列表即可。

![image-20210621142201732](https://images-1302522496.cos.ap-nanjing.myqcloud.com/img/image-20210621142201732.png)

如上述这幅图的二叉树，则可以向下面这样进行表示：

- 第1个元素为根节点的值
- 第2个元素是左子树（所以也是一个列表）
- 第3个元素是右子树（所以也是一个列表）

```
[root, [left], [right]]
-----------------------
   0      1       2
```

如下所示：

```
myTree = \
    [
        "a",
        ["b",
         ["d", [], []],
         ["e", [], []]
         ],
        ["c", 
         ["f"]
         ]
    ]
```

拿到第二层的叶子节点f：

```
print(myTree[2][1])
```



## 节点表示法

使用节点表示法，能够更加清晰的管理树，这比列表表示法通常更加省力。

如下图所示：

![image-20210621142742404](https://images-1302522496.cos.ap-nanjing.myqcloud.com/img/image-20210621142742404.png)



以下是代码实现上图中二叉树的表现：

```
class BinaryTree:
    def __init__(self, root):
        self.key = root
        self.leftChild = None
        self.rightChild = None
        self.height = 0

    def insertLeft(self, newNode):
        tree = BinaryTree(newNode)
        if not self.leftChild:
            self.leftChild = tree
        else:
            # 如果插入位置已有节点，则整体向下挪
            # 新的子节点与旧的子节点链接，旧的父节点与新的子节点链接
            tree.leftChild = self.leftChild
            self.leftChild = tree
        self.height += 1

    def insertRight(self, newNode):
        tree = BinaryTree(newNode)
        if not self.rightChild:
            self.rightChild = tree
        else:
            tree.rightChild = self.rightChild
            self.rightChild = tree
        self.height += 1

    def getRightChild(self):
        return self.rightChild

    def getLeftChild(self):
        return self.leftChild

    def setRootVal(self, obj):
        self.key = obj

    def getRootVal(self):
        return self.key

if __name__ == '__main__':
    binaryTree = BinaryTree("a")
    binaryTree.insertLeft("b")
    binaryTree.insertRight("c")
    binaryTree.leftChild.insertLeft("d")
    binaryTree.leftChild.insertRight("e")
    binaryTree.rightChild.insertLeft("f")
```



# 二叉树遍历

将一颗二叉树依次排开，如下所示：

- 根节点在中间
- 左节点在左边
- 右节点在右边

<img src="https://images-1302522496.cos.ap-nanjing.myqcloud.com/img/image-20210425155317927.png" alt="image-20210425155317927" style="zoom:80%;" />

那么就会有不同的4种遍历规则。

- 前序遍历（preorder）
- 中序遍历（inorder）
- 后序遍历（postorder）
- 层级遍历（levelorder）

我们可以在BinaryTree中新增几个实例方法，用来书写不同的遍历代码：

```
class BinaryTree:
    ...

    def preOrder(self):
        pass

    def inOrder(self):
        pass

    def postOrder(self):
        pass

    def levelOrder(self):
        pass
```





## 前序遍历(pre order)

前序遍历规则如下：

- 首先访问根节点
- 前序访问左子树
- 前序访问右子树

一句话总结：中左右

遍历顺序：

<img src="https://images-1302522496.cos.ap-nanjing.myqcloud.com/img/image-20210425155546095.png" alt="image-20210425155546095" style="zoom:80%;" />

代码实现：

```
    def preOrder(self):
        def inner(tree):
            if tree:
                print(tree.getRootVal())
                inner(tree.getLeftChild())
                inner(tree.getRightChild())
        inner(self)
```



## 中序遍历(in order)

中序遍历规则如下：

- 中序访问左子树
- 然后访问根节点
- 中序访问右子树

一句话总结：左中右

遍历顺序：

<img src="https://images-1302522496.cos.ap-nanjing.myqcloud.com/img/image-20210425155745841.png" alt="image-20210425155745841" style="zoom:80%;" />

代码实现：

```
    def inOrder(self):
        def inner(tree):
            if tree:
                inner(tree.getLeftChild())
                print(tree.getRootVal())
                inner(tree.getRightChild())
        inner(self)
```



## 后序遍历(post order)

后序遍历规则如下：

- 后序访问左子树
- 后序访问右子树
- 最后访问根节点

一句话总结：左右中

遍历顺序：

<img src="https://images-1302522496.cos.ap-nanjing.myqcloud.com/img/image-20210425155914157.png" alt="image-20210425155914157" style="zoom:80%;" />

代码实现：

```
    def postOrder(self):
        def inner(tree):
            if tree:
                inner(tree.getLeftChild())
                inner(tree.getRightChild())
                print(tree.getRootVal())
        inner(self)
```



## 层级遍历(level order)

层级遍历没什么好说的，按层访问：

- 第0层、根
- 第1层、左、右
- …第n层、左、右

遍历顺序：

<img src="https://images-1302522496.cos.ap-nanjing.myqcloud.com/img/image-20210425160204961.png" alt="image-20210425160204961" style="zoom:80%;" />

代码实现，需要借助一个双端队列或者列表：

```
    def levelOrder(self):
        def inner(tree):
            treeLst = []
            treeLst.append(tree)
            while len(treeLst) > 0:
                node = treeLst.pop(0)
                print(node.getRootVal())
                if node.leftChild:
                    treeLst.append(node.getLeftChild())
                if node.rightChild:
                    treeLst.append(node.getRightChild())
        inner(self)
```



## 根据遍历画出树

如果给出你2个遍历结果，并且指明这棵树是二叉树，如何画出这棵树的结构？

- 前序遍历顺序是 A B C D E F G
- 中序遍历顺序是 C B D A F E G

 首先，前序遍历是中左右，中序遍历是左中右，按照下面的结构开始进行结构划分：

```
前序： [A] [B C D] [E F G]
中序： [C B D] [A] [F E G]
```

划分完成之后就可以出图了：

<img src="https://images-1302522496.cos.ap-nanjing.myqcloud.com/img/image-20210425162554727.png" alt="image-20210425162554727" style="zoom:80%;" />

<img src="https://images-1302522496.cos.ap-nanjing.myqcloud.com/img/image-20210425162554727-20210621171456950.png" alt="image-20210425162554727" style="zoom:80%;" />





# 二叉堆

## 什么是二叉堆

二叉堆是二叉树的一种特殊结构，二叉堆必须是完全二叉树或者近似完全二叉树，可分为大根堆和小根堆。

- 小根堆（小顶堆）：任意一个节点都比其孩子节点小
- 大根堆（大顶堆）：任意一个节点都比其孩子节点大

图示如下：

![image-20210425181114475](https://images-1302522496.cos.ap-nanjing.myqcloud.com/img/image-20210425181114475.png)

## 二叉堆的表示

使用列表来表示二叉堆的时候，不需要利用多维列表，单纯的一维列表足以。

因为二叉堆必须是完全二叉树或者近似完全二叉树，所以整个树是平衡的，可以用列表来进行表示。

```
[1, 2, 3, 4, 5, 6, 7]
```

如果要查找任意节点的左子节点与右子节点，可以使用 2*p* 与 2*p*+1 来查找，如果想查找其父节点，可以使用 n // 2 的方式。

如上述列表表示了一个小根堆，我们要寻找3的左子节点与右子节点及父节点，流程如下：

```
Node 3 Position: 3  # 不要按照索引计算，正确计算是索引值+1
Left Child Node Position: 3 * 2 = 6
Right Child Node Position: 3 * 2 + 1 = 7
Parent Node Position: 3 // 2 = 1
```



## 堆排序(Heap Sort)

由于堆只有大根堆和小根堆，为了满足其中的特性，我们必须将一些节点进行值的比对然后上浮或者下沉。

如下图所示，展示了一个大根堆的排序过程：

![常见排序算法导读(8)[堆排序] - veli - 博客园](https://images-1302522496.cos.ap-nanjing.myqcloud.com/img/1094457-20170324104329049-488250498.gif)

时间复杂度为O(n log n)，空间复杂度为O(1)。

实现思路：

1. 构造初始堆，将给定无序序列构造成一个大根堆（排序时一般大根堆为升序，小根堆为降序）
2. 将堆顶元素与末尾元素进行交换，使末尾元素最大。然后继续调整堆，再将堆顶元素与末尾元素交换，得到第二大元素；
3. 重新调整结构，使其满足堆定义，然后继续交换堆顶元素与当前末尾元素；
4. 如此反复进行交换、重建、交换，直到整个序列有序。

代码实现如下，这是一个大根堆：

```
def build(seq, root, end):
    while True:
        # 左子节点的位置
        child = 2 * root + 1
        # 若左子节点超过了最后一个节点，则终止循环
        if child > end:
            break
        # 若右子节点在最后一个节点之前，并且右子节点比左子节点大，则我们的孩子指针移到右子节点上
        if (child + 1 <= end) and (seq[child + 1] > seq[child]):
            child += 1
        # 若最大的孩子节点大于根节点，则交换两者顺序，并且将根节点指针，移到这个孩子节点上
        if seq[child] > seq[root]:
            seq[child], seq[root] = seq[root], seq[child]
            root = child
        else:
            break


def heapSort(seq):
    n = len(seq)
    # 确认最深最后的那个根节点的位置
    first_root = n // 2 - 1
    # 由后向前遍历所有的根节点，建堆并进行调整
    for root in range(first_root, -1, -1):
        build(seq, root, n - 1)

    # 调整完成后，将堆顶的根节点与堆内最后一个元素调换位置，此时为数组中最大的元素，然后重新调整堆，将最大的元素冒到堆顶。依次重复上述操作
    for end in range(n - 1, 0, -1):
        seq[0], seq[end] = seq[end], seq[0]
        build(seq, 0, end - 1)


if __name__ == '__main__':
    lst = [7, 3, 2, 4, 1, 5]
    heapSort(lst)
    print(lst)

```



## ADT BinHeap

如果要使用Python来进行二叉堆实现，同时应当提供以下方法。

这样做的好处是所有的入堆出堆操作时间复杂度均为O(n log n)，我们可以用二叉堆来模拟实现类似优先级队列的数据结构。

| 方法名       | 描述                                                 |
| ------------ | ---------------------------------------------------- |
| BinaryHeap() | 一个类，用于构建一个空的二叉堆对象                   |
| insert()     | 将新key加入到堆中                                    |
| findMin()    | 返回堆中的最小项，最小项仍保留在堆中，堆本身不会改变 |
| delMin()     | 返回堆中的最小项，同时从堆中删除，堆本身会改变       |
| isEmpty()    | 返回堆是否为空                                       |
| size()       | 返回堆中key的个数                                    |
| buildHeap()  | 从一个key列表创建新堆                                |

现在准备实现一个小根堆，用一个列表来保存堆数据，其中列首下标为0的项无用，但是节点的左右子节点查找是根据 2*p* 与 *2*p+1 来计算的，因此我们可以用这个0来做一个占位，使索引与p相同，而不是从0开始计数，所以选择保留它：

```
class BinHeap:
    def __init__(self):
        self.heapList = [0]
        self.currentSize = 0
```

insert()方法的实现，一定要满足完全二叉树的性质，因此我们可以将新的key添加到列表末尾，同时使用堆排序来将该key上浮或者到合适的位置，实现有序的特性。

![image-20210425194158723](https://images-1302522496.cos.ap-nanjing.myqcloud.com/img/image-20210425194158723.png)

```
    def percUp(self, i):
        # 判断父节点是否存在，由于现在新添加的元素
        # 索引+1了，直接进行整除即可
        while i // 2 > 0:
            # 如果新元素小于父节点，则上浮，交换位置
            if self.heapList[i] < self.heapList[i // 2]:
                # 临时保留父节点的元素信息
                temp = self.heapList[i // 2]
                self.heapList[i // 2] = self.heapList[i]
                self.heapList[i] = temp
            # 继续和下一个父节点做比较
            i = i // 2

    def insert(self, k):
        self.heapList.append(k)
        # 现在的currentSize不仅仅是堆中节点的数量总和
        # 更是新key的查找定位位置，也是索引位置
        self.currentSize += 1
        self.percUp(self.currentSize)
```

delMin()方法的实现要移走整个堆中最小的key，由于我们实现的是小根堆，所以最小的元素都在堆顶。

如果直接简单粗暴的移走堆顶root，用那个元素来顶替好呢？

实际上，我们可以采用将堆底，即列表最后一个元素放到堆顶再向下沉的策略来进行该方法的构建。

![image-20210621173759918](https://images-1302522496.cos.ap-nanjing.myqcloud.com/img/image-20210621173759918.png)

```
 def percDown(self, i):
        # 如果没有左子节点，则代表整个列表就1个元素，不是一个堆
        # 就不向下执行
        while (i * 2) <= self.currentSize:
            # 拿出最小的左子节点
            mc = self.minChild(i)
            if self.heapList[i] > self.heapList[mc]:
                # 临时保留root节点的元素信息
                temp = self.heapList[i]
                self.heapList[i] = self.heapList[mc]
                self.heapList[mc] = temp
            i = mc

    def minChild(self, i):
        # 先判断右子节点，是否大于当前的堆顶元素
        if i * 2 + 1 > self.currentSize:
            return i * 2
        # 不大于
        else:
            # 判断左子节点，是否小于右子节点
            if self.heapList[i * 2] < self.heapList[i * 2 + 1]:
                return i * 2
            # 如果左子节点大于右子节点
            else:
                return i * 2 + 1

    def delMin(self):
        # 移除第一个元素
        retVal = self.heapList[1]
        # 最后一个元素放到堆顶
        self.heapList[1] = self.heapList[-1]
        # 堆中元素减去1个
        self.currentSize -= 1
        # 删除最后一个元素
        self.heapList.pop()
        # 传入当前堆顶的位置，开始进行调整
        self.percDown(1)
        return retVal
```

其他方法的实现：

```
    def buildHeap(self, li):
        # 一颗树的总长度+1整除2，会得到该树的root节点+枝节点
        # 忽略掉了叶子节点
        i = len(li) // 2
        # 重新定义长度
        self.currentSize = len(li)
        # 重新赋值
        self.heapList = [0] + li
        # 从最后一个元素开始，进行排序
        while i > 0:
            self.percDown(i)
            i -= 1

    def findMin(self):
        return self.heapList[1]

    def isEmpty(self):
        return not self.heapList

    def size(self):
        return self.__len__()

    def __len__(self):
        return len(self.heapList) - 1

    def __str__(self):
        return str(self.heapList[1:])

    def __contains__(self, item):
        return item in self.heapList
```

完整代码：

```
class BinHeap:
    def __init__(self):
        self.heapList = [0]
        self.currentSize = 0

    def percUp(self, i):
        # 判断父节点是否存在，由于现在新添加的元素
        # 索引+1了，直接进行整除即可
        while i // 2 > 0:
            # 如果新元素小于父节点，则上浮，交换位置
            if self.heapList[i] < self.heapList[i // 2]:
                # 临时保留父节点的元素信息
                temp = self.heapList[i // 2]
                self.heapList[i // 2] = self.heapList[i]
                self.heapList[i] = temp
            # 继续和下一个父节点做比较
            i = i // 2

    def insert(self, k):
        self.heapList.append(k)
        # 现在的currentSize不仅仅是堆中节点的数量总和
        # 更是新key的查找定位位置，也是索引位置
        self.currentSize += 1
        self.percUp(self.currentSize)

    def percDown(self, i):
        # 如果没有左子节点，则代表整个列表就1个元素，不是一个堆
        # 就不向下执行
        while (i * 2) <= self.currentSize:
            # 拿出最小的左子节点
            mc = self.minChild(i)
            if self.heapList[i] > self.heapList[mc]:
                # 临时保留root节点的元素信息
                temp = self.heapList[i]
                self.heapList[i] = self.heapList[mc]
                self.heapList[mc] = temp
            i = mc

    def minChild(self, i):
        # 先判断右子节点，是否大于当前的堆顶元素
        if i * 2 + 1 > self.currentSize:
            return i * 2
        # 不大于
        else:
            # 判断左子节点，是否小于右子节点
            if self.heapList[i * 2] < self.heapList[i * 2 + 1]:
                return i * 2
            # 如果左子节点大于右子节点
            else:
                return i * 2 + 1

    def delMin(self):
        # 移除第一个元素
        retVal = self.heapList[1]
        # 最后一个元素放到堆顶
        self.heapList[1] = self.heapList[-1]
        # 堆中元素减去1个
        self.currentSize -= 1
        # 删除最后一个元素
        self.heapList.pop()
        # 传入当前堆顶的位置，开始进行调整
        self.percDown(1)
        return retVal

    def buildHeap(self, li):
        # 一颗树的总长度+1整除2，会得到该树的root节点+枝节点
        # 忽略掉了叶子节点
        i = len(li) // 2
        # 重新定义长度
        self.currentSize = len(li)
        # 重新赋值
        self.heapList = [0] + li
        # 从最后一个元素开始，进行排序
        while i > 0:
            self.percDown(i)
            i -= 1

    def findMin(self):
        return self.heapList[1]

    def isEmpty(self):
        return not self.heapList

    def size(self):
        return self.__len__()

    def __len__(self):
        return len(self.heapList) - 1

    def __str__(self):
        return str(self.heapList[1:])

    def __contains__(self, item):
        return item in self.heapList


if __name__ == '__main__':
    bHeap = BinHeap()
    for i in range(5, 12):
        bHeap.insert(i)
    bHeap.insert(4)
    print(bHeap)
    bHeap.delMin()
    print(bHeap)
    print(bHeap.isEmpty())
    print(bHeap.size())
```



# 二叉查找树

在前面的章节中，我们已经介绍了基于线性数据结构+二分查找法的查找方式，以及使用HashMap做定点查找的方式。

现在，将介绍一种基于二叉树的查找方式，名为二叉查找树或二叉搜索树Binary Search Tree。

BinarySearchTree有一个性质，即比父节点小的key都出现在左子树，比父节点大的key都出现在右子树。

<img src="https://images-1302522496.cos.ap-nanjing.myqcloud.com/img/image-20210426143917057.png" alt="image-20210426143917057" style="zoom:80%;" />



在插入时，也一样会经过上浮下沉的步骤，如果按照70,31,93,94,14,23,73的顺序插入：

- 首先插入的70成为树根
- 31比70小，放到左子节点
- 93比70大，放到右子节点
- 94比93大，放到右子节点
- 14比31小，放到左子节点
- 23比14大，放到右子节点
- 73比93小，放到左子节点

若插入顺序如果不同，则生成的BinarySearchTree也会不同。



## Python实现BinarySearch树

如果要使用Python来进行二叉查找树的实现，同时应当提供以下方法：

| 方法名             | 描述                                                         |
| ------------------ | ------------------------------------------------------------ |
| BinarySearchTree() | 一个类，用于构建一个空的二叉查找树对象                       |
| put()              | 将key-val关联对加入至BinarySearchTree中，如果key已存在，则将val进行更新 |
| get()              | 指定key，返回val，如val不存在，则返回None                    |
| del                | 通过 del BinarySearchTree[key]的语句形式删除一组键值对       |
| len()              | 返回BinarySearchTree中键值对的数量                           |
| in                 | 支持成员运算符的应用                                         |

为了实现二叉查找树，我们可以用2个类，BinarySearchTree以及TreeNode。

一个用来构建树的结构，一个用来生成树的节点。

BinarySearchTree类的root成员引用根节点的TreeNode，以下是基本方法：

```
class BinarySearchTree:
    def __init__(self):
        self.root = None
        self.size = 0
        
    def length(self):
        return self.size
    
    def __len__(self):
        return self.size
```

下面是节点类的基本方法：

```
class TreeNode:
    def __init__(self, key, val, left=None, right=None, parent=None):
        self.key = key
        self.payload = val
        self.leftChild = left
        self.rightChild = right
        self.parent = parent

    def getLeftChild(self):
        """返回左子节点"""
        return self.leftChild

    def getRightChild(self):
        """返回右子节点"""
        return self.rightChild

    def isLeftChild(self):
        """判断当前节点是否是左节点"""
        return self.parent and \
               self.parent.leftChild == self

    def isRightChild(self):
        """判断当前节点是否是右节点"""
        return self.parent and \
               self.parent.rightChild == self

    def isRoot(self):
        """判断当前节点是否是根节点，根节点无父节点"""
        return not self.parent

    def isLeaf(self):
        """判断当前节点是否是叶子节点"""
        return not (self.rightChild or self.leftChild)

    def hasAnyChildren(self):
        """判断当前节点是否含有任意的子节点"""
        return self.rightChild or self.leftChild

    def hasBothChildren(self):
        """判断当前节点是否含有左子节点和右子节点"""
        return self.rightChild and self.leftChild

    def replaceNodeDate(self, key, value, lc, rc):
        """替换当前节点"""
        self.key = key
        self.payload = value
        self.leftChild = lc
        self.rightChild = rc
        if self.getLeftChild():
            self.leftChild.parent = self
        if self.getRightChild():
            self.rightChild.parent = self
```

当所有的基本方法都齐全后，开始构建put()方法。



## put()



put()方法是BinarySearchTree的一个实例方法，该方法将检测树是否已有根，若没有根那么put()方法将创建一个新的TreeNode实例并将其作为BinarySearchTree的根，如果根节点已就位，则put()方法将调用私有的递归辅助函数_put()方法，它将根据以下算法进行树的搜索：

- 从树的根开始，搜索二叉树，将新键与当前节点中的键进行比较。如果新键小于当前节点，则搜索左子树。如果新键大于当前节点，则搜索右子树。
- 当没有左（或右）孩子要搜索时，我们在树中找到应该建立新节点的位置。

![image-20210426155714982](https://images-1302522496.cos.ap-nanjing.myqcloud.com/img/image-20210426155714982.png)

以下是代码实现：

```
    def put(self, key, val):
        # 如果存在root节点，则下沉开始寻找插入位置
        if self.root:
            self._put(key, val, self.root)
        else:
            self.root = TreeNode(key, val)
        self.size += 1

    def _put(self, key, val, currentNode):
        # 如果新key小于root，则准备在左子树中寻找插入位置
        if key < currentNode.key:
            # 判断是否能获取到左子节点，如果能获取到则递归寻找插入位置
            if currentNode.getLeftChild():
                self._put(key, val, currentNode.leftChild)
            # 如果是叶子节点，则将其变为枝节点，在左边插入
            else:
                currentNode.leftChild = TreeNode(key, val, parent=currentNode)
        # 如果新key大于root，则准备在右子树中寻找插入位置
        else:
            # 判断是否能获取到右子节点，如果能获取到则递归寻找插入位置
            if currentNode.getRightChild():
                self._put(key, val, currentNode.rightChild)
            # 如果是叶子节点，则将其变为枝节点，在右边插入
            else:
                currentNode.rightChild = TreeNode(key, val, parent=currentNode)
```

顺带将索引赋值也做上：

```
    def __setitem__(self, key, value):
        self.put(key,value)
```



## get()



put()方法构建完毕后，让我们接着构建get()方法。

gut()方法是BinarySearchTree的一个实例方法，它与put()方法类似，同样也有一个私有的递归辅助函数_get()方法来进行递归检测，大体流程如下：

- 首先判断该树有没有根，若没有根则直接返回None
- 如果有根，则判断要查找的key是否等于root，如果相等直接返回，如果小于则往左子树递归查找，反之则往右子树递归查找，若都找不到则返回None

![image-20210622113546201](https://images-1302522496.cos.ap-nanjing.myqcloud.com/img/image-20210622113546201.png)

以下是代码实现：

```
    def get(self, key):
        if self.root:
            res = self._get(key, self.root)
            if res:
                return res.payload
            else:
                return None
        else:
            return None

    def _get(self, key, currentNode):
        # 查找到叶子节点都没找到，返回None
        if not currentNode:
            return None
        # 判断是否等于当前Node的key
        elif currentNode.key == key:
            return currentNode
        # 如果小于，递归遍历左子树
        elif key < currentNode.key:
            return self._get(key, currentNode.leftChild)
        # 如果大于，递归遍历右子树
        else:
            return self._get(key, currentNode.rightChild)
        
    def __getitem__(self, key):
        return self.get(key)
```

顺带着，由于实现了_get()方法，我们也可以将BinarySearchTree的掌管成员运算符in的\_\_contains\_\_()一起实现，代码如下：

```
    def __contains__(self, key):
        if self._get(key, self.root):
            return True
        else:
            return False
```



## \_\_iter\_\_()



当get()方法构建完毕后，下一步要构建迭代器了，只需要实现\_\_iter\_\_()方法即可。

将BinarySearchTree中的\_\_iter\_\_()调用至TreeNode中的\_\_iter\_\_()方法即可：

```
# BinarySearchTree
    def __iter__(self):
        return self.root.__iter__()
        
# TreeNode
    def __iter__(self):
        """采用中序遍历"""
        if self:
            if self.getLeftChild():
                for ele in self.leftChild:
                    yield ele
            yield self.key
            if self.getRightChild():
                for ele in self.rightChild:
                    yield ele
```



## delete()



现在简单的方法都构建完毕了，最难的就属delete()方法，它包含2层，1层是找节点、2层是删节点。

为了使程序更加解耦，我们用delete()作为2个方法的代理，负责调度_get()方法来找节点与remove()方法来删节点，当然remove()方法暂时还没有实现。

在delete()方法中，大体思路如下：

- 如果这个树的长度大于1，则说明有节点，调用_get()方法开始从root节点向后查找，找得到就将其设置为None，找不得则抛出异常
- 如果这个树的长度为1，则说明只有一个root节点，此时判定root节点是否是我们需要找的节点，找得到就将root节点设为None，找不得就删除

代码实现如下：

```
    def delete(self,key):
        if self.size > 1:
            nodeToRemove = self._get(key,self.root)
            if nodeToRemove:
                self.remove(nodeToRemove)
                self.size -= 1
            else:
                raise  KeyError("Error, key not in tree")
        
        elif self.size == 1 and self.root.key == key:
            self.root = None
            self.size -= 1
        else:
            raise KeyError("Error, key not in tree")
        
    def __delitem__(self, key):
        self.delete(key)
```

如果找到了节点，就需要执行remove()方法对其进行删除，但是remove()方法还未实现，我们需要提前对其做一些规划。为了保持整颗二叉查找树的性质，删节点时要对以下3种情形做出分别不同的处理：

- 将要被删除的节点是一个叶子节点（没有任何子节点）
- 将要被删除的节点有1个子节点
- 将要被删除的节点有2个子节点

没有子节点的第1种情况最好办，直接删除即可：

![image-20210622113610455](https://images-1302522496.cos.ap-nanjing.myqcloud.com/img/image-20210622113610455.png)

```
    def remove(self, currentNode):
        # 第一种情况：如果被删除节点是叶子节点
        if currentNode.isLeaf():
            # 判断是左叶子还是右叶子，将其置为None
            if currentNode == currentNode.parent.leftChild:
                currentNode.parent.leftChild = None
            else:
                currentNode.parent.rightChild = None
```

第2种情况稍微复杂，被删节点有1个子节点，我们需要将这个唯一的子节点上移，替换掉被删节点的位置。

![image-20210622113627056](https://images-1302522496.cos.ap-nanjing.myqcloud.com/img/image-20210622113627056.png)

但是在替换操作的时候，又要区分几种情况，如下所示：

- 被删节点的子节点是左？还是右子节点？
- 被删节点本身是其父节点的左？还是右子节点？
- 被删节点本身就是根节点？

解决策略如下：

- 如果当前被删节点是左子节点，则我们只需要更新左子节点的父引用以指向当前节点的父节点，然后更新父节点的左子节点引用以指向当前节点的左子节点
- 如果当前被删节点是右子节点，则我们只需要更新左子节点的父引用以指向当前节点的父节点，然后更新父节点的右子节点引用以指向当前节点的左子节点
- 如果当前被删节点没有父级，则它是根。在这种情况下，我们将通过在根上调用replaceNodeData() 方法来替换 key，payload，leftChild和rightChild的数据。

说了这么多，还不如看代码实际，先写个else，来处理第二种情况，因为我们无法保证该节点只有1个子节点，所以将这个情况放在第三种情形下面即可，（将要被删除的节点有2个子节点）：

```
    def remove(self, currentNode):
        # 第一种情况：如果被删除节点是叶子节点
        if currentNode.isLeaf():
            # 判断是左叶子还是右叶子，将其置为None
            if currentNode == currentNode.parent.leftChild:
                currentNode.parent.leftChild = None
            else:
                currentNode.parent.rightChild = None
        # 第三种情况：如果被删除节点有2个子节点
        elif currentNode.hasBothChildren():
            pass

        # 第二种情况：如果被删除的节点有1个子节点
        else:
            # 如果被删除的节点的1个子节点是左子节点
            if currentNode.getLeftChild():
                # 如果被删除的节点本身是左节点
                if currentNode.isLeftChild():
                    # 爸爸死了，让左儿子的爷爷做左儿子的监护人
                    currentNode.leftChild.parent = currentNode.parent
                    # 爷爷的左儿子死了，爷爷让左孙子顶替左儿子的位置
                    currentNode.parent.leftChild = currentNode.leftChild

                # 如果被删除的节点本身是右节点
                elif currentNode.isRightChild():
                    # 爸爸死了，让左儿子的爷爷做左儿子的监护人
                    currentNode.leftChild.parent = currentNode.parent
                    # 爷爷的右儿子死了，爷爷让左孙子顶替右儿子的位置
                    currentNode.parent.rightChild = currentNode.leftChild

                # 如果被删除的节点本身是根节点
                else:
                    # 爸爸死了儿子顶上
                    currentNode.replaceNodeData(currentNode.leftChild.key,
                                                currentNode.leftChild.payload,
                                                currentNode.leftChild.leftChild,
                                                currentNode.leftChild.rightChild)
            # 如果被删除的节点的1个子节点是右子节点
            else:
                # 如果被删除的节点本身是左节点
                if currentNode.isLeftChild():
                    # 爸爸死了，让右儿子的爷爷做右儿子的监护人
                    currentNode.rightChild.parent = currentNode.parent
                    # 爷爷的左儿子死了，爷爷让右孙子顶替左儿子的位置
                    currentNode.parent.leftChild = currentNode.rightChild

                # 如果被删除的节点本身是右节点
                elif currentNode.isRightChild():
                    # 爸爸死了，让右儿子的爷爷做右儿子的监护人
                    currentNode.rightChild.parent = currentNode.parent
                    # 爷爷的右儿子死了，爷爷让右孙子顶替右儿子的位置
                    currentNode.parent.rightChild = currentNode.rightChild

                # 如果被删除的节点本身是根节点
                else:
                    # 爸爸死了儿子顶上
                    currentNode.replaceNodeData(currentNode.rightChild.key,
                                                currentNode.rightChild.payload,
                                                currentNode.rightChild.leftChild,
                                                currentNode.rightChild.rightChild)
```



第3种情形最复杂，即被删节点有2个子节点。

这时无法简单地将某个子节点上移替换被删节点但可以找到另一个合适的节点来替换被删节点，这个合适节点就是被删节点的下一个key值节点，即被删节点右子树中最小的那个，称为后继。

可以肯定这个后继节点最多只有1个子节点（本身是叶节点，或仅有右子树）将这个后继节点摘出来，替换掉被删节点。

![image-20210426172911966](https://images-1302522496.cos.ap-nanjing.myqcloud.com/img/image-20210426172911966.png)

继续补全remove()中第二个条件的代码，我们可以发现下面有一个寻找后继的函数findSuccessor()与进行切分的函数spliceOut()。

```
    # 第三种情况：如果被删除节点有2个子节点
        elif currentNode.hasBothChildren():
            succ = currentNode.findSuccessor()
            succ.spliceOut()
            # 使用后继节点替换掉当前节点信息
            currentNode.key = succ.key
            currentNode.payload = succ.payload
```

这三个方法要书写到TreeNode类中：

```
    def findSuccessor(self):
        """
        寻找后继
        self:将要被删除的节点
        """
        succ = None
        if self.getRightChild():
            succ = self.rightChild.findMin()
        else:
            if self.parent:
                if self.isLeftChild():
                    succ = self.parent
                else:
                    self.parent.rightChild = None
                    succ = self.parent.findSuccessor()
                    self.parent.rightChild = self
        return succ

    def spliceOut(self):
        if self.isLeaf():
            if self.isLeftChild():
                self.parent.leftChild = None
            else:
                self.parent.rightChild = None
        elif self.hasAnyChildren():
            if self.getLeftChild():
                if self.isLeftChild():
                    self.parent.leftChild = self.leftChild
                else:
                    self.parent.rightChild = self.leftChild
                self.leftChild.parent = self.parent
            else:
                if self.isLeftChild():
                    self.parent.leftChild = self.rightChild
                else:
                    self.parent.rightChild = self.rightChild
                self.rightChild.parent = self.parent

    def findMin(self):
        """寻找最小值，self是当前将要被删除节点的右子节点"""
        current = self
        # 判断当前节点是否有左子节点，有就一直往下找
        while current.getLeftChild():
            current = current.leftChild
        # 直到找到将要被删除节点的右子节点下的最左侧节点
        return current
```

## 完整代码



完整及测试代码如下：

```
#! /usr/local/bin/python3
# -*- coding:utf-8 -*-

class BinarySearchTree:
    def __init__(self):
        self.root = None
        self.size = 0

    def length(self):
        return self.size

    def __len__(self):
        return self.size

    def __iter__(self):
        return self.root.__iter__()

    def put(self, key, val):
        if self.root:
            self._put(key, val, self.root)
        else:
            self.root = TreeNode(key, val)
        self.size += 1

    def _put(self, key, val, currentNode):
        # 如果新key小于root，则准备在左子树中寻找插入位置
        if key < currentNode.key:
            # 判断是否能获取到左子节点，如果能获取到则递归寻找插入位置
            if currentNode.getLeftChild():
                self._put(key, val, currentNode.leftChild)
            # 如果是叶子节点，则将其变为枝节点，在左边插入
            else:
                currentNode.leftChild = TreeNode(key, val, parent=currentNode)
        # 如果新key大于root，则准备在右子树中寻找插入位置
        else:
            # 判断是否能获取到右子节点，如果能获取到则递归寻找插入位置
            if currentNode.getRightChild():
                self._put(key, val, currentNode.rightChild)
            # 如果是叶子节点，则将其变为枝节点，在右边插入
            else:
                currentNode.rightChild = TreeNode(key, val, parent=currentNode)

    def __setitem__(self, key, value):
        self.put(key, value)

    def get(self, key):
        if self.root:
            res = self._get(key, self.root)
            if res:
                return res.payload
            else:
                return None
        else:
            return None

    def _get(self, key, currentNode):
        # 查找到叶子节点都没找到，返回None
        if not currentNode:
            return None
        # 判断是否等于当前Node的key
        elif currentNode.key == key:
            return currentNode
        # 如果小于，递归遍历左子树
        elif key < currentNode.key:
            return self._get(key, currentNode.leftChild)
        # 如果大于，递归遍历右子树
        else:
            return self._get(key, currentNode.rightChild)

    def __getitem__(self, key):
        return self.get(key)

    def __contains__(self, key):
        if self._get(key, self.root):
            return True
        else:
            return False

    def delete(self, key):
        if self.size > 1:
            nodeToRemove = self._get(key, self.root)
            if nodeToRemove:
                self.remove(nodeToRemove)
                self.size -= 1
            else:
                raise KeyError("Error, key not in tree")

        elif self.size == 1 and self.root.key == key:
            self.root = None
            self.size -= 1
        else:
            raise KeyError("Error, key not in tree")

    def __delitem__(self, key):
        self.delete(key)

    def remove(self, currentNode):
        # 第一种情况：如果被删除节点是叶子节点
        if currentNode.isLeaf():
            # 判断是左叶子还是右叶子，将其置为None
            if currentNode == currentNode.parent.leftChild:
                currentNode.parent.leftChild = None
            else:
                currentNode.parent.rightChild = None
        # 第三种情况：如果被删除节点有2个子节点
        elif currentNode.hasBothChildren():
            succ = currentNode.findSuccessor()
            succ.spliceOut()
            # 使用后继节点替换掉当前节点信息
            currentNode.key = succ.key
            currentNode.payload = succ.payload

        # 第二种情况：如果被删除的节点有1个子节点
        else:
            # 如果被删除的节点的1个子节点是左子节点
            if currentNode.getLeftChild():
                # 如果被删除的节点本身是左节点
                if currentNode.isLeftChild():
                    # 爸爸死了，让左儿子的爷爷做左儿子的监护人
                    currentNode.leftChild.parent = currentNode.parent
                    # 爷爷的左儿子死了，爷爷让左孙子顶替左儿子的位置
                    currentNode.parent.leftChild = currentNode.leftChild

                # 如果被删除的节点本身是右节点
                elif currentNode.isRightChild():
                    # 爸爸死了，让左儿子的爷爷做左儿子的监护人
                    currentNode.leftChild.parent = currentNode.parent
                    # 爷爷的右儿子死了，爷爷让左孙子顶替右儿子的位置
                    currentNode.parent.rightChild = currentNode.leftChild

                # 如果被删除的节点本身是根节点
                else:
                    # 爸爸死了儿子顶上
                    currentNode.replaceNodeData(currentNode.leftChild.key,
                                                currentNode.leftChild.payload,
                                                currentNode.leftChild.leftChild,
                                                currentNode.leftChild.rightChild)
            # 如果被删除的节点的1个子节点是右子节点
            else:
                # 如果被删除的节点本身是左节点
                if currentNode.isLeftChild():
                    # 爸爸死了，让右儿子的爷爷做右儿子的监护人
                    currentNode.rightChild.parent = currentNode.parent
                    # 爷爷的左儿子死了，爷爷让右孙子顶替左儿子的位置
                    currentNode.parent.leftChild = currentNode.rightChild

                # 如果被删除的节点本身是右节点
                elif currentNode.isRightChild():
                    # 爸爸死了，让右儿子的爷爷做右儿子的监护人
                    currentNode.rightChild.parent = currentNode.parent
                    # 爷爷的右儿子死了，爷爷让右孙子顶替右儿子的位置
                    currentNode.parent.rightChild = currentNode.rightChild

                # 如果被删除的节点本身是根节点
                else:
                    # 爸爸死了儿子顶上
                    currentNode.replaceNodeData(currentNode.rightChild.key,
                                                currentNode.rightChild.payload,
                                                currentNode.rightChild.leftChild,
                                                currentNode.rightChild.rightChild)


class TreeNode:
    def __init__(self, key, val, left=None, right=None, parent=None):
        self.key = key
        self.payload = val
        self.leftChild = left
        self.rightChild = right
        self.parent = parent

    def getLeftChild(self):
        """返回左子节点"""
        return self.leftChild

    def getRightChild(self):
        """返回右子节点"""
        return self.rightChild

    def isLeftChild(self):
        """判断当前节点是否是左节点"""
        return self.parent and \
               self.parent.leftChild == self

    def isRightChild(self):
        """判断当前节点是否是右节点"""
        return self.parent and \
               self.parent.rightChild == self

    def isRoot(self):
        """判断当前节点是否是根节点，根节点无父节点"""
        return not self.parent

    def isLeaf(self):
        """判断当前节点是否是叶子节点"""
        return not (self.rightChild or self.leftChild)

    def hasAnyChildren(self):
        """判断当前节点是否含有任意的子节点"""
        return self.rightChild or self.leftChild

    def hasBothChildren(self):
        """判断当前节点是否含有左子节点和右子节点"""
        return self.rightChild and self.leftChild

    def replaceNodeDate(self, key, value, lc, rc):
        """替换当前节点"""
        self.key = key
        self.payload = value
        self.leftChild = lc
        self.rightChild = rc
        if self.getLeftChild():
            self.leftChild.parent = self
        if self.getRightChild():
            self.rightChild.parent = self

    def __iter__(self):
        """采用中序遍历"""
        if self:
            if self.getLeftChild():
                for ele in self.leftChild:
                    yield ele
            yield self.key
            if self.getRightChild():
                for ele in self.rightChild:
                    yield ele

    def findSuccessor(self):
        """
        寻找后继
        self:将要被删除的节点
        """
        succ = None
        if self.getRightChild():
            succ = self.rightChild.findMin()
        else:
            if self.parent:
                if self.isLeftChild():
                    succ = self.parent
                else:
                    self.parent.rightChild = None
                    succ = self.parent.findSuccessor()
                    self.parent.rightChild = self
        return succ

    def spliceOut(self):
        if self.isLeaf():
            if self.isLeftChild():
                self.parent.leftChild = None
            else:
                self.parent.rightChild = None
        elif self.hasAnyChildren():
            if self.getLeftChild():
                if self.isLeftChild():
                    self.parent.leftChild = self.leftChild
                else:
                    self.parent.rightChild = self.leftChild
                self.leftChild.parent = self.parent
            else:
                if self.isLeftChild():
                    self.parent.leftChild = self.rightChild
                else:
                    self.parent.rightChild = self.rightChild
                self.rightChild.parent = self.parent

    def findMin(self):
        """寻找最小值，self是当前将要被删除节点的右子节点"""
        current = self
        # 判断当前节点是否有左子节点，有就一直往下找
        while current.getLeftChild():
            current = current.leftChild
        # 直到找到将要被删除节点的右子节点下的最左侧节点
        return current


if __name__ == '__main__':
    mytree = BinarySearchTree()
    mytree[3] = "red"
    mytree[4] = "blue"
    mytree[6] = "yellow"
    mytree[2] = "at"
    del mytree[2]
    for i in mytree:
        print(i)
```



## 性能分析

上述的二叉搜索树，性能影响最大的是其高度，而其高度又受数据项key插入顺序的影响。

如果key的列表是随机分布的话，那么大于和小于根节点key的键值大致相等。

这样的树就是平衡树，put()方法最差性能为O(log2n)。

如果key的插入的顺序十分极端，如下图所示，那么put()方法的性能就变为了O(n)，其他方法也类似：

![image-20210426192755146](https://images-1302522496.cos.ap-nanjing.myqcloud.com/img/image-20210426192755146.png)

如何改进二叉搜索树，让其不受到key插入顺序的影响呢？

这就涉及到下面要介绍的平衡二叉查找树的知识了。

# 平衡二叉查找树

AVL树即为平衡二叉树，它能够保证性能不受到key插入顺序的影响。

AVL是发明者的名字缩写：G.M. Adelson-Velskii and E.M. Landis

AVL树的实现与基础的BinarySearcTree的实现基本相同，唯一不同之处在于二叉树的生成与维护过程。



## 平衡因子

AVL树的实现中，需要对每个节点跟踪“平衡因子balancefactor”参数，平衡因子是根据节点的左右子树的高度来定义的，确切地说，是左右子树高度差。

```
balanceFactor = height(leftSubTree) − height(rightSubTree)
```

如果平衡因子大于0，称为“左重left-heavy”，小于零称为“右重right-heavy”平衡因子等于0，则称作平衡。

如果一个二叉查找树中每个节点的平衡因子都在-1，0，1之间，则把这个二叉搜索树称为平衡树。

在平衡树操作过程中，有节点的平衡因子超出此范围，则需要一个重新平衡的过程。

也就是说，左子树和右子树的高度差不能超过1，在AVL树实现中只要确保该点即可。



## 树的自旋

我们只需要在上面的BinarySearchTree中做改进便可完成实现，首先，如果向AVL树插入一个新key，如何才能保持AVL树的平衡性质。

作为BinarySearchTree，新key必定以叶节点形式插入到AVL树中，叶节点的平衡因子是0，其本身无需重新平衡。

但这样做会影响其父节点的平衡因子：

- 作为左子节点插入，则父节点平衡因子会增加1
- 作为右子节点插入，则父节点平衡因子会减少1

这种影响可能随着其父节点到根节点的路径一直传递上去，直到传递到根节点为止。

或者某个父节点平衡因子被调整到0，不再影响上层节点的平衡因子为止。

无论从-1或者1调整到0，都不会改变子树高度，如下图所示，左侧的父节点本身平衡因子是1，但是因为加入了新的节点，父节点的平衡因子变为了0，此时不会再往上传递。

AVL树中如何将不平衡因子转为平衡？最主要的手段就是通过旋转，左旋、右旋、先左旋后右旋、先右旋后左旋4种策略。

根据当前树是左重，还是右重来进行不同方向的旋转，同时还需要更新相关父节点的引用，更新旋转后被影响节点的平衡因子。



## 左旋(LL)



示例1，新插入了C在B的右侧：

- 叶子节点C的平衡因子为0
- 从B的角度看这课树，平衡因子是-1，符合AVL树的性质
- 从A的角度看这课树，平衡因子是-2，已经不符合AVL树的性质，需要进行左旋调整

 ![image-20210427222840581](https://images-1302522496.cos.ap-nanjing.myqcloud.com/img/image-20210427222840581.png)



## 右旋(RR)

示例2，新插入了A在B的左侧：

- 叶子节点A的平衡因子为0
- 从B的角度看这棵树，平衡因子是1，符合AVL树的性质
- 从A的角度看这棵树，平衡因子是2，已经不符合AVL树的性质，需要进行右旋调整

![image-20210427222921264](https://images-1302522496.cos.ap-nanjing.myqcloud.com/img/image-20210427222921264.png)

两次旋转是已经解释过的旋转形式的稍微复杂的版本。为了更好地理解它们，我们应注意旋转时执行的每个动作。让我们首先检查如何执行左右旋转。左右旋转是左旋转与右旋转的组合。



## 先左后右旋(LR)

一个节点已插入到左子树的右子树中。这使C成为不平衡节点。这种情况下使AVL树执行左右旋转：

![右旋](https://images-1302522496.cos.ap-nanjing.myqcloud.com/img/right_subtree_of_left_subtree.jpg)

我们首先在C的左子树上执行左旋转。这使A成为B的左子树：

![左旋](https://images-1302522496.cos.ap-nanjing.myqcloud.com/img/image-20210427223607327.png)

节点C仍然不平衡：

![左旋](https://images-1302522496.cos.ap-nanjing.myqcloud.com/img/left_unbalanced_tree.jpg)

现在，我们将树右旋转，使B成为该子树的新根节点。C现在成为其自己的左子树的右子树。

![右旋](https://images-1302522496.cos.ap-nanjing.myqcloud.com/img/right_rotation.jpg)

目前，树已平衡：

![平衡平均树](https://images-1302522496.cos.ap-nanjing.myqcloud.com/img/balanced_avl_tree.jpg)



## 先右旋后左旋(RL)

一个节点已插入到右子树的左子树中。这使C成为不平衡节点。这种情况下使AVL树执行右左旋转：

![右子树的左子树](https://images-1302522496.cos.ap-nanjing.myqcloud.com/img/left_subtree_of_right_subtree.jpg)

首先，我们沿C节点执行右旋转，使C成为其自己的左子树B的右子树。现在，B成为A的右子树。

![子树向右旋转](https://images-1302522496.cos.ap-nanjing.myqcloud.com/img/subtree_right_rotation.jpg)

节点A仍然由于其右子树的右子树而处于不平衡状态，并且需要向左旋转。

![正确的不平衡树](https://images-1302522496.cos.ap-nanjing.myqcloud.com/img/right_unbalanced_tree.jpg)

通过使B成为子树的新根节点，可以执行向左旋转。A成为其右子树B的左子树。

![左旋](https://images-1302522496.cos.ap-nanjing.myqcloud.com/img/left_rotation.jpg)

目前，树已平衡：

![平衡的AVL树](https://images-1302522496.cos.ap-nanjing.myqcloud.com/img/balanced_avl_tree-20210622121613339.jpg)



## 代码实现

只需要在BinarySearchTree的代码中做如下修改即可，如下添加了左旋代码，右旋和双向旋转没有添加，感兴趣的朋友可以自行实现：

```
# __init__中新增节点的平衡因子属性：
rotRoot.balanceFactor = rotRoot.balanceFactor + 1 - min(0,newRoot.balanceFactor)

def _put(self, key, val, currentNode):
    # 如果新key小于root，则准备在左子树中寻找插入位置
    if key < currentNode.key:
        # 判断是否能获取到左子节点，如果能获取到则递归寻找插入位置
        if currentNode.getLeftChild():
            self._put(key, val, currentNode.leftChild)
        # 如果是叶子节点，则将其变为枝节点，在左边插入
        else:
            currentNode.leftChild = TreeNode(key, val, parent=currentNode)
            # 并且调整其父节点的平衡因子
            self.updateBalance(currentNode.leftChild)
    # 如果新key大于root，则准备在右子树中寻找插入位置
    else:
        # 判断是否能获取到右子节点，如果能获取到则递归寻找插入位置
        if currentNode.getRightChild():
            self._put(key, val, currentNode.rightChild)
        # 如果是叶子节点，则将其变为枝节点，在右边插入
        else:
            currentNode.rightChild = TreeNode(key, val, parent=currentNode)
            # 并且调整其父节点的平衡因子
            self.updateBalance(currentNode.rightChild)
 
 def updateBalance(self, node):
    # 判断节点的因子是否失衡 balanceFactor 是生成的，暂时还没有
    if node.balanceFactor > 1 or node.balanceFactor < -1:
        # 重新跳转平衡因子
        self.rebalance(node)
        return
    if node.parent != None:
        if node.isLeftChild():
            node.parent.balanceFactor += 1
        elif node.isRightChild():
            node.parent.balanceFactor -= 1
        if node.parent.balanceFactor != 0:
            # 继续递归，向上调整父节点的平衡因子
            self.updateBalance(node.parent)
            
def rebalance(self,node):
  # 重新平衡
  if node.balanceFactor < 0:
         if node.rightChild.balanceFactor > 0:
            self.rotateRight(node.rightChild)
            self.rotateLeft(node)
         else:
            self.rotateLeft(node)
  elif node.balanceFactor > 0:
         if node.leftChild.balanceFactor < 0:
            self.rotateLeft(node.leftChild)
            self.rotateRight(node)
         else:
            self.rotateRight(node)      
            
def rotateLeft(self,rotRoot):
    # 左旋
    newRoot = rotRoot.rightChild
    rotRoot.rightChild = newRoot.leftChild
    if newRoot.leftChild != None:
        newRoot.leftChild.parent = rotRoot
    newRoot.parent = rotRoot.parent
    if rotRoot.isRoot():
        self.root = newRoot
    else:
        if rotRoot.isLeftChild():
                rotRoot.parent.leftChild = newRoot
        else:
            rotRoot.parent.rightChild = newRoot
    newRoot.leftChild = rotRoot
    rotRoot.parent = newRoot
    rotRoot.balanceFactor = rotRoot.balanceFactor + 1 - min(newRoot.balanceFactor, 0)
    newRoot.balanceFactor = newRoot.balanceFactor + 1 + max(rotRoot.balanceFactor, 0)
```

