# 低级语言

语言的高级和低级之分并不是说语言本身的层次高低，而是指的是与底层硬件的密切程度。

就如同机器语言与汇编语言就是直接与底层硬件打交道的语言，故也被称为低级语言。



## 机器语言

机器语言是不通过任何操作系统就可以直接与底层硬件打交道的语言，说白了就是计算机能读懂的二进制。

想要使用机器语言就得充分的了解计算机底层硬件的各个知识。

虽然这可能会花上你半生的时间，但是机器语言的执行效率却是无与伦比的高，计算机不需要通过任何编译就能直接运行。

与之相反的是机器语言的开发效率却是慢到令人发指，除了你需要去学习底层硬件相关的知识外还需要对每一条二进制指令烂熟于心，更加恐怖的是面对满屏的010101如果敲错一个字符就全部推倒重来，显然这已经超出了普通人所能承受的极限。

```
    #指令部份的示例
    0000         代表 加载（LOAD）
    0001         代表 存储（STORE）
    ...
​
    #暂存器部份的示例
    0000         代表暂存器 A
    0001         代表暂存器 B
    ...
​
    #存储器部份的示例
    000000000000 代表地址为 0 的存储器
    000000000001 代表地址为 1 的存储器
    000000010000 代表地址为 16 的存储器
    100000000000 代表地址为 2^11 的存储器
​
    #集成示例
    0000,0000,000000010000 代表 LOAD A, 16
    0000,0001,000000000001 代表 LOAD B, 1
    0001,0001,000000010000 代表 STORE B, 16
    0001,0001,000000000001 代表 STORE B, 1[1]
```



| 名词     | 描述                                         |
| -------- | -------------------------------------------- |
| 执行效率 | 极高                                         |
| 开发效率 | 极低                                         |
| 跨平台性 | 极差（由于必须依赖具体的硬件，故移植性极差） |





## 汇编语言

汇编语言仅仅是用一个英文标签代表一组二进制指令，毫无疑问，比起机器语言，汇编语言是一种进步，但汇编语言的本质仍然是直接操作硬件，因此汇编语言仍是比较低级/底层的语言、因为它十分的贴近计算机硬件。

汇编的中打印一句hello world，需要写十多行，如下：

```
; hello.asm 
section .data            ;                数据段声明
        msg db "Hello, world!", 0xA     ; 要输出的字符串
        len equ $ - msg                 ; 字串长度
        section .text            ;        代码段声明
        global _start            ;        指定入口函数
        _start:                  ;        在屏幕上显示一个字符串
        mov edx, len     ;                参数三：字符串长度
        mov ecx, msg     ;                参数二：要显示的字符串
        mov ebx, 1       ;                参数一：文件描述符(stdout) 
        mov eax, 4       ;                系统调用号(sys_write) 
        int 0x80         ;                调用内核功能
                         ;                退出程序
        mov ebx, 0       ;                参数一：退出代码
        mov eax, 1       ;                系统调用号(sys_exit) 
        int 0x80         ;                调用内核功能
```



| 名词     | 描述                                         |
| -------- | -------------------------------------------- |
| 执行效率 | 极高                                         |
| 开发效率 | 低                                           |
| 跨平台性 | 极差（由于必须依赖具体的硬件，故移植性极差） |



# 高级语言



高级语言并不关心底层硬件到底怎么样，因为高级语言是在和操作系统打交道。

而操作系统又是管控硬件的软件，所以高级语言相较于低级语言来说它的开发效率肯定是要快上不少，但是在执行效率上却有所损失。

对于语言的好坏一味的按照执行效率来区分并非是正确的，语言本身只是一种工具，使用语言的人才是真正的操纵者。

语言的对比只应场景适不适用，其本身并无强弱之分。

比如要对底层硬件进行开发，那么无疑汇编语言是最佳的选择，它能与本机硬件打交道所以能充分发挥自己执行效率高的特性，再比如要做一款网络爬虫相关的软件，由于网络具有延迟性会拖慢程序整体的运行速度，故使用汇编语言来编写爬虫便成了弱势（开发周期长，网络环境让汇编语言的高执行效率也体现不出来）。

高级语言中按照翻译方式的不同又大体可分为两类，分别是编译型语言与解释型语言。





## 编译型语言

如Golang，C语言等均为编译型语言。

![image-20210429234855869](https://images-1302522496.cos.ap-nanjing.myqcloud.com/img/image-20210429234855869.png)

编译型语言特点：

- 执行效率高：生成的目标文件可以脱离语言环境独立执行（因为都是存的二进制指令）
- 开发效率低：如果程序需要修改某一功能则必须修改源程序中的代码后再次生成目标程序，倘若只有目标程序而没有源程序的话则修改原本的功能是一件很困难的事情，这样做的好处是保证了代码的安全性，除开通过反编译技术手段否则看不见源代码
- 跨平台性差：大多数编译型语言的代码只针对某一个平台下进行编译，前平台下的编译结果（目标程序）无法拿到不同的平台上使用
- 其他：现在大多数的编程语言都是编译型的。编译程序（GCC）将源程序翻译成目标程序后保存在另一个文件中，该目标程序可脱离编译程序直接在计算机上多次运行。大多数软件产品都是以目标程序形式发行给用户的，不仅便于直接运行提升执行效率，同时又使他人难于盗用其中的技术





## 解释型语言

如Python，JavaScript均为解释型语言。

![image-20210430000320767](https://images-1302522496.cos.ap-nanjing.myqcloud.com/img/image-20210430000320767.png)

解释型语言特点：

- 执行效率低：在解释型语言的实现中，解释器并不产生目标机器代码，而是产生易于执行的中间代码。这种中间代码与机器代码是不同的，中间代码的解释是由软件支持的，不能直接使用硬件，软件解释器通常会导致执行效率偏低
- 开发效率高：用解释型语言编写的程序是由另一个可以理解中间代码的解释程序执行的，与编译程序不同的是，解释程序的任务是逐一将源程序的语句解释成可执行的机器指令，不需要将源程序翻译成目标代码再执行。解释程序的优点是当语句出现语法错误时，可以立即引起程序员的注意。让程序员在程序开发期间就能进行校正，故开发效率高于编译性语言
- 跨平台性强：代码运行是依赖于解释器，不同平台有对应版本的解释器，所以解释型语言的跨平台性更强
- 其他：对于解释型Basic语言，需要一个专门的解释器解释执行Basic程序，每条语句只有在执行时才被翻译，这种解释型语言每执行一次就翻译一次，因而效率低下。一般地，动态语言都是解释型的，例如：Tcl、Perl、Ruby、VBScript、JavaScript等



除此之外，还有一种混合型语言，如Java：Java语言首先会生成Java汇编，然后通过虚拟机进一步转换成计算机可以识别的二进制汇编语言。





# 动态与静态

动态类型：如果一门语言可以在运行时改变变量的类型，那我们称之为动态类型语言（如Python）

静态类型：相反，如果一门语言不可以在运行时改变变量的类型，则称之为静态类型语言（如Golang）

动态类型示例（Python演示）：

```
>>> string = str("hello,world")
>>> type(string)
<class 'str'>
>>> string = b""
>>> type(string)
<class 'bytes'>
>>>
```

静态类型示例（Golang演示）：

```
func main() {
    var str string
    str = "hello,world"
    fmt.Printf("%T",str)
    str = 't'
    // 编译出现异常，不允许改变类型
}
```



# 强类型与弱类型

强类型：如果一门语言不倾向于对变量的类型做隐式转换，那我们将其称之为强类型语言（如Python）

弱类型：相反，如果一门语言倾向于对变量的类型做隐式转换，那我们则称之为弱类型语言（如JavaScript）

强类型示例（Python演示）：

```
>>> 1 == "1"
False
```

弱类型示例（JavaScript演示）：

```
"use strict";
console.log(1 == "1"); // true
```


