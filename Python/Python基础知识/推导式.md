# 推导式

推导式（comprehension）意在能用最精简的代码创建出一个容器类型，是在不丧失代码可读性的前提下最大程度精简代码的一系列操作。

Python从Haskell语言中取得灵感，创建了一系列的推导式。



# 列表推导式

## 应用场景

有一个列表中存了一些人名和性别的元组数据项，我需要将性别为男性的数据项提取至一个新的列表中。

如下所示，在没有学习列表推导式之前， 你可能会这样做：

```
oldList = [
    ["Tom", "Male"],
    ["Jack", "Male"],
    ["Mary", "Female"],
    ["Laura", "Female"]
]

newList = []
for li in oldList:
    if li[-1].lower() == "male":
        newList.append(li)

print(newList)
# [['Tom', 'Male'], ['Jack', 'Male']]
```

如果有列表推导式的帮助，这样的场景就简单很多，它的语法如下：

```
newList = [ 被添加/操作的数据项 for 迭代变量 in 可迭代对象 if 条件]
```

那么精简后的代码如下所示：

```
oldList = [
    ["Tom", "Male"],
    ["Jack", "Male"],
    ["Mary", "Female"],
    ["Laura", "Female"]
]

newList = [li for li in oldList if li[-1].lower() == "male"]

print(newList)
# [['Tom', 'Male'], ['Jack', 'Male']]
```

只有if条件成立后迭代变量才会被添加至新列表中，注意不能跟else，不符合条件的迭代变量将会被直接舍弃。



## 快速创建列表

使用列表推导式可以快速的创建一个列表，如下所示，推导出了1个1-10的列表：

```
newLi = [i for i in range(1, 11)]
print(newLi)

# [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
```

下面的示例中，我们可以快速的推导出了一副扑克牌的列表：

```
newLi = [ i + str(j) for i in ["❤", "♧", "♤", "♢"] for j in range(1, 14)]
newLi.append("bigKing")
newLi.append("smallKing")
print(newLi)
```

结果如下：

```
['❤1', '❤2', '❤3', '❤4', '❤5', '❤6', '❤7', '❤8', '❤9', '❤10', '❤11', '❤12', '❤13', '♧1', '♧2', '♧3', '♧4', '♧5', '♧6', '♧7', '♧8', '♧9', '♧10', '♧11', '♧12', '♧13', '♤1', '♤2', '♤3', '♤4', '♤5', '♤6', '♤7', '♤8', '♤9', '♤10', '♤11', '♤12', '♤13', '♢1', '♢2', '♢3', '♢4', '♢5', '♢6', '♢7', '♢8', '♢9', '♢10', '♢11', '♢12', '♢13', 'bigKing', 'smallKing']
```



## 元素的处理

数据项在添加至列表之前，可以为其进行一些操作。

比如在上面扑克牌的示例中，我们将int对象转换为了str对象，同理也可以做一些别的操作。

如下示例，我们将推导出一个从1 - 26个字母的列表：

```
newLi = [chr(i) for i in range(65, 65 + 26)]
print(newLi)

# ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z']
```



## 迭代变量

需要注意的是，迭代变量与条件成立后添加的数据项没有任何关系，如下所示，仅循环10次，添加了10个A，迭代变量i根本没被用到：

```
newLi = [chr(65) for i in range(10)]
print(newLi)

# ['A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A']
```





# 字典推导式

## 使用示例

字典推导式和列表推导式基本差不多，但是外部是用花括号包裹，并且要有:进行key和value的区分。

第1个例子，基本使用，快速的推导出ASCII码表的对照关系：

```
asciiDict = {i: chr(i) for i in range(0, 128)}
print(asciiDict)
```

结果如下：

```
{0: '\x00', 1: '\x01', 2: '\x02', 3: '\x03', 4: '\x04', 5: '\x05', 6: '\x06', 7: '\x07', 8: '\x08', 9: '\t', 10: '\n', 11: '\x0b', 12: '\x0c', 13: '\r', 14: '\x0e', 15: '\x0f', 16: '\x10', 17: '\x11', 18: '\x12', 19: '\x13', 20: '\x14', 21: '\x15', 22: '\x16', 23: '\x17', 24: '\x18', 25: '\x19', 26: '\x1a', 27: '\x1b', 28: '\x1c', 29: '\x1d', 30: '\x1e', 31: '\x1f', 32: ' ', 33: '!', 34: '"', 35: '#', 36: '$', 37: '%', 38: '&', 39: "'", 40: '(', 41: ')', 42: '*', 43: '+', 44: ',', 45: '-', 46: '.', 47: '/', 48: '0', 49: '1', 50: '2', 51: '3', 52: '4', 53: '5', 54: '6', 55: '7', 56: '8', 57: '9', 58: ':', 59: ';', 60: '<', 61: '=', 62: '>', 63: '?', 64: '@', 65: 'A', 66: 'B', 67: 'C', 68: 'D', 69: 'E', 70: 'F', 71: 'G', 72: 'H', 73: 'I', 74: 'J', 75: 'K', 76: 'L', 77: 'M', 78: 'N', 79: 'O', 80: 'P', 81: 'Q', 82: 'R', 83: 'S', 84: 'T', 85: 'U', 86: 'V', 87: 'W', 88: 'X', 89: 'Y', 90: 'Z', 91: '[', 92: '\\', 93: ']', 94: '^', 95: '_', 96: '`', 97: 'a', 98: 'b', 99: 'c', 100: 'd', 101: 'e', 102: 'f', 103: 'g', 104: 'h', 105: 'i', 106: 'j', 107: 'k', 108: 'l', 109: 'm', 110: 'n', 111: 'o', 112: 'p', 113: 'q', 114: 'r', 115: 's', 116: 't', 117: 'u', 118: 'v', 119: 'w', 120: 'x', 121: 'y', 122: 'z', 123: '{', 124: '|', 125: '}', 126: '~', 127: '\x7f'}
```

第2个例子，对于迭代一些特殊格式的容器，可以直接生成出一个字典：

```
userMessage = [("name", "Yunya"), ("age", 18), ("gender", "male")]
newDict = {k: v for k, v in li1}
print(newDict)

# {'name': 'Yunya', 'age': 18, 'gender': 'male'}
```



# 集合推导式

## 使用示例

集合推导式和字典推导式相同，唯一区别仅在与不需要：和value，以下是示例演示：

```
newSet = {chr(i) for i in range(65, 64 + 27)}
print(newSet)

# {'E', 'Q', 'G', 'Z', 'A', 'R', 'P', 'M', 'H', 'V', 'W', 'I', 'B', 'X', 'D', 'J', 'S', 'F', 'Y', 'N', 'T', 'L', 'C', 'U', 'K', 'O'}
```



# 局部作用域

之前聊过普通的for循环中是不存在局部作用域的，那么在推导式当中是否存在局部作用域呢？

以列表举例：

```
newList = [i for i in range(10)]
print(i)

# NameError: name 'i' is not defined
```

可以看见，在推导式中的局部作用域是存在的。





# 元组推导式？

我们上面介绍了基本的4大容器中的3大容器推导式，为何没有介绍元组推导式？

其实，Python中并未提供元组推导式，而是提供了生成器表达式。

元组本身就是不可变类型，对比列表推导式，它的工作原理其实就是迭代一个可迭代对象然后使用append()进行添加数据项。

由于元组是不可变类型故不能尝试改变其本身容器中数据项的个数。