# 流程控制

流程控制以循环为主，旨在让计算机重复的完成事情。



# 条件循环

## while

while循环是基于条件的循环，while本身具有if判断的功能，当条件为真时开始重复执行子代码块中的内容直至条件为假后跳出循环。

```
tag = 10
while tag > 5:
    print("tag的数值目前是:{num}".format(num=tag))
    tag -= 1

print('while循环执行完毕')
print(tag)

tag = 10
while tag > 5:
    print("tag的数值目前是:{num}".format(num=tag))
    tag -= 1

print('while循环执行完毕')
print(tag)

# tag的数值目前是:10
# tag的数值目前是:9
# tag的数值目前是:8
# tag的数值目前是:7
# tag的数值目前是:6
# while循环执行完毕
# 5
```



## 条件退出

while只有在每一次的循环开始前才会检测条件是否为真，如果条件在子代码块内部发生改变则本次的循环并不会立即退出，如下所示：

```
count = 5

while count != 10:
    # 修改条件后。不会立刻退出
    count = 10
    print("当前count的数值为:", count)
    print("----> 执行中")

print("执行完毕..")

# 当前count的数值为: 10
# ----> 执行中
# 执行完毕..
```



## while/else

while循环正常结束后，会执行else代码块中的代码：

- 正常结束的while循环是指不被强制break的while循环



```
tag = 3
while tag:
    print(tag)
    tag -= 1
else:
    print("else...")

# 3
# 2
# 1
# else...
```



## 死循环

当while的结果永远为真时，将引发死循环。

单纯的死循环不会引来性能损耗问题，但是如果做一些计算操作则必将会对CPU带来极大的性能压力。

```
tag = 1
while 1:
    tag += 10  # CPU没有休息时间
```



# 迭代循环

## for

for循环内部是基于while循环来完成的，for循环在对容器的取值上比while循环更加的方便。

for循环常用于取值操作，以下是语法介绍：

```
for 迭代变量 in 可迭代对象（暂时可理解为容器类型）
    逻辑操作...
```

以下是使用while循环进行取值，相当麻烦：

```
li = [1, 2, 3, 4, 5]
index = 0
while 1:
    try:
        print(li[index])
    except IndexError:
        break
    index += 1

# 1
# 2
# 3
# 4
# 5
```

如果使用for循环，那么就变的简单许多：

```
li = [1, 2, 3, 4, 5]
for i in li:
    print(i)
    
# 1
# 2
# 3
# 4
# 5
```



## 迭代退出

for循环的正常退出是遍历完整个可迭代对象之后进行退出。

```
li = [1, 2, 3, 4, 5]
for i in li:
    print(i)
print("结束了")

# 1
# 2
# 3
# 4
# 5
# 结束了
```



## for/else

当for循环正常退出结束后，会执行else下的代码块：

- 正常结束的for循环是指不被强制break的for循环

```
li = [1, 2, 3, 4, 5]
for i in li:
    print(i)
else:
    print("else..")

# 1
# 2
# 3
# 4
# 5
# else..
```



## range()

如果我们有一个需求需要让计算机重复打印5次hello,world，你可能会这样做：

```
count = 5
while count:
    print("hello,world")
    count -= 1
```

也可以使用for循环来进行完成，但是这样会很麻烦，由于使用for循环必须遍历一个可迭代对象，所以要先创建一个可迭代对象：

```
count = [0, 1, 2, 3, 4]
for i in count:
    print("hello,world")
```

如果你使用range()，这一切都会变得非常简单，range()会帮助你快速的创建一个可迭代对象，我们只需要指定它的次数即可：

```
for i in range(5):
    print("hello,world")
```

关于range()方法的其他讲解，会在下面进行。



## 容器遍历

### 字符串遍历

示例演示：

```
string = "hello,world"
for i in string:
    print("索引:{0:d},值:{1:s}".format(string.index(i), i))

# 索引:0,值:h
# 索引:1,值:e
# 索引:2,值:l
# 索引:2,值:l
# 索引:4,值:o
# 索引:5,值:,
# 索引:6,值:w
# 索引:4,值:o
# 索引:8,值:r
# 索引:2,值:l
# 索引:10,值:d
```



### 列表遍历

普通遍历：

```
li1 = [1, 2, 3, 4]
for i in li1:
    print(i)
```

通过enumerate()函数来同时遍历2个相同长度的列表：

```
li1 = ["A", "B", "C", "D"]
li2 = ["a", "b", "c", "d"]

for index, item in enumerate(li1):
    li1Message = str.format("li1 -> {0:d} -> {1:s}", index, item)
    print(li1Message)
    
    li2Message = str.format("li2 -> {0:d} -> {1:s}", index, li2[index])
    print(li2Message)
```

通过[::-1]来反向遍历列表：

```
li1 = ["A", "B", "C", "D"]
for i in li1[::-1]:
    print(i)
```

隔一个取一个的遍历列表：

```
li1 = ["A", "B", "C", "D"]
for i in li1[::2]:
    print(i)
```



### 字典遍历

普通的遍历只会遍历出key，这样的操作等同于遍历dict.keys()：

```
dic = {
    "k1": "v1",
    "k2": "v2",
    "k3": "v3",
}

for k in dic:
    print(k)

# k1
# k2
# k3

```

如果你想取出value，则可以遍历dict.values()：

```
dic = {
    "k1": "v1",
    "k2": "v2",
    "k3": "v3",
}

for v in dic.values():
    print(v)

# v1
# v2
# v3
```

如果你想同时取出key和value，则可以遍历dict.items():

```
dic = {
    "k1": "v1",
    "k2": "v2",
    "k3": "v3",
}

for k, v in dic.items():
    print(k, v)

# k1 v1
# k2 v2
# k3 v3
```



## 局部作用域

如果一个迭代变量的命名为i，那么这个迭代变量能在外部访问到吗？答案是能！

其实在Python2和Python3中，普通的for循环语句是没有局部作用域这一个说法的，希望在未来版本能有所改进。

```
for i in range(10):
    pass  # pass代表省略


print(i)
# 9
```

# 循环控制

## countinue

在while/for中均可以使用countinue跳过本次循环。

以下用for循环进行举例：

```
for i in range(5):
    if i == 3:
        continue
    else:
        print(i)
        
# 0
# 1
# 2
# 4
```



## break

在while/for中均可以使用break结束本层循环。

以下用for循环进行举例：

```
for i in range(5):
    if i == 3:
        break
    else:
        print(i)
        
# 0
# 1
# 2
```



# 循环嵌套

## while嵌套

while循环支持多层嵌套，在使用时注意下面的事项：

> 1. 如果是使用基于条件退出那么所有的while循环都必须遵循同一个条件才能退出。
> 2. break只针对当前的while循环体退出，对于非当前的while循环体不生效。
> 3. continue只针对当前while循环体跳过，对于非当前的while循环体不生效。

对于注意事项1的示例如下：

```
# 错误示范

tag1 = 1
tag2 = 2
while tag1 == 1:
    print("一层..")
    while tag2 == 2:
        print("    二层..")
        while tag2 == 2:
            print("        三层..")
            tag2 = 3  # 由于条件不同。只退出 第二层和第三层。

# ==== 执行结果 ====

"""
一层..
    二层..
        三层..
一层..
一层..
一层..
（无限打印）
"""

# ==============================================手动分割线==============================================

# 正确示范

tag3 = 3
while tag3:
    print("一层..")
    while tag3:
        print("    二层..")
        while tag3:
            print("        三层..")
            tag3 = False  # 可以看到全部退出了。

# ==== 执行结果 ====

"""
一层..
    二层..
        三层..
"""
```

对于注意事项2的示例如下，注意事项3同理：

```
# ==== 多层while循环基于break退出注意事项 ====

# 错误示范

tag1 = 1
tag2 = 2
while tag1 == 1:
    print("一层..")
    while tag2 == 2:
        print("    二层..")
        while tag2 == 2:
            print("        三层..")
            break  # 跳出三层。回到二层。执行三层。跳出三层。回到二层。执行三层。

# ==== 执行结果 ====

"""
一层..
    二层..
        三层..
    二层..
        三层..
    二层..
        三层..
    （无限打印）
"""

# ==============================================手动分割线==============================================

# 正确示范

tag3 = 3
while tag3:
    print("一层..")
    while tag3:
        print("    二层..")
        while tag3:
            print("        三层..")
            break  # 跳出三层
        break  # 跳出二层
    break  # 跳出一层

# ==== 执行结果 ====

"""
一层..
    二层..
        三层..
"""
```



## for嵌套

for循环同样支持嵌套。

外层执行1次，内层的for循环要全部循环完成才回到外层执行第2次。

```
li1 = ["a", "b"]
li2 = range(2)  # 0,1
for i in li1:
    print("============")
    print("外层循环")
    print(i)
    for j in li2:
        print("    内层循环")
        print("    ", j)

"""
============
外层循环
a
    内层循环
     0
    内层循环
     1
============
外层循环
b
    内层循环
     0
    内层循环
     1
"""
```

以下是使用for循环打印乘法表的例子：

```
for i in range(1, 10):
    for j in range(1, i+1):
        print("%d*%d=%d  " % (j, i, i*j), end="")
    print("")
    
# 1*1=1
# 1*2=2  2*2=4
# 1*3=3  2*3=6  3*3=9
# 1*4=4  2*4=8  3*4=12  4*4=16
# 1*5=5  2*5=10  3*5=15  4*5=20  5*5=25
# 1*6=6  2*6=12  3*6=18  4*6=24  5*6=30  6*6=36
# 1*7=7  2*7=14  3*7=21  4*7=28  5*7=35  6*7=42  7*7=49
# 1*8=8  2*8=16  3*8=24  4*8=32  5*8=40  6*8=48  7*8=56  8*8=64
# 1*9=9  2*9=18  3*9=27  4*9=36  5*9=45  6*9=54  7*9=63  8*9=72  9*9=81
```

# range()详解

## range()

range()方法在Python2中返回的是一个列表，而在Python3中返回的是一个可迭代对象（这种可迭代对象不会存值，而是惰性求值，类似于生成器）。

range()方法有三个参数，如下表所示：

| 参数介绍 | 描述         |
| -------- | ------------ |
| start    | 从几开始生成 |
| stop     | 生成到几结束 |
| step     | 步长间距     |

在使用range()进行生成时，需要注意顾头不顾尾。

如下所示：

```
li = list(range(1, 10, 2))
print(li)
# [1, 3, 5, 7, 9]
```



## xrange()

Python2中的xrange()与Python3中的range()相同，均返回可迭代对象，而非列表。

关于为什么做，其实是为了节省内存空间。

列表中的具体值会存在内存中，而如果是一个通过计算可惰性求值的可迭代对象，则不会消耗太大的内存，以下是自定义range()的实现。

```
class MyRange():
    def __init__(self, start, stop, step=0):
        self.start = start
        self.stop = stop
        self.step = step
        self.old = start  # 开始值

    def __iter__(self):
        return self

    def __next__(self):
        if self.old < self.stop:
            returnValue = self.old
            self.old += self.step  # 添加步长
            return returnValue
        else:
            self.old = self.start
            raise StopIteration # 被for捕捉，结束此次for循环


for i in MyRange(1, 10, 2):
    print(i)
```



# 实例练习

使用for循环打印三角形：

```
for i in range(1, 6):
    for j in range(1, 6 - i):
        print(" ", end="")
    for k in range(1, i + 1):
        print("* ", end="")
    print("")

#     * 
#    * * 
#   * * * 
#  * * * * 
# * * * * * 
```

有四个数字：1、2、3、4，能组成多少个互不相同且无重复数字的三位数？各是多少？

```
count = 0
for i in range(5):
    for j in range(1, 5):
        for k in range(1, 5):
            if (i != k) and (i != j) and (j != k):
                count += 1
                print(i, j, k)

print(count) # 36
```

斐波拉契数列是这样的一个数列：0、1、1、2、3、5、8、13、21、34、……

前2个值加起来的结果恰好等于第3个值，求一个长度为10的斐波拉契数列：

```
n = 10
fibArray = []

a , b = 0, 1
for i in range(n):
    fibArray.append(a)
    a, b = b, a + b
    
print(fibArray)

# [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]
```

输入2个数字，求2个数字的最小公倍数：

```
x = int(input(">>>"))
y = int(input(">>>"))
minCommonMultiple = None

if x > y:
    greater = y
else:
    greater = x

while 1:
    if ((greater % x == 0 ) and (greater % y == 0)):
        minCommonMultiple = greater
        break
    greater += 1

msg = str.format("{0}和{1}的最小公倍数为{2}", x, y, minCommonMultiple)
print(msg)
```

输入2个数字，求2个数字的最大公约数：

```
x = int(input(">>>"))
y = int(input(">>>"))
maxCommonDivisor = None

if x > y:
    smaller = y
else:
    smaller = x

for i in range(1, smaller + 1):
    if ((x % i == 0) and (y % i == 0)):
        maxCommonDivisor = i

msg = str.format("{0}和{1}的最大公约数为{2}", x, y, maxCommonDivisor)
print(msg)
```

