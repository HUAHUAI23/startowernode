# 执行流程

Redis事务可以一次执行多个命令， 并且带有以下三个重要的保证：

- 批量操作在发送EXEC命令前被放入队列缓存
- 收到EXEC命令后进入事务执行，事务中任意命令执行失败，其余的命令依然被执行
- 在事务执行过程，其他客户端提交的命令请求不会插入到事务执行命令序列中

一个事务从开始到执行会经历以下三个阶段：

- 开始事务
- 命令入队
- 执行事务

单个Redis命令的执行是原子性的，但Redis没有在事务上增加任何维持原子性的机制，所以Redis事务的执行并不是原子性的。

事务可以理解为一个打包的批量执行脚本，但批量指令并非原子化的操作，中间某条指令的失败不会导致前面已做指令的回滚，也不会造成后续的指令不做。



# 相关命令

以下是Redis事务中相关命令：

| 命令                | 描述                                                         |
| ------------------- | ------------------------------------------------------------ |
| MULTI               | 开启一组事务                                                 |
| EXEC                | 提交一组事务                                                 |
| DISCARD             | 取消一组事务                                                 |
| WATCH key [key ...] | 监视一个(或多个) key ，如果在事务执行之前这个(或这些) key 被其他命令所改动，那么事务将被打断。也就是说一旦监听成功，这个key则不允许被修改，直到UNWATCH |
| UNWATCH             | 取消 WATCH 命令对所有 key 的监视。                           |



# 操作演示

以下是Redis事务中的操作演示：

```
127.0.0.1:6379> MULTI
OK
127.0.0.1:6379> SET book-name "Mastering C++ in 21 days"
QUEUED
127.0.0.1:6379> GET book-name
QUEUED
127.0.0.1:6379> SADD tag "C++" "Programming" "Mastering Series"
QUEUED
127.0.0.1:6379> SMEMBERS tag
QUEUED
127.0.0.1:6379> EXEC
1) OK
2) "Mastering C++ in 21 days"
3) (integer) 3
4) 1) "Mastering Series"
   2) "C++"
   3) "Programming"
```