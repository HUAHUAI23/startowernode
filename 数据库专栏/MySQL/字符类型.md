# 字符类型

## 基本介绍

MySQL中提供了多种字符串类型，我们可以依据它们不同的特性来选择合适的类型进行数据存储，大多数情况下CHAR和VARCHAR是最常用的。

| 类型       | 最大存储字符数        | 用途                            |
| :--------- | :-------------------- | :------------------------------ |
| CHAR       | 0 - 255字符           | 定长字符串                      |
| VARCHAR    | 0 - 65535字符         | 变长字符串                      |
| TINYBLOB   | 0 - 255字符           | 不超过 255 个字符的二进制字符串 |
| TINYTEXT   | 0 - 255字符           | 短文本字符串                    |
| BLOB       | 0 - 65 535字符        | 二进制形式的长文本数据          |
| TEXT       | 0 - 65 535字符        | 长文本数据                      |
| MEDIUMBLOB | 0 - 16 777 215字符    | 二进制形式的中等长度文本数据    |
| MEDIUMTEXT | 0 - 16 777 215字符    | 中等长度文本数据                |
| LONGBLOB   | 0 - 4 294 967 295字符 | 二进制形式的极大文本数据        |
| LONGTEXT   | 0 - 4 294 967 295字符 | 极大文本数据                    |

## 字符宽度

与数值类型不同，对于字符类型而言，其指定宽度均为存入宽度而非显示宽度，且以字符为单位，同时字符宽度的设定是必须的：

```
CREATE TABLE db1.temp(
    id INT PRIMARY KEY AUTO_INCREMENT COMMENT "主键",
    ch CHAR(4) NOT NULL COMMENT "定长字符串",
    vc VARCHAR(4) NOT NULL COMMENT "变长字符串"
) ENGINE innodb CHARSET utf8mb4 COLLATE utf8mb4_general_ci;
```

# 定长变长

## 区别差异

CHAR类型为定长字符串，存入的字符长度不足其指定宽度时，将会使用空字符进行填充。

VARCHAR类型为变长字符串，存入的字符长度不足其指定宽度时，不会使用空字符进行填充。

如果CHAR和VARCHAR的字符宽度相同，且都建立了索引，那么VARCHAR类型INDEX的key_len会比CHAR类型INDEX的key_len多出2个Bytes，它标识了可变字符的开始位和结束位。

- 通常情况下来讲，CHAR类型存取速度要比VARCHAR高约50%，但是更加浪费磁盘空间
- 在InnoDB存储引擎中，不存在这种差异
- 建议在同一张数据表中统一使用VARCHAR或CHAR类型，这里更推荐使用CHAR类型

CHAR类型的详细概述：

```
特点概述：
	定长，简单粗暴，浪费空间，存取速度快
	
字符个数：
	0-255（一个中文是一个字符，是utf8编码的3个字节，utf8mb4编码的4个字节）
	
存储特点：
	存储CHAR类型的值时，会往右填充空格来满足长度
	
存储举例：
	指定长度为10，存>10个字符则报错，存<10个字符则用空格填充直到凑够10个字符存储
	
检索：
	在检索或者说查询时，查出的结果会自动删除尾部的空格，除非我们打开pad_char_to_full_length SQL模式(SET sql_mode = "PAD_CHAR_TO_FULL_LENGTH");
```

VARCHAR类型的详细概述：

```
特点概述：
	变长，精准，节省空间，存取速度慢
	
字符个数：
	0-65535，如果大于16383会提示用其他类型，如BLOB和TEXT，因为VARCHAR并不适合存储长文本数据。
	
存储特点：
	 VARCHAR类型存储数据的真实内容，不会用空格填充，如果'ab  ',尾部的空格也会被存起来。
	 此外，由于MySQL单行最大限制为65535字节，所以VARCHAR类型会在真实数据前加1-2Bytes的前缀，该前缀用来表示真实数据的bytes字节数。

存储举例：
	 如果真实的数据<255bytes则需要1Bytes的前缀（1Bytes=8bit 2**8最大表示的数字为255）
     如果真实的数据>255bytes则需要2Bytes的前缀（2Bytes=16bit 2**16最大表示的数字为65535）
	即VARCHAR类型最多存储65535个字符。
	
检索：
	如果数据的尾部有空格，那么VARCHAR会保存下来，在检索或者说查询时，也会正常显示包含空格在内的内容
```



## 差异对比

下面是CHAR和VARCHAR在PAD_CHAR_TO_FULL_LENGTH模式下对同一个值存储时的差异对比：

- 注意：PAD_CHAR_TO_FULL_LENGTH模式下如果存储的值大于存储长度的限制，那么它不会抛出异常，而是将值截取后进行存储

如下表所示：

| **插入值** | **CHAR(4)存入值** | **CHAR(4)占据空间** | **VARCHAR(4)存入值** | **VARCHAR(4)占据空间** |
| :--------: | :---------------: | :-----------------: | :------------------: | :--------------------: |
|     ''     |        ' '        |       4 bytes       |         ' '          |        1 bytes         |
|    'ab'    |       'ab '       |       4 bytes       |         'ab'         |        3 bytes         |
|   'abcd'   |      'abcd'       |       4 bytes       |        'abcd'        |        5 bytes         |
| 'abcdefgh' |      'abcd'       |       4 bytes       |        'abcd'        |        5 bytes         |

由于VARCHAR是变长存储，所以需要一个头部标识来表示真实内容究竟占据多少字符，这个头部标识通常占据1-2个字节的存储空间。

存入abcd，VARCHAR(4)需要算上头部标识，即最小占用5字节。而CHAR(4)则仅占用4字节。

若想验证上述的结果，需要使用1个函数与执行计划explain来完成对比：

- LENGTH()：查看字符占用的字节长度
- 补充点：CHAR_LENGTH()可用于查看字符占用的字符长度

示例如下：

```
# 修改模式：使其查看定长字符类型时不会将填充空格移除，且在存储大于存储长度的限制的值是不会抛出异常，而是截取存入

SET sql_mode = 'PAD_CHAR_TO_FULL_LENGTH';
   
--
# 创建数据表

CREATE TABLE temp(
    id INT PRIMARY KEY AUTO_INCREMENT COMMENT "主键",
    ch CHAR(4) NOT NULL COMMENT "定长字符串",
    vc VARCHAR(4) NOT NULL COMMENT "变长字符串"
) ENGINE innodb CHARSET utf8mb4 COLLATE utf8mb4_general_ci;
   
--
# 插入数据

INSERT INTO
    temp(ch, vc)
VALUES
    ("", ""),
    ("ab", "ab"),
    ("abcd", "abcd"),
    ("abcdefg", "abcdefg");
   
--
# 查看数据的字节长度对比情况
# 注意！对于VARCHAR类型来说，它并不会统计头部信息，所以我们需要在原本的基础上+1或者2个bytes单位，因为这里的数据是abcd，共占用4个Bytes，故+1即可

SELECT
    LENGTH(ch) AS "占用字节数CHAR",
    LENGTH(vc) + 1 AS "占用字节数VARCHAR"
FROM
    temp;

+---------------------+------------------------+
| 占用字节数CHAR      | 占用字节数VARCHAR      |
+---------------------+------------------------+
|                   4 |                      1 |
|                   4 |                      3 |
|                   4 |                      5 |
|                   4 |                      5 |
+---------------------+------------------------+
```

下面我们将演示使用执行计划获取VARCHAR类型INDEX的key_len长度，它应该会比CHAR类型INDEX的key_len长度多2个Bytes：

```
# 添加索引

ALTER TABLE temp ADD INDEX cidx(ch);
ALTER TABLE temp ADD INDEX vidx(vc);

--
# 查看索引覆盖情况

# 使用执行计划可以看见ch索引长度key_len是16个字节。utf8mb4下4*4=16
EXPLAIN SELECT ch FROM temp;
+----+-------------+-------+------------+-------+---------------+------+---------+------+------+----------+-------------+
| id | select_type | table | partitions | type  | possible_keys | key  | key_len | ref  | rows | filtered | Extra       |
+----+-------------+-------+------------+-------+---------------+------+---------+------+------+----------+-------------+
|  1 | SIMPLE      | temp  | NULL       | index | NULL          | cidx | 16      | NULL |    4 |   100.00 | Using index |
+----+-------------+-------+------------+-------+---------------+------+---------+------+------+----------+-------------+

# 使用执行计划可以看见vc的key_len是18个字节。这是因为除了utf8mb4下4*4=16之外，还需要加上开始和结束位置，占2字节
EXPLAIN SELECT vc FROM temp;
+----+-------------+-------+------------+-------+---------------+------+---------+------+------+----------+-------------+
| id | select_type | table | partitions | type  | possible_keys | key  | key_len | ref  | rows | filtered | Extra       |
+----+-------------+-------+------------+-------+---------------+------+---------+------+------+----------+-------------+
|  1 | SIMPLE      | temp  | NULL       | index | NULL          | vidx | 18      | NULL |    4 |   100.00 | Using index |
+----+-------------+-------+------------+-------+---------------+------+---------+------+------+----------+-------------+
```



# 常用函数

## 大小写转换

UPPER()函数功能是小写转大写。

LOWER()函数功能是大写转小写。

```
> SELECT UPPER("mysql"), LOWER("MYSQL");
+----------------+----------------+
| UPPER("mysql") | LOWER("MYSQL") |
+----------------+----------------+
| MYSQL          | mysql          |
+----------------+----------------+
```



## 字符替换

REPLACE()函数可以将指定字符的子串替换为新的子串，如下示例将google替换成biying：

```
> SELECT REPLACE("www.google.com", "google", "biying");
+-----------------------------------------------+
| REPLACE("www.google.com", "google", "biying") |
+-----------------------------------------------+
| www.biying.com                                |
+-----------------------------------------------+
```



## 指定量取

LEFT()函数是从左往右取指定数量的字符。

RIGHT()函数是从右往左取指定数量的字符。

```
> SELECT LEFT("ABCDE",3), RIGHT("ABCDE",3);
+-----------------+------------------+
| LEFT("ABCDE",3) | RIGHT("ABCDE",3) |
+-----------------+------------------+
| ABC             | CDE              |
+-----------------+------------------+
```

## 中间字符

MID()函数从中间取字符。

参数2为指定起始位置，默认从1开始。

参数3为指定取出的字符数量，默认一直取完。

```
> SELECT MID("ABCDE",2,2);
+------------------+
| MID("ABCDE",2,2) |
+------------------+
| BC               |
+------------------+
```

## 截取子串

SUBSTRING()函数从指定起始位置开始取出像右的指定字符。

参数2为指定起始位置，默认从1开始。

参数3为指定取出的字符数量，默认一直取完。

感觉它和MID()函数没啥大区别：

```
M > SELECT SUBSTRING("ABCDE",2,2);
+------------------------+
| SUBSTRING("ABCDE",2,2) |
+------------------------+
| BC                     |
+------------------------+
```



## 字符长度

CHAR_LENGTH()函数可获取字符长度，如果想要获取`CHAR`类型的字符长度且包括空白填充字符时需要修改SQL模式：

```
# 修改SQL模式
SET sql_mode = 'PAD_CHAR_TO_FULL_LENGTH';
```

函数示例演示：

```
> SELECT CHAR_LENGTH("ABCDE");
+----------------------+
| CHAR_LENGTH("ABCDE") |
+----------------------+
|                    5 |
+----------------------+
```

## 字节长度

LENGTH()函数可获取字节长度，如果想要获取`CHAR`类型的字节长度且包括空白填充字符时需要修改SQL模式：

```
# 修改SQL模式
SET sql_mode = 'PAD_CHAR_TO_FULL_LENGTH';
```

函数示例演示：

```
> SELECT LENGTH("ABCDE");
+-----------------+
| LENGTH("ABCDE") |
+-----------------+
|               5 |
+-----------------+
```

## 字符连接

CONCAT()和CONCAT_WS()函数可将多段字符进行连接。

- CONCAT()：可将查询结果与任意字符串进行拼接
- CONCAT_WS()：可指定连接符进行拼接，第1个参数是连接符

它们的作用不仅局限于此，还有更多的妙用，我们将在元信息获取一章节中进行介绍，下面是它们的基本使用案例：

```
> SELECT CONCAT("A", "-", "B", "-", "C");
+---------------------------------+
| CONCAT("A", "-", "B", "-", "C") |
+---------------------------------+
| A-B-C                           |
+---------------------------------+

> SELECT CONCAT_WS("-", "A", "B", "C");
+-------------------------------+
| CONCAT_WS("-", "A", "B", "C") |
+-------------------------------+
| A-B-C                         |
+-------------------------------+
```